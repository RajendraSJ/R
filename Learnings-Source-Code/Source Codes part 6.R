library(lobstr)
library(lubridate)
library(MASS)
library(methods)
library(microbenchmark)

library(lobstr)
ast
list(`package:lobstr` = function (x) 
{
  expr <- enexpr(x)
  new_raw(ast_tree(expr))
}, function (x) 
{
  expr <- enexpr(x)
  new_raw(ast_tree(expr))
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
cst
list(`package:lobstr` = function () 
{
  x <- rlang::trace_back(globalenv())
  print(x, simplify = "none")
  invisible()
}, function () 
{
  x <- rlang::trace_back(globalenv())
  print(x, simplify = "none")
  invisible()
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
mem_used
list(`package:lobstr` = function () 
{
  new_bytes(sum(gc()[, 1] * c(node_size(), 8)))
}, function () 
{
  new_bytes(sum(gc()[, 1] * c(node_size(), 8)))
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
obj_addr
list(`package:lobstr` = function (x) 
{
  x <- enquo(x)
  addr <- obj_addr_(quo_get_expr(x), quo_get_env(x))
  if (is_testing()) {
    test_addr_get(addr)
  }
  else {
    addr
  }
}, function (x) 
{
  x <- enquo(x)
  addr <- obj_addr_(quo_get_expr(x), quo_get_env(x))
  if (is_testing()) {
    test_addr_get(addr)
  }
  else {
    addr
  }
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
obj_addrs
list(`package:lobstr` = function (x) 
{
  addrs <- obj_addrs_(x)
  if (is_testing()) {
    vapply(addrs, test_addr_get, character(1), USE.NAMES = FALSE)
  }
  else {
    addrs
  }
}, function (x) 
{
  addrs <- obj_addrs_(x)
  if (is_testing()) {
    vapply(addrs, test_addr_get, character(1), USE.NAMES = FALSE)
  }
  else {
    addrs
  }
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
obj_size
list(`package:lobstr` = function (..., env = parent.frame()) 
{
  dots <- list2(...)
  size <- obj_size_(dots, env, size_node(), size_vector())
  new_bytes(size)
}, function (..., env = parent.frame()) 
{
  dots <- list2(...)
  size <- obj_size_(dots, env, size_node(), size_vector())
  new_bytes(size)
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
obj_sizes
list(`package:lobstr` = function (..., env = parent.frame()) 
{
  dots <- list2(...)
  size <- obj_csize_(dots, env, size_node(), size_vector())
  names(size) <- names(dots)
  new_bytes(size)
}, function (..., env = parent.frame()) 
{
  dots <- list2(...)
  size <- obj_csize_(dots, env, size_node(), size_vector())
  names(size) <- names(dots)
  new_bytes(size)
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
ref
list(`package:lobstr` = function (..., character = FALSE) 
{
  x <- list(...)
  seen <- child_env(emptyenv(), `__next_id` = 1)
  out <- lapply(x, ref_tree, character = character, seen = seen)
  n <- length(x)
  if (n > 1) {
    out[-n] <- lapply(out[-n], function(x) c(x, ""))
  }
  new_raw(unlist(out))
}, function (..., character = FALSE) 
{
  x <- list(...)
  seen <- child_env(emptyenv(), `__next_id` = 1)
  out <- lapply(x, ref_tree, character = character, seen = seen)
  n <- length(x)
  if (n > 1) {
    out[-n] <- lapply(out[-n], function(x) c(x, ""))
  }
  new_raw(unlist(out))
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
sxp
list(`package:lobstr` = function (x, expand = character(), max_depth = 5) 
{
  opts <- c("character", "altrep", "environment", "call", "bytecode")
  if (any(!expand %in% opts)) {
    abort("`expand` must contain only values from ", paste("'", opts, "'", collapse = ","))
  }
  obj_inspect_(x, max_depth - 1, opts[[1]] %in% expand, opts[[2]] %in% expand, opts[[3]] %in% expand, opts[[4]] %in% expand, opts[[5]] %in% expand)
}, function (x, expand = character(), max_depth = 5) 
{
  opts <- c("character", "altrep", "environment", "call", "bytecode")
  if (any(!expand %in% opts)) {
    abort("`expand` must contain only values from ", paste("'", opts, "'", collapse = ","))
  }
  obj_inspect_(x, max_depth - 1, opts[[1]] %in% expand, opts[[2]] %in% expand, opts[[3]] %in% expand, opts[[4]] %in% expand, opts[[5]] %in% expand)
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)
tree
list(`package:lobstr` = function (x, ..., index_unnamed = FALSE, max_depth = 10, max_length = 1000, show_environments = TRUE, hide_scalar_types = TRUE, val_printer = crayon::blue, class_printer = crayon::silver, show_attributes = FALSE, remove_newlines = TRUE, tree_chars = box_chars()) 
{
  rlang::check_dots_empty()
  termination_type <- tree_internal(x, opts = list(index_unnamed = index_unnamed, max_depth = max_depth, max_length = max_length, show_envs = show_environments, hide_scalar_types = hide_scalar_types, val_printer = val_printer, class_printer = class_printer, show_attributes = show_attributes, remove_newlines = remove_newlines, tree_chars = tree_chars))
  if (termination_type == "early") {
    cat("...", "\n")
  }
  invisible(x)
}, function (data, root = data[[1]][[1]], style = NULL, width = console_width(), trim = FALSE) 
{
  stopifnot(is.data.frame(data), ncol(data) >= 2, is_string(root), is.null(style) || (is_tree_style(style)), is_count(width))
  style <- style %||% box_chars()
  labels <- if (ncol(data) >= 3) 
    data[[3]]
  else data[[1]]
  trimlabs <- data[["trimmed"]] %||% labels
  seen <- character()
  res <- character()
  pt <- function(root, n = integer(), mx = integer(), used = character()) {
    num_root <- match(root, data[[1]])
    if (is.na(num_root)) 
      return()
    level <- length(n) - 1
    prefix <- vcapply(seq_along(n), function(i) {
      if (n[i] < mx[i]) {
        if (i == length(n)) {
          paste0(style$j, style$h)
        }
        else {
          paste0(style$v, " ")
        }
      }
      else if (n[i] == mx[i] && i == length(n)) {
        paste0(style$l, style$h)
      }
      else {
        "  "
      }
    })
    root_seen <- root %in% seen
    root_lab <- if (trim && root_seen) 
      trimlabs[[num_root]]
    else labels[[num_root]]
    res <<- c(res, paste0(paste(prefix, collapse = ""), root_lab))
    if (!trim && root %in% used) {
      warning(call. = FALSE, "Endless loop found in tree: ", paste0(c(used, root), collapse = " -> "))
    }
    else if (!trim || !root_seen) {
      seen <<- c(seen, root)
      children <- data[[2]][[num_root]]
      for (d in seq_along(children)) {
        pt(children[[d]], c(n, d), c(mx, length(children)), c(used, root))
      }
    }
  }
  if (nrow(data)) 
    pt(root)
  res <- ansi_substr(res, 1, width)
  class(res) <- unique(c("cli_tree", "tree", class(res), "character"))
  res
}, function (x, ..., index_unnamed = FALSE, max_depth = 10, max_length = 1000, show_environments = TRUE, hide_scalar_types = TRUE, val_printer = crayon::blue, class_printer = crayon::silver, show_attributes = FALSE, remove_newlines = TRUE, tree_chars = box_chars()) 
{
  rlang::check_dots_empty()
  termination_type <- tree_internal(x, opts = list(index_unnamed = index_unnamed, max_depth = max_depth, max_length = max_length, show_envs = show_environments, hide_scalar_types = hide_scalar_types, val_printer = val_printer, class_printer = class_printer, show_attributes = show_attributes, remove_newlines = remove_newlines, tree_chars = tree_chars))
  if (termination_type == "early") {
    cat("...", "\n")
  }
  invisible(x)
})
c("package:lobstr", "namespace:cli", "namespace:lobstr")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
tree_label
list(`package:lobstr` = function (x, opts) 
{
  UseMethod("tree_label")
}, function (x, opts) 
{
  UseMethod("tree_label")
})
c("package:lobstr", "namespace:lobstr")
c(TRUE, FALSE)
c(FALSE, TRUE)


##################################################################################################
library(lubridate)
%--%
  list(`package:lubridate` = function (start, end) 
    interval(start, end), function (start, end) 
      interval(start, end))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
%m-%
  list(`package:lubridate` = new("standardGeneric", .Data = function (e1, e2) 
    standardGeneric("%m-%"), generic = "%m-%", package = "lubridate", group = list(), valueClass = character(0), signature = c("e1", "e2"), default = new("derivedDefaultMethod", .Data = function (e1, e2) 
      standardGeneric("%m-%"), target = new("signature", .Data = "ANY", names = "e1", package = "methods"), defined = new("signature", .Data = "ANY", names = "e1", package = "methods"), generic = "%m-%"), skeleton = (new("derivedDefaultMethod", .Data = function (e1, e2) 
        standardGeneric("%m-%"), target = new("signature", .Data = "ANY", names = "e1", package = "methods"), defined = new("signature", .Data = "ANY", names = "e1", package = "methods"), generic = "%m-%"))(e1, e2)), new("standardGeneric", .Data = function (e1, e2) 
          standardGeneric("%m-%"), generic = "%m-%", package = "lubridate", group = list(), valueClass = character(0), signature = c("e1", "e2"), default = new("derivedDefaultMethod", .Data = function (e1, e2) 
            standardGeneric("%m-%"), target = new("signature", .Data = "ANY", names = "e1", package = "methods"), defined = new("signature", .Data = "ANY", names = "e1", package = "methods"), generic = "%m-%"), skeleton = (new("derivedDefaultMethod", .Data = function (e1, e2) 
              standardGeneric("%m-%"), target = new("signature", .Data = "ANY", names = "e1", package = "methods"), defined = new("signature", .Data = "ANY", names = "e1", package = "methods"), generic = "%m-%"))(e1, e2)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
%m+%
  list(`package:lubridate` = new("standardGeneric", .Data = function (e1, e2) 
    standardGeneric("%m+%"), generic = "%m+%", package = "lubridate", group = list(), valueClass = character(0), signature = c("e1", "e2"), default = new("derivedDefaultMethod", .Data = function (e1, e2) 
      standardGeneric("%m+%"), target = new("signature", .Data = "ANY", names = "e1", package = "methods"), defined = new("signature", .Data = "ANY", names = "e1", package = "methods"), generic = "%m+%"), skeleton = (new("derivedDefaultMethod", .Data = function (e1, e2) 
        standardGeneric("%m+%"), target = new("signature", .Data = "ANY", names = "e1", package = "methods"), defined = new("signature", .Data = "ANY", names = "e1", package = "methods"), generic = "%m+%"))(e1, e2)), new("standardGeneric", .Data = function (e1, e2) 
          standardGeneric("%m+%"), generic = "%m+%", package = "lubridate", group = list(), valueClass = character(0), signature = c("e1", "e2"), default = new("derivedDefaultMethod", .Data = function (e1, e2) 
            standardGeneric("%m+%"), target = new("signature", .Data = "ANY", names = "e1", package = "methods"), defined = new("signature", .Data = "ANY", names = "e1", package = "methods"), generic = "%m+%"), skeleton = (new("derivedDefaultMethod", .Data = function (e1, e2) 
              standardGeneric("%m+%"), target = new("signature", .Data = "ANY", names = "e1", package = "methods"), defined = new("signature", .Data = "ANY", names = "e1", package = "methods"), generic = "%m+%"))(e1, e2)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
%within%
  list(`package:lubridate` = new("standardGeneric", .Data = function (a, b) 
    standardGeneric("%within%"), generic = "%within%", package = "lubridate", group = list(), valueClass = character(0), signature = c("a", "b"), default = new("derivedDefaultMethod", .Data = function (a, b) 
    {
      stop(sprintf("No %%within%% method with signature a = %s,  b = %s", class(a)[[1]], class(b)[[1]]))
    }, target = new("signature", .Data = "ANY", names = "a", package = "methods"), defined = new("signature", .Data = "ANY", names = "a", package = "methods"), generic = "%within%"), skeleton = (new("derivedDefaultMethod", .Data = function (a, b) 
    {
      stop(sprintf("No %%within%% method with signature a = %s,  b = %s", class(a)[[1]], class(b)[[1]]))
    }, target = new("signature", .Data = "ANY", names = "a", package = "methods"), defined = new("signature", .Data = "ANY", names = "a", package = "methods"), generic = "%within%"))(a, b)), new("standardGeneric", .Data = function (a, b) 
      standardGeneric("%within%"), generic = "%within%", package = "lubridate", group = list(), valueClass = character(0), signature = c("a", "b"), default = new("derivedDefaultMethod", .Data = function (a, b) 
      {
        stop(sprintf("No %%within%% method with signature a = %s,  b = %s", class(a)[[1]], class(b)[[1]]))
      }, target = new("signature", .Data = "ANY", names = "a", package = "methods"), defined = new("signature", .Data = "ANY", names = "a", package = "methods"), generic = "%within%"), skeleton = (new("derivedDefaultMethod", .Data = function (a, b) 
      {
        stop(sprintf("No %%within%% method with signature a = %s,  b = %s", class(a)[[1]], class(b)[[1]]))
      }, target = new("signature", .Data = "ANY", names = "a", package = "methods"), defined = new("signature", .Data = "ANY", names = "a", package = "methods"), generic = "%within%"))(a, b)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__Duration
list(`package:lubridate` = new("classRepresentation", slots = list(.Data = "numeric"), contains = list(Timespan = new("SClassExtension", subClass = "Duration", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "Timespan")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Duration"), "Timespan", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "Duration", superClass = "numeric", package = "lubridate", coerce = function (from, strict = TRUE) 
    {
      attributes(from) <- NULL
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.Data <- as(value, "numeric", strict = FALSE)
        from
      }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "Duration", superClass = "vector", package = "lubridate", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "numeric", TRUE)
          as(.value, "vector") <- value
          value <- .value
          {
            from@.Data <- as(value, "numeric", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = getClass("S4")@prototype, validity = function (object) 
        {
          if (is.numeric(object@.Data)) 
            TRUE
          else "Duration value is not a number. Should be numeric."
        }, access = list(), className = "Duration", package = "lubridate", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "numeric"), contains = list(Timespan = new("SClassExtension", subClass = "Duration", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "Timespan")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Duration"), "Timespan", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "Duration", superClass = "numeric", package = "lubridate", coerce = function (from, strict = TRUE) 
            {
              attributes(from) <- NULL
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                from@.Data <- as(value, "numeric", strict = FALSE)
                from
              }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "Duration", superClass = "vector", package = "lubridate", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "numeric", TRUE)
                  as(.value, "vector") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "numeric", strict = FALSE)
                    from
                  }
                }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = getClass("S4")@prototype, validity = function (object) 
                {
                  if (is.numeric(object@.Data)) 
                    TRUE
                  else "Duration value is not a number. Should be numeric."
                }, access = list(), className = "Duration", package = "lubridate", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__Interval
list(`package:lubridate` = new("classRepresentation", slots = list(.Data = "numeric", start = "POSIXct", tzone = "character"), contains = list(Timespan = new("SClassExtension", subClass = "Interval", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "Timespan")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Interval"), "Timespan", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "Interval", superClass = "numeric", package = "lubridate", coerce = function (from, strict = TRUE) 
    {
      attributes(from) <- NULL
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.Data <- as(value, "numeric", strict = FALSE)
        from
      }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "Interval", superClass = "vector", package = "lubridate", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "numeric", TRUE)
          as(.value, "vector") <- value
          value <- .value
          {
            from@.Data <- as(value, "numeric", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = function (object) 
        {
          errors <- character()
          if (!is.numeric(object@.Data)) {
            msg <- "Span length must be numeric."
            errors <- c(errors, msg)
          }
          if (!is(object@start, "POSIXct")) {
            msg <- "Start date must be in POSIXct format."
            errors <- c(errors, msg)
          }
          if (length(object@.Data) != length(object@start)) {
            msg <- paste("Inconsistent lengths: spans = ", length(object@.Data), ", start dates = ", length(object@start), sep = "")
            errors <- c(errors, msg)
          }
          if (length(errors) == 0) 
            TRUE
          else errors
        }, access = list(), className = "Interval", package = "lubridate", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "numeric", start = "POSIXct", tzone = "character"), contains = list(Timespan = new("SClassExtension", subClass = "Interval", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "Timespan")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Interval"), "Timespan", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "Interval", superClass = "numeric", package = "lubridate", coerce = function (from, strict = TRUE) 
            {
              attributes(from) <- NULL
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                from@.Data <- as(value, "numeric", strict = FALSE)
                from
              }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "Interval", superClass = "vector", package = "lubridate", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "numeric", TRUE)
                  as(.value, "vector") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "numeric", strict = FALSE)
                    from
                  }
                }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = function (object) 
                {
                  errors <- character()
                  if (!is.numeric(object@.Data)) {
                    msg <- "Span length must be numeric."
                    errors <- c(errors, msg)
                  }
                  if (!is(object@start, "POSIXct")) {
                    msg <- "Start date must be in POSIXct format."
                    errors <- c(errors, msg)
                  }
                  if (length(object@.Data) != length(object@start)) {
                    msg <- paste("Inconsistent lengths: spans = ", length(object@.Data), ", start dates = ", length(object@start), sep = "")
                    errors <- c(errors, msg)
                  }
                  if (length(errors) == 0) 
                    TRUE
                  else errors
                }, access = list(), className = "Interval", package = "lubridate", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__Period
list(`package:lubridate` = new("classRepresentation", slots = list(.Data = "numeric", year = "numeric", month = "numeric", day = "numeric", hour = "numeric", minute = "numeric"), contains = list(Timespan = new("SClassExtension", subClass = "Period", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "Timespan")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Period"), "Timespan", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "Period", superClass = "numeric", package = "lubridate", coerce = function (from, strict = TRUE) 
    {
      attributes(from) <- NULL
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.Data <- as(value, "numeric", strict = FALSE)
        from
      }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "Period", superClass = "vector", package = "lubridate", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "numeric", TRUE)
          as(.value, "vector") <- value
          value <- .value
          {
            from@.Data <- as(value, "numeric", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = function (object) 
        {
          errors <- character()
          n <- length(object@.Data)
          lengths <- c(length(object@year), length(object@month), length(object@day), length(object@hour), length(object@minute))
          if (any(lengths != n)) {
            msg <- paste("Inconsistent lengths: year = ", lengths[1], ", month = ", lengths[2], ", day = ", lengths[3], ", hour = ", lengths[4], ", minute = ", lengths[5], ", second = ", n, sep = "")
            errors <- c(errors, msg)
          }
          values <- c(object@year, object@month, object@day, object@hour, object@minute)
          values <- na.omit(values)
          if (sum(values - trunc(values))) {
            msg <- "periods must have integer values"
            errors <- c(errors, msg)
          }
          if (length(errors) == 0) 
            TRUE
          else errors
        }, access = list(), className = "Period", package = "lubridate", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "numeric", year = "numeric", month = "numeric", day = "numeric", hour = "numeric", minute = "numeric"), contains = list(Timespan = new("SClassExtension", subClass = "Period", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "Timespan")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Period"), "Timespan", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "Period", superClass = "numeric", package = "lubridate", coerce = function (from, strict = TRUE) 
            {
              attributes(from) <- NULL
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                from@.Data <- as(value, "numeric", strict = FALSE)
                from
              }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "Period", superClass = "vector", package = "lubridate", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "numeric", TRUE)
                  as(.value, "vector") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "numeric", strict = FALSE)
                    from
                  }
                }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = function (object) 
                {
                  errors <- character()
                  n <- length(object@.Data)
                  lengths <- c(length(object@year), length(object@month), length(object@day), length(object@hour), length(object@minute))
                  if (any(lengths != n)) {
                    msg <- paste("Inconsistent lengths: year = ", lengths[1], ", month = ", lengths[2], ", day = ", lengths[3], ", hour = ", lengths[4], ", minute = ", lengths[5], ", second = ", n, sep = "")
                    errors <- c(errors, msg)
                  }
                  values <- c(object@year, object@month, object@day, object@hour, object@minute)
                  values <- na.omit(values)
                  if (sum(values - trunc(values))) {
                    msg <- "periods must have integer values"
                    errors <- c(errors, msg)
                  }
                  if (length(errors) == 0) 
                    TRUE
                  else errors
                }, access = list(), className = "Period", package = "lubridate", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__Timespan
list(`package:lubridate` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = new("Interval", .Data = numeric(0), start = <S4 object of class NULL>, tzone = character(0)), validity = NULL, access = list(), className = "Timespan", package = "lubridate", subclasses = list(Interval = new("SClassExtension", subClass = "Interval", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "Timespan")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Interval"), "Timespan", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), Duration = new("SClassExtension", subClass = "Duration", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "Timespan")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Duration"), "Timespan", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), Period = new("SClassExtension", subClass = "Period", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "Timespan")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Period"), "Timespan", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = new("Interval", .Data = numeric(0), start = <S4 object of class NULL>, tzone = character(0)), validity = NULL, access = list(), className = "Timespan", package = "lubridate", subclasses = list(Interval = new("SClassExtension", subClass = "Interval", superClass = "Timespan", package = "lubridate", 
                                                                                                                                                                                                                                                                                                                                                                                                                                             coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                               from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                   if (!is(value, "Timespan")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                     stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Interval"), "Timespan", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), Duration = new("SClassExtension", subClass = "Duration", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                   from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is(value, "Timespan")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                         stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Duration"), "Timespan", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), Period = new("SClassExtension", subClass = "Period", superClass = "Timespan", package = "lubridate", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                           if (!is(value, "Timespan")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                             stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "Timespan", dQuote("Period"), "Timespan", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__-:base
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__$:base
list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>, <environment>)
c("package:lubridate", "package:methods", "namespace:Rcpp", "namespace:lubridate", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE, TRUE)
.__T__$<-:base
list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
.__T__%%:base
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__%/%:base
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__%m-%:lubridate
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__%m+%:lubridate
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__%within%:lubridate
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__*:base
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__/:base
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__[:base
       list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
       c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
       c(TRUE, TRUE, FALSE, FALSE)
       c(FALSE, FALSE, TRUE, TRUE)
       .__T__[[:base
               list(`package:lubridate` = <environment>, <environment>)
               c("package:lubridate", "namespace:lubridate")
               c(TRUE, FALSE)
               c(FALSE, TRUE)
               .__T__[[<-:base
                       list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
                       c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
                       c(TRUE, TRUE, FALSE, FALSE)
                       c(FALSE, FALSE, TRUE, TRUE)
                       .__T__[<-:base
                              list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
                              c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
                              c(TRUE, TRUE, FALSE, FALSE)
                              c(FALSE, FALSE, TRUE, TRUE)
                              .__T__+:base
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__Arith:base
                              list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
                              c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
                              c(TRUE, TRUE, FALSE, FALSE)
                              c(FALSE, FALSE, TRUE, TRUE)
                              .__T__as.character:base
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__as.difftime:base
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__as.duration:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__as.interval:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__as.numeric:base
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__as.period:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__as_date:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__as_datetime:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__c:base
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__Compare:methods
                              list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
                              c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
                              c(TRUE, TRUE, FALSE, FALSE)
                              c(FALSE, FALSE, TRUE, TRUE)
                              .__T__date<-:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__day<-:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__format_ISO8601:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__hour<-:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__minute<-:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
                              c("package:lubridate", "namespace:lubridate")
                              c(TRUE, FALSE)
                              c(FALSE, TRUE)
                              .__T__month<-:lubridate
                              list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__qday<-:lubridate
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__reclass_timespan:lubridate
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__rep:base
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__second<-:lubridate
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__show:methods
list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>, <environment>)
c("package:lubridate", "package:methods", "namespace:Rcpp", "namespace:lubridate", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE, TRUE)
.__T__time_length:lubridate
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__year<-:lubridate
list(`package:lubridate` = <environment>, <environment>)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
.Depends
list(`package:MASS` = c("grDevices", "graphics", "stats", "utils"), `package:lubridate` = "methods")
c("package:MASS", "package:lubridate")
c(TRUE, TRUE)
c(FALSE, FALSE)
add_with_rollback
list(`package:lubridate` = function (e1, e2, roll_to_first = FALSE, preserve_hms = TRUE) 
{
  any_HMS <- any(e2@.Data != 0) || any(e2@minute != 0) || any(e2@hour != 0) || any(e2@day != 0)
  any_year <- any(e2@year != 0)
  if (!is.na(any_year) && any_year) {
    e2$month <- 12 * e2@year + e2@month
    e2$year <- 0
  }
  new <- .quick_month_add(e1, e2@month)
  roll <- day(new) < day(e1)
  roll <- !is.na(roll) & roll
  new[roll] <- rollback(new[roll], roll_to_first = roll_to_first, preserve_hms = preserve_hms)
  if (!is.na(any_HMS) && any_HMS) {
    e2$month <- 0
    new + e2
  }
  else {
    new
  }
}, function (e1, e2, roll_to_first = FALSE, preserve_hms = TRUE) 
{
  any_HMS <- any(e2@.Data != 0) || any(e2@minute != 0) || any(e2@hour != 0) || any(e2@day != 0)
  any_year <- any(e2@year != 0)
  if (!is.na(any_year) && any_year) {
    e2$month <- 12 * e2@year + e2@month
    e2$year <- 0
  }
  new <- .quick_month_add(e1, e2@month)
  roll <- day(new) < day(e1)
  roll <- !is.na(roll) & roll
  new[roll] <- rollback(new[roll], roll_to_first = roll_to_first, preserve_hms = preserve_hms)
  if (!is.na(any_HMS) && any_HMS) {
    e2$month <- 0
    new + e2
  }
  else {
    new
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
am
list(`package:lubridate` = function (x) 
  hour(x) < 12, function (x) 
    hour(x) < 12)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
Arith
list(`package:lubridate` = new("groupGenericFunction", .Data = function (e1, e2) 
  standardGeneric("Arith"), groupMembers = list("+", "-", "*", "^", "%%", "%/%", "/"), generic = "Arith", package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Arith"), domain = NA))(e1, e2)), `package:methods` = new("groupGenericFunction", .Data = function (e1, e2) 
      standardGeneric("Arith"), groupMembers = list("+", "-", "*", "^", "%%", "%/%", "/"), generic = "Arith", package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Arith"), domain = NA))(e1, e2)), new("groupGenericFunction", .Data = function (e1, e2) 
          standardGeneric("Arith"), groupMembers = list("+", "-", "*", "^", "%%", "%/%", "/"), generic = "Arith", package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
            stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Arith"), domain = NA))(e1, e2)))
c("package:lubridate", "package:methods", "namespace:methods")
c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, TRUE)
as.difftime
list(`package:lubridate` = new("standardGeneric", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
  standardGeneric("as.difftime"), generic = "as.difftime", package = "base", group = list(), valueClass = character(0), signature = c("tim", "format", "units", "tz"), default = new("derivedDefaultMethod", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
  {
    if (inherits(tim, "difftime")) 
      return(tim)
    if (is.character(tim)) {
      difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
    }
    else {
      if (!is.numeric(tim)) 
        stop("'tim' is not character or numeric")
      if (units == "auto") 
        stop("need explicit units for numeric conversion")
      if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
        stop("invalid units specified")
      .difftime(tim, units = units)
    }
  }, target = new("signature", .Data = "ANY", names = "tim", package = "methods"), defined = new("signature", .Data = "ANY", names = "tim", package = "methods"), generic = "as.difftime"), skeleton = (new("derivedDefaultMethod", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
  {
    if (inherits(tim, "difftime")) 
      return(tim)
    if (is.character(tim)) {
      difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
    }
    else {
      if (!is.numeric(tim)) 
        stop("'tim' is not character or numeric")
      if (units == "auto") 
        stop("need explicit units for numeric conversion")
      if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
        stop("invalid units specified")
      .difftime(tim, units = units)
    }
  }, target = new("signature", .Data = "ANY", names = "tim", package = "methods"), defined = new("signature", .Data = "ANY", names = "tim", package = "methods"), generic = "as.difftime"))(tim, format, units, tz)), `package:base` = function (tim, format = "%X", units = "auto", tz = "UTC") 
  {
    if (inherits(tim, "difftime")) 
      return(tim)
    if (is.character(tim)) {
      difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
    }
    else {
      if (!is.numeric(tim)) 
        stop("'tim' is not character or numeric")
      if (units == "auto") 
        stop("need explicit units for numeric conversion")
      if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
        stop("invalid units specified")
      .difftime(tim, units = units)
    }
  }, new("standardGeneric", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
    standardGeneric("as.difftime"), generic = "as.difftime", package = "base", group = list(), valueClass = character(0), signature = c("tim", "format", "units", "tz"), default = new("derivedDefaultMethod", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
    {
      if (inherits(tim, "difftime")) 
        return(tim)
      if (is.character(tim)) {
        difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
      }
      else {
        if (!is.numeric(tim)) 
          stop("'tim' is not character or numeric")
        if (units == "auto") 
          stop("need explicit units for numeric conversion")
        if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
          stop("invalid units specified")
        .difftime(tim, units = units)
      }
    }, target = new("signature", .Data = "ANY", names = "tim", package = "methods"), defined = new("signature", .Data = "ANY", names = "tim", package = "methods"), generic = "as.difftime"), skeleton = (new("derivedDefaultMethod", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
    {
      if (inherits(tim, "difftime")) 
        return(tim)
      if (is.character(tim)) {
        difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
      }
      else {
        if (!is.numeric(tim)) 
          stop("'tim' is not character or numeric")
        if (units == "auto") 
          stop("need explicit units for numeric conversion")
        if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
          stop("invalid units specified")
        .difftime(tim, units = units)
      }
    }, target = new("signature", .Data = "ANY", names = "tim", package = "methods"), defined = new("signature", .Data = "ANY", names = "tim", package = "methods"), generic = "as.difftime"))(tim, format, units, tz)), function (tim, ...) 
      UseMethod("as.difftime"), function (tim, format = "%X", units = "auto", tz = "UTC") 
      {
        if (inherits(tim, "difftime")) 
          return(tim)
        if (is.character(tim)) {
          difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
        }
        else {
          if (!is.numeric(tim)) 
            stop("'tim' is not character or numeric")
          if (units == "auto") 
            stop("need explicit units for numeric conversion")
          if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
            stop("invalid units specified")
          .difftime(tim, units = units)
        }
      })
c("package:lubridate", "package:base", "namespace:lubridate", "namespace:generics", "namespace:base")
c(TRUE, TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, FALSE, TRUE)
as.duration
list(`package:lubridate` = new("standardGeneric", .Data = function (x, ...) 
  standardGeneric("as.duration"), generic = "as.duration", package = "lubridate", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
  {
    stop(sprintf("as.duration is not defined for class '%s'", class(x)))
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.duration"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
  {
    stop(sprintf("as.duration is not defined for class '%s'", class(x)))
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.duration"))(x, ...)), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("as.duration"), generic = "as.duration", package = "lubridate", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
    {
      stop(sprintf("as.duration is not defined for class '%s'", class(x)))
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.duration"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
    {
      stop(sprintf("as.duration is not defined for class '%s'", class(x)))
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.duration"))(x, ...)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.interval
list(`package:lubridate` = new("standardGeneric", .Data = function (x, start, ...) 
  standardGeneric("as.interval"), generic = "as.interval", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "start"), default = new("derivedDefaultMethod", .Data = function (x, start, ...) 
    standardGeneric("as.interval"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.interval"), skeleton = (new("derivedDefaultMethod", .Data = function (x, start, ...) 
      standardGeneric("as.interval"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.interval"))(x, start, ...)), new("standardGeneric", .Data = function (x, start, ...) 
        standardGeneric("as.interval"), generic = "as.interval", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "start"), default = new("derivedDefaultMethod", .Data = function (x, start, ...) 
          standardGeneric("as.interval"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.interval"), skeleton = (new("derivedDefaultMethod", .Data = function (x, start, ...) 
            standardGeneric("as.interval"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.interval"))(x, start, ...)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.period
list(`package:lubridate` = new("standardGeneric", .Data = function (x, unit, ...) 
  standardGeneric("as.period"), generic = "as.period", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "unit"), default = new("derivedDefaultMethod", .Data = function (x, unit, ...) 
  {
    stop(sprintf("as.period is not defined for class '%s'", class(x)))
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.period"), skeleton = (new("derivedDefaultMethod", .Data = function (x, unit, ...) 
  {
    stop(sprintf("as.period is not defined for class '%s'", class(x)))
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.period"))(x, unit, ...)), new("standardGeneric", .Data = function (x, unit, ...) 
    standardGeneric("as.period"), generic = "as.period", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "unit"), default = new("derivedDefaultMethod", .Data = function (x, unit, ...) 
    {
      stop(sprintf("as.period is not defined for class '%s'", class(x)))
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.period"), skeleton = (new("derivedDefaultMethod", .Data = function (x, unit, ...) 
    {
      stop(sprintf("as.period is not defined for class '%s'", class(x)))
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.period"))(x, unit, ...)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
as_date
list(`package:lubridate` = new("standardGeneric", .Data = function (x, ...) 
  standardGeneric("as_date"), generic = "as_date", package = "lubridate", group = list(), valueClass = character(0), signature = "x", default = NULL, skeleton = (function (x, ...) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "as_date"), domain = NA))(x, ...)), new("standardGeneric", .Data = function (x, ...) 
      standardGeneric("as_date"), generic = "as_date", package = "lubridate", group = list(), valueClass = character(0), signature = "x", default = NULL, skeleton = (function (x, ...) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "as_date"), domain = NA))(x, ...)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
as_datetime
list(`package:lubridate` = new("nonstandardGenericFunction", .Data = function (x, ...) 
{
  standardGeneric("as_datetime")
}, generic = "as_datetime", package = "lubridate", group = list(), valueClass = character(0), signature = "x", default = NULL, skeleton = (function (x, ...) 
  stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "as_datetime"), domain = NA))(x, ...)), new("nonstandardGenericFunction", .Data = function (x, ...) 
  {
    standardGeneric("as_datetime")
  }, generic = "as_datetime", package = "lubridate", group = list(), valueClass = character(0), signature = "x", default = NULL, skeleton = (function (x, ...) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "as_datetime"), domain = NA))(x, ...)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ceiling_date
list(`package:lubridate` = function (x, unit = "seconds", change_on_boundary = NULL, week_start = getOption("lubridate.week.start", 7)) 
{
  if (!length(x)) 
    return(x)
  parsed_unit <- parse_period_unit(unit)
  n <- parsed_unit$n
  unit <- standardise_period_names(parsed_unit$unit)
  if (is.null(change_on_boundary)) {
    change_on_boundary <- is.Date(x)
  }
  if (unit == "second") {
    new <- as_datetime(x, tz = tz(x))
    sec <- second(new)
    csec <- ceil_multi_unit(sec, n)
    if (!change_on_boundary) {
      wsec <- which(csec - n == sec)
      if (length(wsec)) 
        csec[wsec] <- sec[wsec]
    }
    update(new, seconds = csec, simple = T)
  }
  else if (unit %in% c("minute", "hour")) {
    new <- as_datetime(x, tz = tz(x))
    delta <- switch(unit, minute = 60, hour = 3600, day = 86400) * n
    new <- if (change_on_boundary) {
      trunc_multi_unit(new, unit, n) + delta
    }
    else {
      new1 <- trunc_multi_unit(new, unit, n)
      not_same <- which(new1 != new)
      new1[not_same] <- new1[not_same] + delta
      new1
    }
    reclass_date_maybe(new, x, unit)
  }
  else {
    if (n > 1 && unit == "week") {
      warning("Multi-unit not supported for weeks. Ignoring.")
    }
    new <- if (change_on_boundary) 
      x
    else update(x, seconds = second(x) - 1e-05, simple = T)
    if (unit %in% c("month", "bimonth", "quarter", "halfyear", "season")) {
      new_month <- switch(unit, month = ceil_multi_unit1(month(new), n), bimonth = ceil_multi_unit1(month(new), 2 * n), quarter = ceil_multi_unit1(month(new), 3 * n), halfyear = ceil_multi_unit1(month(new), 6 * n), season = ceil_multi_unit(month(new), 3 * n))
      unit <- "month"
    }
    new <- switch(unit, minute = update(new, minutes = ceil_multi_unit(minute(new), n), seconds = 0, simple = T), hour = update(new, hours = ceil_multi_unit(hour(new), n), minutes = 0, seconds = 0, simple = T), day = update(new, days = ceil_multi_unit1(day(new), n), hours = 0, minutes = 0, seconds = 0), week = update(new, wdays = 8, hours = 0, minutes = 0, seconds = 0, week_start = week_start), month = update(new, months = new_month, mdays = 1, hours = 0, minutes = 0, seconds = 0), year = update(new, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     years = ceil_multi_unit(year(new), n), months = 1, mdays = 1, hours = 0, minutes = 0, seconds = 0))
    reclass_date_maybe(new, x, unit)
  }
}, function (x, unit = "seconds", change_on_boundary = NULL, week_start = getOption("lubridate.week.start", 7)) 
{
  if (!length(x)) 
    return(x)
  parsed_unit <- parse_period_unit(unit)
  n <- parsed_unit$n
  unit <- standardise_period_names(parsed_unit$unit)
  if (is.null(change_on_boundary)) {
    change_on_boundary <- is.Date(x)
  }
  if (unit == "second") {
    new <- as_datetime(x, tz = tz(x))
    sec <- second(new)
    csec <- ceil_multi_unit(sec, n)
    if (!change_on_boundary) {
      wsec <- which(csec - n == sec)
      if (length(wsec)) 
        csec[wsec] <- sec[wsec]
    }
    update(new, seconds = csec, simple = T)
  }
  else if (unit %in% c("minute", "hour")) {
    new <- as_datetime(x, tz = tz(x))
    delta <- switch(unit, minute = 60, hour = 3600, day = 86400) * n
    new <- if (change_on_boundary) {
      trunc_multi_unit(new, unit, n) + delta
    }
    else {
      new1 <- trunc_multi_unit(new, unit, n)
      not_same <- which(new1 != new)
      new1[not_same] <- new1[not_same] + delta
      new1
    }
    reclass_date_maybe(new, x, unit)
  }
  else {
    if (n > 1 && unit == "week") {
      warning("Multi-unit not supported for weeks. Ignoring.")
    }
    new <- if (change_on_boundary) 
      x
    else update(x, seconds = second(x) - 1e-05, simple = T)
    if (unit %in% c("month", "bimonth", "quarter", "halfyear", "season")) {
      new_month <- switch(unit, month = ceil_multi_unit1(month(new), n), bimonth = ceil_multi_unit1(month(new), 2 * n), quarter = ceil_multi_unit1(month(new), 3 * n), halfyear = ceil_multi_unit1(month(new), 6 * n), season = ceil_multi_unit(month(new), 3 * n))
      unit <- "month"
    }
    new <- switch(unit, minute = update(new, minutes = ceil_multi_unit(minute(new), n), seconds = 0, simple = T), hour = update(new, hours = ceil_multi_unit(hour(new), n), minutes = 0, seconds = 0, simple = T), day = update(new, days = ceil_multi_unit1(day(new), n), hours = 0, minutes = 0, seconds = 0), week = update(new, wdays = 8, hours = 0, minutes = 0, seconds = 0, week_start = week_start), month = update(new, months = new_month, mdays = 1, hours = 0, minutes = 0, seconds = 0), year = update(new, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     years = ceil_multi_unit(year(new), n), months = 1, mdays = 1, hours = 0, minutes = 0, seconds = 0))
    reclass_date_maybe(new, x, unit)
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
Compare
list(`package:lubridate` = new("groupGenericFunction", .Data = function (e1, e2) 
  standardGeneric("Compare"), groupMembers = list("==", ">", "<", "!=", "<=", ">="), generic = "Compare", package = "methods", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Compare"), domain = NA))(e1, e2)), `package:methods` = new("groupGenericFunction", .Data = function (e1, e2) 
      standardGeneric("Compare"), groupMembers = list("==", ">", "<", "!=", "<=", ">="), generic = "Compare", package = "methods", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Compare"), domain = NA))(e1, e2)), new("groupGenericFunction", .Data = function (e1, e2) 
          standardGeneric("Compare"), groupMembers = list("==", ">", "<", "!=", "<=", ">="), generic = "Compare", package = "methods", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
            stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Compare"), domain = NA))(e1, e2)))
c("package:lubridate", "package:methods", "namespace:methods")
c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, TRUE)
cyclic_encoding
list(`package:lubridate` = function (x, periods, encoders = c("sin", "cos"), week_start = getOption("lubridate.week.start", 7)) 
{
  Ne <- length(encoders)
  Np <- length(periods)
  out <- matrix(0, nrow = length(x), ncol = Ne * Np)
  colnames(out) <- paste(rep.int(encoders, Np), rep(periods, each = Ne), sep = ".")
  for (pix in seq_along(periods)) {
    p <- periods[[pix]]
    beg <- as.numeric(floor_date(x, unit = p, week_start = week_start))
    end <- as.numeric(ceiling_date(x, unit = p, week_start = week_start))
    diff <- (2 * pi) * (as.numeric(x) - beg)/(end - beg)
    diff[end == beg] <- 0
    for (tix in seq_along(encoders)) {
      out[, (pix - 1) * Ne + tix] <- do.call(encoders[[tix]], list(diff))
    }
  }
  out
}, function (x, periods, encoders = c("sin", "cos"), week_start = getOption("lubridate.week.start", 7)) 
{
  Ne <- length(encoders)
  Np <- length(periods)
  out <- matrix(0, nrow = length(x), ncol = Ne * Np)
  colnames(out) <- paste(rep.int(encoders, Np), rep(periods, each = Ne), sep = ".")
  for (pix in seq_along(periods)) {
    p <- periods[[pix]]
    beg <- as.numeric(floor_date(x, unit = p, week_start = week_start))
    end <- as.numeric(ceiling_date(x, unit = p, week_start = week_start))
    diff <- (2 * pi) * (as.numeric(x) - beg)/(end - beg)
    diff[end == beg] <- 0
    for (tix in seq_along(encoders)) {
      out[, (pix - 1) * Ne + tix] <- do.call(encoders[[tix]], list(diff))
    }
  }
  out
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
date
list(`package:lubridate` = function (x) 
  UseMethod("date"), `package:base` = function () 
    .Internal(date()), function (x) 
      UseMethod("date"), function () 
        .Internal(date()))
c("package:lubridate", "package:base", "namespace:lubridate", "namespace:base")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
Date
list(`package:lubridate` = function (length = 0) 
{
  structure(rep.int(NA, length), class = "Date")
}, function (length = 0) 
{
  structure(rep.int(NA, length), class = "Date")
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
date_decimal
list(`package:lubridate` = function (decimal, tz = "UTC") 
{
  Y <- trunc(decimal)
  start <- make_datetime(Y, 1, 1, tz = tz)
  end <- make_datetime(Y + 1, 1, 1, tz = tz)
  seconds <- as.numeric(difftime(end, start, units = "secs"))
  frac <- decimal - Y
  end <- start + seconds * frac
  return(end)
}, function (decimal, tz = "UTC") 
{
  Y <- trunc(decimal)
  start <- make_datetime(Y, 1, 1, tz = tz)
  end <- make_datetime(Y + 1, 1, 1, tz = tz)
  seconds <- as.numeric(difftime(end, start, units = "secs"))
  frac <- decimal - Y
  end <- start + seconds * frac
  return(end)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
date<-
  list(`package:lubridate` = new("standardGeneric", .Data = function (x, value) 
    standardGeneric("date<-"), generic = "date<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
      x <- x + days(date(value) - date(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "date<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
        x <- x + days(date(value) - date(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "date<-"))(x, value)), new("standardGeneric", .Data = function (x, value) 
          standardGeneric("date<-"), generic = "date<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
            x <- x + days(date(value) - date(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "date<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
              x <- x + days(date(value) - date(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "date<-"))(x, value)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
day
list(`package:lubridate` = function (x) 
  UseMethod("mday"), function (x) 
    UseMethod("mday"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
day<-
  list(`package:lubridate` = new("standardGeneric", .Data = function (x, value) 
    standardGeneric("day<-"), generic = "day<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
      x <- x + days(value - mday(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "day<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
        x <- x + days(value - mday(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "day<-"))(x, value)), new("standardGeneric", .Data = function (x, value) 
          standardGeneric("day<-"), generic = "day<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
            x <- x + days(value - mday(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "day<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
              x <- x + days(value - mday(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "day<-"))(x, value)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
days
list(`package:lubridate` = function (x = 1) 
  period(day = x), function (x = 1) 
    period(day = x))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
days_in_month
list(`package:lubridate` = function (x) 
{
  month_x <- month(x, label = TRUE, locale = "C")
  n_days <- N_DAYS_IN_MONTHS[month_x]
  n_days[month_x == "Feb" & leap_year(x)] <- 29
  n_days
}, function (x) 
{
  month_x <- month(x, label = TRUE, locale = "C")
  n_days <- N_DAYS_IN_MONTHS[month_x]
  n_days[month_x == "Feb" & leap_year(x)] <- 29
  n_days
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ddays
list(`package:lubridate` = function (x = 1) 
  new("Duration", x * 86400), function (x = 1) 
    new("Duration", x * 86400))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
decimal_date
list(`package:lubridate` = function (date) 
  UseMethod("decimal_date"), function (date) 
    UseMethod("decimal_date"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dhours
list(`package:lubridate` = function (x = 1) 
  new("Duration", x * 3600), function (x = 1) 
    new("Duration", x * 3600))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dmicroseconds
list(`package:lubridate` = function (x = 1) 
  new("Duration", x/1000/1000), function (x = 1) 
    new("Duration", x/1000/1000))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dmilliseconds
list(`package:lubridate` = function (x = 1) 
  new("Duration", x/1000), function (x = 1) 
    new("Duration", x/1000))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dminutes
list(`package:lubridate` = function (x = 1) 
  new("Duration", x * 60), function (x = 1) 
    new("Duration", x * 60))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dmonths
list(`package:lubridate` = function (x = 1) 
  new("Duration", x * average_durations[["month"]]), function (x = 1) 
    new("Duration", x * average_durations[["month"]]))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dmy
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx(..., orders = "dmy", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx(..., orders = "dmy", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dmy_h
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = "dmyr", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = "dmyr", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dmy_hm
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = "dmyR", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = "dmyR", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dmy_hms
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = c("dmyTz", "dmyT"), quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = c("dmyTz", "dmyT"), quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dnanoseconds
list(`package:lubridate` = function (x = 1) 
  new("Duration", x/1000/1000/1000), function (x = 1) 
    new("Duration", x/1000/1000/1000))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dpicoseconds
list(`package:lubridate` = function (x = 1) 
  new("Duration", x/1000/1000/1000/1000), function (x = 1) 
    new("Duration", x/1000/1000/1000/1000))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dseconds
list(`package:lubridate` = function (x = 1) 
  new("Duration", x), function (x = 1) 
    new("Duration", x))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dst
list(`package:lubridate` = function (x) 
  UseMethod("dst"), function (x) 
    UseMethod("dst"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
duration
list(`package:lubridate` = function (num = NULL, units = "seconds", ...) 
{
  if (is.character(num)) {
    as.duration(parse_period(num))
  }
  else {
    out1 <- .duration_from_num(num, units)
    out2 <- .duration_from_pieces(list(...))
    if (is.null(out1) && is.null(out2)) 
      new("Duration", numeric())
    else if (is.null(out1)) 
      out2
    else if (is.null(out2)) 
      out1
    else c(out1, out2)
  }
}, function (num = NULL, units = "seconds", ...) 
{
  if (is.character(num)) {
    as.duration(parse_period(num))
  }
  else {
    out1 <- .duration_from_num(num, units)
    out2 <- .duration_from_pieces(list(...))
    if (is.null(out1) && is.null(out2)) 
      new("Duration", numeric())
    else if (is.null(out1)) 
      out2
    else if (is.null(out2)) 
      out1
    else c(out1, out2)
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dweeks
list(`package:lubridate` = function (x = 1) 
  new("Duration", x * average_durations[["week"]]), function (x = 1) 
    new("Duration", x * average_durations[["week"]]))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dyears
list(`package:lubridate` = function (x = 1) 
  new("Duration", x * average_durations[["year"]]), function (x = 1) 
    new("Duration", x * average_durations[["year"]]))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
dym
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx(..., orders = "dym", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx(..., orders = "dym", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
epiweek
list(`package:lubridate` = function (x) 
{
  .other_week(x, 7)
}, function (x) 
{
  .other_week(x, 7)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
epiyear
list(`package:lubridate` = function (x) 
{
  .other_year(x, 7)
}, function (x) 
{
  .other_year(x, 7)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
fast_strptime
list(`package:lubridate` = function (x, format, tz = "UTC", lt = TRUE, cutoff_2000 = 68) 
{
  parse1 <- function(x, fmt) {
    if (lt) {
      .mklt(parse_dt(x, fmt, TRUE, TRUE, cutoff_2000), tz)
    }
    else {
      if (is_utc(tz)) {
        .POSIXct(parse_dt(x, fmt, TRUE, FALSE, cutoff_2000), "UTC")
      }
      else {
        as.POSIXct(.mklt(parse_dt(x, fmt, TRUE, TRUE, cutoff_2000), tz))
      }
    }
  }
  nnas <- !is.na(x)
  out <- parse1(x, format[[1]])
  for (fmt in format[-1]) {
    nnas <- nnas & is.na(out)
    out[nnas] <- parse1(x[nnas], fmt)
  }
  out
}, function (x, format, tz = "UTC", lt = TRUE, cutoff_2000 = 68) 
{
  parse1 <- function(x, fmt) {
    if (lt) {
      .mklt(parse_dt(x, fmt, TRUE, TRUE, cutoff_2000), tz)
    }
    else {
      if (is_utc(tz)) {
        .POSIXct(parse_dt(x, fmt, TRUE, FALSE, cutoff_2000), "UTC")
      }
      else {
        as.POSIXct(.mklt(parse_dt(x, fmt, TRUE, TRUE, cutoff_2000), tz))
      }
    }
  }
  nnas <- !is.na(x)
  out <- parse1(x, format[[1]])
  for (fmt in format[-1]) {
    nnas <- nnas & is.na(out)
    out[nnas] <- parse1(x[nnas], fmt)
  }
  out
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
fit_to_timeline
list(`package:lubridate` = function (lt, class = "POSIXct", simple = FALSE) 
{
  if (class != "POSIXlt" && class != "POSIXct") 
    stop("class argument must be POSIXlt or POSIXct")
  if (simple) {
    if (class == "POSIXct") 
      as.POSIXct(lt)
    else as.POSIXlt(as.POSIXct(lt))
  }
  else {
    ct <- as.POSIXct(lt)
    lt2 <- as.POSIXlt(ct)
    dstdiff <- !is.na(ct) & (lt$isdst != lt2$isdst)
    if (any(dstdiff)) {
      dlt <- lt[dstdiff]
      dlt2 <- lt2[dstdiff]
      dlt$isdst <- dlt2$isdst
      dlt$zone <- dlt2$zone
      dlt$gmtoff <- dlt2$gmtoff
      dct <- as.POSIXct(dlt)
      if (class == "POSIXct") 
        ct[dstdiff] <- dct
      else lt2[dstdiff] <- dlt
      chours <- format.POSIXlt(as.POSIXlt(dct), "%H", usetz = FALSE)
      lhours <- format.POSIXlt(dlt, "%H", usetz = FALSE)
      any <- any(hdiff <- chours != lhours)
      if (!is.na(any) && any) {
        if (class == "POSIXct") 
          ct[dstdiff][hdiff] <- NA
        else lt2[dstdiff][hdiff] <- NA
      }
    }
    if (class == "POSIXct") 
      ct
    else lt2
  }
}, function (lt, class = "POSIXct", simple = FALSE) 
{
  if (class != "POSIXlt" && class != "POSIXct") 
    stop("class argument must be POSIXlt or POSIXct")
  if (simple) {
    if (class == "POSIXct") 
      as.POSIXct(lt)
    else as.POSIXlt(as.POSIXct(lt))
  }
  else {
    ct <- as.POSIXct(lt)
    lt2 <- as.POSIXlt(ct)
    dstdiff <- !is.na(ct) & (lt$isdst != lt2$isdst)
    if (any(dstdiff)) {
      dlt <- lt[dstdiff]
      dlt2 <- lt2[dstdiff]
      dlt$isdst <- dlt2$isdst
      dlt$zone <- dlt2$zone
      dlt$gmtoff <- dlt2$gmtoff
      dct <- as.POSIXct(dlt)
      if (class == "POSIXct") 
        ct[dstdiff] <- dct
      else lt2[dstdiff] <- dlt
      chours <- format.POSIXlt(as.POSIXlt(dct), "%H", usetz = FALSE)
      lhours <- format.POSIXlt(dlt, "%H", usetz = FALSE)
      any <- any(hdiff <- chours != lhours)
      if (!is.na(any) && any) {
        if (class == "POSIXct") 
          ct[dstdiff][hdiff] <- NA
        else lt2[dstdiff][hdiff] <- NA
      }
    }
    if (class == "POSIXct") 
      ct
    else lt2
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
floor_date
list(`package:lubridate` = function (x, unit = "seconds", week_start = getOption("lubridate.week.start", 7)) 
{
  if (!length(x)) 
    return(x)
  parsed_unit <- parse_period_unit(unit)
  n <- parsed_unit$n
  unit <- standardise_period_names(parsed_unit$unit)
  if (unit %in% c("second", "minute", "hour", "day")) {
    out <- trunc_multi_unit(as_datetime(x, tz = tz(x)), unit, n)
    reclass_date_maybe(out, x, unit)
  }
  else {
    if (n > 1 && unit == "week") {
      warning("Multi-unit not supported for weeks. Ignoring.")
    }
    if (unit %in% c("bimonth", "quarter", "halfyear", "season") || (n > 1 && unit == "month")) {
      new_months <- switch(unit, month = floor_multi_unit1(month(x), n), bimonth = floor_multi_unit1(month(x), 2 * n), quarter = floor_multi_unit1(month(x), 3 * n), halfyear = floor_multi_unit1(month(x), 6 * n), season = floor_multi_unit(month(x), 3 * n))
      n <- Inf
      unit <- "month"
    }
    switch(unit, week = update(x, wdays = 1, hours = 0, minutes = 0, seconds = 0, week_start = week_start), month = {
      if (n > 1) update(x, months = new_months, mdays = 1, hours = 0, minutes = 0, seconds = 0) else update(x, mdays = 1, hours = 0, minutes = 0, seconds = 0)
    }, year = {
      if (n > 1) {
        y <- update(x, ydays = 1, hours = 0, minutes = 0, seconds = 0)
        update(y, years = floor_multi_unit(year(y), n))
      } else {
        update(x, ydays = 1, hours = 0, minutes = 0, seconds = 0)
      }
    })
  }
}, function (x, unit = "seconds", week_start = getOption("lubridate.week.start", 7)) 
{
  if (!length(x)) 
    return(x)
  parsed_unit <- parse_period_unit(unit)
  n <- parsed_unit$n
  unit <- standardise_period_names(parsed_unit$unit)
  if (unit %in% c("second", "minute", "hour", "day")) {
    out <- trunc_multi_unit(as_datetime(x, tz = tz(x)), unit, n)
    reclass_date_maybe(out, x, unit)
  }
  else {
    if (n > 1 && unit == "week") {
      warning("Multi-unit not supported for weeks. Ignoring.")
    }
    if (unit %in% c("bimonth", "quarter", "halfyear", "season") || (n > 1 && unit == "month")) {
      new_months <- switch(unit, month = floor_multi_unit1(month(x), n), bimonth = floor_multi_unit1(month(x), 2 * n), quarter = floor_multi_unit1(month(x), 3 * n), halfyear = floor_multi_unit1(month(x), 6 * n), season = floor_multi_unit(month(x), 3 * n))
      n <- Inf
      unit <- "month"
    }
    switch(unit, week = update(x, wdays = 1, hours = 0, minutes = 0, seconds = 0, week_start = week_start), month = {
      if (n > 1) update(x, months = new_months, mdays = 1, hours = 0, minutes = 0, seconds = 0) else update(x, mdays = 1, hours = 0, minutes = 0, seconds = 0)
    }, year = {
      if (n > 1) {
        y <- update(x, ydays = 1, hours = 0, minutes = 0, seconds = 0)
        update(y, years = floor_multi_unit(year(y), n))
      } else {
        update(x, ydays = 1, hours = 0, minutes = 0, seconds = 0)
      }
    })
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
force_tz
list(`package:lubridate` = function (time, tzone = "", roll = FALSE) 
{
  tzone <- as.character(tzone)
  if (is.data.frame(time)) {
    for (nm in names(time)) {
      if (is.POSIXt(time[[nm]])) {
        time[[nm]] <- force_tz(time[[nm]], tzone = tzone)
      }
    }
    time
  }
  else {
    if (is.POSIXct(time)) 
      cpp_force_tz(time, tz = tzone, roll)
    else if (is.Date(time)) 
      cpp_force_tz(date_to_posix(time), tz = tzone, roll)
    else {
      out <- cpp_force_tz(as.POSIXct(time, tz = tz(time)), tz = tzone, roll)
      reclass_date(out, time)
    }
  }
}, function (time, tzone = "", roll = FALSE) 
{
  tzone <- as.character(tzone)
  if (is.data.frame(time)) {
    for (nm in names(time)) {
      if (is.POSIXt(time[[nm]])) {
        time[[nm]] <- force_tz(time[[nm]], tzone = tzone)
      }
    }
    time
  }
  else {
    if (is.POSIXct(time)) 
      cpp_force_tz(time, tz = tzone, roll)
    else if (is.Date(time)) 
      cpp_force_tz(date_to_posix(time), tz = tzone, roll)
    else {
      out <- cpp_force_tz(as.POSIXct(time, tz = tz(time)), tz = tzone, roll)
      reclass_date(out, time)
    }
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
force_tzs
list(`package:lubridate` = function (time, tzones, tzone_out = "UTC", roll = FALSE) 
{
  if (length(tzones) < length(time)) 
    tzones <- rep_len(tzones, length(time))
  else if (length(tzones) > length(time)) {
    attr <- attributes(time)
    time <- rep_len(time, length(tzones))
    attributes(time) <- attr
  }
  out <- cpp_force_tzs(as.POSIXct(time), tzones, tzone_out, roll)
  reclass_date(out, time)
}, function (time, tzones, tzone_out = "UTC", roll = FALSE) 
{
  if (length(tzones) < length(time)) 
    tzones <- rep_len(tzones, length(time))
  else if (length(tzones) > length(time)) {
    attr <- attributes(time)
    time <- rep_len(time, length(tzones))
    attributes(time) <- attr
  }
  out <- cpp_force_tzs(as.POSIXct(time), tzones, tzone_out, roll)
  reclass_date(out, time)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
format_ISO8601
list(`package:lubridate` = new("standardGeneric", .Data = function (x, usetz = FALSE, precision = NULL, ...) 
  standardGeneric("format_ISO8601"), generic = "format_ISO8601", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "usetz", "precision"), default = NULL, skeleton = (function (x, usetz = FALSE, precision = NULL, ...) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "format_ISO8601"), domain = NA))(x, usetz, precision, ...)), new("standardGeneric", .Data = function (x, usetz = FALSE, precision = NULL, ...) 
      standardGeneric("format_ISO8601"), generic = "format_ISO8601", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "usetz", "precision"), default = NULL, skeleton = (function (x, usetz = FALSE, precision = NULL, ...) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "format_ISO8601"), domain = NA))(x, usetz, precision, ...)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
guess_formats
list(`package:lubridate` = function (x, orders, locale = Sys.getlocale("LC_TIME"), preproc_wday = TRUE, print_matches = FALSE) 
{
  orders <- gsub("[^[:alpha:]]+", "", orders)
  if (any(grepl("hms|hm|ms", orders))) {
    .deprecated("hms, hm and ms usage", ", please use HMS, HM or MS instead", "1.5.6")
    orders <- gsub("hms", "HMS", orders, ignore.case = TRUE)
    orders <- gsub("hm", "HM", orders, ignore.case = TRUE)
    orders <- gsub("ms", "MS", orders, ignore.case = TRUE)
  }
  if (length(wp <- grepl("(?<!O)p", orders, perl = T))) 
    orders <- c(sub("p", "Op", orders[wp], fixed = T), orders)
  if (length(wm <- grepl("(?<!O)m", orders, perl = T))) 
    orders <- c(sub("m", "Om", orders[wm]), orders)
  if (length(wm <- grepl("(?<!O)[bB]", orders, perl = T))) 
    orders <- c(sub("[Bb]", "Ob", orders[wm]), orders)
  if (length(wT <- grepl("T", orders, fixed = T))) 
    orders <- c(sub("T", "HMSOp", orders[wT], fixed = T), orders)
  if (length(wR <- grepl("R", orders, fixed = T))) 
    orders <- c(sub("R", "HMOp", orders[wR], fixed = T), orders)
  if (length(wr <- grepl("r", orders, fixed = T))) 
    orders <- c(sub("r", "HOp", orders[wR], fixed = T), orders)
  osplits <- strsplit(orders, "", fixed = TRUE)
  osplits <- lapply(osplits, function(ospt) {
    if (length(which_O <- which(ospt == "O")) > 0) {
      ospt[which_O + 1] <- paste("O", ospt[which_O + 1], sep = "")
      ospt[-which_O]
    }
    else ospt
  })
  reg <- .get_locale_regs(locale)
  flex_regs <- c(reg$alpha_flex, reg$num_flex, .c_parser_reg_flex)
  exact_regs <- c(reg$alpha_exact, reg$num_exact, .c_parser_reg_exact)
  REGS <- unlist(lapply(osplits, function(fnames) {
    which <- !fnames %in% c(names(reg$alpha_flex), names(reg$num_flex), names(.c_parser_reg_exact))
    if (any(which)) 
      stop("Unknown formats supplied: ", paste(fnames[which], sep = ", "))
    paste("^\\D*?\\b((", paste(unlist(flex_regs[fnames]), collapse = "\\D*?"), ")|(", paste(unlist(exact_regs[fnames]), collapse = "\\D*?"), "))\\D*$", sep = "")
  }))
  if (print_matches) {
    subs <- lapply(REGS, .substitute_formats, x, fmts_only = FALSE)
    names(subs) <- orders
    print(do.call(cbind, c(list(x), subs)))
  }
  .build_formats <- function(regs, orders, x) {
    out <- mapply(function(reg, name) {
      out <- .substitute_formats(reg, x)
      if (!is.null(out)) 
        names(out) <- rep.int(name, length(out))
      out
    }, REGS, orders, SIMPLIFY = F, USE.NAMES = F)
    names(out) <- NULL
    unlist(out)
  }
  if (preproc_wday && !any(grepl("[aA]", orders))) {
    x2 <- gsub(reg$alpha_exact[["A"]], "%A", x, ignore.case = T, perl = T)
    x2 <- gsub(reg$alpha_exact[["a"]], "%a", x2, ignore.case = T, perl = T)
    formats <- .build_formats(REGS, orders, x2)
    if (any(grepl("%[aA]", formats))) 
      c(formats, .build_formats(REGS, orders, x))
    else formats
  }
  else {
    .build_formats(REGS, orders, x)
  }
}, function (x, orders, locale = Sys.getlocale("LC_TIME"), preproc_wday = TRUE, print_matches = FALSE) 
{
  orders <- gsub("[^[:alpha:]]+", "", orders)
  if (any(grepl("hms|hm|ms", orders))) {
    .deprecated("hms, hm and ms usage", ", please use HMS, HM or MS instead", "1.5.6")
    orders <- gsub("hms", "HMS", orders, ignore.case = TRUE)
    orders <- gsub("hm", "HM", orders, ignore.case = TRUE)
    orders <- gsub("ms", "MS", orders, ignore.case = TRUE)
  }
  if (length(wp <- grepl("(?<!O)p", orders, perl = T))) 
    orders <- c(sub("p", "Op", orders[wp], fixed = T), orders)
  if (length(wm <- grepl("(?<!O)m", orders, perl = T))) 
    orders <- c(sub("m", "Om", orders[wm]), orders)
  if (length(wm <- grepl("(?<!O)[bB]", orders, perl = T))) 
    orders <- c(sub("[Bb]", "Ob", orders[wm]), orders)
  if (length(wT <- grepl("T", orders, fixed = T))) 
    orders <- c(sub("T", "HMSOp", orders[wT], fixed = T), orders)
  if (length(wR <- grepl("R", orders, fixed = T))) 
    orders <- c(sub("R", "HMOp", orders[wR], fixed = T), orders)
  if (length(wr <- grepl("r", orders, fixed = T))) 
    orders <- c(sub("r", "HOp", orders[wR], fixed = T), orders)
  osplits <- strsplit(orders, "", fixed = TRUE)
  osplits <- lapply(osplits, function(ospt) {
    if (length(which_O <- which(ospt == "O")) > 0) {
      ospt[which_O + 1] <- paste("O", ospt[which_O + 1], sep = "")
      ospt[-which_O]
    }
    else ospt
  })
  reg <- .get_locale_regs(locale)
  flex_regs <- c(reg$alpha_flex, reg$num_flex, .c_parser_reg_flex)
  exact_regs <- c(reg$alpha_exact, reg$num_exact, .c_parser_reg_exact)
  REGS <- unlist(lapply(osplits, function(fnames) {
    which <- !fnames %in% c(names(reg$alpha_flex), names(reg$num_flex), names(.c_parser_reg_exact))
    if (any(which)) 
      stop("Unknown formats supplied: ", paste(fnames[which], sep = ", "))
    paste("^\\D*?\\b((", paste(unlist(flex_regs[fnames]), collapse = "\\D*?"), ")|(", paste(unlist(exact_regs[fnames]), collapse = "\\D*?"), "))\\D*$", sep = "")
  }))
  if (print_matches) {
    subs <- lapply(REGS, .substitute_formats, x, fmts_only = FALSE)
    names(subs) <- orders
    print(do.call(cbind, c(list(x), subs)))
  }
  .build_formats <- function(regs, orders, x) {
    out <- mapply(function(reg, name) {
      out <- .substitute_formats(reg, x)
      if (!is.null(out)) 
        names(out) <- rep.int(name, length(out))
      out
    }, REGS, orders, SIMPLIFY = F, USE.NAMES = F)
    names(out) <- NULL
    unlist(out)
  }
  if (preproc_wday && !any(grepl("[aA]", orders))) {
    x2 <- gsub(reg$alpha_exact[["A"]], "%A", x, ignore.case = T, perl = T)
    x2 <- gsub(reg$alpha_exact[["a"]], "%a", x2, ignore.case = T, perl = T)
    formats <- .build_formats(REGS, orders, x2)
    if (any(grepl("%[aA]", formats))) 
      c(formats, .build_formats(REGS, orders, x))
    else formats
  }
  else {
    .build_formats(REGS, orders, x)
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
hm
list(`package:lubridate` = function (..., quiet = FALSE, roll = FALSE) 
{
  out <- .parse_hms(..., order = "HM", quiet = quiet)
  if (roll) {
    hms <- .roll_hms(hour = out["H", ], min = out["M", ])
    period(hour = hms$hour, minute = hms$min, second = hms$sec)
  }
  else {
    period(hour = out["H", ], minute = out["M", ])
  }
}, function (..., quiet = FALSE, roll = FALSE) 
{
  out <- .parse_hms(..., order = "HM", quiet = quiet)
  if (roll) {
    hms <- .roll_hms(hour = out["H", ], min = out["M", ])
    period(hour = hms$hour, minute = hms$min, second = hms$sec)
  }
  else {
    period(hour = out["H", ], minute = out["M", ])
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
hms
list(`package:lubridate` = function (..., quiet = FALSE, roll = FALSE) 
{
  out <- .parse_hms(..., order = "HMS", quiet = quiet)
  if (roll) {
    hms <- .roll_hms(out["H", ], out["M", ], out["S", ])
    period(hour = hms$hour, minute = hms$min, second = hms$sec)
  }
  else {
    period(hour = out["H", ], minute = out["M", ], second = out["S", ])
  }
}, function (..., quiet = FALSE, roll = FALSE) 
{
  out <- .parse_hms(..., order = "HMS", quiet = quiet)
  if (roll) {
    hms <- .roll_hms(out["H", ], out["M", ], out["S", ])
    period(hour = hms$hour, minute = hms$min, second = hms$sec)
  }
  else {
    period(hour = out["H", ], minute = out["M", ], second = out["S", ])
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
hour
list(`package:lubridate` = function (x) 
  UseMethod("hour"), function (x) 
    UseMethod("hour"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
hour<-
  list(`package:lubridate` = new("standardGeneric", .Data = function (x, value) 
    standardGeneric("hour<-"), generic = "hour<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
      x <- x + hours(value - hour(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "hour<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
        x <- x + hours(value - hour(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "hour<-"))(x, value)), new("standardGeneric", .Data = function (x, value) 
          standardGeneric("hour<-"), generic = "hour<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
            x <- x + hours(value - hour(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "hour<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
              x <- x + hours(value - hour(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "hour<-"))(x, value)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
hours
list(`package:lubridate` = function (x = 1) 
  period(hour = x), function (x = 1) 
    period(hour = x))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_aligns
list(`package:lubridate` = function (int1, int2) 
{
  int1 <- int_standardize(int1)
  int2 <- int_standardize(int2)
  int1@start == int2@start | (int1@start + int1@.Data) == (int2@start + int2@.Data)
}, function (int1, int2) 
{
  int1 <- int_standardize(int1)
  int2 <- int_standardize(int2)
  int1@start == int2@start | (int1@start + int1@.Data) == (int2@start + int2@.Data)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_diff
list(`package:lubridate` = function (times) 
{
  interval(times[-length(times)], times[-1])
}, function (times) 
{
  interval(times[-length(times)], times[-1])
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_end
list(`package:lubridate` = function (int) 
  int@start + int@.Data, function (int) 
    int@start + int@.Data)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_end<-
  list(`package:lubridate` = function (int, value) 
  {
    value <- as.POSIXct(value)
    span <- as.numeric(value - int@start, "secs")
    int <- new("Interval", span, start = int@start, tzone = int@tzone)
  }, function (int, value) 
  {
    value <- as.POSIXct(value)
    span <- as.numeric(value - int@start, "secs")
    int <- new("Interval", span, start = int@start, tzone = int@tzone)
  })
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_flip
list(`package:lubridate` = function (int) 
{
  new("Interval", -int@.Data, start = int@start + int@.Data, tzone = int@tzone)
}, function (int) 
{
  new("Interval", -int@.Data, start = int@start + int@.Data, tzone = int@tzone)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_length
list(`package:lubridate` = function (int) 
  int@.Data, function (int) 
    int@.Data)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_overlaps
list(`package:lubridate` = function (int1, int2) 
{
  stopifnot(c(is.interval(int1), is.interval(int2)))
  int1 <- int_standardize(int1)
  int2 <- int_standardize(int2)
  int1@start <= int2@start + int2@.Data & int2@start <= int1@start + int1@.Data
}, function (int1, int2) 
{
  stopifnot(c(is.interval(int1), is.interval(int2)))
  int1 <- int_standardize(int1)
  int2 <- int_standardize(int2)
  int1@start <= int2@start + int2@.Data & int2@start <= int1@start + int1@.Data
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_shift
list(`package:lubridate` = function (int, by) 
{
  if (!is.timespan(by)) 
    stop("by is not a recognized timespan object")
  if (is.interval(by)) 
    stop("an interval cannot be shifted by another interval.\n    Convert second interval to a period or duration.")
  interval(int@start + by, int_end(int) + by)
}, function (int, by) 
{
  if (!is.timespan(by)) 
    stop("by is not a recognized timespan object")
  if (is.interval(by)) 
    stop("an interval cannot be shifted by another interval.\n    Convert second interval to a period or duration.")
  interval(int@start + by, int_end(int) + by)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_standardize
list(`package:lubridate` = function (int) 
{
  negs <- !is.na(int@.Data) & int@.Data < 0
  int[negs] <- int_flip(int[negs])
  int
}, function (int) 
{
  negs <- !is.na(int@.Data) & int@.Data < 0
  int[negs] <- int_flip(int[negs])
  int
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_start
list(`package:lubridate` = function (int) 
  int@start, function (int) 
    int@start)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
int_start<-
  list(`package:lubridate` = function (int, value) 
  {
    value <- as.POSIXct(value)
    span <- as.numeric(int@start + int@.Data - value, "secs")
    equal.lengths <- data.frame(span, value)
    int <- new("Interval", span, start = equal.lengths$value, tzone = int@tzone)
  }, function (int, value) 
  {
    value <- as.POSIXct(value)
    span <- as.numeric(int@start + int@.Data - value, "secs")
    equal.lengths <- data.frame(span, value)
    int <- new("Interval", span, start = equal.lengths$value, tzone = int@tzone)
  })
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
intersect
list(`package:lubridate` = function (x, y, ...) 
  UseMethod("intersect"), `package:base` = function (x, y) 
  {
    if (is.null(x) || is.null(y)) 
      return(NULL)
    u <- as.vector(x)
    v <- as.vector(y)
    c(u[!duplicated(unclass(u)) & (match(u, v, 0) > 0)], v[numeric()])
  }, function (x, y, ...) 
    UseMethod("intersect"), function (x, y) 
    {
      if (is.null(x) || is.null(y)) 
        return(NULL)
      u <- as.vector(x)
      v <- as.vector(y)
      c(u[!duplicated(unclass(u)) & (match(u, v, 0) > 0)], v[numeric()])
    })
c("package:lubridate", "package:base", "namespace:generics", "namespace:base")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
interval
list(`package:lubridate` = function (start = NULL, end = NULL, tzone = tz(start)) 
{
  if (is.character(start) && is.null(end)) {
    return(parse_interval(start, tzone))
  }
  if (length(start) == 0 || length(end) == 0) {
    if (is.null(start) && missing(tzone)) {
      tzone <- "UTC"
    }
    start <- POSIXct(tz = tzone)
    return(new("Interval", numeric(), start = start, tzone = tzone))
  }
  if (is.Date(start)) 
    start <- date_to_posix(start)
  if (is.Date(end)) 
    end <- date_to_posix(end)
  force(tzone)
  start <- as_POSIXct(start, tzone)
  end <- as_POSIXct(end, tzone)
  span <- as.numeric(end) - as.numeric(start)
  starts <- start + rep(0, length(span))
  if (tzone != tz(starts)) 
    starts <- with_tz(starts, tzone)
  new("Interval", span, start = starts, tzone = tzone)
}, function (start = NULL, end = NULL, tzone = tz(start)) 
{
  if (is.character(start) && is.null(end)) {
    return(parse_interval(start, tzone))
  }
  if (length(start) == 0 || length(end) == 0) {
    if (is.null(start) && missing(tzone)) {
      tzone <- "UTC"
    }
    start <- POSIXct(tz = tzone)
    return(new("Interval", numeric(), start = start, tzone = tzone))
  }
  if (is.Date(start)) 
    start <- date_to_posix(start)
  if (is.Date(end)) 
    end <- date_to_posix(end)
  force(tzone)
  start <- as_POSIXct(start, tzone)
  end <- as_POSIXct(end, tzone)
  span <- as.numeric(end) - as.numeric(start)
  starts <- start + rep(0, length(span))
  if (tzone != tz(starts)) 
    starts <- with_tz(starts, tzone)
  new("Interval", span, start = starts, tzone = tzone)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.Date
list(`package:lubridate` = function (x) 
  is(x, "Date"), function (x) 
    is(x, "Date"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.difftime
list(`package:lubridate` = function (x) 
  is(x, "difftime"), function (x) 
    is(x, "difftime"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.duration
list(`package:lubridate` = function (x) 
  is(x, "Duration"), function (x) 
    is(x, "Duration"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.instant
list(`package:lubridate` = function (x) 
  inherits(x, c("POSIXt", "POSIXct", "POSIXlt", "Date")), function (x) 
    inherits(x, c("POSIXt", "POSIXct", "POSIXlt", "Date")))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.interval
list(`package:lubridate` = function (x) 
  is(x, c("Interval")), function (x) 
    is(x, c("Interval")))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.period
list(`package:lubridate` = function (x) 
  is(x, "Period"), function (x) 
    is(x, "Period"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.POSIXct
list(`package:lubridate` = function (x) 
  inherits(x, "POSIXct"), function (x) 
    inherits(x, "POSIXct"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.POSIXlt
list(`package:lubridate` = function (x) 
  inherits(x, "POSIXlt"), function (x) 
    inherits(x, "POSIXlt"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.POSIXt
list(`package:lubridate` = function (x) 
  inherits(x, "POSIXt"), function (x) 
    inherits(x, "POSIXt"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.timepoint
list(`package:lubridate` = function (x) 
  inherits(x, c("POSIXt", "POSIXct", "POSIXlt", "Date")), function (x) 
    inherits(x, c("POSIXt", "POSIXct", "POSIXlt", "Date")))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.timespan
list(`package:lubridate` = function (x) 
  is(x, "Timespan"), function (x) 
    is(x, "Timespan"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
isoweek
list(`package:lubridate` = function (x) 
{
  .other_week(x, 1)
}, function (x) 
{
  .other_week(x, 1)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
isoyear
list(`package:lubridate` = function (x) 
{
  .other_year(x, 1)
}, function (x) 
{
  .other_year(x, 1)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
leap_year
list(`package:lubridate` = function (date) 
{
  if (is.numeric(date)) {
    year <- date
  }
  else {
    year <- year(date)
  }
  (year%%4 == 0) & ((year%%100 != 0) | (year%%400 == 0))
}, function (date) 
{
  if (is.numeric(date)) {
    year <- date
  }
  else {
    year <- year(date)
  }
  (year%%4 == 0) & ((year%%100 != 0) | (year%%400 == 0))
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
local_time
list(`package:lubridate` = function (dt, tz = NULL, units = "secs") 
{
  if (is.null(tz)) 
    tz <- tz(dt)
  if (length(tz) < length(dt)) 
    tz <- rep_len(tz, length(dt))
  else if (length(tz) > length(dt)) {
    attr <- attributes(dt)
    dt <- rep_len(dt, length(tz))
    attributes(dt) <- attr
  }
  secs <- cpp_local_time(as.POSIXct(dt), tz)
  out <- structure(secs, units = "secs", class = "difftime")
  units(out) <- units
  out
}, function (dt, tz = NULL, units = "secs") 
{
  if (is.null(tz)) 
    tz <- tz(dt)
  if (length(tz) < length(dt)) 
    tz <- rep_len(tz, length(dt))
  else if (length(tz) > length(dt)) {
    attr <- attributes(dt)
    dt <- rep_len(dt, length(tz))
    attributes(dt) <- attr
  }
  secs <- cpp_local_time(as.POSIXct(dt), tz)
  out <- structure(secs, units = "secs", class = "difftime")
  units(out) <- units
  out
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
local_time
list(`package:lubridate` = function (dt, tz = NULL, units = "secs") 
{
  if (is.null(tz)) 
    tz <- tz(dt)
  if (length(tz) < length(dt)) 
    tz <- rep_len(tz, length(dt))
  else if (length(tz) > length(dt)) {
    attr <- attributes(dt)
    dt <- rep_len(dt, length(tz))
    attributes(dt) <- attr
  }
  secs <- cpp_local_time(as.POSIXct(dt), tz)
  out <- structure(secs, units = "secs", class = "difftime")
  units(out) <- units
  out
}, function (dt, tz = NULL, units = "secs") 
{
  if (is.null(tz)) 
    tz <- tz(dt)
  if (length(tz) < length(dt)) 
    tz <- rep_len(tz, length(dt))
  else if (length(tz) > length(dt)) {
    attr <- attributes(dt)
    dt <- rep_len(dt, length(tz))
    attributes(dt) <- attr
  }
  secs <- cpp_local_time(as.POSIXct(dt), tz)
  out <- structure(secs, units = "secs", class = "difftime")
  units(out) <- units
  out
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
make_date
list(`package:lubridate` = function (year = 1970, month = 1, day = 1) 
{
  lengths <- vapply(list(year, month, day), length, 1, USE.NAMES = FALSE)
  if (min(lengths) == 0) {
    as.Date(integer(), origin = origin)
  }
  else {
    N <- max(lengths)
    secs <- .Call(C_make_d, rep_len(as.integer(year), N), rep_len(as.integer(month), N), rep_len(as.integer(day), N))
    structure(secs/86400, class = "Date")
  }
}, function (year = 1970, month = 1, day = 1) 
{
  lengths <- vapply(list(year, month, day), length, 1, USE.NAMES = FALSE)
  if (min(lengths) == 0) {
    as.Date(integer(), origin = origin)
  }
  else {
    N <- max(lengths)
    secs <- .Call(C_make_d, rep_len(as.integer(year), N), rep_len(as.integer(month), N), rep_len(as.integer(day), N))
    structure(secs/86400, class = "Date")
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
make_datetime
list(`package:lubridate` = function (year = 1970, month = 1, day = 1, hour = 0, min = 0, sec = 0, tz = "UTC") 
{
  lengths <- vapply(list(year, month, day, hour, min, sec), length, 1, USE.NAMES = FALSE)
  if (min(lengths) == 0) {
    .POSIXct(numeric(), tz = tz)
  }
  else {
    N <- max(lengths)
    cpp_update_dt(dt = .rep_maybe(origin, N), year = .rep_maybe(year, N), month = .rep_maybe(month, N), yday = integer(), mday = .rep_maybe(day, N), wday = integer(), hour = .rep_maybe(hour, N), minute = .rep_maybe(min, N), second = .rep_maybe(sec, N), tz = tz, roll = FALSE, week_start = 7)
  }
}, function (year = 1970, month = 1, day = 1, hour = 0, min = 0, sec = 0, tz = "UTC") 
{
  lengths <- vapply(list(year, month, day, hour, min, sec), length, 1, USE.NAMES = FALSE)
  if (min(lengths) == 0) {
    .POSIXct(numeric(), tz = tz)
  }
  else {
    N <- max(lengths)
    cpp_update_dt(dt = .rep_maybe(origin, N), year = .rep_maybe(year, N), month = .rep_maybe(month, N), yday = integer(), mday = .rep_maybe(day, N), wday = integer(), hour = .rep_maybe(hour, N), minute = .rep_maybe(min, N), second = .rep_maybe(sec, N), tz = tz, roll = FALSE, week_start = 7)
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
make_difftime
list(`package:lubridate` = function (num = NULL, units = "auto", ...) 
{
  pieces <- list(...)
  if (!is.null(num) && length(pieces) > 0) {
    .difftime_from_num(c(num, .difftime_from_pieces(pieces)), units)
  }
  else if (!is.null(num)) {
    .difftime_from_num(num, units)
  }
  else if (length(pieces)) {
    .difftime_from_num(.difftime_from_pieces(pieces), units)
  }
  else {
    stop("No valid values have been passed to 'make_difftime' constructor")
  }
}, function (num = NULL, units = "auto", ...) 
{
  pieces <- list(...)
  if (!is.null(num) && length(pieces) > 0) {
    .difftime_from_num(c(num, .difftime_from_pieces(pieces)), units)
  }
  else if (!is.null(num)) {
    .difftime_from_num(num, units)
  }
  else if (length(pieces)) {
    .difftime_from_num(.difftime_from_pieces(pieces), units)
  }
  else {
    stop("No valid values have been passed to 'make_difftime' constructor")
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
mday
list(`package:lubridate` = function (x) 
  UseMethod("mday"), function (x) 
    UseMethod("mday"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
mday<-
  list(`package:lubridate` = function (x, value) 
  {
    day(x) <- value
    x
  }, function (x, value) 
  {
    day(x) <- value
    x
  })
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
mdy
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx(..., orders = "mdy", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx(..., orders = "mdy", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
mdy_h
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = "mdyr", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = "mdyr", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
mdy_hm
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = "mdyR", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = "mdyR", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
mdy_hms
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = c("mdyTz", "mdyT"), quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = c("mdyTz", "mdyT"), quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
microseconds
list(`package:lubridate` = function (x = 1) 
  seconds(x/1e+06), function (x = 1) 
    seconds(x/1e+06))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
milliseconds
list(`package:lubridate` = function (x = 1) 
  seconds(x/1000), function (x = 1) 
    seconds(x/1000))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
minute
list(`package:lubridate` = function (x) 
  UseMethod("minute"), function (x) 
    UseMethod("minute"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
minute<-
  list(`package:lubridate` = new("standardGeneric", .Data = function (x, value) 
    standardGeneric("minute<-"), generic = "minute<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
      x <- x + minutes(value - minute(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "minute<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
        x <- x + minutes(value - minute(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "minute<-"))(x, value)), new("standardGeneric", .Data = function (x, value) 
          standardGeneric("minute<-"), generic = "minute<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
            x <- x + minutes(value - minute(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "minute<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
              x <- x + minutes(value - minute(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "minute<-"))(x, value)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
minutes
list(`package:lubridate` = function (x = 1) 
  period(minute = x), function (x = 1) 
    period(minute = x))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
month
list(`package:lubridate` = function (x, label = FALSE, abbr = TRUE, locale = Sys.getlocale("LC_TIME")) 
  UseMethod("month"), function (x, label = FALSE, abbr = TRUE, locale = Sys.getlocale("LC_TIME")) 
    UseMethod("month"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
month<-
  list(`package:lubridate` = new("standardGeneric", .Data = function (x, value) 
    standardGeneric("month<-"), generic = "month<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
    {
      if (!is.numeric(value)) {
        value <- pmatch(tolower(value), c("january", "february", "march", "june", "july", "august", "september", "october", "november", "december"))
      }
      x <- x + months(value - month(x))
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "month<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
    {
      if (!is.numeric(value)) {
        value <- pmatch(tolower(value), c("january", "february", "march", "june", "july", "august", "september", "october", "november", "december"))
      }
      x <- x + months(value - month(x))
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "month<-"))(x, value)), new("standardGeneric", .Data = function (x, value) 
      standardGeneric("month<-"), generic = "month<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
      {
        if (!is.numeric(value)) {
          value <- pmatch(tolower(value), c("january", "february", "march", "june", "july", "august", "september", "october", "november", "december"))
        }
        x <- x + months(value - month(x))
      }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "month<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
      {
        if (!is.numeric(value)) {
          value <- pmatch(tolower(value), c("january", "february", "march", "june", "july", "august", "september", "october", "november", "december"))
        }
        x <- x + months(value - month(x))
      }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "month<-"))(x, value)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ms
list(`package:lubridate` = function (..., quiet = FALSE, roll = FALSE) 
{
  out <- .parse_hms(..., order = "MS", quiet = quiet)
  if (roll) {
    hms <- .roll_hms(min = out["M", ], sec = out["S", ])
    period(hour = hms$hour, minute = hms$min, second = hms$sec)
  }
  else {
    period(minute = out["M", ], second = out["S", ])
  }
}, function (..., quiet = FALSE, roll = FALSE) 
{
  out <- .parse_hms(..., order = "MS", quiet = quiet)
  if (roll) {
    hms <- .roll_hms(min = out["M", ], sec = out["S", ])
    period(hour = hms$hour, minute = hms$min, second = hms$sec)
  }
  else {
    period(minute = out["M", ], second = out["S", ])
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
my
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME")) 
  .parse_xxx(..., orders = "my", quiet = quiet, tz = tz, locale = locale, truncated = 0), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME")) 
    .parse_xxx(..., orders = "my", quiet = quiet, tz = tz, locale = locale, truncated = 0))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
myd
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx(..., orders = "myd", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx(..., orders = "myd", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
NA_Date_
list(`package:lubridate` = NA, NA)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
NA_POSIXct_
list(`package:lubridate` = NA, NA)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
nanoseconds
list(`package:lubridate` = function (x = 1) 
  seconds(x/1e+09), function (x = 1) 
    seconds(x/1e+09))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
now
list(`package:lubridate` = function (tzone = "") 
  with_tz(Sys.time(), tzone), function (tzone = "") 
    with_tz(Sys.time(), tzone))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
origin
list(`package:lubridate` = 0, 0)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
parse_date_time
list(`package:lubridate` = function (x, orders, tz = "UTC", truncated = 0, quiet = FALSE, locale = Sys.getlocale("LC_TIME"), select_formats = .select_formats, exact = FALSE, train = TRUE, drop = FALSE) 
{
  if (is.null(tz)) 
    tz <- ""
  if (length(tz) != 1 || is.na(tz)) 
    stop("`tz` argument must be a character of length one")
  orig_locale <- Sys.getlocale("LC_TIME")
  Sys.setlocale("LC_TIME", locale)
  on.exit(Sys.setlocale("LC_TIME", orig_locale))
  x <- as.character(.num_to_date(x))
  if (truncated != 0) 
    orders <- .add_truncated(orders, truncated)
  .local_parse <- function(x, first = FALSE) {
    formats <- if (exact) {
      orders
    }
    else {
      train <- .get_train_set(x)
      .best_formats(train, orders, locale = locale, select_formats, drop = drop)
    }
    if (length(formats) > 0) {
      out <- .parse_date_time(x, formats, tz = tz, quiet = quiet, locale = locale)
      new_na <- is.na(out)
      if (any(new_na)) {
        x <- x[new_na]
        if (length(x) == length(out)) {
          failed <<- length(x)
        }
        else {
          out[new_na] <- .local_parse(x)
        }
      }
      out
    }
    else {
      if (first && !quiet) {
        warning("All formats failed to parse. No formats found.", call. = FALSE)
        warned <<- TRUE
      }
      failed <<- length(x)
      NA
    }
  }
  failed <- 0
  warned <- FALSE
  to_parse <- which(!is.na(x) & nzchar(x))
  out <- .POSIXct(rep.int(NA, length(x)), tz = tz)
  if (length(to_parse)) {
    out[to_parse] <- .local_parse(x[to_parse], TRUE)
    if (failed > 0 && !quiet && !warned) 
      warning(" ", failed, " failed to parse.", call. = FALSE)
  }
  out
}, function (x, orders, tz = "UTC", truncated = 0, quiet = FALSE, locale = Sys.getlocale("LC_TIME"), select_formats = .select_formats, exact = FALSE, train = TRUE, drop = FALSE) 
{
  if (is.null(tz)) 
    tz <- ""
  if (length(tz) != 1 || is.na(tz)) 
    stop("`tz` argument must be a character of length one")
  orig_locale <- Sys.getlocale("LC_TIME")
  Sys.setlocale("LC_TIME", locale)
  on.exit(Sys.setlocale("LC_TIME", orig_locale))
  x <- as.character(.num_to_date(x))
  if (truncated != 0) 
    orders <- .add_truncated(orders, truncated)
  .local_parse <- function(x, first = FALSE) {
    formats <- if (exact) {
      orders
    }
    else {
      train <- .get_train_set(x)
      .best_formats(train, orders, locale = locale, select_formats, drop = drop)
    }
    if (length(formats) > 0) {
      out <- .parse_date_time(x, formats, tz = tz, quiet = quiet, locale = locale)
      new_na <- is.na(out)
      if (any(new_na)) {
        x <- x[new_na]
        if (length(x) == length(out)) {
          failed <<- length(x)
        }
        else {
          out[new_na] <- .local_parse(x)
        }
      }
      out
    }
    else {
      if (first && !quiet) {
        warning("All formats failed to parse. No formats found.", call. = FALSE)
        warned <<- TRUE
      }
      failed <<- length(x)
      NA
    }
  }
  failed <- 0
  warned <- FALSE
  to_parse <- which(!is.na(x) & nzchar(x))
  out <- .POSIXct(rep.int(NA, length(x)), tz = tz)
  if (length(to_parse)) {
    out[to_parse] <- .local_parse(x[to_parse], TRUE)
    if (failed > 0 && !quiet && !warned) 
      warning(" ", failed, " failed to parse.", call. = FALSE)
  }
  out
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
parse_date_time2
list(`package:lubridate` = function (x, orders, tz = "UTC", exact = FALSE, lt = FALSE, cutoff_2000 = 68) 
{
  if (length(tz) != 1 || is.na(tz)) 
    stop("`tz` argument must be a character of length one")
  parse1 <- function(x, order) {
    if (!exact) 
      order <- gsub("[^[:alpha:]]+", "", as.character(order))
    if (lt) {
      .mklt(parse_dt(x, order, exact, TRUE, cutoff_2000), tz)
    }
    else {
      if (is_utc(tz)) {
        .POSIXct(parse_dt(x, order, exact, FALSE, cutoff_2000), tz = "UTC")
      }
      else {
        as.POSIXct(.mklt(parse_dt(x, order, exact, TRUE, cutoff_2000), tz))
      }
    }
  }
  nnas <- !is.na(x)
  out <- parse1(x, orders[[1]])
  for (order in orders[-1]) {
    nnas <- nnas & is.na(out)
    out[nnas] <- parse1(x[nnas], order)
  }
  out
}, function (x, orders, tz = "UTC", exact = FALSE, lt = FALSE, cutoff_2000 = 68) 
{
  if (length(tz) != 1 || is.na(tz)) 
    stop("`tz` argument must be a character of length one")
  parse1 <- function(x, order) {
    if (!exact) 
      order <- gsub("[^[:alpha:]]+", "", as.character(order))
    if (lt) {
      .mklt(parse_dt(x, order, exact, TRUE, cutoff_2000), tz)
    }
    else {
      if (is_utc(tz)) {
        .POSIXct(parse_dt(x, order, exact, FALSE, cutoff_2000), tz = "UTC")
      }
      else {
        as.POSIXct(.mklt(parse_dt(x, order, exact, TRUE, cutoff_2000), tz))
      }
    }
  }
  nnas <- !is.na(x)
  out <- parse1(x, orders[[1]])
  for (order in orders[-1]) {
    nnas <- nnas & is.na(out)
    out[nnas] <- parse1(x[nnas], order)
  }
  out
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
period
list(`package:lubridate` = function (num = NULL, units = "second", ...) 
{
  if (is.character(num)) {
    parse_period(num)
  }
  else {
    out1 <- .period_from_num(num, units)
    out2 <- .period_from_units(list(...))
    if (is.null(out1) && is.null(out2)) 
      new("Period", numeric())
    else if (is.null(out1)) 
      out2
    else if (is.null(out2)) 
      out1
    else c(out1, out2)
  }
}, function (num = NULL, units = "second", ...) 
{
  if (is.character(num)) {
    parse_period(num)
  }
  else {
    out1 <- .period_from_num(num, units)
    out2 <- .period_from_units(list(...))
    if (is.null(out1) && is.null(out2)) 
      new("Period", numeric())
    else if (is.null(out1)) 
      out2
    else if (is.null(out2)) 
      out1
    else c(out1, out2)
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
period_to_seconds
list(`package:lubridate` = function (x) 
{
  x@.Data + 60 * x@minute + 60 * 60 * x@hour + 60 * 60 * 24 * x@day + 60 * 60 * 24 * 365.25/12 * x@month + 60 * 60 * 24 * 365.25 * x@year
}, function (x) 
{
  x@.Data + 60 * x@minute + 60 * 60 * x@hour + 60 * 60 * 24 * x@day + 60 * 60 * 24 * 365.25/12 * x@month + 60 * 60 * 24 * 365.25 * x@year
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
picoseconds
list(`package:lubridate` = function (x = 1) 
  seconds(x/1e+12), function (x = 1) 
    seconds(x/1e+12))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
pm
list(`package:lubridate` = function (x) 
  !am(x), function (x) 
    !am(x))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
POSIXct
list(`package:lubridate` = function (length = 0, tz = "UTC") 
{
  t0 <- if (is_utc(tz)) 
    origin
  else force_tz(origin, tz)
  .POSIXct(rep.int(t0, length), tz = tz)
}, function (length = 0, tz = "UTC") 
{
  t0 <- if (is_utc(tz)) 
    origin
  else force_tz(origin, tz)
  .POSIXct(rep.int(t0, length), tz = tz)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
pretty_dates
list(`package:lubridate` = function (x, n, ...) 
{
  otz <- Sys.getenv("TZ")
  if (Sys.getenv("TZ") == "") 
    otz <- "unset"
  Sys.setenv(TZ = tz(x[1]))
  on.exit(if (otz == "unset") Sys.unsetenv("TZ") else Sys.setenv(TZ = otz))
  rng <- range(x)
  diff <- difftime(rng[2], rng[1], units = "secs")
  binunits <- pretty_unit(diff/n)
  f <- get(paste("pretty", binunits, sep = "_"), mode = "function")
  binlength <- f(diff, n)
  start <- pretty_point(min(rng), binunits, binlength)
  end <- pretty_point(max(rng), binunits, binlength, start = FALSE)
  breaks <- seq.POSIXt(start, end, paste(binlength, binunits))
  breaks
}, function (x, n, ...) 
{
  otz <- Sys.getenv("TZ")
  if (Sys.getenv("TZ") == "") 
    otz <- "unset"
  Sys.setenv(TZ = tz(x[1]))
  on.exit(if (otz == "unset") Sys.unsetenv("TZ") else Sys.setenv(TZ = otz))
  rng <- range(x)
  diff <- difftime(rng[2], rng[1], units = "secs")
  binunits <- pretty_unit(diff/n)
  f <- get(paste("pretty", binunits, sep = "_"), mode = "function")
  binlength <- f(diff, n)
  start <- pretty_point(min(rng), binunits, binlength)
  end <- pretty_point(max(rng), binunits, binlength, start = FALSE)
  breaks <- seq.POSIXt(start, end, paste(binlength, binunits))
  breaks
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
qday
list(`package:lubridate` = function (x) 
  UseMethod("qday"), function (x) 
    UseMethod("qday"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
qday<-
  list(`package:lubridate` = new("standardGeneric", .Data = function (x, value) 
    standardGeneric("qday<-"), generic = "qday<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
      x <- x + days(value - qday(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "qday<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
        x <- x + days(value - qday(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "qday<-"))(x, value)), new("standardGeneric", .Data = function (x, value) 
          standardGeneric("qday<-"), generic = "qday<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
            x <- x + days(value - qday(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "qday<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
              x <- x + days(value - qday(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "qday<-"))(x, value)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
quarter
list(`package:lubridate` = function (x, type = "quarter", fiscal_start = 1, with_year = identical(type, "year.quarter")) 
{
  if (length(fiscal_start) > 1) 
    stop("`fiscal_start` must be a singleton", call. = FALSE)
  fs <- (fiscal_start - 1)%%12
  shifted <- seq(fs, 11 + fs)%%12 + 1
  m <- month(x)
  quarters <- rep(1:4, each = 3)
  s <- match(m, shifted)
  q <- quarters[s]
  if (is.logical(type)) 
    type <- if (type) 
      "year.quarter"
  else "quarter"
  if (with_year == TRUE) 
    type <- "year.quarter"
  switch(type, quarter = q, year.quarter = {
    nxt_year_months <- if (fs != 0) (fs + 1):12
    year(x) + (m %in% nxt_year_months) + (q/10)
  }, date_first = , date_last = {
    starting_months <- shifted[seq(1, length(shifted), 3)]
    final_years <- year(x) - (starting_months[q] > m)
    quarter_starting_dates <- make_date(year = final_years, month = starting_months[q], day = 1)
    if (type == "date_first") {
      quarter_starting_dates
    } else if (type == "date_last") {
      add_with_rollback(quarter_starting_dates, months(3)) - days(1)
    }
  }, stop("Unsuported type ", type))
}, function (x, type = "quarter", fiscal_start = 1, with_year = identical(type, "year.quarter")) 
{
  if (length(fiscal_start) > 1) 
    stop("`fiscal_start` must be a singleton", call. = FALSE)
  fs <- (fiscal_start - 1)%%12
  shifted <- seq(fs, 11 + fs)%%12 + 1
  m <- month(x)
  quarters <- rep(1:4, each = 3)
  s <- match(m, shifted)
  q <- quarters[s]
  if (is.logical(type)) 
    type <- if (type) 
      "year.quarter"
  else "quarter"
  if (with_year == TRUE) 
    type <- "year.quarter"
  switch(type, quarter = q, year.quarter = {
    nxt_year_months <- if (fs != 0) (fs + 1):12
    year(x) + (m %in% nxt_year_months) + (q/10)
  }, date_first = , date_last = {
    starting_months <- shifted[seq(1, length(shifted), 3)]
    final_years <- year(x) - (starting_months[q] > m)
    quarter_starting_dates <- make_date(year = final_years, month = starting_months[q], day = 1)
    if (type == "date_first") {
      quarter_starting_dates
    } else if (type == "date_last") {
      add_with_rollback(quarter_starting_dates, months(3)) - days(1)
    }
  }, stop("Unsuported type ", type))
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
reclass_date
list(`package:lubridate` = function (new, orig) 
  UseMethod("reclass_date", orig), function (new, orig) 
    UseMethod("reclass_date", orig))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
reclass_timespan
list(`package:lubridate` = new("standardGeneric", .Data = function (new, orig) 
  standardGeneric("reclass_timespan"), generic = "reclass_timespan", package = "lubridate", group = list(), valueClass = character(0), signature = c("new", "orig"), default = new("derivedDefaultMethod", .Data = function (new, orig) 
    standardGeneric("reclass_timespan"), target = new("signature", .Data = "ANY", names = "new", package = "methods"), defined = new("signature", .Data = "ANY", names = "new", package = "methods"), generic = "reclass_timespan"), skeleton = (new("derivedDefaultMethod", .Data = function (new, orig) 
      standardGeneric("reclass_timespan"), target = new("signature", .Data = "ANY", names = "new", package = "methods"), defined = new("signature", .Data = "ANY", names = "new", package = "methods"), generic = "reclass_timespan"))(new, orig)), new("standardGeneric", .Data = function (new, orig) 
        standardGeneric("reclass_timespan"), generic = "reclass_timespan", package = "lubridate", group = list(), valueClass = character(0), signature = c("new", "orig"), default = new("derivedDefaultMethod", .Data = function (new, orig) 
          standardGeneric("reclass_timespan"), target = new("signature", .Data = "ANY", names = "new", package = "methods"), defined = new("signature", .Data = "ANY", names = "new", package = "methods"), generic = "reclass_timespan"), skeleton = (new("derivedDefaultMethod", .Data = function (new, orig) 
            standardGeneric("reclass_timespan"), target = new("signature", .Data = "ANY", names = "new", package = "methods"), defined = new("signature", .Data = "ANY", names = "new", package = "methods"), generic = "reclass_timespan"))(new, orig)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
rollback
list(`package:lubridate` = function (dates, roll_to_first = FALSE, preserve_hms = TRUE) 
{
  .roll(dates, roll_to_first, preserve_hms)
}, function (dates, roll_to_first = FALSE, preserve_hms = TRUE) 
{
  .roll(dates, roll_to_first, preserve_hms)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
rollbackward
list(`package:lubridate` = function (dates, roll_to_first = FALSE, preserve_hms = TRUE) 
{
  .roll(dates, roll_to_first, preserve_hms)
}, function (dates, roll_to_first = FALSE, preserve_hms = TRUE) 
{
  .roll(dates, roll_to_first, preserve_hms)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
rollforward
list(`package:lubridate` = function (dates, roll_to_first = FALSE, preserve_hms = TRUE) 
{
  .roll(dates, roll_to_first, preserve_hms, forward = TRUE)
}, function (dates, roll_to_first = FALSE, preserve_hms = TRUE) 
{
  .roll(dates, roll_to_first, preserve_hms, forward = TRUE)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
round_date
list(`package:lubridate` = function (x, unit = "second", week_start = getOption("lubridate.week.start", 7)) 
{
  if (!length(x)) 
    return(x)
  parsed_unit <- parse_period_unit(unit)
  n <- parsed_unit$n
  basic_unit <- standardise_period_names(parsed_unit$unit)
  new <- if (n == 1 && basic_unit %in% c("second", "minute", "hour", "day")) {
    round.POSIXt(as_datetime(x, tz = tz(x)), units = lub2base_units[[basic_unit]])
  }
  else {
    above <- unclass(as.POSIXct(ceiling_date(x, unit = unit, week_start = week_start)))
    mid <- unclass(x)
    below <- unclass(as.POSIXct(floor_date(x, unit = unit, week_start = week_start)))
    wabove <- (above - mid) <= (mid - below)
    wabove <- !is.na(wabove) & wabove
    new <- below
    new[wabove] <- above[wabove]
    .POSIXct(new, tz = tz(x))
  }
  reclass_date_maybe(new, x, unit)
}, function (x, unit = "second", week_start = getOption("lubridate.week.start", 7)) 
{
  if (!length(x)) 
    return(x)
  parsed_unit <- parse_period_unit(unit)
  n <- parsed_unit$n
  basic_unit <- standardise_period_names(parsed_unit$unit)
  new <- if (n == 1 && basic_unit %in% c("second", "minute", "hour", "day")) {
    round.POSIXt(as_datetime(x, tz = tz(x)), units = lub2base_units[[basic_unit]])
  }
  else {
    above <- unclass(as.POSIXct(ceiling_date(x, unit = unit, week_start = week_start)))
    mid <- unclass(x)
    below <- unclass(as.POSIXct(floor_date(x, unit = unit, week_start = week_start)))
    wabove <- (above - mid) <= (mid - below)
    wabove <- !is.na(wabove) & wabove
    new <- below
    new[wabove] <- above[wabove]
    .POSIXct(new, tz = tz(x))
  }
  reclass_date_maybe(new, x, unit)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
second
list(`package:lubridate` = function (x) 
  UseMethod("second"), function (x) 
    UseMethod("second"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
second<-
  list(`package:lubridate` = new("standardGeneric", .Data = function (x, value) 
    standardGeneric("second<-"), generic = "second<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
      x <- x + seconds(value - second(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "second<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
        x <- x + seconds(value - second(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "second<-"))(x, value)), new("standardGeneric", .Data = function (x, value) 
          standardGeneric("second<-"), generic = "second<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
            x <- x + seconds(value - second(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "second<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
              x <- x + seconds(value - second(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "second<-"))(x, value)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
seconds
list(`package:lubridate` = function (x = 1) 
  period(second = x), function (x = 1) 
    period(second = x))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
seconds_to_period
list(`package:lubridate` = function (x) 
{
  span <- as.double(x)
  remainder <- abs(span)
  newper <- period(second = rep(0, length(x)))
  slot(newper, "day") <- remainder%/%(3600 * 24)
  remainder <- remainder%%(3600 * 24)
  slot(newper, "hour") <- remainder%/%(3600)
  remainder <- remainder%%(3600)
  slot(newper, "minute") <- remainder%/%(60)
  slot(newper, ".Data") <- remainder%%(60)
  newper * sign(span)
}, function (x) 
{
  span <- as.double(x)
  remainder <- abs(span)
  newper <- period(second = rep(0, length(x)))
  slot(newper, "day") <- remainder%/%(3600 * 24)
  remainder <- remainder%%(3600 * 24)
  slot(newper, "hour") <- remainder%/%(3600)
  remainder <- remainder%%(3600)
  slot(newper, "minute") <- remainder%/%(60)
  slot(newper, ".Data") <- remainder%%(60)
  newper * sign(span)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
semester
list(`package:lubridate` = function (x, with_year = FALSE) 
{
  m <- month(x)
  semesters <- rep(1:2, each = 6)
  s <- semesters[m]
  if (with_year) 
    year(x) + s/10
  else s
}, function (x, with_year = FALSE) 
{
  m <- month(x)
  semesters <- rep(1:2, each = 6)
  s <- semesters[m]
  if (with_year) 
    year(x) + s/10
  else s
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
setdiff
list(`package:lubridate` = function (x, y, ...) 
  UseMethod("setdiff"), `package:base` = function (x, y) 
  {
    u <- as.vector(x)
    v <- as.vector(y)
    u[!duplicated(unclass(u)) & (match(u, v, 0) == 0)]
  }, function (x, y, ...) 
    UseMethod("setdiff"), function (x, y) 
    {
      u <- as.vector(x)
      v <- as.vector(y)
      u[!duplicated(unclass(u)) & (match(u, v, 0) == 0)]
    })
c("package:lubridate", "package:base", "namespace:generics", "namespace:base")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
show
list(`package:lubridate` = new("standardGeneric", .Data = function (object) 
  standardGeneric("show"), generic = "show", package = "methods", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object) 
    showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"), skeleton = (new("derivedDefaultMethod", .Data = function (object) 
      showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"))(object)), `package:methods` = new("standardGeneric", .Data = function (object) 
        standardGeneric("show"), generic = "show", package = "methods", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object) 
          showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"), skeleton = (new("derivedDefaultMethod", .Data = function (object) 
            showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"))(object)), new("standardGeneric", .Data = function (object) 
              standardGeneric("show"), generic = "show", package = "methods", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object) 
                showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"), skeleton = (new("derivedDefaultMethod", .Data = function (object) 
                  showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"))(object)))
c("package:lubridate", "package:methods", "namespace:methods")
c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, TRUE)
stamp
list(`package:lubridate` = function (x, orders = lubridate_formats, locale = Sys.getlocale("LC_TIME"), quiet = FALSE) 
{
  fmts <- unique(guess_formats(x, orders, locale))
  if (is.null(fmts)) 
    stop("Couldn't guess formats of: ", x)
  if (length(fmts) == 1) {
    FMT <- fmts[[1]]
  }
  else {
    trained <- .train_formats(x, fmts, locale = locale)
    formats <- .select_formats(trained)
    FMT <- formats[[1]]
    if (!quiet && length(trained) > 1) {
      message("Multiple formats matched: ", paste("\"", names(trained), "\"(", trained, ")", sep = "", collapse = ", "))
    }
  }
  if (!quiet) 
    message("Using: \"", FMT, "\"")
  reset_local_expr <- quote({
    old_lc_time <- Sys.getlocale("LC_TIME")
    if (old_lc_time != locale) {
      on.exit(Sys.setlocale("LC_TIME", old_lc_time))
      Sys.setlocale("LC_TIME", locale)
    }
  })
  if (grepl("%O[oOzu]|%z", FMT)) {
    oOz_end <- ifelse(grepl("%O[oOz]$", FMT), gsub("^.*(%O[oOz]$)", "\\1", FMT), rep(NA, length(FMT)))
    if (is.na(oOz_end)) {
      FMT <- sub("%O[oOz]", "%z", sub("%Ou", "Z", FMT, fixed = TRUE))
      eval(bquote(function(x, locale = .(locale)) {
        if (!is_utc(tz(x[[1]]))) 
          x <- with_tz(x, tzone = "UTC")
        .(reset_local_expr)
        format(x, format = .(FMT))
      }))
    }
    else {
      FMT <- sub("%O[oOz]$", "", FMT)
      eval(bquote(function(x, locale = .(locale)) {
        .(reset_local_expr)
        paste0(format(x, format = .(FMT)), .format_offset(x, fmt = .(oOz_end)))
      }))
    }
  }
  else {
    eval(bquote(function(x, locale = .(locale)) {
      .(reset_local_expr)
      format(x, format = .(FMT))
    }))
  }
}, function (x, orders = lubridate_formats, locale = Sys.getlocale("LC_TIME"), quiet = FALSE) 
{
  fmts <- unique(guess_formats(x, orders, locale))
  if (is.null(fmts)) 
    stop("Couldn't guess formats of: ", x)
  if (length(fmts) == 1) {
    FMT <- fmts[[1]]
  }
  else {
    trained <- .train_formats(x, fmts, locale = locale)
    formats <- .select_formats(trained)
    FMT <- formats[[1]]
    if (!quiet && length(trained) > 1) {
      message("Multiple formats matched: ", paste("\"", names(trained), "\"(", trained, ")", sep = "", collapse = ", "))
    }
  }
  if (!quiet) 
    message("Using: \"", FMT, "\"")
  reset_local_expr <- quote({
    old_lc_time <- Sys.getlocale("LC_TIME")
    if (old_lc_time != locale) {
      on.exit(Sys.setlocale("LC_TIME", old_lc_time))
      Sys.setlocale("LC_TIME", locale)
    }
  })
  if (grepl("%O[oOzu]|%z", FMT)) {
    oOz_end <- ifelse(grepl("%O[oOz]$", FMT), gsub("^.*(%O[oOz]$)", "\\1", FMT), rep(NA, length(FMT)))
    if (is.na(oOz_end)) {
      FMT <- sub("%O[oOz]", "%z", sub("%Ou", "Z", FMT, fixed = TRUE))
      eval(bquote(function(x, locale = .(locale)) {
        if (!is_utc(tz(x[[1]]))) 
          x <- with_tz(x, tzone = "UTC")
        .(reset_local_expr)
        format(x, format = .(FMT))
      }))
    }
    else {
      FMT <- sub("%O[oOz]$", "", FMT)
      eval(bquote(function(x, locale = .(locale)) {
        .(reset_local_expr)
        paste0(format(x, format = .(FMT)), .format_offset(x, fmt = .(oOz_end)))
      }))
    }
  }
  else {
    eval(bquote(function(x, locale = .(locale)) {
      .(reset_local_expr)
      format(x, format = .(FMT))
    }))
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
stamp_date
list(`package:lubridate` = function (x, locale = Sys.getlocale("LC_TIME"), quiet = FALSE) 
  stamp(x, orders = c("ymd", "dmy", "mdy", "ydm", "dym", "myd", "my", "ym", "md", "dm", "m", "d", "y"), locale = locale, quiet = quiet), function (x, locale = Sys.getlocale("LC_TIME"), quiet = FALSE) 
    stamp(x, orders = c("ymd", "dmy", "mdy", "ydm", "dym", "myd", "my", "ym", "md", "dm", "m", "d", "y"), locale = locale, quiet = quiet))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
stamp_time
list(`package:lubridate` = function (x, locale = Sys.getlocale("LC_TIME"), quiet = FALSE) 
  stamp(x, orders = c("hms", "hm", "ms", "h", "m", "s"), locale = locale, quiet = quiet), function (x, locale = Sys.getlocale("LC_TIME"), quiet = FALSE) 
    stamp(x, orders = c("hms", "hm", "ms", "h", "m", "s"), locale = locale, quiet = quiet))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
time_length
list(`package:lubridate` = new("standardGeneric", .Data = function (x, unit = "second") 
  standardGeneric("time_length"), generic = "time_length", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "unit"), default = new("derivedDefaultMethod", .Data = function (x, unit = "second") 
  {
    as.duration(x)/duration(num = 1, units = unit)
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "time_length"), skeleton = (new("derivedDefaultMethod", .Data = function (x, unit = "second") 
  {
    as.duration(x)/duration(num = 1, units = unit)
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "time_length"))(x, unit)), new("standardGeneric", .Data = function (x, unit = "second") 
    standardGeneric("time_length"), generic = "time_length", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "unit"), default = new("derivedDefaultMethod", .Data = function (x, unit = "second") 
    {
      as.duration(x)/duration(num = 1, units = unit)
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "time_length"), skeleton = (new("derivedDefaultMethod", .Data = function (x, unit = "second") 
    {
      as.duration(x)/duration(num = 1, units = unit)
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "time_length"))(x, unit)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
today
list(`package:lubridate` = function (tzone = "") 
{
  as_date(now(tzone))
}, function (tzone = "") 
{
  as_date(now(tzone))
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
tz
list(`package:lubridate` = function (x) 
{
  UseMethod("tz")
}, function (x) 
{
  UseMethod("tz")
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
tz<-
  list(`package:lubridate` = function (x, value) 
  {
    force_tz(x, value)
  }, function (x, value) 
  {
    force_tz(x, value)
  })
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
union
list(`package:lubridate` = function (x, y, ...) 
  UseMethod("union"), `package:base` = function (x, y) 
  {
    u <- as.vector(x)
    v <- as.vector(y)
    unique(c(u, v))
  }, function (x, y, ...) 
    UseMethod("union"), function (x, y) 
    {
      u <- as.vector(x)
      v <- as.vector(y)
      unique(c(u, v))
    })
c("package:lubridate", "package:base", "namespace:generics", "namespace:base")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
wday
list(`package:lubridate` = function (x, label = FALSE, abbr = TRUE, week_start = getOption("lubridate.week.start", 7), locale = Sys.getlocale("LC_TIME")) 
  UseMethod("wday"), function (x, label = FALSE, abbr = TRUE, week_start = getOption("lubridate.week.start", 7), locale = Sys.getlocale("LC_TIME")) 
    UseMethod("wday"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
wday<-
  list(`package:lubridate` = function (x, week_start = getOption("lubridate.week.start", 7), value) 
  {
    if (!is.numeric(value)) {
      labels <- .shift_wday_names(c("sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"), week_start)
      value <- pmatch(tolower(value), labels)
    }
    x <- x + days(value - wday(x, week_start = week_start))
  }, function (x, week_start = getOption("lubridate.week.start", 7), value) 
  {
    if (!is.numeric(value)) {
      labels <- .shift_wday_names(c("sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"), week_start)
      value <- pmatch(tolower(value), labels)
    }
    x <- x + days(value - wday(x, week_start = week_start))
  })
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
week
list(`package:lubridate` = function (x) 
  (yday(x) - 1)%/%7 + 1, function (x) 
    (yday(x) - 1)%/%7 + 1)
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
week<-
  list(`package:lubridate` = function (x, value) 
    x <- x + days((value - week(x)) * 7), function (x, value) 
      x <- x + days((value - week(x)) * 7))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
weeks
list(`package:lubridate` = function (x = 1) 
  period(week = x), function (x = 1) 
    period(week = x))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
with_tz
list(`package:lubridate` = function (time, tzone = "") 
{
  if (!C_valid_tz(tzone)) 
    warning(sprintf("Unrecognized time zone '%s'", tzone))
  if (is.data.frame(time)) {
    for (nm in names(time)) {
      if (is.POSIXt(time[[nm]])) {
        time[[nm]] <- .with_tz(time[[nm]], tzone = tzone)
      }
    }
    time
  }
  else {
    .with_tz(time, tzone)
  }
}, function (time, tzone = "") 
{
  if (!C_valid_tz(tzone)) 
    warning(sprintf("Unrecognized time zone '%s'", tzone))
  if (is.data.frame(time)) {
    for (nm in names(time)) {
      if (is.POSIXt(time[[nm]])) {
        time[[nm]] <- .with_tz(time[[nm]], tzone = tzone)
      }
    }
    time
  }
  else {
    .with_tz(time, tzone)
  }
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
yday
list(`package:lubridate` = function (x) 
  UseMethod("yday"), function (x) 
    UseMethod("yday"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
yday<-
  list(`package:lubridate` = function (x, value) 
    x <- x + days(value - yday(x)), function (x, value) 
      x <- x + days(value - yday(x)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ydm
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx(..., orders = "ydm", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx(..., orders = "ydm", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ydm_h
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = "ydmr", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = "ydmr", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ydm_hm
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = "ydmR", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = "ydmR", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ydm_hms
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = c("ydmTz", "ydmT"), quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = c("ydmTz", "ydmT"), quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
year
list(`package:lubridate` = function (x) 
  UseMethod("year"), function (x) 
    UseMethod("year"))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
year<-
  list(`package:lubridate` = new("standardGeneric", .Data = function (x, value) 
    standardGeneric("year<-"), generic = "year<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
    {
      x <- x + years(value - year(x))
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "year<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
    {
      x <- x + years(value - year(x))
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "year<-"))(x, value)), new("standardGeneric", .Data = function (x, value) 
      standardGeneric("year<-"), generic = "year<-", package = "lubridate", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
      {
        x <- x + years(value - year(x))
      }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "year<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
      {
        x <- x + years(value - year(x))
      }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "year<-"))(x, value)))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
years
list(`package:lubridate` = function (x = 1) 
  period(year = x), function (x = 1) 
    period(year = x))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ym
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME")) 
  .parse_xxx(..., orders = "ym", quiet = quiet, tz = tz, locale = locale, truncated = 0), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME")) 
    .parse_xxx(..., orders = "ym", quiet = quiet, tz = tz, locale = locale, truncated = 0))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ymd
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx(..., orders = "ymd", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx(..., orders = "ymd", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ymd_h
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = "ymdr", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = "ymdr", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ymd_hm
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
  .parse_xxx_hms(..., orders = "ymdR", quiet = quiet, tz = tz, locale = locale, truncated = truncated), function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
    .parse_xxx_hms(..., orders = "ymdR", quiet = quiet, tz = tz, locale = locale, truncated = truncated))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
ymd_hms
list(`package:lubridate` = function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
{
  .parse_xxx_hms(..., orders = c("ymdTz", "ymdT"), quiet = quiet, tz = tz, locale = locale, truncated = truncated)
}, function (..., quiet = FALSE, tz = "UTC", locale = Sys.getlocale("LC_TIME"), truncated = 0) 
{
  .parse_xxx_hms(..., orders = c("ymdTz", "ymdT"), quiet = quiet, tz = tz, locale = locale, truncated = truncated)
})
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)
yq
list(`package:lubridate` = function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME")) 
  .parse_xxx(..., orders = "yq", quiet = quiet, tz = tz, locale = locale, truncated = 0), function (..., quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME")) 
    .parse_xxx(..., orders = "yq", quiet = quiet, tz = tz, locale = locale, truncated = 0))
c("package:lubridate", "namespace:lubridate")
c(TRUE, FALSE)
c(FALSE, TRUE)


#########################################################################################################
library(MASS)
.Depends
list(`package:MASS` = c("grDevices", "graphics", "stats", "utils"), `package:lubridate` = "methods")
c("package:MASS", "package:lubridate")
c(TRUE, TRUE)
c(FALSE, FALSE)
abbey
list(`package:MASS` = c(5.2, 6.5, 6.9, 7, 7, 7, 7.4, 8, 8, 8, 8, 8.5, 9, 9, 10, 11, 11, 12, 12, 13.7, 14, 14, 14, 16, 17, 17, 18, 24, 28, 34, 125))
package:MASS
TRUE
FALSE
accdeaths
list(`package:MASS` = c(9007, 8106, 8928, 9137, 10017, 10826, 11317, 10744, 9713, 9938, 9161, 8927, 7750, 6981, 8038, 8422, 8714, 9512, 10120, 9823, 8743, 9129, 8710, 8680, 8162, 7306, 8124, 7870, 9387, 9556, 10093, 9620, 8285, 8466, 8160, 8034, 7717, 7461, 7767, 7925, 8623, 8945, 10078, 9179, 8037, 8488, 7874, 8647, 7792, 6957, 7726, 8106, 8890, 9299, 10625, 9302, 8314, 8850, 8265, 8796, 7836, 6892, 7791, 8192, 9115, 9434, 10484, 9827, 9110, 9070, 8633, 9240))
package:MASS
TRUE
FALSE
addterm
list(`package:MASS` = function (object, ...) 
  UseMethod("addterm"), function (object, ...) 
    UseMethod("addterm"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
Aids2
list(`package:MASS` = list(state = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
                                     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
                                     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
                                     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
                                     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
                                     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
                                     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), sex = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2), diag = c(10905, 11029, 9551, 9577, 10015, 9971, 10746, 10042, 10464, 10439, 10416, 10216, 10385, 10366, 10452, 10552, 10673, 10923, 10993, 11020, 10805, 10996, 10738, 11063, 10885, 11056, 11283, 11195, 10848, 11289, 10961, 11311, 11337, 11458, 11480, 11462, 8302, 8711, 8726, 8760, 8802, 8877, 9011, 8990, 9063, 9003, 9022, 8985, 9030, 9086, 9015, 9009, 8970, 9171, 9087, 9115, 9065, 9104, 9028, 9101, 9096, 9128, 9125, 9083, 9150, 
                                                                                                                                                                             9014, 9157, 9098, 8913, 9141, 9158, 9167, 9244, 9138, 9222, 9272, 9131, 9236, 9145, 8964, 9207, 9240, 9281, 9300, 9294, 9258, 9145, 9310, 9344, 9185, 9247, 9201, 9349, 9246, 9273, 9241, 9264, 9310, 9230, 9361, 9225, 9233, 9413, 9270, 9385, 9272, 9236, 9398, 9347, 9248, 9273, 9470, 9344, 9412, 9334, 9167, 9301, 9378, 9446, 9380, 9401, 9439, 9383, 9369, 9516, 9452, 9267, 9474, 9378, 9301, 9327, 9439, 9534, 9436, 9489, 9429, 9514, 9439, 9555, 9456, 9413, 9419, 9566, 9467, 9525, 9434, 9496, 9512, 9277, 
                                                                                                                                                                             9109, 9510, 9615, 9571, 9462, 9480, 9501, 9501, 9605, 9596, 9585, 9549, 9517, 9636, 9588, 10813, 9485, 9642, 9629, 9639, 9265, 9551, 9655, 9568, 9518, 9684, 9667, 9598, 9552, 9581, 9558, 9693, 9620, 9645, 9572, 9695, 9595, 9689, 9673, 9551, 9606, 9189, 9647, 9682, 9681, 9652, 9697, 9620, 9741, 9596, 9641, 9368, 9713, 9778, 9639, 9625, 9714, 9676, 9700, 9685, 9639, 9694, 9708, 9459, 9619, 9661, 9741, 9744, 9645, 9796, 9719, 9790, 9747, 9780, 9780, 9654, 9700, 9751, 9634, 9656, 9787, 9707, 9734, 9755, 
                                                                                                                                                                             9693, 9726, 9661, 9745, 9742, 9653, 9684, 9841, 9670, 9675, 9790, 9679, 9763, 9999, 9739, 9759, 9839, 9726, 9834, 9873, 9700, 9867, 9701, 9821, 9743, 9758, 9806, 9768, 9845, 9871, 9715, 9787, 9856, 9710, 9834, 9748, 9832, 9763, 9740, 9362, 8945, 9775, 9752, 10604, 9857, 9863, 9824, 9893, 9846, 9813, 9869, 9781, 9864, 9865, 9890, 9893, 9813, 9922, 9888, 9759, 9908, 9835, 9779, 9905, 9858, 9946, 9861, 9873, 9845, 9955, 9892, 9787, 9947, 9950, 9805, 9849, 9877, 9922, 9919, 9455, 9928, 9823, 9782, 9892, 
                                                                                                                                                                             9914, 9867, 10018, 9849, 9828, 9795, 9929, 9911, 9955, 9969, 9988, 9960, 9920, 9868, 9845, 9614, 9925, 9862, 9826, 9936, 9910, 9975, 9901, 9862, 9929, 10010, 9941, 10037, 9992, 10006, 9734, 9924, 10003, 9920, 9948, 9902, 9916, 9856, 10024, 9999, 9892, 9991, 9979, 10018, 9938, 9971, 9966, 9919, 10076, 9947, 9935, 9915, 10041, 10037, 10027, 9931, 10013, 10043, 9948, 9978, 9940, 10001, 9976, 10039, 10062, 10020, 9973, 10090, 10054, 10025, 10092, 10097, 10063, 10028, 9978, 10007, 9926, 9992, 10006, 10128, 
                                                                                                                                                                             10020, 10086, 10116, 10037, 10076, 10083, 10119, 9994, 10111, 10066, 10030, 9966, 10008, 10051, 9955, 10112, 10094, 9988, 10093, 9980, 10149, 10086, 10088, 9976, 10127, 10066, 10033, 10081, 10122, 9890, 10066, 10104, 10162, 9436, 10188, 10007, 10098, 10032, 10064, 9781, 10129, 10033, 9967, 10141, 10085, 10079, 10163, 10095, 10177, 10038, 10069, 10166, 10186, 10200, 10057, 10094, 10098, 10184, 10167, 10053, 10084, 10109, 10101, 9978, 10064, 10088, 10195, 10158, 10136, 10061, 10078, 10187, 10160, 10139, 
                                                                                                                                                                             10205, 10100, 10130, 10708, 10129, 10034, 10171, 10174, 10151, 10211, 10182, 10209, 10119, 9914, 10174, 10173, 10099, 10217, 10218, 10167, 10137, 10215, 10083, 10103, 9637, 10111, 10236, 10268, 10134, 10141, 10191, 9979, 10225, 10241, 10126, 10121, 10262, 10271, 10214, 9555, 10283, 10256, 10283, 10136, 10173, 10062, 10213, 10216, 10249, 10172, 10181, 10163, 10137, 10230, 10203, 10321, 9998, 10252, 10274, 10185, 10218, 10251, 10197, 10175, 10252, 10178, 10262, 10310, 10334, 10275, 10294, 10290, 10172, 
                                                                                                                                                                             10250, 10143, 10169, 10345, 10274, 10146, 10307, 10220, 10264, 10299, 10311, 10304, 10241, 10330, 10217, 10295, 10329, 10212, 10216, 10311, 10365, 10322, 10195, 10350, 10230, 10283, 10318, 10247, 10220, 10380, 10351, 10309, 10291, 10275, 10421, 10423, 10443, 10412, 9707, 10301, 10355, 10145, 10167, 10256, 10336, 10316, 10405, 10255, 10317, 10392, 10314, 10345, 10377, 10424, 10318, 10355, 10254, 10314, 10292, 10315, 10330, 10387, 10424, 10361, 10370, 10435, 10441, 10379, 10364, 10391, 10345, 10384, 
                                                                                                                                                                             10396, 10371, 10460, 10409, 10358, 10435, 10449, 10429, 10448, 10446, 10319, 10351, 10416, 10494, 10509, 10438, 10371, 10384, 10340, 10455, 10457, 10372, 10500, 10372, 10448, 10483, 10466, 10432, 10383, 10482, 10403, 10395, 10521, 10431, 10437, 10330, 10460, 10508, 10418, 10476, 10412, 10521, 10522, 10399, 10431, 10243, 10377, 10488, 10540, 10521, 10403, 10522, 10393, 10432, 10447, 10497, 10459, 10446, 10490, 10519, 10488, 10413, 10424, 10534, 10415, 10566, 10408, 10543, 10419, 10456, 10451, 10551, 
                                                                                                                                                                             10422, 10479, 10537, 10410, 10571, 10424, 10529, 10461, 10571, 10462, 10440, 10461, 10501, 10568, 10448, 10481, 10355, 10289, 10309, 10451, 10430, 10472, 10552, 10539, 10455, 10468, 10512, 10546, 10494, 10509, 10425, 10432, 10591, 10617, 10514, 10478, 10569, 10473, 10092, 10236, 10428, 10532, 10477, 10568, 10500, 10460, 10496, 10546, 10285, 10524, 10163, 10305, 10452, 10525, 10529, 10389, 10572, 10437, 10502, 10511, 10483, 10624, 10516, 10475, 10487, 10592, 10496, 10492, 10551, 10623, 10577, 10528, 
                                                                                                                                                                             10560, 10599, 10498, 10584, 10519, 10083, 10650, 10551, 10576, 10527, 10610, 10515, 10521, 10524, 10588, 10646, 10579, 10643, 10582, 10612, 10515, 10595, 10383, 10568, 10535, 10689, 10570, 10563, 10651, 10595, 10679, 10665, 10566, 10648, 10772, 10676, 10682, 10689, 10196, 10677, 10354, 10621, 10579, 10659, 10671, 10643, 9873, 10681, 10610, 10649, 10632, 10586, 10597, 10680, 10687, 10639, 10645, 10586, 10632, 10646, 10569, 10402, 10647, 10680, 10683, 10636, 10651, 10619, 10629, 10365, 10639, 10463, 
                                                                                                                                                                             10707, 10729, 10724, 10735, 10681, 10620, 10653, 10668, 10741, 10535, 10615, 10636, 10643, 10688, 10706, 10600, 10747, 10629, 10287, 10688, 10468, 10741, 10543, 10698, 10253, 10701, 10547, 10633, 10607, 10587, 10681, 10637, 10628, 10755, 10740, 10806, 10671, 10523, 10670, 10817, 10691, 10639, 10821, 10665, 10717, 10683, 10633, 10715, 10518, 10805, 10757, 10807, 10775, 10758, 10830, 10835, 10776, 10679, 10818, 10585, 10734, 10461, 10350, 10690, 10723, 10782, 10453, 10719, 10830, 10485, 10865, 10746, 
                                                                                                                                                                             10776, 10739, 10737, 10868, 10765, 10799, 10880, 10789, 10743, 10762, 10720, 10840, 10783, 10735, 10793, 10827, 10796, 10802, 10753, 10555, 10802, 10800, 10914, 10860, 10741, 10770, 10777, 10911, 10597, 10767, 10688, 10760, 10136, 10696, 10723, 10840, 10832, 10770, 10837, 10772, 10863, 10583, 10717, 10886, 10757, 10136, 9947, 10929, 10812, 10803, 10917, 10905, 10904, 10707, 10792, 10857, 10951, 10795, 10757, 10801, 10586, 10959, 10928, 10908, 10793, 10875, 10884, 10748, 10880, 10906, 10898, 10967, 
                                                                                                                                                                             10948, 10730, 10549, 10849, 10841, 10921, 10885, 10882, 10820, 10887, 10905, 10262, 10879, 10746, 10696, 10606, 10956, 10830, 10875, 10909, 10944, 10999, 10579, 10856, 10859, 10427, 10806, 10944, 10963, 10982, 10942, 10947, 11018, 10943, 11023, 10976, 10982, 10818, 10796, 10858, 10732, 10739, 10720, 10961, 10565, 10441, 10603, 10917, 10404, 10769, 10727, 10524, 10665, 10735, 10908, 10940, 10795, 10876, 11000, 10209, 10846, 10719, 10896, 10890, 10852, 10945, 10859, 10837, 10857, 10917, 10928, 10862, 
                                                                                                                                                                             10927, 10823, 10936, 10593, 10751, 10531, 10530, 10930, 10872, 10473, 10119, 9741, 10917, 10843, 10673, 10528, 10610, 10217, 10637, 10516, 10639, 10339, 10585, 10404, 10736, 10253, 10958, 10597, 10124, 10672, 10150, 10187, 10416, 10670, 10800, 10904, 10835, 10958, 11046, 10419, 11022, 10501, 10787, 10846, 10410, 10477, 10708, 10386, 9034, 11033, 10640, 10601, 10871, 10766, 10834, 11034, 10860, 10426, 10607, 11017, 10889, 10899, 10977, 10935, 10962, 10690, 10848, 10987, 10963, 11003, 10948, 10977, 
                                                                                                                                                                             10876, 10273, 10990, 11047, 10785, 10491, 10963, 9971, 10960, 10900, 10974, 11028, 11065, 10937, 10863, 10997, 11088, 10894, 10995, 11022, 10950, 10939, 10953, 11036, 10972, 10957, 10938, 11003, 10127, 10492, 11054, 10877, 11063, 10999, 11002, 11034, 11093, 11053, 10793, 11054, 11006, 10859, 11096, 11001, 11125, 11011, 11072, 11120, 11030, 11026, 10405, 10876, 10878, 11043, 11008, 10971, 11053, 11066, 11071, 11058, 11016, 11063, 11074, 11121, 11020, 10770, 10899, 11005, 10781, 10708, 10319, 10175, 
                                                                                                                                                                             11151, 11082, 10984, 11029, 11057, 11110, 11111, 11096, 11158, 11061, 11102, 10919, 10997, 11049, 11131, 11028, 11064, 11092, 10584, 11171, 10759, 10986, 11080, 11167, 11048, 10963, 10978, 10860, 10963, 10917, 10237, 11038, 10936, 10797, 11028, 11036, 10940, 11040, 11085, 10925, 11162, 9933, 10917, 10982, 11000, 11050, 10502, 11107, 10828, 11087, 11134, 10931, 9944, 10715, 10093, 11210, 10286, 11162, 9986, 11054, 10663, 11031, 11130, 10863, 11067, 11164, 11145, 11126, 10616, 10868, 10878, 11122, 
                                                                                                                                                                             10968, 11143, 11102, 11205, 11077, 11094, 11019, 10905, 10104, 10988, 9746, 10309, 10711, 10942, 10955, 11012, 11023, 11154, 11053, 11095, 11073, 11136, 11066, 11109, 11236, 11227, 10345, 11028, 11240, 10724, 11209, 11204, 11214, 10876, 11135, 11148, 10643, 11188, 11223, 11100, 11168, 11204, 11177, 11123, 11258, 11211, 11222, 10991, 11131, 10639, 11025, 11143, 11027, 10921, 11046, 10973, 10402, 11047, 10960, 10355, 10696, 10976, 11003, 10937, 11125, 11146, 10577, 11198, 11118, 11268, 11248, 11282, 
                                                                                                                                                                             11203, 11192, 10989, 11175, 11218, 11247, 11167, 11200, 11238, 11282, 11153, 11060, 11231, 11162, 11239, 11074, 11145, 11283, 11197, 11289, 11171, 10899, 9554, 11149, 11218, 9588, 11026, 11118, 11280, 10751, 11060, 10752, 11276, 11257, 11198, 11172, 11143, 11168, 11263, 11205, 11163, 11174, 11205, 11215, 11178, 11067, 11274, 11128, 10887, 11245, 11054, 11289, 11157, 11147, 11212, 11240, 10808, 11273, 11121, 11190, 11308, 11178, 11205, 11208, 11194, 11276, 11200, 11162, 11266, 11283, 11235, 10995, 
                                                                                                                                                                             11234, 11232, 10730, 11264, 11101, 10927, 11239, 11282, 11324, 11230, 11269, 10308, 10690, 11117, 9470, 11026, 11151, 10431, 10959, 10783, 11066, 11139, 10702, 10859, 10844, 10970, 10583, 11309, 11030, 10811, 11025, 10948, 10949, 11092, 10947, 10503, 11025, 10960, 10985, 11107, 9392, 11228, 10767, 11000, 11240, 11284, 11200, 11155, 10286, 11203, 10965, 11254, 11315, 10991, 11117, 10668, 11245, 11137, 11110, 11178, 11177, 11235, 11143, 11073, 11255, 11035, 11106, 11097, 11187, 11201, 11242, 9270, 
                                                                                                                                                                             11134, 9051, 11158, 11279, 11307, 11218, 11298, 10220, 11125, 11124, 11073, 10601, 10704, 11301, 10463, 11153, 10416, 11071, 11205, 11054, 10515, 10901, 11223, 11284, 11200, 11367, 11233, 11327, 11316, 11205, 11237, 11332, 10859, 11232, 11194, 11301, 11296, 11253, 11343, 11334, 11177, 11218, 11293, 11205, 11318, 11346, 11375, 11292, 11388, 11278, 11223, 11278, 11383, 11337, 11277, 11362, 11336, 11306, 11331, 11352, 11376, 10943, 11223, 11256, 11373, 11321, 11414, 11328, 11263, 11054, 11165, 11399, 
                                                                                                                                                                             11391, 11249, 11337, 11372, 11264, 11360, 11208, 11325, 11309, 11448, 11399, 11358, 11359, 11093, 11335, 11300, 11285, 11316, 11300, 11323, 11365, 11319, 11372, 11334, 11336, 11289, 11324, 11280, 11430, 11280, 11302, 11368, 11298, 11292, 11327, 11230, 11317, 10398, 11254, 11078, 11421, 11441, 11394, 11384, 11453, 11414, 11446, 11472, 11330, 11402, 11168, 11386, 11421, 11434, 11368, 11269, 11313, 11208, 11417, 11332, 11453, 11432, 11362, 11480, 11501, 11399, 11442, 11414, 11407, 11348, 11469, 11108, 
                                                                                                                                                                             11456, 11357, 11106, 10116, 11080, 11458, 11392, 11226, 11490, 11307, 11404, 11351, 11455, 11441, 11469, 11391, 11363, 11407, 11367, 11437, 11411, 11407, 11448, 11477, 11385, 11502, 11092, 11466, 11413, 11503, 11463, 11209, 9310, 9301, 11421, 11454, 11376, 11392, 11437, 11358, 11393, 11493, 11145, 11324, 11401, 11423, 11442, 11287, 11376, 11431, 11394, 11076, 11366, 11484, 11467, 11502, 11423, 11431, 11288, 11484, 11459, 11451, 11438, 11493, 11421, 11501, 11405, 11501, 11498, 11430, 11397, 11372, 
                                                                                                                                                                             11309, 11398, 11404, 11464, 11415, 11414, 11266, 10148, 11492, 11467, 11294, 11304, 11443, 11236, 11325, 11470, 11454, 11435, 11495, 11485, 11301, 11495, 11482, 11406, 11400, 11416, 11369, 11345, 11442, 9209, 11501, 11336, 11484, 11481, 11393, 11315, 11361, 11371, 11470, 11340, 11431, 11433, 11441, 11392, 10387, 11484, 11481, 11202, 11059, 11500, 11407, 11387, 11397, 11295, 11428, 11432, 11410, 11143, 11503, 11492, 11371, 10710, 11431, 11437, 11259, 11086, 11362, 11331, 11342, 11457, 10959, 10943, 
                                                                                                                                                                             11329, 10338, 11258, 11196, 11158, 11212, 10849, 10971, 9353, 11486, 11489, 11046, 9321, 9381, 10745, 11093, 11330, 11379, 11425, 11419, 9023, 8963, 9199, 9167, 9151, 8815, 9194, 9208, 9200, 9235, 9318, 9278, 9384, 9495, 9490, 9316, 9245, 9586, 9652, 9681, 9718, 9730, 10770, 9820, 9728, 9815, 9972, 9868, 9873, 9869, 9905, 9983, 9981, 9912, 9949, 10005, 10051, 9978, 9988, 9750, 10039, 10102, 10228, 10237, 10248, 10122, 10259, 10130, 9454, 9938, 10236, 10330, 10323, 10173, 9765, 10330, 9777, 10280, 
                                                                                                                                                                             10365, 10437, 10338, 10354, 10424, 10329, 10365, 10340, 10689, 10466, 10498, 10553, 10523, 10518, 10557, 10549, 10557, 10269, 10581, 10458, 10611, 10643, 10776, 10633, 10631, 10688, 10570, 10513, 10674, 10680, 10645, 10779, 10674, 10816, 10741, 10662, 10716, 10239, 10772, 10487, 10860, 10723, 10794, 10945, 10841, 10875, 10702, 10765, 10545, 10848, 10826, 10874, 10564, 10396, 10773, 10985, 10328, 11063, 10915, 10369, 10588, 10917, 10568, 10723, 10679, 10751, 10759, 11042, 10897, 10911, 10912, 10995, 
                                                                                                                                                                             11024, 10969, 11106, 11137, 10885, 11075, 11036, 10843, 11061, 11118, 11134, 11160, 11146, 11086, 11031, 11193, 11019, 11054, 11172, 10151, 11241, 11282, 11306, 11258, 11214, 11234, 11008, 11047, 10940, 10989, 11286, 11131, 10934, 11155, 11119, 11218, 10890, 11270, 11033, 11053, 11190, 11012, 11192, 10819, 11070, 11351, 11333, 11089, 11165, 11275, 11392, 11147, 11246, 11277, 11030, 11320, 11344, 11301, 11288, 11275, 10575, 11336, 10400, 11283, 11386, 11312, 11104, 11240, 11426, 11407, 9541, 10385, 
                                                                                                                                                                             10995, 10105, 11402, 11363, 11481, 10574, 10874, 11435, 11429, 11478, 9862, 11455, 11385, 10567, 11481, 11442, 11487, 11185, 11325, 11401, 11502, 11404, 11487, 11335, 9474, 9541, 9691, 9793, 9934, 10035, 10084, 9447, 10106, 10126, 10166, 10091, 9857, 10217, 10236, 10324, 10292, 10308, 10834, 10279, 10413, 10887, 10412, 10370, 10947, 10520, 10456, 10532, 10603, 10570, 10535, 11018, 10534, 10597, 10313, 10689, 10480, 10608, 10665, 10574, 10982, 10916, 10620, 10536, 10611, 10616, 10607, 10702, 10588, 
                                                                                                                                                                             10835, 10808, 10705, 10751, 10779, 10912, 10790, 10847, 10808, 10939, 9276, 10922, 10994, 10938, 11150, 11061, 11161, 11214, 11095, 10953, 10791, 11120, 11152, 10966, 11106, 11138, 11034, 11060, 10865, 10599, 10852, 11274, 11248, 11377, 11272, 11379, 11275, 11364, 11410, 11318, 11376, 11306, 11419, 11320, 11493, 11272, 11500, 11398, 11286, 9159, 11121, 10068, 9968, 10550, 10677, 10797, 10869, 10779, 11032, 11067, 11150, 11166, 11297, 11494, 11287, 8499, 8582, 8720, 8791, 8897, 9016, 9114, 9050, 9055, 
                                                                                                                                                                             9164, 9106, 8974, 9197, 9246, 9271, 9416, 8996, 9499, 9435, 9563, 9568, 9572, 9538, 9637, 9438, 9544, 9512, 9627, 9689, 9624, 9586, 9606, 9582, 9691, 9182, 9668, 9588, 9712, 9636, 9665, 9757, 9767, 9839, 9643, 9678, 9784, 9768, 9804, 9831, 9784, 9750, 9784, 9870, 9779, 9854, 9809, 9755, 9799, 9852, 9936, 9820, 9934, 9824, 9962, 9814, 9977, 9894, 9939, 9937, 9863, 9887, 9940, 9893, 9847, 9999, 9908, 9896, 10121, 9981, 10035, 10084, 10031, 10006, 9957, 9920, 10108, 10047, 10098, 10111, 10027, 10049, 
                                                                                                                                                                             10021, 9872, 9922, 10017, 10079, 10045, 10047, 10103, 10104, 10039, 10125, 10156, 10136, 10132, 10063, 10236, 10225, 10248, 10177, 10182, 10105, 10249, 10138, 10218, 10095, 10099, 10180, 10168, 10238, 10226, 10228, 10102, 10134, 10137, 10123, 10295, 10155, 10294, 10296, 10255, 10208, 10319, 10185, 10230, 10229, 10175, 10267, 10302, 10268, 10194, 10356, 10277, 10246, 10232, 10296, 10304, 10210, 10248, 10373, 10254, 10283, 10373, 10415, 10227, 10341, 10352, 10338, 10254, 10258, 10307, 10295, 10317, 
                                                                                                                                                                             10396, 10309, 10367, 10324, 10451, 10393, 10339, 10388, 10336, 10399, 10348, 10350, 10387, 10352, 10336, 10441, 10397, 10339, 10090, 9977, 10449, 10337, 10331, 10499, 10369, 10467, 10377, 10517, 10446, 10371, 10378, 10348, 10507, 10496, 10433, 10406, 10428, 10422, 10390, 10387, 10508, 10496, 10543, 10490, 10409, 10450, 10436, 10474, 10418, 10447, 10436, 10512, 10514, 10467, 10548, 10423, 10511, 10490, 10579, 10492, 10477, 10564, 10576, 10576, 10478, 10545, 10491, 10994, 10529, 10539, 10653, 10660, 
                                                                                                                                                                             10658, 10669, 10570, 10548, 10572, 10603, 10625, 10559, 10556, 10635, 10482, 10703, 10702, 10591, 10576, 10646, 10636, 10678, 10618, 10621, 10644, 10703, 11051, 10693, 10637, 10531, 10724, 10656, 10693, 10649, 10650, 10702, 9797, 10750, 10630, 10654, 10651, 10676, 10529, 10716, 10488, 10634, 10750, 10637, 10570, 10624, 10706, 10511, 10734, 10761, 10691, 10720, 10775, 10069, 10664, 10592, 10626, 10847, 10412, 10694, 11079, 10774, 10600, 10799, 10765, 10702, 9994, 10758, 10848, 10832, 10774, 10735, 
                                                                                                                                                                             10853, 10774, 10847, 10649, 10705, 10842, 10758, 10825, 10808, 10884, 10924, 10758, 10930, 10933, 10935, 10951, 10782, 10861, 10869, 10868, 10905, 10828, 10825, 10957, 10954, 10854, 10799, 10938, 10813, 10824, 10944, 10829, 10917, 10883, 10826, 10980, 10869, 10460, 10863, 10821, 10904, 10928, 10866, 10924, 10985, 10822, 10851, 10815, 10927, 10960, 10923, 10880, 11126, 10972, 11051, 10979, 10920, 11043, 10975, 10906, 10981, 11028, 11022, 10994, 11030, 10934, 10946, 11058, 11084, 10947, 11011, 11009, 
                                                                                                                                                                             10954, 10984, 11008, 10968, 10960, 11067, 10979, 11036, 11114, 11013, 11127, 11189, 11082, 11114, 11074, 11091, 11102, 11181, 11158, 11175, 11218, 11015, 11202, 11199, 11187, 10866, 11232, 11131, 11067, 11052, 11191, 11053, 9122, 10740, 11142, 11246, 11196, 11225, 10603, 11085, 11181, 11210, 11207, 11177, 11123, 11173, 11262, 10321, 11184, 11085, 11232, 11189, 11178, 11288, 11309, 11277, 11149, 10831, 11213, 11299, 11243, 11259, 11261, 11224, 11221, 11048, 11245, 11253, 11251, 11337, 11313, 11359, 
                                                                                                                                                                             11331, 11349, 10180, 11293, 11258, 11279, 11392, 11343, 11251, 11249, 11404, 11259, 11266, 11376, 11254, 11381, 11345, 11386, 11332, 11294, 11406, 11354, 11410, 11160, 11353, 11236, 11352, 11287, 11473, 11407, 11343, 11285, 11306, 11416, 11120, 11312, 11359, 11300, 11133, 11425, 11435, 11451, 11357, 11436, 11327, 11491, 11394, 11426, 11360, 11454, 11416, 11459, 11466, 11334, 11402, 11373, 11426, 11404, 11366, 11346, 11378, 11387, 11491, 11403, 11393, 11425, 11363, 11444, 11454, 11492, 11202, 11170, 
                                                                                                                                                                             11333, 11498, 11502, 11373, 11370, 11406, 11478, 11464, 11454, 11408, 11477, 11470, 11405, 11501, 11461, 11448, 11232, 11464, 11469, 11473, 11472, 11300, 11495, 11467, 11167, 10871, 11374, 11440, 11285, 11300, 11310, 10908, 11478, 11418, 10647, 11291, 11368, 11398, 11419, 11236, 10937, 11483, 11204, 11478, 11295, 10934, 10749, 11489, 11205, 11429, 11303, 11487, 11181, 11312, 11369, 10826, 9387, 11482, 11262, 10921, 10044, 11284, 11368, 10240, 10133, 8816, 8865, 8931, 9216, 9294, 9402, 9504, 9544, 
                                                                                                                                                                             9526, 9494, 9256, 9703, 9712, 9626, 9843, 9828, 9810, 9733, 9855, 9797, 9911, 9868, 9915, 9911, 9910, 10033, 9947, 10081, 10691, 10176, 10180, 10257, 10297, 10201, 10336, 10312, 10451, 10409, 10367, 10429, 10322, 10478, 10474, 10375, 10478, 10434, 10532, 10519, 10472, 10545, 10494, 10546, 10670, 10603, 10597, 10661, 10758, 10627, 10444, 10745, 10679, 10735, 10633, 10873, 10728, 10646, 10726, 10807, 10794, 10777, 10767, 10810, 10822, 10826, 10829, 10944, 10746, 10930, 10850, 10936, 10997, 10924, 11003, 
                                                                                                                                                                             11032, 11094, 11020, 10916, 10655, 11106, 11080, 10983, 11162, 11133, 11111, 11087, 11228, 11011, 11232, 11243, 11173, 11156, 11125, 11226, 10159, 10725, 9644, 10584, 11356, 11348, 11302, 11388, 11338, 9939, 11111, 11190, 11419, 11265, 11311, 11297, 11385, 11339, 11359, 11475, 11420, 11496, 11460, 11448), death = c(11081, 11096, 9983, 9654, 10290, 10344, 11135, 11069, 10956, 10873, 10432, 10524, 10477, 10631, 11504, 10684, 11200, 11504, 11504, 11171, 10877, 11504, 11504, 11504, 11196, 11504, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11504, 11312, 11504, 11463, 11504, 11504, 8469, 8850, 9254, 8959, 8879, 9180, 9696, 9175, 9172, 9109, 9218, 9254, 9781, 9314, 9943, 9350, 9240, 9309, 9598, 9686, 9262, 9126, 9532, 9268, 9226, 9660, 9207, 9682, 9285, 9152, 9962, 9418, 9082, 9222, 9920, 10461, 9379, 9565, 9536, 9290, 9392, 10013, 9250, 9300, 9768, 9447, 9723, 9736, 10070, 9259, 9436, 9533, 11320, 9214, 9549, 9315, 9392, 9956, 10018, 9576, 9451, 9730, 9501, 10046, 9318, 9304, 9986, 10237, 9600, 9380, 10738, 9782, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          9639, 9630, 10295, 9489, 9705, 9457, 9615, 9492, 9462, 9684, 10717, 9763, 9604, 9695, 10679, 9448, 9532, 9561, 9964, 9827, 9757, 9355, 9757, 9449, 9579, 9452, 9870, 9735, 9812, 9518, 11504, 9525, 9434, 9893, 9592, 9518, 9831, 9543, 9617, 9532, 9595, 9388, 9584, 9945, 9816, 9999, 10565, 9507, 9791, 9857, 9936, 9613, 9607, 9956, 9651, 10976, 10813, 10171, 9887, 9833, 9957, 9525, 9843, 9997, 9637, 9773, 11504, 9749, 10623, 9932, 9606, 9848, 9877, 9934, 9945, 9741, 11504, 10154, 10136, 9880, 9591, 10045, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          9700, 9718, 9791, 11504, 9683, 9867, 9677, 11504, 9851, 9843, 9612, 9827, 10007, 9875, 9642, 10029, 9905, 9767, 9733, 11234, 9855, 9850, 11095, 9756, 9980, 10625, 10007, 11504, 9863, 10690, 9918, 9886, 10022, 10104, 10040, 10562, 10123, 10048, 10109, 9879, 10254, 11504, 9857, 9752, 9741, 9847, 11504, 9743, 11504, 11504, 9849, 9687, 10364, 9840, 9694, 9997, 10419, 10181, 9767, 10419, 9810, 10260, 10135, 10072, 9961, 9874, 10256, 9908, 10387, 9925, 9945, 10671, 10007, 9736, 9798, 10671, 9725, 10040, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          9872, 10340, 10005, 9748, 9362, 8945, 9801, 10245, 10682, 10351, 9912, 10890, 10000, 9933, 10321, 10349, 11398, 10257, 9985, 10059, 9893, 9867, 10352, 11064, 9897, 10095, 10128, 9888, 10142, 9976, 10188, 10557, 9891, 10672, 10058, 11504, 9806, 10157, 10012, 10294, 9926, 10081, 10050, 10171, 10212, 10164, 10505, 10000, 11504, 11504, 9923, 10217, 10066, 9840, 9796, 10038, 10028, 10173, 11504, 10583, 10428, 10344, 10119, 9847, 9930, 10407, 11074, 10010, 10156, 10127, 9984, 10674, 9955, 10669, 10293, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          9944, 10046, 10577, 10147, 10037, 10859, 10236, 10051, 10382, 9999, 10246, 9894, 10075, 10116, 10309, 10501, 10125, 10660, 10780, 9993, 10441, 10439, 10088, 10916, 10061, 10101, 11026, 10039, 10409, 10660, 10961, 10809, 10587, 10260, 10747, 10439, 10264, 10466, 10069, 11081, 11054, 10513, 10930, 10354, 10092, 10116, 10760, 11504, 10539, 10161, 10532, 10594, 10816, 10256, 10340, 10939, 10622, 10742, 11001, 10551, 10147, 10615, 10113, 10322, 10242, 10792, 10024, 10689, 9959, 10117, 10762, 10466, 10103, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          10318, 10466, 10755, 10708, 9982, 10468, 10859, 10288, 10560, 10374, 10046, 10625, 10426, 10869, 10938, 10210, 11504, 10260, 10967, 11504, 9793, 10139, 10507, 11380, 11504, 10441, 10881, 11382, 10844, 10682, 10174, 10167, 10631, 10321, 10395, 10081, 10490, 10462, 10367, 10447, 11350, 10423, 10942, 11504, 10990, 10212, 10611, 10905, 11237, 10936, 11094, 10636, 10787, 10965, 10594, 10868, 11032, 10239, 10765, 11504, 11504, 10668, 10302, 10535, 11504, 10206, 11504, 10515, 10122, 10315, 10260, 10111, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11066, 10730, 10563, 10186, 11165, 10266, 10297, 9684, 10495, 10397, 11504, 10678, 10705, 11504, 10336, 10362, 10276, 11504, 10641, 10839, 10273, 10232, 10153, 10944, 10704, 10924, 10678, 10860, 10999, 10735, 10325, 10299, 10174, 10184, 10284, 11504, 10717, 10903, 11504, 10032, 10498, 10699, 11237, 11504, 11504, 11504, 10472, 10261, 11504, 10825, 10814, 10469, 11285, 10642, 10827, 11041, 11254, 10349, 10462, 11071, 10897, 10423, 11129, 11504, 10559, 10735, 10471, 10312, 11504, 10939, 11095, 10315, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 10571, 10404, 11372, 10776, 11328, 11133, 11471, 11504, 10705, 10655, 10727, 11504, 11504, 10990, 11504, 11504, 11265, 11504, 10893, 10788, 10372, 11504, 10371, 10755, 10883, 11229, 10714, 11041, 11112, 11415, 10376, 10657, 10375, 11054, 10940, 10446, 10365, 10355, 11504, 11504, 11068, 10775, 11504, 10785, 10904, 11039, 10603, 10927, 10512, 11504, 11191, 11504, 10458, 11182, 10794, 10626, 10479, 10762, 11007, 10736, 10860, 11376, 10583, 11062, 10319, 10351, 11504, 11336, 11370, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          10457, 10405, 10911, 10902, 10582, 10577, 10949, 11504, 10831, 11094, 10488, 10778, 10815, 11115, 10711, 10782, 10794, 10836, 10846, 11504, 10492, 10630, 11044, 11504, 11504, 10819, 11504, 11390, 10676, 10639, 10487, 10965, 11239, 10634, 11031, 11098, 11262, 11504, 11169, 10799, 10957, 10996, 11277, 10586, 11014, 10711, 10949, 11009, 11504, 11092, 10881, 11213, 10850, 11156, 10816, 11504, 10737, 11053, 10744, 10736, 10873, 10924, 10597, 10825, 11109, 10912, 10832, 10626, 10505, 11180, 11078, 10690, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11168, 11504, 11052, 10577, 11504, 11075, 10594, 10929, 10744, 11285, 11284, 11504, 10862, 10919, 11369, 10977, 10635, 10949, 11504, 10894, 10886, 10621, 11504, 10959, 10962, 10669, 11504, 11504, 11504, 11373, 11504, 11109, 10840, 11227, 11205, 10868, 11504, 11504, 10608, 10868, 10666, 11288, 11197, 10640, 11137, 11128, 11188, 11504, 11078, 10668, 11504, 10553, 11504, 11172, 11504, 11051, 10758, 10830, 11238, 10865, 10884, 11236, 11312, 11495, 11144, 10706, 10932, 10770, 10538, 11215, 10746, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11024, 10671, 11339, 10839, 11037, 10953, 11504, 10986, 11504, 11504, 11504, 11232, 10821, 11504, 10861, 11504, 11504, 11221, 11504, 11195, 11504, 11038, 10582, 11344, 11307, 11291, 10585, 11007, 10783, 11504, 11033, 10716, 11061, 10705, 11005, 11504, 11504, 11370, 11504, 11347, 10949, 10743, 11318, 11283, 11504, 10545, 11504, 10832, 10717, 11368, 11062, 11339, 10781, 10963, 11157, 10795, 11504, 10952, 11504, 10825, 10789, 10948, 10961, 10805, 10747, 10565, 11504, 11286, 10788, 11226, 11504, 11288, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11374, 11504, 11504, 10949, 11187, 10807, 11504, 11504, 11337, 10873, 10997, 11129, 11504, 11422, 11213, 11287, 10755, 10767, 11072, 11242, 11339, 11220, 11244, 11504, 11454, 10822, 10674, 11058, 11026, 11504, 10731, 10648, 10974, 11050, 11057, 10958, 11504, 11100, 11464, 10786, 11026, 10841, 10831, 11367, 11504, 11504, 11504, 11377, 10831, 11044, 11472, 11114, 10724, 11317, 11203, 11205, 11430, 11504, 11200, 11475, 11504, 11108, 11302, 11504, 10763, 10983, 11439, 11443, 11504, 11150, 10868, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 10927, 10754, 11158, 11275, 10963, 11057, 11504, 10909, 11504, 11504, 11504, 11504, 11504, 10944, 11163, 10848, 11069, 10868, 11289, 11504, 10967, 11504, 11249, 11504, 10983, 11504, 10964, 11504, 11435, 10793, 11242, 11304, 10876, 11504, 11504, 11116, 10889, 11326, 11499, 11504, 10852, 11141, 10951, 10820, 11504, 11178, 11012, 10803, 10950, 10900, 11014, 11504, 11099, 11323, 11504, 11504, 11504, 11504, 10868, 11109, 11016, 11504, 11244, 11504, 11504, 11411, 10890, 11095, 10888, 11504, 11419, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11103, 10987, 10881, 11504, 11183, 11217, 10899, 11504, 11051, 10956, 11002, 11479, 11504, 11504, 11504, 11123, 11140, 11504, 11069, 11098, 11252, 11504, 11504, 11157, 11504, 10975, 11198, 11463, 11235, 11504, 11504, 11374, 10954, 11345, 10912, 10902, 10970, 11504, 11319, 10996, 10800, 10912, 11380, 10565, 10878, 11243, 11138, 10894, 11120, 10952, 11504, 11045, 11198, 11408, 11504, 11094, 11504, 11504, 11504, 10803, 10982, 11379, 11447, 11504, 10932, 11504, 10869, 11504, 10998, 11267, 11209, 11169, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11090, 11462, 10674, 11038, 11504, 10690, 10885, 10438, 11173, 10560, 11179, 11366, 10679, 11504, 10865, 10803, 11504, 11237, 10812, 11213, 11504, 11457, 11504, 11504, 11504, 11504, 11480, 10847, 11504, 11075, 11504, 10402, 11504, 11504, 11504, 11251, 10904, 11255, 11504, 11504, 11504, 11267, 11504, 11026, 11504, 11273, 11504, 11504, 11096, 11495, 11122, 11056, 11504, 11053, 11277, 11504, 11292, 11504, 11037, 11504, 11504, 11504, 11110, 11504, 11043, 10914, 11504, 11504, 11504, 11504, 11504, 11181, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 10945, 11243, 11504, 11018, 11380, 11504, 11504, 11504, 11504, 10945, 11504, 10127, 10984, 11504, 11504, 11504, 11504, 11504, 11159, 11246, 11504, 11195, 11167, 11504, 11011, 11504, 11327, 11504, 11101, 11504, 11504, 11504, 11047, 11405, 11504, 11504, 11499, 11504, 11156, 11504, 11504, 11265, 11504, 11504, 11088, 11087, 11502, 11504, 11001, 11001, 11450, 10817, 10917, 10640, 10909, 11441, 11504, 11504, 11504, 11504, 11504, 11504, 11481, 11504, 11504, 11504, 11185, 11504, 11504, 11347, 11163, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11067, 11504, 10602, 11391, 11504, 11239, 11504, 11504, 11504, 11501, 11236, 11256, 11504, 11504, 11087, 11130, 11504, 11504, 11504, 11504, 11432, 11504, 11504, 11504, 11504, 10028, 11504, 11504, 11462, 11097, 11504, 11504, 11504, 11208, 11504, 10951, 10033, 11504, 10579, 11504, 10347, 11504, 9987, 11504, 11504, 11455, 11402, 11504, 11465, 11504, 11504, 11328, 11504, 11504, 11504, 11152, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 10207, 11491, 9817, 10448, 10770, 11034, 11207, 11102, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11054, 11504, 11250, 11504, 11194, 11481, 11504, 11504, 11504, 11504, 11352, 11504, 11504, 11504, 11412, 11217, 11504, 11504, 11504, 11504, 11275, 11504, 11245, 11234, 11348, 11504, 11186, 11418, 11504, 11504, 11504, 11504, 11504, 11504, 11227, 11504, 11504, 10930, 11504, 11504, 10544, 11147, 11065, 10797, 11504, 11090, 11504, 11133, 11441, 11361, 11190, 11237, 11164, 11388, 11504, 11504, 11504, 11504, 11234, 11206, 11504, 11423, 11320, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11504, 11431, 11504, 9569, 11504, 11504, 9598, 11504, 11441, 11375, 11504, 11504, 10752, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11235, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11385, 11504, 11381, 11343, 11504, 11322, 11504, 11485, 11504, 11295, 11504, 11138, 11191, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11322, 11384, 11036, 11504, 11504, 10934, 11504, 11504, 11504, 11443, 11504, 11504, 11504, 11504, 11410, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 10813, 11258, 11504, 11504, 11504, 11504, 11504, 11123, 11504, 10706, 11504, 11102, 11252, 11504, 11307, 11504, 11490, 11242, 11197, 11504, 11504, 11504, 11108, 11504, 11504, 11399, 11081, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11289, 11337, 11251, 11504, 11105, 11504, 11504, 11148, 11504, 11504, 11504, 11504, 9274, 11154, 11504, 11504, 11504, 11421, 11376, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11163, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11278, 11504, 11453, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11327, 11504, 11504, 11504, 11504, 11504, 11346, 11504, 11504, 11504, 11504, 11442, 11504, 11504, 11504, 11504, 11504, 11443, 11504, 11504, 11504, 11504, 11504, 11504, 11423, 11504, 11275, 11331, 11504, 11504, 11504, 11504, 11504, 11264, 11425, 11504, 11504, 11504, 11504, 11504, 11493, 11504, 11401, 11487, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11363, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11454, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11220, 11504, 11504, 11504, 11504, 11504, 11504, 11463, 11498, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11480, 11504, 11504, 11504, 11291, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11416, 11467, 11424, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11391, 11504, 11504, 11504, 11504, 11370, 9788, 9301, 11450, 11504, 11504, 11504, 11504, 11378, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11446, 11377, 11431, 11504, 11504, 11446, 11504, 11504, 11504, 11504, 11504, 11370, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11424, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11433, 11398, 11504, 11478, 11447, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11504, 11504, 11504, 11504, 11420, 11504, 11504, 11501, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11443, 11504, 11413, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11300, 11504, 11504, 11450, 11504, 11504, 11504, 11504, 11504, 11504, 11370, 11504, 11504, 11379, 11453, 11504, 11504, 11504, 11504, 11504, 9424, 10745, 11242, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11504, 9039, 8979, 9215, 9176, 9956, 8815, 9239, 9224, 9308, 9654, 9395, 9994, 9673, 9753, 9567, 9788, 9381, 9877, 10236, 9696, 10754, 9777, 11504, 9820, 11504, 9892, 10518, 9881, 10028, 10033, 10801, 10003, 10928, 9967, 9989, 10891, 11052, 9980, 10049, 9752, 10862, 10792, 10509, 11504, 11504, 10466, 10261, 10834, 9590, 10011, 11139, 11167, 10523, 11031, 10059, 10345, 11276, 10718, 10996, 11115, 10758, 10583, 10518, 11044, 11504, 10513, 11504, 10480, 10733, 11381, 11504, 10928, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11122, 10556, 10560, 10272, 10748, 10731, 11469, 10831, 11504, 11504, 10633, 11418, 10914, 11093, 11504, 10879, 11338, 10839, 11446, 11225, 11220, 10757, 11504, 10789, 10779, 10903, 10908, 10729, 11150, 10953, 11193, 11504, 11188, 10799, 10884, 10998, 10856, 11191, 10957, 10963, 11414, 11180, 11001, 11504, 11504, 11504, 11299, 11108, 11436, 11208, 11269, 11476, 10988, 11504, 10901, 11504, 11504, 11262, 11504, 11504, 11504, 11142, 11084, 11504, 11504, 11330, 11504, 11334, 11504, 11504, 11504, 11186, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11155, 11211, 11198, 11089, 11504, 11154, 11241, 11504, 11504, 11504, 11230, 11504, 11504, 11504, 11213, 11504, 11462, 11437, 11392, 11504, 11504, 11481, 11441, 11504, 11443, 11504, 11392, 11504, 11504, 11174, 11504, 11410, 11392, 11504, 11504, 11285, 11504, 11504, 11282, 11504, 11504, 11334, 11504, 11344, 11504, 11275, 11189, 11504, 11485, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11007, 10537, 11504, 11504, 11504, 10933, 11504, 11449, 11504, 11479, 10777, 11504, 11504, 10954, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11442, 10319, 9741, 10050, 9799, 10509, 10280, 10506, 9447, 10223, 10596, 10454, 10508, 9997, 11015, 10896, 10470, 10330, 10615, 10838, 10392, 10611, 11504, 10988, 10881, 11504, 11304, 11138, 10766, 10614, 11259, 11504, 11504, 10841, 11018, 10636, 11066, 11039, 10820, 11367, 11504, 11504, 11334, 11079, 10644, 10846, 11504, 11358, 11504, 11504, 11418, 11504, 11187, 11376, 10896, 11501, 11504, 11132, 11504, 11504, 11504, 11268, 11088, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11280, 11243, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11357, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 9163, 11504, 11005, 10333, 11052, 11400, 10944, 11504, 11504, 11415, 11091, 11450, 11504, 11504, 11504, 11504, 8568, 8630, 9045, 8992, 9084, 9026, 10002, 9075, 9394, 10428, 9435, 9140, 9561, 9405, 9641, 9773, 10760, 10450, 9940, 9995, 9584, 9572, 9860, 9655, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          10680, 11477, 9942, 9741, 10193, 9653, 11504, 9852, 9965, 10183, 11434, 9726, 9998, 9735, 9638, 9665, 9771, 10026, 10820, 10000, 9878, 9891, 9777, 11504, 9869, 10000, 9943, 10515, 10333, 10722, 10011, 10001, 9876, 10659, 10411, 10237, 10321, 10905, 9830, 10814, 10140, 10194, 10811, 10838, 10601, 10138, 10237, 10451, 10815, 10119, 10942, 11030, 9911, 11414, 10269, 11025, 10979, 10668, 10631, 10695, 10598, 10717, 10796, 10403, 11504, 10384, 10788, 10460, 9905, 10010, 10861, 10696, 10703, 11148, 11108, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          10478, 10079, 11283, 11174, 10362, 11503, 10480, 11249, 10764, 10298, 11085, 10815, 10785, 11277, 11504, 11283, 10143, 10151, 10882, 10442, 10251, 10565, 10973, 10102, 10258, 10137, 10362, 10550, 10741, 10355, 10987, 10559, 10715, 10760, 10367, 10997, 10363, 10761, 10930, 10303, 11099, 10593, 11236, 10633, 11504, 10882, 11022, 11477, 10752, 10891, 11029, 10287, 10606, 10390, 10675, 11247, 11503, 10354, 11100, 11137, 10635, 10642, 10356, 10728, 11130, 10594, 10739, 11035, 10949, 11504, 11499, 11492, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          10719, 11019, 10899, 10907, 10774, 10487, 11116, 10610, 11015, 10376, 10402, 10539, 11504, 10984, 11504, 10990, 11133, 11029, 11189, 10522, 10644, 11504, 10640, 10422, 11504, 10654, 11504, 10468, 10821, 11433, 10423, 10843, 11161, 11504, 10936, 10753, 10888, 11170, 10450, 11491, 10947, 10761, 10595, 10567, 10972, 10907, 11504, 10949, 10642, 11123, 10743, 11301, 11331, 11315, 11504, 11119, 10604, 11082, 11315, 11105, 11504, 10726, 10909, 11504, 10672, 11270, 10573, 10823, 11322, 11238, 11504, 10630, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11277, 10881, 11153, 11276, 10956, 11278, 10989, 11504, 11504, 11161, 11375, 11504, 11460, 11105, 11075, 11122, 11140, 10929, 10865, 10662, 11504, 11034, 10855, 11409, 10218, 10947, 11305, 11504, 10906, 11405, 11148, 11504, 10632, 11367, 11504, 10980, 10761, 11105, 11181, 10677, 11504, 11170, 11251, 11504, 11504, 11504, 11421, 11504, 11200, 10851, 10833, 11037, 11504, 10795, 11504, 11435, 11117, 11504, 10611, 11504, 11100, 11450, 11162, 11504, 10980, 11504, 11504, 11407, 11477, 11377, 11097, 11500, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11440, 11504, 11504, 10994, 11504, 11273, 10982, 11504, 11472, 11504, 11504, 11504, 10916, 10913, 11248, 11504, 11447, 11163, 11504, 11504, 10938, 11142, 11504, 10996, 11289, 11504, 10909, 11471, 11199, 10828, 11504, 11182, 11504, 11504, 11402, 11504, 11504, 11504, 11239, 11504, 11504, 11504, 11444, 11107, 11504, 11423, 11307, 11004, 11418, 11202, 11504, 11141, 11480, 11504, 11037, 11504, 11504, 11351, 11421, 11133, 11479, 10954, 11504, 11491, 11142, 11504, 11504, 11186, 11504, 11504, 11504, 11339, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11168, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11380, 11183, 11504, 11143, 11504, 11504, 11504, 11184, 11323, 11255, 11504, 11124, 11504, 11082, 9516, 10754, 11504, 11504, 11504, 11504, 11504, 11475, 11223, 11369, 11504, 11504, 11504, 11504, 11504, 11345, 11504, 11234, 11504, 11504, 11178, 11504, 11504, 11504, 11504, 11185, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11326, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11323, 11504, 11504, 11504, 11504, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11504, 11504, 11504, 11292, 11504, 11504, 11504, 11451, 11504, 11462, 11504, 11504, 11504, 11504, 11504, 11396, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11327, 11504, 11504, 11416, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11489, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11413, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11437, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 11504, 11504, 11504, 11504, 11504, 11456, 11366, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 11504, 10871, 11504, 11504, 11504, 11504, 11349, 11504, 11504, 11504, 11504, 11504, 11472, 11504, 11504, 11378, 11504, 11504, 11504, 11504, 11504, 11504, 11278, 11504, 11504, 11504, 11406, 11504, 11504, 11504, 11504, 10984, 11504, 11504, 11504, 11504, 11504, 11504, 11368, 10628, 10738, 9310, 9215, 9343, 9232, 11504, 11504, 9939, 9933, 9796, 9501, 9698, 11504, 11410, 9693, 10156, 10352, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 9825, 10446, 10421, 10720, 10131, 9920, 10099, 10001, 10557, 9961, 10503, 11024, 10944, 11089, 10865, 10300, 10553, 10900, 11219, 11504, 11504, 10773, 11504, 10456, 11116, 10997, 10827, 10677, 11008, 11504, 11504, 11504, 11162, 11140, 10833, 11039, 11135, 11157, 11504, 11504, 11358, 10958, 11504, 11504, 10743, 10724, 11504, 11504, 11504, 11504, 11504, 10797, 11436, 10913, 10988, 11504, 11504, 10961, 11374, 10746, 11504, 11063, 11307, 11073, 11504, 11504, 11191, 11504, 11236, 11504, 11468, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          11504, 11504, 10984, 11163, 11134, 11451, 11088, 11504, 11162, 11504, 11494, 11504, 11504, 11504, 11309, 10669, 10783, 10264, 10594, 11504, 11504, 11332, 11504, 11504, 11252, 11382, 11268, 11504, 11504, 11311, 11504, 11504, 11444, 11504, 11504, 11504, 11504, 11504, 11504), status = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 1, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 2, 1, 2, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 2, 2, 1, 2, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 2, 2, 1, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 1, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1), T.categ = c(1, 1, 1, 5, 1, 1, 8, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 4, 3, 1, 5, 1, 4, 1, 7, 3, 6, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 6, 1, 6, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 8, 1, 1, 6, 1, 1, 1, 1, 5, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 6, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 8, 1, 6, 6, 6, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 6, 1, 1, 3, 1, 6, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 6, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 5, 1, 6, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 8, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 8, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 5, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 6, 1, 1, 1, 7, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 4, 6, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             4, 1, 1, 1, 1, 1, 1, 1, 3, 1, 2, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 2, 1, 1, 6, 7, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 2, 1, 1, 1, 1, 1, 2, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 5, 1, 1, 6, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 6, 8, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 8, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 8, 6, 3, 1, 1, 1, 1, 1, 1, 8, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 5, 1, 6, 5, 1, 1, 1, 1, 8, 1, 5, 1, 8, 1, 1, 1, 5, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 8, 1, 4, 1, 1, 1, 1, 6, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 5, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 6, 3, 6, 1, 6, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 2, 1, 3, 8, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 8, 5, 5, 1, 1, 1, 1, 1, 1, 6, 1, 6, 1, 1, 1, 1, 1, 3, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 3, 1, 6, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 2, 3, 1, 1, 1, 1, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 5, 6, 6, 6, 1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 6, 6, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 6, 1, 1, 1, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 3, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             5, 1, 8, 1, 3, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 8, 1, 1, 6, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 2, 1, 1, 4, 1, 1, 6, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 3, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 7, 1, 1, 1, 1, 1, 1, 1, 4, 8, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 3, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 4, 5, 5, 1, 1, 1, 1, 1, 8, 8, 5, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 8, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 4, 4, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 6, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 2, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 5, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 2, 5, 1, 1, 1, 1, 1, 1, 5, 1, 4, 1, 1, 1, 1, 1, 4, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 2, 1, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 5, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 5, 1, 1), age = c(35, 53, 42, 44, 39, 36, 36, 31, 26, 27, 45, 36, 27, 35, 30, 39, 30, 21, 56, 41, 28, 38, 26, 39, 46, 13, 34, 39, 31, 1, 30, 37, 38, 33, 30, 40, 51, 29, 29, 37, 46, 37, 54, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       30, 25, 26, 41, 41, 27, 35, 35, 25, 34, 35, 33, 31, 43, 59, 31, 41, 34, 37, 31, 37, 38, 44, 41, 41, 32, 40, 23, 42, 33, 47, 52, 35, 38, 23, 45, 48, 32, 38, 25, 36, 39, 25, 33, 35, 49, 38, 30, 44, 55, 31, 32, 29, 42, 28, 49, 32, 42, 33, 29, 28, 70, 33, 34, 33, 27, 38, 46, 45, 36, 39, 31, 16, 48, 24, 25, 42, 23, 48, 49, 38, 69, 37, 34, 30, 29, 59, 25, 48, 34, 41, 41, 36, 20, 49, 45, 64, 27, 39, 28, 46, 24, 34, 26, 35, 31, 52, 34, 41, 38, 39, 39, 56, 49, 41, 31, 32, 37, 36, 57, 32, 44, 40, 33, 32, 38, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       17, 35, 37, 38, 27, 38, 26, 40, 36, 40, 21, 38, 29, 31, 34, 40, 29, 34, 39, 43, 30, 57, 36, 29, 23, 24, 49, 82, 37, 52, 45, 42, 39, 57, 30, 49, 25, 28, 51, 44, 37, 41, 37, 48, 26, 31, 42, 31, 23, 42, 31, 47, 39, 33, 42, 28, 35, 34, 35, 38, 71, 30, 29, 24, 54, 30, 27, 35, 25, 53, 41, 38, 44, 31, 30, 58, 40, 57, 31, 33, 49, 66, 35, 25, 21, 33, 35, 26, 54, 46, 49, 69, 37, 38, 43, 47, 48, 31, 29, 34, 45, 41, 20, 12, 11, 78, 31, 58, 47, 67, 29, 34, 40, 43, 45, 29, 24, 23, 50, 39, 46, 35, 35, 47, 30, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       37, 25, 37, 40, 41, 31, 57, 30, 39, 64, 48, 43, 41, 40, 34, 54, 34, 28, 55, 31, 43, 34, 32, 48, 22, 33, 39, 32, 37, 30, 40, 43, 39, 38, 37, 42, 60, 29, 29, 32, 42, 38, 37, 48, 29, 42, 50, 64, 56, 22, 35, 45, 30, 40, 39, 26, 41, 40, 31, 50, 41, 43, 27, 28, 36, 43, 35, 26, 32, 31, 26, 53, 44, 39, 26, 26, 39, 23, 29, 33, 29, 24, 23, 26, 33, 40, 33, 39, 37, 24, 39, 42, 55, 52, 43, 36, 45, 39, 35, 42, 30, 48, 24, 36, 49, 44, 45, 37, 30, 46, 44, 34, 40, 34, 40, 37, 29, 56, 36, 36, 45, 38, 24, 27, 44, 43, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       32, 33, 33, 34, 53, 56, 32, 34, 36, 3, 24, 27, 34, 52, 32, 59, 39, 43, 40, 27, 41, 50, 37, 29, 30, 32, 38, 40, 31, 28, 27, 38, 37, 35, 43, 41, 27, 37, 24, 32, 32, 38, 34, 42, 36, 58, 45, 34, 34, 35, 36, 33, 69, 49, 33, 33, 28, 37, 27, 27, 47, 26, 27, 70, 38, 41, 50, 37, 35, 20, 52, 30, 34, 25, 24, 32, 41, 29, 36, 36, 42, 41, 35, 51, 38, 52, 31, 36, 63, 35, 33, 34, 25, 30, 37, 37, 43, 53, 45, 40, 50, 39, 33, 30, 35, 38, 31, 30, 31, 24, 35, 40, 44, 40, 53, 39, 27, 33, 23, 48, 43, 29, 29, 41, 34, 65, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       48, 43, 65, 47, 31, 50, 38, 44, 43, 39, 45, 38, 41, 41, 40, 26, 28, 38, 40, 21, 46, 42, 31, 42, 41, 34, 36, 27, 50, 5, 45, 25, 68, 42, 41, 30, 22, 49, 41, 34, 32, 29, 41, 31, 39, 52, 61, 45, 41, 37, 28, 35, 67, 47, 35, 27, 39, 44, 24, 28, 24, 39, 37, 40, 25, 37, 32, 29, 39, 44, 38, 24, 41, 23, 34, 32, 28, 34, 40, 41, 31, 31, 47, 54, 25, 30, 66, 39, 39, 65, 45, 28, 39, 33, 27, 42, 29, 37, 18, 30, 30, 48, 42, 40, 24, 37, 53, 30, 25, 50, 39, 29, 20, 74, 47, 52, 26, 43, 46, 55, 33, 33, 51, 27, 22, 30, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       30, 31, 30, 30, 38, 25, 39, 49, 58, 49, 29, 44, 23, 28, 44, 29, 31, 40, 37, 56, 33, 32, 24, 34, 53, 24, 24, 35, 38, 29, 52, 33, 22, 38, 31, 55, 32, 31, 32, 27, 26, 44, 30, 51, 44, 29, 26, 32, 29, 43, 41, 36, 25, 49, 29, 33, 38, 62, 47, 23, 30, 45, 23, 33, 37, 47, 42, 36, 55, 51, 56, 38, 32, 42, 27, 38, 61, 26, 38, 38, 28, 38, 37, 52, 27, 29, 18, 48, 30, 31, 5, 45, 40, 46, 32, 34, 43, 50, 43, 23, 44, 36, 42, 41, 28, 38, 45, 25, 26, 38, 26, 37, 32, 26, 34, 53, 35, 40, 36, 39, 34, 42, 42, 39, 51, 38, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       24, 34, 41, 30, 39, 26, 39, 38, 38, 29, 63, 45, 39, 24, 30, 33, 27, 38, 42, 30, 40, 42, 28, 41, 29, 67, 26, 31, 38, 34, 34, 33, 36, 36, 35, 32, 33, 64, 51, 48, 41, 27, 46, 23, 44, 37, 27, 48, 30, 28, 45, 35, 33, 25, 47, 40, 48, 31, 33, 41, 36, 37, 24, 34, 24, 43, 57, 51, 41, 38, 39, 43, 36, 42, 46, 36, 27, 39, 39, 43, 41, 48, 32, 50, 33, 40, 27, 28, 49, 35, 37, 47, 43, 39, 44, 29, 35, 36, 29, 24, 49, 40, 34, 28, 32, 37, 33, 41, 34, 24, 26, 30, 34, 24, 42, 34, 45, 39, 37, 42, 29, 31, 39, 24, 30, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       45, 28, 25, 36, 33, 47, 46, 5, 3, 15, 53, 32, 33, 40, 35, 45, 50, 36, 47, 49, 43, 27, 45, 30, 43, 30, 31, 37, 50, 35, 35, 33, 54, 26, 25, 25, 33, 46, 25, 37, 47, 39, 32, 29, 44, 42, 29, 43, 40, 26, 40, 28, 66, 46, 38, 29, 40, 28, 43, 26, 33, 35, 39, 31, 32, 47, 37, 58, 32, 32, 43, 32, 38, 27, 28, 26, 41, 43, 31, 33, 38, 34, 44, 37, 44, 38, 35, 39, 25, 65, 69, 30, 29, 33, 44, 51, 38, 32, 44, 33, 38, 43, 44, 31, 30, 55, 35, 47, 33, 43, 37, 39, 44, 48, 55, 38, 27, 36, 56, 35, 34, 36, 31, 37, 44, 52, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       49, 15, 30, 39, 58, 41, 32, 28, 49, 44, 36, 46, 30, 27, 26, 44, 41, 37, 39, 43, 21, 32, 39, 49, 27, 44, 29, 42, 29, 43, 29, 33, 47, 33, 47, 43, 30, 32, 52, 37, 40, 45, 39, 30, 31, 26, 47, 40, 39, 29, 29, 60, 27, 22, 31, 43, 33, 28, 31, 31, 27, 41, 50, 34, 37, 31, 42, 42, 28, 50, 46, 43, 32, 39, 32, 43, 36, 33, 43, 25, 36, 25, 29, 41, 43, 29, 52, 44, 28, 50, 20, 31, 27, 29, 31, 27, 57, 42, 69, 44, 46, 34, 46, 53, 51, 43, 40, 39, 39, 31, 53, 36, 43, 35, 52, 44, 41, 32, 31, 26, 38, 42, 30, 49, 29, 46, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       27, 41, 30, 51, 36, 58, 40, 28, 31, 36, 39, 47, 26, 49, 33, 37, 33, 47, 56, 36, 27, 45, 41, 27, 32, 32, 28, 47, 28, 38, 49, 55, 30, 23, 43, 39, 33, 43, 24, 46, 26, 34, 28, 26, 42, 50, 42, 29, 32, 27, 40, 28, 39, 35, 35, 30, 51, 28, 46, 32, 29, 27, 33, 37, 44, 41, 41, 44, 31, 43, 38, 39, 30, 42, 43, 32, 33, 67, 30, 29, 32, 36, 43, 28, 49, 28, 54, 55, 32, 40, 46, 31, 30, 42, 32, 25, 16, 56, 29, 62, 14, 28, 30, 43, 30, 47, 37, 29, 33, 24, 39, 35, 66, 43, 31, 30, 38, 37, 42, 48, 22, 42, 44, 27, 29, 35, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       39, 45, 41, 32, 39, 24, 39, 29, 30, 52, 30, 42, 32, 33, 48, 25, 26, 31, 47, 47, 35, 37, 45, 34, 35, 58, 47, 36, 26, 53, 27, 28, 46, 35, 38, 46, 52, 47, 38, 43, 45, 50, 34, 43, 39, 49, 44, 43, 35, 39, 27, 34, 27, 66, 46, 52, 25, 30, 34, 32, 34, 34, 36, 18, 25, 36, 38, 45, 21, 62, 32, 34, 27, 54, 53, 25, 33, 45, 57, 25, 26, 36, 51, 30, 35, 52, 27, 42, 37, 41, 34, 56, 56, 52, 27, 38, 43, 30, 39, 33, 41, 66, 31, 34, 55, 78, 25, 33, 36, 33, 37, 41, 36, 40, 45, 37, 57, 28, 32, 33, 26, 32, 30, 37, 37, 44, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       26, 20, 26, 48, 25, 33, 45, 35, 36, 32, 27, 33, 27, 26, 27, 43, 26, 29, 45, 53, 38, 38, 41, 45, 37, 33, 41, 37, 40, 40, 36, 31, 46, 30, 40, 25, 65, 28, 37, 52, 55, 32, 23, 46, 46, 64, 37, 27, 30, 45, 27, 64, 16, 35, 24, 29, 44, 24, 35, 39, 32, 21, 25, 32, 28, 41, 29, 45, 41, 60, 37, 51, 40, 43, 34, 42, 48, 27, 37, 33, 29, 37, 40, 34, 42, 34, 39, 34, 39, 31, 39, 41, 32, 25, 53, 36, 44, 43, 42, 28, 41, 29, 44, 37, 33, 26, 35, 36, 35, 33, 43, 47, 39, 29, 32, 53, 56, 28, 42, 45, 63, 40, 28, 42, 26, 26, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       29, 43, 44, 39, 41, 42, 45, 31, 56, 36, 42, 30, 24, 29, 29, 32, 43, 22, 40, 39, 47, 50, 25, 35, 38, 28, 27, 44, 40, 39, 65, 32, 30, 22, 29, 51, 27, 48, 40, 44, 55, 31, 44, 37, 55, 29, 47, 33, 39, 29, 30, 30, 41, 44, 53, 35, 28, 42, 27, 43, 55, 56, 30, 29, 42, 36, 41, 40, 45, 27, 34, 40, 72, 23, 26, 40, 46, 45, 28, 30, 31, 29, 43, 46, 32, 32, 43, 22, 37, 26, 34, 32, 41, 29, 39, 34, 31, 26, 56, 77, 37, 73, 80, 50, 36, 32, 28, 54, 62, 33, 69, 25, 46, 35, 28, 57, 40, 35, 42, 24, 41, 30, 43, 31, 26, 42, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       38, 34, 31, 47, 54, 28, 28, 46, 35, 35, 35, 29, 60, 37, 42, 59, 42, 34, 46, 59, 28, 29, 31, 44, 21, 24, 43, 24, 41, 42, 30, 37, 29, 33, 33, 49, 29, 26, 30, 36, 25, 35, 26, 31, 73, 45, 25, 42, 30, 36, 48, 38, 37, 50, 34, 43, 33, 49, 35, 28, 35, 22, 44, 31, 46, 40, 41, 39, 24, 30, 42, 38, 39, 32, 63, 42, 24, 41, 21, 40, 31, 31, 48, 48, 37, 44, 30, 48, 42, 47, 50, 30, 44, 29, 46, 31, 42, 55, 30, 25, 35, 41, 45, 48, 35, 29, 51, 0, 0, 1, 30, 27, 0, 45, 28, 52, 42, 46, 36, 32, 66, 51, 41, 59, 25, 35, 45, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       43, 22, 29, 34, 50, 48, 35, 3, 56, 36, 25, 50, 48, 38, 37, 38, 50, 30, 32, 47, 20, 35, 21, 32, 44, 39, 27, 39, 73, 60, 30, 31, 43, 34, 26, 44, 45, 30, 37, 33, 51, 37, 43, 30, 48, 32, 46, 51, 46, 47, 41, 41, 31, 45, 36, 36, 51, 34, 32, 50, 31, 28, 52, 33, 37, 24, 49, 41, 52, 32, 37, 45, 49, 29, 38, 39, 70, 29, 66, 24, 40, 57, 24, 39, 42, 47, 19, 45, 42, 36, 29, 36, 33, 35, 34, 51, 35, 30, 23, 34, 46, 28, 61, 25, 33, 46, 35, 52, 44, 32, 32, 44, 47, 28, 42, 42, 29, 33, 29, 41, 28, 26, 42, 51, 50, 43, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       56, 29, 31, 40, 49, 35, 6, 42, 27, 32, 24, 40, 35, 35, 35, 34, 28, 49, 21, 25, 33, 33, 36, 53, 30, 31, 45, 29, 25, 37, 17, 36, 32, 47, 35, 44, 26, 43, 34, 51, 25, 63, 28, 63, 53, 52, 47, 34, 30, 40, 41, 44, 57, 29, 46, 27, 22, 42, 12, 41, 29, 61, 46, 27, 40, 37, 33, 23, 48, 40, 41, 41, 36, 49, 28, 34, 36, 35, 45, 57, 34, 37, 32, 29, 26, 35, 41, 0, 35, 38, 35, 40, 37, 46, 31, 53, 40, 51, 35, 33, 36, 31, 32, 35, 41, 44, 28, 38, 41, 38, 43, 53, 37, 28, 32, 29, 38, 39, 53, 39, 46, 23, 38, 34, 34, 41, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       39, 55, 27, 41, 43, 54, 55, 26, 51, 34, 29, 27, 45, 38, 30, 28, 32, 37, 6, 29, 59, 52, 33, 28, 28, 34, 35, 36, 38, 42, 26, 45, 42, 47, 40, 45, 47, 30, 39, 38, 32, 48, 37, 30, 27, 37, 50, 41, 55, 37, 48, 33, 34, 44, 21, 9, 31, 37, 34, 33, 40, 25, 39, 28, 45, 51, 28, 37, 43, 38, 47, 32, 51, 43, 27, 35, 29, 43, 30, 58, 30, 39, 37, 38, 23, 32, 43, 33, 33, 43, 51, 28, 31, 29, 52, 46, 40, 38, 40, 42, 38, 24, 34, 32, 34, 39, 61, 25, 23, 33, 47, 24, 41, 62, 39, 41, 26, 33, 59, 26, 43, 45, 39, 66, 37, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       29, 48, 25, 30, 26, 33, 44, 28, 29, 24, 25, 38, 55, 40, 25, 31, 41, 33, 25, 45, 31, 48, 47, 39, 38, 29, 37, 39, 36, 56, 38, 37, 28, 43, 39, 49, 28, 36, 35, 26, 28, 45, 32, 36, 25, 40, 41, 66, 34, 35, 50, 24, 22, 25, 39, 25, 36, 33, 62, 34, 34, 39, 25, 37, 36, 35, 39, 37, 35, 48, 48, 33, 37, 32, 23, 38, 25, 43, 31, 31, 53, 25, 42, 32, 47, 35, 48, 41, 25, 40, 33, 12, 28, 49, 27, 31, 38, 25, 39, 28, 36, 36, 40, 41, 37, 28, 32, 33, 34, 35, 57, 33, 34, 19, 35, 38, 38, 41, 26, 34, 51, 26, 29, 31, 31, 29, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       33, 31, 34, 44, 40, 26, 46, 39, 25, 49, 31, 25, 42, 34, 28, 34, 56, 51, 37, 30, 25, 44, 36, 32, 25, 33, 37, 43, 45, 35, 41, 30, 32, 27, 33, 32, 26, 69, 32, 37, 55, 37, 29, 43, 38, 39, 37, 29, 32, 39, 45, 34, 32, 33, 38, 47, 30, 22, 35, 34, 36, 30, 30, 35, 44, 50, 36, 39, 37, 33, 36, 56, 41, 31, 33, 23, 47, 28, 46, 41, 26, 40, 35, 42, 35, 26, 40, 28, 32, 36, 35, 39, 40, 38, 28, 47, 39, 57, 35, 27, 33, 32, 48, 43, 37, 30, 48, 28, 50, 35, 39, 37, 29, 28, 58, 33, 34, 49, 44, 32, 36, 31, 42, 58, 45, 26, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       25, 48, 40, 38, 40, 37, 30, 38, 34, 42, 43, 39, 35, 38, 23, 40, 36, 33, 50, 45, 40, 30, 39, 25, 39, 28, 31, 30, 26, 45, 53, 49, 36, 29, 36, 58, 39, 40, 30, 37, 62, 25, 39, 14, 17, 50, 49, 35, 28, 31, 42, 46, 27, 36, 28, 25, 27, 40, 34, 35, 33, 33, 30, 32, 33, 25, 43, 28, 37, 45, 42, 48, 26, 37, 38, 24, 26, 15, 30, 31, 33, 31, 24, 32, 12, 29, 54, 29, 44, 33, 43, 38, 52, 47, 41, 45, 41, 48, 29, 35, 35, 26, 40, 37, 39, 33, 40, 41, 29, 54, 37, 30, 46, 42, 44, 47, 36, 32, 41, 30, 46, 48, 29, 43, 41, 46, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       27, 28, 31, 26, 48, 30, 40, 35, 43, 29, 43, 30, 42, 36, 28, 41, 41, 25, 29, 26, 49, 41, 46, 34, 45, 26, 34, 37, 30, 58, 42, 35, 36, 27, 27, 45, 43, 28, 30, 34, 52, 56, 31, 43, 57, 60, 26, 60, 46, 45, 1, 27, 35, 41, 30, 31, 28, 30, 36, 35, 57, 45, 46, 36, 51, 42, 27, 40, 32, 49, 27, 29, 24, 27, 46, 33, 35, 27, 36, 40, 32, 28, 36, 42, 44, 34, 34, 35, 29, 33, 47, 36, 32, 24, 44, 50, 34, 26, 46, 34, 27, 49, 46, 39, 26, 46, 41, 35, 46, 55, 42, 38, 43, 34, 51, 43, 45, 40, 32, 38, 41, 59, 39, 49, 27, 44, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       43, 39, 26, 38, 46, 64, 40, 46, 29, 27, 39, 42, 44, 42, 37, 59, 37, 36, 29, 45, 52, 22, 31, 66, 41, 61, 47, 24, 44, 52, 29, 38, 38, 22, 36, 26, 58, 47, 35, 28, 26, 42, 39, 39, 43, 23, 39, 38, 27, 38, 27, 32, 26, 36, 31, 28, 34, 31, 36, 35, 50, 36, 31, 26, 40, 25, 22, 32, 38, 48, 39, 56, 36, 30, 43, 50, 38, 47, 31, 47, 52, 37, 40, 29, 40, 41, 41, 43, 49, 25, 49, 39, 38, 46, 60, 34, 56, 39, 32, 27, 25, 45, 49, 33, 23, 46, 51, 27, 37, 28, 38, 32, 45, 33, 53, 26, 57, 41, 32, 39, 12, 23, 31, 32, 43, 30, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       34, 37, 50, 33, 41, 25, 44, 45, 35, 41, 45, 37, 41, 42, 25, 48, 51, 39, 34, 37, 39, 27, 46, 34, 49, 55, 37)))
package:MASS
TRUE
FALSE
Animals
list(`package:MASS` = list(body = c(1.35, 465, 36.33, 27.66, 1.04, 11700, 2547, 187.1, 521, 10, 3.3, 529, 207, 62, 6654, 9400, 6.8, 35, 0.12, 0.023, 2.5, 55.5, 100, 52.16, 0.28, 87000, 0.122, 192), brain = c(8.1, 423, 119.5, 115, 5.5, 50, 4603, 419, 655, 115, 25.6, 680, 406, 1320, 5712, 70, 179, 56, 1, 0.4, 12.1, 175, 157, 440, 1.9, 154.5, 3, 180)))
package:MASS
TRUE
FALSE
anorexia
list(`package:MASS` = list(Treat = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3), Prewt = c(80.7, 89.4, 91.8, 74, 78.1, 88.3, 87.3, 75.1, 80.6, 78.4, 77.6, 88.7, 81.3, 78.1, 70.5, 77.3, 85.2, 86, 84.1, 79.7, 85.5, 84.4, 79.6, 77.5, 72.3, 89, 80.5, 84.9, 81.5, 82.6, 79.9, 88.7, 94.9, 76.3, 81, 80.5, 85, 89.2, 81.3, 76.5, 70, 80.4, 
                                                                                                                                                                                                                                                                        83.3, 83, 87.7, 84.2, 86.4, 76.5, 80.2, 87.8, 83.3, 79.7, 84.5, 80.8, 87.4, 83.8, 83.3, 86, 82.5, 86.7, 79.6, 76.9, 94.2, 73.4, 80.5, 81.6, 82.1, 77.6, 83.5, 89.9, 86, 87.3), Postwt = c(80.2, 80.1, 86.4, 86.3, 76.1, 78.1, 75.1, 86.7, 73.5, 84.6, 77.4, 79.5, 89.6, 81.4, 81.8, 77.3, 84.2, 75.4, 79.5, 73, 88.3, 84.7, 81.4, 81.2, 88.2, 78.8, 82.2, 85.6, 81.4, 81.9, 76.4, 103.6, 98.4, 93.4, 73.4, 82.1, 96.7, 95.3, 82.4, 72.5, 90.9, 71.3, 85.4, 81.6, 89.1, 83.9, 82.7, 75.7, 82.6, 100.4, 85.2, 83.6, 84.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  96.2, 86.7, 95.2, 94.3, 91.5, 91.9, 100.3, 76.7, 76.8, 101.6, 94.9, 75.2, 77.8, 95.5, 90.7, 92.5, 93.8, 91.7, 98)))
package:MASS
TRUE
FALSE
area
list(`package:MASS` = function (f, a, b, ..., fa = f(a, ...), fb = f(b, ...), limit = 10, eps = 1e-05) 
{
  h <- b - a
  d <- (a + b)/2
  fd <- f(d, ...)
  a1 <- ((fa + fb) * h)/2
  a2 <- ((fa + 4 * fd + fb) * h)/6
  if (abs(a1 - a2) < eps) 
    return(a2)
  if (limit == 0) {
    warning(gettextf("iteration limit reached near 'x = %f'", d), domain = NA)
    return(a2)
  }
  Recall(f, a, d, ..., fa = fa, fb = fd, limit = limit - 1, eps = eps) + Recall(f, d, b, ..., fa = fd, fb = fb, limit = limit - 1, eps = eps)
}, function (f, a, b, ..., fa = f(a, ...), fb = f(b, ...), limit = 10, eps = 1e-05) 
{
  h <- b - a
  d <- (a + b)/2
  fd <- f(d, ...)
  a1 <- ((fa + fb) * h)/2
  a2 <- ((fa + 4 * fd + fb) * h)/6
  if (abs(a1 - a2) < eps) 
    return(a2)
  if (limit == 0) {
    warning(gettextf("iteration limit reached near 'x = %f'", d), domain = NA)
    return(a2)
  }
  Recall(f, a, d, ..., fa = fa, fb = fd, limit = limit - 1, eps = eps) + Recall(f, d, b, ..., fa = fd, fb = fb, limit = limit - 1, eps = eps)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.fractions
list(`package:MASS` = function (x) 
  if (is.fractions(x)) x else fractions(x), function (x) 
    if (is.fractions(x)) x else fractions(x))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
bacteria
list(`package:MASS` = list(y = c(2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 
                                 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2, 1, 2), ap = c(2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                         2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), hilo = c(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1, 1, 1, 1, 1, 1, 1, 1), week = c(0, 2, 4, 11, 0, 2, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 6, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 11, 0, 2, 11, 0, 2, 6, 11, 0, 2, 4, 6, 11, 0, 4, 6, 11, 0, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          4, 0, 2, 4, 6, 0, 2, 11, 0, 2, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 4, 0, 2, 4, 6, 11, 0, 2, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11, 0, 4, 6, 0, 2, 4, 6, 11, 0, 2, 6, 11, 0, 2, 4, 6, 11, 0, 2, 4, 6, 11), ID = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 34, 34, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 40, 40, 41, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 46, 46, 46, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              47, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50), trt = c(1, 1, 1, 1, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   2, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3)))
package:MASS
TRUE
FALSE
bandwidth.nrd
list(`package:MASS` = function (x) 
{
  r <- quantile(x, c(0.25, 0.75))
  h <- (r[2] - r[1])/1.34
  4 * 1.06 * min(sqrt(var(x)), h) * length(x)^(-1/5)
}, function (x) 
{
  r <- quantile(x, c(0.25, 0.75))
  h <- (r[2] - r[1])/1.34
  4 * 1.06 * min(sqrt(var(x)), h) * length(x)^(-1/5)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
bcv
list(`package:MASS` = function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax) 
{
  fbcv <- function(h, x, n, d) .C(VR_bcv_bin, as.integer(n), as.integer(length(x)), as.double(d), x, as.double(h), u = double(1))$u
  n <- length(x)
  if (!n) 
    stop("'x' has length zero")
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5) * 4
  storage.mode(x) <- "double"
  Z <- .C(VR_den_bin, as.integer(n), as.integer(nb), d = double(1), x, cnt = integer(nb))
  d <- Z$d
  cnt <- as.integer(Z$cnt)
  h <- optimize(fbcv, c(lower, upper), tol = 0.1 * lower, x = cnt, n = n, d = d)$minimum
  if (h < 1.1 * lower | h > upper - 0.1 * lower) 
    warning("minimum occurred at one end of the range")
  h
}, function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax) 
{
  fbcv <- function(h, x, n, d) .C(VR_bcv_bin, as.integer(n), as.integer(length(x)), as.double(d), x, as.double(h), u = double(1))$u
  n <- length(x)
  if (!n) 
    stop("'x' has length zero")
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5) * 4
  storage.mode(x) <- "double"
  Z <- .C(VR_den_bin, as.integer(n), as.integer(nb), d = double(1), x, cnt = integer(nb))
  d <- Z$d
  cnt <- as.integer(Z$cnt)
  h <- optimize(fbcv, c(lower, upper), tol = 0.1 * lower, x = cnt, n = n, d = d)$minimum
  if (h < 1.1 * lower | h > upper - 0.1 * lower) 
    warning("minimum occurred at one end of the range")
  h
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
beav1
list(`package:MASS` = list(day = c(346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 346, 347, 347, 347, 
                                   347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347), time = c(840, 850, 900, 910, 920, 930, 940, 950, 1000, 1010, 1020, 1030, 1040, 1050, 1100, 1110, 1120, 1130, 1140, 1150, 1200, 1210, 1220, 1230, 1240, 1250, 1300, 1310, 1320, 1330, 1340, 1350, 1400, 1410, 1420, 1430, 1440, 1450, 1500, 1510, 1520, 1530, 1540, 1550, 1600, 1610, 1620, 1630, 1640, 1650, 1700, 1710, 1720, 1730, 1740, 1750, 1800, 1810, 1820, 1830, 1840, 1850, 1900, 1910, 1920, 1930, 1940, 
                                                                                                                                                 1950, 2000, 2010, 2020, 2030, 2040, 2050, 2100, 2110, 2120, 2130, 2140, 2150, 2200, 2210, 2230, 2240, 2250, 2300, 2310, 2320, 2330, 2340, 2350, 0, 10, 20, 30, 40, 50, 100, 110, 120, 130, 140, 150, 200, 210, 220, 230, 240, 250, 300, 310, 320, 330, 340), temp = c(36.33, 36.34, 36.35, 36.42, 36.55, 36.69, 36.71, 36.75, 36.81, 36.88, 36.89, 36.91, 36.85, 36.89, 36.89, 36.67, 36.5, 36.74, 36.77, 36.76, 36.78, 36.82, 36.89, 36.99, 36.92, 36.99, 36.89, 36.94, 36.92, 36.97, 36.91, 36.79, 36.77, 36.69, 36.62, 
                                                                                                                                                                                                                                                                                                                                                                                                                       36.54, 36.55, 36.67, 36.69, 36.62, 36.64, 36.59, 36.65, 36.75, 36.8, 36.81, 36.87, 36.87, 36.89, 36.94, 36.98, 36.95, 37, 37.07, 37.05, 37, 36.95, 37, 36.94, 36.88, 36.93, 36.98, 36.97, 36.85, 36.92, 36.99, 37.01, 37.1, 37.09, 37.02, 36.96, 36.84, 36.87, 36.85, 36.85, 36.87, 36.89, 36.86, 36.91, 37.53, 37.23, 37.2, 37.25, 37.2, 37.21, 37.24, 37.1, 37.2, 37.18, 36.93, 36.83, 36.93, 36.83, 36.8, 36.75, 36.71, 36.73, 36.75, 36.72, 36.76, 36.7, 36.82, 36.88, 36.94, 36.79, 36.78, 36.8, 36.82, 36.84, 36.86, 
                                                                                                                                                                                                                                                                                                                                                                                                                       36.88, 36.93, 36.97, 37.15), activ = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1)))
package:MASS
TRUE
FALSE
beav2
list(`package:MASS` = list(day = c(307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 308, 308, 308, 308, 308, 308, 308, 
                                   308, 308, 308, 308, 308, 308), time = c(930, 940, 950, 1000, 1010, 1020, 1030, 1040, 1050, 1100, 1110, 1120, 1130, 1140, 1150, 1200, 1210, 1220, 1230, 1240, 1250, 1300, 1310, 1320, 1330, 1340, 1350, 1400, 1410, 1420, 1430, 1440, 1450, 1500, 1510, 1520, 1530, 1540, 1550, 1600, 1610, 1620, 1630, 1640, 1650, 1700, 1710, 1720, 1730, 1740, 1750, 1800, 1810, 1820, 1830, 1840, 1850, 1900, 1910, 1920, 1930, 1940, 1950, 2000, 2010, 2020, 2030, 2040, 2050, 2100, 2110, 2120, 2130, 2140, 2150, 2200, 2210, 2220, 
                                                                           2230, 2240, 2250, 2300, 2310, 2320, 2330, 2340, 2350, 0, 10, 20, 30, 40, 50, 100, 110, 120, 130, 140, 150, 200), temp = c(36.58, 36.73, 36.93, 37.15, 37.23, 37.24, 37.24, 36.9, 36.95, 36.89, 36.95, 37, 36.9, 36.99, 36.99, 37.01, 37.04, 37.04, 37.14, 37.07, 36.98, 37.01, 36.97, 36.97, 37.12, 37.13, 37.14, 37.15, 37.17, 37.12, 37.12, 37.17, 37.28, 37.28, 37.44, 37.51, 37.64, 37.51, 37.98, 38.02, 38, 38.24, 38.1, 38.24, 38.11, 38.02, 38.11, 38.01, 37.91, 37.96, 38.03, 38.17, 38.19, 38.18, 38.15, 38.04, 
                                                                                                                                                                                                     37.96, 37.84, 37.83, 37.84, 37.74, 37.76, 37.76, 37.64, 37.63, 38.06, 38.19, 38.35, 38.25, 37.86, 37.95, 37.95, 37.76, 37.6, 37.89, 37.86, 37.71, 37.78, 37.82, 37.76, 37.81, 37.84, 38.01, 38.1, 38.15, 37.92, 37.64, 37.7, 37.46, 37.41, 37.46, 37.56, 37.55, 37.75, 37.76, 37.73, 37.77, 38.01, 38.04, 38.07), activ = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))
package:MASS
TRUE
FALSE
biopsy
list(`package:MASS` = list(ID = c("1000025", "1002945", "1015425", "1016277", "1017023", "1017122", "1018099", "1018561", "1033078", "1033078", "1035283", "1036172", "1041801", "1043999", "1044572", "1047630", "1048672", "1049815", "1050670", "1050718", "1054590", "1054593", "1056784", "1057013", "1059552", "1065726", "1066373", "1066979", "1067444", "1070935", "1070935", "1071760", "1072179", "1074610", "1075123", "1079304", "1080185", "1081791", "1084584", "1091262", "1096800", "1099510", "1100524", 
                                  "1102573", "1103608", "1103722", "1105257", "1105524", "1106095", "1106829", "1108370", "1108449", "1110102", "1110503", "1110524", "1111249", "1112209", "1113038", "1113483", "1113906", "1115282", "1115293", "1116116", "1116132", "1116192", "1116998", "1117152", "1118039", "1120559", "1121732", "1121919", "1123061", "1124651", "1125035", "1126417", "1131294", "1132347", "1133041", "1133136", "1136142", "1137156", "1143978", "1143978", "1147044", "1147699", "1147748", "1148278", "1148873", "1152331", 
                                  "1155546", "1156272", "1156948", "1157734", "1158247", "1160476", "1164066", "1165297", "1165790", "1165926", "1166630", "1166654", "1167439", "1167471", "1168359", "1168736", "1169049", "1170419", "1170420", "1171710", "1171710", "1171795", "1171845", "1172152", "1173216", "1173235", "1173347", "1173347", "1173509", "1173514", "1173681", "1174057", "1174057", "1174131", "1174428", "1175937", "1176406", "1176881", "1177027", "1177399", "1177512", "1178580", "1179818", "1180194", "1180523", "1180831", 
                                  "1181356", "1182404", "1182410", "1183240", "1183246", "1183516", "1183911", "1183983", "1184184", "1184241", "1184840", "1185609", "1185610", "1187457", "1187805", "1188472", "1189266", "1189286", "1190394", "1190485", "1192325", "1193091", "1193210", "1193683", "1196295", "1196915", "1197080", "1197270", "1197440", "1197510", "1197979", "1197993", "1198128", "1198641", "1199219", "1199731", "1199983", "1200772", "1200847", "1200892", "1200952", "1201834", "1201936", "1202125", "1202812", "1203096", 
                                  "1204242", "1204898", "1205138", "1205579", "1206089", "1206695", "1206841", "1207986", "1208301", "1210963", "1211202", "1212232", "1212251", "1212422", "1212422", "1213375", "1213383", "1214092", "1214556", "1214966", "1216694", "1216947", "1217051", "1217264", "1218105", "1218741", "1218860", "1218860", "1219406", "1219525", "1219859", "1220330", "1221863", "1222047", "1222936", "1223282", "1223426", "1223793", "1223967", "1224329", "1225799", "1226012", "1226612", "1227210", "1227244", "1227481", 
                                  "1228152", "1228311", "1230175", "1230688", "1231387", "1231706", "1232225", "1236043", "1241232", "1241559", "1241679", "1242364", "1243256", "1270479", "1276091", "1277018", "128059", "1285531", "1287775", "144888", "145447", "167528", "169356", "183913", "191250", "1017023", "1100524", "1116116", "1168736", "1182404", "1182404", "1198641", "242970", "255644", "263538", "274137", "303213", "314428", "1182404", "1198641", "320675", "324427", "385103", "390840", "411453", "320675", "428903", "431495", 
                                  "432809", "434518", "452264", "456282", "476903", "486283", "486662", "488173", "492268", "508234", "527363", "529329", "535331", "543558", "555977", "560680", "561477", "563649", "601265", "606140", "606722", "616240", "61634", "625201", "63375", "635844", "636130", "640744", "646904", "653777", "659642", "666090", "666942", "667204", "673637", "684955", "688033", "691628", "693702", "704097", "704168", "706426", "709287", "718641", "721482", "730881", "733639", "733639", "733823", "740492", "743348", 
                                  "752904", "756136", "760001", "760239", "76389", "764974", "770066", "785208", "785615", "792744", "797327", "798429", "704097", "806423", "809912", "810104", "814265", "814911", "822829", "826923", "830690", "831268", "832226", "832567", "836433", "837082", "846832", "850831", "855524", "857774", "859164", "859350", "866325", "873549", "877291", "877943", "888169", "888523", "896404", "897172", "95719", "160296", "342245", "428598", "492561", "493452", "493452", "521441", "560680", "636437", "640712", 
                                  "654244", "657753", "685977", "805448", "846423", "1002504", "1022257", "1026122", "1071084", "1080233", "1114570", "1114570", "1116715", "1131411", "1151734", "1156017", "1158247", "1158405", "1168278", "1176187", "1196263", "1196475", "1206314", "1211265", "1213784", "1223003", "1223306", "1223543", "1229929", "1231853", "1234554", "1236837", "1237674", "1238021", "1238464", "1238633", "1238915", "1238948", "1239232", "1239347", "1239967", "1240337", "1253505", "1255384", "1257200", "1257648", 
                                  "1257815", "1257938", "1258549", "1258556", "1266154", "1272039", "1276091", "1276091", "1276091", "1277629", "1293439", "1293439", "1294562", "1295186", "527337", "558538", "566509", "608157", "677910", "734111", "734111", "780555", "827627", "1049837", "1058849", "1182404", "1193544", "1201870", "1202253", "1227081", "1230994", "1238410", "1246562", "1257470", "1259008", "1266124", "1267898", "1268313", "1268804", "1276091", "1280258", "1293966", "1296572", "1298416", "1299596", "1105524", "1181685", 
                                  "1211594", "1238777", "1257608", "1269574", "1277145", "1287282", "1296025", "1296263", "1296593", "1299161", "1301945", "1302428", "1318169", "474162", "787451", "1002025", "1070522", "1073960", "1076352", "1084139", "1115293", "1119189", "1133991", "1142706", "1155967", "1170945", "1181567", "1182404", "1204558", "1217952", "1224565", "1238186", "1253917", "1265899", "1268766", "1277268", "1286943", "1295508", "1297327", "1297522", "1298360", "1299924", "1299994", "1304595", "1306282", "1313325", 
                                  "1320077", "1320077", "1320304", "1330439", "333093", "369565", "412300", "672113", "749653", "769612", "769612", "798429", "807657", "8233704", "837480", "867392", "869828", "1043068", "1056171", "1061990", "1113061", "1116192", "1135090", "1145420", "1158157", "1171578", "1174841", "1184586", "1186936", "1197527", "1222464", "1240603", "1240603", "1241035", "1287971", "1289391", "1299924", "1306339", "1313658", "1313982", "1321264", "1321321", "1321348", "1321931", "1321942", "1321942", "1328331", 
                                  "1328755", "1331405", "1331412", "1333104", "1334071", "1343068", "1343374", "1344121", "142932", "183936", "324382", "378275", "385103", "690557", "695091", "695219", "824249", "871549", "878358", "1107684", "1115762", "1217717", "1239420", "1254538", "1261751", "1268275", "1272166", "1294261", "1295529", "1298484", "1311875", "1315506", "1320141", "1325309", "1333063", "1333495", "1334659", "1336798", "1344449", "1350568", "1352663", "188336", "352431", "353098", "411453", "557583", "636375", "736150", 
                                  "803531", "822829", "1016634", "1031608", "1041043", "1042252", "1057067", "1061990", "1073836", "1083817", "1096352", "1140597", "1149548", "1174009", "1183596", "1190386", "1190546", "1213273", "1218982", "1225382", "1235807", "1238777", "1253955", "1257366", "1260659", "1268952", "1275807", "1277792", "1277792", "1285722", "1288608", "1290203", "1294413", "1299596", "1303489", "1311033", "1311108", "1315807", "1318671", "1319609", "1323477", "1324572", "1324681", "1325159", "1326892", "1330361", 
                                  "1333877", "1334015", "1334667", "1339781", "1339781", "13454352", "1345452", "1345593", "1347749", "1347943", "1348851", "1350319", "1350423", "1352848", "1353092", "1354840", "1354840", "1355260", "1365075", "1365328", "1368267", "1368273", "1368882", "1369821", "1371026", "1371920", "466906", "466906", "534555", "536708", "566346", "603148", "654546", "654546", "695091", "714039", "763235", "776715", "841769", "888820", "897471", "897471"), V1 = c(5, 5, 3, 6, 4, 8, 1, 2, 2, 4, 1, 2, 5, 1, 8, 7, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         4, 4, 10, 6, 7, 10, 3, 8, 1, 5, 3, 5, 2, 1, 3, 2, 10, 2, 3, 2, 10, 6, 5, 2, 6, 10, 6, 5, 10, 1, 3, 1, 4, 7, 9, 5, 10, 5, 10, 10, 8, 8, 5, 9, 5, 1, 9, 6, 1, 10, 4, 5, 8, 1, 5, 6, 1, 9, 10, 1, 1, 5, 3, 2, 2, 4, 5, 3, 3, 5, 3, 3, 4, 2, 1, 3, 4, 1, 2, 1, 2, 5, 9, 7, 10, 2, 4, 8, 10, 7, 10, 1, 1, 6, 1, 8, 10, 10, 3, 1, 8, 4, 1, 3, 1, 4, 10, 5, 5, 1, 7, 3, 8, 1, 5, 2, 5, 3, 3, 5, 4, 3, 4, 1, 3, 2, 9, 1, 2, 1, 3, 1, 3, 8, 1, 7, 10, 4, 1, 5, 1, 2, 1, 9, 10, 4, 3, 1, 5, 4, 5, 10, 3, 1, 3, 1, 1, 6, 8, 5, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         5, 4, 5, 1, 1, 6, 5, 8, 2, 1, 10, 5, 1, 10, 7, 5, 1, 3, 4, 8, 5, 1, 3, 9, 10, 1, 5, 1, 5, 10, 1, 1, 5, 8, 8, 1, 10, 10, 8, 1, 1, 6, 6, 1, 10, 4, 7, 10, 1, 10, 8, 1, 10, 7, 6, 8, 10, 3, 3, 10, 9, 8, 10, 5, 3, 2, 1, 1, 5, 8, 8, 4, 3, 1, 10, 6, 6, 9, 5, 3, 3, 3, 5, 10, 5, 8, 10, 7, 5, 10, 3, 10, 1, 8, 5, 3, 7, 3, 3, 3, 1, 1, 10, 3, 2, 1, 10, 7, 8, 10, 3, 6, 5, 1, 1, 8, 10, 1, 5, 5, 5, 8, 9, 8, 1, 10, 1, 8, 10, 1, 1, 7, 3, 2, 1, 8, 1, 1, 4, 5, 6, 1, 4, 7, 3, 3, 5, 1, 3, 10, 1, 8, 10, 10, 5, 5, 5, 8, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         1, 6, 1, 1, 8, 10, 1, 2, 1, 7, 1, 5, 1, 3, 4, 5, 2, 3, 2, 1, 4, 5, 8, 8, 10, 6, 3, 3, 4, 2, 2, 6, 5, 1, 1, 4, 1, 4, 5, 3, 1, 1, 1, 3, 5, 1, 10, 3, 2, 2, 3, 7, 5, 2, 5, 1, 10, 3, 1, 1, 3, 3, 4, 3, 1, 3, 3, 5, 3, 1, 1, 4, 1, 2, 3, 1, 1, 10, 5, 8, 3, 8, 1, 5, 2, 3, 10, 4, 5, 3, 9, 5, 8, 1, 2, 1, 5, 5, 3, 6, 10, 10, 4, 4, 5, 10, 5, 1, 1, 5, 2, 1, 5, 1, 5, 4, 5, 3, 4, 2, 10, 10, 8, 5, 5, 5, 3, 6, 4, 4, 10, 10, 6, 4, 1, 3, 6, 6, 4, 5, 3, 4, 4, 5, 4, 5, 5, 9, 8, 5, 1, 3, 10, 3, 6, 1, 5, 4, 5, 5, 3, 1, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         4, 4, 6, 4, 4, 4, 1, 3, 8, 1, 5, 2, 1, 5, 5, 3, 6, 4, 1, 1, 3, 4, 1, 4, 10, 7, 3, 3, 4, 4, 6, 4, 7, 4, 1, 3, 2, 1, 5, 5, 4, 6, 5, 3, 5, 4, 2, 5, 6, 2, 3, 7, 3, 1, 3, 4, 3, 4, 5, 5, 2, 5, 5, 5, 1, 3, 4, 5, 3, 4, 8, 10, 8, 7, 3, 1, 10, 5, 5, 1, 1, 1, 5, 5, 6, 3, 5, 1, 8, 5, 9, 5, 4, 2, 10, 5, 4, 5, 4, 5, 3, 5, 3, 1, 4, 5, 5, 10, 4, 1, 5, 5, 10, 5, 8, 2, 2, 4, 3, 1, 4, 5, 3, 6, 7, 1, 5, 3, 4, 2, 2, 4, 6, 5, 1, 8, 3, 3, 10, 4, 4, 5, 4, 3, 3, 1, 2, 3, 1, 1, 5, 3, 3, 1, 5, 4, 3, 3, 5, 5, 7, 1, 1, 4, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         1, 3, 1, 5, 3, 5, 5, 3, 3, 2, 5, 1, 4, 1, 5, 1, 2, 10, 5, 5, 1, 1, 1, 1, 3, 4, 1, 1, 5, 3, 3, 3, 2, 5, 4, 4), V2 = c(1, 4, 1, 8, 1, 10, 1, 1, 1, 2, 1, 1, 3, 1, 7, 4, 1, 1, 7, 1, 3, 5, 1, 4, 1, 2, 2, 1, 1, 1, 1, 1, 7, 1, 1, 1, 10, 2, 4, 5, 6, 4, 10, 6, 10, 1, 7, 1, 1, 8, 5, 3, 3, 5, 5, 6, 10, 2, 2, 5, 3, 1, 10, 3, 1, 4, 1, 3, 3, 1, 1, 10, 3, 4, 6, 1, 1, 3, 1, 1, 2, 1, 2, 1, 5, 10, 3, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 5, 3, 3, 1, 2, 10, 3, 10, 6, 1, 5, 3, 6, 3, 10, 3, 1, 3, 5, 1, 2, 1, 2, 10, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              4, 1, 5, 1, 3, 1, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 4, 1, 1, 8, 1, 2, 10, 1, 1, 5, 2, 1, 1, 9, 7, 1, 1, 1, 1, 1, 6, 8, 1, 1, 1, 1, 1, 10, 6, 8, 1, 10, 1, 3, 1, 1, 1, 8, 7, 1, 5, 5, 8, 2, 10, 5, 1, 1, 1, 1, 4, 1, 1, 1, 7, 8, 1, 1, 1, 10, 10, 1, 1, 1, 10, 10, 1, 10, 10, 7, 1, 1, 10, 1, 1, 6, 1, 5, 5, 1, 5, 9, 1, 10, 4, 8, 4, 4, 3, 1, 8, 8, 10, 4, 1, 1, 1, 1, 1, 1, 10, 4, 1, 1, 2, 4, 3, 10, 10, 6, 1, 1, 1, 7, 5, 10, 8, 4, 9, 1, 10, 3, 8, 1, 4, 1, 3, 2, 1, 1, 1, 1, 1, 5, 1, 1, 4, 4, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              10, 10, 1, 1, 6, 1, 1, 8, 4, 1, 5, 3, 4, 2, 1, 4, 1, 10, 1, 3, 8, 1, 1, 8, 1, 1, 1, 6, 1, 1, 6, 5, 8, 1, 4, 6, 1, 1, 4, 1, 2, 1, 1, 10, 4, 4, 1, 2, 4, 6, 1, 5, 1, 1, 5, 3, 1, 1, 1, 6, 1, 2, 1, 4, 2, 1, 1, 4, 7, 1, 1, 3, 10, 10, 3, 10, 10, 2, 4, 1, 1, 10, 8, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 6, 2, 1, 1, 3, 6, 3, 1, 1, 1, 8, 1, 1, 2, 1, 1, 1, 2, 2, 10, 1, 3, 1, 2, 1, 2, 1, 3, 1, 1, 1, 10, 1, 5, 3, 7, 1, 2, 3, 2, 10, 3, 1, 1, 10, 3, 7, 1, 1, 3, 1, 1, 2, 9, 8, 10, 1, 1, 1, 4, 2, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              1, 7, 1, 1, 1, 5, 3, 2, 6, 8, 1, 1, 1, 1, 1, 1, 1, 9, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 8, 1, 3, 10, 7, 1, 1, 1, 10, 6, 3, 1, 8, 1, 10, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 3, 10, 1, 1, 1, 1, 1, 1, 1, 6, 10, 1, 1, 1, 7, 1, 1, 4, 5, 1, 1, 1, 1, 1, 1, 4, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 10, 1, 1, 8, 1, 1, 2, 4, 1, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 7, 1, 1, 4, 10, 10, 6, 1, 1, 9, 1, 1, 1, 1, 1, 1, 7, 10, 1, 1, 1, 10, 1, 8, 1, 10, 5, 3, 1, 8, 1, 1, 1, 1, 2, 1, 1, 1, 4, 3, 5, 1, 1, 10, 1, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              10, 10, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 6, 1, 1, 1, 2, 1, 1, 7, 1, 1, 10, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 10, 1, 1, 2, 1, 1, 1, 1, 1, 4, 8, 1, 1, 1, 1, 1, 1, 1, 2, 1, 7, 10, 10, 2, 1, 3, 1, 1, 1, 1, 1, 1, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 10, 8, 8), V3 = c(1, 4, 1, 8, 1, 10, 1, 2, 1, 1, 1, 1, 3, 1, 5, 6, 1, 1, 7, 1, 2, 5, 1, 5, 1, 3, 1, 1, 1, 3, 1, 1, 7, 1, 2, 1, 10, 1, 4, 3, 6, 3, 10, 5, 10, 1, 7, 1, 1, 7, 8, 3, 6, 5, 5, 6, 10, 4, 3, 5, 5, 1, 10, 4, 1, 2, 1, 4, 8, 1, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        2, 3, 5, 4, 2, 4, 1, 1, 1, 2, 1, 1, 1, 7, 6, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 6, 5, 4, 2, 3, 10, 4, 10, 8, 1, 4, 1, 4, 3, 10, 2, 1, 3, 5, 1, 1, 2, 1, 10, 5, 6, 1, 3, 1, 5, 1, 3, 1, 8, 1, 1, 1, 1, 1, 2, 1, 1, 1, 5, 1, 1, 3, 5, 1, 1, 7, 1, 4, 8, 1, 1, 5, 2, 1, 2, 10, 7, 1, 1, 1, 1, 1, 7, 10, 1, 1, 1, 1, 1, 10, 5, 7, 1, 10, 1, 3, 1, 1, 1, 8, 6, 1, 8, 6, 4, 3, 10, 10, 1, 1, 1, 1, 4, 1, 1, 1, 7, 8, 1, 1, 1, 10, 9, 1, 1, 1, 10, 8, 1, 10, 10, 8, 1, 1, 7, 3, 1, 4, 1, 6, 5, 1, 7, 9, 1, 10, 7, 7, 6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        5, 2, 4, 8, 8, 10, 3, 3, 1, 1, 1, 1, 1, 10, 4, 1, 1, 2, 4, 3, 10, 10, 6, 1, 1, 1, 7, 8, 10, 9, 4, 4, 4, 6, 5, 8, 1, 7, 1, 5, 4, 1, 3, 1, 1, 1, 7, 1, 1, 3, 6, 5, 10, 10, 1, 3, 6, 1, 1, 8, 4, 1, 7, 4, 3, 1, 2, 10, 1, 10, 1, 4, 4, 1, 1, 7, 1, 1, 1, 4, 1, 1, 5, 5, 7, 1, 4, 3, 1, 1, 6, 1, 2, 1, 1, 3, 6, 7, 1, 2, 6, 7, 1, 5, 1, 1, 5, 3, 1, 1, 1, 4, 1, 2, 1, 4, 3, 1, 1, 5, 10, 1, 1, 3, 10, 5, 5, 10, 3, 2, 4, 1, 1, 10, 8, 3, 3, 2, 3, 2, 1, 2, 1, 1, 1, 1, 4, 1, 3, 2, 1, 1, 2, 6, 3, 1, 1, 1, 7, 1, 1, 3, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1, 1, 1, 3, 8, 1, 3, 1, 1, 1, 2, 1, 2, 2, 1, 1, 10, 2, 6, 2, 8, 1, 2, 1, 2, 10, 3, 3, 1, 10, 6, 8, 1, 1, 1, 1, 1, 2, 7, 10, 10, 1, 3, 1, 3, 2, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 5, 1, 2, 5, 9, 2, 3, 1, 1, 1, 1, 1, 8, 6, 6, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 7, 1, 2, 10, 8, 2, 1, 1, 10, 4, 2, 1, 9, 1, 10, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 7, 4, 1, 1, 2, 8, 1, 1, 5, 6, 1, 1, 1, 1, 3, 1, 4, 2, 1, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 10, 1, 1, 3, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1, 1, 1, 1, 1, 10, 2, 1, 4, 8, 4, 10, 1, 1, 7, 2, 1, 1, 1, 1, 2, 10, 5, 1, 1, 1, 10, 1, 8, 1, 8, 7, 4, 2, 6, 1, 2, 3, 1, 4, 1, 1, 1, 6, 2, 10, 1, 1, 10, 1, 3, 10, 10, 1, 1, 3, 1, 1, 1, 1, 1, 3, 2, 1, 1, 3, 6, 1, 1, 1, 3, 1, 1, 4, 1, 4, 7, 4, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 5, 8, 1, 1, 1, 3, 3, 1, 1, 2, 1, 4, 10, 7, 1, 1, 2, 1, 4, 2, 1, 1, 1, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 10, 6, 8), V4 = c(1, 5, 1, 1, 3, 8, 1, 1, 1, 1, 1, 1, 3, 1, 10, 4, 1, 1, 6, 1, 10, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               3, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 3, 2, 1, 1, 8, 1, 9, 3, 9, 1, 2, 6, 4, 1, 4, 1, 3, 2, 1, 4, 2, 8, 6, 3, 1, 1, 1, 2, 5, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 8, 2, 10, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 8, 1, 4, 6, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 10, 1, 4, 1, 1, 10, 4, 8, 10, 1, 4, 2, 3, 10, 3, 1, 1, 1, 10, 1, 1, 2, 1, 2, 1, 7, 1, 7, 1, 4, 1, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 2, 1, 3, 4, 1, 1, 6, 1, 1, 6, 1, 1, 1, 3, 4, 1, 1, 2, 1, 1, 8, 10, 1, 2, 1, 1, 1, 10, 4, 7, 1, 3, 1, 3, 1, 1, 1, 8, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 6, 10, 10, 1, 8, 10, 1, 1, 1, 1, 5, 4, 1, 1, 5, 4, 1, 1, 1, 9, 3, 1, 1, 1, 10, 8, 1, 10, 10, 7, 1, 1, 7, 1, 2, 3, 3, 3, 6, 1, 4, 5, 1, 3, 4, 5, 3, 5, 1, 1, 2, 5, 8, 2, 3, 3, 1, 1, 1, 2, 8, 1, 1, 1, 1, 10, 5, 2, 1, 2, 1, 1, 1, 1, 10, 6, 4, 10, 10, 1, 3, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 2, 10, 1, 10, 10, 10, 1, 1, 8, 1, 1, 1, 6, 1, 8, 3, 1, 1, 6, 5, 1, 7, 1, 9, 4, 1, 1, 6, 1, 1, 1, 10, 1, 1, 6, 2, 8, 1, 4, 2, 1, 1, 10, 1, 1, 1, 1, 2, 4, 2, 1, 2, 6, 3, 1, 8, 1, 1, 5, 1, 1, 1, 1, 8, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 10, 5, 3, 1, 3, 10, 1, 1, 1, 7, 3, 4, 10, 10, 1, 2, 1, 1, 10, 10, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 4, 1, 1, 6, 2, 1, 1, 2, 3, 2, 1, 1, 2, 4, 1, 1, 1, 1, 1, 1, 1, 1, 7, 1, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 6, 1, 2, 6, 5, 1, 2, 1, 3, 7, 1, 1, 1, 10, 1, 2, 1, 1, 1, 3, 1, 3, 5, 1, 1, 1, 3, 1, 10, 4, 3, 1, 6, 1, 1, 1, 1, 8, 3, 1, 3, 8, 1, 1, 8, 6, 1, 1, 3, 1, 3, 1, 1, 7, 2, 5, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 10, 1, 4, 10, 5, 1, 3, 1, 10, 10, 1, 1, 4, 1, 10, 10, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 10, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 1, 1, 1, 1, 10, 7, 1, 1, 2, 3, 1, 1, 4, 10, 1, 2, 1, 1, 2, 1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 10, 1, 1, 7, 1, 1, 2, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 10, 4, 5, 1, 1, 3, 1, 1, 1, 1, 1, 1, 6, 5, 1, 6, 1, 10, 1, 9, 1, 5, 6, 5, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 3, 2, 1, 10, 1, 10, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 2, 1, 5, 1, 1, 1, 1, 1, 1, 4, 1, 1, 8, 3, 1, 3, 3, 1, 1, 1, 1, 1, 1, 3, 10, 1, 2, 3, 1, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 3, 1, 2, 1, 1, 8, 8, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 1, 1, 1, 1, 1, 1, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 3, 5, 1, 1, 1, 1, 3, 4, 5), V5 = c(2, 7, 2, 3, 2, 7, 2, 2, 2, 2, 1, 2, 2, 2, 7, 6, 2, 2, 4, 2, 5, 6, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 8, 2, 2, 2, 6, 1, 2, 6, 6, 3, 8, 10, 8, 2, 4, 2, 2, 4, 2, 2, 3, 10, 8, 4, 3, 5, 6, 2, 3, 2, 10, 5, 2, 3, 2, 8, 4, 2, 2, 10, 2, 6, 3, 2, 2, 2, 2, 3, 1, 2, 2, 2, 8, 10, 5, 5, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 10, 5, 10, 2, 2, 6, 10, 3, 2, 8, 2, 3, 2, 5, 2, 10, 2, 2, 2, 4, 4, 2, 2, 2, 10, 8, 9, 2, 4, 2, 5, 10, 2, 2, 8, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       3, 2, 2, 2, 2, 1, 2, 2, 4, 2, 2, 2, 6, 3, 8, 10, 1, 6, 4, 2, 2, 3, 2, 2, 3, 6, 5, 2, 2, 1, 2, 2, 8, 6, 2, 1, 2, 2, 2, 8, 3, 10, 2, 8, 2, 6, 1, 2, 2, 5, 4, 1, 5, 6, 5, 2, 6, 10, 2, 2, 2, 2, 4, 2, 2, 2, 5, 10, 2, 2, 2, 6, 7, 1, 1, 1, 5, 4, 2, 7, 3, 5, 2, 2, 6, 2, 2, 10, 1, 3, 3, 2, 4, 3, 1, 10, 3, 6, 3, 5, 3, 2, 8, 6, 6, 3, 2, 1, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 3, 8, 10, 4, 2, 2, 2, 5, 3, 10, 5, 6, 10, 2, 3, 3, 3, 2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2, 4, 2, 2, 8, 10, 3, 4, 6, 2, 2, 2, 2, 2, 6, 4, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       5, 4, 4, 2, 9, 2, 3, 4, 2, 2, 4, 2, 3, 2, 10, 2, 1, 7, 5, 6, 5, 6, 5, 2, 2, 2, 2, 2, 2, 2, 6, 5, 2, 2, 2, 4, 3, 2, 4, 2, 1, 2, 2, 2, 2, 2, 10, 2, 3, 1, 5, 3, 2, 2, 7, 7, 2, 3, 3, 10, 8, 3, 10, 6, 4, 2, 2, 2, 8, 5, 2, 1, 3, 2, 2, 2, 2, 2, 2, 1, 3, 4, 2, 4, 2, 2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 1, 2, 2, 2, 2, 2, 2, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 8, 2, 3, 3, 10, 2, 2, 5, 2, 10, 2, 2, 2, 10, 2, 4, 2, 2, 2, 4, 2, 2, 5, 3, 6, 2, 2, 2, 4, 2, 2, 2, 3, 2, 2, 2, 1, 6, 1, 2, 2, 6, 3, 2, 5, 6, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 6, 4, 4, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 4, 1, 2, 10, 5, 2, 1, 1, 6, 3, 3, 2, 3, 1, 6, 4, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 2, 2, 2, 2, 2, 2, 1, 3, 3, 1, 1, 2, 4, 3, 3, 3, 4, 2, 2, 2, 2, 2, 1, 4, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 1, 4, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 6, 6, 8, 3, 2, 2, 4, 2, 2, 2, 2, 2, 2, 5, 4, 2, 3, 2, 6, 2, 6, 2, 4, 4, 3, 2, 4, 2, 2, 2, 2, 1, 2, 1, 2, 4, 5, 5, 2, 2, 10, 2, 3, 5, 6, 2, 1, 2, 2, 1, 2, 2, 2, 3, 2, 2, 1, 3, 7, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 5, 2, 2, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 2, 3, 2, 2, 2, 2, 2, 2, 8, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 5, 5, 2, 2, 3, 2, 2, 2, 2, 2, 2, 5, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 3, 2, 7, 3, 4), V6 = c(1, 10, 2, 4, 1, 10, 10, 1, 1, 1, 1, 1, 3, 3, 9, 1, 1, 1, 10, 1, 10, 7, 1, NA, 1, 7, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 10, 7, NA, 3, 10, 1, 1, 1, 9, 1, 1, 8, 3, 4, 5, 8, 8, 5, 6, 1, 10, 2, 3, 2, 8, 2, 1, 2, 1, 10, 9, 1, 1, 2, 1, 10, 4, 2, 1, 1, 3, 1, 1, 1, 1, 2, 9, 4, 8, 10, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 1, 1, 1, 1, 1, 1, 6, 10, 5, 5, 1, 3, 1, 3, 10, 10, 1, 9, 2, 9, 10, 8, 3, 5, 2, 10, 3, 2, 1, 2, 10, 10, 7, 1, 10, 1, 10, 1, 1, 1, 10, 1, 1, 2, 1, 1, 1, NA, 1, 1, 5, 5, 1, NA, 8, 2, 1, 10, 1, 10, 5, 3, 1, 10, 1, 1, NA, 10, 10, 1, 1, 3, NA, 2, 10, 1, 1, 1, 1, 1, 1, 10, 10, 10, 1, 1, 1, 10, 1, 1, 1, 10, 10, 1, 8, 10, 8, 1, 8, 10, 1, 1, 1, 1, 7, 1, 1, 1, 10, 10, 1, 1, 1, 10, 5, 1, 1, 1, 10, 8, 1, 10, 10, 5, 1, 1, 4, 1, 1, 10, 5, 8, 10, 1, 10, 5, 1, 10, 7, 8, 1, 10, 1, NA, 10, 2, 9, 10, 2, 1, 1, 5, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 2, 10, 9, 1, NA, 1, 10, 10, 10, 8, 10, 1, 1, 1, 8, 10, 10, 10, 10, 3, 1, 10, 10, 4, 1, 10, 1, 10, 4, 1, NA, 1, 1, 1, 7, 1, 1, 10, 10, 10, 10, 10, 1, 5, 10, 1, 1, NA, 10, NA, 10, 5, NA, 1, 10, 4, 1, 10, 1, 10, 10, 1, 1, 3, 5, 1, 1, 1, 1, 1, NA, 10, 8, 1, 5, 10, NA, 1, 10, 1, 1, 10, 1, 4, 10, 8, 1, 1, 10, 10, 1, 10, 1, 1, 10, 10, 1, 1, 1, 10, 1, 1, 1, 1, 8, 1, 1, 3, 10, 1, 1, 3, 10, 4, 7, 10, 10, 3, 3, 1, 1, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 10, 1, 1, 2, 1, 10, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 1, 1, 1, 1, 1, 9, 1, 1, 4, 1, 1, 1, 1, 2, 1, 1, NA, 4, 1, 10, 3, 10, 1, 2, 1, 3, 10, 1, 1, 1, 10, 1, 2, 1, 1, 1, 1, 1, 1, 8, 10, 1, 1, 1, 1, 10, 4, 3, 2, 1, 1, 1, 1, 1, 10, 1, 1, 1, 10, 1, 6, 10, 3, 1, 1, 1, 5, 1, 1, 1, 4, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 5, 10, 1, 3, 1, 10, 3, 4, 1, 10, 1, 10, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 4, 1, 1, 1, 1, 1, 1, 10, 10, 1, 1, 1, 10, 1, 1, 5, 10, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 10, 1, 1, 5, 1, 1, 1, 5, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 3, 10, 5, 10, 10, 1, 1, 2, 1, 1, 1, 1, 1, 1, 10, 10, 1, 1, 1, 10, 1, 3, 1, 1, 10, 10, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 8, 1, 1, 10, 1, 10, 2, 10, 1, 1, 1, 1, NA, 1, 1, 1, 2, 1, 1, 1, 4, 6, 5, 1, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 4, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 2, 1, 3, 4, 5), V7 = c(3, 3, 3, 3, 3, 9, 3, 3, 1, 2, 3, 2, 4, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            5, 4, 2, 3, 4, 3, 5, 7, 2, 7, 3, 3, 2, 2, 2, 1, 2, 3, 7, 3, 2, 2, 8, 7, 5, 7, 7, 6, 7, 3, 8, 2, 4, 2, 3, 3, 2, 3, 4, 7, 7, 3, 3, 5, 5, 5, 4, 2, 3, 3, 2, 4, 3, 4, 8, 3, 2, 7, 7, 4, 3, 4, 2, 2, 3, 2, 7, 2, 3, 7, 7, 4, 4, 6, 3, 2, 3, 1, 3, 2, 3, 3, 1, 3, 2, 7, 3, 2, 3, 7, 8, 3, 4, 5, 2, 7, 5, 3, 7, 8, 3, 1, 3, 7, 1, 3, 3, 3, 5, 5, 8, 2, 7, 3, 1, 1, 2, 3, 3, 2, 2, 3, 2, 1, 2, 2, 1, 1, 4, 1, 2, 2, 4, 2, 5, 7, 3, 5, 8, 1, 1, 3, 2, 3, 1, 7, 5, 3, 3, 1, 3, 3, 3, 3, 3, 1, 1, 3, 2, 10, 6, 5, 3, 5, 3, 3, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            1, 3, 7, 5, 3, 7, 7, 9, 3, 7, 4, 2, 3, 3, 3, 7, 3, 1, 2, 7, 8, 3, 3, 3, 7, 3, 3, 3, 3, 8, 7, 3, 7, 10, 5, 2, 3, 8, 3, 3, 9, 2, 7, 7, 2, 8, 7, 3, 9, 7, 8, 4, 4, 3, 3, 4, 4, 3, 5, 2, 3, 3, 5, 3, 3, 7, 3, 3, 3, 1, 5, 3, 7, 3, 3, 1, 2, 3, 3, 5, 10, 7, 5, 5, 3, 4, 7, 8, 3, 3, 3, 7, 3, 3, 2, 2, 2, 3, 3, 3, 3, 5, 5, 3, 10, 4, 2, 5, 4, 1, 3, 6, 2, 2, 7, 4, 2, 1, 7, 7, 3, 7, 3, 3, 3, 3, 3, 8, 5, 2, 1, 3, 1, 2, 4, 4, 8, 3, 7, 7, 3, 3, 4, 3, 2, 5, 2, 3, 7, 6, 3, 2, 4, 3, 1, 3, 3, 2, 4, 7, 3, 1, 1, 9, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            1, 3, 7, 1, 3, 4, 4, 2, 2, 3, 7, 4, 3, 8, 5, 2, 2, 3, 2, 7, 8, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 3, 1, 7, 3, 1, 1, 1, 7, 3, 2, 2, 2, 7, 2, 1, 2, 2, 3, 1, 2, 1, 9, 1, 2, 1, 1, 2, 2, 2, 3, 2, 2, 2, 8, 3, 6, 3, 7, 2, 3, 1, 3, 8, 3, 2, 1, 10, 1, 5, 2, 2, 2, 3, 2, 1, 4, 5, 2, 1, 1, 1, 10, 1, 1, 1, 2, 1, 1, 1, 1, 8, 2, 1, 1, 10, 1, 1, 8, 10, 1, 1, 1, 1, 1, 1, 1, 7, 9, 7, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 7, 1, 1, 10, 9, 1, 1, 2, 8, 3, 4, 1, 7, 2, 6, 2, 2, 1, 1, 2, 2, 3, 2, 2, 3, 1, 1, 4, 1, 1, 1, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            2, 8, 9, 1, 2, 1, 9, 1, 1, 7, 5, 2, 1, 1, 3, 1, 2, 6, 2, 3, 2, 2, 3, 3, 3, 2, 2, 2, 1, 1, 2, 2, 2, 7, 1, 1, 7, 2, 3, 4, 2, 1, 4, 2, 1, 2, 2, 3, 3, 3, 2, 3, 10, 3, 2, 2, 10, 8, 9, 2, 2, 7, 3, 2, 2, 2, 3, 2, 7, 6, 1, 1, 1, 10, 2, 4, 1, 10, 7, 4, 1, 7, 2, 2, 3, 2, 1, 2, 2, 2, 8, 8, 7, 1, 1, 10, 1, 7, 8, 10, 2, 2, 2, 2, 1, 2, 2, 2, 6, 2, 1, 2, 1, 7, 1, 1, 1, 1, 2, 1, 5, 1, 1, 10, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 10, 2, 1, 2, 2, 2, 3, 2, 2, 3, 7, 1, 2, 3, 2, 2, 2, 1, 1, 3, 7, 7, 7, 3, 3, 1, 2, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            1, 1, 10, 5, 3, 1, 1, 1, 1, 2, 1, 1, 1, 4, 1, 2, 1, 1, 8, 10, 10), V8 = c(1, 2, 1, 7, 1, 7, 1, 1, 1, 1, 1, 1, 4, 1, 5, 3, 1, 1, 1, 1, 4, 10, 1, 3, 1, 6, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 9, 1, 6, 5, 8, 5, 3, 1, 10, 1, 8, 1, 1, 8, 1, 4, 10, 3, 1, 6, 9, 4, 1, 1, 10, 1, 3, 9, 1, 3, 1, 9, 9, 2, 1, 8, 2, 8, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 10, 4, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 10, 5, 1, 1, 8, 2, 1, 7, 3, 8, 3, 1, 3, 1, 1, 1, 2, 5, 1, 1, 1, 1, 3, 3, 10, 1, 5, 1, 6, 1, 1, 1, 6, 2, 1, 3, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      1, 1, 3, 1, 1, 1, 1, 1, 8, 8, 1, 4, 10, 1, 1, 1, 1, 1, 1, 10, 7, 2, 1, 1, 1, 2, 10, 1, 1, 1, 1, 1, 1, 10, 1, 7, 1, 10, 1, 1, 1, 1, 1, 8, 1, 1, 10, 7, 10, 1, 10, 10, 1, 1, 1, 1, 8, 1, 1, 1, 8, 1, 1, 1, 1, 10, 5, 1, 1, 1, 10, 7, 1, 10, 6, 10, 1, 1, 10, 1, 1, 10, 1, 4, 9, 1, 9, 7, 1, 10, 6, 9, 3, 1, 6, 1, 8, 10, 10, 3, 3, 1, 1, 1, 1, 1, 8, 3, 6, 1, 1, 3, 5, 3, 3, 6, 1, 1, 1, 4, 1, 6, 8, 5, 3, 2, 3, 1, 7, 1, 9, 1, 1, 3, 2, 1, 1, 1, 1, 3, 1, 1, 6, 3, 8, 7, 10, 1, 10, 10, 1, 1, 10, 3, 1, 4, 7, 3, 1, 7, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      10, 1, 10, 1, 3, 10, 1, 1, 8, 1, 1, 1, 5, 1, 1, 9, 3, 9, 1, 3, 4, 1, 1, 1, 1, 3, 4, 1, 10, 1, 1, 1, 2, 3, 4, 1, 4, 1, 1, 3, 6, 1, 1, 1, 5, 1, 3, 3, 3, 6, 1, 1, 6, 9, 1, 2, 3, 3, 10, 5, 10, 1, 1, 1, 1, 1, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 8, 2, 1, 1, 2, 1, 1, 2, 2, 1, 9, 1, 1, 1, 1, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 5, 1, 6, 5, 2, 1, 2, 1, 1, 2, 3, 1, 1, 10, 1, 10, 1, 1, 2, 2, 2, 1, 2, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 7, 1, 1, 6, 10, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      2, 1, 10, 7, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 10, 10, 1, 1, 1, 1, 4, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 10, 10, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 8, 1, 1, 2, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 2, 10, 1, 1, 5, 3, 2, 10, 1, 1, 7, 1, 1, 1, 1, 1, 1, 5, 10, 1, 1, 1, 10, 2, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 8, 1, 1, 1, 1, 1, 5, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      7, 1, 1, 1, 1, 1, 1, 10, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 2, 1, 1, 1, 1, 6, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 10, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 6, 2, 1, 1, 1, 1, 3, 1, 1, 1, 4, 1, 1, 1, 1, 10, 6, 4), V9 = c(1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 4, 1, 1, 1, 2, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 2, 1, 1, 1, 2, 5, 1, 2, 7, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 8, 1, 1, 10, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 10, 1, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 4, 2, 1, 1, 1, 8, 7, 1, 1, 1, 3, 2, 1, 3, 1, 1, 1, 1, 8, 1, 1, 1, 1, 3, 1, 1, 1, 5, 1, 2, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 7, 1, 3, 1, 1, 1, 1, 1, 1, 1, 6, 2, 1, 1, 7, 1, 1, 3, 10, 1, 1, 1, 1, 1, 7, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 1, 5, 1, 1, 1, 1, 6, 1, 1, 4, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 10, 4, 10, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1, 1, 1, 1, 1, 1, 3, 5, 1, 1, 3, 1, 2, 1, 8, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 2, 3, 10, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 10, 1, 1, 4, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 3, 8, 3, 3, 10, 4, 1, 1, 1, 1, 7, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1, 2, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 2, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 3, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 2, 1, 1, 2, 1, 1), class = c(1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 2, 2, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2)))
package:MASS
TRUE
FALSE
birthwt
list(`package:MASS` = list(low = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), age = c(19, 33, 20, 21, 18, 21, 22, 17, 29, 26, 19, 19, 22, 30, 18, 18, 15, 25, 20, 28, 32, 31, 36, 28, 25, 28, 17, 29, 26, 17, 17, 24, 35, 25, 25, 29, 19, 27, 31, 33, 21, 19, 23, 21, 18, 18, 32, 19, 24, 22, 22, 23, 22, 30, 19, 16, 21, 30, 20, 17, 17, 23, 24, 28, 26, 20, 24, 28, 20, 22, 22, 31, 23, 16, 16, 18, 25, 32, 20, 23, 22, 32, 30, 20, 23, 17, 19, 23, 36, 22, 24, 21, 19, 25, 16, 29, 29, 19, 19, 
                                                                                                                                               30, 24, 19, 24, 23, 20, 25, 30, 22, 18, 16, 32, 18, 29, 33, 20, 28, 14, 28, 25, 16, 20, 26, 21, 22, 25, 31, 35, 19, 24, 45, 28, 29, 34, 25, 25, 27, 23, 24, 24, 21, 32, 19, 25, 16, 25, 20, 21, 24, 21, 20, 25, 19, 19, 26, 24, 17, 20, 22, 27, 20, 17, 25, 20, 18, 18, 20, 21, 26, 31, 15, 23, 20, 24, 15, 23, 30, 22, 17, 23, 17, 26, 20, 26, 14, 28, 14, 23, 17, 21), lwt = c(182, 155, 105, 108, 107, 124, 118, 103, 123, 113, 95, 150, 95, 107, 100, 100, 98, 118, 120, 120, 121, 100, 202, 120, 120, 167, 122, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                150, 168, 113, 113, 90, 121, 155, 125, 140, 138, 124, 215, 109, 185, 189, 130, 160, 90, 90, 132, 132, 115, 85, 120, 128, 130, 95, 115, 110, 110, 153, 103, 119, 119, 119, 110, 140, 133, 169, 115, 250, 141, 158, 112, 150, 115, 112, 135, 229, 140, 134, 121, 190, 131, 170, 110, 127, 123, 120, 105, 130, 175, 125, 133, 134, 235, 95, 135, 135, 154, 147, 147, 137, 110, 184, 110, 110, 120, 241, 112, 169, 120, 170, 186, 120, 130, 117, 170, 134, 135, 130, 120, 95, 158, 160, 115, 129, 130, 120, 170, 120, 116, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                123, 120, 130, 187, 105, 85, 150, 97, 128, 132, 165, 105, 91, 115, 130, 92, 150, 200, 155, 103, 125, 89, 102, 112, 117, 138, 130, 120, 130, 130, 80, 110, 105, 109, 148, 110, 121, 100, 96, 102, 110, 187, 122, 105, 115, 120, 142, 130, 120, 110, 120, 154, 105, 190, 101, 95, 100, 94, 142, 130), race = c(2, 3, 1, 1, 1, 3, 1, 3, 1, 1, 3, 3, 3, 3, 1, 1, 2, 1, 3, 1, 3, 1, 1, 3, 3, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 3, 1, 3, 1, 3, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             3, 1, 2, 1, 3, 3, 2, 1, 2, 1, 1, 2, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 2, 1, 1, 1, 2, 1, 3, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 2, 3, 3, 3, 3, 2, 3, 1, 1, 1, 3, 3, 1, 1, 2, 1, 3, 3, 3, 1, 1, 1, 1, 3, 2, 1, 2, 3, 1, 3, 3, 3, 2, 1, 3, 3, 1, 1, 2, 2, 2, 3, 3, 1, 1, 1, 1, 2, 3, 3, 1, 3, 1, 3, 3, 2, 1), smoke = c(0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1), ptl = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 2, 1, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        0, 0, 0, 0, 0), ht = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1), ui = c(1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), ftv = c(0, 3, 1, 2, 0, 0, 1, 1, 1, 0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 1, 2, 3, 1, 0, 2, 0, 0, 2, 0, 1, 1, 1, 1, 1, 0, 2, 2, 0, 2, 1, 2, 2, 1, 0, 0, 0, 4, 0, 2, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 2, 6, 1, 2, 0, 2, 1, 0, 0, 0, 1, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 2, 4, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      1, 2, 1, 0, 1, 0, 0, 2, 1, 1, 0, 1, 0, 2, 2, 1, 0, 1, 1, 0, 2, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 2, 2, 0, 0, 0, 1, 2, 0, 0, 0, 0, 3, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 3, 0, 2, 1, 3, 0, 0, 2, 2, 0, 0, 3), bwt = c(2523, 2551, 2557, 2594, 2600, 2622, 2637, 2637, 2663, 2665, 2722, 2733, 2751, 2750, 2769, 2769, 2778, 2782, 2807, 2821, 2835, 2835, 2836, 2863, 2877, 2877, 2906, 2920, 2920, 2920, 2920, 2948, 2948, 2977, 2977, 2977, 2977, 2922, 3005, 3033, 3042, 3062, 3062, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         3062, 3062, 3062, 3080, 3090, 3090, 3090, 3100, 3104, 3132, 3147, 3175, 3175, 3203, 3203, 3203, 3225, 3225, 3232, 3232, 3234, 3260, 3274, 3274, 3303, 3317, 3317, 3317, 3321, 3331, 3374, 3374, 3402, 3416, 3430, 3444, 3459, 3460, 3473, 3544, 3487, 3544, 3572, 3572, 3586, 3600, 3614, 3614, 3629, 3629, 3637, 3643, 3651, 3651, 3651, 3651, 3699, 3728, 3756, 3770, 3770, 3770, 3790, 3799, 3827, 3856, 3860, 3860, 3884, 3884, 3912, 3940, 3941, 3941, 3969, 3983, 3997, 3997, 4054, 4054, 4111, 4153, 4167, 4174, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         4238, 4593, 4990, 709, 1021, 1135, 1330, 1474, 1588, 1588, 1701, 1729, 1790, 1818, 1885, 1893, 1899, 1928, 1928, 1928, 1936, 1970, 2055, 2055, 2082, 2084, 2084, 2100, 2125, 2126, 2187, 2187, 2211, 2225, 2240, 2240, 2282, 2296, 2296, 2301, 2325, 2353, 2353, 2367, 2381, 2381, 2381, 2410, 2410, 2410, 2414, 2424, 2438, 2442, 2450, 2466, 2466, 2466, 2495, 2495, 2495, 2495)))
package:MASS
TRUE
FALSE
Boston
list(`package:MASS` = list(crim = c(0.00632, 0.02731, 0.02729, 0.03237, 0.06905, 0.02985, 0.08829, 0.14455, 0.21124, 0.17004, 0.22489, 0.11747, 0.09378, 0.62976, 0.63796, 0.62739, 1.05393, 0.7842, 0.80271, 0.7258, 1.25179, 0.85204, 1.23247, 0.98843, 0.75026, 0.84054, 0.67191, 0.95577, 0.77299, 1.00245, 1.13081, 1.35472, 1.38799, 1.15172, 1.61282, 0.06417, 0.09744, 0.08014, 0.17505, 0.02763, 0.03359, 0.12744, 0.1415, 0.15936, 0.12269, 0.17142, 0.18836, 0.22927, 0.25387, 0.21977, 0.08873, 0.04337, 
                                    0.0536, 0.04981, 0.0136, 0.01311, 0.02055, 0.01432, 0.15445, 0.10328, 0.14932, 0.17171, 0.11027, 0.1265, 0.01951, 0.03584, 0.04379, 0.05789, 0.13554, 0.12816, 0.08826, 0.15876, 0.09164, 0.19539, 0.07896, 0.09512, 0.10153, 0.08707, 0.05646, 0.08387, 0.04113, 0.04462, 0.03659, 0.03551, 0.05059, 0.05735, 0.05188, 0.07151, 0.0566, 0.05302, 0.04684, 0.03932, 0.04203, 0.02875, 0.04294, 0.12204, 0.11504, 0.12083, 0.08187, 0.0686, 0.14866, 0.11432, 0.22876, 0.21161, 0.1396, 0.13262, 0.1712, 0.13117, 0.12802, 
                                    0.26363, 0.10793, 0.10084, 0.12329, 0.22212, 0.14231, 0.17134, 0.13158, 0.15098, 0.13058, 0.14476, 0.06899, 0.07165, 0.09299, 0.15038, 0.09849, 0.16902, 0.38735, 0.25915, 0.32543, 0.88125, 0.34006, 1.19294, 0.59005, 0.32982, 0.97617, 0.55778, 0.32264, 0.35233, 0.2498, 0.54452, 0.2909, 1.62864, 3.32105, 4.0974, 2.77974, 2.37934, 2.15505, 2.36862, 2.33099, 2.73397, 1.6566, 1.49632, 1.12658, 2.14918, 1.41385, 3.53501, 2.44668, 1.22358, 1.34284, 1.42502, 1.27346, 1.46336, 1.83377, 1.51902, 2.24236, 2.924, 
                                    2.01019, 1.80028, 2.3004, 2.44953, 1.20742, 2.3139, 0.13914, 0.09178, 0.08447, 0.06664, 0.07022, 0.05425, 0.06642, 0.0578, 0.06588, 0.06888, 0.09103, 0.10008, 0.08308, 0.06047, 0.05602, 0.07875, 0.12579, 0.0837, 0.09068, 0.06911, 0.08664, 0.02187, 0.01439, 0.01381, 0.04011, 0.04666, 0.03768, 0.0315, 0.01778, 0.03445, 0.02177, 0.0351, 0.02009, 0.13642, 0.22969, 0.25199, 0.13587, 0.43571, 0.17446, 0.37578, 0.21719, 0.14052, 0.28955, 0.19802, 0.0456, 0.07013, 0.11069, 0.11425, 0.35809, 0.40771, 0.62356, 
                                    0.6147, 0.31533, 0.52693, 0.38214, 0.41238, 0.29819, 0.44178, 0.537, 0.46296, 0.57529, 0.33147, 0.44791, 0.33045, 0.52058, 0.51183, 0.08244, 0.09252, 0.11329, 0.10612, 0.1029, 0.12757, 0.20608, 0.19133, 0.33983, 0.19657, 0.16439, 0.19073, 0.1403, 0.21409, 0.08221, 0.36894, 0.04819, 0.03548, 0.01538, 0.61154, 0.66351, 0.65665, 0.54011, 0.53412, 0.52014, 0.82526, 0.55007, 0.76162, 0.7857, 0.57834, 0.5405, 0.09065, 0.29916, 0.16211, 0.1146, 0.22188, 0.05644, 0.09604, 0.10469, 0.06127, 0.07978, 0.21038, 
                                    0.03578, 0.03705, 0.06129, 0.01501, 0.00906, 0.01096, 0.01965, 0.03871, 0.0459, 0.04297, 0.03502, 0.07886, 0.03615, 0.08265, 0.08199, 0.12932, 0.05372, 0.14103, 0.06466, 0.05561, 0.04417, 0.03537, 0.09266, 0.1, 0.05515, 0.05479, 0.07503, 0.04932, 0.49298, 0.3494, 2.63548, 0.79041, 0.26169, 0.26938, 0.3692, 0.25356, 0.31827, 0.24522, 0.40202, 0.47547, 0.1676, 0.18159, 0.35114, 0.28392, 0.34109, 0.19186, 0.30347, 0.24103, 0.06617, 0.06724, 0.04544, 0.05023, 0.03466, 0.05083, 0.03738, 0.03961, 0.03427, 
                                    0.03041, 0.03306, 0.05497, 0.06151, 0.01301, 0.02498, 0.02543, 0.03049, 0.03113, 0.06162, 0.0187, 0.01501, 0.02899, 0.06211, 0.0795, 0.07244, 0.01709, 0.04301, 0.10659, 8.98296, 3.8497, 5.20177, 4.26131, 4.54192, 3.83684, 3.67822, 4.22239, 3.47428, 4.55587, 3.69695, 13.5222, 4.89822, 5.66998, 6.53876, 9.2323, 8.26725, 11.1081, 18.4982, 19.6091, 15.288, 9.82349, 23.6482, 17.8667, 88.9762, 15.8744, 9.18702, 7.99248, 20.0849, 16.8118, 24.3938, 22.5971, 14.3337, 8.15174, 6.96215, 5.29305, 11.5779, 8.64476, 
                                    13.3598, 8.71675, 5.87205, 7.67202, 38.3518, 9.91655, 25.0461, 14.2362, 9.59571, 24.8017, 41.5292, 67.9208, 20.7162, 11.9511, 7.40389, 14.4383, 51.1358, 14.0507, 18.811, 28.6558, 45.7461, 18.0846, 10.8342, 25.9406, 73.5341, 11.8123, 11.0874, 7.02259, 12.0482, 7.05042, 8.79212, 15.8603, 12.2472, 37.6619, 7.36711, 9.33889, 8.49213, 10.0623, 6.44405, 5.58107, 13.9134, 11.1604, 14.4208, 15.1772, 13.6781, 9.39063, 22.0511, 9.72418, 5.66637, 9.96654, 12.8023, 10.6718, 6.28807, 9.92485, 9.32909, 7.52601, 
                                    6.71772, 5.44114, 5.09017, 8.24809, 9.51363, 4.75237, 4.66883, 8.20058, 7.75223, 6.80117, 4.81213, 3.69311, 6.65492, 5.82115, 7.83932, 3.1636, 3.77498, 4.42228, 15.5757, 13.0751, 4.34879, 4.03841, 3.56868, 4.64689, 8.05579, 6.39312, 4.87141, 15.0234, 10.233, 14.3337, 5.82401, 5.70818, 5.73116, 2.81838, 2.37857, 3.67367, 5.69175, 4.83567, 0.15086, 0.18337, 0.20746, 0.10574, 0.11132, 0.17331, 0.27957, 0.17899, 0.2896, 0.26838, 0.23912, 0.17783, 0.22438, 0.06263, 0.04527, 0.06076, 0.10959, 0.04741), 
                           zn = c(18, 0, 0, 0, 0, 0, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 12.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 21, 21, 21, 75, 90, 85, 100, 25, 25, 25, 25, 25, 25, 17.5, 80, 80, 12.5, 12.5, 12.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 25, 25, 25, 0, 0, 0, 0, 0, 0, 0, 0, 28, 28, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 45, 45, 45, 45, 45, 60, 60, 80, 80, 80, 80, 95, 95, 82.5, 82.5, 95, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 30, 30, 30, 30, 30, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 80, 80, 90, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 40, 40, 40, 40, 40, 20, 20, 20, 20, 90, 90, 55, 80, 
                                  52.5, 52.5, 52.5, 80, 80, 80, 0, 0, 0, 0, 0, 70, 70, 70, 34, 34, 34, 33, 33, 33, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35, 35, 0, 0, 0, 0, 0, 0, 0, 0, 35, 0, 55, 55, 0, 0, 85, 80, 40, 40, 60, 60, 90, 80, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), indus = c(2.31, 7.07, 7.07, 2.18, 2.18, 2.18, 7.87, 7.87, 7.87, 7.87, 7.87, 7.87, 7.87, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 8.14, 5.96, 5.96, 5.96, 5.96, 2.95, 2.95, 6.91, 6.91, 6.91, 6.91, 6.91, 6.91, 6.91, 6.91, 
                                                                                                                                                                                                                                                6.91, 5.64, 5.64, 5.64, 5.64, 4, 1.22, 0.74, 1.32, 5.13, 5.13, 5.13, 5.13, 5.13, 5.13, 1.38, 3.37, 3.37, 6.07, 6.07, 6.07, 10.81, 10.81, 10.81, 10.81, 12.83, 12.83, 12.83, 12.83, 12.83, 12.83, 4.86, 4.86, 4.86, 4.86, 4.49, 4.49, 4.49, 4.49, 3.41, 3.41, 3.41, 3.41, 15.04, 15.04, 15.04, 2.89, 2.89, 2.89, 2.89, 2.89, 8.56, 8.56, 8.56, 8.56, 8.56, 8.56, 8.56, 8.56, 8.56, 8.56, 8.56, 10.01, 10.01, 10.01, 10.01, 10.01, 10.01, 10.01, 10.01, 10.01, 25.65, 25.65, 25.65, 25.65, 25.65, 25.65, 25.65, 21.89, 
                                                                                                                                                                                                                                                21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 21.89, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 19.58, 4.05, 4.05, 4.05, 4.05, 4.05, 4.05, 4.05, 2.46, 2.46, 2.46, 2.46, 2.46, 2.46, 2.46, 2.46, 3.44, 3.44, 3.44, 3.44, 3.44, 3.44, 2.93, 2.93, 0.46, 1.52, 1.52, 1.52, 1.47, 1.47, 2.03, 2.03, 2.68, 
                                                                                                                                                                                                                                                2.68, 10.59, 10.59, 10.59, 10.59, 10.59, 10.59, 10.59, 10.59, 10.59, 10.59, 10.59, 13.89, 13.89, 13.89, 13.89, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 6.2, 4.93, 4.93, 4.93, 4.93, 4.93, 4.93, 5.86, 5.86, 5.86, 5.86, 5.86, 5.86, 5.86, 5.86, 5.86, 5.86, 3.64, 3.64, 3.75, 3.97, 3.97, 3.97, 3.97, 3.97, 3.97, 3.97, 3.97, 3.97, 3.97, 3.97, 3.97, 6.96, 6.96, 6.96, 6.96, 6.96, 6.41, 6.41, 6.41, 6.41, 6.41, 3.33, 3.33, 3.33, 3.33, 1.21, 2.97, 2.25, 1.76, 5.32, 
                                                                                                                                                                                                                                                5.32, 5.32, 4.95, 4.95, 4.95, 13.92, 13.92, 13.92, 13.92, 13.92, 2.24, 2.24, 2.24, 6.09, 6.09, 6.09, 2.18, 2.18, 2.18, 2.18, 9.9, 9.9, 9.9, 9.9, 9.9, 9.9, 9.9, 9.9, 9.9, 9.9, 9.9, 9.9, 7.38, 7.38, 7.38, 7.38, 7.38, 7.38, 7.38, 7.38, 3.24, 3.24, 3.24, 6.06, 6.06, 5.19, 5.19, 5.19, 5.19, 5.19, 5.19, 5.19, 5.19, 1.52, 1.89, 3.78, 3.78, 4.39, 4.39, 4.15, 2.01, 1.25, 1.25, 1.69, 1.69, 2.02, 1.91, 1.91, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 
                                                                                                                                                                                                                                                18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 
                                                                                                                                                                                                                                                18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 18.1, 27.74, 27.74, 27.74, 27.74, 27.74, 9.69, 9.69, 9.69, 9.69, 9.69, 9.69, 9.69, 9.69, 11.93, 11.93, 11.93, 11.93, 11.93), chas = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), nox = c(0.538, 0.469, 0.469, 0.458, 0.458, 0.458, 0.524, 0.524, 0.524, 0.524, 0.524, 0.524, 0.524, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.538, 0.499, 0.499, 0.499, 0.499, 0.428, 0.428, 0.448, 0.448, 0.448, 0.448, 0.448, 0.448, 0.448, 0.448, 0.448, 0.439, 0.439, 0.439, 0.439, 0.41, 0.403, 0.41, 0.411, 0.453, 0.453, 0.453, 0.453, 0.453, 0.453, 0.4161, 0.398, 0.398, 0.409, 0.409, 0.409, 0.413, 0.413, 0.413, 0.413, 0.437, 0.437, 0.437, 0.437, 0.437, 0.437, 0.426, 0.426, 0.426, 0.426, 0.449, 0.449, 0.449, 0.449, 0.489, 0.489, 0.489, 0.489, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0.464, 0.464, 0.464, 0.445, 0.445, 0.445, 0.445, 0.445, 0.52, 0.52, 0.52, 0.52, 0.52, 0.52, 0.52, 0.52, 0.52, 0.52, 0.52, 0.547, 0.547, 0.547, 0.547, 0.547, 0.547, 0.547, 0.547, 0.547, 0.581, 0.581, 0.581, 0.581, 0.581, 0.581, 0.581, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.624, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.871, 0.605, 0.605, 0.871, 0.605, 0.605, 0.605, 0.605, 0.605, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0.605, 0.605, 0.605, 0.605, 0.605, 0.605, 0.605, 0.51, 0.51, 0.51, 0.51, 0.51, 0.51, 0.51, 0.488, 0.488, 0.488, 0.488, 0.488, 0.488, 0.488, 0.488, 0.437, 0.437, 0.437, 0.437, 0.437, 0.437, 0.401, 0.401, 0.422, 0.404, 0.404, 0.404, 0.403, 0.403, 0.415, 0.415, 0.4161, 0.4161, 0.489, 0.489, 0.489, 0.489, 0.489, 0.489, 0.489, 0.489, 0.489, 0.489, 0.489, 0.55, 0.55, 0.55, 0.55, 0.507, 0.507, 0.507, 0.507, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.507, 0.507, 0.507, 0.507, 0.507, 0.507, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0.428, 0.428, 0.428, 0.428, 0.428, 0.428, 0.431, 0.431, 0.431, 0.431, 0.431, 0.431, 0.431, 0.431, 0.431, 0.431, 0.392, 0.392, 0.394, 0.647, 0.647, 0.647, 0.647, 0.647, 0.647, 0.647, 0.647, 0.647, 0.647, 0.575, 0.575, 0.464, 0.464, 0.464, 0.464, 0.464, 0.447, 0.447, 0.447, 0.447, 0.447, 0.4429, 0.4429, 0.4429, 0.4429, 0.401, 0.4, 0.389, 0.385, 0.405, 0.405, 0.405, 0.411, 0.411, 0.411, 0.437, 0.437, 0.437, 0.437, 0.437, 0.4, 0.4, 0.4, 0.433, 0.433, 0.433, 0.472, 0.472, 0.472, 0.472, 0.544, 0.544, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0.544, 0.544, 0.544, 0.544, 0.544, 0.544, 0.544, 0.544, 0.544, 0.544, 0.493, 0.493, 0.493, 0.493, 0.493, 0.493, 0.493, 0.493, 0.46, 0.46, 0.46, 0.4379, 0.4379, 0.515, 0.515, 0.515, 0.515, 0.515, 0.515, 0.515, 0.515, 0.442, 0.518, 0.484, 0.484, 0.442, 0.442, 0.429, 0.435, 0.429, 0.429, 0.411, 0.411, 0.41, 0.413, 0.413, 0.77, 0.77, 0.77, 0.77, 0.77, 0.77, 0.77, 0.77, 0.718, 0.718, 0.718, 0.631, 0.631, 0.631, 0.631, 0.631, 0.668, 0.668, 0.668, 0.671, 0.671, 0.671, 0.671, 0.671, 0.671, 0.671, 0.7, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.693, 0.693, 0.693, 0.693, 0.693, 0.693, 0.693, 0.693, 0.693, 0.693, 0.693, 0.693, 0.693, 0.659, 0.659, 0.597, 0.597, 0.597, 0.597, 0.597, 0.597, 0.693, 0.679, 0.679, 0.679, 0.679, 0.718, 0.718, 0.718, 0.614, 0.614, 0.584, 0.679, 0.584, 0.679, 0.679, 0.679, 0.584, 0.584, 0.584, 0.713, 0.713, 0.74, 0.74, 0.74, 0.74, 0.74, 0.74, 0.74, 0.74, 0.74, 0.74, 0.74, 0.74, 0.74, 0.713, 0.713, 0.713, 0.713, 0.713, 0.713, 0.713, 0.713, 0.713, 0.713, 0.713, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0.713, 0.713, 0.713, 0.713, 0.713, 0.655, 0.655, 0.655, 0.584, 0.58, 0.58, 0.58, 0.532, 0.58, 0.614, 0.584, 0.584, 0.614, 0.614, 0.614, 0.614, 0.532, 0.532, 0.532, 0.532, 0.583, 0.583, 0.583, 0.583, 0.609, 0.609, 0.609, 0.609, 0.609, 0.585, 0.585, 0.585, 0.585, 0.585, 0.585, 0.585, 0.585, 0.573, 0.573, 0.573, 0.573, 0.573), rm = c(6.575, 6.421, 7.185, 6.998, 7.147, 6.43, 6.012, 6.172, 5.631, 6.004, 6.377, 6.009, 5.889, 5.949, 6.096, 5.834, 5.935, 5.99, 5.456, 5.727, 5.57, 5.965, 6.142, 5.813, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5.924, 5.599, 5.813, 6.047, 6.495, 6.674, 5.713, 6.072, 5.95, 5.701, 6.096, 5.933, 5.841, 5.85, 5.966, 6.595, 7.024, 6.77, 6.169, 6.211, 6.069, 5.682, 5.786, 6.03, 5.399, 5.602, 5.963, 6.115, 6.511, 5.998, 5.888, 7.249, 6.383, 6.816, 6.145, 5.927, 5.741, 5.966, 6.456, 6.762, 7.104, 6.29, 5.787, 5.878, 5.594, 5.885, 6.417, 5.961, 6.065, 6.245, 6.273, 6.286, 6.279, 6.14, 6.232, 5.874, 6.727, 6.619, 6.302, 6.167, 6.389, 6.63, 6.015, 6.121, 7.007, 7.079, 6.417, 6.405, 6.442, 6.211, 6.249, 6.625, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           6.163, 8.069, 7.82, 7.416, 6.727, 6.781, 6.405, 6.137, 6.167, 5.851, 5.836, 6.127, 6.474, 6.229, 6.195, 6.715, 5.913, 6.092, 6.254, 5.928, 6.176, 6.021, 5.872, 5.731, 5.87, 6.004, 5.961, 5.856, 5.879, 5.986, 5.613, 5.693, 6.431, 5.637, 6.458, 6.326, 6.372, 5.822, 5.757, 6.335, 5.942, 6.454, 5.857, 6.151, 6.174, 5.019, 5.403, 5.468, 4.903, 6.13, 5.628, 4.926, 5.186, 5.597, 6.122, 5.404, 5.012, 5.709, 6.129, 6.152, 5.272, 6.943, 6.066, 6.51, 6.25, 7.489, 7.802, 8.375, 5.854, 6.101, 7.929, 5.877, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           6.319, 6.402, 5.875, 5.88, 5.572, 6.416, 5.859, 6.546, 6.02, 6.315, 6.86, 6.98, 7.765, 6.144, 7.155, 6.563, 5.604, 6.153, 7.831, 6.782, 6.556, 7.185, 6.951, 6.739, 7.178, 6.8, 6.604, 7.875, 7.287, 7.107, 7.274, 6.975, 7.135, 6.162, 7.61, 7.853, 8.034, 5.891, 6.326, 5.783, 6.064, 5.344, 5.96, 5.404, 5.807, 6.375, 5.412, 6.182, 5.888, 6.642, 5.951, 6.373, 6.951, 6.164, 6.879, 6.618, 8.266, 8.725, 8.04, 7.163, 7.686, 6.552, 5.981, 7.412, 8.337, 8.247, 6.726, 6.086, 6.631, 7.358, 6.481, 6.606, 6.897, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           6.095, 6.358, 6.393, 5.593, 5.605, 6.108, 6.226, 6.433, 6.718, 6.487, 6.438, 6.957, 8.259, 6.108, 5.876, 7.454, 8.704, 7.333, 6.842, 7.203, 7.52, 8.398, 7.327, 7.206, 5.56, 7.014, 8.297, 7.47, 5.92, 5.856, 6.24, 6.538, 7.691, 6.758, 6.854, 7.267, 6.826, 6.482, 6.812, 7.82, 6.968, 7.645, 7.923, 7.088, 6.453, 6.23, 6.209, 6.315, 6.565, 6.861, 7.148, 6.63, 6.127, 6.009, 6.678, 6.549, 5.79, 6.345, 7.041, 6.871, 6.59, 6.495, 6.982, 7.236, 6.616, 7.42, 6.849, 6.635, 5.972, 4.973, 6.122, 6.023, 6.266, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           6.567, 5.705, 5.914, 5.782, 6.382, 6.113, 6.426, 6.376, 6.041, 5.708, 6.415, 6.431, 6.312, 6.083, 5.868, 6.333, 6.144, 5.706, 6.031, 6.316, 6.31, 6.037, 5.869, 5.895, 6.059, 5.985, 5.968, 7.241, 6.54, 6.696, 6.874, 6.014, 5.898, 6.516, 6.635, 6.939, 6.49, 6.579, 5.884, 6.728, 5.663, 5.936, 6.212, 6.395, 6.127, 6.112, 6.398, 6.251, 5.362, 5.803, 8.78, 3.561, 4.963, 3.863, 4.97, 6.683, 7.016, 6.216, 5.875, 4.906, 4.138, 7.313, 6.649, 6.794, 6.38, 6.223, 6.968, 6.545, 5.536, 5.52, 4.368, 5.277, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           4.652, 5, 4.88, 5.39, 5.713, 6.051, 5.036, 6.193, 5.887, 6.471, 6.405, 5.747, 5.453, 5.852, 5.987, 6.343, 6.404, 5.349, 5.531, 5.683, 4.138, 5.608, 5.617, 6.852, 5.757, 6.657, 4.628, 5.155, 4.519, 6.434, 6.782, 5.304, 5.957, 6.824, 6.411, 6.006, 5.648, 6.103, 5.565, 5.896, 5.837, 6.202, 6.193, 6.38, 6.348, 6.833, 6.425, 6.436, 6.208, 6.629, 6.461, 6.152, 5.935, 5.627, 5.818, 6.406, 6.219, 6.485, 5.854, 6.459, 6.341, 6.251, 6.185, 6.417, 6.749, 6.655, 6.297, 7.393, 6.728, 6.525, 5.976, 5.936, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           6.301, 6.081, 6.701, 6.376, 6.317, 6.513, 6.209, 5.759, 5.952, 6.003, 5.926, 5.713, 6.167, 6.229, 6.437, 6.98, 5.427, 6.162, 6.484, 5.304, 6.185, 6.229, 6.242, 6.75, 7.061, 5.762, 5.871, 6.312, 6.114, 5.905, 5.454, 5.414, 5.093, 5.983, 5.983, 5.707, 5.926, 5.67, 5.39, 5.794, 6.019, 5.569, 6.027, 6.593, 6.12, 6.976, 6.794, 6.03), age = c(65.2, 78.9, 61.1, 45.8, 54.2, 58.7, 66.6, 96.1, 100, 85.9, 94.3, 82.9, 39, 61.8, 84.5, 56.5, 29.3, 81.7, 36.6, 69.5, 98.1, 89.2, 91.7, 100, 94.1, 85.7, 90.3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              88.8, 94.4, 87.3, 94.1, 100, 82, 95, 96.9, 68.2, 61.4, 41.5, 30.2, 21.8, 15.8, 2.9, 6.6, 6.5, 40, 33.8, 33.3, 85.5, 95.3, 62, 45.7, 63, 21.1, 21.4, 47.6, 21.9, 35.7, 40.5, 29.2, 47.2, 66.2, 93.4, 67.8, 43.4, 59.5, 17.8, 31.1, 21.4, 36.8, 33, 6.6, 17.5, 7.8, 6.2, 6, 45, 74.5, 45.8, 53.7, 36.6, 33.5, 70.4, 32.2, 46.7, 48, 56.1, 45.1, 56.8, 86.3, 63.1, 66.1, 73.9, 53.6, 28.9, 77.3, 57.8, 69.6, 76, 36.9, 62.5, 79.9, 71.3, 85.4, 87.4, 90, 96.7, 91.9, 85.2, 97.1, 91.2, 54.4, 81.6, 92.9, 95.4, 84.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              88.2, 72.5, 82.6, 73.1, 65.2, 69.7, 84.1, 92.9, 97, 95.8, 88.4, 95.6, 96, 98.8, 94.7, 98.9, 97.7, 97.9, 95.4, 98.4, 98.2, 93.5, 98.4, 98.2, 97.9, 93.6, 100, 100, 100, 97.8, 100, 100, 95.7, 93.8, 94.9, 97.3, 100, 88, 98.5, 96, 82.6, 94, 97.4, 100, 100, 92.6, 90.8, 98.2, 93.9, 91.8, 93, 96.2, 79.2, 96.1, 95.2, 94.6, 97.3, 88.5, 84.1, 68.7, 33.1, 47.2, 73.4, 74.4, 58.4, 83.3, 62.2, 92.2, 95.6, 89.8, 68.8, 53.6, 41.1, 29.1, 38.9, 21.5, 30.8, 26.3, 9.9, 18.8, 32, 34.1, 36.6, 38.3, 15.3, 13.9, 38.4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              15.7, 33.2, 31.9, 22.3, 52.5, 72.7, 59.1, 100, 92.1, 88.6, 53.8, 32.3, 9.8, 42.4, 56, 85.1, 93.8, 92.4, 88.5, 91.3, 77.7, 80.8, 78.3, 83, 86.5, 79.9, 17, 21.4, 68.1, 76.9, 73.3, 70.4, 66.5, 61.5, 76.5, 71.6, 18.5, 42.2, 54.3, 65.1, 52.9, 7.8, 76.5, 70.2, 34.9, 79.2, 49.1, 17.5, 13, 8.9, 6.8, 8.4, 32, 19.1, 34.2, 86.9, 100, 100, 81.8, 89.4, 91.5, 94.5, 91.6, 62.8, 84.6, 67, 52.6, 61.5, 42.1, 16.3, 58.7, 51.8, 32.9, 42.8, 49, 27.6, 32.1, 32.2, 64.5, 37.2, 49.7, 24.8, 20.8, 31.9, 31.5, 31.3, 45.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              22.9, 27.9, 27.7, 23.4, 18.4, 42.3, 31.1, 51, 58, 20.1, 10, 47.4, 40.4, 18.4, 17.7, 41.1, 58.1, 71.9, 70.3, 82.5, 76.7, 37.8, 52.8, 90.4, 82.8, 87.3, 77.7, 83.2, 71.7, 67.2, 58.8, 52.3, 54.3, 49.9, 74.3, 40.1, 14.7, 28.9, 43.7, 25.8, 17.2, 32.2, 28.4, 23.3, 38.1, 38.5, 34.5, 46.3, 59.6, 37.3, 45.4, 58.5, 49.3, 59.7, 56.4, 28.1, 48.5, 52.3, 27.7, 29.7, 34.5, 44.4, 35.9, 18.5, 36.1, 21.9, 19.5, 97.4, 91, 83.4, 81.3, 88, 91.1, 96.2, 89, 82.9, 87.9, 91.4, 100, 100, 96.8, 97.5, 100, 89.6, 100, 100, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              97.9, 93.3, 98.8, 96.2, 100, 91.9, 99.1, 100, 100, 91.2, 98.1, 100, 89.5, 100, 98.9, 97, 82.5, 97, 92.6, 94.7, 98.8, 96, 98.9, 100, 77.8, 100, 100, 100, 96, 85.4, 100, 100, 100, 97.9, 100, 100, 100, 100, 100, 100, 100, 90.8, 89.1, 100, 76.5, 100, 95.3, 87.6, 85.1, 70.6, 95.4, 59.7, 78.7, 78.1, 95.6, 86.1, 94.3, 74.8, 87.9, 95, 94.6, 93.3, 100, 87.9, 93.9, 92.4, 97.2, 100, 100, 96.6, 94.8, 96.4, 96.6, 98.7, 98.3, 92.6, 98.2, 91.8, 99.3, 94.1, 86.5, 87.9, 80.3, 83.7, 84.4, 90, 88.4, 83, 89.9, 65.4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              48.2, 84.7, 94.5, 71, 56.7, 84, 90.7, 75, 67.6, 95.4, 97.4, 93.6, 97.3, 96.7, 88, 64.7, 74.9, 77, 40.3, 41.9, 51.9, 79.8, 53.2, 92.7, 98.3, 98, 98.8, 83.5, 54, 42.6, 28.8, 72.9, 70.6, 65.3, 73.5, 79.7, 69.1, 76.7, 91, 89.3, 80.8), dis = c(4.09, 4.9671, 4.9671, 6.0622, 6.0622, 6.0622, 5.5605, 5.9505, 6.0821, 6.5921, 6.3467, 6.2267, 5.4509, 4.7075, 4.4619, 4.4986, 4.4986, 4.2579, 3.7965, 3.7965, 3.7979, 4.0123, 3.9769, 4.0952, 4.3996, 4.4546, 4.682, 4.4534, 4.4547, 4.239, 4.233, 4.175, 3.99, 3.7872, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             3.7598, 3.3603, 3.3779, 3.9342, 3.8473, 5.4011, 5.4011, 5.7209, 5.7209, 5.7209, 5.7209, 5.1004, 5.1004, 5.6894, 5.87, 6.0877, 6.8147, 6.8147, 6.8147, 6.8147, 7.3197, 8.6966, 9.1876, 8.3248, 7.8148, 6.932, 7.2254, 6.8185, 7.2255, 7.9809, 9.2229, 6.6115, 6.6115, 6.498, 6.498, 6.498, 5.2873, 5.2873, 5.2873, 5.2873, 4.2515, 4.5026, 4.0522, 4.0905, 5.0141, 4.5026, 5.4007, 5.4007, 5.4007, 5.4007, 4.7794, 4.4377, 4.4272, 3.7476, 3.4217, 3.4145, 3.0923, 3.0921, 3.6659, 3.6659, 3.615, 3.4952, 3.4952, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             3.4952, 3.4952, 3.4952, 2.7778, 2.8561, 2.7147, 2.7147, 2.421, 2.1069, 2.211, 2.1224, 2.4329, 2.5451, 2.7778, 2.6775, 2.3534, 2.548, 2.2565, 2.4631, 2.7301, 2.7474, 2.4775, 2.7592, 2.2577, 2.1974, 2.0869, 1.9444, 2.0063, 1.9929, 1.7572, 1.7883, 1.8125, 1.9799, 2.1185, 2.271, 2.3274, 2.4699, 2.346, 2.1107, 1.9669, 1.8498, 1.6686, 1.6687, 1.6119, 1.4394, 1.3216, 1.4118, 1.3459, 1.4191, 1.5166, 1.4608, 1.5296, 1.5257, 1.618, 1.5916, 1.6102, 1.6232, 1.7494, 1.7455, 1.7364, 1.8773, 1.7573, 1.7659, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1.7984, 1.9709, 2.0407, 2.162, 2.422, 2.2834, 2.0459, 2.4259, 2.1, 2.2625, 2.4259, 2.3887, 2.5961, 2.6463, 2.7019, 3.1323, 3.5549, 3.3175, 2.9153, 2.829, 2.741, 2.5979, 2.7006, 2.847, 2.9879, 3.2797, 3.1992, 3.7886, 4.5667, 4.5667, 6.4798, 6.4798, 6.4798, 6.2196, 6.2196, 5.6484, 7.309, 7.309, 7.309, 7.6534, 7.6534, 6.27, 6.27, 5.118, 5.118, 3.9454, 4.3549, 4.3549, 4.2392, 3.875, 3.8771, 3.665, 3.6526, 3.9454, 3.5875, 3.9454, 3.1121, 3.4211, 2.8893, 3.3633, 2.8617, 3.048, 3.2721, 3.2721, 2.8944, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             2.8944, 3.2157, 3.2157, 3.3751, 3.3751, 3.6715, 3.6715, 3.8384, 3.6519, 3.6519, 3.6519, 4.148, 4.148, 6.1899, 6.1899, 6.3361, 6.3361, 7.0355, 7.0355, 7.9549, 7.9549, 8.0555, 8.0555, 7.8265, 7.8265, 7.3967, 7.3967, 8.9067, 8.9067, 9.2203, 9.2203, 6.3361, 1.801, 1.8946, 2.0107, 2.1121, 2.1398, 2.2885, 2.0788, 1.9301, 1.9865, 2.1329, 2.4216, 2.872, 3.9175, 4.429, 4.429, 3.9175, 4.3665, 4.0776, 4.2673, 4.7872, 4.8628, 4.1403, 4.1007, 4.6947, 5.2447, 5.2119, 5.885, 7.3073, 7.3073, 9.0892, 7.3172, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             7.3172, 7.3172, 5.1167, 5.1167, 5.1167, 5.5027, 5.5027, 5.9604, 5.9604, 6.32, 7.8278, 7.8278, 7.8278, 5.4917, 5.4917, 5.4917, 4.022, 3.37, 3.0992, 3.1827, 3.3175, 3.1025, 2.5194, 2.6403, 2.834, 3.2628, 3.6023, 3.945, 3.9986, 4.0317, 3.5325, 4.0019, 4.5404, 4.5404, 4.7211, 4.7211, 4.7211, 5.4159, 5.4159, 5.4159, 5.2146, 5.2146, 5.8736, 6.6407, 6.6407, 6.4584, 6.4584, 5.9853, 5.2311, 5.615, 4.8122, 4.8122, 4.8122, 7.0379, 6.2669, 5.7321, 6.4654, 8.0136, 8.0136, 8.5353, 8.344, 8.7921, 8.7921, 10.7103, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             10.7103, 12.1265, 10.5857, 10.5857, 2.1222, 2.5052, 2.7227, 2.5091, 2.5182, 2.2955, 2.1036, 1.9047, 1.9047, 1.6132, 1.7523, 1.5106, 1.3325, 1.3567, 1.2024, 1.1691, 1.1296, 1.1742, 1.137, 1.3163, 1.3449, 1.358, 1.3861, 1.3861, 1.4165, 1.5192, 1.5804, 1.5331, 1.4395, 1.4261, 1.4672, 1.5184, 1.5895, 1.7281, 1.9265, 2.1678, 1.77, 1.7912, 1.7821, 1.7257, 1.6768, 1.6334, 1.4896, 1.5004, 1.5888, 1.5741, 1.639, 1.7028, 1.6074, 1.4254, 1.1781, 1.2852, 1.4547, 1.4655, 1.413, 1.5275, 1.5539, 1.5894, 1.6582, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1.8347, 1.8195, 1.6475, 1.8026, 1.794, 1.8589, 1.8746, 1.9512, 2.0218, 2.0635, 1.9096, 1.9976, 1.8629, 1.9356, 1.9682, 2.0527, 2.0882, 2.2004, 2.3158, 2.2222, 2.1247, 2.0026, 1.9142, 1.8206, 1.8172, 1.8662, 2.0651, 2.0048, 1.9784, 1.8956, 1.9879, 2.072, 2.198, 2.2616, 2.185, 2.3236, 2.3552, 2.3682, 2.4527, 2.4961, 2.4358, 2.5806, 2.7792, 2.7831, 2.7175, 2.5975, 2.5671, 2.7344, 2.8016, 2.9634, 3.0665, 2.8715, 2.5403, 2.9084, 2.8237, 3.0334, 3.0993, 2.8965, 2.5329, 2.4298, 2.206, 2.3053, 2.1007, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             2.1705, 1.9512, 3.4242, 3.3317, 3.4106, 4.0983, 3.724, 3.9917, 3.5459, 3.1523, 1.8209, 1.7554, 1.8226, 1.8681, 2.1099, 2.3817, 2.3817, 2.7986, 2.7986, 2.8927, 2.4091, 2.3999, 2.4982, 2.4786, 2.2875, 2.1675, 2.3889, 2.505), rad = c(1, 2, 2, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 3, 5, 2, 5, 8, 8, 8, 8, 8, 8, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2, 2, 2, 4, 4, 4, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 1, 1, 4, 2, 2, 2, 3, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    1, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 1, 1, 1, 1, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 5, 5, 3, 3, 4, 4, 1, 1, 4, 4, 5, 4, 4, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1), tax = c(296, 242, 242, 222, 222, 222, 311, 311, 311, 311, 311, 311, 311, 307, 307, 307, 307, 307, 307, 307, 307, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 279, 279, 279, 279, 252, 252, 233, 233, 233, 233, 233, 233, 233, 233, 233, 243, 243, 243, 243, 469, 226, 313, 256, 284, 284, 284, 284, 284, 284, 216, 337, 337, 345, 345, 345, 305, 305, 305, 305, 398, 398, 398, 398, 398, 398, 281, 281, 281, 281, 247, 247, 247, 247, 270, 270, 270, 270, 270, 270, 270, 276, 276, 276, 276, 276, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 432, 432, 432, 432, 432, 432, 432, 432, 432, 188, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               188, 188, 188, 188, 188, 188, 437, 437, 437, 437, 437, 437, 437, 437, 437, 437, 437, 437, 437, 437, 437, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 403, 296, 296, 296, 296, 296, 296, 296, 193, 193, 193, 193, 193, 193, 193, 193, 398, 398, 398, 398, 398, 398, 265, 265, 255, 329, 329, 329, 402, 402, 348, 348, 224, 224, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 276, 276, 276, 276, 307, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 307, 300, 300, 300, 300, 300, 300, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 315, 315, 244, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 264, 223, 223, 223, 223, 223, 254, 254, 254, 254, 254, 216, 216, 216, 216, 198, 285, 300, 241, 293, 293, 293, 245, 245, 245, 289, 289, 289, 289, 289, 358, 358, 358, 329, 329, 329, 222, 222, 222, 222, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 287, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               287, 287, 287, 287, 287, 287, 287, 430, 430, 430, 304, 304, 224, 224, 224, 224, 224, 224, 224, 224, 284, 422, 370, 370, 352, 352, 351, 280, 335, 335, 411, 411, 187, 334, 334, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 711, 711, 711, 711, 711, 391, 391, 391, 391, 391, 391, 391, 391, 273, 273, 273, 273, 273), ptratio = c(15.3, 17.8, 17.8, 18.7, 18.7, 18.7, 15.2, 15.2, 15.2, 15.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     15.2, 15.2, 15.2, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 19.2, 19.2, 19.2, 19.2, 18.3, 18.3, 17.9, 17.9, 17.9, 17.9, 17.9, 17.9, 17.9, 17.9, 17.9, 16.8, 16.8, 16.8, 16.8, 21.1, 17.9, 17.3, 15.1, 19.7, 19.7, 19.7, 19.7, 19.7, 19.7, 18.6, 16.1, 16.1, 18.9, 18.9, 18.9, 19.2, 19.2, 19.2, 19.2, 18.7, 18.7, 18.7, 18.7, 18.7, 18.7, 19, 19, 19, 19, 18.5, 18.5, 18.5, 18.5, 17.8, 17.8, 17.8, 17.8, 18.2, 18.2, 18.2, 18, 18, 18, 18, 18, 20.9, 20.9, 20.9, 20.9, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     20.9, 20.9, 20.9, 20.9, 20.9, 20.9, 20.9, 17.8, 17.8, 17.8, 17.8, 17.8, 17.8, 17.8, 17.8, 17.8, 19.1, 19.1, 19.1, 19.1, 19.1, 19.1, 19.1, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 21.2, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 16.6, 16.6, 16.6, 16.6, 16.6, 16.6, 16.6, 17.8, 17.8, 17.8, 17.8, 17.8, 17.8, 17.8, 17.8, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     15.2, 15.2, 15.2, 15.2, 15.2, 15.2, 15.6, 15.6, 14.4, 12.6, 12.6, 12.6, 17, 17, 14.7, 14.7, 14.7, 14.7, 18.6, 18.6, 18.6, 18.6, 18.6, 18.6, 18.6, 18.6, 18.6, 18.6, 18.6, 16.4, 16.4, 16.4, 16.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 17.4, 16.6, 16.6, 16.6, 16.6, 16.6, 16.6, 19.1, 19.1, 19.1, 19.1, 19.1, 19.1, 19.1, 19.1, 19.1, 19.1, 16.4, 16.4, 15.9, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 18.6, 18.6, 18.6, 18.6, 18.6, 17.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     17.6, 17.6, 17.6, 17.6, 14.9, 14.9, 14.9, 14.9, 13.6, 15.3, 15.3, 18.2, 16.6, 16.6, 16.6, 19.2, 19.2, 19.2, 16, 16, 16, 16, 16, 14.8, 14.8, 14.8, 16.1, 16.1, 16.1, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 18.4, 19.6, 19.6, 19.6, 19.6, 19.6, 19.6, 19.6, 19.6, 16.9, 16.9, 16.9, 16.9, 16.9, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 15.5, 15.9, 17.6, 17.6, 18.8, 18.8, 17.9, 17, 19.7, 19.7, 18.3, 18.3, 17, 22, 22, 20.2, 20.2, 20.2, 20.2, 20.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.2, 20.1, 20.1, 20.1, 20.1, 20.1, 19.2, 19.2, 19.2, 19.2, 19.2, 19.2, 19.2, 19.2, 21, 21, 21, 21, 21), black = c(396.9, 396.9, 392.83, 394.63, 396.9, 394.12, 395.6, 396.9, 386.63, 386.71, 392.52, 396.9, 390.5, 396.9, 380.02, 395.62, 386.85, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          386.75, 288.99, 390.95, 376.57, 392.53, 396.9, 394.54, 394.33, 303.42, 376.88, 306.38, 387.94, 380.23, 360.17, 376.73, 232.6, 358.77, 248.31, 396.9, 377.56, 396.9, 393.43, 395.63, 395.62, 385.41, 383.37, 394.46, 389.39, 396.9, 396.9, 392.74, 396.9, 396.9, 395.56, 393.97, 396.9, 396.9, 396.9, 395.93, 396.9, 392.9, 390.68, 396.9, 395.11, 378.08, 396.9, 395.58, 393.24, 396.9, 396.9, 396.21, 396.9, 396.9, 383.73, 376.94, 390.91, 377.17, 394.92, 383.23, 373.66, 386.96, 386.4, 396.06, 396.9, 395.63, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          396.9, 390.64, 396.9, 392.3, 395.99, 395.15, 396.9, 396.06, 392.18, 393.55, 395.01, 396.33, 396.9, 357.98, 391.83, 396.9, 393.53, 396.9, 394.76, 395.58, 70.8, 394.47, 392.69, 394.05, 395.67, 387.69, 395.24, 391.23, 393.49, 395.59, 394.95, 396.9, 388.74, 344.91, 393.3, 394.51, 338.63, 391.5, 389.15, 377.67, 378.09, 370.31, 379.38, 385.02, 359.29, 392.11, 396.9, 396.9, 395.04, 396.9, 385.76, 388.69, 262.76, 394.67, 378.25, 394.08, 392.04, 396.9, 388.08, 396.9, 396.9, 396.9, 396.9, 172.91, 169.27, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          391.71, 356.99, 351.85, 372.8, 341.6, 343.28, 261.95, 321.02, 88.01, 88.63, 363.43, 353.89, 364.31, 338.92, 374.43, 389.61, 388.45, 395.11, 240.16, 369.3, 227.61, 297.09, 330.04, 292.29, 348.13, 396.9, 395.5, 393.23, 390.96, 393.23, 395.6, 391.27, 396.9, 395.56, 396.9, 394.12, 396.9, 391, 387.11, 392.63, 393.87, 382.84, 396.9, 377.68, 389.71, 390.49, 393.37, 376.7, 394.23, 396.9, 354.31, 392.2, 396.9, 384.3, 393.77, 395.38, 392.78, 390.55, 396.9, 394.87, 389.43, 381.32, 396.9, 393.25, 395.24, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          390.94, 385.81, 348.93, 393.63, 392.8, 392.78, 396.9, 393.74, 391.7, 395.24, 390.39, 396.9, 385.05, 382, 387.38, 372.08, 377.51, 380.34, 378.35, 376.14, 385.91, 378.95, 360.2, 376.75, 388.45, 390.07, 379.41, 383.78, 391.25, 394.62, 372.75, 374.71, 372.49, 389.13, 390.18, 376.14, 374.71, 393.74, 396.28, 377.07, 386.09, 396.9, 392.89, 395.18, 386.34, 389.7, 383.29, 391.93, 392.8, 388.37, 386.86, 393.42, 387.89, 392.4, 384.07, 384.54, 390.3, 391.34, 388.65, 396.9, 394.96, 390.77, 396.9, 396.9, 389.25, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          393.45, 396.9, 396.9, 387.31, 392.23, 377.07, 395.52, 394.72, 394.72, 341.6, 396.9, 396.9, 371.72, 396.9, 396.9, 396.9, 396.9, 396.9, 396.9, 392.85, 396.9, 368.24, 371.58, 390.86, 395.75, 383.61, 390.43, 393.68, 393.36, 396.9, 396.9, 396.9, 396.24, 350.45, 396.9, 396.3, 393.39, 395.69, 396.42, 390.7, 396.9, 395.21, 396.23, 396.9, 396.9, 396.9, 391.13, 396.9, 393.68, 396.9, 396.9, 382.44, 375.21, 368.57, 394.02, 362.25, 389.71, 389.4, 396.9, 396.9, 394.81, 396.14, 396.9, 396.9, 394.74, 389.96, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          396.9, 387.97, 385.64, 364.61, 392.43, 390.94, 389.85, 396.9, 370.78, 392.33, 384.46, 382.8, 376.04, 377.73, 391.34, 395.43, 390.74, 374.56, 350.65, 380.79, 353.04, 354.55, 354.7, 316.03, 131.42, 375.52, 375.33, 392.05, 366.15, 347.88, 396.9, 396.9, 396.9, 363.02, 396.9, 396.9, 393.74, 396.9, 396.9, 396.9, 396.9, 285.83, 396.9, 396.9, 396.9, 372.92, 396.9, 394.43, 378.38, 396.9, 396.9, 396.9, 391.98, 396.9, 393.1, 396.9, 338.16, 396.9, 396.9, 376.11, 396.9, 329.46, 384.97, 370.22, 332.09, 314.64, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          179.36, 2.6, 35.05, 28.79, 210.97, 88.27, 27.25, 21.57, 127.36, 16.45, 48.45, 318.75, 319.98, 291.55, 2.52, 3.65, 7.68, 24.65, 18.82, 96.73, 60.72, 83.45, 81.33, 97.95, 100.19, 100.63, 109.85, 27.49, 9.32, 68.95, 396.9, 391.45, 385.96, 395.69, 386.73, 240.52, 43.06, 318.01, 388.52, 396.9, 304.21, 0.32, 355.29, 385.09, 375.87, 6.68, 50.92, 10.48, 3.5, 272.21, 396.9, 255.23, 391.43, 396.9, 393.82, 396.9, 334.4, 22.01, 331.29, 368.74, 396.9, 396.9, 395.33, 393.37, 374.68, 352.58, 302.76, 396.21, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          349.48, 379.7, 383.32, 396.9, 393.07, 395.28, 392.92, 370.73, 388.62, 392.68, 388.22, 395.09, 344.05, 318.43, 390.11, 396.9, 396.9, 396.9, 393.29, 396.9, 396.9, 396.9, 395.77, 396.9, 391.99, 396.9, 396.9, 393.45, 396.9), lstat = c(4.98, 9.14, 4.03, 2.94, 5.33, 5.21, 12.43, 19.15, 29.93, 17.1, 20.45, 13.27, 15.71, 8.26, 10.26, 8.47, 6.58, 14.67, 11.69, 11.28, 21.02, 13.83, 18.72, 19.88, 16.3, 16.51, 14.81, 17.28, 12.8, 11.98, 22.6, 13.04, 27.71, 18.35, 20.34, 9.68, 11.41, 8.77, 10.13, 4.32, 1.98, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 4.84, 5.81, 7.44, 9.55, 10.21, 14.15, 18.8, 30.81, 16.2, 13.45, 9.43, 5.28, 8.43, 14.8, 4.81, 5.77, 3.95, 6.86, 9.22, 13.15, 14.44, 6.73, 9.5, 8.05, 4.67, 10.24, 8.1, 13.09, 8.79, 6.72, 9.88, 5.52, 7.54, 6.78, 8.94, 11.97, 10.27, 12.34, 9.1, 5.29, 7.22, 6.72, 7.51, 9.62, 6.53, 12.86, 8.44, 5.5, 5.7, 8.81, 8.2, 8.16, 6.21, 10.59, 6.65, 11.34, 4.21, 3.57, 6.19, 9.42, 7.67, 10.63, 13.44, 12.33, 16.47, 18.66, 14.09, 12.27, 15.55, 13, 10.16, 16.21, 17.09, 10.45, 15.76, 12.04, 10.3, 15.37, 13.61, 14.37, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 14.27, 17.93, 25.41, 17.58, 14.81, 27.26, 17.19, 15.39, 18.34, 12.6, 12.26, 11.12, 15.03, 17.31, 16.96, 16.9, 14.59, 21.32, 18.46, 24.16, 34.41, 26.82, 26.42, 29.29, 27.8, 16.65, 29.53, 28.32, 21.45, 14.1, 13.28, 12.12, 15.79, 15.12, 15.02, 16.14, 4.59, 6.43, 7.39, 5.5, 1.73, 1.92, 3.32, 11.64, 9.81, 3.7, 12.14, 11.1, 11.32, 14.43, 12.03, 14.69, 9.04, 9.64, 5.33, 10.11, 6.29, 6.92, 5.04, 7.56, 9.45, 4.82, 5.68, 13.98, 13.15, 4.45, 6.68, 4.56, 5.39, 5.1, 4.69, 2.87, 5.03, 4.38, 2.97, 4.08, 8.61, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 6.62, 4.56, 4.45, 7.43, 3.11, 3.81, 2.88, 10.87, 10.97, 18.06, 14.66, 23.09, 17.27, 23.98, 16.03, 9.38, 29.55, 9.47, 13.51, 9.69, 17.92, 10.5, 9.71, 21.46, 9.93, 7.6, 4.14, 4.63, 3.13, 6.36, 3.92, 3.76, 11.65, 5.25, 2.47, 3.95, 8.05, 10.88, 9.54, 4.73, 6.36, 7.37, 11.38, 12.4, 11.22, 5.19, 12.5, 18.46, 9.16, 10.15, 9.52, 6.56, 5.9, 3.59, 3.53, 3.54, 6.57, 9.25, 3.11, 5.12, 7.79, 6.9, 9.59, 7.26, 5.91, 11.25, 8.1, 10.45, 14.79, 7.44, 3.16, 13.65, 13, 6.59, 7.73, 6.58, 3.53, 2.98, 6.05, 4.16, 7.19, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 4.85, 3.76, 4.59, 3.01, 3.16, 7.85, 8.23, 12.93, 7.14, 7.6, 9.51, 3.33, 3.56, 4.7, 8.58, 10.4, 6.27, 7.39, 15.84, 4.97, 4.74, 6.07, 9.5, 8.67, 4.86, 6.93, 8.93, 6.47, 7.53, 4.54, 9.97, 12.64, 5.98, 11.72, 7.9, 9.28, 11.5, 18.33, 15.94, 10.36, 12.73, 7.2, 6.87, 7.7, 11.74, 6.12, 5.08, 6.15, 12.79, 9.97, 7.34, 9.09, 12.43, 7.83, 5.68, 6.75, 8.01, 9.8, 10.56, 8.51, 9.74, 9.29, 5.49, 8.65, 7.18, 4.61, 10.53, 12.67, 6.36, 5.99, 5.89, 5.98, 5.49, 7.79, 4.5, 8.05, 5.57, 17.6, 13.27, 11.48, 12.67, 7.79, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 14.19, 10.19, 14.64, 5.29, 7.12, 14, 13.33, 3.26, 3.73, 2.96, 9.53, 8.88, 34.77, 37.97, 13.44, 23.24, 21.24, 23.69, 21.78, 17.21, 21.08, 23.6, 24.56, 30.63, 30.81, 28.28, 31.99, 30.62, 20.85, 17.11, 18.76, 25.68, 15.17, 16.35, 17.12, 19.37, 19.92, 30.59, 29.97, 26.77, 20.32, 20.31, 19.77, 27.38, 22.98, 23.34, 12.13, 26.4, 19.78, 10.11, 21.22, 34.37, 20.08, 36.98, 29.05, 25.79, 26.64, 20.62, 22.74, 15.02, 15.7, 14.1, 23.29, 17.16, 24.39, 15.69, 14.52, 21.52, 24.08, 17.64, 19.69, 12.03, 16.22, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 15.17, 23.27, 18.05, 26.45, 34.02, 22.88, 22.11, 19.52, 16.59, 18.85, 23.79, 23.98, 17.79, 16.44, 18.13, 19.31, 17.44, 17.73, 17.27, 16.74, 18.71, 18.13, 19.01, 16.94, 16.23, 14.7, 16.42, 14.65, 13.99, 10.29, 13.22, 14.13, 17.15, 21.32, 18.13, 14.76, 16.29, 12.87, 14.36, 11.66, 18.14, 24.1, 18.68, 24.91, 18.03, 13.11, 10.74, 7.74, 7.01, 10.42, 13.34, 10.58, 14.98, 11.45, 18.06, 23.97, 29.68, 18.07, 13.35, 12.01, 13.59, 17.6, 21.14, 14.1, 12.92, 15.1, 14.33, 9.67, 9.08, 5.64, 6.48, 7.88), medv = c(24, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       21.6, 34.7, 33.4, 36.2, 28.7, 22.9, 27.1, 16.5, 18.9, 15, 18.9, 21.7, 20.4, 18.2, 19.9, 23.1, 17.5, 20.2, 18.2, 13.6, 19.6, 15.2, 14.5, 15.6, 13.9, 16.6, 14.8, 18.4, 21, 12.7, 14.5, 13.2, 13.1, 13.5, 18.9, 20, 21, 24.7, 30.8, 34.9, 26.6, 25.3, 24.7, 21.2, 19.3, 20, 16.6, 14.4, 19.4, 19.7, 20.5, 25, 23.4, 18.9, 35.4, 24.7, 31.6, 23.3, 19.6, 18.7, 16, 22.2, 25, 33, 23.5, 19.4, 22, 17.4, 20.9, 24.2, 21.7, 22.8, 23.4, 24.1, 21.4, 20, 20.8, 21.2, 20.3, 28, 23.9, 24.8, 22.9, 23.9, 26.6, 22.5, 22.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       23.6, 28.7, 22.6, 22, 22.9, 25, 20.6, 28.4, 21.4, 38.7, 43.8, 33.2, 27.5, 26.5, 18.6, 19.3, 20.1, 19.5, 19.5, 20.4, 19.8, 19.4, 21.7, 22.8, 18.8, 18.7, 18.5, 18.3, 21.2, 19.2, 20.4, 19.3, 22, 20.3, 20.5, 17.3, 18.8, 21.4, 15.7, 16.2, 18, 14.3, 19.2, 19.6, 23, 18.4, 15.6, 18.1, 17.4, 17.1, 13.3, 17.8, 14, 14.4, 13.4, 15.6, 11.8, 13.8, 15.6, 14.6, 17.8, 15.4, 21.5, 19.6, 15.3, 19.4, 17, 15.6, 13.1, 41.3, 24.3, 23.3, 27, 50, 50, 50, 22.7, 25, 50, 23.8, 23.8, 22.3, 17.4, 19.1, 23.1, 23.6, 22.6, 29.4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       23.2, 24.6, 29.9, 37.2, 39.8, 36.2, 37.9, 32.5, 26.4, 29.6, 50, 32, 29.8, 34.9, 37, 30.5, 36.4, 31.1, 29.1, 50, 33.3, 30.3, 34.6, 34.9, 32.9, 24.1, 42.3, 48.5, 50, 22.6, 24.4, 22.5, 24.4, 20, 21.7, 19.3, 22.4, 28.1, 23.7, 25, 23.3, 28.7, 21.5, 23, 26.7, 21.7, 27.5, 30.1, 44.8, 50, 37.6, 31.6, 46.7, 31.5, 24.3, 31.7, 41.7, 48.3, 29, 24, 25.1, 31.5, 23.7, 23.3, 22, 20.1, 22.2, 23.7, 17.6, 18.5, 24.3, 20.5, 24.5, 26.2, 24.4, 24.8, 29.6, 42.8, 21.9, 20.9, 44, 50, 36, 30.1, 33.8, 43.1, 48.8, 31, 36.5, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       22.8, 30.7, 50, 43.5, 20.7, 21.1, 25.2, 24.4, 35.2, 32.4, 32, 33.2, 33.1, 29.1, 35.1, 45.4, 35.4, 46, 50, 32.2, 22, 20.1, 23.2, 22.3, 24.8, 28.5, 37.3, 27.9, 23.9, 21.7, 28.6, 27.1, 20.3, 22.5, 29, 24.8, 22, 26.4, 33.1, 36.1, 28.4, 33.4, 28.2, 22.8, 20.3, 16.1, 22.1, 19.4, 21.6, 23.8, 16.2, 17.8, 19.8, 23.1, 21, 23.8, 23.1, 20.4, 18.5, 25, 24.6, 23, 22.2, 19.3, 22.6, 19.8, 17.1, 19.4, 22.2, 20.7, 21.1, 19.5, 18.5, 20.6, 19, 18.7, 32.7, 16.5, 23.9, 31.2, 17.5, 17.2, 23.1, 24.5, 26.6, 22.9, 24.1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       18.6, 30.1, 18.2, 20.6, 17.8, 21.7, 22.7, 22.6, 25, 19.9, 20.8, 16.8, 21.9, 27.5, 21.9, 23.1, 50, 50, 50, 50, 50, 13.8, 13.8, 15, 13.9, 13.3, 13.1, 10.2, 10.4, 10.9, 11.3, 12.3, 8.8, 7.2, 10.5, 7.4, 10.2, 11.5, 15.1, 23.2, 9.7, 13.8, 12.7, 13.1, 12.5, 8.5, 5, 6.3, 5.6, 7.2, 12.1, 8.3, 8.5, 5, 11.9, 27.9, 17.2, 27.5, 15, 17.2, 17.9, 16.3, 7, 7.2, 7.5, 10.4, 8.8, 8.4, 16.7, 14.2, 20.8, 13.4, 11.7, 8.3, 10.2, 10.9, 11, 9.5, 14.5, 14.1, 16.1, 14.3, 11.7, 13.4, 9.6, 8.7, 8.4, 12.8, 10.5, 17.1, 18.4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       15.4, 10.8, 11.8, 14.9, 12.6, 14.1, 13, 13.4, 15.2, 16.1, 17.8, 14.9, 14.1, 12.7, 13.5, 14.9, 20, 16.4, 17.7, 19.5, 20.2, 21.4, 19.9, 19, 19.1, 19.1, 20.1, 19.9, 19.6, 23.2, 29.8, 13.8, 13.3, 16.7, 12, 14.6, 21.4, 23, 23.7, 25, 21.8, 20.6, 21.2, 19.1, 20.6, 15.2, 7, 8.1, 13.6, 20.1, 21.8, 24.5, 23.1, 19.7, 18.3, 21.2, 17.5, 16.8, 22.4, 20.6, 23.9, 22, 11.9)))
package:MASS
TRUE
FALSE
boxcox
list(`package:MASS` = function (object, ...) 
  UseMethod("boxcox"), function (object, ...) 
    UseMethod("boxcox"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
cabbages
list(`package:MASS` = list(Cult = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Date = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3), HeadWt = c(2.5, 2.2, 3.1, 4.3, 2.5, 4.3, 3.8, 4.3, 1.7, 3.1, 3, 2.8, 2.8, 2.7, 2.6, 2.8, 2.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                  2.6, 2.6, 3.5, 2.2, 1.8, 1.6, 2.1, 3.3, 3.8, 3.2, 3.6, 4.2, 1.6, 2, 2.4, 1.9, 2.8, 1.7, 3.2, 2, 2.2, 2.2, 2.2, 4, 2.8, 3.1, 4.2, 3.7, 3, 2.2, 2.3, 3.8, 2, 1.5, 1.4, 1.7, 1.3, 1.7, 1.6, 1.4, 1, 1.5, 1.6), VitC = c(51, 55, 45, 42, 53, 50, 50, 52, 56, 49, 65, 52, 41, 51, 41, 45, 51, 45, 61, 42, 54, 59, 66, 54, 45, 49, 49, 55, 49, 68, 58, 55, 67, 61, 67, 68, 58, 63, 56, 72, 52, 70, 57, 58, 47, 56, 72, 63, 54, 60, 78, 75, 70, 84, 71, 72, 62, 68, 66, 72)))
package:MASS
TRUE
FALSE
caith
list(`package:MASS` = list(fair = c(326, 688, 343, 98), red = c(38, 116, 84, 48), medium = c(241, 584, 909, 403), dark = c(110, 188, 412, 681), black = c(3, 4, 26, 85)))
package:MASS
TRUE
FALSE
Cars93
list(`package:MASS` = list(Manufacturer = c(1, 1, 2, 2, 3, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 14, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 25, 25, 25, 25, 25, 26, 27, 28, 28, 28, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32), Model = c(49, 56, 9, 1, 6, 24, 54, 74, 73, 35, 79, 22, 30, 17, 58, 59, 15, 20, 31, 27, 52, 48, 26, 80, 83, 21, 37, 
                                                                                                                                                                                                                                                                                                                                                                                                               84, 86, 93, 44, 41, 90, 64, 68, 13, 89, 33, 62, 85, 66, 25, 11, 43, 40, 77, 82, 70, 38, 75, 28, 92, 5, 69, 7, 60, 72, 2, 4, 19, 32, 63, 36, 78, 14, 71, 61, 12, 34, 81, 39, 51, 53, 87, 45, 47, 16, 10, 76, 50, 57, 55, 88, 91, 23, 18, 67, 46, 42, 65, 29, 3, 8), Type = c(4, 3, 1, 3, 3, 3, 2, 2, 3, 2, 3, 1, 1, 5, 3, 6, 6, 2, 5, 2, 1, 2, 4, 4, 1, 6, 3, 5, 4, 2, 4, 4, 1, 5, 5, 6, 3, 2, 4, 5, 5, 4, 1, 4, 4, 5, 3, 3, 3, 3, 3, 2, 4, 4, 1, 6, 5, 1, 3, 5, 3, 4, 3, 4, 1, 6, 3, 1, 3, 6, 2, 5, 4, 1, 5, 3, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           4, 4, 4, 1, 4, 4, 5, 3, 6, 4, 6, 1, 5, 1, 3), Min.Price = c(12.9, 29.2, 25.9, 30.8, 23.7, 14.2, 19.9, 22.6, 26.3, 33, 37.5, 8.5, 11.4, 13.4, 13.4, 14.7, 14.7, 18, 34.6, 18.4, 14.5, 29.5, 7.9, 8.4, 11.9, 13.6, 14.8, 18.5, 7.9, 17.5, 6.9, 8.4, 10.4, 10.8, 12.8, 14.5, 15.6, 20.1, 6.7, 11.5, 17, 8.4, 13.8, 6.8, 9, 9.1, 12.4, 45.4, 27.5, 34.7, 33.3, 34.4, 7.4, 10.9, 14.3, 16.6, 32.5, 29, 43.8, 13.3, 14.9, 7.7, 22.4, 8.7, 13, 16.7, 21, 13, 14.2, 19.5, 19.5, 11.4, 8.2, 9.4, 14, 15.4, 19.4, 20.3, 9.2, 7.3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       10.5, 16.3, 7.3, 7.8, 14.2, 15.2, 18.9, 8.7, 16.6, 17.6, 22.9, 21.8, 24.8), Price = c(15.9, 33.9, 29.1, 37.7, 30, 15.7, 20.8, 23.7, 26.3, 34.7, 40.1, 13.4, 11.4, 15.1, 15.9, 16.3, 16.6, 18.8, 38, 18.4, 15.8, 29.5, 9.2, 11.3, 13.3, 19, 15.6, 25.8, 12.2, 19.3, 7.4, 10.1, 11.3, 15.9, 14, 19.9, 20.2, 20.9, 8.4, 12.5, 19.8, 12.1, 17.5, 8, 10, 10, 13.9, 47.9, 28, 35.2, 34.3, 36.1, 8.3, 11.6, 16.5, 19.1, 32.5, 31.9, 61.9, 14.1, 14.9, 10.3, 26.1, 11.8, 15.7, 19.1, 21.5, 13.5, 16.3, 19.5, 20.7, 14.4, 9, 11.1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             17.7, 18.5, 24.4, 28.7, 11.1, 8.4, 10.9, 19.5, 8.6, 9.8, 18.4, 18.2, 22.7, 9.1, 19.7, 20, 23.3, 22.7, 26.7), Max.Price = c(18.8, 38.7, 32.3, 44.6, 36.2, 17.3, 21.7, 24.9, 26.3, 36.3, 42.7, 18.3, 11.4, 16.8, 18.4, 18, 18.6, 19.6, 41.5, 18.4, 17.1, 29.5, 10.6, 14.2, 14.7, 24.4, 16.4, 33.1, 16.5, 21.2, 7.9, 11.9, 12.2, 21, 15.2, 25.3, 24.8, 21.7, 10, 13.5, 22.7, 15.8, 21.2, 9.2, 11, 11, 15.3, 50.4, 28.4, 35.6, 35.3, 37.8, 9.1, 12.3, 18.7, 21.7, 32.5, 34.9, 80, 15, 14.9, 12.9, 29.9, 14.9, 18.3, 21.5, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        22, 14, 18.4, 19.5, 21.9, 17.4, 9.9, 12.8, 21.4, 21.6, 29.4, 37.1, 12.9, 9.5, 11.3, 22.7, 10, 11.8, 22.6, 21.2, 26.6, 9.5, 22.7, 22.4, 23.7, 23.5, 28.5), MPG.city = c(25, 18, 20, 19, 22, 22, 19, 16, 19, 16, 16, 25, 25, 19, 21, 18, 15, 17, 17, 20, 23, 20, 29, 23, 22, 17, 21, 18, 29, 20, 31, 23, 22, 22, 24, 15, 21, 18, 46, 30, 24, 42, 24, 29, 22, 26, 20, 17, 18, 18, 17, 18, 29, 28, 26, 18, 17, 20, 19, 23, 19, 29, 18, 29, 24, 17, 21, 24, 23, 18, 19, 23, 31, 23, 19, 19, 19, 20, 28, 33, 25, 23, 39, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               25, 22, 18, 25, 17, 21, 18, 21, 20), MPG.highway = c(31, 25, 26, 26, 30, 31, 28, 25, 27, 25, 25, 36, 34, 28, 29, 23, 20, 26, 25, 28, 28, 26, 33, 29, 27, 21, 27, 24, 33, 28, 33, 30, 27, 29, 30, 20, 30, 26, 50, 36, 31, 46, 31, 33, 29, 34, 27, 22, 24, 23, 26, 26, 37, 36, 34, 24, 25, 29, 25, 26, 26, 33, 24, 33, 30, 23, 26, 31, 31, 23, 28, 30, 41, 31, 28, 27, 28, 26, 38, 37, 30, 30, 43, 37, 32, 29, 22, 33, 21, 30, 25, 28, 28), AirBags = c(3, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 3, 2, 1, 3, 3, 3, 2, 2, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     2, 3, 2, 2, 2, 2, 2, 3, 1, 3, 3, 3, 2, 2, 2, 2, 2, 3, 2, 1, 2, 1, 3, 3, 3, 3, 2, 2, 1, 1, 1, 3, 3, 2, 3, 2, 2, 1, 2, 3, 3, 2, 2, 2, 3, 2, 3, 2, 3, 2, 3, 3, 3, 1, 3, 1, 2, 2, 3, 3, 2, 3, 2, 2, 2, 2, 3, 3, 3, 3, 2, 1), DriveTrain = c(2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 3, 3, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 3, 2, 1, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 1, 3, 3, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             2, 3, 2), Cylinders = c(2, 4, 4, 4, 2, 2, 4, 4, 4, 5, 5, 2, 2, 4, 2, 4, 4, 5, 5, 4, 2, 4, 2, 2, 2, 4, 2, 4, 2, 4, 2, 2, 2, 2, 2, 4, 4, 5, 1, 2, 2, 2, 2, 2, 2, 2, 2, 5, 4, 4, 4, 5, 2, 2, 2, 4, 6, 2, 4, 2, 4, 2, 4, 2, 2, 4, 4, 2, 2, 4, 4, 2, 2, 2, 4, 4, 4, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 3, 2, 4, 2, 3), EngineSize = c(1.8, 3.2, 2.8, 2.8, 3.5, 2.2, 3.8, 5.7, 3.8, 4.9, 4.6, 2.2, 2.2, 3.4, 2.2, 3.8, 4.3, 5, 5.7, 3.3, 3, 3.3, 1.5, 2.2, 2.5, 3, 2.5, 3, 1.5, 3.5, 1.3, 1.8, 2.3, 2.3, 2, 3, 3, 4.6, 1, 1.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            2.3, 1.5, 2.2, 1.5, 1.8, 1.5, 2, 4.5, 3, 3, 3.8, 4.6, 1.6, 1.8, 2.5, 3, 1.3, 2.3, 3.2, 1.6, 3.8, 1.5, 3, 1.6, 2.4, 3, 3, 2.3, 2.2, 3.8, 3.8, 1.8, 1.6, 2, 3.4, 3.4, 3.8, 2.1, 1.9, 1.2, 1.8, 2.2, 1.3, 1.5, 2.2, 2.2, 2.4, 1.8, 2.5, 2, 2.8, 2.3, 2.4), Horsepower = c(140, 200, 172, 172, 208, 110, 170, 180, 170, 200, 295, 110, 110, 160, 110, 170, 165, 170, 300, 153, 141, 147, 92, 93, 100, 142, 100, 300, 92, 214, 63, 127, 96, 105, 115, 145, 140, 190, 55, 90, 160, 102, 140, 81, 124, 92, 128, 278, 185, 225, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   160, 210, 82, 103, 164, 155, 255, 130, 217, 100, 140, 92, 202, 110, 150, 151, 160, 155, 110, 170, 170, 92, 74, 110, 160, 200, 170, 140, 85, 73, 90, 130, 70, 82, 135, 130, 138, 81, 109, 134, 178, 114, 168), RPM = c(6300, 5500, 5500, 5500, 5700, 5200, 4800, 4000, 4800, 4100, 6000, 5200, 5200, 4600, 5200, 4800, 4000, 4200, 5000, 5300, 5000, 4800, 6000, 4800, 4800, 5000, 4800, 6000, 6000, 5800, 5000, 6500, 4200, 4600, 5500, 4800, 4800, 4200, 5700, 5400, 5800, 5900, 5600, 5500, 6000, 5550, 6000, 6000, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         5200, 6000, 4400, 4600, 5000, 5500, 5600, 5000, 6500, 5100, 5500, 5750, 3800, 6000, 6000, 6000, 5600, 4800, 5200, 6000, 5200, 4800, 4800, 5000, 5600, 5200, 4600, 5000, 4800, 6000, 5000, 5600, 5200, 5600, 6000, 5200, 5400, 5400, 5000, 5500, 4500, 5800, 5800, 5400, 6200), Rev.per.mile = c(2890, 2335, 2280, 2535, 2545, 2565, 1570, 1320, 1690, 1510, 1985, 2380, 2665, 1805, 2595, 1690, 1790, 1350, 1450, 1990, 2090, 1785, 3285, 2595, 2535, 1970, 2465, 2120, 2505, 1980, 3150, 2410, 2805, 2285, 2340, 2080, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         1885, 1415, 3755, 3250, 2855, 2650, 2610, 2710, 2745, 2540, 2335, 1955, 2325, 2510, 1835, 1840, 2370, 2220, 2505, 2240, 2325, 2425, 2220, 2475, 1730, 2505, 2210, 2435, 2130, 2065, 2045, 2380, 2565, 1690, 1570, 2360, 3130, 2665, 1805, 1890, 1565, 2910, 2145, 2875, 3375, 2330, 3360, 3505, 2405, 2340, 2515, 2550, 2915, 2685, 2385, 2215, 2310), Man.trans.avail = c(2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2, 1, 2, 2, 1, 1, 2, 2, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Fuel.tank.capacity = c(13.2, 18, 16.9, 21.1, 21.1, 16.4, 18, 23, 18.8, 18, 20, 15.2, 15.6, 15.5, 16.5, 20, 27, 23, 20, 18, 16, 16, 13.2, 14, 16, 20, 16, 19.8, 13.2, 18, 10, 13.2, 15.9, 15.4, 15.5, 21, 16, 20, 10.6, 12.4, 15.9, 11.9, 17, 11.9, 13.7, 11.9, 17.2, 22.5, 18.5, 20.6, 18.4, 20, 13.2, 14.5, 15.5, 19.6, 20, 14.5, 18.5, 11.1, 18, 13.2, 19, 13.2, 15.9, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         20, 18.5, 15.2, 16.5, 20, 18, 15.9, 13.2, 15.2, 15.5, 16.5, 18, 18, 12.8, 9.2, 15.9, 15.9, 10.6, 11.9, 15.9, 18.5, 19.8, 12.4, 21.1, 18.5, 18.5, 15.8, 19.3), Passengers = c(5, 5, 5, 6, 4, 6, 6, 6, 5, 6, 5, 5, 5, 4, 6, 7, 8, 6, 2, 6, 6, 6, 5, 5, 6, 7, 6, 4, 5, 6, 4, 5, 5, 4, 4, 7, 5, 6, 4, 4, 4, 4, 4, 5, 5, 4, 5, 5, 5, 4, 6, 6, 4, 5, 5, 7, 2, 5, 5, 4, 5, 5, 5, 5, 5, 7, 5, 5, 5, 7, 6, 4, 4, 5, 4, 5, 6, 5, 5, 4, 5, 5, 4, 5, 4, 5, 7, 4, 7, 5, 4, 5, 5), Length = c(177, 195, 180, 193, 186, 189, 200, 216, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         198, 206, 204, 182, 184, 193, 198, 178, 194, 214, 179, 203, 183, 203, 174, 172, 181, 175, 192, 180, 174, 202, 141, 171, 177, 180, 179, 176, 192, 212, 151, 164, 175, 173, 185, 168, 172, 166, 184, 200, 188, 191, 205, 219, 164, 172, 184, 190, 169, 175, 187, 166, 199, 172, 190, 170, 181, 190, 188, 188, 190, 194, 201, 173, 177, 181, 196, 195, 177, 184, 176, 146, 175, 179, 161, 162, 174, 188, 187, 163, 187, 180, 159, 190, 184), Wheelbase = c(102, 115, 102, 106, 109, 105, 111, 116, 108, 114, 111, 101, 103, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 101, 108, 110, 111, 116, 96, 113, 104, 110, 98, 97, 104, 112, 105, 97, 98, 113, 90, 98, 100, 101, 103, 119, 106, 114, 93, 97, 100, 103, 107, 94, 98, 94, 104, 113, 103, 106, 109, 117, 97, 98, 103, 110, 96, 105, 110, 95, 113, 98, 107, 96, 103, 112, 104, 103, 105, 110, 111, 97, 99, 101, 101, 108, 111, 99, 102, 90, 97, 102, 93, 94, 99, 103, 113, 93, 115, 103, 97, 104, 105), Width = c(68, 71, 67, 70, 69, 69, 74, 78, 73, 73, 74, 66, 68, 74, 71, 74, 78, 77, 74, 74, 68, 69, 66, 67, 68, 72, 69, 72, 66, 74, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                63, 67, 68, 68, 70, 72, 71, 78, 63, 67, 70, 67, 67, 63, 66, 64, 69, 72, 70, 71, 73, 77, 66, 66, 69, 72, 69, 67, 69, 65, 73, 67, 70, 66, 67, 74, 69, 67, 70, 74, 74, 67, 66, 66, 75, 72, 74, 67, 68, 60, 65, 67, 63, 65, 69, 70, 71, 63, 72, 67, 66, 67, 69), Turn.circle = c(37, 38, 37, 37, 39, 41, 42, 45, 41, 43, 44, 38, 39, 43, 40, 44, 42, 42, 43, 40, 41, 44, 32, 38, 39, 42, 42, 40, 36, 40, 33, 36, 39, 40, 38, 45, 40, 43, 34, 37, 39, 36, 41, 35, 36, 34, 41, 42, 40, 39, 42, 45, 34, 36, 40, 39, 37, 34, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             37, 36, 38, 36, 43, 33, 40, 41, 41, 39, 42, 44, 42, 39, 35, 39, 43, 41, 43, 37, 40, 32, 35, 37, 34, 36, 39, 38, 41, 34, 38, 35, 36, 37, 38), Rear.seat.room = c(26.5, 30, 28, 31, 27, 28, 30.5, 30.5, 26.5, 35, 31, 25, 26, 25, 28.5, 30.5, 33.5, 29.5, NA, 31, 30.5, 36, 26.5, 26.5, 30.5, 26.5, 30.5, 20, 26.5, 30, 26, 28, 27.5, 24, 23, 30, 27.5, 30, 27.5, 24.5, 23.5, 28, 28, 26, 28, 23.5, 31, 29, 27.5, 25, 30, 31.5, 27, 26.5, 29.5, 27.5, NA, 26, 27, 19, 28, 26, 27.5, 26, 28.5, 27, 28.5, 28, 28, 30.5, 31.5, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             24.5, 25.5, 25, 25, 28.5, 30.5, 26.5, 26.5, 23.5, 27.5, 27, 27.5, 24, 23, 28.5, 35, 26, 34, 31.5, 26, 29.5, 30), Luggage.room = c(11, 15, 14, 17, 13, 16, 17, 21, 14, 18, 14, 13, 14, 13, 16, NA, NA, 20, NA, 15, 14, 17, 11, 13, 14, NA, 16, 11, 11, 15, 12, 12, 13, 12, 18, NA, 18, 21, 10, 11, 8, 12, 14, 11, 12, 9, 14, 15, 14, 9, 19, 22, 16, 13, 14, NA, NA, 12, 15, 6, 15, 11, 14, 12, 14, NA, 14, 14, 16, NA, 17, 8, 17, 13, 13, 16, 18, 14, 12, 10, 15, 14, 10, 11, 13, 15, NA, 10, NA, 14, 15, 14, 15), Weight = c(2705, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          3560, 3375, 3405, 3640, 2880, 3470, 4105, 3495, 3620, 3935, 2490, 2785, 3240, 3195, 3715, 4025, 3910, 3380, 3515, 3085, 3570, 2270, 2670, 2970, 3705, 3080, 3805, 2295, 3490, 1845, 2530, 2690, 2850, 2710, 3735, 3325, 3950, 1695, 2475, 2865, 2350, 3040, 2345, 2620, 2285, 2885, 4000, 3510, 3515, 3695, 4055, 2325, 2440, 2970, 3735, 2895, 2920, 3525, 2450, 3610, 2295, 3730, 2545, 3050, 4100, 3200, 2910, 2890, 3715, 3470, 2640, 2350, 2575, 3240, 3450, 3495, 2775, 2495, 2045, 2490, 3085, 1965, 2055, 2950, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          3030, 3785, 2240, 3960, 2985, 2810, 2985, 3245), Origin = c(2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Make = c(1, 2, 4, 3, 5, 6, 7, 9, 8, 10, 11, 15, 16, 13, 18, 19, 12, 14, 17, 20, 22, 21, 24, 26, 27, 23, 25, 28, 29, 30, 34, 33, 38, 35, 36, 31, 37, 32, 39, 40, 43, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       42, 41, 45, 44, 46, 47, 48, 49, 50, 51, 52, 53, 56, 54, 55, 57, 58, 59, 60, 61, 63, 62, 67, 64, 66, 65, 68, 69, 71, 70, 72, 76, 77, 74, 75, 73, 78, 79, 80, 82, 81, 83, 87, 85, 84, 86, 90, 89, 91, 88, 92, 93)))
package:MASS
TRUE
FALSE
cats
list(`package:MASS` = list(Sex = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Bwt = c(2, 2, 2, 2.1, 2.1, 2.1, 2.1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            2.1, 2.1, 2.1, 2.1, 2.1, 2.2, 2.2, 2.2, 2.2, 2.2, 2.2, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.4, 2.4, 2.4, 2.4, 2.5, 2.5, 2.6, 2.6, 2.6, 2.7, 2.7, 2.7, 2.9, 2.9, 2.9, 3, 3, 2, 2, 2.1, 2.2, 2.2, 2.2, 2.2, 2.2, 2.2, 2.2, 2.2, 2.3, 2.4, 2.4, 2.4, 2.4, 2.4, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.6, 2.6, 2.6, 2.6, 2.6, 2.6, 2.7, 2.7, 2.7, 2.7, 2.7, 2.7, 2.7, 2.7, 2.7, 2.8, 2.8, 2.8, 2.8, 2.8, 2.8, 2.8, 2.9, 2.9, 2.9, 2.9, 2.9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3.1, 3.1, 3.1, 3.1, 3.1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            3.1, 3.2, 3.2, 3.2, 3.2, 3.2, 3.2, 3.3, 3.3, 3.3, 3.3, 3.3, 3.4, 3.4, 3.4, 3.4, 3.4, 3.5, 3.5, 3.5, 3.5, 3.5, 3.6, 3.6, 3.6, 3.6, 3.7, 3.8, 3.8, 3.9, 3.9), Hwt = c(7, 7.4, 9.5, 7.2, 7.3, 7.6, 8.1, 8.2, 8.3, 8.5, 8.7, 9.8, 7.1, 8.7, 9.1, 9.7, 10.9, 11, 7.3, 7.9, 8.4, 9, 9, 9.5, 9.6, 9.7, 10.1, 10.1, 10.6, 11.2, 6.3, 8.7, 8.8, 10.2, 9, 10.9, 8.7, 10.1, 10.1, 8.5, 10.2, 10.8, 9.9, 10.1, 10.1, 10.6, 13, 6.5, 6.5, 10.1, 7.2, 7.6, 7.9, 8.5, 9.1, 9.6, 9.6, 10.7, 9.6, 7.3, 7.9, 7.9, 9.1, 9.3, 7.9, 8.6, 8.8, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                8.8, 9.3, 11, 12.7, 12.7, 7.7, 8.3, 9.4, 9.4, 10.5, 11.5, 8, 9, 9.6, 9.6, 9.8, 10.4, 11.1, 12, 12.5, 9.1, 10, 10.2, 11.4, 12, 13.3, 13.5, 9.4, 10.1, 10.6, 11.3, 11.8, 10, 10.4, 10.6, 11.6, 12.2, 12.4, 12.7, 13.3, 13.8, 9.9, 11.5, 12.1, 12.5, 13, 14.3, 11.6, 11.9, 12.3, 13, 13.5, 13.6, 11.5, 12, 14.1, 14.9, 15.4, 11.2, 12.2, 12.4, 12.8, 14.4, 11.7, 12.9, 15.6, 15.7, 17.2, 11.8, 13.3, 14.8, 15, 11, 14.8, 16.8, 14.4, 20.5)))
package:MASS
TRUE
FALSE
cement
list(`package:MASS` = list(x1 = c(7, 1, 11, 11, 7, 11, 3, 1, 2, 21, 1, 11, 10), x2 = c(26, 29, 56, 31, 52, 55, 71, 31, 54, 47, 40, 66, 68), x3 = c(6, 15, 8, 8, 6, 9, 17, 22, 18, 4, 23, 9, 8), x4 = c(60, 52, 20, 47, 33, 22, 6, 44, 22, 26, 34, 12, 12), y = c(78.5, 74.3, 104.3, 87.6, 95.9, 109.2, 102.7, 72.5, 93.1, 115.9, 83.8, 113.3, 109.4)))
package:MASS
TRUE
FALSE
chem
list(`package:MASS` = c(2.9, 3.1, 3.4, 3.4, 3.7, 3.7, 2.8, 2.5, 2.4, 2.4, 2.7, 2.2, 5.28, 3.37, 3.03, 3.03, 28.95, 3.77, 3.4, 2.2, 3.5, 3.6, 3.7, 3.7))
package:MASS
TRUE
FALSE
con2tr
list(`package:MASS` = function (obj) 
{
  data.frame(expand.grid(x = obj$x, y = obj$y), z = as.vector(obj$z))
}, function (obj) 
{
  data.frame(expand.grid(x = obj$x, y = obj$y), z = as.vector(obj$z))
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
contr.sdif
list(`package:MASS` = function (n, contrasts = TRUE, sparse = FALSE) 
{
  if (is.numeric(n) && length(n) == 1) {
    if (n%%1 || n < 2) 
      stop("invalid number of levels")
    lab <- as.character(seq(n))
  }
  else {
    lab <- as.character(n)
    n <- length(n)
    if (n < 2) 
      stop("invalid number of levels")
  }
  if (contrasts) {
    cont <- col(matrix(nrow = n, ncol = n - 1))
    upper.tri <- !lower.tri(cont)
    cont[upper.tri] <- cont[upper.tri] - n
    structure(cont/n, dimnames = list(lab, paste(lab[-1], lab[-n], sep = "-")))
  }
  else .Diag(lab, sparse = sparse)
}, function (n, contrasts = TRUE, sparse = FALSE) 
{
  if (is.numeric(n) && length(n) == 1) {
    if (n%%1 || n < 2) 
      stop("invalid number of levels")
    lab <- as.character(seq(n))
  }
  else {
    lab <- as.character(n)
    n <- length(n)
    if (n < 2) 
      stop("invalid number of levels")
  }
  if (contrasts) {
    cont <- col(matrix(nrow = n, ncol = n - 1))
    upper.tri <- !lower.tri(cont)
    cont[upper.tri] <- cont[upper.tri] - n
    structure(cont/n, dimnames = list(lab, paste(lab[-1], lab[-n], sep = "-")))
  }
  else .Diag(lab, sparse = sparse)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
coop
list(`package:MASS` = list(Lab = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
                                   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6), Spc = c(1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 
                                                                                                                                                                                                                                                                                                                                            5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 
                                                                                                                                                                                                                                                                                                                                            5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7), Bat = c(1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                        2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3), Conc = c(0.29, 0.33, 0.33, 0.32, 0.34, 0.31, 0.13, 0.14, 0.16, 0.11, 0.14, 0.13, 0.68, 0.71, 0.86, 0.76, 0.72, 0.73, 0.5, 0.47, 0.64, 0.53, 0.49, 0.5, 6.6, 7.08, 7.56, 7.14, 7.19, 6.64, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1.36, 1.34, 1.51, 1.44, 1.52, 1.3, 1.06, 0.88, 1.01, 1.09, 0.87, 1.02, 0.4, 0.4, 0.43, 0.36, 0.42, 0.4, 0.22, 0.22, 0.24, 0.19, 0.21, 0.22, 1.03, 1.05, 1.05, 1.16, 0.97, 1.12, 0.81, 0.57, 0.67, 0.6, 0.66, 0.8, 8.4, 8.6, 7.54, 8.5, 8.74, 8.22, 2.12, 2.44, 1.49, 1.7, 1.73, 1.64, 1.5, 1.07, 1.23, 0.93, 1.32, 1.25, 0.4, 0.35, 0.38, 0.32, 0.38, 0.33, 0.25, 0.2, 0.16, 0.16, 0.25, 0.18, 0.83, 0.66, 0.89, 0.92, 0.75, 0.75, 0.5, 0.5, 0.58, 0.67, 0.5, 0.5, 6.9, 6.7, 7.1, 7.1, 6.3, 6.7, 1.5, 1.5, 1.5, 1.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1.3, 1.5, 1, 1, 1.1, 1.1, 0.75, 0.9, 0.9, 1.3, 0.9, 1.1, 0.9, 0.9, 1.7, 1.3, 1.5, 1.5, 0.6, 0.4, 1.3, 1.7, 1.5, 1.5, 2.1, 1.9, 1.3, 1.3, 1.3, 1.1, 0.2, 0.2, 7.6, 7.8, 7.9, 7.5, 7.8, 7.4, 2.4, 2.6, 2.2, 2.8, 2.2, 1.7, 1.5, 1.9, 2.4, 1.9, 1.7, 2, 0.44, 0.44, 0.45, 0.45, 0.42, 0.46, 0.23, 0.24, 0.22, 0.23, 0.24, 0.18, 1.1, 1, 1.1, 1.2, 1.2, 1.1, 0.48, 0.47, 0.57, 0.56, 0.55, 0.55, 8, 7.8, 8, 7.9, 8.3, 8.3, 1.9, 1.9, 1.9, 1.9, 1.8, 1.9, 1.3, 1.4, 1.3, 1.3, 1.2, 1.2, 0.38, 0.39, 0.4, 0.46, 0.72, 0.79, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             0.24, 0.2, 0.15, 0.16, 0.35, 0.42, 1.03, 0.88, 1.06, 1.16, 1.1, 1.2, 0.31, 0.31, 0.69, 0.73, 1.1, 0.9, 7.7, 6.9, 9.4, 9.9, 9.2, 9, 1.7, 1.8, 2, 2.1, 1.5, 1.5, 1.5, 1.5, 1.3, 1.4, 1.5, 1.8)))
package:MASS
TRUE
FALSE
corresp
list(`package:MASS` = function (x, ...) 
  UseMethod("corresp"), function (x, ...) 
    UseMethod("corresp"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
cov.mcd
list(`package:MASS` = function (...) 
{
  oc <- sys.call()
  oc$method <- "mcd"
  oc[[1]] <- quote(MASS::cov.rob)
  eval.parent(oc)
}, function (...) 
{
  oc <- sys.call()
  oc$method <- "mcd"
  oc[[1]] <- quote(MASS::cov.rob)
  eval.parent(oc)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
cov.mve
list(`package:MASS` = function (...) 
{
  oc <- sys.call()
  oc$method <- "mve"
  oc[[1]] <- quote(MASS::cov.rob)
  eval.parent(oc)
}, function (...) 
{
  oc <- sys.call()
  oc$method <- "mve"
  oc[[1]] <- quote(MASS::cov.rob)
  eval.parent(oc)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
cov.rob
list(`package:MASS` = function (x, cor = FALSE, quantile.used = floor((n + p + 1)/2), method = c("mve", "mcd", "classical"), nsamp = "best", seed) 
{
  method <- match.arg(method)
  x <- as.matrix(x)
  if (any(is.na(x)) || any(is.infinite(x))) 
    stop("missing or infinite values are not allowed")
  n <- nrow(x)
  p <- ncol(x)
  if (n < p + 1) 
    stop(gettextf("at least %d cases are needed", p + 1), domain = NA)
  if (method == "classical") {
    ans <- list(center = colMeans(x), cov = var(x))
  }
  else {
    if (quantile.used < p + 1) 
      stop(gettextf("'quantile' must be at least %d", p + 1), domain = NA)
    if (quantile.used > n - 1) 
      stop(gettextf("'quantile' must be at most %d", n - 1), domain = NA)
    divisor <- apply(x, 2, IQR)
    if (any(divisor == 0)) 
      stop("at least one column has IQR 0")
    x <- x/rep(divisor, rep(n, p))
    qn <- quantile.used
    ps <- p + 1
    nexact <- choose(n, ps)
    if (is.character(nsamp) && nsamp == "best") 
      nsamp <- if (nexact < 5000) 
        "exact"
    else "sample"
    if (is.numeric(nsamp) && nsamp > nexact) {
      warning(sprintf(ngettext(nexact, "only %d set, so all sets will be tried", "only %d sets, so all sets will be tried"), nexact), domain = NA)
      nsamp <- "exact"
    }
    samp <- nsamp != "exact"
    if (samp) {
      if (nsamp == "sample") 
        nsamp <- min(500 * ps, 3000)
    }
    else nsamp <- nexact
    if (nsamp > 2147483647) {
      if (samp) 
        stop(sprintf("Too many samples (%.3g)", nsamp))
      else stop(sprintf("Too many combinations (%.3g) for nsamp = \"exact\"", nsamp))
    }
    if (samp && !missing(seed)) {
      if (exists(".Random.seed", envir = .GlobalEnv, inherits = FALSE)) {
        seed.keep <- get(".Random.seed", envir = .GlobalEnv, inherits = FALSE)
        on.exit(assign(".Random.seed", seed.keep, envir = .GlobalEnv))
      }
      assign(".Random.seed", seed, envir = .GlobalEnv)
    }
    z <- .C(mve_fitlots, as.double(x), as.integer(n), as.integer(p), as.integer(qn), as.integer(method == "mcd"), as.integer(samp), as.integer(ps), as.integer(nsamp), crit = double(1), sing = integer(1), bestone = integer(n))
    z$sing <- paste(z$sing, "singular samples of size", ps, "out of", nsamp)
    crit <- z$crit + 2 * sum(log(divisor)) + if (method == "mcd") 
      -p * log(qn - 1)
    else 0
    best <- seq(n)[z$bestone != 0]
    if (!length(best)) 
      stop("'x' is probably collinear")
    means <- colMeans(x[best, , drop = FALSE])
    rcov <- var(x[best, , drop = FALSE]) * (1 + 15/(n - p))^2
    dist <- mahalanobis(x, means, rcov)
    cut <- qchisq(0.975, p) * quantile(dist, qn/n)/qchisq(qn/n, p)
    cov <- divisor * var(x[dist < cut, , drop = FALSE]) * rep(divisor, rep(p, p))
    attr(cov, "names") <- NULL
    ans <- list(center = colMeans(x[dist < cut, , drop = FALSE]) * divisor, cov = cov, msg = z$sing, crit = crit, best = best)
  }
  if (cor) {
    sd <- sqrt(diag(ans$cov))
    ans <- c(ans, list(cor = (ans$cov/sd)/rep(sd, rep(p, p))))
  }
  ans$n.obs <- n
  ans
}, function (x, cor = FALSE, quantile.used = floor((n + p + 1)/2), method = c("mve", "mcd", "classical"), nsamp = "best", seed) 
{
  method <- match.arg(method)
  x <- as.matrix(x)
  if (any(is.na(x)) || any(is.infinite(x))) 
    stop("missing or infinite values are not allowed")
  n <- nrow(x)
  p <- ncol(x)
  if (n < p + 1) 
    stop(gettextf("at least %d cases are needed", p + 1), domain = NA)
  if (method == "classical") {
    ans <- list(center = colMeans(x), cov = var(x))
  }
  else {
    if (quantile.used < p + 1) 
      stop(gettextf("'quantile' must be at least %d", p + 1), domain = NA)
    if (quantile.used > n - 1) 
      stop(gettextf("'quantile' must be at most %d", n - 1), domain = NA)
    divisor <- apply(x, 2, IQR)
    if (any(divisor == 0)) 
      stop("at least one column has IQR 0")
    x <- x/rep(divisor, rep(n, p))
    qn <- quantile.used
    ps <- p + 1
    nexact <- choose(n, ps)
    if (is.character(nsamp) && nsamp == "best") 
      nsamp <- if (nexact < 5000) 
        "exact"
    else "sample"
    if (is.numeric(nsamp) && nsamp > nexact) {
      warning(sprintf(ngettext(nexact, "only %d set, so all sets will be tried", "only %d sets, so all sets will be tried"), nexact), domain = NA)
      nsamp <- "exact"
    }
    samp <- nsamp != "exact"
    if (samp) {
      if (nsamp == "sample") 
        nsamp <- min(500 * ps, 3000)
    }
    else nsamp <- nexact
    if (nsamp > 2147483647) {
      if (samp) 
        stop(sprintf("Too many samples (%.3g)", nsamp))
      else stop(sprintf("Too many combinations (%.3g) for nsamp = \"exact\"", nsamp))
    }
    if (samp && !missing(seed)) {
      if (exists(".Random.seed", envir = .GlobalEnv, inherits = FALSE)) {
        seed.keep <- get(".Random.seed", envir = .GlobalEnv, inherits = FALSE)
        on.exit(assign(".Random.seed", seed.keep, envir = .GlobalEnv))
      }
      assign(".Random.seed", seed, envir = .GlobalEnv)
    }
    z <- .C(mve_fitlots, as.double(x), as.integer(n), as.integer(p), as.integer(qn), as.integer(method == "mcd"), as.integer(samp), as.integer(ps), as.integer(nsamp), crit = double(1), sing = integer(1), bestone = integer(n))
    z$sing <- paste(z$sing, "singular samples of size", ps, "out of", nsamp)
    crit <- z$crit + 2 * sum(log(divisor)) + if (method == "mcd") 
      -p * log(qn - 1)
    else 0
    best <- seq(n)[z$bestone != 0]
    if (!length(best)) 
      stop("'x' is probably collinear")
    means <- colMeans(x[best, , drop = FALSE])
    rcov <- var(x[best, , drop = FALSE]) * (1 + 15/(n - p))^2
    dist <- mahalanobis(x, means, rcov)
    cut <- qchisq(0.975, p) * quantile(dist, qn/n)/qchisq(qn/n, p)
    cov <- divisor * var(x[dist < cut, , drop = FALSE]) * rep(divisor, rep(p, p))
    attr(cov, "names") <- NULL
    ans <- list(center = colMeans(x[dist < cut, , drop = FALSE]) * divisor, cov = cov, msg = z$sing, crit = crit, best = best)
  }
  if (cor) {
    sd <- sqrt(diag(ans$cov))
    ans <- c(ans, list(cor = (ans$cov/sd)/rep(sd, rep(p, p))))
  }
  ans$n.obs <- n
  ans
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
cov.trob
list(`package:MASS` = function (x, wt = rep(1, n), cor = FALSE, center = TRUE, nu = 5, maxit = 25, tol = 0.01) 
{
  test.values <- function(x) {
    if (any(is.na(x)) || any(is.infinite(x))) 
      stop("missing or infinite values in 'x'")
  }
  scale.simp <- function(x, center, n, p) x - rep(center, rep(n, p))
  x <- as.matrix(x)
  n <- nrow(x)
  p <- ncol(x)
  dn <- colnames(x)
  test.values(x)
  if (!(miss.wt <- missing(wt))) {
    wt0 <- wt
    test.values(wt)
    if (length(wt) != n) 
      stop("length of 'wt' must equal number of observations")
    if (any(wt < 0)) 
      stop("negative weights not allowed")
    if (!sum(wt)) 
      stop("no positive weights")
    x <- x[wt > 0, , drop = FALSE]
    wt <- wt[wt > 0]
    n <- nrow(x)
  }
  loc <- colSums(wt * x)/sum(wt)
  if (is.numeric(center)) {
    if (length(center) != p) 
      stop("'center' is not the right length")
    loc <- center
  }
  else if (is.logical(center) && !center) 
    loc <- rep(0, p)
  use.loc <- is.logical(center) && center
  w <- wt * (1 + p/nu)
  endit <- 0
  for (iter in 1:maxit) {
    w0 <- w
    X <- scale.simp(x, loc, n, p)
    sX <- svd(sqrt(w/sum(w)) * X, nu = 0)
    wX <- X %*% sX$v %*% diag(1/sX$d, , p)
    Q <- drop(wX^2 %*% rep(1, p))
    w <- (wt * (nu + p))/(nu + Q)
    if (use.loc) 
      loc <- colSums(w * x)/sum(w)
    if (all(abs(w - w0) < tol)) 
      break
    endit <- iter
  }
  if (endit == maxit || abs(mean(w) - mean(wt)) > tol || abs(mean(w * Q)/p - 1) > tol) 
    warning("Probable convergence failure")
  cov <- crossprod(sqrt(w) * X)/sum(wt)
  if (length(dn)) {
    dimnames(cov) <- list(dn, dn)
    names(loc) <- dn
  }
  if (miss.wt) 
    ans <- list(cov = cov, center = loc, n.obs = n)
  else ans <- list(cov = cov, center = loc, wt = wt0, n.obs = n)
  if (cor) {
    sd <- sqrt(diag(cov))
    cor <- (cov/sd)/rep(sd, rep.int(p, p))
    if (length(dn)) 
      dimnames(cor) <- list(dn, dn)
    ans <- c(ans, list(cor = cor))
  }
  ans$call <- match.call()
  ans$iter <- endit
  ans
}, function (x, wt = rep(1, n), cor = FALSE, center = TRUE, nu = 5, maxit = 25, tol = 0.01) 
{
  test.values <- function(x) {
    if (any(is.na(x)) || any(is.infinite(x))) 
      stop("missing or infinite values in 'x'")
  }
  scale.simp <- function(x, center, n, p) x - rep(center, rep(n, p))
  x <- as.matrix(x)
  n <- nrow(x)
  p <- ncol(x)
  dn <- colnames(x)
  test.values(x)
  if (!(miss.wt <- missing(wt))) {
    wt0 <- wt
    test.values(wt)
    if (length(wt) != n) 
      stop("length of 'wt' must equal number of observations")
    if (any(wt < 0)) 
      stop("negative weights not allowed")
    if (!sum(wt)) 
      stop("no positive weights")
    x <- x[wt > 0, , drop = FALSE]
    wt <- wt[wt > 0]
    n <- nrow(x)
  }
  loc <- colSums(wt * x)/sum(wt)
  if (is.numeric(center)) {
    if (length(center) != p) 
      stop("'center' is not the right length")
    loc <- center
  }
  else if (is.logical(center) && !center) 
    loc <- rep(0, p)
  use.loc <- is.logical(center) && center
  w <- wt * (1 + p/nu)
  endit <- 0
  for (iter in 1:maxit) {
    w0 <- w
    X <- scale.simp(x, loc, n, p)
    sX <- svd(sqrt(w/sum(w)) * X, nu = 0)
    wX <- X %*% sX$v %*% diag(1/sX$d, , p)
    Q <- drop(wX^2 %*% rep(1, p))
    w <- (wt * (nu + p))/(nu + Q)
    if (use.loc) 
      loc <- colSums(w * x)/sum(w)
    if (all(abs(w - w0) < tol)) 
      break
    endit <- iter
  }
  if (endit == maxit || abs(mean(w) - mean(wt)) > tol || abs(mean(w * Q)/p - 1) > tol) 
    warning("Probable convergence failure")
  cov <- crossprod(sqrt(w) * X)/sum(wt)
  if (length(dn)) {
    dimnames(cov) <- list(dn, dn)
    names(loc) <- dn
  }
  if (miss.wt) 
    ans <- list(cov = cov, center = loc, n.obs = n)
  else ans <- list(cov = cov, center = loc, wt = wt0, n.obs = n)
  if (cor) {
    sd <- sqrt(diag(cov))
    cor <- (cov/sd)/rep(sd, rep.int(p, p))
    if (length(dn)) 
      dimnames(cor) <- list(dn, dn)
    ans <- c(ans, list(cor = cor))
  }
  ans$call <- match.call()
  ans$iter <- endit
  ans
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
cpus
list(`package:MASS` = list(name = c(1, 3, 2, 4, 5, 6, 8, 9, 10, 7, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 36, 37, 38, 39, 40, 41, 42, 43, 44, 31, 32, 33, 34, 35, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 87, 88, 89, 90, 91, 92, 93, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85, 86, 81, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 
                                    116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 167, 168, 166, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 209, 208), syct = c(125, 29, 29, 29, 29, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    26, 23, 23, 23, 23, 400, 400, 60, 50, 350, 200, 167, 143, 143, 110, 143, 143, 143, 110, 320, 320, 320, 320, 320, 320, 25, 25, 50, 50, 56, 64, 50, 50, 50, 50, 50, 50, 50, 50, 133, 133, 810, 810, 320, 200, 700, 700, 140, 200, 110, 110, 220, 800, 800, 800, 800, 800, 125, 75, 75, 75, 90, 105, 105, 105, 75, 75, 175, 300, 300, 300, 300, 300, 300, 180, 330, 300, 300, 330, 330, 140, 140, 140, 140, 140, 140, 140, 140, 57, 57, 26, 26, 26, 26, 480, 203, 115, 1100, 1100, 600, 400, 400, 900, 900, 900, 900, 900, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    225, 225, 180, 185, 180, 225, 25, 25, 17, 17, 1500, 1500, 800, 50, 50, 50, 50, 50, 50, 100, 100, 100, 50, 50, 50, 150, 115, 115, 92, 92, 92, 75, 60, 60, 60, 50, 72, 72, 40, 40, 35, 38, 48, 38, 30, 112, 84, 56, 56, 56, 56, 56, 56, 38, 38, 38, 38, 38, 200, 200, 200, 250, 250, 250, 160, 160, 160, 160, 160, 240, 240, 105, 105, 105, 52, 70, 59, 59, 26, 26, 26, 116, 50, 50, 50, 50, 30, 30, 180, 180, 180, 180, 124, 98, 125, 480, 480), mmin = c(256, 8000, 8000, 8000, 8000, 8000, 16000, 16000, 16000, 32000, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1000, 512, 2000, 4000, 64, 512, 524, 512, 1000, 5000, 1500, 3100, 2300, 3100, 128, 512, 256, 256, 512, 256, 1310, 1310, 2620, 2620, 5240, 5240, 500, 1000, 2000, 1000, 1000, 2000, 2000, 2000, 1000, 1000, 512, 1000, 512, 512, 384, 256, 1000, 1000, 1000, 1000, 1000, 256, 256, 256, 256, 256, 512, 2000, 2000, 2000, 256, 256, 1000, 2000, 2000, 3000, 256, 768, 768, 768, 768, 384, 192, 768, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 4000, 4000, 16000, 16000, 8000, 8000, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             96, 1000, 512, 512, 768, 768, 2000, 4000, 1000, 512, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 2000, 1000, 2000, 2000, 4000, 4000, 768, 768, 768, 2000, 2000, 2000, 2000, 2000, 8000, 1000, 1000, 1000, 2000, 2000, 2000, 512, 2000, 2000, 2000, 2000, 2000, 4000, 4000, 2000, 4000, 4000, 4000, 2000, 8000, 8000, 8000, 16000, 4000, 8000, 16000, 1000, 1000, 1000, 2000, 2000, 4000, 4000, 4000, 4000, 4000, 8000, 8000, 4000, 1000, 1000, 2000, 512, 512, 1000, 512, 512, 1000, 1000, 2000, 512, 512, 2000, 2000, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             2000, 4000, 4000, 4000, 8000, 8000, 8000, 8000, 2000, 2000, 2000, 2000, 4000, 8000, 8000, 262, 512, 262, 512, 1000, 1000, 2000, 512, 1000), mmax = c(6000, 32000, 32000, 32000, 16000, 32000, 32000, 32000, 64000, 64000, 3000, 3500, 8000, 16000, 64, 16000, 2000, 5000, 2000, 5000, 6300, 6200, 6200, 6200, 6000, 2000, 6000, 3000, 5000, 5000, 2620, 2620, 10480, 10480, 20970, 20970, 2000, 4000, 8000, 4000, 8000, 16000, 16000, 16000, 12000, 8000, 512, 5000, 8000, 8000, 8000, 2000, 16000, 8000, 4000, 12000, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  8000, 8000, 8000, 8000, 8000, 8000, 1000, 8000, 16000, 16000, 1000, 2000, 4000, 4000, 8000, 8000, 2000, 3000, 3000, 12000, 4500, 12000, 768, 12000, 3000, 4000, 16000, 2000, 4000, 4000, 4000, 4000, 32000, 8000, 32000, 32000, 4000, 16000, 24000, 32000, 32000, 32000, 16000, 512, 2000, 6000, 1500, 2000, 2000, 4000, 8000, 1000, 1000, 4000, 4000, 4000, 4000, 4000, 8000, 16000, 16000, 4000, 12000, 12000, 16000, 16000, 1000, 2000, 2000, 4000, 8000, 8000, 16000, 16000, 16000, 8000, 8000, 8000, 16000, 16000, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  16000, 4000, 8000, 4000, 8000, 8000, 8000, 16000, 16000, 16000, 16000, 16000, 16000, 8000, 16000, 32000, 32000, 32000, 24000, 32000, 32000, 1000, 2000, 4000, 6000, 8000, 8000, 12000, 16000, 8000, 8000, 16000, 24000, 16000, 2000, 4000, 8000, 4000, 4000, 16000, 4000, 2000, 4000, 8000, 8000, 1000, 2000, 4000, 6000, 8000, 16000, 12000, 12000, 16000, 24000, 32000, 32000, 8000, 32000, 32000, 32000, 32000, 64000, 64000, 4000, 4000, 4000, 4000, 8000, 8000, 8000, 8000, 4000), cach = c(256, 32, 32, 32, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   64, 64, 64, 64, 128, 0, 4, 65, 65, 0, 0, 8, 0, 0, 142, 0, 0, 0, 0, 0, 4, 0, 4, 4, 4, 131, 131, 30, 30, 30, 30, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 0, 4, 8, 0, 0, 16, 0, 16, 16, 16, 0, 0, 0, 0, 0, 0, 64, 64, 128, 0, 0, 0, 8, 8, 8, 0, 0, 6, 6, 0, 6, 6, 6, 0, 8, 8, 0, 0, 0, 0, 8, 32, 32, 32, 32, 8, 1, 64, 64, 64, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 4, 8, 0, 8, 8, 8, 16, 16, 2, 8, 16, 8, 32, 0, 0, 0, 0, 8, 8, 24, 24, 48, 0, 24, 24, 12, 24, 24, 0, 16, 2, 32, 32, 4, 16, 32, 64, 64, 64, 64, 16, 32, 64, 64, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   128, 32, 64, 256, 0, 0, 0, 0, 0, 0, 0, 0, 32, 32, 64, 160, 128, 0, 0, 64, 0, 0, 1, 2, 2, 8, 16, 32, 8, 8, 8, 16, 16, 32, 8, 32, 64, 32, 64, 128, 32, 24, 48, 112, 112, 96, 128, 0, 0, 0, 0, 0, 32, 0, 32, 0), chmin = c(16, 8, 8, 8, 8, 8, 16, 16, 16, 32, 1, 1, 1, 1, 1, 4, 4, 7, 5, 8, 5, 5, 6, 6, 1, 1, 1, 1, 1, 1, 12, 12, 12, 12, 12, 12, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 1, 1, 6, 1, 2, 3, 2, 1, 3, 3, 4, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 6, 12, 16, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 3, 1, 3, 6, 6, 0, 0, 0, 3, 3, 1, 1, 1, 1, 2, 2, 3, 3, 6, 6, 8, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 8, 6, 8, 8, 8, 16, 8, 8, 16, 1, 1, 1, 1, 1, 1, 1, 1, 16, 16, 4, 4, 16, 1, 1, 1, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 3, 6, 4, 4, 6, 6, 12, 8, 12, 24, 5, 6, 26, 52, 52, 12, 12, 1, 1, 1, 1, 1, 2, 2, 0, 0), chmax = c(128, 32, 32, 32, 16, 32, 32, 32, 32, 64, 2, 6, 8, 8, 4, 32, 15, 32, 16, 64, 32, 20, 64, 64, 12, 3, 6, 3, 5, 6, 24, 24, 24, 24, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    24, 24, 4, 5, 5, 5, 5, 5, 6, 6, 12, 12, 1, 1, 5, 8, 1, 1, 3, 2, 2, 2, 2, 4, 4, 4, 4, 4, 20, 38, 38, 38, 10, 10, 24, 19, 24, 48, 24, 24, 24, 24, 24, 24, 24, 31, 4, 64, 112, 2, 6, 6, 8, 20, 20, 54, 54, 54, 20, 12, 16, 24, 24, 24, 16, 1, 5, 6, 1, 1, 1, 1, 1, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6, 6, 4, 5, 12, 12, 0, 0, 0, 6, 6, 6, 6, 6, 10, 6, 6, 6, 16, 16, 16, 128, 3, 5, 6, 6, 6, 6, 6, 8, 8, 10, 16, 8, 16, 24, 24, 32, 24, 24, 24, 4, 6, 6, 8, 8, 8, 8, 8, 32, 32, 8, 8, 32, 2, 4, 5, 7, 7, 8, 5, 8, 14, 14, 13, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    3, 5, 8, 16, 14, 12, 8, 12, 24, 16, 16, 32, 28, 26, 52, 104, 104, 176, 176, 3, 3, 3, 3, 8, 8, 14, 0, 0), perf = c(198, 269, 220, 172, 132, 318, 367, 489, 636, 1144, 38, 40, 92, 138, 10, 35, 19, 28, 31, 120, 30, 33, 61, 76, 23, 69, 33, 27, 77, 27, 274, 368, 32, 63, 106, 208, 20, 29, 71, 26, 36, 40, 52, 60, 72, 72, 18, 20, 40, 62, 24, 24, 138, 36, 26, 60, 71, 12, 14, 20, 16, 22, 36, 144, 144, 259, 17, 26, 32, 32, 62, 64, 22, 36, 44, 50, 45, 53, 36, 84, 16, 38, 38, 16, 22, 29, 40, 35, 134, 66, 141, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      189, 22, 132, 237, 465, 465, 277, 185, 6, 24, 45, 7, 13, 16, 32, 32, 11, 11, 18, 22, 37, 40, 34, 50, 76, 66, 24, 49, 66, 100, 133, 12, 18, 20, 27, 45, 56, 70, 80, 136, 16, 26, 32, 45, 54, 65, 30, 50, 40, 62, 60, 50, 66, 86, 74, 93, 110, 143, 105, 214, 277, 370, 510, 214, 326, 510, 8, 12, 17, 21, 24, 34, 42, 46, 51, 116, 100, 140, 212, 25, 30, 41, 25, 50, 50, 30, 32, 38, 60, 109, 6, 11, 22, 33, 58, 130, 75, 113, 188, 173, 248, 405, 70, 114, 208, 307, 397, 915, 1150, 12, 14, 18, 21, 42, 46, 52, 67, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      45), estperf = c(199, 253, 253, 253, 132, 290, 381, 381, 749, 1238, 23, 24, 70, 117, 15, 64, 23, 29, 22, 124, 35, 39, 40, 45, 28, 21, 28, 22, 28, 27, 102, 102, 74, 74, 138, 136, 23, 29, 44, 30, 41, 74, 74, 74, 54, 41, 18, 28, 36, 38, 34, 19, 72, 36, 30, 56, 42, 34, 34, 34, 34, 34, 19, 75, 113, 157, 18, 20, 28, 33, 47, 54, 20, 23, 25, 52, 27, 50, 18, 53, 23, 30, 73, 20, 25, 28, 29, 32, 175, 57, 181, 181, 32, 82, 171, 361, 350, 220, 113, 15, 21, 35, 18, 20, 20, 28, 45, 18, 17, 26, 28, 28, 31, 31, 42, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       76, 76, 26, 59, 65, 101, 116, 18, 20, 20, 30, 44, 44, 82, 82, 128, 37, 46, 46, 80, 88, 88, 33, 46, 29, 53, 53, 41, 86, 95, 107, 117, 119, 120, 48, 126, 266, 270, 426, 151, 267, 603, 19, 21, 26, 35, 41, 47, 62, 78, 80, 80, 142, 281, 190, 21, 25, 67, 24, 24, 64, 25, 20, 29, 43, 53, 19, 22, 31, 41, 47, 99, 67, 81, 149, 183, 275, 382, 56, 182, 227, 341, 360, 919, 978, 24, 24, 24, 24, 37, 50, 41, 47, 25)))
package:MASS
TRUE
FALSE
crabs
list(`package:MASS` = list(sp = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), sex = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                               2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), index = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
                                                                                                                                                                                                                                                                                                                                                                                                                                          18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 
                                                                                                                                                                                                                                                                                                                                                                                                                                          48, 49, 50), FL = c(8.1, 8.8, 9.2, 9.6, 9.8, 10.8, 11.1, 11.6, 11.8, 11.8, 12.2, 12.3, 12.6, 12.8, 12.8, 12.9, 13.1, 13.1, 13.3, 13.9, 14.3, 14.6, 15, 15, 15, 15.2, 15.4, 15.7, 15.9, 16.1, 16.1, 16.2, 16.3, 16.4, 16.6, 16.8, 16.9, 17.1, 17.1, 17.2, 17.7, 17.9, 18, 18.8, 19.3, 19.3, 19.7, 19.8, 19.8, 21.3, 7.2, 9, 9.1, 9.1, 9.5, 9.8, 10.1, 10.3, 10.4, 10.8, 11, 11.2, 11.5, 11.6, 11.6, 11.7, 11.9, 12, 12, 12.6, 12.8, 12.8, 12.8, 13, 13.1, 13.2, 13.4, 13.7, 13.9, 14.7, 14.9, 15, 15, 15.1, 15.1, 15.1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              15.2, 15.3, 15.4, 15.5, 15.6, 15.6, 15.7, 15.8, 16.2, 16.4, 16.7, 17.4, 17.5, 19.2, 9.1, 10.2, 10.7, 11.4, 12.5, 12.5, 12.7, 13.2, 13.4, 13.7, 14, 14.1, 14.1, 14.1, 14.2, 14.2, 14.2, 14.6, 14.7, 15.1, 15.1, 15.4, 15.7, 16.2, 16.3, 17.1, 17.4, 17.5, 17.5, 17.8, 17.9, 18, 18.2, 18.4, 18.6, 18.6, 18.8, 18.8, 19.4, 19.4, 20.1, 20.6, 21, 21.5, 21.6, 21.6, 21.9, 22.1, 23, 23.1, 10.7, 11.4, 12.5, 12.6, 12.9, 14, 14, 14.3, 14.7, 14.9, 15, 15.6, 15.6, 15.6, 15.7, 16.1, 16.1, 16.2, 16.7, 17.1, 17.5, 17.5, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              17.5, 17.6, 18, 18, 18.3, 18.4, 18.4, 18.5, 18.6, 18.8, 18.9, 19.1, 19.1, 19.7, 19.9, 19.9, 20, 20.1, 20.3, 20.5, 20.6, 20.9, 21.3, 21.4, 21.7, 21.9, 22.5, 23.1), RW = c(6.7, 7.7, 7.8, 7.9, 8, 9, 9.9, 9.1, 9.6, 10.5, 10.8, 11, 10, 10.2, 10.9, 11, 10.6, 10.9, 11.1, 11.1, 11.6, 11.3, 10.9, 11.5, 11.9, 12.1, 11.8, 12.6, 12.7, 11.6, 12.8, 13.3, 12.7, 13, 13.5, 12.8, 13.2, 12.6, 12.7, 13.5, 13.6, 14.1, 13.7, 15.8, 13.5, 13.8, 15.3, 14.2, 14.3, 15.7, 6.5, 8.5, 8.1, 8.2, 8.2, 8.9, 9.3, 9.5, 9.7, 9.5, 9.8, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        10, 11, 11, 11.4, 10.6, 11.4, 10.7, 11.1, 12.2, 11.7, 12.2, 12.2, 11.4, 11.5, 12.2, 11.8, 12.5, 13, 12.5, 13.2, 13.8, 14.2, 13.3, 13.5, 13.8, 14.3, 14.2, 13.3, 13.8, 13.9, 14.7, 13.9, 15, 15.2, 14, 16.1, 16.9, 16.7, 16.5, 6.9, 8.2, 8.6, 9, 9.4, 9.4, 10.4, 11, 10.1, 11, 11.5, 10.4, 10.5, 10.7, 10.6, 10.7, 11.3, 11.3, 11.1, 11.4, 11.5, 11.1, 12.2, 11.8, 11.6, 12.6, 12.8, 12, 12.7, 12.5, 12.9, 13.4, 13.7, 13.4, 13.4, 13.5, 13.4, 13.8, 14.1, 14.4, 13.7, 14.4, 15, 15.5, 15.4, 14.8, 15.7, 15.8, 16.8, 15.7, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        9.7, 9.2, 10, 11.5, 11.2, 11.9, 12.8, 12.2, 13.2, 13, 12.3, 13.5, 14, 14.1, 13.6, 13.6, 13.7, 14, 14.3, 14.5, 14.3, 14.4, 14.7, 14, 14.9, 16.3, 15.7, 15.5, 15.7, 14.6, 14.5, 15.2, 16.7, 16, 16.3, 16.7, 16.6, 17.9, 16.7, 17.2, 16, 17.5, 17.5, 16.5, 18.4, 18, 17.1, 17.2, 17.2, 20.2), CL = c(16.1, 18.1, 19, 20.1, 20.3, 23, 23.8, 24.5, 24.2, 25.2, 27.3, 26.8, 27.7, 27.2, 27.4, 26.8, 28.2, 28.3, 27.8, 29.2, 31.3, 31.9, 31.4, 32.4, 32.5, 32.3, 33, 35.8, 34, 33.8, 34.9, 36, 35.6, 35.7, 38.1, 36.2, 37.3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          36.4, 36.7, 37.6, 38.7, 39.7, 39.2, 42.1, 41.6, 40.9, 41.9, 43.2, 42.4, 47.1, 14.7, 19.3, 18.5, 19.2, 19.6, 20.4, 20.9, 21.3, 21.7, 22.5, 22.5, 22.8, 24.7, 24.6, 23.7, 24.9, 26, 24.6, 25.4, 26.1, 27.1, 26.7, 27.9, 27.3, 27.6, 27.9, 28.4, 28.6, 30, 30.1, 30.1, 31.7, 32.8, 31.8, 31.9, 31.7, 33.9, 32.6, 32.4, 33.4, 32.8, 33.9, 33.6, 34.5, 34.5, 34.2, 36.6, 38.2, 38.6, 40.9, 16.7, 20.2, 20.7, 22.7, 23.2, 24.2, 26, 27.1, 26.6, 27.5, 29.2, 28.9, 29.1, 28.7, 28.7, 27.8, 29.2, 29.9, 29, 30.2, 30.9, 30.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          31.7, 32.3, 31.6, 35, 36.1, 34.4, 34.6, 36, 36.9, 36.7, 38.8, 37.9, 37.8, 36.9, 37.2, 39.2, 39.1, 39.8, 40.6, 42.8, 42.9, 45.5, 45.7, 43.4, 45.4, 44.6, 47.2, 47.6, 21.4, 21.7, 24.1, 25, 25.8, 27, 28.8, 28.1, 29.6, 30, 30.1, 31.2, 31.6, 31, 31, 31.6, 31.4, 31.6, 32.3, 33.1, 34.5, 34.5, 33.3, 34, 34.7, 37.9, 35.1, 35.6, 36.5, 37, 34.7, 35.8, 36.3, 37.8, 37.9, 39.9, 39.4, 40.1, 40.4, 39.8, 39.4, 40, 41.5, 39.9, 43.8, 41.2, 41.7, 42.6, 43, 46.2), CW = c(19, 20.8, 22.4, 23.1, 23, 26.5, 27.1, 28.4, 27.8, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                29.3, 31.6, 31.5, 31.7, 31.8, 31.5, 30.9, 32.3, 32.4, 32.3, 33.3, 35.5, 36.4, 36.4, 37, 37.2, 36.7, 37.5, 40.3, 38.9, 39, 40.7, 41.7, 40.9, 41.8, 43.4, 41.8, 42.7, 42, 41.9, 43.9, 44.5, 44.6, 44.4, 49, 47.4, 46.5, 48.5, 49.7, 48.9, 54.6, 17.1, 22.7, 21.6, 22.2, 22.4, 23.9, 24.4, 24.7, 25.4, 26.3, 25.7, 26.9, 29.2, 28.5, 27.7, 28.5, 30.1, 28.9, 29.2, 31.6, 31.2, 31.1, 31.9, 31.8, 32.6, 32.1, 32.7, 33.8, 34.9, 34.7, 35.6, 36.9, 37.4, 36.3, 37, 36.6, 38.5, 38.3, 37.6, 38.7, 37.9, 39.5, 38.5, 40.3, 40.1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                39.8, 41.9, 44.1, 44.5, 47.9, 18.6, 22.2, 22.7, 24.8, 26, 27, 28.8, 30.4, 29.6, 30.5, 32.2, 31.8, 31.6, 31.9, 31.7, 30.9, 32.2, 33.5, 32.1, 33.3, 34, 33.6, 34.2, 35.3, 34.2, 38.9, 39.5, 37.3, 38.4, 39.8, 40.9, 41.3, 42.7, 42.2, 41.9, 40.2, 41.1, 43.3, 43.2, 44.3, 44.5, 46.5, 47.2, 49.7, 49.7, 48.2, 51, 49.6, 52.1, 52.8, 24, 24.1, 27, 28.1, 29.1, 31.4, 32.4, 31.8, 33.4, 33.7, 33.3, 35.1, 35.3, 34.5, 34.8, 36, 36.1, 35.6, 37, 37.2, 39.6, 39, 37.6, 38.6, 39.5, 43, 40.5, 40, 41.6, 42, 39.4, 40.5, 41.7, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                42.3, 42.6, 43.6, 43.9, 46.4, 45.1, 44.1, 44.1, 45.5, 46.2, 44.7, 48.4, 46.2, 47.2, 47.4, 48.7, 52.5), BD = c(7, 7.4, 7.7, 8.2, 8.2, 9.8, 9.8, 10.4, 9.7, 10.3, 10.9, 11.4, 11.4, 10.9, 11, 11.4, 11, 11.2, 11.3, 12.1, 12.7, 13.7, 13.2, 13.4, 13.6, 13.6, 13.6, 14.5, 14.2, 14.4, 15.7, 15.4, 14.9, 15.2, 14.9, 14.9, 15.6, 15.1, 15.6, 16.1, 16, 16.8, 16.2, 17.8, 17.8, 16.8, 17.8, 18.6, 18.3, 20, 6.1, 7.7, 7.7, 7.7, 7.8, 8.8, 8.4, 8.9, 8.3, 9.1, 8.2, 9.4, 10.1, 10.4, 10, 10.4, 10.9, 10.5, 11, 11.2, 11.9, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              11.1, 11.5, 11.3, 11.1, 11.5, 11.7, 11.9, 13.1, 12.5, 12, 14, 14, 13.5, 13.8, 13, 14.7, 13.8, 13.8, 14.7, 13.4, 14.3, 14.1, 15.3, 13.9, 15.2, 15.4, 16.6, 17, 18.1, 7.4, 9, 9.2, 10.1, 10.8, 11.2, 12.1, 12.2, 12, 12.2, 13.1, 13.5, 13.1, 13.3, 12.9, 12.7, 13.5, 12.8, 13.1, 14, 13.9, 13.5, 14.2, 14.7, 14.5, 15.7, 16.2, 15.3, 16.1, 16.7, 16.5, 17.1, 17.2, 17.7, 17.3, 17, 17.5, 17.9, 17.8, 17.9, 18, 19.6, 19.4, 20.9, 20.6, 20.1, 21.1, 20.5, 21.5, 21.6, 9.8, 9.7, 10.9, 11.5, 11.9, 12.6, 12.7, 12.5, 12.9, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              13.3, 14, 14.1, 13.8, 13.8, 13.8, 14, 13.9, 13.7, 14.7, 14.6, 15.6, 16, 14.6, 15.5, 15.7, 17.2, 16.1, 15.9, 16.4, 16.6, 15, 16.6, 15.3, 16.8, 17.2, 18.2, 17.9, 17.9, 17.7, 18.6, 18, 19.2, 19.2, 17.5, 20, 18.7, 19.6, 19.5, 19.8, 21.1)))
package:MASS
TRUE
FALSE
Cushings
list(`package:MASS` = list(Tetrahydrocortisone = c(3.1, 3, 1.9, 3.8, 4.1, 1.9, 8.3, 3.8, 3.9, 7.8, 9.1, 15.4, 7.7, 6.5, 5.7, 13.6, 10.2, 9.2, 9.6, 53.8, 15.8, 5.1, 12.9, 13, 2.6, 30, 20.5), Pregnanetriol = c(11.7, 1.3, 0.1, 0.04, 1.1, 0.4, 1, 0.2, 0.6, 1.2, 0.6, 3.6, 1.6, 0.4, 0.4, 1.6, 6.4, 7.9, 3.1, 2.5, 7.6, 0.4, 5, 0.8, 0.1, 0.1, 0.8), Type = c(1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4)))
package:MASS
TRUE
FALSE
DDT
list(`package:MASS` = c(2.79, 2.93, 3.22, 3.78, 3.22, 3.38, 3.18, 3.33, 3.34, 3.06, 3.07, 3.56, 3.08, 4.64, 3.34))
package:MASS
TRUE
FALSE
deaths
list(`package:MASS` = c(3035, 2552, 2704, 2554, 2014, 1655, 1721, 1524, 1596, 2074, 2199, 2512, 2933, 2889, 2938, 2497, 1870, 1726, 1607, 1545, 1396, 1787, 2076, 2837, 2787, 3891, 3179, 2011, 1636, 1580, 1489, 1300, 1356, 1653, 2013, 2823, 3102, 2294, 2385, 2444, 1748, 1554, 1498, 1361, 1346, 1564, 1640, 2293, 2815, 3137, 2679, 1969, 1870, 1633, 1529, 1366, 1357, 1570, 1535, 2491, 3084, 2605, 2573, 2143, 1693, 1504, 1461, 1354, 1333, 1492, 1781, 1915))
package:MASS
TRUE
FALSE
denumerate
list(`package:MASS` = function (x) 
  UseMethod("denumerate"), function (x) 
    UseMethod("denumerate"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
dose.p
list(`package:MASS` = function (obj, cf = 1:2, p = 0.5) 
{
  eta <- family(obj)$linkfun(p)
  b <- coef(obj)[cf]
  x.p <- (eta - b[1])/b[2]
  names(x.p) <- paste("p = ", format(p), ":", sep = "")
  pd <- -cbind(1, x.p)/b[2]
  SE <- sqrt(((pd %*% vcov(obj)[cf, cf]) * pd) %*% c(1, 1))
  res <- structure(x.p, SE = SE, p = p)
  class(res) <- "glm.dose"
  res
}, function (obj, cf = 1:2, p = 0.5) 
{
  eta <- family(obj)$linkfun(p)
  b <- coef(obj)[cf]
  x.p <- (eta - b[1])/b[2]
  names(x.p) <- paste("p = ", format(p), ":", sep = "")
  pd <- -cbind(1, x.p)/b[2]
  SE <- sqrt(((pd %*% vcov(obj)[cf, cf]) * pd) %*% c(1, 1))
  res <- structure(x.p, SE = SE, p = p)
  class(res) <- "glm.dose"
  res
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
drivers
list(`package:MASS` = c(1687, 1508, 1507, 1385, 1632, 1511, 1559, 1630, 1579, 1653, 2152, 2148, 1752, 1765, 1717, 1558, 1575, 1520, 1805, 1800, 1719, 2008, 2242, 2478, 2030, 1655, 1693, 1623, 1805, 1746, 1795, 1926, 1619, 1992, 2233, 2192, 2080, 1768, 1835, 1569, 1976, 1853, 1965, 1689, 1778, 1976, 2397, 2654, 2097, 1963, 1677, 1941, 2003, 1813, 2012, 1912, 2084, 2080, 2118, 2150, 1608, 1503, 1548, 1382, 1731, 1798, 1779, 1887, 2004, 2077, 2092, 2051, 1577, 1356, 1652, 1382, 1519, 1421, 1442, 1543, 
                        1656, 1561, 1905, 2199, 1473, 1655, 1407, 1395, 1530, 1309, 1526, 1327, 1627, 1748, 1958, 2274, 1648, 1401, 1411, 1403, 1394, 1520, 1528, 1643, 1515, 1685, 2000, 2215, 1956, 1462, 1563, 1459, 1446, 1622, 1657, 1638, 1643, 1683, 2050, 2262, 1813, 1445, 1762, 1461, 1556, 1431, 1427, 1554, 1645, 1653, 2016, 2207, 1665, 1361, 1506, 1360, 1453, 1522, 1460, 1552, 1548, 1827, 1737, 1941, 1474, 1458, 1542, 1404, 1522, 1385, 1641, 1510, 1681, 1938, 1868, 1726, 1456, 1445, 1456, 1365, 1487, 1558, 1488, 1684, 
                        1594, 1850, 1998, 2079, 1494, 1057, 1218, 1168, 1236, 1076, 1174, 1139, 1427, 1487, 1483, 1513, 1357, 1165, 1282, 1110, 1297, 1185, 1222, 1284, 1444, 1575, 1737, 1763))
package:MASS
TRUE
FALSE
dropterm
list(`package:MASS` = function (object, ...) 
  UseMethod("dropterm"), function (object, ...) 
    UseMethod("dropterm"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
eagles
list(`package:MASS` = list(y = c(17, 29, 17, 20, 1, 15, 0, 1), n = c(24, 29, 27, 20, 12, 16, 28, 4), P = c(1, 1, 1, 1, 2, 2, 2, 2), A = c(1, 1, 2, 2, 1, 1, 2, 2), V = c(1, 2, 1, 2, 1, 2, 1, 2)))
package:MASS
TRUE
FALSE
enlist
list(`package:MASS` = function (vec) 
{
  x <- as.list(vec)
  names(x) <- names(vec)
  x
}, function (vec) 
{
  x <- as.list(vec)
  names(x) <- names(vec)
  x
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
epil
list(`package:MASS` = list(y = c(5, 3, 3, 3, 3, 5, 3, 3, 2, 4, 0, 5, 4, 4, 1, 4, 7, 18, 9, 21, 5, 2, 8, 7, 6, 4, 0, 2, 40, 20, 21, 12, 5, 6, 6, 5, 14, 13, 6, 0, 26, 12, 6, 22, 12, 6, 8, 4, 4, 4, 6, 2, 7, 9, 12, 14, 16, 24, 10, 9, 11, 0, 0, 5, 0, 0, 3, 3, 37, 29, 28, 29, 3, 5, 2, 5, 3, 0, 6, 7, 3, 4, 3, 4, 3, 4, 3, 4, 2, 3, 3, 5, 8, 12, 2, 8, 18, 24, 76, 25, 2, 1, 2, 1, 3, 1, 4, 2, 13, 15, 13, 12, 11, 14, 9, 8, 8, 7, 9, 4, 0, 4, 3, 0, 3, 6, 1, 3, 2, 6, 7, 4, 4, 3, 1, 3, 22, 17, 19, 16, 5, 4, 7, 4, 
                                 2, 4, 0, 4, 3, 7, 7, 7, 4, 18, 2, 5, 2, 1, 1, 0, 0, 2, 4, 0, 5, 4, 0, 3, 11, 14, 25, 15, 10, 5, 3, 8, 19, 7, 6, 7, 1, 1, 2, 3, 6, 10, 8, 8, 2, 1, 0, 0, 102, 65, 72, 63, 4, 3, 2, 4, 8, 6, 5, 7, 1, 3, 1, 5, 18, 11, 28, 13, 6, 3, 4, 0, 3, 5, 4, 3, 1, 23, 19, 8, 2, 3, 0, 1, 0, 0, 0, 0, 1, 4, 3, 2), trt = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                 2, 2, 2), base = c(11, 11, 11, 11, 11, 11, 11, 11, 6, 6, 6, 6, 8, 8, 8, 8, 66, 66, 66, 66, 27, 27, 27, 27, 12, 12, 12, 12, 52, 52, 52, 52, 23, 23, 23, 23, 10, 10, 10, 10, 52, 52, 52, 52, 33, 33, 33, 33, 18, 18, 18, 18, 42, 42, 42, 42, 87, 87, 87, 87, 50, 50, 50, 50, 18, 18, 18, 18, 111, 111, 111, 111, 18, 18, 18, 18, 20, 20, 20, 20, 12, 12, 12, 12, 9, 9, 9, 9, 17, 17, 17, 17, 28, 28, 28, 28, 55, 55, 55, 55, 9, 9, 9, 9, 10, 10, 10, 10, 47, 47, 47, 47, 76, 76, 76, 76, 38, 38, 38, 38, 19, 19, 19, 19, 
                                                                                                                                                                                                                                                                                                                                                                    10, 10, 10, 10, 19, 19, 19, 19, 24, 24, 24, 24, 31, 31, 31, 31, 14, 14, 14, 14, 11, 11, 11, 11, 67, 67, 67, 67, 41, 41, 41, 41, 7, 7, 7, 7, 22, 22, 22, 22, 13, 13, 13, 13, 46, 46, 46, 46, 36, 36, 36, 36, 38, 38, 38, 38, 7, 7, 7, 7, 36, 36, 36, 36, 11, 11, 11, 11, 151, 151, 151, 151, 22, 22, 22, 22, 41, 41, 41, 41, 32, 32, 32, 32, 56, 56, 56, 56, 24, 24, 24, 24, 16, 16, 16, 16, 22, 22, 22, 22, 25, 25, 25, 25, 13, 13, 13, 13, 12, 12, 12, 12), age = c(31, 31, 31, 31, 30, 30, 30, 30, 25, 25, 25, 25, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         36, 36, 36, 36, 22, 22, 22, 22, 29, 29, 29, 29, 31, 31, 31, 31, 42, 42, 42, 42, 37, 37, 37, 37, 28, 28, 28, 28, 36, 36, 36, 36, 24, 24, 24, 24, 23, 23, 23, 23, 36, 36, 36, 36, 26, 26, 26, 26, 26, 26, 26, 26, 28, 28, 28, 28, 31, 31, 31, 31, 32, 32, 32, 32, 21, 21, 21, 21, 29, 29, 29, 29, 21, 21, 21, 21, 32, 32, 32, 32, 25, 25, 25, 25, 30, 30, 30, 30, 40, 40, 40, 40, 19, 19, 19, 19, 22, 22, 22, 22, 18, 18, 18, 18, 32, 32, 32, 32, 20, 20, 20, 20, 30, 30, 30, 30, 18, 18, 18, 18, 24, 24, 24, 24, 30, 30, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         30, 30, 35, 35, 35, 35, 27, 27, 27, 27, 20, 20, 20, 20, 22, 22, 22, 22, 28, 28, 28, 28, 23, 23, 23, 23, 40, 40, 40, 40, 33, 33, 33, 33, 21, 21, 21, 21, 35, 35, 35, 35, 25, 25, 25, 25, 26, 26, 26, 26, 25, 25, 25, 25, 22, 22, 22, 22, 32, 32, 32, 32, 25, 25, 25, 25, 35, 35, 35, 35, 21, 21, 21, 21, 41, 41, 41, 41, 32, 32, 32, 32, 26, 26, 26, 26, 21, 21, 21, 21, 36, 36, 36, 36, 37, 37, 37, 37), V4 = c(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), subject = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               58, 59, 59, 59, 59), period = c(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4), lbase = c(-0.756353788717556, -0.756353788717556, -0.756353788717556, -0.756353788717556, -0.756353788717556, -0.756353788717556, -0.756353788717556, -0.756353788717556, -1.36248959228787, -1.36248959228787, -1.36248959228787, -1.36248959228787, -1.07480751983609, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -1.07480751983609, -1.07480751983609, -1.07480751983609, 1.0354056805105, 1.0354056805105, 1.0354056805105, 1.0354056805105, 0.141587804488402, 0.141587804488402, 0.141587804488402, 0.141587804488402, -0.669342411727926, -0.669342411727926, -0.669342411727926, -0.669342411727926, 0.796994657065501, 0.796994657065501, 0.796994657065501, 0.796994657065501, -0.018754845586777, -0.018754845586777, -0.018754845586777, -0.018754845586777, -0.851663968521881, -0.851663968521881, -0.851663968521881, -0.851663968521881, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.796994657065501, 0.796994657065501, 0.796994657065501, 0.796994657065501, 0.342258499950553, 0.342258499950553, 0.342258499950553, 0.342258499950553, -0.263877303619762, -0.263877303619762, -0.263877303619762, -0.263877303619762, 0.583420556767442, 0.583420556767442, 0.583420556767442, 0.583420556767442, 1.31165905713866, 1.31165905713866, 1.31165905713866, 1.31165905713866, 0.75777394391222, 0.75777394391222, 0.75777394391222, 0.75777394391222, -0.263877303619762, -0.263877303619762, -0.263877303619762, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -0.263877303619762, 1.55528113979641, 1.55528113979641, 1.55528113979641, 1.55528113979641, -0.263877303619762, -0.263877303619762, -0.263877303619762, -0.263877303619762, -0.158516787961936, -0.158516787961936, -0.158516787961936, -0.158516787961936, -0.669342411727926, -0.669342411727926, -0.669342411727926, -0.669342411727926, -0.957024484179707, -0.957024484179707, -0.957024484179707, -0.957024484179707, -0.321035717459711, -0.321035717459711, -0.321035717459711, -0.321035717459711, 0.177955448659277, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.177955448659277, 0.177955448659277, 0.177955448659277, 0.853084123716544, 0.853084123716544, 0.853084123716544, 0.853084123716544, -0.957024484179707, -0.957024484179707, -0.957024484179707, -0.957024484179707, -0.851663968521881, -0.851663968521881, -0.851663968521881, -0.851663968521881, 0.695898540194132, 0.695898540194132, 0.695898540194132, 0.695898540194132, 1.1764842787704, 1.1764842787704, 1.1764842787704, 1.1764842787704, 0.483337098210459, 0.483337098210459, 0.483337098210459, 0.483337098210459, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -0.209810082349486, -0.209810082349486, -0.209810082349486, -0.209810082349486, -0.851663968521881, -0.851663968521881, -0.851663968521881, -0.851663968521881, -0.209810082349486, -0.209810082349486, -0.209810082349486, -0.209810082349486, 0.0238047688320189, 0.0238047688320189, 0.0238047688320189, 0.0238047688320189, 0.279738142969219, 0.279738142969219, 0.279738142969219, 0.279738142969219, -0.515191731900668, -0.515191731900668, -0.515191731900668, -0.515191731900668, -0.756353788717556, -0.756353788717556, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -0.756353788717556, -0.756353788717556, 1.05044355787504, 1.05044355787504, 1.05044355787504, 1.05044355787504, 0.559323005188381, 0.559323005188381, 0.559323005188381, 0.559323005188381, -1.20833891246061, -1.20833891246061, -1.20833891246061, -1.20833891246061, -0.0632066081576108, -0.0632066081576108, -0.0632066081576108, -0.0632066081576108, -0.58929970405439, -0.58929970405439, -0.58929970405439, -0.58929970405439, 0.674392334973168, 0.674392334973168, 0.674392334973168, 0.674392334973168, 0.429269876940183, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.429269876940183, 0.429269876940183, 0.429269876940183, 0.483337098210459, 0.483337098210459, 0.483337098210459, 0.483337098210459, -1.20833891246061, -1.20833891246061, -1.20833891246061, -1.20833891246061, 0.429269876940183, 0.429269876940183, 0.429269876940183, 0.429269876940183, -0.756353788717556, -0.756353788717556, -0.756353788717556, -0.756353788717556, 1.863030775299, 1.863030775299, 1.863030775299, 1.863030775299, -0.0632066081576108, -0.0632066081576108, -0.0632066081576108, -0.0632066081576108, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.559323005188381, 0.559323005188381, 0.559323005188381, 0.559323005188381, 0.3114868412838, 0.3114868412838, 0.3114868412838, 0.3114868412838, 0.871102629219222, 0.871102629219222, 0.871102629219222, 0.871102629219222, 0.0238047688320189, 0.0238047688320189, 0.0238047688320189, 0.0238047688320189, -0.381660339276146, -0.381660339276146, -0.381660339276146, -0.381660339276146, -0.0632066081576108, -0.0632066081576108, -0.0632066081576108, -0.0632066081576108, 0.0646267633522741, 0.0646267633522741, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.0646267633522741, 0.0646267633522741, -0.58929970405439, -0.58929970405439, -0.58929970405439, -0.58929970405439, -0.669342411727926, -0.669342411727926, -0.669342411727926, -0.669342411727926), lage = c(0.114203695299265, 0.114203695299265, 0.114203695299265, 0.114203695299265, 0.0814138724762743, 0.0814138724762743, 0.0814138724762743, 0.0814138724762743, -0.10090768431768, -0.10090768431768, -0.10090768431768, -0.10090768431768, 0.263735429270229, 0.263735429270229, 0.263735429270229, 0.263735429270229, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -0.228741055827565, -0.228741055827565, -0.228741055827565, -0.228741055827565, 0.047512320800593, 0.047512320800593, 0.047512320800593, 0.047512320800593, 0.114203695299265, 0.114203695299265, 0.114203695299265, 0.114203695299265, 0.417886109097487, 0.417886109097487, 0.417886109097487, 0.417886109097487, 0.291134403458343, 0.291134403458343, 0.291134403458343, 0.291134403458343, 0.0124210009893226, 0.0124210009893226, 0.0124210009893226, 0.0124210009893226, 0.263735429270229, 0.263735429270229, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     0.263735429270229, 0.263735429270229, -0.141729678837935, -0.141729678837935, -0.141729678837935, -0.141729678837935, -0.184289293256731, -0.184289293256731, -0.184289293256731, -0.184289293256731, 0.263735429270229, 0.263735429270229, 0.263735429270229, 0.263735429270229, -0.061686971164399, -0.061686971164399, -0.061686971164399, -0.061686971164399, -0.061686971164399, -0.061686971164399, -0.061686971164399, -0.061686971164399, 0.0124210009893226, 0.0124210009893226, 0.0124210009893226, 0.0124210009893226, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     0.114203695299265, 0.114203695299265, 0.114203695299265, 0.114203695299265, 0.145952393613845, 0.145952393613845, 0.145952393613845, 0.145952393613845, -0.275261071462458, -0.275261071462458, -0.275261071462458, -0.275261071462458, 0.047512320800593, 0.047512320800593, 0.047512320800593, 0.047512320800593, -0.275261071462458, -0.275261071462458, -0.275261071462458, -0.275261071462458, 0.145952393613845, 0.145952393613845, 0.145952393613845, 0.145952393613845, -0.10090768431768, -0.10090768431768, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -0.10090768431768, -0.10090768431768, 0.0814138724762743, 0.0814138724762743, 0.0814138724762743, 0.0814138724762743, 0.369095944928055, 0.369095944928055, 0.369095944928055, 0.369095944928055, -0.375344530019441, -0.375344530019441, -0.375344530019441, -0.375344530019441, -0.228741055827565, -0.228741055827565, -0.228741055827565, -0.228741055827565, -0.429411751289717, -0.429411751289717, -0.429411751289717, -0.429411751289717, 0.145952393613845, 0.145952393613845, 0.145952393613845, 0.145952393613845, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -0.32405123563189, -0.32405123563189, -0.32405123563189, -0.32405123563189, 0.0814138724762743, 0.0814138724762743, 0.0814138724762743, 0.0814138724762743, -0.429411751289717, -0.429411751289717, -0.429411751289717, -0.429411751289717, -0.141729678837935, -0.141729678837935, -0.141729678837935, -0.141729678837935, 0.0814138724762743, 0.0814138724762743, 0.0814138724762743, 0.0814138724762743, 0.235564552303532, 0.235564552303532, 0.235564552303532, 0.235564552303532, -0.023946643181552, -0.023946643181552, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -0.023946643181552, -0.023946643181552, -0.32405123563189, -0.32405123563189, -0.32405123563189, -0.32405123563189, -0.228741055827565, -0.228741055827565, -0.228741055827565, -0.228741055827565, 0.0124210009893226, 0.0124210009893226, 0.0124210009893226, 0.0124210009893226, -0.184289293256731, -0.184289293256731, -0.184289293256731, -0.184289293256731, 0.369095944928055, 0.369095944928055, 0.369095944928055, 0.369095944928055, 0.176724052280599, 0.176724052280599, 0.176724052280599, 0.176724052280599, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -0.275261071462458, -0.275261071462458, -0.275261071462458, -0.275261071462458, 0.235564552303532, 0.235564552303532, 0.235564552303532, 0.235564552303532, -0.10090768431768, -0.10090768431768, -0.10090768431768, -0.10090768431768, -0.061686971164399, -0.061686971164399, -0.061686971164399, -0.061686971164399, -0.10090768431768, -0.10090768431768, -0.10090768431768, -0.10090768431768, -0.228741055827565, -0.228741055827565, -0.228741055827565, -0.228741055827565, 0.145952393613845, 0.145952393613845, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     0.145952393613845, 0.145952393613845, -0.10090768431768, -0.10090768431768, -0.10090768431768, -0.10090768431768, 0.235564552303532, 0.235564552303532, 0.235564552303532, 0.235564552303532, -0.275261071462458, -0.275261071462458, -0.275261071462458, -0.275261071462458, 0.393788557518427, 0.393788557518427, 0.393788557518427, 0.393788557518427, 0.145952393613845, 0.145952393613845, 0.145952393613845, 0.145952393613845, -0.061686971164399, -0.061686971164399, -0.061686971164399, -0.061686971164399, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -0.275261071462458, -0.275261071462458, -0.275261071462458, -0.275261071462458, 0.263735429270229, 0.263735429270229, 0.263735429270229, 0.263735429270229, 0.291134403458343, 0.291134403458343, 0.291134403458343, 0.291134403458343)))
package:MASS
TRUE
FALSE
eqscplot
list(`package:MASS` = function (x, y, ratio = 1, tol = 0.04, uin, ...) 
{
  dots <- list(...)
  nmdots <- names(dots)
  Call <- match.call()
  Call$ratio <- Call$tol <- Call$uin <- NULL
  if (is.matrix(x)) {
    y <- x[, 2]
    x <- x[, 1]
    if (!is.null(dn <- colnames(x))) {
      xlab0 <- dn[1]
      ylab0 <- dn[2]
    }
    else {
      xlab0 <- ""
      ylab0 <- ""
    }
  }
  else if (is.list(x)) {
    y <- x$y
    x <- x$x
    xlab0 <- "x"
    ylab0 <- "y"
  }
  else {
    xlab0 <- deparse(substitute(x))
    ylab0 <- deparse(substitute(y))
  }
  Call$x <- x
  Call$y <- y
  Call$xlab <- if ("xlab" %in% nmdots) 
    dots$xlab
  else xlab0
  Call$ylab <- if ("ylab" %in% nmdots) 
    dots$ylab
  else ylab0
  xlim <- if ("xlim" %in% nmdots) 
    dots$xlim
  else range(x[is.finite(x)])
  ylim <- if ("ylim" %in% nmdots) 
    dots$ylim
  else range(y[is.finite(y)])
  midx <- 0.5 * (xlim[2] + xlim[1])
  xlim <- midx + (1 + tol) * 0.5 * c(-1, 1) * (xlim[2] - xlim[1])
  midy <- 0.5 * (ylim[2] + ylim[1])
  ylim <- midy + (1 + tol) * 0.5 * c(-1, 1) * (ylim[2] - ylim[1])
  oldpin <- par("pin")
  xuin <- oxuin <- oldpin[1]/abs(diff(xlim))
  yuin <- oyuin <- oldpin[2]/abs(diff(ylim))
  if (missing(uin)) {
    if (yuin > xuin * ratio) 
      yuin <- xuin * ratio
    else xuin <- yuin/ratio
  }
  else {
    if (length(uin) == 1) 
      uin <- uin * c(1, ratio)
    if (any(c(xuin, yuin) < uin)) 
      stop("'uin' is too large to fit plot in")
    xuin <- uin[1]
    yuin <- uin[2]
  }
  xlim <- midx + oxuin/xuin * c(-1, 1) * diff(xlim) * 0.5
  ylim <- midy + oyuin/yuin * c(-1, 1) * diff(ylim) * 0.5
  Call$xlim <- xlim
  Call$ylim <- ylim
  Call$xaxs <- Call$yaxs <- "i"
  Call[[1]] <- as.name("plot")
  eval.parent(Call)
}, function (x, y, ratio = 1, tol = 0.04, uin, ...) 
{
  dots <- list(...)
  nmdots <- names(dots)
  Call <- match.call()
  Call$ratio <- Call$tol <- Call$uin <- NULL
  if (is.matrix(x)) {
    y <- x[, 2]
    x <- x[, 1]
    if (!is.null(dn <- colnames(x))) {
      xlab0 <- dn[1]
      ylab0 <- dn[2]
    }
    else {
      xlab0 <- ""
      ylab0 <- ""
    }
  }
  else if (is.list(x)) {
    y <- x$y
    x <- x$x
    xlab0 <- "x"
    ylab0 <- "y"
  }
  else {
    xlab0 <- deparse(substitute(x))
    ylab0 <- deparse(substitute(y))
  }
  Call$x <- x
  Call$y <- y
  Call$xlab <- if ("xlab" %in% nmdots) 
    dots$xlab
  else xlab0
  Call$ylab <- if ("ylab" %in% nmdots) 
    dots$ylab
  else ylab0
  xlim <- if ("xlim" %in% nmdots) 
    dots$xlim
  else range(x[is.finite(x)])
  ylim <- if ("ylim" %in% nmdots) 
    dots$ylim
  else range(y[is.finite(y)])
  midx <- 0.5 * (xlim[2] + xlim[1])
  xlim <- midx + (1 + tol) * 0.5 * c(-1, 1) * (xlim[2] - xlim[1])
  midy <- 0.5 * (ylim[2] + ylim[1])
  ylim <- midy + (1 + tol) * 0.5 * c(-1, 1) * (ylim[2] - ylim[1])
  oldpin <- par("pin")
  xuin <- oxuin <- oldpin[1]/abs(diff(xlim))
  yuin <- oyuin <- oldpin[2]/abs(diff(ylim))
  if (missing(uin)) {
    if (yuin > xuin * ratio) 
      yuin <- xuin * ratio
    else xuin <- yuin/ratio
  }
  else {
    if (length(uin) == 1) 
      uin <- uin * c(1, ratio)
    if (any(c(xuin, yuin) < uin)) 
      stop("'uin' is too large to fit plot in")
    xuin <- uin[1]
    yuin <- uin[2]
  }
  xlim <- midx + oxuin/xuin * c(-1, 1) * diff(xlim) * 0.5
  ylim <- midy + oyuin/yuin * c(-1, 1) * diff(ylim) * 0.5
  Call$xlim <- xlim
  Call$ylim <- ylim
  Call$xaxs <- Call$yaxs <- "i"
  Call[[1]] <- as.name("plot")
  eval.parent(Call)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
farms
list(`package:MASS` = list(Mois = c(1, 1, 2, 2, 1, 1, 1, 4, 3, 2, 1, 3, 4, 4, 4, 4, 2, 1, 4, 4), Manag = c(4, 1, 4, 4, 2, 2, 2, 2, 2, 1, 1, 4, 4, 3, 3, 4, 3, 3, 3, 3), Use = c(2, 2, 2, 2, 1, 2, 3, 3, 1, 1, 3, 2, 2, 3, 2, 3, 1, 1, 1, 1), Manure = c(5, 3, 5, 5, 3, 3, 4, 4, 2, 2, 2, 3, 4, 1, 1, 4, 1, 1, 1, 1)))
package:MASS
TRUE
FALSE
fbeta
list(`package:MASS` = function (x, alpha, beta) 
{
  x^(alpha - 1) * (1 - x)^(beta - 1)
}, function (x, alpha, beta) 
{
  x^(alpha - 1) * (1 - x)^(beta - 1)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
fgl
list(`package:MASS` = list(RI = c(3.00999999999999, -0.3900000000001, -1.81999999999994, -0.339999999999918, -0.579999999999927, -2.03999999999996, -0.569999999999936, -0.440000000000055, 1.18000000000006, -0.450000000000045, -2.29000000000019, -0.369999999999891, -2.11000000000013, -0.519999999999982, -0.369999999999891, -0.3900000000001, -0.159999999999854, 3.96000000000004, 1.1099999999999, -0.650000000000091, -0.5, 1.66000000000008, -0.639999999999873, -0.490000000000009, -0.799999999999955, 
                                  -0.3599999999999, -0.0699999999999363, -0.789999999999964, -0.320000000000164, -0.159999999999854, -0.320000000000164, -0.529999999999973, -0.25, -0.470000000000027, -0.170000000000073, -2.32999999999993, 1.09000000000015, -0.0299999999999727, 4.12999999999988, 4.12999999999988, -0.0699999999999363, -0.450000000000045, -0.210000000000036, 4.09999999999991, -0.1400000000001, 1, 0.690000000000055, 8.67000000000007, 4.23000000000002, 0.980000000000018, 5.20000000000005, 1.25999999999999, 0.0800000000001546, 
                                  0.369999999999891, -0.220000000000027, -0.309999999999945, -5.84999999999991, 0.240000000000009, -0.460000000000036, -0.460000000000036, 1.04999999999995, 1.76999999999998, 3.72000000000003, 4.26999999999998, 3.72000000000003, 2.99000000000001, 3.51999999999998, 3.51999999999998, 3.51999999999998, 5, -2.25999999999999, 0.480000000000018, -2.06999999999994, -1.69000000000005, -2.03999999999996, -2.09999999999991, -1.54999999999995, -1.73000000000002, -1.87000000000012, -2.09999999999991, -2.08000000000015, 
                                  -2.06999999999994, -1.54000000000019, -2.05999999999995, -3.91000000000008, -1.75, -2.30999999999995, -1.54999999999995, -1.81999999999994, -1.60000000000014, 0.410000000000082, -1.95000000000005, -2.12000000000012, -2.09999999999991, -1.71000000000004, 0.599999999999909, 0.410000000000082, -0.569999999999936, -1.1099999999999, 0.110000000000127, -1.45000000000005, -0.699999999999818, 0.200000000000045, 9.25, 6.09999999999991, 6.75, 13.25, 15.9300000000001, 4.2199999999998, 0.180000000000064, 8.6400000000001, 
                                  9.3900000000001, 9.76999999999998, 0.920000000000073, 0.470000000000027, 0.459999999999809, 0.289999999999964, -0.920000000000073, -1.26999999999998, -1.48000000000002, 0.440000000000055, -1.37000000000012, -1.13000000000011, -0.930000000000064, 3.76999999999998, 0.720000000000027, -1.32999999999993, 2.80999999999995, 2.68000000000006, 2.20000000000005, 3.76999999999998, 8.1400000000001, 0.129999999999882, 0, 0.110000000000127, -0.110000000000127, 0.0599999999999454, -0.8900000000001, -1.25999999999999, 
                                  -1.25999999999999, -1.10000000000014, 0.509999999999991, -1.37999999999988, -0.909999999999854, -1.40000000000009, 0.389999999999873, -0.309999999999945, -1.90000000000009, -1.29999999999995, -1.57000000000016, -1.34999999999991, 3.26999999999998, -0.210000000000036, -1.90000000000009, -1.05999999999995, -1.54000000000019, -1.45000000000005, 3.21000000000004, -0.240000000000009, -0.0399999999999636, 0.319999999999936, 1.33999999999992, 4.11000000000013, -2.86000000000013, 1.15000000000009, 3.70999999999981, 
                                  3.50999999999999, 1.69000000000005, -1.34000000000015, 1.94000000000005, 5.69000000000005, -4.83999999999992, -4.78999999999996, 2.42999999999984, 2.58000000000015, 3.19000000000005, 1.04999999999995, 1.37000000000012, 0.289999999999964, 0.519999999999982, -5.00999999999999, 0.880000000000109, 1.16000000000008, 1.69000000000005, -6.84999999999991, -6.69000000000005, 0.380000000000109, 5.15000000000009, 4.47000000000003, 5.64999999999986, -1.87000000000012, -1.98000000000002, -1.76999999999998, -0.809999999999945, 
                                  -1.17000000000007, -2.54999999999995, -2.44000000000005, -0.730000000000018, -2.69000000000005, -1.91000000000008, -2.92000000000007, -1.47000000000003, -2.86000000000013, -1.42000000000007, -1.82999999999993, -0.680000000000064, -1.54999999999995, 0.309999999999945, -1.60000000000014, -1.76999999999998, -1.14999999999986, 2.65000000000009, -1.49000000000001, -0.8900000000001), Na = c(13.64, 13.89, 13.53, 13.21, 13.27, 12.79, 13.3, 13.15, 14.04, 13, 12.72, 12.8, 12.88, 12.86, 12.61, 12.81, 12.68, 
                                                                                                                                                                                                                                                                                                                                                                                                                                      14.36, 13.9, 13.02, 12.82, 14.77, 12.78, 12.81, 13.38, 12.98, 13.21, 12.87, 12.56, 13.08, 12.65, 12.84, 12.85, 12.57, 12.69, 13.29, 13.89, 12.74, 14.21, 14.21, 12.79, 12.71, 13.21, 13.73, 12.73, 13.49, 13.19, 13.99, 13.21, 13.58, 13.72, 13.2, 13.43, 13.14, 13.21, 12.45, 12.99, 12.87, 13.48, 13.39, 13.6, 13.81, 13.51, 14.17, 13.48, 13.69, 13.05, 13.05, 13.12, 13.31, 14.86, 13.64, 13.09, 13.34, 13.02, 13.02, 13.44, 13, 13.92, 12.82, 12.86, 13.25, 13.41, 13.09, 14.25, 13.36, 13.24, 13.4, 13.01, 12.55, 
                                                                                                                                                                                                                                                                                                                                                                                                                                      12.93, 12.9, 13.12, 13.24, 12.71, 13.36, 13.02, 12.2, 12.67, 12.96, 12.75, 12.35, 12.62, 13.8, 13.83, 11.45, 10.73, 12.3, 14.43, 13.72, 11.23, 11.02, 12.64, 13.46, 13.1, 13.41, 13.24, 13.72, 13.3, 13.56, 13.25, 12.93, 13.23, 13.48, 13.2, 12.93, 12.94, 13.78, 13.55, 13.98, 13.75, 13.7, 13.43, 13.71, 13.33, 13.19, 13, 12.89, 12.79, 12.87, 13.33, 13.2, 12.85, 13, 12.99, 12.85, 13.65, 13.33, 13.24, 12.16, 13.14, 14.32, 13.64, 13.42, 12.86, 13.04, 13.41, 14.03, 13.53, 13.5, 13.33, 13.64, 14.19, 14.01, 
                                                                                                                                                                                                                                                                                                                                                                                                                                      12.73, 11.56, 11.03, 12.64, 12.86, 13.27, 13.44, 13.02, 13, 13.38, 12.85, 12.97, 14, 13.79, 14.46, 14.09, 14.4, 14.99, 14.15, 14.56, 17.38, 13.69, 14.32, 13.44, 14.86, 15.79, 13.88, 14.85, 14.2, 14.75, 14.56, 14.14, 13.87, 14.7, 14.38, 15.01, 15.15, 11.95, 14.85, 14.8, 14.95, 14.95, 14.94, 14.39, 14.37, 14.14, 14.92, 14.36, 14.38, 14.23), Mg = c(4.49, 3.6, 3.55, 3.69, 3.62, 3.61, 3.6, 3.61, 3.58, 3.6, 3.46, 3.66, 3.43, 3.56, 3.59, 3.54, 3.67, 3.85, 3.73, 3.54, 3.55, 3.75, 3.62, 3.57, 3.5, 3.54, 3.48, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  3.48, 3.52, 3.49, 3.56, 3.5, 3.48, 3.47, 3.54, 3.45, 3.53, 3.48, 3.82, 3.82, 3.5, 3.42, 3.39, 3.84, 3.43, 3.48, 3.37, 3.7, 3.77, 3.35, 3.72, 3.33, 2.87, 2.84, 2.81, 2.71, 3.47, 3.48, 3.74, 3.66, 3.62, 3.58, 3.86, 3.81, 3.74, 3.59, 3.65, 3.65, 3.58, 3.58, 3.67, 3.87, 3.59, 3.57, 3.56, 3.58, 3.61, 3.58, 3.52, 3.52, 3.52, 3.45, 3.55, 3.52, 3.09, 3.58, 3.49, 3.49, 3.5, 3.48, 3.74, 3.44, 3.41, 3.34, 3.33, 3.43, 3.62, 3.25, 2.88, 2.96, 2.85, 2.72, 2.76, 3.15, 2.9, 0, 0, 0, 0, 0, 0, 0, 0, 3.83, 3.97, 3.89, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  3.9, 3.68, 3.64, 3.57, 3.76, 3.54, 3.54, 3.48, 3.68, 3.66, 3.61, 2.28, 2.09, 1.35, 1.01, 0, 3.98, 3.93, 3.85, 3.9, 3.8, 3.62, 3.52, 3.56, 3.54, 3.63, 3.51, 3.47, 3.18, 3.67, 3.66, 3.53, 3.57, 3.52, 3.45, 3.9, 3.65, 3.4, 3.58, 3.4, 3.39, 3.76, 3.41, 3.36, 3.34, 3.54, 3.78, 2.68, 1.85, 1.88, 1.71, 0, 0, 0, 0, 0, 0, 0, 1.61, 0.33, 2.39, 2.41, 2.24, 2.19, 1.74, 0.78, 0, 0, 0, 3.2, 3.26, 3.34, 2.2, 1.83, 1.78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), Al = c(1.1, 1.36, 1.54, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1.29, 1.24, 1.62, 1.14, 1.05, 1.37, 1.36, 1.56, 1.27, 1.4, 1.27, 1.31, 1.23, 1.16, 0.89, 1.18, 1.69, 1.49, 0.29, 1.29, 1.35, 1.15, 1.21, 1.41, 1.33, 1.43, 1.28, 1.3, 1.14, 1.23, 1.38, 1.34, 1.21, 1.32, 1.35, 0.47, 0.47, 1.12, 1.2, 1.33, 0.72, 1.19, 1.35, 1.18, 0.71, 0.79, 1.23, 0.51, 1.28, 1.19, 1.28, 1.29, 1.29, 1.12, 1.29, 1.17, 1.19, 1.11, 1.32, 0.88, 0.78, 0.9, 1.12, 0.87, 0.87, 0.9, 0.82, 1.74, 1.27, 1.52, 1.57, 1.54, 1.51, 1.54, 1.54, 1.25, 1.9, 2.12, 1.43, 1.25, 1.55, 2.08, 1.49, 1.47, 1.52, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1.48, 1.87, 1.11, 1.45, 1.58, 1.47, 1.49, 1.43, 1.06, 1.16, 1.71, 1.43, 1.44, 1.63, 0.83, 0.66, 1.17, 1.88, 2.1, 1, 1, 0.56, 0.77, 0.75, 0.67, 1.26, 1.19, 1.33, 1.41, 1.81, 1.53, 1.47, 1.32, 1.62, 1.48, 1.71, 1.15, 1.56, 1.26, 1.43, 1.67, 1.63, 1.36, 1.36, 1.18, 1.54, 1.25, 1.3, 1.08, 1.57, 1.54, 1.64, 1.61, 1.07, 1.44, 1.79, 1.23, 1.24, 1.11, 1.34, 1.38, 1.35, 1.76, 0.83, 0.65, 1.22, 1.31, 1.26, 1.28, 0.58, 1.52, 1.63, 1.54, 0.75, 0.91, 3.5, 1.86, 1.56, 1.56, 1.65, 1.83, 1.76, 1.58, 3.04, 3.02, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1.4, 2.17, 1.51, 1.56, 1.19, 1.62, 1.66, 1.54, 1.74, 2.09, 0.56, 0.34, 1.81, 2.22, 1.23, 2.06, 1.31, 1.79, 2.38, 2.79, 2, 1.98, 2.68, 2.54, 2.34, 2.66, 2.51, 2.25, 1.19, 2.42, 1.99, 2.27, 1.8, 1.87, 1.82, 2.74, 2.88, 1.99, 2.02, 1.94, 2.08), Si = c(71.78, 72.73, 72.99, 72.61, 73.08, 72.97, 73.09, 73.24, 72.08, 72.99, 73.2, 73.01, 73.28, 73.21, 73.29, 73.24, 73.11, 71.36, 72.12, 72.73, 72.75, 72.02, 72.79, 73.02, 72.85, 73, 72.64, 73.04, 73.15, 72.86, 73.08, 73.27, 72.97, 73.39, 72.95, 72.74, 71.81, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 72.96, 71.77, 71.77, 73.03, 73.2, 72.76, 71.76, 72.95, 71.95, 72.72, 71.57, 71.99, 72.08, 71.75, 72.36, 72.84, 72.85, 72.98, 73.7, 72.98, 72.95, 72.99, 72.79, 72.64, 71.72, 71.79, 71.35, 72.01, 71.96, 72.22, 72.32, 72.2, 71.99, 71.87, 71.96, 73.1, 72.87, 73.11, 73.12, 72.39, 72.83, 72.88, 72.86, 72.66, 73.17, 72.81, 72.87, 72.28, 72.72, 73.25, 72.65, 72.89, 73.23, 72.28, 73.06, 73.26, 73.1, 73.28, 72.26, 72.34, 73.55, 73.21, 72.92, 73.27, 72.87, 73.81, 70.57, 71.15, 72.19, 69.81, 70.16, 72.67, 74.45, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 73.21, 73.08, 72.02, 72.55, 72.44, 72.38, 72.33, 72.06, 72.53, 72.45, 72.4, 72.96, 72.84, 72.52, 72.75, 72.51, 72.75, 71.99, 72.18, 71.76, 72.19, 71.24, 72.49, 71.81, 72.78, 72.33, 73.07, 72.96, 73.36, 73.14, 72.54, 72.83, 73.01, 72.72, 72.97, 72.57, 72.77, 72.67, 72.7, 72.89, 72.48, 71.5, 73, 72.69, 72.61, 73.01, 72.64, 71.79, 72.04, 71.94, 72.14, 72.65, 71.36, 69.89, 72.69, 72.86, 73.44, 73.75, 73.88, 73.03, 72.22, 70.48, 70.7, 72.25, 72.18, 73.39, 72.37, 72.76, 72.38, 72.67, 74.55, 72.5, 72.74, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 73.48, 75.41, 72.81, 71.25, 72.38, 70.26, 70.43, 73.1, 73.28, 73.46, 73.02, 73.29, 73.39, 73.23, 73.28, 73.1, 73.05, 73.5, 75.18, 73.72, 73.11, 73.3, 72.99, 73.11, 72.86, 72.85, 72.61, 73.06, 73.42, 73.61, 73.36), K = c(0.06, 0.48, 0.39, 0.57, 0.55, 0.64, 0.58, 0.57, 0.56, 0.57, 0.67, 0.6, 0.69, 0.54, 0.58, 0.58, 0.61, 0.15, 0.06, 0.54, 0.54, 0.03, 0.59, 0.62, 0.5, 0.65, 0.59, 0.56, 0.57, 0.6, 0.61, 0.56, 0.61, 0.6, 0.57, 0.56, 0.51, 0.64, 0.11, 0.11, 0.64, 0.59, 0.59, 0.17, 0.62, 0.55, 0.57, 0.02, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             0.13, 0.59, 0.09, 0.6, 0.55, 0.55, 0.51, 0.56, 0.62, 0.6, 0.59, 0.57, 0.14, 0.12, 0.23, 0, 0.18, 0.09, 0.19, 0.19, 0.23, 0.12, 0.16, 0.54, 0.67, 0.61, 0.72, 0.69, 0.66, 0.61, 0.37, 0.69, 0.69, 0.61, 0.68, 0.68, 1.1, 0.45, 0.38, 0.67, 0.6, 0.63, 0.64, 0.44, 0.07, 0.39, 0.67, 0.51, 0.64, 0.62, 0.73, 0.6, 0.57, 0.7, 0.35, 0.08, 0.08, 0.81, 0.58, 0.12, 0.1, 0, 0, 0, 0.06, 0.57, 0.6, 0.51, 0.55, 0.64, 0.65, 0.64, 0.58, 0.64, 0.56, 0.62, 0.54, 0.58, 0.56, 0.49, 0.53, 0.39, 0.33, 0.19, 0.58, 0.54, 0.52, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             0.55, 0.56, 0.61, 0.66, 0.65, 0.68, 0.57, 0.68, 0.66, 0.58, 0.62, 0.11, 0.56, 0.56, 0.57, 0.6, 0, 0.06, 0.59, 0.61, 0.52, 0.52, 0.11, 0.58, 0.57, 0.56, 0.16, 0.23, 1.68, 0.6, 0.47, 0.58, 0.38, 0.97, 0.47, 0.32, 6.21, 6.21, 0.33, 0.76, 0.13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.76, 1.46, 0.6, 0.76, 0.31, 0, 0, 0.04, 0, 0, 0.08, 0.14, 0, 0.04, 0.05, 0, 2.7, 0, 0, 0, 0, 0, 1.41, 0, 0.08, 0, 0, 0, 0), Ca = c(8.75, 7.83, 7.78, 8.22, 8.07, 8.07, 8.17, 8.24, 8.3, 8.4, 8.09, 8.56, 8.05, 8.38, 8.5, 8.39, 8.7, 9.15, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             8.89, 8.44, 8.52, 9, 8.7, 8.59, 8.43, 8.53, 8.43, 8.43, 8.54, 8.49, 8.69, 8.55, 8.56, 8.55, 8.75, 8.57, 8.78, 8.68, 9.57, 9.57, 8.77, 8.64, 8.59, 9.74, 8.76, 9, 8.83, 9.82, 10.02, 8.91, 10.06, 9.14, 9.03, 9.07, 9.02, 9.06, 8.35, 8.43, 8.03, 8.27, 8.76, 8.67, 9.54, 9.69, 9.61, 9.4, 9.85, 9.85, 9.82, 10.17, 7.36, 8.32, 7.83, 7.89, 7.9, 7.96, 8.03, 8.04, 7.94, 7.97, 7.97, 7.86, 8.1, 8.05, 7.08, 8.21, 8.03, 8.08, 8.12, 8.08, 8.96, 8.27, 8.39, 8.22, 8.24, 8.6, 9.13, 8.9, 8.54, 8.79, 8.79, 9.23, 9.42, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             11.64, 10.79, 13.24, 13.3, 16.19, 11.52, 10.99, 14.68, 14.96, 14.4, 8.21, 8.43, 8.28, 8.31, 7.88, 8.03, 7.96, 8.42, 8.03, 8.1, 7.99, 8.52, 8.55, 8.6, 9.85, 9.57, 10.56, 11.14, 13.44, 8.15, 8.21, 8.12, 8.44, 8.38, 8.11, 7.9, 7.99, 8.11, 8.41, 8.23, 8.18, 8.81, 8.68, 8.6, 8.33, 8.44, 8.53, 8.38, 9.49, 8.93, 8.32, 8.79, 8.58, 8.65, 9.65, 8.79, 8.81, 8.99, 8.89, 9.14, 5.87, 10.09, 11.41, 11.62, 11.53, 10.17, 11.32, 12.24, 6.96, 6.93, 12.5, 9.7, 11.27, 9.57, 9.77, 9.26, 9.32, 7.59, 9.95, 10.88, 11.22, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             6.65, 5.43, 5.79, 8.83, 9.76, 8.61, 8.67, 8.76, 9.04, 8.53, 8.52, 9.07, 9.41, 8.95, 9.08, 8.83, 8.34, 8.93, 8.39, 8.28, 8.71, 8.61, 8.67, 6.47, 9.45, 9.18, 8.4, 8.44, 8.48, 8.62), Ba = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.09, 0, 0, 0, 0.11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.14, 0.11, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        0, 0, 0, 0, 0, 3.15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.09, 0.06, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.15, 0, 2.2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.19, 1.63, 0, 0, 1.68, 0.76, 0.64, 0.4, 1.59, 1.57, 0.61, 0.81, 0.66, 0.64, 0.53, 0.63, 0, 0.56, 1.71, 0.67, 1.55, 1.38, 2.88, 0.54, 1.06, 1.59, 1.64, 1.57, 1.67), Fe = c(0, 0, 0, 0, 0, 0.26, 0, 0, 0, 0.11, 0.24, 0, 0.24, 0.17, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    0, 0, 0, 0, 0, 0.07, 0.19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.14, 0, 0.22, 0.06, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.3, 0, 0.16, 0.1, 0, 0, 0.16, 0.11, 0, 0, 0.09, 0.24, 0.31, 0, 0, 0.11, 0, 0, 0.11, 0, 0.07, 0, 0.17, 0.17, 0.16, 0.03, 0.12, 0.32, 0, 0, 0, 0, 0, 0, 0.14, 0, 0, 0, 0, 0.09, 0, 0, 0, 0.1, 0, 0.09, 0.22, 0, 0.19, 0, 0, 0, 0.15, 0.24, 0, 0, 0.22, 0, 0.2, 0, 0, 0.34, 0.28, 0.24, 0.08, 0, 0, 0, 0, 0.14, 0, 0, 0.1, 0, 0.29, 0, 0, 0.21, 0, 0, 0, 0.12, 0, 0.17, 0.17, 0.18, 0, 0.1, 0, 0.15, 0, 0.28, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    0.12, 0, 0, 0, 0, 0.17, 0.25, 0, 0.24, 0.35, 0, 0, 0.1, 0, 0.17, 0, 0, 0, 0, 0, 0, 0, 0, 0.09, 0, 0.24, 0.37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.51, 0.28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.09, 0.09, 0.08, 0.07, 0.05, 0.01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6)))
package:MASS
TRUE
FALSE
fitdistr
list(`package:MASS` = function (x, densfun, start, ...) 
{
  myfn <- function(parm, ...) -sum(log(dens(parm, ...)))
  mylogfn <- function(parm, ...) -sum(dens(parm, ..., log = TRUE))
  mydt <- function(x, m, s, df, log) dt((x - m)/s, df, log = TRUE) - log(s)
  Call <- match.call(expand.dots = TRUE)
  if (missing(start)) 
    start <- NULL
  dots <- names(list(...))
  dots <- dots[!is.element(dots, c("upper", "lower"))]
  if (missing(x) || length(x) == 0 || mode(x) != "numeric") 
    stop("'x' must be a non-empty numeric vector")
  if (any(!is.finite(x))) 
    stop("'x' contains missing or infinite values")
  if (missing(densfun) || !(is.function(densfun) || is.character(densfun))) 
    stop("'densfun' must be supplied as a function or name")
  control <- list()
  n <- length(x)
  if (is.character(densfun)) {
    distname <- tolower(densfun)
    densfun <- switch(distname, beta = dbeta, cauchy = dcauchy, `chi-squared` = dchisq, exponential = dexp, f = df, gamma = dgamma, geometric = dgeom, `log-normal` = dlnorm, lognormal = dlnorm, logistic = dlogis, `negative binomial` = dnbinom, normal = dnorm, poisson = dpois, t = mydt, weibull = dweibull, NULL)
    if (is.null(densfun)) 
      stop("unsupported distribution")
    if (distname %in% c("lognormal", "log-normal")) {
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "log-Normal"), domain = NA)
      if (any(x <= 0)) 
        stop("need positive values to fit a log-Normal")
      lx <- log(x)
      sd0 <- sqrt((n - 1)/n) * sd(lx)
      mx <- mean(lx)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2, dimnames = list(names(sds), names(sds)))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dlnorm(x, mx, sd0, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "normal") {
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "Normal"), domain = NA)
      sd0 <- sqrt((n - 1)/n) * sd(x)
      mx <- mean(x)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("mean", "sd")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2, dimnames = list(names(sds), names(sds)))
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dnorm(x, mx, sd0, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "poisson") {
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "Poisson"), domain = NA)
      estimate <- mean(x)
      sds <- sqrt(estimate/n)
      names(estimate) <- names(sds) <- "lambda"
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("lambda", "lambda"))
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dpois(x, estimate, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "exponential") {
      if (any(x < 0)) 
        stop("Exponential values must be >= 0")
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "exponential"), domain = NA)
      estimate <- 1/mean(x)
      sds <- estimate/sqrt(n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("rate", "rate"))
      names(estimate) <- names(sds) <- "rate"
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dexp(x, estimate, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "geometric") {
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "geometric"), domain = NA)
      estimate <- 1/(1 + mean(x))
      sds <- estimate * sqrt((1 - estimate)/n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("prob", "prob"))
      names(estimate) <- names(sds) <- "prob"
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dgeom(x, estimate, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "weibull" && is.null(start)) {
      if (any(x <= 0)) 
        stop("Weibull values must be > 0")
      lx <- log(x)
      m <- mean(lx)
      v <- var(lx)
      shape <- 1.2/sqrt(v)
      scale <- exp(m + 0.572/shape)
      start <- list(shape = shape, scale = scale)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "gamma" && is.null(start)) {
      if (any(x < 0)) 
        stop("gamma values must be >= 0")
      m <- mean(x)
      v <- var(x)
      start <- list(shape = m^2/v, rate = m/v)
      start <- start[!is.element(names(start), dots)]
      control <- list(parscale = c(1, start$rate))
    }
    if (distname == "negative binomial" && is.null(start)) {
      m <- mean(x)
      v <- var(x)
      size <- if (v > m) 
        m^2/(v - m)
      else 100
      start <- list(size = size, mu = m)
      start <- start[!is.element(names(start), dots)]
    }
    if (is.element(distname, c("cauchy", "logistic")) && is.null(start)) {
      start <- list(location = median(x), scale = IQR(x)/2)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "t" && is.null(start)) {
      start <- list(m = median(x), s = IQR(x)/2, df = 10)
      start <- start[!is.element(names(start), dots)]
    }
  }
  if (is.null(start) || !is.list(start)) 
    stop("'start' must be a named list")
  nm <- names(start)
  f <- formals(densfun)
  args <- names(f)
  m <- match(nm, args)
  if (any(is.na(m))) 
    stop("'start' specifies names which are not arguments to 'densfun'")
  formals(densfun) <- c(f[c(1, m)], f[-c(1, m)])
  dens <- function(parm, x, ...) densfun(x, parm, ...)
  if ((l <- length(nm)) > 1) 
    body(dens) <- parse(text = paste("densfun(x,", paste("parm[", 1:l, "]", collapse = ", "), ", ...)"))
  Call[[1]] <- quote(stats::optim)
  Call$densfun <- Call$start <- NULL
  Call$x <- x
  Call$par <- start
  Call$fn <- if ("log" %in% args) 
    mylogfn
  else myfn
  Call$hessian <- TRUE
  if (length(control)) 
    Call$control <- control
  if (is.null(Call$method)) {
    if (any(c("lower", "upper") %in% names(Call))) 
      Call$method <- "L-BFGS-B"
    else if (length(start) > 1) 
      Call$method <- "BFGS"
    else Call$method <- "Nelder-Mead"
  }
  res <- eval.parent(Call)
  if (res$convergence > 0) 
    stop("optimization failed")
  vc <- solve(res$hessian)
  sds <- sqrt(diag(vc))
  structure(list(estimate = res$par, sd = sds, vcov = vc, loglik = -res$value, n = n), class = "fitdistr")
}, function (x, densfun, start, ...) 
{
  myfn <- function(parm, ...) -sum(log(dens(parm, ...)))
  mylogfn <- function(parm, ...) -sum(dens(parm, ..., log = TRUE))
  mydt <- function(x, m, s, df, log) dt((x - m)/s, df, log = TRUE) - log(s)
  Call <- match.call(expand.dots = TRUE)
  if (missing(start)) 
    start <- NULL
  dots <- names(list(...))
  dots <- dots[!is.element(dots, c("upper", "lower"))]
  if (missing(x) || length(x) == 0 || mode(x) != "numeric") 
    stop("'x' must be a non-empty numeric vector")
  if (any(!is.finite(x))) 
    stop("'x' contains missing or infinite values")
  if (missing(densfun) || !(is.function(densfun) || is.character(densfun))) 
    stop("'densfun' must be supplied as a function or name")
  control <- list()
  n <- length(x)
  if (is.character(densfun)) {
    distname <- tolower(densfun)
    densfun <- switch(distname, beta = dbeta, cauchy = dcauchy, `chi-squared` = dchisq, exponential = dexp, f = df, gamma = dgamma, geometric = dgeom, `log-normal` = dlnorm, lognormal = dlnorm, logistic = dlogis, `negative binomial` = dnbinom, normal = dnorm, poisson = dpois, t = mydt, weibull = dweibull, NULL)
    if (is.null(densfun)) 
      stop("unsupported distribution")
    if (distname %in% c("lognormal", "log-normal")) {
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "log-Normal"), domain = NA)
      if (any(x <= 0)) 
        stop("need positive values to fit a log-Normal")
      lx <- log(x)
      sd0 <- sqrt((n - 1)/n) * sd(lx)
      mx <- mean(lx)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2, dimnames = list(names(sds), names(sds)))
      names(estimate) <- names(sds) <- c("meanlog", "sdlog")
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dlnorm(x, mx, sd0, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "normal") {
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "Normal"), domain = NA)
      sd0 <- sqrt((n - 1)/n) * sd(x)
      mx <- mean(x)
      estimate <- c(mx, sd0)
      sds <- c(sd0/sqrt(n), sd0/sqrt(2 * n))
      names(estimate) <- names(sds) <- c("mean", "sd")
      vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2, dimnames = list(names(sds), names(sds)))
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dnorm(x, mx, sd0, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "poisson") {
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "Poisson"), domain = NA)
      estimate <- mean(x)
      sds <- sqrt(estimate/n)
      names(estimate) <- names(sds) <- "lambda"
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("lambda", "lambda"))
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dpois(x, estimate, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "exponential") {
      if (any(x < 0)) 
        stop("Exponential values must be >= 0")
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "exponential"), domain = NA)
      estimate <- 1/mean(x)
      sds <- estimate/sqrt(n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("rate", "rate"))
      names(estimate) <- names(sds) <- "rate"
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dexp(x, estimate, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "geometric") {
      if (!is.null(start)) 
        stop(gettextf("supplying pars for the %s distribution is not supported", "geometric"), domain = NA)
      estimate <- 1/(1 + mean(x))
      sds <- estimate * sqrt((1 - estimate)/n)
      vc <- matrix(sds^2, ncol = 1, nrow = 1, dimnames = list("prob", "prob"))
      names(estimate) <- names(sds) <- "prob"
      return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n, loglik = sum(dgeom(x, estimate, log = TRUE))), class = "fitdistr"))
    }
    if (distname == "weibull" && is.null(start)) {
      if (any(x <= 0)) 
        stop("Weibull values must be > 0")
      lx <- log(x)
      m <- mean(lx)
      v <- var(lx)
      shape <- 1.2/sqrt(v)
      scale <- exp(m + 0.572/shape)
      start <- list(shape = shape, scale = scale)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "gamma" && is.null(start)) {
      if (any(x < 0)) 
        stop("gamma values must be >= 0")
      m <- mean(x)
      v <- var(x)
      start <- list(shape = m^2/v, rate = m/v)
      start <- start[!is.element(names(start), dots)]
      control <- list(parscale = c(1, start$rate))
    }
    if (distname == "negative binomial" && is.null(start)) {
      m <- mean(x)
      v <- var(x)
      size <- if (v > m) 
        m^2/(v - m)
      else 100
      start <- list(size = size, mu = m)
      start <- start[!is.element(names(start), dots)]
    }
    if (is.element(distname, c("cauchy", "logistic")) && is.null(start)) {
      start <- list(location = median(x), scale = IQR(x)/2)
      start <- start[!is.element(names(start), dots)]
    }
    if (distname == "t" && is.null(start)) {
      start <- list(m = median(x), s = IQR(x)/2, df = 10)
      start <- start[!is.element(names(start), dots)]
    }
  }
  if (is.null(start) || !is.list(start)) 
    stop("'start' must be a named list")
  nm <- names(start)
  f <- formals(densfun)
  args <- names(f)
  m <- match(nm, args)
  if (any(is.na(m))) 
    stop("'start' specifies names which are not arguments to 'densfun'")
  formals(densfun) <- c(f[c(1, m)], f[-c(1, m)])
  dens <- function(parm, x, ...) densfun(x, parm, ...)
  if ((l <- length(nm)) > 1) 
    body(dens) <- parse(text = paste("densfun(x,", paste("parm[", 1:l, "]", collapse = ", "), ", ...)"))
  Call[[1]] <- quote(stats::optim)
  Call$densfun <- Call$start <- NULL
  Call$x <- x
  Call$par <- start
  Call$fn <- if ("log" %in% args) 
    mylogfn
  else myfn
  Call$hessian <- TRUE
  if (length(control)) 
    Call$control <- control
  if (is.null(Call$method)) {
    if (any(c("lower", "upper") %in% names(Call))) 
      Call$method <- "L-BFGS-B"
    else if (length(start) > 1) 
      Call$method <- "BFGS"
    else Call$method <- "Nelder-Mead"
  }
  res <- eval.parent(Call)
  if (res$convergence > 0) 
    stop("optimization failed")
  vc <- solve(res$hessian)
  sds <- sqrt(diag(vc))
  structure(list(estimate = res$par, sd = sds, vcov = vc, loglik = -res$value, n = n), class = "fitdistr")
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
forbes
list(`package:MASS` = list(bp = c(194.5, 194.3, 197.9, 198.4, 199.4, 199.9, 200.9, 201.1, 201.4, 201.3, 203.6, 204.6, 209.5, 208.6, 210.7, 211.9, 212.2), pres = c(20.79, 20.79, 22.4, 22.67, 23.15, 23.35, 23.89, 23.99, 24.02, 24.01, 25.14, 26.57, 28.49, 27.76, 29.04, 29.88, 30.06)))
package:MASS
TRUE
FALSE
fractions
list(`package:MASS` = function (x, cycles = 10, max.denominator = 2000, ...) 
{
  ans <- .rat(x, cycles, max.denominator)
  ndc <- paste(ans$rat[, 1], ans$rat[, 2], sep = "/")
  int <- ans$rat[, 2] == 1
  ndc[int] <- as.character(ans$rat[int, 1])
  structure(ans$x, fracs = ndc, class = c("fractions", class(ans$x)))
}, function (x, cycles = 10, max.denominator = 2000, ...) 
{
  ans <- .rat(x, cycles, max.denominator)
  ndc <- paste(ans$rat[, 1], ans$rat[, 2], sep = "/")
  int <- ans$rat[, 2] == 1
  ndc[int] <- as.character(ans$rat[int, 1])
  structure(ans$x, fracs = ndc, class = c("fractions", class(ans$x)))
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
frequency.polygon
list(`package:MASS` = function (x, nclass = nclass.freq(x), xlab = "", ylab = "", ...) 
{
  hst <- hist(x, nclass, probability = TRUE, plot = FALSE, ...)
  midpoints <- 0.5 * (hst$breaks[-length(hst$breaks)] + hst$breaks[-1])
  plot(midpoints, hst$counts, type = "l", xlab = xlab, ylab = ylab)
}, function (x, nclass = nclass.freq(x), xlab = "", ylab = "", ...) 
{
  hst <- hist(x, nclass, probability = TRUE, plot = FALSE, ...)
  midpoints <- 0.5 * (hst$breaks[-length(hst$breaks)] + hst$breaks[-1])
  plot(midpoints, hst$counts, type = "l", xlab = xlab, ylab = ylab)
}, function (x, nclass = nclass.freq(x), xlab = "", ylab = "", ...) 
{
  hst <- hist(x, nclass, probability = TRUE, plot = FALSE, ...)
  midpoints <- 0.5 * (hst$breaks[-length(hst$breaks)] + hst$breaks[-1])
  plot(midpoints, hst$counts, type = "l", xlab = xlab, ylab = ylab)
})
c("package:MASS", "registered S3 method for frequency from namespace MASS", "namespace:MASS")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
GAGurine
list(`package:MASS` = list(Age = c(0, 0, 0, 0, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.02, 0.02, 0.03, 0.03, 0.03, 0.04, 0.04, 0.04, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.06, 0.07, 0.1, 0.1, 0.14, 0.14, 0.15, 0.17, 0.18, 0.23, 0.24, 0.24, 0.25, 0.27, 0.28, 0.29, 0.29, 0.3, 0.33, 0.33, 0.4, 0.41, 0.45, 0.46, 0.47, 0.5, 0.5, 0.53, 0.55, 0.56, 0.56, 0.57, 0.58, 0.59, 0.59, 0.62, 0.64, 0.65, 0.65, 0.69, 0.71, 0.75, 0.8, 0.8, 0.82, 0.83, 0.84, 0.85, 0.86, 0.86, 0.87, 0.89, 0.94, 0.96, 0.97, 0.98, 
                                   0.99, 1.02, 1.03, 1.03, 1.05, 1.07, 1.07, 1.07, 1.08, 1.15, 1.23, 1.24, 1.25, 1.25, 1.25, 1.3, 1.31, 1.31, 1.31, 1.35, 1.37, 1.39, 1.39, 1.53, 1.59, 1.65, 1.75, 1.76, 1.77, 1.84, 1.86, 1.91, 1.99, 1.99, 2.02, 2.07, 2.09, 2.11, 2.12, 2.13, 2.19, 2.29, 2.32, 2.37, 2.41, 2.43, 2.49, 2.58, 2.73, 2.73, 2.74, 2.77, 2.82, 2.87, 2.87, 2.92, 2.95, 2.98, 3, 3.02, 3.03, 3.1, 3.13, 3.18, 3.19, 3.21, 3.29, 3.29, 3.63, 3.64, 3.64, 3.71, 3.85, 3.98, 4.07, 4.09, 4.11, 4.21, 4.27, 4.29, 4.29, 4.35, 4.38, 4.39, 4.43, 
                                   4.48, 4.5, 4.55, 4.65, 4.67, 4.68, 4.7, 4.75, 4.76, 4.77, 4.83, 4.85, 4.85, 4.93, 4.98, 4.99, 5.01, 5.04, 5.08, 5.1, 5.14, 5.18, 5.26, 5.26, 5.28, 5.29, 5.29, 5.35, 5.67, 5.79, 5.87, 5.92, 6.04, 6.05, 6.12, 6.15, 6.18, 6.19, 6.2, 6.2, 6.2, 6.25, 6.28, 6.31, 6.33, 6.34, 6.37, 6.43, 6.59, 6.61, 6.73, 6.9, 7.07, 7.35, 7.38, 7.44, 7.55, 7.57, 7.62, 7.62, 7.79, 7.8, 7.95, 7.95, 7.95, 8.03, 8.04, 8.17, 8.24, 8.28, 8.35, 8.36, 8.4, 8.46, 8.73, 8.81, 9.01, 9.05, 9.28, 9.28, 9.36, 9.55, 9.86, 10, 10.02, 10.09, 
                                   10.1, 10.12, 10.15, 10.28, 10.4, 10.49, 10.63, 10.7, 10.81, 11.15, 11.45, 11.47, 11.55, 11.78, 11.85, 11.9, 11.98, 12.15, 12.23, 12.32, 12.39, 12.46, 12.53, 12.75, 12.8, 12.88, 12.89, 12.97, 13.13, 13.4, 13.42, 13.73, 13.73, 13.92, 13.97, 14.12, 14.22, 14.61, 14.64, 14.85, 14.88, 14.92, 14.95, 14.96, 15.06, 15.15, 15.55, 15.72, 15.86, 15.87, 15.91, 16.01, 16.12, 16.23, 16.6, 16.74, 16.78, 17.08, 17.14, 17.23, 17.3, 17.67), GAG = c(23, 23.8, 16.9, 18.6, 17.9, 25.9, 16.5, 26.3, 26.9, 17.9, 29.1, 32.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      41.9, 38.7, 37.6, 46.4, 30.5, 34.8, 26.7, 33, 56.3, 33.5, 29.7, 32.8, 27.6, 31.9, 55.4, 33.3, 36.4, 25.9, 21.6, 26, 12.8, 34.2, 19.4, 21.9, 19.3, 26.2, 9.6, 36.1, 19.7, 19.2, 20.4, 23.1, 23.8, 21.6, 25.4, 18.4, 18.6, 26.4, 25.7, 20.4, 15.9, 20.8, 20.9, 15.7, 20.4, 14.1, 21.4, 15.6, 30.5, 15.4, 19.2, 22.6, 15.2, 14.9, 39.5, 17.3, 17.2, 13.8, 17.7, 15.6, 20.4, 14.8, 19.5, 18, 22.5, 20.4, 13.1, 17.4, 18.9, 16.1, 21.9, 18.4, 15.2, 19.1, 15.1, 17.2, 18.4, 24.1, 19, 16, 21.8, 16.5, 16.2, 10.8, 27, 17.3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      18.3, 18.3, 13.3, 12.1, 11, 12.7, 13.4, 14.3, 11.5, 16.5, 25.1, 16.3, 15.4, 18.6, 18.3, 13.2, 11.1, 11, 12.5, 14.8, 16.8, 12.8, 12.2, 14.7, 9.7, 14.2, 13.9, 9.5, 14.6, 12.1, 10.6, 10.8, 10.4, 9.9, 9.6, 21.7, 11.8, 11.8, 13, 11.3, 9, 18.3, 14.6, 11.5, 7.3, 11.6, 8.6, 11.5, 8.3, 10.3, 12.5, 13.2, 17.9, 10.7, 8.6, 12.5, 8.6, 6, 12.6, 12.7, 10.2, 10.7, 8.4, 9.9, 7.7, 13.6, 12.3, 7.5, 11.8, 7.7, 10.3, 16.9, 8.5, 9.7, 10.6, 6.4, 8.8, 8.8, 9.6, 6.6, 7.9, 6.3, 13.1, 7.8, 8.7, 9.2, 9.2, 8.4, 10.5, 8.6, 8.7, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      8, 11.1, 7.5, 7.6, 8.7, 8.8, 11.4, 6.6, 10.6, 5.5, 8.7, 6.8, 9.7, 6.8, 5.7, 8.5, 5.5, 8.4, 8.7, 9.8, 7.7, 6.8, 6.6, 7, 6.3, 6.8, 8.8, 10.3, 8, 1.8, 13.4, 6.8, 5.7, 7.1, 6.7, 6.5, 7.7, 5.8, 6.4, 6.5, 4.1, 8, 6.8, 6.4, 8.3, 7.3, 5.6, 5.1, 6.9, 7.7, 5.4, 5.9, 5, 5.2, 6.1, 6.3, 6.3, 7.1, 7.4, 5, 5.9, 6, 4.8, 9.9, 5.4, 5, 6.1, 13.8, 6.2, 5.5, 5.5, 11.7, 5.9, 9.8, 6.1, 7.5, 4.1, 7.7, 8.1, 4.5, 5.8, 5.4, 5.7, 3.1, 6.4, 7, 5.7, 3.9, 9.4, 4.4, 5, 15.9, 3.7, 9.1, 4.7, 3.6, 3.7, 4.1, 7.9, 3.3, 6.6, 1.9, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      5.7, 3.2, 3.8, 5.3, 3.2, 4.2, 6, 9.7, 3.4, 3.2, 2.5, 2, 4, 4.3, 2.8, 2.2, 4.7, 2.5, 2.2, 2.2, 1.9, 9.3)))
package:MASS
TRUE
FALSE
galaxies
list(`package:MASS` = c(9172, 9350, 9483, 9558, 9775, 10227, 10406, 16084, 16170, 18419, 18552, 18600, 18927, 19052, 19070, 19330, 19343, 19349, 19440, 19473, 19529, 19541, 19547, 19663, 19846, 19856, 19863, 19914, 19918, 19973, 19989, 20166, 20175, 20179, 20196, 20215, 20221, 20415, 20629, 20795, 20821, 20846, 20875, 20986, 21137, 21492, 21701, 21814, 21921, 21960, 22185, 22209, 22242, 22249, 22314, 22374, 22495, 22746, 22747, 22888, 22914, 23206, 23241, 23263, 23484, 23538, 23542, 23666, 23706, 
                        23711, 24129, 24285, 24289, 24366, 24717, 24990, 25633, 26690, 26995, 32065, 32789, 34279))
package:MASS
TRUE
FALSE
gamma.dispersion
list(`package:MASS` = function (object, ...) 
  1/gamma.shape(object, ...)[[1]], function (object, ...) 
    1/gamma.shape(object, ...)[[1]], function (object, ...) 
      1/gamma.shape(object, ...)[[1]])
c("package:MASS", "registered S3 method for gamma from namespace MASS", "namespace:MASS")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
gamma.shape
list(`package:MASS` = function (object, ...) 
  UseMethod("gamma.shape"), function (object, ...) 
    UseMethod("gamma.shape"), function (object, ...) 
      UseMethod("gamma.shape"))
c("package:MASS", "registered S3 method for gamma from namespace MASS", "namespace:MASS")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
gehan
list(`package:MASS` = list(pair = c(1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21), time = c(1, 10, 22, 7, 3, 32, 12, 23, 8, 22, 17, 6, 2, 16, 11, 34, 8, 32, 12, 25, 2, 11, 5, 20, 4, 19, 15, 6, 8, 17, 23, 35, 5, 6, 11, 13, 4, 9, 1, 6, 8, 10), cens = c(1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0), treat = c(2, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1)))
package:MASS
TRUE
FALSE
genotype
list(`package:MASS` = list(Litter = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4), Mother = c(1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4), Wt = c(61.5, 68.2, 64, 65, 59.7, 55, 42, 60.2, 52.5, 61.8, 49.5, 52.7, 42, 54, 61, 48.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                        39.6, 60.3, 51.7, 49.3, 48, 50.8, 64.7, 61.7, 64, 62, 56.5, 59, 47.2, 53, 51.3, 40.5, 37, 36.3, 68, 56.3, 69.8, 67, 39.7, 46, 61.3, 55.3, 55.7, 50, 43.8, 54.5, 59, 57.4, 54, 47, 59.5, 52.8, 56, 45.2, 57, 61.4, 44.8, 51.5, 53, 42, 54)))
package:MASS
TRUE
FALSE
geyser
list(`package:MASS` = list(waiting = c(80, 71, 57, 80, 75, 77, 60, 86, 77, 56, 81, 50, 89, 54, 90, 73, 60, 83, 65, 82, 84, 54, 85, 58, 79, 57, 88, 68, 76, 78, 74, 85, 75, 65, 76, 58, 91, 50, 87, 48, 93, 54, 86, 53, 78, 52, 83, 60, 87, 49, 80, 60, 92, 43, 89, 60, 84, 69, 74, 71, 108, 50, 77, 57, 80, 61, 82, 48, 81, 73, 62, 79, 54, 80, 73, 81, 62, 81, 71, 79, 81, 74, 59, 81, 66, 87, 53, 80, 50, 87, 51, 82, 58, 81, 49, 92, 50, 88, 62, 93, 56, 89, 51, 79, 58, 82, 52, 88, 52, 78, 69, 75, 77, 53, 80, 55, 
                                       87, 53, 85, 61, 93, 54, 76, 80, 81, 59, 86, 78, 71, 77, 76, 94, 75, 50, 83, 82, 72, 77, 75, 65, 79, 72, 78, 77, 79, 75, 78, 64, 80, 49, 88, 54, 85, 51, 96, 50, 80, 78, 81, 72, 75, 78, 87, 69, 55, 83, 49, 82, 57, 84, 57, 84, 73, 78, 57, 79, 57, 90, 62, 87, 78, 52, 98, 48, 78, 79, 65, 84, 50, 83, 60, 80, 50, 88, 50, 84, 74, 76, 65, 89, 49, 88, 51, 78, 85, 65, 75, 77, 69, 92, 68, 87, 61, 81, 55, 93, 53, 84, 70, 73, 93, 50, 87, 77, 74, 72, 82, 74, 80, 49, 91, 53, 86, 49, 79, 89, 87, 76, 59, 80, 89, 45, 
                                       93, 72, 71, 54, 79, 74, 65, 78, 57, 87, 72, 84, 47, 84, 57, 87, 68, 86, 75, 73, 53, 82, 93, 77, 54, 96, 48, 89, 63, 84, 76, 62, 83, 50, 85, 78, 78, 81, 78, 76, 74, 81, 66, 84, 48, 93, 47, 87, 51, 78, 54, 87, 52, 85, 58, 88, 79), duration = c(4.0166667, 2.15, 4, 4, 4, 2, 4.3833333, 4.2833333, 2.0333333, 4.8333333, 1.8333333, 5.45, 1.6166667, 4.8666667, 4.3833333, 1.7666667, 4.6666667, 2, 4.7333333, 4.2166667, 1.9, 4.9666667, 2, 4, 2, 4, 2.8333333, 4.5, 4.0666667, 3.7166667, 3.5166667, 4.4666667, 2.2166667, 
                                                                                                                                                                                                                                                                                         4.8833333, 2.6, 4.15, 2.2, 4.7666667, 1.8333333, 4.6, 2.2666667, 4.1333333, 2, 4, 2, 4, 1.8833333, 4.2666667, 2.0833333, 4.4666667, 2.5, 4, 1.7666667, 4.3333333, 2.1833333, 4.4833333, 3.8833333, 3.3333333, 3.7333333, 4, 1.95, 5.2666667, 2, 4, 2, 4, 2, 4, 3.5333333, 2.1666667, 4.5, 2.0166667, 4.15, 4.2, 4.3333333, 1.9333333, 4.65, 3.8166667, 4.0333333, 4.1666667, 4.6666667, 1.8166667, 4, 3, 4, 2, 4.45, 2.05, 4.25, 1.9166667, 4.6666667, 1.7333333, 4.3833333, 1.7666667, 4.6, 1.8666667, 4.45, 1.6333333, 
                                                                                                                                                                                                                                                                                         5.0333333, 1.8166667, 5.1, 1.6333333, 4.2833333, 2, 4, 2, 4.5333333, 2, 4, 2.9333333, 4.7333333, 3.9, 1.95, 4.1166667, 1.8, 4.6666667, 1.8333333, 4.7, 2.1166667, 4.7833333, 1.8166667, 4.1, 4.65, 4, 2, 4, 4, 4.2166667, 4.1333333, 3.9333333, 3.75, 4.4166667, 2.4666667, 4.1666667, 3.8, 4.3166667, 3.8666667, 4.6833333, 1.7, 4.9666667, 4.2666667, 4.5833333, 4, 4, 4, 4, 1.9833333, 4.6, 0.8333333, 4.9166667, 1.7333333, 4.5833333, 1.7, 4.75, 1.8333333, 4.5, 1.8666667, 4.45, 4.45, 4, 4.8, 4, 4, 2, 4, 1.9333333, 
                                                                                                                                                                                                                                                                                         4.5833333, 2, 3.7, 2.8666667, 4.8333333, 3.45, 4.3833333, 1.8, 4.4, 2.4833333, 4.5166667, 2.1, 4.35, 4.3666667, 1.7833333, 4.9166667, 1.8166667, 4, 4, 4, 3.8666667, 1.85, 4.7, 2.0166667, 4.4666667, 1.8666667, 4.1666667, 1.9, 4.25, 3.25, 4.2166667, 1.8833333, 4.9833333, 1.85, 4, 1.9666667, 4.7666667, 4, 2, 4, 4, 2.3833333, 4.4166667, 4.2166667, 4.3666667, 2, 4.45, 1.75, 4.5, 1.6166667, 4.7, 2.5666667, 3.7, 4.2333333, 1.9333333, 4.35, 4, 4, 4, 4.2166667, 4, 4.1333333, 1.8833333, 4.4666667, 1.95, 4.2166667, 
                                                                                                                                                                                                                                                                                         1.7166667, 4.45, 4.25, 3.9666667, 4.3833333, 1.9666667, 4.45, 4.2666667, 1.9166667, 4.4166667, 3, 4, 2, 4, 3.2833333, 1.8333333, 4.6166667, 1.8333333, 4.6166667, 4.6, 4.25, 1.9333333, 4.9833333, 1.9666667, 4.3, 4.2, 4.5333333, 4.4, 4.6166667, 2, 4, 4, 3.9166667, 2, 4.5, 1.8, 4, 2.75, 4.7333333, 3.9666667, 1.95, 4.9666667, 1.85, 4.8, 4, 4, 4, 4, 4, 4, 4, 2, 4, 1.9333333, 4.3333333, 1.6666667, 4.7666667, 1.95, 4.6833333, 1.9333333, 4.4166667, 2.1333333, 4.0833333, 2.0666667, 4, 4, 2)))
package:MASS
TRUE
FALSE
gilgais
list(`package:MASS` = list(pH00 = c(7, 6.7, 7.8, 8.9, 7, 8.5, 7, 7.4, 7.4, 7.2, 8.5, 7.7, 7.5, 8.2, 6.8, 6.3, 6.9, 7, 6.9, 6.7, 7.9, 8.5, 8.2, 5.9, 8.3, 7, 6.3, 7, 7.4, 7.6, 7.7, 7.6, 6.2, 6.9, 7.1, 7.9, 7.1, 8.1, 7.5, 6.6, 7.3, 7, 7.2, 7, 7.2, 7.1, 6.9, 8.4, 8, 6.7, 8.5, 7.2, 7.5, 7.6, 7.8, 8.5, 7.8, 6.5, 6.6, 6.8, 7, 7.7, 8.1, 6.9, 6.7, 6.4, 7.1, 7.6, 7.3, 8.5, 7, 6.8, 7, 6.9, 8.7, 8.2, 6.8, 6.7, 6.8, 7.9, 8.3, 8.2, 8.5, 8.3, 7.1, 8, 8.1, 6.7, 7.5, 7, 7.4, 7.8, 6.7, 7, 7.7, 6.4, 7.2, 7.5, 7.7, 
                                    6.5, 6.8, 7.9, 6.4, 8.4, 7.1, 6.8, 6.8, 7.6, 8.1, 8.7, 8.5, 8.6, 7.2, 8.7, 8.6, 8.3, 6.5, 6.6, 8.2, 7.7, 6.2, 7.3, 7.8, 7.8, 7.5, 6.7, 8.3, 7.6, 7.2, 6.2, 7.3, 8.3, 8.2, 7.3, 7.3, 8.2, 7.6, 7.1, 6.5, 7.4, 7.2, 6.8, 7, 7.3, 8.6, 8, 7.2, 6.6, 7.7, 7.8, 7.3, 7.1, 7.2, 7.7, 8.6, 6.9, 7.4, 7.1, 7.2, 6.7, 6.7, 7.6, 6.3, 8.3, 7.1, 6.7, 6.7, 8.9, 6.8, 8.5, 6.6, 8.3, 6.9, 8.2, 7.2, 6, 8, 6.5, 7, 8.6, 7.3, 6.2, 6.5, 6.5, 6.7, 7.8, 6.4, 7.2, 8.1, 6.4, 6.5, 6.1, 7.4, 6.6, 6.7, 8.5, 6.9, 6.4, 6.7, 7.6, 7.6, 6.1, 
                                    8.2, 8, 7, 6.7, 6.4, 7.7, 6.3, 7.5, 8.4, 7.6, 8.2, 7.3, 6.8, 8.4, 7.6, 9, 8.7, 8.5, 7.6, 7.4, 7.5, 6.8, 7.1, 8.1, 6.7, 5.8, 6.1, 8.6, 6.3, 8.1, 7.1, 8, 6.4, 6.1, 8.2, 7.5, 8.3, 8.4, 8.7, 7.5, 7.1, 7.5, 7, 7.8, 6.8, 6.7, 7.8, 6.8, 8.5, 7.2, 8.7, 6.7, 6.6, 6.4, 7.3, 6.2, 8.3, 7.8, 8.8, 8.8, 8.8, 6.9, 6.7, 6.9, 8.6, 8.1, 7.4, 7.8, 8.7, 7.8, 7.3, 6.9, 6.2, 8.1, 8.2, 6.7, 8.6, 8.4, 6.5, 6.7, 8.4, 7.5, 7.2, 7.8, 6.4, 8, 7.4, 5.9, 7.3, 8.5, 8.7, 7.8, 7.2, 8.1, 7.1, 8.4, 8, 8.2, 7.1, 8.2, 8.5, 8.6, 8.3, 
                                    6.3, 6.4, 8.6, 8.1, 7, 7.1, 8.3, 6.7, 6.4, 6.5, 6.5, 6.5, 5.6, 8.8, 7.5, 6.8, 6, 6.5, 8.4, 7.1, 7.7, 8.3, 7.7, 7.7, 6.7, 6.5, 6.6, 7, 7.2, 6.7, 6.7, 6.8, 6.6, 6.9, 6.4, 7.6, 7.3, 7.4, 7.2, 7.1, 6.8, 7.7, 8.4, 6.3, 7.1, 7.8, 7.5, 8.5, 8.3, 7.6, 7.2, 8.2, 7.1, 8.5, 9, 8.9, 8.4, 7.5, 7.5, 7.2), pH30 = c(9.4, 9.2, 9.3, 8.4, 8.7, 8.1, 9, 8.4, 8.7, 8.9, 9.1, 8.9, 8.9, 9, 8.6, 8.5, 8.4, 8.4, 8.5, 8.7, 8.5, 8.7, 8.6, 8, 8.9, 8.5, 9, 8.5, 8.6, 8.2, 8.7, 9.2, 8.8, 9.4, 9.2, 8.9, 9.1, 9.2, 8.9, 8.5, 9, 8.7, 
                                                                                                                                                                                                                                                                                                                                                  8.9, 8.2, 8.7, 9, 8.3, 9, 9.2, 8.7, 9.4, 9, 8.9, 8.7, 9.2, 9.3, 9.3, 8.5, 9, 9.2, 8.9, 9.1, 9.2, 8.5, 9, 9.1, 8.6, 8.6, 8.8, 9.3, 9, 8.5, 8.4, 8.6, 9.2, 9.1, 9.1, 7.9, 9, 9.3, 9, 8.9, 9.2, 9, 9, 8.9, 9, 9, 9, 8.5, 9.2, 9.3, 8.9, 8.9, 9.1, 8.6, 8.9, 9.2, 8.9, 7.8, 8, 9, 8.2, 9, 8.4, 8.6, 8.7, 9, 8.5, 9.1, 9.7, 9, 9, 9.2, 9.1, 8.9, 7.5, 9, 9, 9.2, 8.3, 9.1, 8.8, 9.2, 8.6, 8.1, 8.4, 8.7, 9, 8.9, 9, 7.8, 8.3, 8.2, 7.8, 7.9, 8.8, 8.2, 8, 8.9, 8.9, 8.5, 8.5, 8.3, 8.8, 7.8, 8.7, 8.5, 9.1, 9.2, 8.5, 8.3, 
                                                                                                                                                                                                                                                                                                                                                  8.6, 9, 9, 8.5, 8.9, 8.2, 8.4, 8.7, 8.8, 8.9, 8.6, 8.3, 8.9, 7.9, 9, 7.7, 8.6, 9, 8.6, 9.2, 9.2, 9, 8.4, 8.9, 8.9, 7.9, 8.9, 9.3, 9.2, 8.1, 8.9, 7.6, 9.1, 9.1, 8.5, 9.1, 9.1, 8.3, 8.4, 8.5, 9.2, 9.1, 9.1, 9.4, 9.2, 8.6, 8.7, 9.3, 9, 9, 9.2, 9.3, 9, 8.9, 9.2, 9.3, 7.8, 9.1, 9.1, 9, 8.9, 8.6, 9, 9.1, 9.1, 9.1, 9.1, 9.1, 8.9, 9.1, 8.8, 8.9, 8.7, 8.5, 8.9, 8.7, 8, 9, 9.1, 9.3, 9.2, 9.5, 9.1, 8.1, 8.9, 8.7, 8.5, 9.3, 9, 9.4, 9.2, 9.3, 9.2, 9.4, 9.1, 8.9, 9.1, 9.2, 9.4, 8.4, 8.4, 8.8, 8.6, 8.7, 9.2, 8.7, 
                                                                                                                                                                                                                                                                                                                                                  9.2, 8.8, 8.5, 8.5, 8.9, 8.9, 8.7, 8.5, 8.9, 9, 9.1, 8.5, 8.6, 8.7, 8.9, 9.1, 8.3, 9, 9, 8.8, 9.3, 9.3, 9.2, 8.9, 9, 8.4, 8.3, 8.8, 9.3, 9.2, 8.7, 7.5, 8.4, 8.9, 8.8, 8.4, 8.6, 8.7, 8.7, 9, 8.8, 8.8, 8.8, 8.5, 9.3, 8.9, 8.8, 8.8, 8.4, 9, 9.1, 9.1, 8.8, 9.2, 8.7, 8.5, 7.7, 8.7, 8, 8, 8.7, 8.5, 8.7, 9, 9.1, 9.3, 9.4, 8.4, 8.5, 8.7, 8.8, 8.9, 8.5, 8.9, 9.6, 9.5, 9.2, 8.6, 9.3, 8.7, 8.5, 8.5, 8.3, 8.7, 8.8, 8.2, 8.8, 8.7, 8.4, 9.1, 8.4, 8.8, 8.5, 8.7, 7.9, 8.8, 8.6, 8.8, 9.1, 8.9, 8.7, 8.3, 8.3, 8.2, 
                                                                                                                                                                                                                                                                                                                                                  8.4, 8.8, 8.4), pH80 = c(7.9, 9.2, 8, 7.8, 8.5, 8.2, 8, 8.2, 8.1, 8.5, 9, 8.1, 7.9, 8.2, 8.2, 8, 8.3, 8.3, 8.5, 8.6, 8.5, 8, 7.8, 8.4, 8, 8.8, 8.6, 8.4, 8.5, 8.1, 8, 9.3, 9, 9.4, 9.5, 9.3, 9.1, 9.1, 9, 9.2, 9, 8.5, 8.6, 8.4, 8.7, 8.7, 9, 9.1, 9.2, 9, 8.9, 8.7, 8.4, 8.2, 8.9, 9.1, 8.9, 8.7, 8.8, 8.8, 8.7, 8.2, 8.9, 9.5, 9, 8.9, 7.7, 8.4, 7.7, 9, 7.7, 7.8, 8.5, 7.6, 8.7, 8.6, 9, 8.1, 9, 9.2, 9.4, 9.3, 9.3, 9.1, 8.7, 8.6, 7.9, 8.5, 8.6, 7.8, 9, 9.2, 9, 9.1, 9.1, 8.9, 8.9, 8.9, 8.8, 8.1, 8.5, 8.6, 8, 
                                                                                                                                                                                                                                                                                                                                                                           8.8, 8.1, 8, 8.6, 8.7, 7.9, 7.5, 7.2, 7.2, 7.5, 7.8, 8.6, 9.2, 9, 9.2, 9.3, 9.3, 9, 9.2, 9, 8.2, 7.4, 8.4, 7.6, 7.7, 8, 7.8, 8.2, 8, 8.3, 7.9, 7.9, 7.9, 8.1, 8.8, 8.9, 9.2, 8.8, 8, 7.8, 8.7, 8.4, 7.9, 8, 9.1, 7.9, 7.9, 8.5, 8.3, 8.3, 9.5, 9.3, 8.8, 8.4, 7.7, 8.5, 8.5, 8.4, 8.6, 8.3, 8.6, 9.3, 9.1, 8.7, 7.8, 8.7, 9.1, 9.2, 9.2, 9.2, 8.9, 8.5, 8.8, 9.1, 9.2, 8.8, 9.2, 9.1, 9.1, 9.1, 9.2, 8.8, 9.3, 9.2, 8.7, 8.7, 9, 9, 8.8, 8.9, 9.1, 9.1, 9.2, 9.3, 9.4, 9.4, 9.3, 9.4, 9.1, 8.8, 8.8, 8.7, 9.1, 9.1, 9.1, 
                                                                                                                                                                                                                                                                                                                                                                           9.3, 9.3, 8.7, 8.9, 8.7, 7.6, 7.7, 8.4, 8.8, 8.8, 8.7, 9.3, 9.5, 8.3, 8.5, 8.5, 7.9, 7.7, 8.4, 9, 9, 8.2, 8.8, 9.1, 9.1, 8.6, 9.5, 9.4, 9.1, 7.5, 7.3, 8, 8.2, 8.8, 8.4, 8.3, 8.8, 9.4, 9.3, 9.2, 8.5, 8.8, 9.1, 8.8, 8.4, 9.5, 9.5, 9.5, 9.3, 9.3, 8.8, 8.6, 8.7, 8.7, 8.7, 9.3, 9.2, 7.6, 8, 8.8, 8.4, 8.5, 8.6, 8.6, 9.1, 8.5, 9.1, 9.3, 9.3, 9.3, 9.2, 9.3, 8.9, 8.7, 8.4, 8.3, 8.3, 8.3, 9.1, 9.4, 9.3, 9.3, 8.3, 8.7, 8, 8.9, 8.6, 8.9, 7.9, 7.9, 8.4, 8.6, 8.7, 8, 8.5, 7.8, 7.5, 8.6, 8.7, 8.5, 8.9, 9.2, 9.1, 
                                                                                                                                                                                                                                                                                                                                                                           9, 8.1, 9.3, 8.9, 9.1, 9.2, 9.4, 8.4, 8.4, 8.6, 9.2, 9.5, 9.5, 9.3, 8.6, 8.7, 8.7, 8.6, 8.8, 8.7, 8.8, 9.6, 9.4, 8.7, 8.2, 8.4, 8.5, 8.2, 8.2, 6.8, 7.2, 8.3, 8.6, 8.6, 8.6, 8.5, 8.9, 9.1, 7.8, 6.8, 5.1, 4.9, 7.5, 7.9, 7.9, 7.2, 7.3, 7.4, 5.8, 8.1, 7, 7.1, 8.2, 8), e00 = c(20, 12, 11, 55, 20, 90, 11, 10, 23, 15, 14, 19, 11, 16, 27, 18, 27, 47, 7, 22, 30, 16, 28, 20, 13, 9, 18, 38, 90, 20, 27, 15, 8, 21, 7, 10, 9, 9, 6, 11, 5, 8, 16, 76, 8, 11, 11, 12, 10, 9, 15, 15, 5, 10, 8, 19, 14, 15, 8, 12, 8, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            14, 13, 6, 7, 7, 13, 12, 20, 10, 5, 58, 22, 16, 13, 15, 9, 9, 10, 7, 9, 9, 11, 10, 16, 14, 19, 15, 9, 24, 9, 9, 7, 9, 10, 5, 5, 9, 8, 9, 7, 7, 5, 12, 56, 19, 10, 6, 32, 29, 43, 24, 14, 14, 8, 11, 7, 14, 11, 11, 8, 7, 16, 16, 12, 7, 66, 14, 9, 7, 10, 14, 68, 94, 240, 110, 14, 7, 5, 10, 9, 26, 6, 62, 22, 80, 10, 8, 10, 15, 56, 78, 21, 10, 15, 8, 17, 210, 120, 23, 13, 18, 59, 20, 6, 6, 13, 34, 10, 16, 7, 25, 11, 19, 45, 20, 15, 11, 12, 17, 14, 9, 5, 5, 7, 17, 6, 11, 10, 5, 11, 7, 5, 5, 8, 16, 8, 6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            5, 11, 10, 10, 10, 11, 10, 5, 10, 5, 5, 6, 18, 5, 7, 9, 9, 12, 6, 18, 30, 13, 10, 10, 13, 17, 16, 80, 10, 24, 5, 23, 29, 26, 9, 6, 5, 8, 17, 29, 28, 20, 27, 12, 6, 7, 8, 8, 7, 5, 30, 13, 18, 86, 32, 5, 5, 5, 16, 5, 17, 23, 58, 45, 34, 10, 6, 74, 20, 18, 6, 60, 39, 25, 7, 26, 13, 14, 14, 10, 14, 12, 7, 7, 17, 46, 51, 16, 10, 16, 11, 8, 14, 13, 32, 40, 28, 12, 19, 16, 10, 16, 7, 29, 17, 24, 22, 11, 9, 17, 22, 9, 5, 14, 46, 11, 11, 13, 8, 16, 40, 42, 32, 11, 7, 14, 5, 60, 27, 18, 26, 7, 5, 10, 11, 14, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            7, 11, 11, 20, 45, 7, 16, 14, 100, 56, 9, 22, 25, 16, 12, 18, 56, 19, 130, 29, 13, 14, 20, 12, 25, 55, 80, 51, 36, 36, 11), e30 = c(37, 27, 44, 290, 150, 350, 44, 50, 110, 89, 38, 60, 58, 50, 140, 170, 170, 210, 77, 53, 84, 140, 150, 140, 72, 110, 29, 180, 190, 320, 130, 29, 15, 36, 23, 17, 20, 29, 25, 11, 24, 100, 83, 280, 93, 39, 17, 24, 21, 15, 44, 50, 88, 130, 32, 32, 38, 14, 16, 26, 22, 60, 32, 9, 20, 23, 140, 170, 120, 33, 70, 200, 130, 140, 63, 81, 27, 30, 25, 33, 23, 16, 27, 120, 47, 50, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                63, 94, 80, 190, 34, 35, 18, 18, 30, 14, 15, 27, 22, 19, 110, 62, 36, 42, 200, 150, 76, 33, 190, 60, 110, 70, 38, 54, 31, 20, 7, 23, 21, 26, 15, 24, 21, 51, 150, 100, 180, 72, 57, 26, 39, 200, 290, 300, 460, 460, 68, 39, 9, 30, 69, 170, 120, 240, 130, 440, 120, 15, 34, 46, 230, 280, 130, 30, 27, 25, 74, 330, 310, 150, 120, 99, 160, 260, 32, 17, 59, 510, 66, 39, 26, 29, 44, 84, 260, 52, 27, 19, 85, 55, 39, 17, 21, 9, 30, 27, 13, 37, 55, 22, 14, 16, 38, 23, 24, 46, 34, 13, 15, 34, 21, 22, 54, 56, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                24, 30, 32, 12, 31, 64, 23, 21, 48, 66, 96, 35, 74, 100, 26, 18, 92, 180, 130, 170, 220, 89, 18, 6, 68, 30, 31, 30, 48, 27, 24, 77, 190, 260, 50, 120, 54, 65, 55, 41, 45, 26, 19, 72, 47, 51, 290, 280, 34, 12, 16, 22, 11, 38, 160, 260, 320, 170, 24, 16, 240, 130, 120, 78, 310, 280, 190, 35, 74, 19, 24, 21, 23, 45, 34, 39, 66, 100, 250, 300, 160, 34, 26, 15, 7, 9, 94, 150, 280, 210, 110, 140, 100, 130, 110, 100, 190, 82, 140, 110, 20, 11, 110, 34, 22, 13, 37, 210, 24, 6, 13, 6, 6, 200, 260, 170, 30, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                23, 34, 38, 320, 300, 270, 240, 61, 50, 95, 50, 31, 73, 190, 63, 190, 290, 290, 18, 150, 110, 340, 160, 210, 290, 41, 16, 170, 300, 180, 510, 210, 60, 57, 87, 50, 130, 370, 340, 360, 330, 160, 86), e80 = c(370, 80, 350, 460, 270, 360, 340, 270, 270, 220, 100, 330, 390, 250, 310, 370, 140, 200, 200, 170, 170, 340, 300, 220, 350, 140, 200, 260, 230, 340, 340, 82, 80, 85, 66, 46, 56, 100, 100, 70, 100, 190, 160, 240, 150, 140, 70, 86, 68, 56, 130, 170, 230, 250, 120, 120, 110, 91, 64, 120, 120, 300, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              120, 35, 74, 74, 390, 250, 420, 120, 340, 340, 180, 340, 190, 170, 100, 110, 85, 87, 46, 36, 73, 39, 140, 140, 340, 190, 160, 330, 96, 78, 51, 40, 74, 68, 54, 89, 94, 240, 190, 170, 240, 150, 260, 340, 200, 150, 350, 340, 400, 410, 390, 300, 130, 48, 15, 73, 53, 60, 33, 40, 45, 180, 420, 230, 390, 420, 330, 320, 310, 340, 310, 390, 430, 420, 310, 44, 27, 76, 170, 310, 330, 210, 270, 380, 290, 77, 350, 360, 240, 220, 170, 63, 64, 72, 210, 530, 270, 200, 180, 150, 180, 240, 81, 76, 200, 340, 150, 89, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              53, 85, 100, 120, 180, 160, 38, 35, 160, 120, 110, 48, 55, 22, 95, 76, 78, 130, 170, 120, 89, 100, 150, 85, 88, 100, 76, 40, 48, 88, 55, 88, 160, 170, 140, 75, 96, 110, 40, 92, 200, 89, 76, 370, 380, 210, 130, 180, 210, 76, 47, 340, 250, 270, 370, 220, 160, 66, 26, 150, 80, 100, 110, 200, 66, 27, 96, 340, 320, 350, 320, 170, 160, 160, 110, 95, 86, 66, 150, 140, 140, 210, 230, 29, 35, 35, 68, 44, 130, 240, 260, 230, 240, 66, 36, 400, 390, 190, 270, 240, 280, 210, 120, 150, 82, 56, 68, 68, 120, 110, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              130, 160, 210, 230, 260, 220, 90, 80, 42, 58, 21, 200, 400, 180, 200, 180, 440, 420, 260, 210, 170, 360, 270, 430, 340, 130, 73, 250, 160, 67, 38, 110, 280, 85, 18, 57, 55, 32, 280, 310, 220, 86, 60, 76, 100, 270, 250, 270, 270, 170, 180, 190, 84, 44, 160, 200, 250, 220, 230, 120, 410, 350, 200, 210, 190, 210, 270, 140, 91, 270, 270, 450, 450, 380, 200, 220, 350, 400, 350, 310, 260, 320, 290, 200, 260), c00 = c(60, 45, 20, 480, 180, 1350, 55, 20, 250, 75, 20, 34, 20, 20, 175, 170, 325, 625, 35, 43, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             85, 38, 250, 210, 20, 25, 160, 490, 1450, 130, 380, 20, 35, 65, 23, 20, 37, 20, 20, 38, 20, 70, 85, 900, 30, 55, 20, 20, 20, 20, 20, 35, 41, 65, 20, 20, 20, 80, 27, 20, 20, 85, 20, 20, 29, 29, 145, 80, 260, 20, 31, 600, 290, 340, 20, 100, 36, 29, 55, 20, 20, 20, 20, 20, 35, 33, 42, 150, 90, 350, 28, 20, 30, 32, 33, 20, 21, 37, 20, 23, 70, 20, 20, 20, 750, 165, 44, 20, 210, 145, 170, 85, 60, 20, 20, 20, 20, 42, 28, 40, 25, 22, 25, 31, 90, 41, 1150, 55, 60, 38, 31, 29, 750, 1300, 3000, 1500, 65, 27, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             27, 23, 70, 410, 32, 900, 65, 1150, 38, 23, 20, 42, 700, 1150, 220, 20, 20, 20, 120, 3350, 1000, 235, 105, 200, 390, 175, 25, 24, 70, 260, 20, 22, 20, 125, 38, 20, 550, 75, 27, 31, 90, 20, 30, 55, 25, 20, 24, 20, 20, 55, 20, 20, 55, 20, 20, 25, 27, 20, 39, 38, 20, 29, 20, 55, 20, 55, 65, 20, 44, 20, 20, 20, 20, 20, 20, 55, 34, 20, 31, 24, 135, 20, 25, 75, 110, 140, 120, 1050, 55, 77, 20, 65, 175, 29, 20, 20, 20, 20, 20, 330, 100, 70, 100, 20, 39, 55, 70, 23, 45, 37, 200, 80, 20, 1300, 215, 24, 36, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             32, 20, 20, 20, 160, 550, 370, 250, 28, 28, 1100, 65, 125, 30, 1000, 320, 280, 25, 270, 65, 20, 20, 33, 20, 20, 20, 29, 37, 600, 800, 80, 39, 20, 20, 35, 20, 20, 165, 550, 340, 27, 160, 28, 20, 48, 38, 190, 20, 48, 46, 20, 20, 31, 20, 20, 20, 20, 520, 40, 32, 28, 20, 44, 270, 600, 350, 50, 25, 20, 20, 800, 260, 170, 300, 27, 20, 75, 55, 85, 47, 95, 46, 60, 600, 32, 130, 85, 1340, 700, 60, 260, 300, 20, 100, 180, 750, 135, 1350, 240, 38, 36, 50, 40, 70, 550, 950, 650, 430, 430, 65), c30 = c(60, 38, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            155, 2885, 1500, 2350, 300, 550, 1225, 790, 205, 300, 420, 365, 1410, 1650, 1865, 2550, 890, 535, 850, 1080, 1800, 2150, 600, 1300, 205, 1850, 1875, 3425, 1375, 95, 115, 100, 30, 23, 37, 55, 75, 65, 120, 1140, 925, 2750, 925, 320, 87, 37, 29, 29, 265, 490, 700, 1050, 80, 60, 85, 83, 46, 55, 75, 430, 80, 24, 65, 78, 1685, 1725, 1050, 120, 700, 2425, 1750, 1480, 505, 700, 104, 315, 83, 110, 34, 26, 40, 1515, 450, 455, 415, 940, 725, 1800, 95, 90, 32, 26, 36, 65, 20, 38, 40, 170, 1340, 530, 355, 215, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            1610, 1975, 700, 150, 2285, 245, 665, 385, 155, 290, 58, 29, 37, 30, 32, 33, 80, 27, 30, 285, 1400, 1165, 1540, 455, 445, 83, 185, 110, 3450, 3690, 3210, 2925, 530, 80, 32, 90, 610, 2125, 1250, 2560, 1590, 3300, 1350, 60, 85, 150, 2935, 3250, 825, 85, 65, 150, 890, 3575, 3325, 1950, 1000, 1200, 2000, 2475, 110, 80, 525, 2775, 285, 100, 88, 67, 170, 740, 2600, 455, 60, 65, 975, 285, 140, 20, 27, 20, 100, 41, 34, 140, 335, 27, 46, 100, 155, 63, 37, 150, 108, 42, 53, 50, 23, 33, 325, 305, 140, 32, 83, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            50, 23, 60, 520, 63, 75, 570, 850, 850, 225, 800, 690, 75, 70, 800, 2600, 1650, 2300, 2700, 1040, 83, 33, 575, 140, 61, 48, 165, 110, 34, 590, 1950, 2700, 290, 1040, 280, 500, 330, 240, 170, 60, 40, 625, 345, 295, 3305, 2625, 185, 38, 20, 36, 46, 185, 1700, 2865, 3385, 2350, 105, 66, 3150, 1725, 1450, 850, 3450, 3175, 2700, 260, 975, 130, 90, 35, 80, 290, 125, 340, 900, 840, 3245, 3240, 2225, 160, 47, 24, 39, 38, 1035, 1690, 2500, 2100, 1000, 1700, 1050, 1600, 1425, 1400, 2150, 675, 1600, 1130, 145, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            68, 1250, 155, 47, 27, 165, 2425, 135, 21, 38, 20, 22, 2450, 2950, 2400, 165, 75, 70, 110, 2735, 3160, 2985, 2950, 625, 625, 1150, 300, 78, 625, 2700, 550, 2200, 2650, 2650, 155, 1730, 1015, 3400, 2150, 2350, 2975, 300, 130, 1450, 2460, 1250, 3250, 1450, 420, 600, 1025, 485, 1500, 2415, 4770, 4135, 4150, 1800, 1400), c80 = c(505, 450, 1325, 1900, 3200, 2435, 1240, 1400, 2425, 1650, 675, 725, 1050, 1250, 1900, 2140, 1565, 2365, 2625, 1700, 1600, 1935, 2600, 2900, 1490, 1500, 2250, 2950, 2950, 2450, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   2085, 650, 800, 600, 410, 290, 550, 950, 925, 810, 1250, 1900, 1900, 2735, 1700, 1650, 675, 600, 430, 600, 1590, 1650, 1650, 1425, 1425, 1025, 1125, 680, 640, 1250, 1250, 1400, 725, 80, 725, 760, 1915, 2700, 1785, 950, 1200, 1850, 1900, 1595, 2050, 1850, 800, 1350, 575, 360, 145, 155, 355, 125, 1350, 1275, 1025, 1750, 1450, 2050, 590, 510, 260, 315, 615, 675, 500, 850, 960, 1040, 1750, 1210, 1710, 1000, 1700, 2300, 2075, 1575, 3315, 1125, 1675, 1300, 825, 930, 675, 215, 50, 590, 315, 450, 440, 290, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   335, 1250, 2375, 3050, 2400, 1115, 1725, 625, 1375, 965, 2835, 2725, 2625, 3065, 1750, 220, 90, 550, 1350, 1950, 1550, 2225, 2300, 2775, 1850, 440, 545, 820, 2450, 3050, 1900, 240, 350, 215, 1850, 3050, 2925, 2500, 2000, 1450, 2200, 2700, 575, 740, 2200, 3365, 1595, 650, 350, 590, 840, 1175, 1900, 1800, 285, 200, 1625, 1115, 780, 380, 365, 110, 1150, 650, 560, 1215, 1700, 1050, 675, 1050, 1450, 510, 625, 900, 340, 160, 205, 420, 370, 725, 1575, 2275, 1800, 590, 925, 1150, 133, 740, 1150, 600, 625, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   1700, 1620, 1750, 1200, 1850, 2425, 550, 175, 1500, 2650, 2575, 2275, 2525, 1850, 640, 200, 1500, 750, 950, 590, 850, 450, 430, 900, 2650, 3000, 1175, 1850, 1135, 1500, 1900, 1550, 685, 500, 300, 1475, 1400, 1525, 2325, 2715, 63, 83, 120, 550, 290, 1200, 1900, 2350, 2650, 2950, 335, 145, 2350, 2075, 1450, 1150, 2365, 3725, 2525, 1425, 1800, 780, 340, 460, 485, 1075, 800, 1200, 1600, 2600, 2960, 3300, 2600, 800, 690, 270, 350, 175, 1400, 1740, 1890, 2115, 1775, 1825, 2200, 2250, 1475, 1850, 1915, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   2900, 1620, 1575, 1250, 740, 1800, 1325, 450, 270, 1235, 3100, 635, 155, 550, 540, 260, 3700, 4250, 2900, 950, 410, 600, 850, 2765, 3000, 3470, 2950, 2000, 1675, 1850, 625, 185, 2300, 2650, 2250, 3000, 2825, 1750, 2025, 1900, 2425, 2640, 2750, 2650, 2965, 1475, 1100, 2450, 2775, 1925, 2400, 2175, 1300, 1700, 1735, 1625, 1975, 3935, 3190, 4725, 3700, 2600, 1650)))
package:MASS
TRUE
FALSE
ginv
list(`package:MASS` = function (X, tol = sqrt(.Machine$double.eps)) 
{
  if (length(dim(X)) > 2 || !(is.numeric(X) || is.complex(X))) 
    stop("'X' must be a numeric or complex matrix")
  if (!is.matrix(X)) 
    X <- as.matrix(X)
  Xsvd <- svd(X)
  if (is.complex(X)) 
    Xsvd$u <- Conj(Xsvd$u)
  Positive <- Xsvd$d > max(tol * Xsvd$d[1], 0)
  if (all(Positive)) 
    Xsvd$v %*% (1/Xsvd$d * t(Xsvd$u))
  else if (!any(Positive)) 
    array(0, dim(X)[2:1])
  else Xsvd$v[, Positive, drop = FALSE] %*% ((1/Xsvd$d[Positive]) * t(Xsvd$u[, Positive, drop = FALSE]))
}, function (X, tol = sqrt(.Machine$double.eps)) 
{
  if (length(dim(X)) > 2 || !(is.numeric(X) || is.complex(X))) 
    stop("'X' must be a numeric or complex matrix")
  if (!is.matrix(X)) 
    X <- as.matrix(X)
  Xsvd <- svd(X)
  if (is.complex(X)) 
    Xsvd$u <- Conj(Xsvd$u)
  Positive <- Xsvd$d > max(tol * Xsvd$d[1], 0)
  if (all(Positive)) 
    Xsvd$v %*% (1/Xsvd$d * t(Xsvd$u))
  else if (!any(Positive)) 
    array(0, dim(X)[2:1])
  else Xsvd$v[, Positive, drop = FALSE] %*% ((1/Xsvd$d[Positive]) * t(Xsvd$u[, Positive, drop = FALSE]))
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
glm.convert
list(`package:MASS` = function (object) 
{
  object$call[[1]] <- quote(stats::glm)
  if (is.null(object$link)) 
    object$link <- as.name("log")
  object$call$family <- call("negative.binomial", theta = object$theta, link = object$link)
  object$call$init.theta <- object$call$link <- NULL
  class(object) <- c("glm", "lm")
  object
}, function (object) 
{
  object$call[[1]] <- quote(stats::glm)
  if (is.null(object$link)) 
    object$link <- as.name("log")
  object$call$family <- call("negative.binomial", theta = object$theta, link = object$link)
  object$call$init.theta <- object$call$link <- NULL
  class(object) <- c("glm", "lm")
  object
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
glm.nb
list(`package:MASS` = function (formula, data, weights, subset, na.action, start = NULL, etastart, mustart, control = glm.control(...), method = "glm.fit", model = TRUE, x = FALSE, y = TRUE, contrasts = NULL, ..., init.theta, link = log) 
{
  loglik <- function(n, th, mu, y, w) sum(w * (lgamma(th + y) - lgamma(th) - lgamma(y + 1) + th * log(th) + y * log(mu + (y == 0)) - (th + y) * log(th + mu)))
  link <- substitute(link)
  fam0 <- if (missing(init.theta)) 
    do.call("poisson", list(link = link))
  else do.call("negative.binomial", list(theta = init.theta, link = link))
  mf <- Call <- match.call()
  m <- match(c("formula", "data", "subset", "weights", "na.action", "etastart", "mustart", "offset"), names(mf), 0)
  mf <- mf[c(1, m)]
  mf$drop.unused.levels <- TRUE
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval.parent(mf)
  Terms <- attr(mf, "terms")
  if (method == "model.frame") 
    return(mf)
  Y <- model.response(mf, "numeric")
  X <- if (!is.empty.model(Terms)) 
    model.matrix(Terms, mf, contrasts)
  else matrix(, NROW(Y), 0)
  w <- model.weights(mf)
  if (!length(w)) 
    w <- rep(1, nrow(mf))
  else if (any(w < 0)) 
    stop("negative weights not allowed")
  offset <- model.offset(mf)
  mustart <- model.extract(mf, "mustart")
  etastart <- model.extract(mf, "etastart")
  n <- length(Y)
  if (!missing(method)) {
    if (!exists(method, mode = "function")) 
      stop(gettextf("unimplemented method: %s", sQuote(method)), domain = NA)
    glm.fitter <- get(method)
  }
  else {
    method <- "glm.fit"
    glm.fitter <- stats::glm.fit
  }
  if (control$trace > 1) 
    message("Initial fit:")
  fit <- glm.fitter(x = X, y = Y, w = w, start = start, etastart = etastart, mustart = mustart, offset = offset, family = fam0, control = list(maxit = control$maxit, epsilon = control$epsilon, trace = control$trace > 1), intercept = attr(Terms, "intercept") > 0)
  class(fit) <- c("glm", "lm")
  mu <- fit$fitted.values
  th <- as.vector(theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace = control$trace > 2))
  if (control$trace > 1) 
    message(gettextf("Initial value for 'theta': %f", signif(th)), domain = NA)
  fam <- do.call("negative.binomial", list(theta = th, link = link))
  iter <- 0
  d1 <- sqrt(2 * max(1, fit$df.residual))
  d2 <- del <- 1
  g <- fam$linkfun
  Lm <- loglik(n, th, mu, Y, w)
  Lm0 <- Lm + 2 * d1
  while ((iter <- iter + 1) <= control$maxit && (abs(Lm0 - Lm)/d1 + abs(del)/d2) > control$epsilon) {
    eta <- g(mu)
    fit <- glm.fitter(x = X, y = Y, w = w, etastart = eta, offset = offset, family = fam, control = list(maxit = control$maxit, epsilon = control$epsilon, trace = control$trace > 1), intercept = attr(Terms, "intercept") > 0)
    t0 <- th
    th <- theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace = control$trace > 2)
    fam <- do.call("negative.binomial", list(theta = th, link = link))
    mu <- fit$fitted.values
    del <- t0 - th
    Lm0 <- Lm
    Lm <- loglik(n, th, mu, Y, w)
    if (control$trace) {
      Ls <- loglik(n, th, Y, Y, w)
      Dev <- 2 * (Ls - Lm)
      message(sprintf("Theta(%d) = %f, 2(Ls - Lm) = %f", iter, signif(th), signif(Dev)), domain = NA)
    }
  }
  if (!is.null(attr(th, "warn"))) 
    fit$th.warn <- attr(th, "warn")
  if (iter > control$maxit) {
    warning("alternation limit reached")
    fit$th.warn <- gettext("alternation limit reached")
  }
  if (length(offset) && attr(Terms, "intercept")) {
    null.deviance <- if (length(Terms)) 
      glm.fitter(X[, "(Intercept)", drop = FALSE], Y, w, offset = offset, family = fam, control = list(maxit = control$maxit, epsilon = control$epsilon, trace = control$trace > 1), intercept = TRUE)$deviance
    else fit$deviance
    fit$null.deviance <- null.deviance
  }
  class(fit) <- c("negbin", "glm", "lm")
  fit$terms <- Terms
  fit$formula <- as.vector(attr(Terms, "formula"))
  Call$init.theta <- signif(as.vector(th), 10)
  Call$link <- link
  fit$call <- Call
  if (model) 
    fit$model <- mf
  fit$na.action <- attr(mf, "na.action")
  if (x) 
    fit$x <- X
  if (!y) 
    fit$y <- NULL
  fit$theta <- as.vector(th)
  fit$SE.theta <- attr(th, "SE")
  fit$twologlik <- as.vector(2 * Lm)
  fit$aic <- -fit$twologlik + 2 * fit$rank + 2
  fit$contrasts <- attr(X, "contrasts")
  fit$xlevels <- .getXlevels(Terms, mf)
  fit$method <- method
  fit$control <- control
  fit$offset <- offset
  fit
}, function (formula, data, weights, subset, na.action, start = NULL, etastart, mustart, control = glm.control(...), method = "glm.fit", model = TRUE, x = FALSE, y = TRUE, contrasts = NULL, ..., init.theta, link = log) 
{
  loglik <- function(n, th, mu, y, w) sum(w * (lgamma(th + y) - lgamma(th) - lgamma(y + 1) + th * log(th) + y * log(mu + (y == 0)) - (th + y) * log(th + mu)))
  link <- substitute(link)
  fam0 <- if (missing(init.theta)) 
    do.call("poisson", list(link = link))
  else do.call("negative.binomial", list(theta = init.theta, link = link))
  mf <- Call <- match.call()
  m <- match(c("formula", "data", "subset", "weights", "na.action", "etastart", "mustart", "offset"), names(mf), 0)
  mf <- mf[c(1, m)]
  mf$drop.unused.levels <- TRUE
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval.parent(mf)
  Terms <- attr(mf, "terms")
  if (method == "model.frame") 
    return(mf)
  Y <- model.response(mf, "numeric")
  X <- if (!is.empty.model(Terms)) 
    model.matrix(Terms, mf, contrasts)
  else matrix(, NROW(Y), 0)
  w <- model.weights(mf)
  if (!length(w)) 
    w <- rep(1, nrow(mf))
  else if (any(w < 0)) 
    stop("negative weights not allowed")
  offset <- model.offset(mf)
  mustart <- model.extract(mf, "mustart")
  etastart <- model.extract(mf, "etastart")
  n <- length(Y)
  if (!missing(method)) {
    if (!exists(method, mode = "function")) 
      stop(gettextf("unimplemented method: %s", sQuote(method)), domain = NA)
    glm.fitter <- get(method)
  }
  else {
    method <- "glm.fit"
    glm.fitter <- stats::glm.fit
  }
  if (control$trace > 1) 
    message("Initial fit:")
  fit <- glm.fitter(x = X, y = Y, w = w, start = start, etastart = etastart, mustart = mustart, offset = offset, family = fam0, control = list(maxit = control$maxit, epsilon = control$epsilon, trace = control$trace > 1), intercept = attr(Terms, "intercept") > 0)
  class(fit) <- c("glm", "lm")
  mu <- fit$fitted.values
  th <- as.vector(theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace = control$trace > 2))
  if (control$trace > 1) 
    message(gettextf("Initial value for 'theta': %f", signif(th)), domain = NA)
  fam <- do.call("negative.binomial", list(theta = th, link = link))
  iter <- 0
  d1 <- sqrt(2 * max(1, fit$df.residual))
  d2 <- del <- 1
  g <- fam$linkfun
  Lm <- loglik(n, th, mu, Y, w)
  Lm0 <- Lm + 2 * d1
  while ((iter <- iter + 1) <= control$maxit && (abs(Lm0 - Lm)/d1 + abs(del)/d2) > control$epsilon) {
    eta <- g(mu)
    fit <- glm.fitter(x = X, y = Y, w = w, etastart = eta, offset = offset, family = fam, control = list(maxit = control$maxit, epsilon = control$epsilon, trace = control$trace > 1), intercept = attr(Terms, "intercept") > 0)
    t0 <- th
    th <- theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace = control$trace > 2)
    fam <- do.call("negative.binomial", list(theta = th, link = link))
    mu <- fit$fitted.values
    del <- t0 - th
    Lm0 <- Lm
    Lm <- loglik(n, th, mu, Y, w)
    if (control$trace) {
      Ls <- loglik(n, th, Y, Y, w)
      Dev <- 2 * (Ls - Lm)
      message(sprintf("Theta(%d) = %f, 2(Ls - Lm) = %f", iter, signif(th), signif(Dev)), domain = NA)
    }
  }
  if (!is.null(attr(th, "warn"))) 
    fit$th.warn <- attr(th, "warn")
  if (iter > control$maxit) {
    warning("alternation limit reached")
    fit$th.warn <- gettext("alternation limit reached")
  }
  if (length(offset) && attr(Terms, "intercept")) {
    null.deviance <- if (length(Terms)) 
      glm.fitter(X[, "(Intercept)", drop = FALSE], Y, w, offset = offset, family = fam, control = list(maxit = control$maxit, epsilon = control$epsilon, trace = control$trace > 1), intercept = TRUE)$deviance
    else fit$deviance
    fit$null.deviance <- null.deviance
  }
  class(fit) <- c("negbin", "glm", "lm")
  fit$terms <- Terms
  fit$formula <- as.vector(attr(Terms, "formula"))
  Call$init.theta <- signif(as.vector(th), 10)
  Call$link <- link
  fit$call <- Call
  if (model) 
    fit$model <- mf
  fit$na.action <- attr(mf, "na.action")
  if (x) 
    fit$x <- X
  if (!y) 
    fit$y <- NULL
  fit$theta <- as.vector(th)
  fit$SE.theta <- attr(th, "SE")
  fit$twologlik <- as.vector(2 * Lm)
  fit$aic <- -fit$twologlik + 2 * fit$rank + 2
  fit$contrasts <- attr(X, "contrasts")
  fit$xlevels <- .getXlevels(Terms, mf)
  fit$method <- method
  fit$control <- control
  fit$offset <- offset
  fit
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
glmmPQL
list(`package:MASS` = function (fixed, random, family, data, correlation, weights, control, niter = 10, verbose = TRUE, ...) 
{
  if (!requireNamespace("nlme", quietly = TRUE)) 
    stop("package 'nlme' is essential")
  if (is.character(family)) 
    family <- get(family)
  if (is.function(family)) 
    family <- family()
  if (is.null(family$family)) {
    print(family)
    stop("'family' not recognized")
  }
  m <- mcall <- Call <- match.call()
  nm <- names(m)[-1]
  keep <- is.element(nm, c("weights", "data", "subset", "na.action"))
  for (i in nm[!keep]) m[[i]] <- NULL
  allvars <- if (is.list(random)) 
    allvars <- c(all.vars(fixed), names(random), unlist(lapply(random, function(x) all.vars(formula(x)))))
  else c(all.vars(fixed), all.vars(random))
  Terms <- if (missing(data)) 
    terms(fixed)
  else terms(fixed, data = data)
  off <- attr(Terms, "offset")
  if (length(off <- attr(Terms, "offset"))) 
    allvars <- c(allvars, as.character(attr(Terms, "variables"))[off + 1])
  if (!missing(correlation) && !is.null(attr(correlation, "formula"))) 
    allvars <- c(allvars, all.vars(attr(correlation, "formula")))
  Call$fixed <- eval(fixed)
  Call$random <- eval(random)
  m$formula <- as.formula(paste("~", paste(allvars, collapse = "+")))
  environment(m$formula) <- environment(fixed)
  m$drop.unused.levels <- TRUE
  m[[1]] <- quote(stats::model.frame)
  mf <- eval.parent(m)
  off <- model.offset(mf)
  if (is.null(off)) 
    off <- 0
  wts <- model.weights(mf)
  if (is.null(wts)) 
    wts <- rep(1, nrow(mf))
  mf$wts <- wts
  fit0 <- glm(formula = fixed, family = family, data = mf, weights = wts, ...)
  w <- fit0$prior.weights
  eta <- fit0$linear.predictors
  zz <- eta + fit0$residuals - off
  wz <- fit0$weights
  fam <- family
  nm <- names(mcall)[-1]
  keep <- is.element(nm, c("fixed", "random", "data", "subset", "na.action", "control"))
  for (i in nm[!keep]) mcall[[i]] <- NULL
  fixed[[2]] <- quote(zz)
  mcall[["fixed"]] <- fixed
  mcall[[1]] <- quote(nlme::lme)
  mcall$random <- random
  mcall$method <- "ML"
  if (!missing(correlation)) 
    mcall$correlation <- correlation
  mcall$weights <- quote(nlme::varFixed(~invwt))
  mf$zz <- zz
  mf$invwt <- 1/wz
  mcall$data <- mf
  for (i in seq_len(niter)) {
    if (verbose) 
      message(gettextf("iteration %d", i), domain = NA)
    fit <- eval(mcall)
    etaold <- eta
    eta <- fitted(fit) + off
    if (sum((eta - etaold)^2) < 1e-06 * sum(eta^2)) 
      break
    mu <- fam$linkinv(eta)
    mu.eta.val <- fam$mu.eta(eta)
    mf$zz <- eta + (fit0$y - mu)/mu.eta.val - off
    wz <- w * mu.eta.val^2/fam$variance(mu)
    mf$invwt <- 1/wz
    mcall$data <- mf
  }
  attributes(fit$logLik) <- NULL
  fit$call <- Call
  fit$family <- family
  fit$logLik <- as.numeric(NA)
  oldClass(fit) <- c("glmmPQL", oldClass(fit))
  fit
}, function (fixed, random, family, data, correlation, weights, control, niter = 10, verbose = TRUE, ...) 
{
  if (!requireNamespace("nlme", quietly = TRUE)) 
    stop("package 'nlme' is essential")
  if (is.character(family)) 
    family <- get(family)
  if (is.function(family)) 
    family <- family()
  if (is.null(family$family)) {
    print(family)
    stop("'family' not recognized")
  }
  m <- mcall <- Call <- match.call()
  nm <- names(m)[-1]
  keep <- is.element(nm, c("weights", "data", "subset", "na.action"))
  for (i in nm[!keep]) m[[i]] <- NULL
  allvars <- if (is.list(random)) 
    allvars <- c(all.vars(fixed), names(random), unlist(lapply(random, function(x) all.vars(formula(x)))))
  else c(all.vars(fixed), all.vars(random))
  Terms <- if (missing(data)) 
    terms(fixed)
  else terms(fixed, data = data)
  off <- attr(Terms, "offset")
  if (length(off <- attr(Terms, "offset"))) 
    allvars <- c(allvars, as.character(attr(Terms, "variables"))[off + 1])
  if (!missing(correlation) && !is.null(attr(correlation, "formula"))) 
    allvars <- c(allvars, all.vars(attr(correlation, "formula")))
  Call$fixed <- eval(fixed)
  Call$random <- eval(random)
  m$formula <- as.formula(paste("~", paste(allvars, collapse = "+")))
  environment(m$formula) <- environment(fixed)
  m$drop.unused.levels <- TRUE
  m[[1]] <- quote(stats::model.frame)
  mf <- eval.parent(m)
  off <- model.offset(mf)
  if (is.null(off)) 
    off <- 0
  wts <- model.weights(mf)
  if (is.null(wts)) 
    wts <- rep(1, nrow(mf))
  mf$wts <- wts
  fit0 <- glm(formula = fixed, family = family, data = mf, weights = wts, ...)
  w <- fit0$prior.weights
  eta <- fit0$linear.predictors
  zz <- eta + fit0$residuals - off
  wz <- fit0$weights
  fam <- family
  nm <- names(mcall)[-1]
  keep <- is.element(nm, c("fixed", "random", "data", "subset", "na.action", "control"))
  for (i in nm[!keep]) mcall[[i]] <- NULL
  fixed[[2]] <- quote(zz)
  mcall[["fixed"]] <- fixed
  mcall[[1]] <- quote(nlme::lme)
  mcall$random <- random
  mcall$method <- "ML"
  if (!missing(correlation)) 
    mcall$correlation <- correlation
  mcall$weights <- quote(nlme::varFixed(~invwt))
  mf$zz <- zz
  mf$invwt <- 1/wz
  mcall$data <- mf
  for (i in seq_len(niter)) {
    if (verbose) 
      message(gettextf("iteration %d", i), domain = NA)
    fit <- eval(mcall)
    etaold <- eta
    eta <- fitted(fit) + off
    if (sum((eta - etaold)^2) < 1e-06 * sum(eta^2)) 
      break
    mu <- fam$linkinv(eta)
    mu.eta.val <- fam$mu.eta(eta)
    mf$zz <- eta + (fit0$y - mu)/mu.eta.val - off
    wz <- w * mu.eta.val^2/fam$variance(mu)
    mf$invwt <- 1/wz
    mcall$data <- mf
  }
  attributes(fit$logLik) <- NULL
  fit$call <- Call
  fit$family <- family
  fit$logLik <- as.numeric(NA)
  oldClass(fit) <- c("glmmPQL", oldClass(fit))
  fit
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
hills
list(`package:MASS` = list(dist = c(2.5, 6, 6, 7.5, 8, 8, 16, 6, 5, 6, 28, 5, 9.5, 6, 4.5, 10, 14, 3, 4.5, 5.5, 3, 3.5, 6, 2, 3, 4, 6, 5, 6.5, 5, 10, 6, 18, 4.5, 20), climb = c(650, 2500, 900, 800, 3070, 2866, 7500, 800, 800, 650, 2100, 2000, 2200, 500, 1500, 3000, 2200, 350, 1000, 600, 300, 1500, 2200, 900, 600, 2000, 800, 950, 1750, 500, 4400, 600, 5200, 850, 5000), time = c(16.083, 48.35, 33.65, 45.6, 62.267, 73.217, 204.617, 36.367, 29.75, 39.75, 192.667, 43.05, 65, 44.133, 26.933, 72.25, 98.417, 
                                                                                                                                                                                                                                                                                                                                                                                            78.65, 17.417, 32.567, 15.95, 27.9, 47.633, 17.933, 18.683, 26.217, 34.433, 28.567, 50.5, 20.95, 85.583, 32.383, 170.25, 28.1, 159.833)))
package:MASS
TRUE
FALSE
hist.FD
list(`package:MASS` = function (x, prob = TRUE, xlab = deparse(substitute(x)), ...) 
  invisible(hist(x, nclass.FD(x), prob = prob, xlab = xlab, ...)), function (x, prob = TRUE, xlab = deparse(substitute(x)), ...) 
    invisible(hist(x, nclass.FD(x), prob = prob, xlab = xlab, ...)), function (x, prob = TRUE, xlab = deparse(substitute(x)), ...) 
      invisible(hist(x, nclass.FD(x), prob = prob, xlab = xlab, ...)))
c("package:MASS", "registered S3 method for hist from namespace MASS", "namespace:MASS")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
hist.scott
list(`package:MASS` = function (x, prob = TRUE, xlab = deparse(substitute(x)), ...) 
  invisible(hist(x, nclass.scott(x), prob = prob, xlab = xlab, ...)), function (x, prob = TRUE, xlab = deparse(substitute(x)), ...) 
    invisible(hist(x, nclass.scott(x), prob = prob, xlab = xlab, ...)), function (x, prob = TRUE, xlab = deparse(substitute(x)), ...) 
      invisible(hist(x, nclass.scott(x), prob = prob, xlab = xlab, ...)))
c("package:MASS", "registered S3 method for hist from namespace MASS", "namespace:MASS")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
housing
list(`package:MASS` = list(Sat = c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3), Infl = c(1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3), Type = c(1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4), Cont = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Freq = c(21, 21, 28, 34, 22, 36, 10, 11, 36, 61, 23, 17, 43, 35, 40, 26, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            18, 54, 13, 9, 10, 8, 8, 12, 6, 7, 9, 18, 6, 7, 15, 13, 13, 7, 5, 11, 14, 19, 37, 17, 23, 40, 3, 5, 23, 78, 46, 43, 48, 45, 86, 15, 25, 62, 20, 23, 20, 10, 22, 24, 7, 10, 21, 57, 23, 13, 31, 21, 13, 5, 6, 13)))
package:MASS
TRUE
FALSE
huber
list(`package:MASS` = function (y, k = 1.5, tol = 1e-06) 
{
  y <- y[!is.na(y)]
  n <- length(y)
  mu <- median(y)
  s <- mad(y)
  if (s == 0) 
    stop("cannot estimate scale: MAD is zero for this sample")
  repeat {
    yy <- pmin(pmax(mu - k * s, y), mu + k * s)
    mu1 <- sum(yy)/n
    if (abs(mu - mu1) < tol * s) 
      break
    mu <- mu1
  }
  list(mu = mu, s = s)
}, function (y, k = 1.5, tol = 1e-06) 
{
  y <- y[!is.na(y)]
  n <- length(y)
  mu <- median(y)
  s <- mad(y)
  if (s == 0) 
    stop("cannot estimate scale: MAD is zero for this sample")
  repeat {
    yy <- pmin(pmax(mu - k * s, y), mu + k * s)
    mu1 <- sum(yy)/n
    if (abs(mu - mu1) < tol * s) 
      break
    mu <- mu1
  }
  list(mu = mu, s = s)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
hubers
list(`package:MASS` = function (y, k = 1.5, mu, s, initmu = median(y), tol = 1e-06) 
{
  mmu <- missing(mu)
  ms <- missing(s)
  y <- y[!is.na(y)]
  n <- length(y)
  if (mmu) {
    mu0 <- initmu
    n1 <- n - 1
  }
  else {
    mu0 <- mu
    mu1 <- mu
    n1 <- n
  }
  if (ms) {
    s0 <- mad(y)
    if (s0 == 0) 
      return(list(mu = mu0, s = 0))
  }
  else {
    s0 <- s
    s1 <- s
  }
  th <- 2 * pnorm(k) - 1
  beta <- th + k^2 * (1 - th) - 2 * k * dnorm(k)
  for (i in 1:30) {
    yy <- pmin(pmax(mu0 - k * s0, y), mu0 + k * s0)
    if (mmu) 
      mu1 <- sum(yy)/n
    if (ms) {
      ss <- sum((yy - mu1)^2)/n1
      s1 <- sqrt(ss/beta)
    }
    if ((abs(mu0 - mu1) < tol * s0) && abs(s0 - s1) < tol * s0) 
      break
    mu0 <- mu1
    s0 <- s1
  }
  list(mu = mu0, s = s0)
}, function (y, k = 1.5, mu, s, initmu = median(y), tol = 1e-06) 
{
  mmu <- missing(mu)
  ms <- missing(s)
  y <- y[!is.na(y)]
  n <- length(y)
  if (mmu) {
    mu0 <- initmu
    n1 <- n - 1
  }
  else {
    mu0 <- mu
    mu1 <- mu
    n1 <- n
  }
  if (ms) {
    s0 <- mad(y)
    if (s0 == 0) 
      return(list(mu = mu0, s = 0))
  }
  else {
    s0 <- s
    s1 <- s
  }
  th <- 2 * pnorm(k) - 1
  beta <- th + k^2 * (1 - th) - 2 * k * dnorm(k)
  for (i in 1:30) {
    yy <- pmin(pmax(mu0 - k * s0, y), mu0 + k * s0)
    if (mmu) 
      mu1 <- sum(yy)/n
    if (ms) {
      ss <- sum((yy - mu1)^2)/n1
      s1 <- sqrt(ss/beta)
    }
    if ((abs(mu0 - mu1) < tol * s0) && abs(s0 - s1) < tol * s0) 
      break
    mu0 <- mu1
    s0 <- s1
  }
  list(mu = mu0, s = s0)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
immer
list(`package:MASS` = list(Loc = c(5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2), Var = c(1, 3, 5, 4, 2, 1, 3, 5, 4, 2, 1, 3, 5, 4, 2, 1, 3, 5, 4, 2, 1, 3, 5, 4, 2, 1, 3, 5, 4, 2), Y1 = c(81, 105.4, 119.7, 109.7, 98.3, 146.6, 142, 150.7, 191.5, 145.7, 82.3, 77.3, 78.4, 131.3, 89.6, 119.8, 121.4, 124, 140.8, 124.8, 98.9, 89, 69.1, 89.3, 104.1, 86.9, 77.1, 78.9, 101.8, 96), Y2 = c(80.7, 82.3, 80.4, 87.2, 84.2, 100.4, 115.5, 112.2, 147.7, 108.1, 103.1, 105.1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                          116.5, 139.9, 129.6, 98.9, 61.9, 96.2, 125.5, 75.7, 66.4, 49.9, 96.7, 61.9, 80.3, 67.7, 66.7, 67.4, 91.8, 94.1)))
package:MASS
TRUE
FALSE
Insurance
list(`package:MASS` = list(District = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4), Group = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4), Age = c(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4), Holders = c(197, 264, 246, 1680, 284, 536, 696, 3582, 133, 286, 355, 1640, 24, 71, 99, 452, 85, 139, 151, 931, 149, 313, 419, 2443, 66, 175, 221, 1110, 9, 48, 72, 322, 35, 73, 89, 648, 53, 155, 240, 1635, 24, 78, 121, 692, 7, 29, 43, 245, 20, 33, 40, 316, 31, 81, 122, 724, 18, 39, 68, 344, 3, 16, 25, 114), Claims = c(38, 35, 20, 156, 63, 84, 89, 400, 19, 52, 74, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   233, 4, 18, 19, 77, 22, 19, 22, 87, 25, 51, 49, 290, 14, 46, 39, 143, 4, 15, 12, 53, 5, 11, 10, 67, 10, 24, 37, 187, 8, 19, 24, 101, 3, 2, 8, 37, 2, 5, 4, 36, 7, 10, 22, 102, 5, 7, 16, 63, 0, 6, 8, 33)))
package:MASS
TRUE
FALSE
is.fractions
list(`package:MASS` = function (f) 
  inherits(f, "fractions"), function (f) 
    inherits(f, "fractions"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
isoMDS
list(`package:MASS` = function (d, y = cmdscale(d, k), k = 2, maxit = 50, trace = TRUE, tol = 0.001, p = 2) 
{
  if (any(!is.finite(d)) && missing(y)) 
    stop("an initial configuration must be supplied with NA/Infs in 'd'")
  if (!is.matrix(y)) 
    stop("'y' must be a matrix")
  if (is.null(n <- attr(d, "Size"))) {
    x <- as.matrix(d)
    if ((n <- nrow(x)) != ncol(x)) 
      stop("distances must be result of 'dist' or a square matrix")
    rn <- rownames(x)
  }
  else {
    x <- matrix(0, n, n)
    x[row(x) > col(x)] <- d
    x <- x + t(x)
    rn <- attr(d, "Labels")
  }
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid size")
  ab <- x[row(x) < col(x)] <= 0
  if (any(ab, na.rm = TRUE)) {
    ab <- !is.na(ab) & ab
    aa <- cbind(as.vector(row(x)), as.vector(col(x)))[row(x) < col(x), ]
    aa <- aa[ab, , drop = FALSE]
    stop(gettextf("zero or negative distance between objects %d and %d", aa[1, 1], aa[1, 2]), domain = NA)
  }
  nas <- is.na(x)
  diag(nas) <- FALSE
  if (any(rowSums(!nas) < 2)) 
    stop("not enough non-missing data")
  if (any(dim(y) != c(n, k))) 
    stop("invalid initial configuration")
  if (any(!is.finite(y))) 
    stop("initial configuration must be complete")
  dis <- x[row(x) > col(x)]
  ord <- order(dis)
  nd <- sum(!is.na(ord))
  on.exit(.C(VR_mds_unload))
  .C(VR_mds_init_data, as.integer(nd), as.integer(k), n, as.integer(ord - 1), as.integer(order(ord) - 1), as.double(y), as.double(p))
  tmp <- .C(VR_mds_dovm, val = double(1), as.integer(maxit), as.integer(trace), y = as.double(y), as.double(tol))
  points <- matrix(tmp$y, , k)
  dimnames(points) <- list(rn, NULL)
  list(points = points, stress = tmp$val)
}, function (d, y = cmdscale(d, k), k = 2, maxit = 50, trace = TRUE, tol = 0.001, p = 2) 
{
  if (any(!is.finite(d)) && missing(y)) 
    stop("an initial configuration must be supplied with NA/Infs in 'd'")
  if (!is.matrix(y)) 
    stop("'y' must be a matrix")
  if (is.null(n <- attr(d, "Size"))) {
    x <- as.matrix(d)
    if ((n <- nrow(x)) != ncol(x)) 
      stop("distances must be result of 'dist' or a square matrix")
    rn <- rownames(x)
  }
  else {
    x <- matrix(0, n, n)
    x[row(x) > col(x)] <- d
    x <- x + t(x)
    rn <- attr(d, "Labels")
  }
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid size")
  ab <- x[row(x) < col(x)] <= 0
  if (any(ab, na.rm = TRUE)) {
    ab <- !is.na(ab) & ab
    aa <- cbind(as.vector(row(x)), as.vector(col(x)))[row(x) < col(x), ]
    aa <- aa[ab, , drop = FALSE]
    stop(gettextf("zero or negative distance between objects %d and %d", aa[1, 1], aa[1, 2]), domain = NA)
  }
  nas <- is.na(x)
  diag(nas) <- FALSE
  if (any(rowSums(!nas) < 2)) 
    stop("not enough non-missing data")
  if (any(dim(y) != c(n, k))) 
    stop("invalid initial configuration")
  if (any(!is.finite(y))) 
    stop("initial configuration must be complete")
  dis <- x[row(x) > col(x)]
  ord <- order(dis)
  nd <- sum(!is.na(ord))
  on.exit(.C(VR_mds_unload))
  .C(VR_mds_init_data, as.integer(nd), as.integer(k), n, as.integer(ord - 1), as.integer(order(ord) - 1), as.double(y), as.double(p))
  tmp <- .C(VR_mds_dovm, val = double(1), as.integer(maxit), as.integer(trace), y = as.double(y), as.double(tol))
  points <- matrix(tmp$y, , k)
  dimnames(points) <- list(rn, NULL)
  list(points = points, stress = tmp$val)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
kde2d
list(`package:MASS` = function (x, y, h, n = 25, lims = c(range(x), range(y))) 
{
  nx <- length(x)
  if (length(y) != nx) 
    stop("data vectors must be the same length")
  if (any(!is.finite(x)) || any(!is.finite(y))) 
    stop("missing or infinite values in the data are not allowed")
  if (any(!is.finite(lims))) 
    stop("only finite values are allowed in 'lims'")
  n <- rep(n, length.out = 2)
  gx <- seq.int(lims[1], lims[2], length.out = n[1])
  gy <- seq.int(lims[3], lims[4], length.out = n[2])
  h <- if (missing(h)) 
    c(bandwidth.nrd(x), bandwidth.nrd(y))
  else rep(h, length.out = 2)
  if (any(h <= 0)) 
    stop("bandwidths must be strictly positive")
  h <- h/4
  ax <- outer(gx, x, "-")/h[1]
  ay <- outer(gy, y, "-")/h[2]
  z <- tcrossprod(matrix(dnorm(ax), , nx), matrix(dnorm(ay), , nx))/(nx * h[1] * h[2])
  list(x = gx, y = gy, z = z)
}, function (x, y, h, n = 25, lims = c(range(x), range(y))) 
{
  nx <- length(x)
  if (length(y) != nx) 
    stop("data vectors must be the same length")
  if (any(!is.finite(x)) || any(!is.finite(y))) 
    stop("missing or infinite values in the data are not allowed")
  if (any(!is.finite(lims))) 
    stop("only finite values are allowed in 'lims'")
  n <- rep(n, length.out = 2)
  gx <- seq.int(lims[1], lims[2], length.out = n[1])
  gy <- seq.int(lims[3], lims[4], length.out = n[2])
  h <- if (missing(h)) 
    c(bandwidth.nrd(x), bandwidth.nrd(y))
  else rep(h, length.out = 2)
  if (any(h <= 0)) 
    stop("bandwidths must be strictly positive")
  h <- h/4
  ax <- outer(gx, x, "-")/h[1]
  ay <- outer(gy, y, "-")/h[2]
  z <- tcrossprod(matrix(dnorm(ax), , nx), matrix(dnorm(ay), , nx))/(nx * h[1] * h[2])
  list(x = gx, y = gy, z = z)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
lda
list(`package:MASS` = function (x, ...) 
  UseMethod("lda"), function (x, ...) 
    UseMethod("lda"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
ldahist
list(`package:MASS` = function (data, g, nbins = 25, h, x0 = -h/1000, breaks, xlim = range(breaks), ymax = 0, width, type = c("histogram", "density", "both"), sep = (type != "density"), col = 5, xlab = deparse(substitute(data)), bty = "n", ...) 
{
  xlab
  type <- match.arg(type)
  data <- data[!is.na(data)]
  g <- g[!is.na(data)]
  counts <- table(g)
  groups <- names(counts)[counts > 0]
  if (missing(breaks)) {
    if (missing(h)) 
      h <- diff(pretty(data, nbins))[1]
    first <- floor((min(data) - x0)/h)
    last <- ceiling((max(data) - x0)/h)
    breaks <- x0 + h * c(first:last)
  }
  if (type == "histogram" || type == "both") {
    if (any(diff(breaks) <= 0)) 
      stop("'breaks' must be strictly increasing")
    if (min(data) < min(breaks) || max(data) > max(breaks)) 
      stop("'breaks' do not cover the data")
    est <- vector("list", length(groups))
    names(est) <- groups
    for (grp in groups) {
      bin <- cut(data[g == grp], breaks, include.lowest = TRUE)
      est1 <- tabulate(bin, length(levels(bin)))
      est1 <- est1/(diff(breaks) * length(data[g == grp]))
      ymax <- max(ymax, est1)
      est[[grp]] <- est1
    }
  }
  if (type == "density" || type == "both") {
    xd <- vector("list", length(groups))
    for (grp in groups) {
      if (missing(width)) 
        width <- width.SJ(data[g == grp])
      xd1 <- density(data[g == grp], n = 200, width = width, from = xlim[1], to = xlim[2])
      ymax <- max(ymax, xd1$y)
      xd[[grp]] <- xd1
    }
  }
  dev.hold()
  on.exit(dev.flush())
  if (!sep) 
    plot(xlim, c(0, ymax), type = "n", xlab = xlab, ylab = "", bty = bty)
  else {
    oldpar <- par(mfrow = c(length(groups), 1))
    on.exit(par(oldpar), add = TRUE)
  }
  for (grp in groups) {
    if (sep) 
      plot(xlim, c(0, ymax), type = "n", xlab = paste("group", grp), ylab = "", bty = bty)
    if (type == "histogram" || type == "both") {
      n <- length(breaks)
      rect(breaks[-n], 0, breaks[-1], est[[grp]], col = col, ...)
    }
    if (type == "density" || type == "both") 
      lines(xd[[grp]])
  }
  invisible()
}, function (data, g, nbins = 25, h, x0 = -h/1000, breaks, xlim = range(breaks), ymax = 0, width, type = c("histogram", "density", "both"), sep = (type != "density"), col = 5, xlab = deparse(substitute(data)), bty = "n", ...) 
{
  xlab
  type <- match.arg(type)
  data <- data[!is.na(data)]
  g <- g[!is.na(data)]
  counts <- table(g)
  groups <- names(counts)[counts > 0]
  if (missing(breaks)) {
    if (missing(h)) 
      h <- diff(pretty(data, nbins))[1]
    first <- floor((min(data) - x0)/h)
    last <- ceiling((max(data) - x0)/h)
    breaks <- x0 + h * c(first:last)
  }
  if (type == "histogram" || type == "both") {
    if (any(diff(breaks) <= 0)) 
      stop("'breaks' must be strictly increasing")
    if (min(data) < min(breaks) || max(data) > max(breaks)) 
      stop("'breaks' do not cover the data")
    est <- vector("list", length(groups))
    names(est) <- groups
    for (grp in groups) {
      bin <- cut(data[g == grp], breaks, include.lowest = TRUE)
      est1 <- tabulate(bin, length(levels(bin)))
      est1 <- est1/(diff(breaks) * length(data[g == grp]))
      ymax <- max(ymax, est1)
      est[[grp]] <- est1
    }
  }
  if (type == "density" || type == "both") {
    xd <- vector("list", length(groups))
    for (grp in groups) {
      if (missing(width)) 
        width <- width.SJ(data[g == grp])
      xd1 <- density(data[g == grp], n = 200, width = width, from = xlim[1], to = xlim[2])
      ymax <- max(ymax, xd1$y)
      xd[[grp]] <- xd1
    }
  }
  dev.hold()
  on.exit(dev.flush())
  if (!sep) 
    plot(xlim, c(0, ymax), type = "n", xlab = xlab, ylab = "", bty = bty)
  else {
    oldpar <- par(mfrow = c(length(groups), 1))
    on.exit(par(oldpar), add = TRUE)
  }
  for (grp in groups) {
    if (sep) 
      plot(xlim, c(0, ymax), type = "n", xlab = paste("group", grp), ylab = "", bty = bty)
    if (type == "histogram" || type == "both") {
      n <- length(breaks)
      rect(breaks[-n], 0, breaks[-1], est[[grp]], col = col, ...)
    }
    if (type == "density" || type == "both") 
      lines(xd[[grp]])
  }
  invisible()
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
leuk
list(`package:MASS` = list(wbc = c(2300, 750, 4300, 2600, 6000, 10500, 10000, 17000, 5400, 7000, 9400, 32000, 35000, 100000, 100000, 52000, 100000, 4400, 3000, 4000, 1500, 9000, 5300, 10000, 19000, 27000, 28000, 31000, 26000, 21000, 79000, 100000, 100000), ag = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), time = c(65, 156, 100, 134, 16, 108, 121, 4, 39, 143, 56, 26, 22, 1, 1, 5, 65, 56, 65, 17, 7, 16, 22, 3, 4, 2, 3, 8, 4, 3, 30, 4, 43)))
package:MASS
TRUE
FALSE
lm.gls
list(`package:MASS` = function (formula, data, W, subset, na.action, inverse = FALSE, method = "qr", model = FALSE, x = FALSE, y = FALSE, contrasts = NULL, ...) 
{
  call <- match.call()
  m <- match.call(expand.dots = FALSE)
  m$W <- m$inverse <- m$method <- m$model <- m$x <- m$y <- m$contrasts <- m$... <- NULL
  m[[1]] <- quote(stats::model.frame)
  m <- eval.parent(m)
  if (method == "model.frame") 
    return(m)
  Terms <- attr(m, "terms")
  Y <- model.response(m)
  X <- model.matrix(Terms, m, contrasts)
  n <- nrow(X)
  if (any(dim(W) != c(n, n))) 
    stop("dim(W) is not correct")
  eW <- eigen(W, TRUE)
  d <- eW$values
  if (any(d <= 0)) 
    stop("'W' is not positive definite")
  A <- diag(d^ifelse(inverse, -0.5, 0.5)) %*% t(eW$vector)
  Ainv <- eW$vector %*% diag(d^ifelse(inverse, 0.5, -0.5))
  fit <- lm.fit(A %*% X, A %*% Y, method = method, ...)
  fit$fitted.values <- drop(Ainv %*% fit$fitted.values)
  fit$residuals <- drop(Ainv %*% fit$residuals)
  fit$terms <- Terms
  fit$call <- call
  if (model) 
    fit$model <- m
  if (x) 
    fit$x <- X
  if (y) 
    fit$y <- Y
  fit$na.action <- attr(m, "na.action")
  class(fit) <- "lm.gls"
  fit$xlevels <- .getXlevels(Terms, m)
  fit$contrasts <- attr(X, "contrasts")
  fit
}, function (formula, data, W, subset, na.action, inverse = FALSE, method = "qr", model = FALSE, x = FALSE, y = FALSE, contrasts = NULL, ...) 
{
  call <- match.call()
  m <- match.call(expand.dots = FALSE)
  m$W <- m$inverse <- m$method <- m$model <- m$x <- m$y <- m$contrasts <- m$... <- NULL
  m[[1]] <- quote(stats::model.frame)
  m <- eval.parent(m)
  if (method == "model.frame") 
    return(m)
  Terms <- attr(m, "terms")
  Y <- model.response(m)
  X <- model.matrix(Terms, m, contrasts)
  n <- nrow(X)
  if (any(dim(W) != c(n, n))) 
    stop("dim(W) is not correct")
  eW <- eigen(W, TRUE)
  d <- eW$values
  if (any(d <= 0)) 
    stop("'W' is not positive definite")
  A <- diag(d^ifelse(inverse, -0.5, 0.5)) %*% t(eW$vector)
  Ainv <- eW$vector %*% diag(d^ifelse(inverse, 0.5, -0.5))
  fit <- lm.fit(A %*% X, A %*% Y, method = method, ...)
  fit$fitted.values <- drop(Ainv %*% fit$fitted.values)
  fit$residuals <- drop(Ainv %*% fit$residuals)
  fit$terms <- Terms
  fit$call <- call
  if (model) 
    fit$model <- m
  if (x) 
    fit$x <- X
  if (y) 
    fit$y <- Y
  fit$na.action <- attr(m, "na.action")
  class(fit) <- "lm.gls"
  fit$xlevels <- .getXlevels(Terms, m)
  fit$contrasts <- attr(X, "contrasts")
  fit
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
lm.ridge
list(`package:MASS` = function (formula, data, subset, na.action, lambda = 0, model = FALSE, x = FALSE, y = FALSE, contrasts = NULL, ...) 
{
  m <- match.call(expand.dots = FALSE)
  m$model <- m$x <- m$y <- m$contrasts <- m$... <- m$lambda <- NULL
  m[[1]] <- quote(stats::model.frame)
  m <- eval.parent(m)
  Terms <- attr(m, "terms")
  Y <- model.response(m)
  X <- model.matrix(Terms, m, contrasts)
  n <- nrow(X)
  p <- ncol(X)
  offset <- model.offset(m)
  if (!is.null(offset)) 
    Y <- Y - offset
  if (Inter <- attr(Terms, "intercept")) {
    Xm <- colMeans(X[, -Inter])
    Ym <- mean(Y)
    p <- p - 1
    X <- X[, -Inter] - rep(Xm, rep(n, p))
    Y <- Y - Ym
  }
  else Ym <- Xm <- NA
  Xscale <- drop(rep(1/n, n) %*% X^2)^0.5
  X <- X/rep(Xscale, rep(n, p))
  Xs <- svd(X)
  rhs <- t(Xs$u) %*% Y
  d <- Xs$d
  lscoef <- Xs$v %*% (rhs/d)
  lsfit <- X %*% lscoef
  resid <- Y - lsfit
  s2 <- sum(resid^2)/(n - p - Inter)
  HKB <- (p - 2) * s2/sum(lscoef^2)
  LW <- (p - 2) * s2 * n/sum(lsfit^2)
  k <- length(lambda)
  dx <- length(d)
  div <- d^2 + rep(lambda, rep(dx, k))
  a <- drop(d * rhs)/div
  dim(a) <- c(dx, k)
  coef <- Xs$v %*% a
  dimnames(coef) <- list(names(Xscale), format(lambda))
  GCV <- colSums((Y - X %*% coef)^2)/(n - colSums(matrix(d^2/div, dx)))^2
  res <- list(coef = drop(coef), scales = Xscale, Inter = Inter, lambda = lambda, ym = Ym, xm = Xm, GCV = GCV, kHKB = HKB, kLW = LW)
  class(res) <- "ridgelm"
  res
}, function (formula, data, subset, na.action, lambda = 0, model = FALSE, x = FALSE, y = FALSE, contrasts = NULL, ...) 
{
  m <- match.call(expand.dots = FALSE)
  m$model <- m$x <- m$y <- m$contrasts <- m$... <- m$lambda <- NULL
  m[[1]] <- quote(stats::model.frame)
  m <- eval.parent(m)
  Terms <- attr(m, "terms")
  Y <- model.response(m)
  X <- model.matrix(Terms, m, contrasts)
  n <- nrow(X)
  p <- ncol(X)
  offset <- model.offset(m)
  if (!is.null(offset)) 
    Y <- Y - offset
  if (Inter <- attr(Terms, "intercept")) {
    Xm <- colMeans(X[, -Inter])
    Ym <- mean(Y)
    p <- p - 1
    X <- X[, -Inter] - rep(Xm, rep(n, p))
    Y <- Y - Ym
  }
  else Ym <- Xm <- NA
  Xscale <- drop(rep(1/n, n) %*% X^2)^0.5
  X <- X/rep(Xscale, rep(n, p))
  Xs <- svd(X)
  rhs <- t(Xs$u) %*% Y
  d <- Xs$d
  lscoef <- Xs$v %*% (rhs/d)
  lsfit <- X %*% lscoef
  resid <- Y - lsfit
  s2 <- sum(resid^2)/(n - p - Inter)
  HKB <- (p - 2) * s2/sum(lscoef^2)
  LW <- (p - 2) * s2 * n/sum(lsfit^2)
  k <- length(lambda)
  dx <- length(d)
  div <- d^2 + rep(lambda, rep(dx, k))
  a <- drop(d * rhs)/div
  dim(a) <- c(dx, k)
  coef <- Xs$v %*% a
  dimnames(coef) <- list(names(Xscale), format(lambda))
  GCV <- colSums((Y - X %*% coef)^2)/(n - colSums(matrix(d^2/div, dx)))^2
  res <- list(coef = drop(coef), scales = Xscale, Inter = Inter, lambda = lambda, ym = Ym, xm = Xm, GCV = GCV, kHKB = HKB, kLW = LW)
  class(res) <- "ridgelm"
  res
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
lmsreg
list(`package:MASS` = function (...) 
{
  oc <- sys.call()
  oc$method <- "lms"
  oc[[1]] <- quote(MASS::lqs)
  eval.parent(oc)
}, function (...) 
{
  oc <- sys.call()
  oc$method <- "lms"
  oc[[1]] <- quote(MASS::lqs)
  eval.parent(oc)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
lmwork
list(`package:MASS` = function (object) 
{
  resid <- object$residuals
  hat <- lm.influence(object, do.coef = FALSE)$hat
  hat <- hat[hat > 0]
  ok <- !(is.na(resid))
  n.miss <- sum(!ok)
  if (n.miss) 
    warning(sprintf(ngettext(n.miss, "%d missing observation deleted", "%d missing observations deleted"), n.miss), domain = NA)
  resid <- resid[ok]
  n <- length(resid)
  p <- object$rank
  rdf <- object$df.residual
  if (is.null(rdf)) 
    rdf <- n - p
  if (!is.null(object$weights)) {
    wt <- object$weights[ok]
    resid <- resid * wt^0.5
    excl <- wt == 0
    if (any(excl)) {
      warning(sprintf(ngettext(sum(excl), "%d row with zero weights not counted", "%d rows with zero weights not counted"), sum(excl)), domain = NA)
      resid <- resid[!excl]
      if (is.null(object$df.resid)) 
        rdf <- rdf - sum(excl)
    }
  }
  stdres <- studres <- resid
  if (n > p) {
    stddev <- sqrt(sum(resid^2)/rdf)
    sr <- resid/(sqrt(1 - hat) * stddev)
    stdres <- sr
    studres <- sr/sqrt((n - p - sr^2)/(n - p - 1))
    if (!is.null(object$na.action)) {
      stdres <- naresid(object$na.action, stdres)
      studres <- naresid(object$na.action, studres)
    }
  }
  else stddev <- stdres[] <- studres[] <- NA
  list(stddev = stddev, stdres = stdres, studres = studres)
}, function (object) 
{
  resid <- object$residuals
  hat <- lm.influence(object, do.coef = FALSE)$hat
  hat <- hat[hat > 0]
  ok <- !(is.na(resid))
  n.miss <- sum(!ok)
  if (n.miss) 
    warning(sprintf(ngettext(n.miss, "%d missing observation deleted", "%d missing observations deleted"), n.miss), domain = NA)
  resid <- resid[ok]
  n <- length(resid)
  p <- object$rank
  rdf <- object$df.residual
  if (is.null(rdf)) 
    rdf <- n - p
  if (!is.null(object$weights)) {
    wt <- object$weights[ok]
    resid <- resid * wt^0.5
    excl <- wt == 0
    if (any(excl)) {
      warning(sprintf(ngettext(sum(excl), "%d row with zero weights not counted", "%d rows with zero weights not counted"), sum(excl)), domain = NA)
      resid <- resid[!excl]
      if (is.null(object$df.resid)) 
        rdf <- rdf - sum(excl)
    }
  }
  stdres <- studres <- resid
  if (n > p) {
    stddev <- sqrt(sum(resid^2)/rdf)
    sr <- resid/(sqrt(1 - hat) * stddev)
    stdres <- sr
    studres <- sr/sqrt((n - p - sr^2)/(n - p - 1))
    if (!is.null(object$na.action)) {
      stdres <- naresid(object$na.action, stdres)
      studres <- naresid(object$na.action, studres)
    }
  }
  else stddev <- stdres[] <- studres[] <- NA
  list(stddev = stddev, stdres = stdres, studres = studres)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
loglm
list(`package:MASS` = function (formula, data, subset, na.action, ...) 
{
  .call <- match.call()
  if (missing(data) || inherits(data, "data.frame")) {
    m <- match.call(expand.dots = FALSE)
    m$... <- NULL
    m[[1]] <- quote(stats::model.frame)
    data <- eval.parent(m)
    .formula <- as.formula(attr(data, "terms"))
  }
  else {
    trms <- attr(data, "terms") <- terms(formula <- denumerate(formula))
    .formula <- renumerate(as.formula(trms))
  }
  loglm1(formula, data, ..., .call = .call, .formula = .formula)
}, function (formula, data, subset, na.action, ...) 
{
  .call <- match.call()
  if (missing(data) || inherits(data, "data.frame")) {
    m <- match.call(expand.dots = FALSE)
    m$... <- NULL
    m[[1]] <- quote(stats::model.frame)
    data <- eval.parent(m)
    .formula <- as.formula(attr(data, "terms"))
  }
  else {
    trms <- attr(data, "terms") <- terms(formula <- denumerate(formula))
    .formula <- renumerate(as.formula(trms))
  }
  loglm1(formula, data, ..., .call = .call, .formula = .formula)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
loglm1
list(`package:MASS` = function (formula, data, ...) 
  UseMethod("loglm1", data), function (formula, data, ...) 
    UseMethod("loglm1", data))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
logtrans
list(`package:MASS` = function (object, ...) 
  UseMethod("logtrans"), function (object, ...) 
    UseMethod("logtrans"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
lqs
list(`package:MASS` = function (x, ...) 
  UseMethod("lqs"), function (x, ...) 
    UseMethod("lqs"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
lqs.formula
list(`package:MASS` = function (formula, data, ..., method = c("lts", "lqs", "lms", "S", "model.frame"), subset, na.action, model = TRUE, x.ret = FALSE, y.ret = FALSE, contrasts = NULL) 
{
  method <- match.arg(method)
  mf <- match.call(expand.dots = FALSE)
  mf$method <- mf$contrasts <- mf$model <- mf$x.ret <- mf$y.ret <- mf$... <- NULL
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval.parent(mf)
  if (method == "model.frame") 
    return(mf)
  mt <- attr(mf, "terms")
  y <- model.extract(mf, "response")
  offset <- model.offset(mf)
  if (!is.null(offset)) 
    y <- y - offset
  x <- model.matrix(mt, mf, contrasts)
  contr <- attr(x, "contrasts")
  xint <- match("(Intercept)", colnames(x), nomatch = 0)
  if (xint) 
    x <- x[, -xint, drop = FALSE]
  fit <- lqs.default(x, y, intercept = (xint > 0), method = method, ...)
  fit$terms <- mt
  fit$call <- match.call()
  fit$contrasts <- contr
  fit$xlevels <- .getXlevels(mt, mf)
  fit$na.action <- attr(mf, "na.action")
  if (model) 
    fit$model <- mf
  if (x.ret) 
    fit$x <- x
  if (y.ret) 
    fit$y <- y
  fit
}, function (formula, data, ..., method = c("lts", "lqs", "lms", "S", "model.frame"), subset, na.action, model = TRUE, x.ret = FALSE, y.ret = FALSE, contrasts = NULL) 
{
  method <- match.arg(method)
  mf <- match.call(expand.dots = FALSE)
  mf$method <- mf$contrasts <- mf$model <- mf$x.ret <- mf$y.ret <- mf$... <- NULL
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval.parent(mf)
  if (method == "model.frame") 
    return(mf)
  mt <- attr(mf, "terms")
  y <- model.extract(mf, "response")
  offset <- model.offset(mf)
  if (!is.null(offset)) 
    y <- y - offset
  x <- model.matrix(mt, mf, contrasts)
  contr <- attr(x, "contrasts")
  xint <- match("(Intercept)", colnames(x), nomatch = 0)
  if (xint) 
    x <- x[, -xint, drop = FALSE]
  fit <- lqs.default(x, y, intercept = (xint > 0), method = method, ...)
  fit$terms <- mt
  fit$call <- match.call()
  fit$contrasts <- contr
  fit$xlevels <- .getXlevels(mt, mf)
  fit$na.action <- attr(mf, "na.action")
  if (model) 
    fit$model <- mf
  if (x.ret) 
    fit$x <- x
  if (y.ret) 
    fit$y <- y
  fit
}, function (formula, data, ..., method = c("lts", "lqs", "lms", "S", "model.frame"), subset, na.action, model = TRUE, x.ret = FALSE, y.ret = FALSE, contrasts = NULL) 
{
  method <- match.arg(method)
  mf <- match.call(expand.dots = FALSE)
  mf$method <- mf$contrasts <- mf$model <- mf$x.ret <- mf$y.ret <- mf$... <- NULL
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval.parent(mf)
  if (method == "model.frame") 
    return(mf)
  mt <- attr(mf, "terms")
  y <- model.extract(mf, "response")
  offset <- model.offset(mf)
  if (!is.null(offset)) 
    y <- y - offset
  x <- model.matrix(mt, mf, contrasts)
  contr <- attr(x, "contrasts")
  xint <- match("(Intercept)", colnames(x), nomatch = 0)
  if (xint) 
    x <- x[, -xint, drop = FALSE]
  fit <- lqs.default(x, y, intercept = (xint > 0), method = method, ...)
  fit$terms <- mt
  fit$call <- match.call()
  fit$contrasts <- contr
  fit$xlevels <- .getXlevels(mt, mf)
  fit$na.action <- attr(mf, "na.action")
  if (model) 
    fit$model <- mf
  if (x.ret) 
    fit$x <- x
  if (y.ret) 
    fit$y <- y
  fit
})
c("package:MASS", "registered S3 method for lqs from namespace MASS", "namespace:MASS")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
ltsreg
list(`package:MASS` = function (...) 
{
  oc <- sys.call()
  oc$method <- "lts"
  oc[[1]] <- quote(MASS::lqs)
  eval.parent(oc)
}, function (...) 
{
  oc <- sys.call()
  oc$method <- "lts"
  oc[[1]] <- quote(MASS::lqs)
  eval.parent(oc)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
mammals
list(`package:MASS` = list(body = c(3.385, 0.48, 1.35, 465, 36.33, 27.66, 14.83, 1.04, 4.19, 0.425, 0.101, 0.92, 1, 0.005, 0.06, 3.5, 2, 1.7, 2547, 0.023, 187.1, 521, 0.785, 10, 3.3, 0.2, 1.41, 529, 207, 85, 0.75, 62, 6654, 3.5, 6.8, 35, 4.05, 0.12, 0.023, 0.01, 1.4, 250, 2.5, 55.5, 100, 52.16, 10.55, 0.55, 60, 3.6, 4.288, 0.28, 0.075, 0.122, 0.048, 192, 3, 160, 0.9, 1.62, 0.104, 4.235), brain = c(44.5, 15.5, 8.1, 423, 119.5, 115, 98.2, 5.5, 58, 6.4, 4, 5.7, 6.6, 0.14, 1, 10.8, 12.3, 6.3, 4603, 0.3, 
                                                                                                                                                                                                                                                                                                                                                                                                                 419, 655, 3.5, 115, 25.6, 5, 17.5, 680, 406, 325, 12.3, 1320, 5712, 3.9, 179, 56, 17, 1, 0.4, 0.25, 12.5, 490, 12.1, 175, 157, 440, 179.5, 2.4, 81, 21, 39.2, 1.9, 1.2, 3, 0.33, 180, 25, 169, 2.6, 11.4, 2.5, 50.4)))
package:MASS
TRUE
FALSE
mca
list(`package:MASS` = function (df, nf = 2, abbrev = FALSE) 
{
  class.ind <- function(cl) {
    n <- length(cl)
    cl <- as.factor(cl)
    x <- matrix(0, n, length(levels(cl)))
    x[(1:n) + n * (unclass(cl) - 1)] <- 1
    dimnames(x) <- list(names(cl), levels(cl))
    x
  }
  if (!all(unlist(lapply(df, is.factor)))) 
    stop("all variables must be factors")
  Call <- match.call()
  n <- nrow(df)
  p <- length(df)
  G <- as.matrix(do.call("data.frame", c(lapply(df, class.ind), check.names = FALSE)))
  Dc <- drop((rep(1, n)) %*% G)
  X <- t(t(G)/(sqrt(p * Dc)))
  X.svd <- svd(X)
  sec <- 1 + (1:nf)
  rs <- X %*% X.svd$v[, sec]/p
  cs <- diag(1/(sqrt(p * Dc))) %*% X.svd$v[, sec]
  fs <- X.svd$u[, sec]/rep(p * X.svd$d[sec], rep(n, nf))
  dimnames(rs) <- list(row.names(df), as.character(1:nf))
  dimnames(fs) <- dimnames(rs)
  varnames <- if (abbrev) 
    unlist(lapply(df, levels))
  else colnames(G)
  dimnames(cs) <- list(varnames, as.character(1:nf))
  structure(list(rs = rs, cs = cs, fs = fs, d = X.svd$d[sec], p = p, call = Call), class = "mca")
}, function (df, nf = 2, abbrev = FALSE) 
{
  class.ind <- function(cl) {
    n <- length(cl)
    cl <- as.factor(cl)
    x <- matrix(0, n, length(levels(cl)))
    x[(1:n) + n * (unclass(cl) - 1)] <- 1
    dimnames(x) <- list(names(cl), levels(cl))
    x
  }
  if (!all(unlist(lapply(df, is.factor)))) 
    stop("all variables must be factors")
  Call <- match.call()
  n <- nrow(df)
  p <- length(df)
  G <- as.matrix(do.call("data.frame", c(lapply(df, class.ind), check.names = FALSE)))
  Dc <- drop((rep(1, n)) %*% G)
  X <- t(t(G)/(sqrt(p * Dc)))
  X.svd <- svd(X)
  sec <- 1 + (1:nf)
  rs <- X %*% X.svd$v[, sec]/p
  cs <- diag(1/(sqrt(p * Dc))) %*% X.svd$v[, sec]
  fs <- X.svd$u[, sec]/rep(p * X.svd$d[sec], rep(n, nf))
  dimnames(rs) <- list(row.names(df), as.character(1:nf))
  dimnames(fs) <- dimnames(rs)
  varnames <- if (abbrev) 
    unlist(lapply(df, levels))
  else colnames(G)
  dimnames(cs) <- list(varnames, as.character(1:nf))
  structure(list(rs = rs, cs = cs, fs = fs, d = X.svd$d[sec], p = p, call = Call), class = "mca")
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
mcycle
list(`package:MASS` = list(times = c(2.4, 2.6, 3.2, 3.6, 4, 6.2, 6.6, 6.8, 7.8, 8.2, 8.8, 8.8, 9.6, 10, 10.2, 10.6, 11, 11.4, 13.2, 13.6, 13.8, 14.6, 14.6, 14.6, 14.6, 14.6, 14.6, 14.8, 15.4, 15.4, 15.4, 15.4, 15.6, 15.6, 15.8, 15.8, 16, 16, 16.2, 16.2, 16.2, 16.4, 16.4, 16.6, 16.8, 16.8, 16.8, 17.6, 17.6, 17.6, 17.6, 17.8, 17.8, 18.6, 18.6, 19.2, 19.4, 19.4, 19.6, 20.2, 20.4, 21.2, 21.4, 21.8, 22, 23.2, 23.4, 24, 24.2, 24.2, 24.6, 25, 25, 25.4, 25.4, 25.6, 26, 26.2, 26.2, 26.4, 27, 27.2, 27.2, 27.2, 
                                     27.6, 28.2, 28.4, 28.4, 28.6, 29.4, 30.2, 31, 31.2, 32, 32, 32.8, 33.4, 33.8, 34.4, 34.8, 35.2, 35.2, 35.4, 35.6, 35.6, 36.2, 36.2, 38, 38, 39.2, 39.4, 40, 40.4, 41.6, 41.6, 42.4, 42.8, 42.8, 43, 44, 44.4, 45, 46.6, 47.8, 47.8, 48.8, 50.6, 52, 53.2, 55, 55, 55.4, 57.6), accel = c(0, -1.3, -2.7, 0, -2.7, -2.7, -2.7, -1.3, -2.7, -2.7, -1.3, -2.7, -2.7, -2.7, -5.4, -2.7, -5.4, 0, -2.7, -2.7, 0, -13.3, -5.4, -5.4, -9.3, -16, -22.8, -2.7, -22.8, -32.1, -53.5, -54.9, -40.2, -21.5, -21.5, -50.8, -42.9, 
                                                                                                                                                                                                                                                                                                                              -26.8, -21.5, -50.8, -61.7, -5.4, -80.4, -59, -71, -91.1, -77.7, -37.5, -85.6, -123.1, -101.9, -99.1, -104.4, -112.5, -50.8, -123.1, -85.6, -72.3, -127.2, -123.1, -117.9, -134, -101.9, -108.4, -123.1, -123.1, -128.5, -112.5, -95.1, -81.8, -53.5, -64.4, -57.6, -72.3, -44.3, -26.8, -5.4, -107.1, -21.5, -65.6, -16, -45.6, -24.2, 9.5, 4, 12, -21.5, 37.5, 46.9, -17.4, 36.2, 75, 8.1, 54.9, 48.2, 46.9, 16, 45.6, 1.3, 75, -16, -54.9, 69.6, 34.8, 32.1, -37.5, 22.8, 46.9, 10.7, 5.4, -1.3, -21.5, -13.3, 30.8, 
                                                                                                                                                                                                                                                                                                                              -10.7, 29.4, 0, -10.7, 14.7, -1.3, 0, 10.7, 10.7, -26.8, -14.7, -13.3, 0, 10.7, -14.7, -2.7, 10.7, -2.7, 10.7)))
package:MASS
TRUE
FALSE
Melanoma
list(`package:MASS` = list(time = c(10, 30, 35, 99, 185, 204, 210, 232, 232, 279, 295, 355, 386, 426, 469, 493, 529, 621, 629, 659, 667, 718, 752, 779, 793, 817, 826, 833, 858, 869, 872, 967, 977, 982, 1041, 1055, 1062, 1075, 1156, 1228, 1252, 1271, 1312, 1427, 1435, 1499, 1506, 1508, 1510, 1512, 1516, 1525, 1542, 1548, 1557, 1560, 1563, 1584, 1605, 1621, 1627, 1634, 1641, 1641, 1648, 1652, 1654, 1654, 1667, 1678, 1685, 1690, 1710, 1710, 1726, 1745, 1762, 1779, 1787, 1787, 1793, 1804, 1812, 1836, 
                                    1839, 1839, 1854, 1856, 1860, 1864, 1899, 1914, 1919, 1920, 1927, 1933, 1942, 1955, 1956, 1958, 1963, 1970, 2005, 2007, 2011, 2024, 2028, 2038, 2056, 2059, 2061, 2062, 2075, 2085, 2102, 2103, 2104, 2108, 2112, 2150, 2156, 2165, 2209, 2227, 2227, 2256, 2264, 2339, 2361, 2387, 2388, 2403, 2426, 2426, 2431, 2460, 2467, 2492, 2493, 2521, 2542, 2559, 2565, 2570, 2660, 2666, 2676, 2738, 2782, 2787, 2984, 3032, 3040, 3042, 3067, 3079, 3101, 3144, 3152, 3154, 3180, 3182, 3185, 3199, 3228, 3229, 3278, 3297, 
                                    3328, 3330, 3338, 3383, 3384, 3385, 3388, 3402, 3441, 3458, 3459, 3459, 3476, 3523, 3667, 3695, 3695, 3776, 3776, 3830, 3856, 3872, 3909, 3968, 4001, 4103, 4119, 4124, 4207, 4310, 4390, 4479, 4492, 4668, 4688, 4926, 5565), status = c(3, 3, 2, 3, 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 2, 1, 2, 2, 2, 1, 3, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 
                                                                                                                                                                                                                                                                              2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 3, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), sex = c(1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0), age = c(76, 56, 41, 71, 52, 28, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   77, 60, 49, 68, 53, 64, 68, 63, 14, 72, 46, 72, 95, 54, 89, 25, 37, 43, 68, 67, 86, 56, 16, 42, 65, 52, 58, 60, 68, 75, 19, 66, 56, 46, 58, 74, 65, 64, 27, 73, 56, 63, 69, 77, 80, 76, 65, 61, 26, 57, 45, 31, 36, 46, 43, 68, 57, 57, 55, 58, 20, 67, 44, 59, 32, 83, 55, 15, 58, 47, 54, 55, 38, 41, 56, 48, 44, 70, 40, 53, 65, 54, 71, 49, 55, 69, 83, 60, 40, 77, 35, 46, 34, 69, 60, 84, 66, 56, 75, 36, 52, 58, 39, 68, 71, 52, 55, 66, 35, 44, 72, 58, 54, 33, 45, 62, 72, 51, 77, 43, 65, 63, 60, 50, 40, 67, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   69, 74, 49, 47, 42, 54, 72, 45, 67, 48, 34, 44, 31, 42, 24, 58, 78, 62, 70, 35, 61, 54, 29, 64, 47, 62, 32, 49, 25, 49, 64, 36, 58, 37, 54, 61, 31, 61, 60, 43, 68, 4, 60, 50, 20, 54, 29, 56, 60, 46, 42, 34, 56, 12, 21, 46, 49, 35, 42, 47, 69, 52, 52, 30, 22, 55, 26, 19, 29, 40, 42, 50, 41), year = c(1972, 1968, 1977, 1968, 1965, 1971, 1972, 1974, 1968, 1971, 1969, 1972, 1965, 1970, 1969, 1971, 1971, 1972, 1968, 1972, 1968, 1967, 1973, 1967, 1970, 1966, 1965, 1971, 1967, 1965, 1968, 1970, 1967, 1970, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1967, 1967, 1966, 1971, 1970, 1973, 1971, 1971, 1970, 1972, 1969, 1973, 1970, 1973, 1973, 1973, 1968, 1970, 1973, 1972, 1973, 1973, 1973, 1970, 1973, 1972, 1973, 1973, 1973, 1973, 1973, 1973, 1973, 1973, 1971, 1973, 1973, 1971, 1973, 1973, 1970, 1973, 1973, 1973, 1973, 1973, 1973, 1973, 1973, 1972, 1972, 1972, 1972, 1972, 1969, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1972, 1968, 1965, 1972, 1970, 1972, 1966, 1972, 1969, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1972, 1972, 1972, 1972, 1971, 1971, 1971, 1971, 1971, 1971, 1971, 1971, 1966, 1971, 1971, 1971, 1971, 1971, 1965, 1971, 1971, 1971, 1971, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1969, 1970, 1969, 1969, 1969, 1967, 1969, 1969, 1969, 1969, 1969, 1969, 1969, 1966, 1969, 1969, 1969, 1969, 1969, 1968, 1968, 1968, 1967, 1968, 1968, 1968, 1968, 1968, 1968, 1967, 1968, 1968, 1968, 1968, 1967, 1967, 1967, 1967, 1967, 1967, 1967, 1967, 1967, 1967, 1967, 1966, 1966, 1966, 1966, 1966, 1965, 1965, 1965, 1965, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1965, 1964, 1962), thickness = c(6.76, 0.65, 1.34, 2.9, 12.08, 4.84, 5.16, 3.22, 12.88, 7.41, 4.19, 0.16, 3.87, 4.84, 2.42, 12.56, 5.8, 7.06, 5.48, 7.73, 13.85, 2.34, 4.19, 4.04, 4.84, 0.32, 8.54, 2.58, 3.56, 3.54, 0.97, 4.83, 1.62, 6.44, 14.66, 2.58, 3.87, 3.54, 1.34, 2.24, 3.87, 3.54, 17.42, 1.29, 3.22, 1.29, 4.51, 8.38, 1.94, 0.16, 2.58, 1.29, 0.16, 1.62, 1.29, 2.1, 0.32, 0.81, 1.13, 5.16, 1.62, 1.37, 0.24, 0.81, 1.29, 1.29, 0.97, 1.13, 5.8, 1.29, 0.48, 1.62, 2.26, 0.58, 0.97, 2.58, 0.81, 3.54, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 0.97, 1.78, 1.94, 1.29, 3.22, 1.53, 1.29, 1.62, 1.62, 0.32, 4.84, 1.29, 0.97, 3.06, 3.54, 1.62, 2.58, 1.94, 0.81, 7.73, 0.97, 12.88, 2.58, 4.09, 0.64, 0.97, 3.22, 1.62, 3.87, 0.32, 0.32, 3.22, 2.26, 3.06, 2.58, 0.65, 1.13, 0.81, 0.97, 1.76, 1.94, 0.65, 0.97, 5.64, 9.66, 0.1, 5.48, 2.26, 4.83, 0.97, 0.97, 5.16, 0.81, 2.9, 3.87, 1.94, 0.16, 0.64, 2.26, 1.45, 4.82, 1.29, 7.89, 0.81, 3.54, 1.29, 0.64, 3.22, 1.45, 0.48, 1.94, 0.16, 0.16, 1.29, 1.94, 3.54, 0.81, 0.65, 7.09, 0.16, 1.62, 1.62, 1.29, 6.12, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 0.48, 0.64, 3.22, 1.94, 2.58, 2.58, 0.81, 0.81, 3.22, 0.32, 3.22, 2.74, 4.84, 1.62, 0.65, 1.45, 0.65, 1.29, 1.62, 3.54, 3.22, 0.65, 1.03, 7.09, 1.29, 0.65, 1.78, 12.24, 8.06, 0.81, 2.1, 3.87, 0.65, 1.94, 0.65, 2.1, 1.94, 1.13, 7.06, 6.12, 0.48, 2.26, 2.9), ulcer = c(1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0)))
package:MASS
TRUE
FALSE
menarche
list(`package:MASS` = list(Age = c(9.21, 10.21, 10.58, 10.83, 11.08, 11.33, 11.58, 11.83, 12.08, 12.33, 12.58, 12.83, 13.08, 13.33, 13.58, 13.83, 14.08, 14.33, 14.58, 14.83, 15.08, 15.33, 15.58, 15.83, 17.58), Total = c(376, 200, 93, 120, 90, 88, 105, 111, 100, 93, 100, 108, 99, 106, 105, 117, 98, 97, 120, 102, 122, 111, 94, 114, 1049), Menarche = c(0, 0, 0, 2, 2, 5, 10, 17, 16, 29, 39, 51, 47, 67, 81, 88, 79, 90, 113, 95, 117, 107, 92, 112, 1049)))
package:MASS
TRUE
FALSE
michelson
list(`package:MASS` = list(Speed = c(850, 740, 900, 1070, 930, 850, 950, 980, 980, 880, 1000, 980, 930, 650, 760, 810, 1000, 1000, 960, 960, 960, 940, 960, 940, 880, 800, 850, 880, 900, 840, 830, 790, 810, 880, 880, 830, 800, 790, 760, 800, 880, 880, 880, 860, 720, 720, 620, 860, 970, 950, 880, 910, 850, 870, 840, 840, 850, 840, 840, 840, 890, 810, 810, 820, 800, 770, 760, 740, 750, 760, 910, 920, 890, 860, 880, 720, 840, 850, 850, 780, 890, 840, 780, 810, 760, 810, 790, 810, 820, 850, 870, 870, 
                                     810, 740, 810, 940, 950, 800, 810, 870), Run = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20), Expt = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)))
package:MASS
TRUE
FALSE
minn38
list(`package:MASS` = list(hs = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
                                  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3), phs = c(1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 
                                                                               3, 3, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4), fol = c(1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 
                                                                                                                                        2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7), sex = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), f = c(87, 72, 52, 88, 32, 14, 20, 3, 6, 17, 9, 1, 2, 3, 17, 18, 14, 14, 12, 5, 4, 105, 209, 541, 328, 124, 148, 109, 216, 159, 119, 158, 43, 24, 41, 4, 14, 13, 15, 5, 6, 5, 14, 28, 44, 36, 7, 15, 13, 118, 227, 578, 304, 119, 131, 88, 256, 176, 119, 144, 42, 24, 32, 2, 8, 10, 12, 2, 2, 2, 10, 22, 33, 20, 7, 4, 4, 53, 95, 257, 115, 56, 61, 41, 53, 36, 52, 48, 12, 9, 3, 7, 16, 28, 18, 5, 1, 1, 13, 11, 49, 29, 10, 15, 6, 76, 111, 
                                                                                                                                                                                                                                                                                            521, 191, 101, 130, 88, 163, 116, 162, 130, 35, 19, 25, 30, 41, 64, 47, 11, 13, 9, 28, 53, 129, 62, 37, 22, 15, 118, 214, 708, 305, 152, 174, 158, 309, 225, 243, 237, 72, 42, 36, 17, 49, 79, 57, 20, 10, 14, 38, 68, 284, 63, 21, 19, 19, 89, 210, 448, 219, 95, 105, 93)))
package:MASS
TRUE
FALSE
motors
list(`package:MASS` = list(temp = c(150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220), time = c(8064, 8064, 8064, 8064, 8064, 8064, 8064, 8064, 8064, 8064, 1764, 2772, 3444, 3542, 3780, 4860, 5196, 5448, 5448, 5448, 408, 408, 1344, 1344, 1440, 1680, 1680, 1680, 1680, 1680, 408, 408, 504, 504, 504, 528, 528, 528, 528, 528), cens = c(0, 0, 0, 0, 0, 0, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0)))
package:MASS
TRUE
FALSE
muscle
list(`package:MASS` = list(Strip = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21, 21), Conc = c(1, 2, 3, 4, 1, 2, 3, 4, 0.25, 0.5, 1, 2, 0.25, 0.5, 1, 0.25, 0.5, 1, 0.25, 0.5, 1, 1, 2, 0.25, 1, 0.5, 1, 0.25, 1, 0.25, 0.5, 1, 1, 2, 1, 2, 0.5, 1, 0.5, 1, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3), Length = c(15.8, 20.8, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         22.6, 23.8, 20.6, 26.8, 28.4, 27, 7.2, 15.4, 22.8, 27.4, 2.2, 9, 16.6, 2, 6, 15.2, 5, 9.2, 14.2, 28, 32, 5.6, 26, 15.4, 23.2, 11.8, 29, 11, 18.8, 26.2, 26, 33.8, 24.2, 28.8, 15, 24, 20.8, 29, 18.2, 25.8, 30, 32.2, 21.5, 28.4, 32, 29.6, 15.4, 19, 19.4, 29, 34, 37, 22.2, 29, 32.2, 23, 27.4, 30.4)))
package:MASS
TRUE
FALSE
mvrnorm
list(`package:MASS` = function (n = 1, mu, Sigma, tol = 1e-06, empirical = FALSE, EISPACK = FALSE) 
{
  p <- length(mu)
  if (!all(dim(Sigma) == c(p, p))) 
    stop("incompatible arguments")
  if (EISPACK) 
    stop("'EISPACK' is no longer supported by R", domain = NA)
  eS <- eigen(Sigma, symmetric = TRUE)
  ev <- eS$values
  if (!all(ev >= -tol * abs(ev[1]))) 
    stop("'Sigma' is not positive definite")
  X <- matrix(rnorm(p * n), n)
  if (empirical) {
    X <- scale(X, TRUE, FALSE)
    X <- X %*% svd(X, nu = 0)$v
    X <- scale(X, FALSE, TRUE)
  }
  X <- drop(mu) + eS$vectors %*% diag(sqrt(pmax(ev, 0)), p) %*% t(X)
  nm <- names(mu)
  if (is.null(nm) && !is.null(dn <- dimnames(Sigma))) 
    nm <- dn[[1]]
  dimnames(X) <- list(nm, NULL)
  if (n == 1) 
    drop(X)
  else t(X)
}, function (n = 1, mu, Sigma, tol = 1e-06, empirical = FALSE, EISPACK = FALSE) 
{
  p <- length(mu)
  if (!all(dim(Sigma) == c(p, p))) 
    stop("incompatible arguments")
  if (EISPACK) 
    stop("'EISPACK' is no longer supported by R", domain = NA)
  eS <- eigen(Sigma, symmetric = TRUE)
  ev <- eS$values
  if (!all(ev >= -tol * abs(ev[1]))) 
    stop("'Sigma' is not positive definite")
  X <- matrix(rnorm(p * n), n)
  if (empirical) {
    X <- scale(X, TRUE, FALSE)
    X <- X %*% svd(X, nu = 0)$v
    X <- scale(X, FALSE, TRUE)
  }
  X <- drop(mu) + eS$vectors %*% diag(sqrt(pmax(ev, 0)), p) %*% t(X)
  nm <- names(mu)
  if (is.null(nm) && !is.null(dn <- dimnames(Sigma))) 
    nm <- dn[[1]]
  dimnames(X) <- list(nm, NULL)
  if (n == 1) 
    drop(X)
  else t(X)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
nclass.freq
list(`package:MASS` = function (x) 
{
  h <- 2.15 * sqrt(var(x)) * length(x)^(-1/5)
  ceiling(diff(range(x))/h)
}, function (x) 
{
  h <- 2.15 * sqrt(var(x)) * length(x)^(-1/5)
  ceiling(diff(range(x))/h)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
neg.bin
list(`package:MASS` = function (theta = stop("'theta' must be given")) 
{
  .Theta <- theta
  env <- new.env(parent = .GlobalEnv)
  assign(".Theta", theta, envir = env)
  stats <- make.link("log")
  variance <- function(mu) mu + mu^2/.Theta
  validmu <- function(mu) all(mu > 0)
  dev.resids <- function(y, mu, wt) 2 * wt * (y * log(pmax(1, y)/mu) - (y + .Theta) * log((y + .Theta)/(mu + .Theta)))
  aic <- function(y, n, mu, wt, dev) {
    term <- (y + .Theta) * log(mu + .Theta) - y * log(mu) + lgamma(y + 1) - .Theta * log(.Theta) + lgamma(.Theta) - lgamma(.Theta + y)
    2 * sum(term * wt)
  }
  initialize <- expression({
    if (any(y < 0)) stop("negative values not allowed for the negative binomial family")
    n <- rep(1, nobs)
    mustart <- y + (y == 0)/6
  })
  simfun <- function(object, nsim) {
    ftd <- fitted(object)
    rnegbin(nsim * length(ftd), ftd, .Theta)
  }
  environment(variance) <- environment(validmu) <- environment(dev.resids) <- environment(aic) <- environment(simfun) <- env
  structure(list(family = "Negative Binomial", link = "log", linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
}, function (theta = stop("'theta' must be given")) 
{
  .Theta <- theta
  env <- new.env(parent = .GlobalEnv)
  assign(".Theta", theta, envir = env)
  stats <- make.link("log")
  variance <- function(mu) mu + mu^2/.Theta
  validmu <- function(mu) all(mu > 0)
  dev.resids <- function(y, mu, wt) 2 * wt * (y * log(pmax(1, y)/mu) - (y + .Theta) * log((y + .Theta)/(mu + .Theta)))
  aic <- function(y, n, mu, wt, dev) {
    term <- (y + .Theta) * log(mu + .Theta) - y * log(mu) + lgamma(y + 1) - .Theta * log(.Theta) + lgamma(.Theta) - lgamma(.Theta + y)
    2 * sum(term * wt)
  }
  initialize <- expression({
    if (any(y < 0)) stop("negative values not allowed for the negative binomial family")
    n <- rep(1, nobs)
    mustart <- y + (y == 0)/6
  })
  simfun <- function(object, nsim) {
    ftd <- fitted(object)
    rnegbin(nsim * length(ftd), ftd, .Theta)
  }
  environment(variance) <- environment(validmu) <- environment(dev.resids) <- environment(aic) <- environment(simfun) <- env
  structure(list(family = "Negative Binomial", link = "log", linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
negative.binomial
list(`package:MASS` = function (theta = stop("'theta' must be specified"), link = "log") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  if (linktemp %in% c("log", "identity", "sqrt")) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else stop(gettextf("\"%s\" link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"", linktemp))
  }
  .Theta <- theta
  env <- new.env(parent = .GlobalEnv)
  assign(".Theta", theta, envir = env)
  variance <- function(mu) mu + mu^2/.Theta
  validmu <- function(mu) all(mu > 0)
  dev.resids <- function(y, mu, wt) 2 * wt * (y * log(pmax(1, y)/mu) - (y + .Theta) * log((y + .Theta)/(mu + .Theta)))
  aic <- function(y, n, mu, wt, dev) {
    term <- (y + .Theta) * log(mu + .Theta) - y * log(mu) + lgamma(y + 1) - .Theta * log(.Theta) + lgamma(.Theta) - lgamma(.Theta + y)
    2 * sum(term * wt)
  }
  initialize <- expression({
    if (any(y < 0)) stop("negative values not allowed for the negative binomial family")
    n <- rep(1, nobs)
    mustart <- y + (y == 0)/6
  })
  simfun <- function(object, nsim) {
    ftd <- fitted(object)
    rnegbin(nsim * length(ftd), ftd, .Theta)
  }
  environment(variance) <- environment(validmu) <- environment(dev.resids) <- environment(aic) <- environment(simfun) <- env
  famname <- paste("Negative Binomial(", format(round(theta, 4)), ")", sep = "")
  structure(list(family = famname, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
}, function (theta = stop("'theta' must be specified"), link = "log") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  if (linktemp %in% c("log", "identity", "sqrt")) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else stop(gettextf("\"%s\" link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"", linktemp))
  }
  .Theta <- theta
  env <- new.env(parent = .GlobalEnv)
  assign(".Theta", theta, envir = env)
  variance <- function(mu) mu + mu^2/.Theta
  validmu <- function(mu) all(mu > 0)
  dev.resids <- function(y, mu, wt) 2 * wt * (y * log(pmax(1, y)/mu) - (y + .Theta) * log((y + .Theta)/(mu + .Theta)))
  aic <- function(y, n, mu, wt, dev) {
    term <- (y + .Theta) * log(mu + .Theta) - y * log(mu) + lgamma(y + 1) - .Theta * log(.Theta) + lgamma(.Theta) - lgamma(.Theta + y)
    2 * sum(term * wt)
  }
  initialize <- expression({
    if (any(y < 0)) stop("negative values not allowed for the negative binomial family")
    n <- rep(1, nobs)
    mustart <- y + (y == 0)/6
  })
  simfun <- function(object, nsim) {
    ftd <- fitted(object)
    rnegbin(nsim * length(ftd), ftd, .Theta)
  }
  environment(variance) <- environment(validmu) <- environment(dev.resids) <- environment(aic) <- environment(simfun) <- env
  famname <- paste("Negative Binomial(", format(round(theta, 4)), ")", sep = "")
  structure(list(family = famname, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
negexp.SSival
list(`package:MASS` = function (mCall, data, LHS) 
{
  x <- eval(mCall[["x"]], data)
  if (length(x) < 3) 
    stop("at least 3 distinct 'x' values are needed")
  y <- eval(LHS, data)
  mx <- mean(x)
  b <- as.vector(lsfit(cbind(x - mx, -(x - mx)^2/2), y)$coef)
  rx <- range(x)
  xh <- mx + b[2]/b[3]
  if (prod(xh - rx) < 0) 
    if (xh - rx[1] > rx[2] - xh) 
      rx[2] <- xh
  else rx[1] <- xh
  x0 <- c(rx[1], sum(rx)/2, rx[2])
  dy <- diff(b[1] + b[2] * (x0 - mx) - (b[3] * (x0 - mx)^2)/2)
  th <- (x0[2] - x0[1])/log(dy[1]/dy[2])
  b <- as.vector(lsfit(exp(-x/th), y)$coef)
  pars <- list(b[1], b[2], th)
  names(pars) <- mCall[c("b0", "b1", "th")]
  print(unlist(pars))
  pars
}, function (mCall, data, LHS) 
{
  x <- eval(mCall[["x"]], data)
  if (length(x) < 3) 
    stop("at least 3 distinct 'x' values are needed")
  y <- eval(LHS, data)
  mx <- mean(x)
  b <- as.vector(lsfit(cbind(x - mx, -(x - mx)^2/2), y)$coef)
  rx <- range(x)
  xh <- mx + b[2]/b[3]
  if (prod(xh - rx) < 0) 
    if (xh - rx[1] > rx[2] - xh) 
      rx[2] <- xh
  else rx[1] <- xh
  x0 <- c(rx[1], sum(rx)/2, rx[2])
  dy <- diff(b[1] + b[2] * (x0 - mx) - (b[3] * (x0 - mx)^2)/2)
  th <- (x0[2] - x0[1])/log(dy[1]/dy[2])
  b <- as.vector(lsfit(exp(-x/th), y)$coef)
  pars <- list(b[1], b[2], th)
  names(pars) <- mCall[c("b0", "b1", "th")]
  print(unlist(pars))
  pars
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
newcomb
list(`package:MASS` = c(28, -44, 29, 30, 24, 28, 37, 32, 36, 27, 26, 28, 29, 26, 27, 22, 23, 20, 25, 25, 36, 23, 31, 32, 24, 27, 33, 16, 24, 29, 36, 21, 28, 26, 27, 27, 32, 25, 28, 24, 40, 21, 31, 32, 28, 26, 30, 27, 26, 24, 32, 29, 34, -2, 25, 19, 36, 29, 30, 22, 28, 33, 39, 25, 16, 23))
package:MASS
TRUE
FALSE
nlschools
list(`package:MASS` = list(lang = c(46, 45, 33, 46, 20, 30, 30, 57, 36, 36, 29, 40, 41, 47, 33, 37, 29, 26, 37, 40, 27, 43, 39, 21, 42, 21, 27, 16, 31, 21, 18, 32, 28, 33, 38, 14, 39, 23, 43, 25, 24, 41, 32, 26, 21, 37, 30, 41, 31, 27, 33, 29, 31, 18, 37, 22, 43, 9, 41, 46, 34, 47, 44, 50, 45, 43, 34, 35, 22, 27, 45, 45, 38, 24, 50, 22, 43, 28, 38, 20, 40, 47, 20, 28, 33, 21, 44, 43, 18, 31, 21, 41, 48, 43, 32, 17, 27, 55, 45, 36, 24, 35, 43, 48, 38, 44, 47, 36, 41, 41, 26, 52, 43, 54, 49, 51, 47, 
                                    51, 51, 34, 51, 49, 42, 50, 33, 46, 57, 35, 44, 36, 50, 38, 49, 26, 48, 32, 46, 38, 44, 35, 40, 40, 46, 31, 50, 46, 51, 29, 39, 49, 43, 37, 35, 38, 40, 42, 41, 32, 40, 20, 29, 41, 23, 27, 35, 33, 31, 29, 31, 40, 19, 40, 51, 51, 35, 50, 51, 52, 44, 39, 41, 51, 20, 43, 31, 42, 50, 41, 38, 52, 34, 34, 54, 47, 25, 27, 35, 28, 34, 42, 38, 51, 55, 40, 49, 37, 31, 31, 28, 30, 34, 42, 29, 27, 32, 22, 34, 36, 46, 45, 39, 36, 33, 28, 35, 42, 42, 34, 47, 43, 45, 53, 53, 42, 40, 50, 41, 35, 42, 52, 26, 39, 33, 
                                    50, 38, 45, 43, 41, 36, 38, 31, 53, 35, 41, 27, 30, 48, 36, 30, 18, 34, 49, 44, 50, 51, 50, 50, 44, 48, 26, 50, 52, 46, 50, 36, 44, 35, 20, 36, 42, 43, 35, 45, 50, 49, 51, 53, 48, 38, 40, 31, 38, 29, 52, 41, 48, 50, 37, 30, 28, 30, 45, 25, 49, 30, 35, 18, 39, 20, 47, 34, 45, 31, 38, 38, 26, 43, 34, 39, 36, 46, 38, 25, 23, 38, 53, 31, 45, 43, 26, 29, 15, 29, 20, 23, 27, 22, 23, 44, 25, 30, 32, 35, 32, 28, 37, 46, 52, 40, 51, 46, 18, 32, 41, 46, 25, 21, 31, 25, 28, 39, 25, 49, 34, 36, 19, 48, 22, 47, 
                                    47, 44, 35, 43, 38, 44, 37, 44, 32, 42, 36, 42, 50, 52, 46, 55, 50, 42, 54, 50, 53, 49, 49, 51, 54, 53, 46, 34, 47, 42, 51, 44, 36, 40, 50, 23, 51, 45, 44, 34, 48, 37, 39, 54, 46, 54, 44, 40, 31, 46, 23, 52, 44, 40, 37, 38, 34, 51, 40, 39, 23, 39, 44, 42, 40, 41, 51, 43, 33, 42, 48, 33, 33, 33, 39, 47, 42, 44, 50, 33, 41, 45, 40, 52, 45, 55, 35, 54, 42, 41, 45, 29, 26, 53, 41, 22, 28, 41, 31, 48, 26, 36, 47, 48, 52, 37, 37, 43, 36, 35, 35, 44, 22, 50, 43, 27, 22, 45, 19, 50, 39, 40, 29, 49, 51, 56, 
                                    41, 27, 31, 48, 40, 33, 38, 40, 39, 43, 46, 51, 47, 49, 43, 43, 53, 40, 53, 48, 36, 50, 54, 42, 51, 43, 51, 53, 49, 41, 44, 41, 57, 51, 43, 43, 43, 43, 54, 33, 55, 47, 36, 55, 41, 54, 50, 54, 47, 41, 50, 43, 50, 52, 32, 52, 21, 36, 49, 37, 28, 50, 47, 35, 52, 52, 39, 25, 25, 38, 31, 26, 35, 29, 32, 34, 51, 47, 39, 39, 27, 45, 32, 41, 38, 40, 39, 29, 40, 32, 17, 50, 38, 47, 41, 50, 38, 47, 27, 42, 27, 43, 43, 39, 43, 53, 54, 47, 37, 40, 27, 41, 34, 43, 37, 37, 42, 25, 33, 16, 34, 40, 30, 47, 36, 52, 
                                    28, 37, 43, 50, 35, 37, 32, 34, 49, 34, 34, 39, 40, 34, 51, 49, 39, 37, 45, 48, 40, 36, 44, 48, 49, 31, 41, 42, 46, 28, 45, 46, 26, 28, 46, 42, 48, 41, 45, 45, 45, 50, 24, 54, 20, 52, 44, 45, 34, 46, 39, 51, 28, 42, 45, 41, 46, 48, 42, 28, 25, 46, 49, 35, 42, 51, 43, 31, 40, 41, 30, 48, 42, 51, 53, 50, 41, 45, 24, 45, 36, 41, 33, 47, 43, 51, 32, 22, 30, 37, 41, 20, 52, 45, 51, 49, 27, 42, 53, 52, 47, 47, 18, 50, 39, 26, 27, 44, 49, 35, 42, 53, 45, 50, 38, 50, 44, 41, 47, 45, 52, 48, 50, 40, 33, 46, 
                                    49, 50, 47, 40, 51, 51, 53, 42, 55, 53, 44, 51, 32, 36, 55, 30, 39, 42, 34, 36, 31, 37, 47, 30, 27, 39, 35, 38, 29, 46, 46, 43, 43, 42, 49, 46, 49, 27, 47, 36, 49, 30, 39, 45, 55, 29, 32, 48, 38, 42, 31, 31, 38, 48, 44, 35, 31, 30, 46, 48, 28, 36, 39, 46, 38, 31, 33, 44, 46, 53, 30, 27, 40, 45, 37, 50, 46, 47, 54, 50, 50, 35, 30, 48, 55, 35, 38, 38, 41, 31, 15, 21, 29, 15, 25, 27, 25, 49, 29, 52, 27, 49, 42, 34, 51, 43, 42, 29, 39, 49, 41, 23, 48, 22, 19, 52, 53, 37, 44, 34, 30, 41, 49, 53, 44, 41, 
                                    37, 51, 14, 17, 33, 43, 38, 26, 26, 31, 30, 29, 36, 43, 40, 26, 32, 38, 43, 33, 26, 34, 17, 39, 45, 47, 45, 46, 35, 47, 43, 42, 39, 51, 44, 46, 33, 40, 51, 45, 49, 39, 45, 30, 41, 46, 39, 45, 48, 30, 48, 44, 29, 55, 43, 45, 45, 42, 41, 28, 26, 46, 38, 37, 54, 29, 36, 36, 20, 46, 48, 24, 26, 40, 35, 55, 36, 30, 38, 39, 52, 36, 43, 31, 43, 42, 37, 47, 49, 31, 41, 33, 42, 41, 44, 41, 34, 32, 46, 40, 38, 40, 24, 39, 24, 37, 25, 28, 39, 39, 33, 38, 38, 29, 34, 47, 49, 34, 39, 27, 31, 40, 39, 25, 34, 36, 
                                    52, 48, 31, 43, 27, 47, 27, 40, 29, 40, 41, 44, 47, 44, 33, 28, 28, 50, 51, 40, 38, 29, 38, 34, 43, 43, 46, 34, 52, 56, 46, 47, 41, 40, 42, 48, 42, 48, 44, 45, 46, 53, 40, 46, 42, 47, 32, 52, 40, 48, 32, 53, 37, 36, 54, 24, 43, 50, 38, 46, 51, 38, 47, 48, 28, 51, 43, 52, 43, 49, 42, 45, 57, 52, 50, 51, 27, 54, 44, 45, 54, 27, 43, 35, 45, 37, 46, 53, 54, 51, 36, 51, 55, 44, 42, 48, 54, 54, 42, 55, 49, 48, 44, 53, 51, 58, 48, 51, 48, 42, 47, 53, 49, 47, 41, 47, 54, 46, 33, 44, 49, 55, 49, 37, 46, 30, 
                                    33, 51, 50, 40, 46, 47, 48, 56, 25, 52, 47, 40, 27, 41, 32, 45, 47, 35, 44, 35, 45, 46, 51, 33, 29, 48, 41, 38, 44, 27, 53, 44, 42, 50, 48, 53, 41, 38, 41, 33, 54, 31, 50, 40, 52, 46, 46, 53, 36, 46, 55, 51, 42, 45, 45, 52, 55, 37, 46, 51, 46, 51, 54, 51, 53, 46, 55, 51, 54, 55, 37, 51, 53, 51, 43, 48, 47, 46, 51, 47, 46, 45, 38, 41, 43, 44, 42, 51, 40, 54, 50, 55, 47, 44, 42, 56, 33, 46, 48, 32, 43, 45, 45, 53, 50, 48, 37, 51, 40, 44, 38, 35, 23, 46, 38, 52, 45, 34, 46, 41, 40, 51, 31, 47, 44, 47, 
                                    48, 48, 30, 40, 50, 54, 37, 40, 34, 47, 33, 43, 53, 36, 49, 54, 45, 41, 35, 34, 30, 41, 37, 46, 43, 30, 39, 40, 25, 38, 34, 37, 33, 39, 34, 49, 46, 37, 37, 43, 47, 38, 28, 42, 43, 34, 31, 51, 38, 34, 49, 52, 46, 40, 49, 40, 49, 54, 51, 56, 54, 52, 39, 47, 38, 52, 48, 34, 39, 40, 51, 54, 51, 51, 54, 49, 42, 55, 42, 54, 29, 35, 50, 37, 40, 52, 52, 41, 51, 45, 40, 34, 38, 47, 34, 23, 34, 51, 47, 50, 47, 38, 49, 29, 38, 48, 25, 31, 45, 31, 40, 47, 49, 50, 48, 41, 42, 54, 42, 32, 51, 34, 38, 32, 21, 46, 
                                    44, 43, 46, 57, 44, 50, 43, 39, 52, 38, 51, 43, 40, 42, 38, 54, 51, 50, 45, 43, 51, 44, 23, 40, 34, 20, 44, 52, 40, 33, 47, 52, 50, 30, 50, 44, 52, 53, 42, 54, 51, 45, 52, 51, 50, 44, 28, 43, 50, 41, 51, 53, 35, 50, 41, 55, 37, 44, 52, 49, 48, 52, 43, 54, 39, 24, 50, 47, 48, 40, 58, 48, 40, 35, 42, 44, 31, 35, 37, 40, 50, 55, 50, 39, 43, 43, 50, 45, 53, 40, 48, 51, 37, 47, 54, 26, 48, 42, 41, 41, 55, 52, 53, 47, 39, 41, 42, 57, 39, 34, 39, 37, 40, 42, 46, 50, 27, 49, 43, 25, 51, 41, 37, 34, 34, 51, 
                                    53, 57, 49, 21, 27, 39, 50, 38, 42, 54, 37, 40, 51, 25, 25, 47, 25, 52, 50, 47, 56, 53, 37, 53, 42, 42, 45, 54, 23, 48, 54, 47, 46, 38, 26, 53, 51, 55, 33, 51, 47, 52, 37, 51, 41, 53, 35, 49, 43, 55, 54, 55, 55, 55, 31, 36, 57, 41, 49, 42, 37, 33, 44, 43, 39, 34, 45, 46, 34, 46, 27, 48, 39, 44, 34, 45, 29, 19, 24, 30, 29, 24, 41, 46, 37, 34, 30, 35, 38, 40, 39, 45, 45, 44, 46, 48, 47, 27, 43, 26, 31, 34, 32, 47, 49, 40, 41, 53, 52, 47, 34, 27, 41, 41, 44, 37, 36, 49, 41, 17, 41, 51, 31, 41, 37, 48, 
                                    47, 32, 48, 40, 47, 54, 43, 37, 41, 49, 42, 32, 40, 36, 53, 23, 42, 38, 43, 51, 41, 52, 50, 26, 36, 20, 46, 39, 34, 33, 44, 42, 48, 25, 44, 48, 46, 49, 43, 39, 35, 31, 40, 53, 44, 52, 33, 49, 40, 48, 17, 29, 44, 29, 24, 41, 36, 30, 34, 50, 52, 51, 44, 55, 50, 44, 49, 54, 32, 52, 48, 37, 45, 23, 49, 56, 43, 44, 45, 33, 30, 38, 35, 43, 38, 37, 34, 44, 42, 46, 47, 40, 42, 45, 35, 39, 46, 46, 49, 32, 40, 43, 50, 55, 47, 36, 44, 50, 40, 50, 52, 55, 30, 26, 45, 35, 37, 45, 43, 50, 46, 50, 53, 53, 37, 46, 
                                    45, 51, 37, 49, 46, 37, 37, 23, 47, 49, 51, 56, 30, 28, 45, 31, 29, 49, 43, 49, 40, 39, 33, 30, 31, 37, 53, 42, 31, 35, 22, 28, 33, 21, 24, 22, 46, 25, 27, 43, 36, 26, 46, 46, 44, 32, 35, 26, 34, 45, 47, 45, 32, 32, 47, 28, 46, 37, 40, 42, 53, 22, 21, 37, 42, 42, 35, 51, 46, 31, 40, 52, 47, 39, 39, 52, 48, 40, 47, 45, 56, 51, 47, 38, 36, 26, 37, 48, 33, 43, 52, 42, 53, 47, 55, 39, 33, 46, 45, 49, 48, 47, 40, 39, 47, 41, 41, 45, 40, 55, 50, 53, 52, 29, 46, 27, 33, 31, 47, 56, 28, 44, 40, 34, 32, 28, 
                                    49, 42, 50, 46, 51, 42, 42, 40, 46, 35, 42, 52, 47, 47, 33, 43, 46, 49, 26, 35, 45, 49, 21, 33, 33, 21, 34, 31, 27, 32, 41, 22, 34, 22, 52, 23, 35, 35, 26, 40, 49, 36, 36, 42, 32, 37, 46, 35, 51, 47, 47, 44, 49, 37, 35, 33, 37, 53, 51, 53, 36, 43, 52, 36, 50, 48, 49, 43, 38, 39, 44, 41, 52, 55, 49, 55, 42, 43, 39, 41, 56, 41, 49, 44, 48, 42, 48, 53, 54, 53, 44, 44, 44, 54, 36, 50, 43, 46, 51, 46, 43, 43, 53, 40, 35, 46, 51, 43, 28, 40, 40, 24, 22, 33, 37, 33, 53, 37, 49, 52, 51, 39, 46, 42, 44, 37, 
                                    49, 37, 51, 34, 32, 40, 40, 41, 36, 49, 45, 43, 35, 48, 46, 43, 44, 33, 40, 30, 31, 34, 42, 42, 51, 48, 42, 51, 47, 40, 49, 52, 52, 46, 46, 44, 48, 31, 40, 39, 45, 47, 23, 49, 36, 51, 40, 46, 52, 53, 37, 47, 49, 54, 50, 52, 53, 48, 53, 51, 44, 47, 51, 57, 44, 54, 55, 50, 49, 57, 45, 48, 42, 41, 50, 52, 39, 48, 51, 38, 45, 46, 44, 34, 50, 41, 41, 33, 38, 44, 42, 15, 35, 46, 49, 40, 52, 40, 46, 49, 21, 46, 55, 47, 53, 46, 50, 44, 37, 49, 43, 47, 34, 51, 29, 34, 53, 43, 57, 48, 31, 38, 49, 36, 42, 33, 
                                    30, 35, 35, 37, 42, 49, 48, 49, 28, 41, 41, 35, 50, 43, 45, 47, 39, 35, 44, 52, 51, 51, 54, 33, 51, 47, 38, 33, 44, 29, 50, 48, 36, 53, 44, 34, 28, 39, 40, 44, 39, 37, 23, 32, 38, 54, 45, 49, 29, 38, 53, 50, 46, 42, 46, 48, 39, 29, 42, 43, 35, 51, 33, 36, 17, 28, 43, 49, 39, 51, 29, 38, 52, 42, 34, 55, 42, 47, 42, 47, 41, 32, 53, 47, 56, 51, 33, 47, 41, 53, 41, 39, 45, 34, 41, 37, 33, 33, 48, 37, 40, 37, 34, 49, 47, 38, 49, 44, 33, 46, 50, 23, 23, 39, 51, 41, 38, 32, 38, 55, 51, 51, 36, 47, 33, 46, 
                                    37, 34, 40, 42, 34, 48, 31, 32, 38, 47, 36, 45, 25, 11, 19, 16, 42, 29, 24, 52, 30, 21, 25, 21, 33, 26, 34, 39), IQ = c(15, 14.5, 9.5, 11, 8, 9.5, 9.5, 13, 9.5, 11, 5.5, 14, 9, 10.5, 10, 11, 6.5, 4, 11, 11, 11, 12.5, 11.5, 10, 10, 11.5, 10.5, 8, 7.5, 7.5, 6.5, 11.5, 10.5, 10.5, 12.5, 8, 11, 9.5, 10.5, 8.5, 7.5, 11, 10.5, 10.5, 9.5, 10, 11.5, 9.5, 9, 8, 7.5, 8.5, 14, 8.5, 13, 10.5, 15, 9, 10, 12, 11, 11, 12.5, 13, 12.5, 11, 11.5, 11, 9.5, 9.5, 15, 11.5, 13, 10.5, 13, 11, 14, 13.5, 10.5, 9.5, 15.5, 
                                                                                                                                                            12, 11, 11, 13, 11.5, 12.5, 12, 10, 10.5, 11.5, 11, 14.5, 13, 8.5, 11.5, 8.5, 13, 12.5, 13.5, 8, 9, 11.5, 13, 14.5, 12, 12, 13.5, 11.5, 12, 10, 14, 12.5, 13, 11.5, 15.5, 13.5, 12, 12, 8.5, 10.5, 10, 9, 13, 6.5, 13.5, 16.5, 10.5, 13.5, 12, 12.5, 13, 12, 10.5, 12, 12.5, 13, 10, 11, 11, 16.5, 13, 11.5, 10, 13.5, 13.5, 16.5, 9, 12, 13.5, 14, 10, 10.5, 13, 13, 14, 14.5, 12, 12.5, 10.5, 11, 12.5, 13, 11.5, 9.5, 11.5, 9.5, 12, 10, 12, 6.5, 11, 18, 16, 12, 11.5, 12, 15.5, 14, 6, 12.5, 16.5, 12, 10, 10, 11, 
                                                                                                                                                            13, 12, 11, 13, 10.5, 7, 13, 13, 11, 8, 8, 12, 8.5, 9.5, 10.5, 15.5, 14.5, 12, 12, 13, 9.5, 12, 8.5, 11, 9.5, 12.5, 11, 12, 13, 9.5, 14.5, 12.5, 12.5, 12.5, 12.5, 11, 10.5, 11, 12, 11, 10, 9.5, 9.5, 10, 11, 12, 12, 12, 11, 12.5, 12.5, 9, 13, 13, 9, 12, 8, 13.5, 10, 13.5, 14.5, 12, 10.5, 12, 9.5, 15.5, 13.5, 11.5, 9, 10, 12.5, 12, 9.5, 11.5, 12.5, 13, 12.5, 15.5, 14, 13.5, 14, 12, 13, 9.5, 13.5, 15, 12.5, 13.5, 11, 11, 11.5, 12.5, 11, 12.5, 13, 11.5, 16.5, 15.5, 13.5, 12.5, 15, 10, 11.5, 13, 12.5, 
                                                                                                                                                            10.5, 11, 15, 15, 13, 15.5, 11.5, 11, 10, 9.5, 11.5, 11.5, 14.5, 12, 12.5, 9.5, 11, 10, 14.5, 11, 13, 11.5, 11.5, 11.5, 11, 11.5, 10.5, 11.5, 10.5, 12.5, 11, 11, 9.5, 12.5, 12.5, 10, 10.5, 11.5, 12, 10.5, 7, 10, 11, 4.5, 6, 10, 7.5, 12.5, 9, 10.5, 12, 11, 8.5, 12, 13.5, 13, 12.5, 10, 13, 10.5, 8, 8.5, 13.5, 13.5, 9, 11, 11.5, 10.5, 10.5, 13.5, 11, 14.5, 11, 15.5, 10.5, 11, 11.5, 17, 12.5, 12, 12, 17, 7, 13.5, 11.5, 13, 11, 13.5, 11, 12.5, 11.5, 12, 11, 15.5, 12.5, 11.5, 14.5, 15.5, 15, 13, 13.5, 
                                                                                                                                                            11.5, 15.5, 13.5, 13, 10.5, 13, 12, 18, 13, 13, 13.5, 16.5, 10.5, 13, 11.5, 11.5, 11.5, 12, 7, 10.5, 15.5, 12.5, 14.5, 11, 12.5, 10, 11, 9.5, 16, 13.5, 13, 12.5, 11.5, 7, 17.5, 9.5, 12, 12.5, 10.5, 15.5, 12.5, 12, 12, 11, 12.5, 13, 10.5, 12, 12, 12, 11.5, 13, 12, 13, 13.5, 14, 11.5, 13, 8.5, 11, 13, 10.5, 15, 11.5, 11.5, 15.5, 12, 11, 10, 7.5, 15.5, 11, 9.5, 6, 12.5, 11.5, 13.5, 8, 13, 12, 14, 14, 12, 13.5, 13, 12, 11.5, 10.5, 11.5, 9, 11.5, 12, 6, 9.5, 11.5, 7.5, 15, 9, 15, 8, 10, 15, 16, 11.5, 
                                                                                                                                                            13, 10.5, 12.5, 12, 11, 11.5, 10, 10.5, 14.5, 13.5, 16, 10.5, 17.5, 13.5, 12.5, 14.5, 12, 12.5, 13.5, 14, 12, 17.5, 12, 13, 11.5, 16, 17.5, 14.5, 11.5, 11.5, 13, 15, 11, 10, 16, 12.5, 12, 11.5, 9.5, 14.5, 13.5, 11.5, 12.5, 12, 12, 14.5, 11.5, 12, 12, 13.5, 13.5, 11.5, 14.5, 9, 14, 10.5, 11, 11, 11, 10.5, 16.5, 14, 11.5, 15.5, 15.5, 11, 12, 10.5, 13, 11.5, 9, 12.5, 12.5, 9.5, 13, 13.5, 15, 15.5, 13, 11.5, 16, 10, 10.5, 10.5, 14, 16, 9.5, 11, 10.5, 11, 15, 13.5, 14, 15, 14.5, 11.5, 13.5, 11, 13, 10.5, 
                                                                                                                                                            12, 13.5, 12.5, 9.5, 17, 14, 14.5, 8.5, 13.5, 10.5, 11.5, 10, 12.5, 12.5, 11, 11.5, 9, 9, 6.5, 9.5, 12, 9.5, 13, 8.5, 16, 6.5, 8.5, 15, 15.5, 10.5, 12, 11, 10.5, 14, 12.5, 11.5, 12, 8, 11, 12.5, 10, 8.5, 12, 8, 13, 9.5, 11, 13.5, 13, 14.5, 9, 13, 11, 15.5, 11.5, 12.5, 13.5, 9, 7, 9.5, 12, 12, 11.5, 10, 11, 13.5, 11.5, 7.5, 14, 7.5, 13.5, 11, 10, 9.5, 11, 12, 14, 10.5, 11.5, 13.5, 13, 11, 12.5, 14, 10.5, 7, 14.5, 15.5, 11, 12.5, 13, 10.5, 11, 9.5, 11, 11.5, 16, 10.5, 15, 15.5, 12.5, 10.5, 11, 10, 
                                                                                                                                                            11.5, 10.5, 8.5, 12, 13.5, 13.5, 14, 11.5, 10, 9, 8, 12.5, 9.5, 14, 12.5, 12.5, 12, 11.5, 13, 15.5, 13.5, 12, 12.5, 7.5, 12.5, 12.5, 9, 10, 11, 13, 12, 11, 11.5, 11.5, 12, 12, 13, 10.5, 13.5, 12.5, 11, 11.5, 13, 11.5, 15, 13, 12.5, 13, 17.5, 13, 7, 15.5, 14.5, 15.5, 12.5, 16.5, 14, 13.5, 13, 10, 13.5, 15.5, 11.5, 10.5, 10, 8, 11.5, 11, 12, 13, 9, 9, 12, 9.5, 10.5, 12.5, 13, 11.5, 13, 12, 13.5, 12, 12, 12.5, 12.5, 12.5, 11.5, 13.5, 8.5, 11.5, 12.5, 13, 9.5, 10.5, 16, 11, 12, 12, 11, 16.5, 14.5, 13, 
                                                                                                                                                            12.5, 8.5, 9, 11, 12.5, 10, 11, 13.5, 13, 10.5, 8.5, 10.5, 12, 11, 12, 10.5, 11.5, 13, 9, 9, 12, 10, 12, 16, 15.5, 6, 7.5, 5.5, 10.5, 13, 9, 12, 9, 10.5, 12, 10, 4, 7, 6, 6, 10.5, 11, 12.5, 12, 14, 9.5, 12.5, 11.5, 8, 14.5, 11, 13, 11.5, 14.5, 15.5, 14, 12.5, 14, 11, 11, 15, 17, 12.5, 14, 11.5, 11, 13, 13.5, 12, 12, 10, 10.5, 14, 12.5, 10.5, 11.5, 11, 12, 10.5, 6, 11, 7, 10.5, 11.5, 13, 10.5, 8.5, 8.5, 13.5, 14.5, 10.5, 12, 13.5, 5.5, 15.5, 11.5, 11.5, 13, 11.5, 13, 14, 13, 13, 10.5, 11, 11, 15, 
                                                                                                                                                            10.5, 11, 13.5, 12.5, 12.5, 11.5, 13.5, 12.5, 15, 13, 11, 13, 13, 10, 14, 11.5, 10, 15.5, 12, 12, 11.5, 14, 12, 12, 8, 11, 11, 9.5, 13.5, 8, 10.5, 11, 10, 12, 12, 11, 8.5, 11.5, 9.5, 11, 12, 11.5, 10.5, 12.5, 12, 12, 13, 9.5, 12, 14.5, 11.5, 11.5, 12, 11, 12, 9, 13.5, 12.5, 12.5, 11, 12, 11, 13.5, 12, 9.5, 12.5, 10.5, 11.5, 10, 9.5, 11, 9, 13, 11, 8, 11, 12.5, 10, 10.5, 14, 13.5, 12.5, 12.5, 10.5, 11.5, 12, 12, 10.5, 13, 10, 15, 13, 10.5, 11.5, 13, 14, 10, 11, 7, 11, 16, 13.5, 13.5, 15, 10.5, 12, 
                                                                                                                                                            13, 14.5, 14, 14, 6.5, 7, 13.5, 12, 12, 12.5, 12, 10, 11.5, 13.5, 10.5, 12.5, 12, 12, 16, 14.5, 12, 12.5, 12.5, 12, 13.5, 13.5, 13, 12, 13.5, 13.5, 9.5, 14.5, 11.5, 13, 10.5, 15, 12, 11.5, 15, 11, 13, 13, 12, 13, 15, 12, 12.5, 13.5, 12.5, 12, 6.5, 14.5, 12.5, 12, 10.5, 12, 14.5, 12, 12.5, 13.5, 6, 14.5, 12.5, 12, 17, 8, 12.5, 12.5, 13, 12, 11, 12.5, 14.5, 12.5, 8.5, 13, 13, 14, 14, 11, 14.5, 14.5, 12, 13, 13, 13.5, 11, 14.5, 15, 13, 11.5, 13.5, 13, 13.5, 14.5, 13, 12, 13.5, 12.5, 12.5, 13.5, 11, 
                                                                                                                                                            11.5, 12.5, 12.5, 14.5, 10, 12.5, 12, 6, 11, 13.5, 11, 12.5, 13, 10, 12.5, 15, 11, 12, 11.5, 12.5, 9.5, 10.5, 11, 15, 13.5, 11.5, 11.5, 8, 14, 15, 12.5, 11.5, 10.5, 12, 10.5, 8.5, 12, 12.5, 13.5, 13.5, 12, 12, 13.5, 12.5, 12, 14.5, 10.5, 11, 13.5, 10.5, 14, 11.5, 13.5, 10, 12, 14.5, 10.5, 13.5, 11.5, 13, 12.5, 10, 12.5, 11, 13, 11.5, 13.5, 12, 10, 13.5, 13.5, 12, 12.5, 13, 14, 12.5, 12.5, 15, 13.5, 13, 12, 15, 12.5, 12, 11.5, 10.5, 12.5, 13, 11, 11, 11.5, 13, 12, 13.5, 12.5, 17, 11.5, 17, 11.5, 14, 
                                                                                                                                                            13.5, 12.5, 13, 16.5, 12, 13, 12.5, 12.5, 15, 11.5, 14.5, 13.5, 14.5, 12, 13, 15, 11, 12, 11.5, 9, 9.5, 11.5, 10.5, 9.5, 12, 9, 13.5, 12, 12.5, 15, 11.5, 12, 14, 13.5, 13.5, 13, 11.5, 12, 12, 12.5, 9, 13.5, 11, 11.5, 9.5, 12, 12.5, 10, 12.5, 13, 12, 13.5, 10.5, 10.5, 10.5, 12.5, 9.5, 12.5, 11.5, 12, 11.5, 11, 10, 11, 10, 12.5, 7, 10, 11.5, 12, 13, 9.5, 8.5, 12.5, 12, 10.5, 10, 11.5, 10.5, 7.5, 10, 16, 12, 7.5, 13.5, 15, 11, 12, 14.5, 11.5, 12, 11.5, 13, 13.5, 12.5, 12.5, 12, 10, 11.5, 12, 12.5, 10, 
                                                                                                                                                            11, 9, 13, 13, 13.5, 13, 13.5, 10, 12, 15, 10.5, 12, 8, 12.5, 14, 12, 11.5, 11, 14, 12, 15, 11.5, 12, 11, 12.5, 10.5, 11, 9, 8.5, 12.5, 10.5, 13, 14, 11, 11.5, 10, 11.5, 14, 12, 7, 12.5, 8, 12, 13.5, 12, 13, 11, 12.5, 10, 12.5, 12, 9.5, 16.5, 10.5, 14, 11, 10.5, 11.5, 12, 11.5, 10, 14, 12, 11, 14, 12.5, 13.5, 13, 12.5, 12.5, 11, 11.5, 11, 15, 17.5, 14.5, 12.5, 12.5, 12, 9.5, 5, 12, 8, 7.5, 12, 15, 12, 9.5, 12, 13, 17.5, 9.5, 12.5, 12.5, 13.5, 11.5, 12, 14.5, 11, 8, 15, 13.5, 14, 11.5, 10.5, 11.5, 
                                                                                                                                                            11.5, 13.5, 13.5, 11, 11.5, 12, 13, 12, 10.5, 13, 12.5, 15, 13.5, 12.5, 12, 11.5, 11.5, 11.5, 13.5, 8, 13.5, 11, 17, 13.5, 12, 11, 12, 9, 7.5, 11, 12.5, 12, 12.5, 13, 14, 12, 11, 8.5, 12, 13.5, 12, 11.5, 12, 12.5, 11, 11.5, 14, 10.5, 13, 9, 10, 8, 14.5, 13, 11.5, 11.5, 8.5, 9.5, 12.5, 16.5, 12, 10.5, 12, 4, 10.5, 11, 11.5, 13, 10.5, 13, 11.5, 10.5, 12, 11.5, 10, 10.5, 10.5, 11, 13.5, 13.5, 12, 7, 10, 12.5, 14.5, 10, 12, 14.5, 12, 12, 14, 8.5, 9, 11.5, 7.5, 11, 12, 12, 16, 16, 10.5, 13, 11, 12.5, 
                                                                                                                                                            15, 15.5, 10, 11, 12.5, 12, 12, 14.5, 7, 12.5, 11.5, 14, 11, 11, 12.5, 16, 11, 12.5, 8, 10.5, 11, 11.5, 14.5, 13, 16, 13.5, 13.5, 14.5, 8.5, 8.5, 14.5, 10.5, 11.5, 9.5, 10.5, 12, 11.5, 14, 11.5, 12, 11.5, 13.5, 11, 11.5, 9.5, 12, 13.5, 13, 13, 12, 12, 9.5, 10, 11, 6.5, 6.5, 11.5, 11, 12, 10.5, 8.5, 8.5, 8, 12, 10.5, 11, 12, 11.5, 11, 12, 12.5, 11.5, 12, 11, 9, 12.5, 11.5, 12.5, 11, 14, 13, 13.5, 12, 11.5, 15, 10.5, 10.5, 11.5, 12, 12, 11, 12.5, 10, 6, 11, 18, 14.5, 10, 12, 11, 10.5, 11, 13, 11.5, 
                                                                                                                                                            12.5, 15.5, 11, 12, 13, 13, 12, 12, 12.5, 13, 14.5, 11.5, 12.5, 11.5, 17, 13, 9.5, 11, 13.5, 8.5, 10.5, 10.5, 11, 10.5, 10.5, 10.5, 11.5, 11.5, 12, 11.5, 14.5, 10.5, 12, 15, 7, 13, 9, 9, 11, 12.5, 13, 13, 11, 12, 11, 15, 7, 9.5, 12.5, 10, 10.5, 10, 10, 11, 12.5, 12.5, 10.5, 15, 11.5, 15, 14, 11, 12.5, 14, 11.5, 13, 11.5, 10.5, 13.5, 11, 15.5, 15.5, 13, 11.5, 11, 10, 11, 12, 10.5, 12, 13, 12.5, 11.5, 10, 11, 12, 13, 10.5, 13, 15, 12.5, 12, 12, 12.5, 12, 11, 12, 10.5, 16, 15, 7.5, 13, 11.5, 15.5, 12, 
                                                                                                                                                            12.5, 13.5, 15.5, 9.5, 7.5, 14, 10.5, 10.5, 12.5, 14, 13.5, 12.5, 15, 13.5, 14.5, 10.5, 12, 11.5, 15.5, 11.5, 14.5, 15, 13, 12, 13, 13.5, 12.5, 18, 16.5, 11.5, 11, 13.5, 9.5, 8.5, 14, 10.5, 14.5, 12.5, 13, 13, 13.5, 10.5, 9, 14, 15, 11.5, 10, 9, 9.5, 8.5, 10, 8, 7, 11.5, 11, 8.5, 13.5, 11, 10, 12.5, 12, 14.5, 10.5, 13.5, 9, 12, 12, 13, 12.5, 10, 11, 13, 10, 14, 13, 12.5, 13.5, 9.5, 11, 8.5, 10.5, 11, 8.5, 8.5, 12.5, 10.5, 10.5, 10, 11, 14, 12.5, 12, 14, 12, 13, 12.5, 11.5, 14.5, 13.5, 12.5, 12.5, 
                                                                                                                                                            11, 10.5, 11, 12, 10.5, 11.5, 14.5, 13, 13, 11, 15, 9.5, 13, 12.5, 12.5, 11, 12.5, 12.5, 13, 13.5, 11.5, 11.5, 11.5, 13.5, 11.5, 12.5, 15.5, 12, 15.5, 9, 13.5, 12, 13, 12, 13.5, 14.5, 9, 14.5, 14.5, 9, 12.5, 8.5, 13, 13, 11, 13, 15, 12.5, 14.5, 8.5, 16.5, 10, 14, 13.5, 11.5, 11.5, 5.5, 12.5, 13, 13.5, 11, 12, 11.5, 12, 10, 9, 7, 10, 11.5, 8, 10.5, 12, 12, 7, 14, 6, 17, 7, 11.5, 9, 10, 13.5, 15.5, 7.5, 12.5, 10.5, 9, 11, 14.5, 10, 11.5, 15.5, 11.5, 14, 11.5, 9, 11.5, 11.5, 14.5, 12, 13.5, 14, 10, 
                                                                                                                                                            12, 14, 11, 13, 13, 13, 12, 12.5, 12, 13.5, 8.5, 15, 15.5, 16, 14, 16, 14, 11, 7.5, 14.5, 10.5, 15, 10.5, 13.5, 11.5, 10.5, 15, 13, 12.5, 13.5, 12.5, 5.5, 17.5, 9.5, 14.5, 14, 13.5, 10, 12.5, 10.5, 10.5, 10, 10, 12, 11.5, 12.5, 12, 11.5, 8.5, 11.5, 10.5, 7, 12, 11.5, 8, 12.5, 12, 12.5, 12.5, 12.5, 13, 12, 11, 11, 11, 12.5, 9.5, 13, 11, 11, 12.5, 11.5, 12.5, 10.5, 14, 11, 13.5, 12.5, 15, 16.5, 13, 12.5, 8.5, 10, 12, 11.5, 11.5, 15, 10, 12, 14.5, 10, 17.5, 12.5, 13, 12, 10.5, 12, 10, 12.5, 13, 12.5, 
                                                                                                                                                            7, 14, 14, 11.5, 11, 12, 12.5, 11, 13.5, 11, 11.5, 13, 6.5, 12, 12.5, 12, 17, 11.5, 12.5, 13.5, 12, 12, 13.5, 9.5, 12.5, 11.5, 15.5, 12, 14.5, 13, 9.5, 15, 12, 12, 9.5, 12.5, 12, 11.5, 13.5, 12.5, 11.5, 13.5, 11, 11, 13, 12, 9.5, 15, 11.5, 11, 11, 11.5, 12.5, 14.5, 8.5, 13, 12.5, 14, 11, 10.5, 12, 11, 15.5, 8.5, 13, 13.5, 13.5, 14, 11, 13.5, 9.5, 10.5, 12.5, 13.5, 13, 11, 13, 10.5, 10.5, 13.5, 10, 13, 13, 9, 10, 11, 9.5, 8.5, 8, 10, 12.5, 11.5, 12, 11.5, 11.5, 13, 16.5, 11, 13, 12, 11, 14.5, 12.5, 
                                                                                                                                                            11, 13.5, 15, 11.5, 11.5, 12, 13.5, 14, 14, 10, 9.5, 13, 7, 9.5, 13.5, 8.5, 14.5, 15.5, 11, 12.5, 9, 12, 11, 11, 12.5, 10, 12.5, 11, 8, 10, 10, 14.5, 11, 13, 8.5, 7, 11.5, 12.5, 10, 11.5, 9, 10, 11, 9, 10, 9.5, 12.5, 12, 9, 13, 8, 14, 10.5, 12.5, 11, 12.5, 7, 11.5, 12.5, 13.5, 9.5, 14.5, 12.5, 12.5, 12.5, 13, 11, 10.5, 12.5, 14, 16.5, 12.5, 11, 13.5, 12.5, 15.5, 13, 11.5, 10, 10.5, 11.5, 10.5, 12, 8.5, 13.5, 12, 12.5, 10.5, 10.5, 11.5, 11.5, 13, 14.5, 15, 12, 12, 15.5, 12.5, 8, 11.5, 11.5, 12.5, 
                                                                                                                                                            11, 11, 15.5, 14, 12.5, 11.5, 8, 13, 11, 14.5, 12.5, 7.5, 12.5, 13, 10, 12, 12.5, 11, 13.5, 9, 10.5, 12, 11, 6, 9.5, 8, 13.5, 11, 10, 13.5, 11, 9.5, 10, 12.5, 9, 11, 10.5, 12), class = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
                                                                                                                                                                                                                                                                                                                                                       8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
                                                                                                                                                                                                                                                                                                                                                       16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 
                                                                                                                                                                                                                                                                                                                                                       25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 30, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 
                                                                                                                                                                                                                                                                                                                                                       31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 
                                                                                                                                                                                                                                                                                                                                                       37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 
                                                                                                                                                                                                                                                                                                                                                       44, 44, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
                                                                                                                                                                                                                                                                                                                                                       53, 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 
                                                                                                                                                                                                                                                                                                                                                       60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 69, 
                                                                                                                                                                                                                                                                                                                                                       69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 
                                                                                                                                                                                                                                                                                                                                                       74, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 80, 80, 80, 80, 80, 80, 80, 80, 80, 
                                                                                                                                                                                                                                                                                                                                                       80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 85, 
                                                                                                                                                                                                                                                                                                                                                       85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 89, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90, 90, 90, 90, 90, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 92, 
                                                                                                                                                                                                                                                                                                                                                       92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 95, 95, 95, 95, 95, 95, 95, 95, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 99, 99, 99, 
                                                                                                                                                                                                                                                                                                                                                       99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100, 100, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 
                                                                                                                                                                                                                                                                                                                                                       104, 104, 104, 104, 104, 104, 104, 104, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 109, 109, 109, 109, 109, 109, 109, 110, 110, 110, 110, 110, 110, 110, 110, 111, 111, 111, 111, 
                                                                                                                                                                                                                                                                                                                                                       111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 115, 115, 115, 115, 115, 115, 115, 115, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 117, 117, 117, 117, 
                                                                                                                                                                                                                                                                                                                                                       117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 119, 119, 119, 119, 119, 119, 119, 119, 119, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 121, 121, 121, 121, 121, 121, 121, 121, 121, 121, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 124, 124, 124, 124, 
                                                                                                                                                                                                                                                                                                                                                       124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 126, 126, 126, 126, 126, 126, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 
                                                                                                                                                                                                                                                                                                                                                       130, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 133, 133, 133, 133, 133, 133, 133), GS = c(29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 19, 19, 19, 19, 19, 19, 19, 25, 25, 25, 25, 25, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 35, 35, 35, 35, 35, 35, 35, 35, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                28, 28, 28, 28, 28, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 14, 14, 14, 14, 14, 14, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 15, 15, 15, 15, 15, 15, 15, 15, 19, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 28, 28, 28, 28, 28, 28, 28, 28, 28, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 26, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 23, 23, 23, 23, 23, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                28, 28, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 29, 29, 29, 29, 23, 23, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                23, 23, 23, 23, 23, 23, 23, 23, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 15, 15, 15, 15, 15, 15, 15, 15, 15, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 28, 28, 28, 28, 28, 28, 28, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 20, 20, 20, 20, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                22, 22, 22, 22, 22, 22, 22, 22, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                34, 34, 34, 34, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 28, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 32, 32, 32, 32, 32, 32, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 14, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 27, 27, 27, 27, 27, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 22, 22, 22, 22, 22, 22, 22, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 18, 18, 18, 18, 18, 18, 18, 20, 20, 20, 20, 20, 20, 20, 20, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 32, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 15, 15, 15, 15, 15, 15, 15, 15, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 30, 30, 30, 30, 30, 30, 30), SES = c(23, 10, 15, 23, 10, 10, 23, 10, 13, 15, 10, 18, 15, 20, 10, 20, 13, 10, 10, 15, 10, 13, 10, 10, 10, 15, 15, 20, 15, 10, 23, 10, 15, 20, 20, 10, 33, 27, 33, 33, 28, 37, 30, 20, 40, 20, 17, 20, 50, 20, 27, 40, 40, 20, 40, 25, 20, 30, 30, 20, 23, 33, 27, 27, 23, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 30, 35, 37, 23, 15, 50, 27, 35, 33, 25, 20, 30, 28, 33, 25, 33, 50, 15, 25, 50, 30, 38, 20, 35, 50, 35, 35, 20, 18, 18, 20, 20, 28, 28, 18, 18, 18, 23, 23, 23, 20, 18, 23, 25, 23, 20, 20, 10, 20, 30, 20, 23, 17, 23, 20, 23, 23, 37, 17, 17, 33, 20, 30, 27, 23, 23, 27, 27, 20, 35, 40, 33, 30, 33, 17, 23, 37, 20, 20, 45, 40, 43, 28, 33, 35, 47, 23, 23, 28, 23, 47, 40, 40, 27, 23, 27, 40, 30, 23, 27, 35, 23, 40, 20, 20, 20, 35, 45, 47, 50, 50, 45, 40, 35, 35, 35, 45, 15, 20, 37, 25, 23, 27, 20, 20, 20, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 18, 30, 45, 18, 13, 23, 18, 10, 25, 25, 30, 33, 20, 30, 35, 25, 30, 30, 20, 40, 40, 30, 20, 33, 30, 30, 38, 28, 30, 37, 40, 30, 40, 20, 50, 40, 20, 20, 47, 47, 20, 40, 30, 30, 45, 23, 30, 20, 25, 20, 23, 20, 20, 20, 23, 33, 20, 25, 30, 20, 37, 17, 45, 40, 50, 50, 40, 20, 30, 20, 50, 20, 30, 20, 20, 30, 30, 40, 20, 30, 30, 50, 40, 30, 40, 20, 30, 28, 23, 30, 45, 45, 28, 18, 28, 20, 18, 20, 20, 20, 30, 20, 20, 20, 20, 20, 15, 10, 15, 10, 28, 38, 43, 40, 40, 30, 20, 20, 30, 38, 48, 20, 25, 25, 15, 25, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 18, 18, 10, 17, 25, 18, 18, 25, 25, 17, 20, 20, 18, 17, 18, 20, 10, 10, 20, 25, 25, 30, 10, 17, 25, 10, 20, 10, 30, 10, 27, 10, 50, 25, 17, 17, 50, 50, 17, 20, 27, 13, 10, 30, 45, 43, 18, 20, 13, 28, 15, 35, 15, 20, 20, 33, 10, 15, 25, 35, 15, 40, 43, 50, 37, 48, 30, 50, 40, 45, 50, 40, 50, 40, 40, 50, 50, 40, 43, 33, 43, 17, 50, 43, 20, 20, 45, 45, 50, 45, 43, 38, 35, 40, 28, 50, 30, 45, 30, 30, 30, 50, 20, 50, 38, 45, 30, 27, 20, 45, 43, 30, 10, 30, 40, 40, 30, 50, 45, 40, 30, 35, 35, 20, 30, 40, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 40, 40, 30, 50, 40, 30, 40, 40, 45, 35, 45, 50, 40, 50, 50, 50, 40, 40, 35, 30, 30, 50, 10, 33, 33, 25, 33, 40, 50, 37, 40, 20, 18, 28, 25, 30, 25, 40, 28, 50, 35, 10, 13, 23, 10, 25, 30, 27, 20, 50, 30, 37, 10, 18, 10, 43, 37, 27, 30, 25, 23, 25, 30, 25, 50, 40, 50, 30, 30, 45, 50, 30, 30, 30, 30, 40, 20, 20, 40, 50, 50, 30, 30, 50, 18, 30, 25, 13, 43, 15, 43, 13, 37, 40, 33, 50, 10, 28, 37, 37, 35, 13, 30, 30, 30, 45, 17, 40, 17, 30, 37, 33, 33, 37, 30, 30, 33, 37, 20, 20, 27, 30, 23, 17, 23, 37, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 30, 27, 40, 30, 33, 27, 43, 40, 23, 27, 28, 37, 20, 30, 20, 40, 20, 20, 18, 20, 23, 20, 25, 15, 18, 20, 15, 23, 23, 20, 18, 30, 25, 15, 20, 15, 20, 18, 18, 38, 38, 18, 18, 20, 20, 17, 23, 33, 45, 20, 15, 33, 20, 33, 27, 25, 38, 13, 17, 30, 45, 47, 33, 17, 20, 17, 30, 20, 27, 27, 33, 33, 20, 23, 45, 33, 37, 25, 43, 20, 37, 20, 20, 30, 25, 17, 20, 40, 40, 20, 43, 47, 20, 47, 17, 50, 17, 50, 33, 17, 10, 10, 15, 30, 17, 50, 20, 50, 30, 30, 30, 43, 30, 23, 50, 35, 30, 50, 50, 20, 35, 23, 33, 50, 23, 50, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 50, 40, 50, 35, 20, 30, 20, 20, 20, 47, 30, 23, 25, 20, 17, 23, 30, 23, 40, 35, 30, 30, 25, 35, 35, 37, 37, 43, 10, 20, 33, 33, 33, 30, 40, 30, 30, 40, 50, 40, 40, 40, 20, 50, 30, 20, 40, 30, 50, 30, 28, 38, 20, 33, 38, 20, 40, 50, 38, 20, 50, 45, 33, 38, 20, 20, 25, 20, 20, 20, 20, 20, 33, 20, 30, 10, 23, 35, 20, 20, 40, 40, 17, 25, 20, 20, 30, 15, 40, 18, 33, 18, 18, 25, 20, 20, 25, 18, 25, 13, 17, 15, 13, 18, 33, 15, 15, 13, 10, 10, 15, 40, 23, 25, 13, 18, 13, 18, 10, 23, 33, 30, 20, 10, 23, 23, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 13, 33, 30, 30, 35, 33, 25, 23, 20, 30, 20, 35, 30, 33, 33, 30, 15, 10, 20, 10, 15, 30, 10, 43, 20, 47, 23, 37, 23, 30, 40, 47, 35, 27, 33, 50, 20, 50, 37, 43, 43, 50, 50, 50, 20, 30, 37, 18, 28, 47, 40, 33, 23, 28, 23, 37, 13, 10, 20, 15, 10, 18, 10, 23, 23, 10, 10, 20, 10, 10, 20, 20, 13, 15, 10, 15, 47, 30, 35, 50, 50, 50, 50, 50, 30, 50, 20, 40, 30, 20, 30, 20, 20, 30, 28, 23, 20, 45, 20, 20, 20, 28, 27, 20, 10, 10, 20, 23, 40, 10, 20, 25, 18, 33, 23, 13, 30, 18, 33, 33, 30, 30, 30, 27, 27, 33, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 27, 30, 27, 47, 30, 30, 27, 33, 40, 30, 30, 37, 37, 45, 40, 23, 30, 33, 33, 33, 23, 37, 23, 28, 20, 20, 30, 20, 10, 15, 20, 17, 20, 38, 30, 20, 23, 15, 20, 25, 15, 35, 20, 33, 45, 15, 18, 20, 25, 30, 10, 25, 20, 35, 13, 23, 20, 23, 20, 33, 18, 33, 20, 37, 48, 37, 37, 20, 28, 28, 30, 20, 13, 23, 20, 40, 27, 20, 17, 20, 28, 30, 20, 30, 30, 20, 28, 17, 37, 37, 37, 33, 45, 23, 25, 20, 30, 30, 20, 45, 30, 30, 20, 50, 35, 20, 40, 20, 50, 40, 20, 20, 40, 40, 40, 40, 20, 30, 10, 50, 33, 45, 10, 13, 20, 30, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 20, 28, 10, 28, 20, 25, 20, 10, 15, 20, 20, 27, 30, 48, 40, 20, 33, 30, 47, 30, 20, 50, 50, 20, 25, 25, 25, 20, 28, 40, 40, 13, 43, 23, 40, 23, 23, 43, 27, 33, 20, 40, 30, 33, 30, 20, 40, 40, 18, 20, 30, 37, 23, 43, 20, 30, 37, 38, 20, 37, 20, 33, 33, 30, 13, 20, 15, 20, 20, 17, 18, 18, 25, 20, 43, 18, 13, 15, 37, 23, 15, 20, 17, 20, 40, 17, 43, 17, 30, 15, 15, 20, 33, 10, 17, 17, 23, 20, 20, 17, 40, 20, 13, 17, 15, 13, 10, 50, 30, 25, 23, 33, 17, 20, 25, 37, 25, 20, 20, 25, 25, 18, 20, 23, 20, 23, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 23, 20, 25, 20, 25, 23, 43, 20, 10, 20, 23, 25, 23, 28, 23, 20, 28, 48, 35, 28, 38, 48, 28, 20, 15, 50, 33, 30, 50, 33, 35, 33, 23, 45, 35, 33, 43, 33, 37, 33, 43, 47, 40, 20, 45, 23, 33, 43, 20, 30, 47, 40, 20, 45, 20, 50, 20, 40, 30, 40, 40, 40, 40, 10, 40, 20, 30, 50, 40, 50, 20, 40, 40, 50, 30, 30, 30, 20, 10, 20, 20, 30, 20, 20, 20, 20, 20, 47, 23, 47, 33, 20, 20, 47, 17, 23, 23, 20, 20, 40, 23, 20, 30, 50, 40, 30, 37, 47, 43, 40, 30, 43, 47, 47, 30, 43, 47, 37, 43, 30, 33, 40, 40, 40, 30, 25, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 30, 27, 35, 40, 23, 33, 17, 50, 50, 30, 33, 30, 37, 33, 23, 43, 37, 30, 40, 20, 20, 23, 40, 40, 37, 30, 23, 48, 30, 28, 28, 23, 20, 10, 18, 10, 10, 20, 25, 30, 37, 20, 35, 38, 35, 23, 20, 20, 20, 33, 30, 23, 10, 23, 23, 40, 40, 45, 25, 20, 30, 30, 23, 20, 20, 20, 30, 33, 20, 50, 45, 10, 20, 10, 10, 45, 10, 10, 50, 35, 35, 10, 50, 40, 40, 50, 25, 35, 37, 40, 35, 50, 20, 20, 47, 37, 20, 48, 20, 17, 27, 18, 37, 17, 38, 37, 37, 40, 40, 30, 43, 43, 23, 50, 20, 23, 33, 27, 30, 30, 43, 20, 43, 30, 18, 28, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 20, 20, 18, 18, 15, 23, 23, 33, 23, 15, 23, 20, 25, 23, 23, 20, 20, 23, 18, 23, 25, 45, 40, 35, 47, 35, 20, 50, 50, 35, 35, 35, 40, 40, 50, 20, 20, 35, 40, 20, 40, 40, 20, 25, 35, 40, 18, 18, 15, 18, 15, 15, 18, 50, 15, 10, 15, 47, 15, 15, 15, 18, 18, 18, 43, 13, 18, 20, 18, 28, 18, 15, 40, 45, 30, 30, 23, 33, 33, 45, 17, 37, 50, 23, 50, 50, 10, 23, 20, 30, 25, 43, 30, 40, 18, 27, 20, 28, 18, 38, 30, 18, 20, 25, 23, 20, 28, 18, 40, 33, 35, 30, 18, 33, 20, 18, 18, 18, 15, 33, 18, 20, 17, 20, 30, 20, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 20, 17, 20, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 23, 43, 25, 20, 25, 23, 30, 23, 25, 50, 15, 18, 20, 15, 33, 37, 37, 43, 40, 23, 20, 23, 20, 28, 43, 40, 15, 25, 33, 18, 10, 10, 23, 20, 40, 20, 43, 50, 37, 47, 43, 50, 50, 17, 30, 43, 20, 27, 17, 37, 25, 40, 13, 33, 23, 37, 47, 10, 47, 17, 23, 23, 23, 40, 30, 40, 18, 18, 18, 30, 18, 15, 17, 40, 27, 20, 20, 20, 15, 10, 20, 30, 40, 30, 48, 35, 33, 15, 35, 30, 33, 15, 35, 15, 18, 18, 27, 35, 20, 30, 45, 27, 23, 15, 20, 18, 20, 20, 37, 47, 17, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 15, 35, 20, 40, 15, 35, 15, 15, 15, 15, 15, 18, 25, 20, 18, 18, 18, 23, 23, 23, 20, 23, 23, 25, 27, 20, 23, 45, 40, 30, 40, 20, 37, 23, 28, 30, 47, 50, 23, 18, 23, 18, 40, 40, 27, 23, 30, 27, 30, 30, 23, 27, 33, 30, 27, 23, 23, 20, 20, 23, 30, 30, 40, 27, 23, 10, 30, 17, 10, 25, 25, 40, 40, 45, 17, 40, 20, 30, 27, 20, 20, 20, 20, 10, 10, 10, 23, 10, 15, 10, 10, 15, 15, 10, 10, 10, 10, 15, 20, 10, 10, 40, 40, 20, 38, 50, 30, 40, 45, 37, 43, 40, 43, 37, 20, 37, 38, 47, 37, 40, 37, 37, 27, 33, 47, 18, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 20, 35, 23, 18, 28, 20, 25, 20, 20, 18, 30, 10, 17, 10, 13, 27, 13, 20, 17, 20, 23, 10, 20, 43, 50, 10, 23, 33, 20, 47, 10, 10, 10, 35, 40, 35, 43, 48, 48, 30, 35, 40, 30, 43, 38, 35, 28, 35, 30, 25, 18, 20, 33, 18, 23, 15, 23, 18, 18, 18, 27, 18, 17, 15, 25, 23, 18, 25, 17, 18, 18, 18, 18, 28, 15, 20, 10, 20, 20, 20, 20, 20, 47, 20, 15, 20, 40, 20, 37, 15, 15, 20, 43, 17, 30, 17, 10, 27, 50, 23, 20, 20, 20, 20, 33, 20, 20, 18, 20, 20, 38, 28, 23, 25, 20, 27, 40, 27, 20, 17, 20, 20, 35, 28, 35, 28, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 33, 50, 40, 43, 33, 33, 40, 28, 50, 20, 50, 23, 40, 35, 35, 33, 23, 23, 33, 50, 15, 28, 18, 15, 23, 10, 15, 18, 25, 35, 18, 15, 20, 18, 40, 20, 20, 17, 27, 23, 20, 45, 40, 30, 25, 45, 40, 30, 50, 25, 50, 20, 30, 40, 35, 30, 40, 40, 30, 30, 37, 33, 30, 30, 20, 23, 30, 20, 38, 23, 30, 25, 20, 20, 25, 50, 50, 50, 20, 27, 40, 23, 33, 28, 30, 40, 33, 27, 20, 17, 30, 40, 20, 33, 30, 40, 20, 23, 43, 20, 27, 23, 20, 33, 23, 37, 27, 27, 27, 37, 30, 20, 27, 20, 20, 30, 37, 23, 25, 20, 23, 50, 50, 23, 18, 45, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 35, 23, 20, 25, 20, 20, 20, 23, 23, 23, 20, 25, 20, 30, 20, 33, 33, 20, 18, 33, 35, 28, 28, 40, 20, 43, 17, 40, 50, 45, 48, 28, 37, 30, 37, 50, 45, 20, 17, 23, 15, 10, 20, 30, 50, 10, 50, 35, 35, 10, 10, 20, 20, 30, 20, 10, 20, 40, 50, 35, 20, 30, 30, 20, 10, 33, 30, 17, 33, 30, 30, 40, 18, 18, 18, 15, 23, 40, 17, 17, 17, 17, 27, 45, 10, 28, 18, 17, 20, 15, 28, 10, 17, 27, 10, 45, 23, 50, 20, 35, 25, 25, 30, 25, 18, 33, 23, 27, 20, 23, 23, 20, 20, 23, 18, 18, 18, 20, 28, 18, 23, 15, 15, 25, 15, 18, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 18, 35, 40, 50, 40, 50, 50, 35, 50, 50, 40, 30, 15, 27, 27, 50, 33, 30, 23, 23, 33, 33, 33, 33, 40, 20, 37, 20, 20, 23, 23, 47, 33, 33, 33, 33, 23, 17, 28, 33, 30, 18, 17, 27, 48, 40, 37, 47, 40, 27, 10, 47, 33, 30, 40, 23, 15, 15, 28, 20, 20, 27, 23, 30, 17, 10, 17, 17, 30, 10, 10, 27, 10, 13, 10, 17, 25, 25, 18, 25), COMB = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)))
package:MASS
TRUE
FALSE
npk
list(`package:MASS` = list(block = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6), N = c(1, 2, 1, 2, 2, 2, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 1, 1), P = c(2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1), K = c(2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1), yield = c(49.5, 62.8, 46.8, 57, 59.8, 58.5, 55.5, 56, 62.8, 55.8, 69.5, 55, 62, 48.8, 45.5, 44.2, 52, 51.5, 49.8, 48.8, 57.2, 59, 53.2, 56)), `package:datasets` = list(
  block = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6), N = c(1, 2, 1, 2, 2, 2, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 1, 1), P = c(2, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1), K = c(2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1), yield = c(49.5, 62.8, 46.8, 57, 59.8, 58.5, 55.5, 56, 62.8, 55.8, 69.5, 55, 62, 48.8, 45.5, 44.2, 52, 51.5, 49.8, 48.8, 57.2, 59, 53.2, 56)))
c("package:MASS", "package:datasets")
c(TRUE, TRUE)
c(FALSE, TRUE)
npr1
list(`package:MASS` = list(x = c(8, 13.13, 13.88, 13.38, 13.38, 13.88, 12.25, 12.88, 11.25, 11.38, 12, 10.25, 10.25, 10.63, 10.75, 9.25, 9.38, 9.63, 9.75, 9.75, 8.25, 8.75, 8.88, 9, 9.38, 9.5, 9.63, 9.75, 9.75, 9.88, 10, 10, 10.13, 10.13, 10.25, 10.38, 10.5, 10.63, 10.75, 10.75, 10.75, 10.88, 11, 11, 11.25, 11.5, 11.75, 11.88, 11.88, 12.25, 12.25, 12.63, 12.75, 12.88, 13.38, 7.75, 6.13, 7, 8.38, 13.38, 11.88, 11.25, 10.13, 10.88, 9.38, 9.5, 9.5, 10, 8.5, 8.75, 9, 9, 8.75, 9, 9, 9.38, 9.63, 9.88, 
                                 9.88, 10.13, 10.13, 10.5, 10.5, 10.75, 10.88, 11, 11.38, 11.5, 11.13, 11.63, 12.38, 13, 12.25, 12.13, 13, 13.63, 13.63, 13.63, 13.75, 13.88, 13.88, 13.38, 13.5, 13.5), y = c(2.38, 2.5, 3.13, 2.63, 2.13, 2.13, 2.5, 2.25, 3, 2.13, 2.25, 2.88, 2.38, 2.75, 2.25, 2.75, 2.25, 2.63, 3, 2.13, 2.38, 2.13, 2.75, 2.13, 1.25, 1.38, 1.25, 1.63, 1.25, 1.25, 1.63, 1.13, 1.5, 1.25, 1.13, 1.25, 1.13, 1.25, 2, 1.38, 1.13, 1.25, 1.75, 1.13, 1.38, 1.63, 1.75, 1.5, 1.25, 1.88, 1.38, 2, 1.63, 1.13, 1.75, 4.13, 3.38, 3.38, 
                                                                                                                                                                                                               5.63, 4.25, 4.25, 4.38, 4.25, 4.25, 4.38, 4.63, 4.13, 4.13, 4.5, 5, 4.75, 4.25, 3.13, 4, 3.63, 3.25, 3.75, 4, 3.75, 3.13, 3.75, 3.88, 3.38, 3.13, 3.38, 3.88, 3.5, 3.88, 3.25, 4, 3.75, 3.38, 3.63, 3.13, 3.63, 4, 3.63, 3.5, 3.88, 4, 3.63, 3.63, 3.75, 3.13), perm = c(327, 3369, 4770, 938, 568, 667, 2561, 2538, 1078, 1078, 3116, 1619, 1447, 1668, 208, 2994, 2079, 762, 539, 610, 2211, 2617, 993, 1096, 538, 745, 592, 937, 1239, 1055, 185, 1172, 1863, 1141, 892, 2124, 1090, 785, 280, 270, 1752, 2477, 683, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1109, 1385, 1864, 765, 727, 1351, 963, 1309, 1883, 926, 2558, 1339, 1393, 162, 857, 2048, 2105, 1217, 767, 2655, 3790, 3457, 785, 3360, 1255, 213, 248, 3091, 459, 4022, 1169, 681, 1690, 2341, 2763, 758, 305, 2569, 906, 1301, 80, 897, 2169, 1128, 4244, 3347, 2166, 2887, 2383, 4, 1437, 1423, 2005, 1659, 2011, 529, 1484, 918, 2319, 1611, 1454), por = c(33, 34, 40, 35, 32, 34, 32, 34, 36, 34, 36, 34, 34, 34, 35, 35, 35, 33, 32, 35, 32, 32, 31, 35, 33, 35, 34, 36, 32, 36, 27, 35, 35, 33, 35, 35, 33, 32, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        37, 32, 32, 32, 32, 33, 33, 34, 34, 32, 32, 33, 30, 35, 35, 30, 33, 38, 34, 34, 31, 32, 33, 34, 35, 35, 37, 34, 35, 38, 33, 35, 36, 34, 31, 34, 30, 37, 36, 35, 35, 36, 38, 30, 34, 31, 38, 33, 28, 34, 36, 36, 36, 35, 31, 37, 33, 31, 37, 37, 32, 33, 34, 36, 37, 36)))
package:MASS
TRUE
FALSE
Null
list(`package:MASS` = function (M) 
{
  tmp <- qr(M)
  set <- if (tmp$rank == 0) 
    seq_len(ncol(M))
  else -seq_len(tmp$rank)
  qr.Q(tmp, complete = TRUE)[, set, drop = FALSE]
}, function (M) 
{
  tmp <- qr(M)
  set <- if (tmp$rank == 0) 
    seq_len(ncol(M))
  else -seq_len(tmp$rank)
  qr.Q(tmp, complete = TRUE)[, set, drop = FALSE]
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
oats
list(`package:MASS` = list(B = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6), V = c(3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2), N = c(1, 2, 3, 4, 1, 2, 3, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4), Y = c(111, 130, 157, 174, 117, 114, 161, 141, 105, 140, 118, 156, 61, 91, 97, 100, 70, 108, 126, 149, 96, 124, 121, 144, 68, 64, 112, 86, 60, 102, 89, 96, 89, 129, 132, 124, 74, 89, 81, 122, 64, 103, 132, 133, 70, 89, 104, 117, 62, 90, 100, 116, 80, 82, 94, 126, 63, 70, 109, 99, 53, 74, 118, 113, 89, 82, 86, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      104, 97, 99, 119, 121)))
package:MASS
TRUE
FALSE
OME
list(`package:MASS` = list(ID = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 16, 16, 
                                  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 27, 27, 27, 27, 27, 27, 27, 27, 27, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 
                                  31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 
                                  43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 
                                  57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 
                                  63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 
                                  69, 69, 70, 70, 70, 70, 70, 70, 70, 70, 70, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 77, 77, 77, 77, 77, 77, 77, 77, 77, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 85, 85, 85, 85, 85, 85, 85, 85, 
                                  85, 85, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 91, 91, 91, 91, 91, 91, 91, 91, 91, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 95, 95, 95, 95, 95, 95, 95, 
                                  95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100), Age = c(30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 
                                                                                                                                                                                                                                                                                                                                                         30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 
                                                                                                                                                                                                                                                                                                                                                         30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 
                                                                                                                                                                                                                                                                                                                                                         30, 30, 30, 30, 30, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 
                                                                                                                                                                                                                                                                                                                                                         30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 18, 30, 18, 30, 18, 30, 18, 30, 
                                                                                                                                                                                                                                                                                                                                                         18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 18, 18, 18, 18, 18, 18, 7, 7, 7, 7, 7, 7, 7, 7, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 30, 7, 7, 7, 7, 7, 7, 7, 7, 18, 30, 18, 
                                                                                                                                                                                                                                                                                                                                                         30, 18, 30, 30, 18, 30, 30, 18, 30, 18, 30, 18, 30, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 30, 18, 30, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 18, 18, 18, 18, 18, 18, 18, 18, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 
                                                                                                                                                                                                                                                                                                                                                         18, 18, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 18, 30, 30, 18, 30, 30, 18, 30, 30, 18, 30, 30, 18, 30, 30, 18, 30, 30, 18, 30, 30, 18, 30, 30, 18, 30, 30, 18, 30, 30, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 30, 30, 30, 30, 30, 30, 30, 
                                                                                                                                                                                                                                                                                                                                                         30, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 30, 30, 30, 30, 30, 30, 30, 30, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 18, 30, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 18, 18, 18, 18, 18, 18, 18, 18, 
                                                                                                                                                                                                                                                                                                                                                         18, 18), OME = c(3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
                                                                                                                                                                                                                                                                                                                                                                          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
                                                                                                                                                                                                                                                                                                                                                                          3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 
                                                                                                                                                                                                                                                                                                                                                                          1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 3, 3, 1, 3, 3, 1, 3, 1, 3, 1, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                          2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), Loud = c(35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 40, 45, 50, 55, 65, 40, 45, 50, 55, 65, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 35, 35, 35, 35, 40, 40, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 40, 45, 50, 55, 65, 40, 45, 50, 55, 65, 35, 40, 40, 45, 45, 50, 55, 45, 50, 55, 40, 45, 50, 55, 65, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 40, 45, 50, 55, 65, 40, 45, 50, 55, 65, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 40, 45, 50, 55, 65, 40, 45, 50, 55, 65, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                55, 55, 40, 45, 50, 55, 40, 45, 50, 55, 35, 35, 35, 35, 40, 40, 40, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 40, 45, 50, 55, 65, 40, 45, 50, 55, 65, 35, 35, 35, 35, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 35, 40, 45, 50, 55, 35, 45, 50, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 35, 35, 35, 35, 40, 40, 40, 40, 40, 40, 45, 45, 45, 45, 45, 45, 50, 50, 50, 50, 50, 50, 55, 55, 55, 55, 55, 55, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 40, 45, 50, 55, 35, 40, 45, 50, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55, 35, 40, 45, 50, 55, 40, 45, 50, 55, 35, 35, 35, 35, 40, 40, 40, 40, 45, 45, 45, 45, 50, 50, 50, 50, 55, 55, 55, 55, 35, 40, 45, 50, 55, 35, 40, 45, 50, 55, 35, 40, 45, 50, 55, 35, 40, 45, 50, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                55, 40, 45, 50, 55, 65, 40, 45, 50, 55, 65, 35, 40, 45, 50, 55, 35, 40, 45, 50, 55, 35, 40, 45, 50, 55, 35, 40, 45, 50, 55, 35, 35, 40, 40, 45, 45, 50, 50, 55, 55), Noise = c(1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               2, 1, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2), Correct = c(1, 4, 0, 1, 2, 2, 3, 4, 3, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 3, 1, 1, 1, 5, 4, 2, 3, 4, 4, 4, 4, 5, 5, 6, 9, 8, 6, 5, 2, 3, 2, 7, 2, 7, 7, 7, 4, 4, 1, 2, 2, 3, 3, 5, 5, 3, 5, 2, 4, 6, 9, 8, 5, 9, 11, 9, 8, 4, 7, 3, 3, 9, 7, 9, 12, 11, 5, 11, 1, 1, 3, 1, 2, 2, 2, 3, 3, 2, 1, 2, 3, 2, 1, 2, 3, 3, 4, 2, 3, 9, 4, 4, 5, 5, 7, 5, 9, 5, 4, 5, 1, 7, 6, 8, 10, 10, 5, 7, 4, 5, 2, 6, 2, 7, 4, 7, 9, 4, 1, 2, 2, 2, 2, 4, 2, 3, 3, 6, 3, 3, 3, 2, 3, 6, 4, 5, 3, 3, 5, 6, 3, 7, 7, 8, 7, 7, 8, 8, 1, 1, 1, 1, 1, 2, 1, 1, 3, 2, 3, 0, 2, 0, 2, 5, 1, 2, 2, 1, 1, 1, 3, 2, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       4, 1, 3, 4, 5, 2, 2, 5, 3, 8, 7, 4, 3, 4, 2, 2, 2, 5, 2, 2, 4, 6, 3, 1, 1, 2, 1, 3, 2, 6, 5, 3, 5, 5, 3, 5, 2, 3, 3, 3, 6, 6, 5, 3, 4, 4, 7, 6, 7, 9, 6, 6, 8, 5, 0, 0, 1, 1, 0, 4, 2, 2, 5, 2, 1, 0, 1, 1, 4, 7, 4, 1, 2, 3, 2, 3, 9, 3, 3, 6, 5, 10, 5, 2, 2, 4, 2, 3, 5, 7, 5, 6, 5, 0, 2, 2, 2, 2, 5, 2, 3, 2, 0, 7, 9, 8, 10, 6, 9, 9, 10, 13, 10, 2, 2, 1, 1, 2, 5, 5, 3, 2, 1, 1, 1, 1, 2, 2, 1, 3, 3, 4, 4, 1, 5, 7, 7, 8, 6, 11, 9, 0, 3, 2, 2, 2, 3, 3, 7, 6, 5, 1, 2, 2, 6, 1, 3, 3, 2, 6, 3, 1, 3, 1, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 5, 2, 1, 3, 3, 1, 4, 4, 3, 1, 8, 5, 4, 6, 3, 1, 0, 1, 3, 1, 2, 4, 3, 1, 1, 2, 2, 4, 5, 1, 6, 4, 7, 4, 3, 0, 0, 2, 1, 2, 1, 3, 3, 2, 2, 3, 1, 3, 3, 3, 4, 6, 4, 1, 1, 2, 1, 0, 2, 1, 1, 4, 6, 3, 3, 1, 1, 1, 2, 2, 0, 3, 3, 5, 3, 1, 1, 4, 1, 0, 6, 0, 2, 4, 3, 2, 2, 1, 3, 2, 2, 1, 3, 3, 1, 4, 2, 3, 2, 5, 4, 3, 2, 5, 3, 5, 3, 8, 6, 4, 4, 3, 1, 6, 4, 1, 1, 1, 2, 0, 3, 3, 4, 1, 2, 4, 3, 4, 2, 2, 1, 1, 1, 4, 2, 3, 2, 6, 4, 2, 1, 2, 1, 6, 5, 2, 1, 0, 1, 1, 1, 2, 3, 2, 4, 1, 1, 2, 4, 6, 2, 2, 1, 3, 3, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 2, 1, 2, 2, 2, 1, 3, 2, 4, 1, 5, 3, 7, 3, 7, 2, 4, 1, 1, 2, 2, 0, 1, 2, 2, 4, 2, 2, 2, 5, 3, 3, 3, 5, 5, 4, 3, 1, 3, 2, 4, 4, 2, 1, 2, 2, 3, 1, 5, 2, 5, 4, 3, 3, 7, 3, 3, 2, 2, 2, 4, 4, 5, 1, 4, 4, 2, 3, 1, 0, 0, 1, 1, 1, 1, 1, 1, 3, 3, 2, 3, 4, 1, 1, 1, 0, 1, 0, 2, 4, 3, 2, 3, 2, 1, 0, 0, 2, 2, 5, 1, 2, 0, 2, 3, 3, 3, 3, 2, 3, 2, 2, 3, 0, 3, 3, 3, 1, 0, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 0, 0, 2, 1, 3, 1, 3, 3, 3, 2, 2, 1, 4, 1, 4, 5, 4, 3, 4, 5, 1, 5, 1, 2, 1, 3, 1, 2, 3, 1, 4, 1, 1, 4, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       4, 4, 5, 2, 3, 2, 1, 2, 2, 4, 1, 0, 2, 2, 1, 1, 0, 2, 0, 0, 2, 2, 2, 3, 2, 1, 1, 2, 1, 4, 4, 0, 2, 2, 3, 1, 2, 1, 4, 6, 3, 2, 4, 6, 3, 4, 4, 3, 3, 3, 1, 2, 2, 3, 3, 4, 2, 3, 2, 2, 4, 2, 1, 1, 0, 3, 6, 1, 2, 1, 1, 2, 5, 3, 2, 4, 3, 3, 1, 1, 4, 1, 1, 2, 0, 2, 3, 5, 3, 0, 2, 3, 3, 6, 5, 1, 1, 2, 2, 4, 1, 1, 2, 2, 1, 3, 4, 3, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 1, 2, 1, 1, 1, 4, 3, 1, 5, 2, 3, 1, 0, 0, 0, 1, 2, 0, 2, 1, 0, 2, 6, 2, 4, 3, 1, 1, 0, 2, 3, 3, 1, 2, 3, 2, 2, 2, 2, 1, 1, 3, 4, 3, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       5, 3, 5, 3, 3, 2, 2, 6, 1, 3, 0, 1, 3, 3, 1, 2, 2, 2, 2, 2, 0, 2, 4, 6, 6, 4, 6, 4, 2, 4, 4, 2, 3, 4, 6, 5, 3, 7, 4, 4, 0, 4, 6, 5, 7, 4, 3, 4, 6, 2, 0, 3, 4, 2, 1, 2, 4, 4, 2, 0, 1, 3, 1, 1, 1, 2, 3, 1, 3, 3, 3, 2, 3, 4, 3, 2, 4, 2, 2, 3, 1, 1, 1, 1, 2, 3, 1, 1, 3, 4, 0, 2, 4, 4, 2, 4, 8, 6, 6, 2, 0, 4, 3, 1, 7, 3, 4, 2, 1, 2, 2, 1, 2, 2, 1, 3, 2, 4, 1, 0, 3, 4, 1, 6, 2, 3, 1, 2, 3, 3, 3, 3, 4, 4, 2, 3, 4, 3, 0, 2, 4, 4, 4, 4, 3, 3, 2, 3, 1, 1, 5, 3, 1, 3, 2, 7, 2, 3, 1, 1, 3, 2, 3, 5, 4, 3, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 2, 1, 5, 1, 2, 1, 4, 2, 2, 2, 1, 3, 1, 0, 1, 3, 1, 1, 2, 3, 2, 5, 2, 1, 1, 5, 1, 2, 1, 1, 0, 3, 4, 1, 2, 3, 7, 3, 0, 3, 2, 3, 3, 2, 2, 0, 2, 4, 0, 4, 3, 5, 7, 4, 5, 5, 3, 5, 1, 2, 3, 6, 5, 3, 8, 2, 5, 5, 4, 0, 2, 2, 3, 2, 2, 3, 2, 5, 3, 4, 3, 5, 1, 3, 7, 3, 4, 5), Trials = c(4, 5, 3, 1, 4, 2, 3, 4, 3, 2, 4, 4, 4, 1, 2, 5, 4, 2, 3, 4, 6, 6, 10, 5, 6, 6, 10, 8, 6, 6, 5, 6, 6, 7, 4, 7, 8, 7, 4, 4, 3, 4, 3, 3, 6, 5, 5, 4, 7, 2, 11, 7, 10, 8, 11, 9, 11, 9, 8, 4, 10, 7, 6, 9, 10, 9, 14, 11, 6, 11, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              2, 4, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 3, 2, 3, 3, 5, 2, 7, 10, 8, 4, 6, 5, 7, 5, 9, 5, 6, 6, 3, 7, 11, 8, 10, 10, 5, 7, 7, 6, 2, 6, 3, 7, 4, 7, 9, 4, 4, 4, 4, 2, 4, 4, 2, 3, 3, 6, 4, 5, 5, 3, 4, 6, 4, 5, 3, 3, 9, 8, 7, 7, 13, 8, 8, 7, 8, 8, 3, 1, 2, 2, 3, 2, 1, 2, 3, 3, 3, 2, 2, 2, 2, 5, 1, 2, 2, 3, 2, 4, 4, 4, 3, 4, 2, 3, 4, 9, 3, 5, 5, 8, 8, 7, 4, 3, 4, 4, 2, 3, 7, 3, 2, 4, 6, 4, 1, 4, 4, 3, 3, 2, 6, 5, 3, 5, 5, 6, 6, 4, 3, 5, 3, 6, 6, 5, 3, 5, 6, 7, 6, 8, 10, 7, 6, 8, 5, 2, 3, 1, 1, 2, 4, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              2, 5, 4, 3, 3, 3, 5, 4, 7, 4, 1, 2, 4, 2, 7, 9, 4, 3, 6, 5, 10, 5, 5, 5, 5, 2, 4, 5, 7, 5, 6, 5, 2, 2, 4, 2, 5, 5, 2, 3, 2, 1, 11, 10, 11, 11, 12, 9, 9, 10, 13, 10, 5, 2, 3, 1, 3, 5, 5, 3, 2, 1, 4, 3, 1, 2, 2, 1, 3, 3, 13, 10, 2, 5, 10, 7, 8, 6, 14, 9, 5, 4, 4, 5, 4, 3, 5, 7, 6, 5, 2, 3, 4, 6, 2, 3, 3, 2, 6, 3, 5, 3, 2, 4, 4, 5, 2, 1, 3, 3, 4, 7, 7, 3, 4, 8, 5, 4, 6, 3, 2, 1, 3, 4, 3, 2, 4, 3, 1, 1, 2, 3, 7, 6, 3, 6, 4, 7, 4, 3, 1, 2, 4, 1, 3, 2, 3, 4, 2, 3, 4, 1, 4, 4, 4, 4, 6, 4, 1, 1, 4, 3, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              2, 4, 1, 4, 6, 3, 3, 2, 2, 3, 4, 3, 1, 3, 3, 5, 4, 4, 3, 4, 2, 3, 6, 1, 2, 4, 3, 2, 2, 3, 3, 5, 2, 2, 3, 3, 1, 8, 5, 4, 3, 7, 6, 3, 2, 7, 4, 6, 4, 8, 6, 4, 4, 3, 1, 6, 4, 2, 2, 4, 2, 3, 3, 4, 4, 1, 2, 6, 5, 7, 4, 3, 2, 1, 1, 6, 4, 3, 2, 7, 5, 2, 1, 2, 1, 6, 5, 4, 1, 1, 2, 2, 1, 2, 3, 2, 4, 3, 2, 2, 4, 6, 4, 2, 1, 5, 3, 8, 2, 3, 1, 5, 3, 4, 1, 6, 2, 4, 1, 6, 3, 7, 3, 7, 2, 4, 1, 4, 5, 3, 1, 4, 3, 3, 6, 4, 3, 2, 5, 3, 3, 3, 5, 5, 4, 3, 1, 4, 2, 11, 6, 3, 2, 4, 3, 8, 4, 5, 2, 6, 4, 3, 3, 7, 3, 3, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              5, 4, 4, 5, 5, 1, 5, 4, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 4, 2, 5, 4, 1, 2, 2, 3, 2, 2, 2, 4, 3, 2, 3, 3, 3, 3, 2, 2, 2, 5, 1, 4, 2, 2, 3, 3, 4, 3, 2, 3, 3, 2, 3, 1, 3, 3, 3, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 4, 2, 1, 2, 1, 2, 1, 3, 4, 3, 3, 3, 2, 2, 1, 6, 2, 6, 5, 4, 4, 5, 5, 1, 5, 2, 2, 2, 4, 2, 2, 3, 3, 5, 3, 1, 4, 1, 4, 4, 5, 2, 3, 2, 1, 3, 2, 5, 3, 2, 3, 2, 1, 4, 1, 3, 2, 2, 2, 2, 3, 3, 2, 2, 1, 2, 1, 4, 4, 2, 3, 4, 3, 5, 3, 2, 4, 6, 6, 2, 4, 6, 3, 4, 4, 3, 4, 3, 1, 3, 3, 3, 3, 6, 4, 4, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              2, 4, 3, 2, 4, 2, 4, 6, 1, 6, 3, 1, 2, 6, 4, 2, 4, 3, 3, 1, 1, 5, 2, 4, 3, 3, 4, 3, 5, 4, 3, 2, 3, 3, 8, 5, 1, 1, 2, 2, 4, 3, 2, 3, 3, 3, 3, 5, 3, 2, 4, 2, 1, 1, 3, 2, 2, 2, 2, 3, 4, 4, 2, 2, 2, 4, 3, 1, 5, 3, 3, 4, 2, 1, 2, 2, 2, 1, 4, 2, 1, 2, 6, 4, 4, 3, 1, 1, 1, 2, 3, 3, 2, 2, 3, 2, 2, 2, 3, 3, 2, 4, 4, 5, 3, 1, 5, 3, 5, 3, 5, 3, 3, 2, 2, 6, 1, 3, 1, 2, 4, 3, 1, 3, 2, 2, 2, 4, 2, 4, 4, 8, 6, 4, 6, 4, 2, 7, 6, 7, 3, 6, 6, 5, 4, 7, 4, 7, 7, 5, 6, 9, 8, 5, 3, 4, 7, 5, 2, 3, 4, 2, 1, 3, 4, 4, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              1, 2, 8, 2, 2, 2, 3, 4, 2, 3, 3, 3, 4, 3, 5, 3, 2, 5, 2, 2, 3, 1, 1, 1, 1, 2, 3, 1, 1, 3, 6, 6, 8, 6, 4, 2, 4, 8, 6, 6, 5, 3, 5, 5, 1, 7, 3, 4, 2, 3, 2, 3, 5, 3, 4, 2, 3, 2, 4, 2, 3, 4, 4, 3, 6, 3, 3, 2, 2, 3, 5, 5, 4, 6, 4, 3, 3, 4, 3, 1, 2, 7, 5, 4, 4, 3, 3, 2, 4, 7, 3, 6, 4, 3, 4, 2, 8, 2, 4, 5, 3, 4, 6, 3, 5, 5, 3, 1, 4, 4, 4, 5, 1, 2, 1, 4, 2, 2, 5, 1, 4, 3, 3, 1, 4, 3, 6, 2, 3, 3, 5, 2, 1, 1, 5, 1, 2, 4, 3, 2, 3, 4, 2, 3, 3, 7, 3, 2, 3, 2, 3, 3, 2, 4, 1, 2, 4, 3, 5, 4, 6, 7, 6, 6, 5, 4, 5, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              4, 6, 5, 6, 5, 4, 8, 2, 5, 5, 6, 3, 3, 2, 4, 4, 2, 3, 2, 5, 4, 5, 5, 5, 2, 4, 7, 3, 5, 5)))
package:MASS
TRUE
FALSE
painters
list(`package:MASS` = list(Composition = c(10, 15, 8, 12, 0, 15, 8, 15, 4, 17, 10, 13, 10, 15, 13, 12, 14, 16, 10, 13, 11, 15, 6, 4, 8, 6, 12, 5, 8, 15, 12, 15, 14, 6, 13, 15, 18, 14, 15, 8, 9, 4, 8, 11, 10, 13, 15, 18, 15, 15, 10, 16, 15, 15), Drawing = c(8, 16, 13, 16, 15, 16, 17, 16, 12, 18, 13, 15, 15, 14, 14, 15, 15, 14, 10, 12, 15, 15, 8, 6, 9, 8, 9, 6, 14, 14, 15, 10, 14, 6, 13, 17, 10, 13, 17, 10, 10, 15, 6, 10, 8, 14, 6, 13, 12, 10, 8, 16, 15, 17), Colour = c(16, 4, 16, 9, 8, 4, 4, 7, 10, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         12, 8, 8, 6, 7, 10, 5, 6, 12, 6, 9, 0, 12, 17, 14, 18, 15, 14, 16, 17, 16, 18, 16, 10, 16, 15, 9, 10, 10, 13, 10, 16, 6, 6, 14, 16, 10, 17, 17, 13, 17, 8, 8, 4, 6), Expression = c(3, 14, 7, 8, 0, 14, 8, 6, 4, 18, 8, 8, 6, 10, 9, 8, 10, 6, 2, 6, 6, 13, 0, 0, 4, 4, 6, 0, 5, 4, 6, 3, 6, 0, 12, 17, 4, 5, 13, 8, 13, 6, 4, 6, 6, 10, 12, 17, 6, 13, 4, 16, 15, 15), School = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 7, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            7, 7, 7, 7, 7, 7, 8, 8, 8, 8)))
package:MASS
TRUE
FALSE
parcoord
list(`package:MASS` = function (x, col = 1, lty = 1, var.label = FALSE, ...) 
{
  rx <- apply(x, 2, range, na.rm = TRUE)
  x <- apply(x, 2, function(x) (x - min(x, na.rm = TRUE))/(max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
  matplot(1:ncol(x), t(x), type = "l", col = col, lty = lty, xlab = "", ylab = "", axes = FALSE, ...)
  axis(1, at = 1:ncol(x), labels = colnames(x))
  for (i in 1:ncol(x)) {
    lines(c(i, i), c(0, 1), col = "grey70")
    if (var.label) 
      text(c(i, i), c(0, 1), labels = format(rx[, i], digits = 3), xpd = NA, offset = 0.3, pos = c(1, 3), cex = 0.7)
  }
  invisible()
}, function (x, col = 1, lty = 1, var.label = FALSE, ...) 
{
  rx <- apply(x, 2, range, na.rm = TRUE)
  x <- apply(x, 2, function(x) (x - min(x, na.rm = TRUE))/(max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
  matplot(1:ncol(x), t(x), type = "l", col = col, lty = lty, xlab = "", ylab = "", axes = FALSE, ...)
  axis(1, at = 1:ncol(x), labels = colnames(x))
  for (i in 1:ncol(x)) {
    lines(c(i, i), c(0, 1), col = "grey70")
    if (var.label) 
      text(c(i, i), c(0, 1), labels = format(rx[, i], digits = 3), xpd = NA, offset = 0.3, pos = c(1, 3), cex = 0.7)
  }
  invisible()
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
petrol
list(`package:MASS` = list(No = c(1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 10, 10, 10), SG = c(50.8, 50.8, 50.8, 50.8, 40.8, 40.8, 40.8, 40, 40, 40, 38.4, 38.4, 38.4, 38.4, 40.3, 40.3, 40.3, 32.2, 32.2, 32.2, 41.3, 41.3, 41.3, 41.3, 38.1, 38.1, 38.1, 32.2, 32.2, 31.8, 31.8, 31.8), VP = c(8.6, 8.6, 8.6, 8.6, 3.5, 3.5, 3.5, 6.1, 6.1, 6.1, 6.1, 6.1, 6.1, 6.1, 4.8, 4.8, 4.8, 5.2, 5.2, 5.2, 1.8, 1.8, 1.8, 1.8, 1.2, 1.2, 1.2, 2.4, 2.4, 0.2, 0.2, 0.2), V10 = c(190, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        190, 190, 190, 210, 210, 210, 217, 217, 217, 220, 220, 220, 220, 231, 231, 231, 236, 236, 236, 267, 267, 267, 267, 274, 274, 274, 284, 284, 316, 316, 316), EP = c(205, 275, 345, 407, 218, 273, 347, 212, 272, 340, 235, 300, 365, 410, 307, 367, 395, 267, 360, 402, 235, 275, 358, 416, 285, 365, 444, 351, 424, 365, 379, 428), Y = c(12.2, 22.3, 34.7, 45.7, 8, 13.1, 26.6, 7.4, 18.2, 30.4, 6.9, 15.2, 26, 33.6, 14.4, 26.8, 34.9, 10, 24.8, 31.7, 2.8, 6.4, 16.1, 27.8, 5, 17.6, 32.1, 14, 23.2, 8.5, 14.7, 18
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        )))
package:MASS
TRUE
FALSE
phones
list(`package:MASS` = list(year = c(50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73), calls = c(4.4, 4.7, 4.7, 5.9, 6.6, 7.3, 8.1, 8.8, 10.6, 12, 13.5, 14.9, 16.1, 21.2, 119, 124, 142, 159, 182, 212, 43, 24, 27, 29)))
package:MASS
TRUE
FALSE
Pima.te
list(`package:MASS` = list(npreg = c(6, 1, 1, 3, 2, 5, 0, 1, 3, 9, 1, 5, 3, 10, 4, 9, 2, 4, 3, 7, 9, 0, 2, 1, 1, 5, 7, 1, 0, 5, 0, 1, 4, 2, 4, 5, 2, 3, 7, 0, 13, 2, 15, 4, 7, 2, 6, 1, 1, 1, 4, 1, 7, 4, 0, 2, 1, 1, 4, 3, 8, 0, 0, 5, 2, 2, 2, 9, 1, 7, 2, 17, 4, 7, 0, 6, 2, 8, 0, 1, 8, 4, 0, 0, 5, 8, 2, 0, 5, 6, 5, 7, 1, 1, 3, 4, 0, 6, 3, 7, 0, 1, 4, 6, 2, 9, 0, 9, 1, 2, 1, 3, 11, 4, 5, 2, 10, 2, 2, 7, 0, 2, 7, 7, 1, 4, 0, 0, 6, 2, 0, 2, 2, 10, 0, 2, 2, 3, 7, 3, 13, 2, 1, 1, 2, 6, 8, 2, 1, 1, 1, 8, 
                                     1, 3, 1, 1, 5, 5, 4, 5, 3, 3, 0, 0, 1, 0, 0, 1, 1, 1, 5, 8, 3, 1, 2, 3, 3, 5, 9, 1, 6, 1, 1, 3, 4, 3, 1, 2, 0, 8, 1, 1, 3, 1, 1, 0, 4, 0, 0, 0, 1, 0, 9, 9, 8, 5, 0, 0, 1, 0, 4, 3, 0, 0, 0, 1, 0, 2, 2, 4, 4, 2, 6, 2, 3, 7, 3, 12, 3, 3, 9, 6, 2, 3, 2, 1, 0, 3, 10, 4, 1, 8, 5, 4, 1, 3, 1, 1, 11, 6, 1, 3, 2, 1, 1, 6, 3, 11, 2, 2, 6, 1, 1, 1, 1, 1, 0, 3, 6, 11, 2, 9, 0, 4, 4, 0, 1, 7, 1, 3, 0, 11, 1, 2, 2, 1, 4, 10, 6, 6, 10, 3, 0, 0, 2, 1, 7, 3, 6, 2, 2, 5, 10, 0, 7, 3, 10, 1, 5, 1, 0, 2, 2, 0, 8, 2, 
                                     11, 3, 1, 13, 12, 1, 3, 1, 3, 0, 1, 2, 9, 10, 5, 1), glu = c(148, 85, 89, 78, 197, 166, 118, 103, 126, 119, 97, 109, 88, 122, 103, 102, 90, 111, 180, 106, 171, 180, 71, 103, 101, 88, 150, 73, 105, 99, 109, 95, 146, 100, 129, 95, 112, 113, 83, 101, 106, 100, 136, 123, 81, 92, 93, 122, 81, 126, 144, 89, 160, 97, 162, 107, 88, 117, 173, 170, 84, 100, 93, 106, 108, 106, 90, 156, 153, 152, 88, 163, 151, 102, 114, 104, 75, 179, 129, 128, 109, 109, 113, 108, 111, 196, 81, 147, 109, 125, 85, 142, 100, 87, 
                                                                                                  162, 197, 117, 134, 74, 181, 179, 91, 91, 119, 146, 184, 165, 124, 111, 90, 113, 111, 155, 95, 96, 128, 101, 108, 100, 106, 104, 108, 133, 136, 119, 96, 78, 107, 151, 146, 126, 144, 120, 161, 128, 124, 155, 113, 109, 115, 152, 112, 157, 122, 102, 105, 118, 87, 95, 130, 95, 126, 139, 99, 125, 196, 189, 103, 147, 99, 81, 173, 84, 98, 87, 93, 105, 90, 125, 119, 116, 105, 100, 131, 127, 96, 193, 136, 72, 172, 102, 112, 143, 173, 144, 129, 119, 94, 102, 151, 181, 95, 89, 80, 90, 189, 117, 180, 104, 120, 
                                                                                                  82, 91, 134, 120, 74, 88, 124, 97, 144, 137, 132, 158, 123, 84, 135, 139, 173, 83, 89, 99, 125, 81, 154, 117, 84, 94, 96, 84, 99, 163, 145, 129, 68, 87, 122, 77, 127, 128, 90, 84, 88, 186, 187, 131, 116, 84, 88, 84, 103, 99, 99, 111, 98, 143, 119, 108, 176, 111, 112, 82, 123, 89, 108, 124, 181, 92, 152, 174, 105, 138, 68, 112, 94, 90, 94, 102, 128, 97, 100, 103, 179, 136, 117, 155, 101, 112, 145, 111, 98, 165, 68, 123, 162, 95, 129, 107, 142, 169, 80, 127, 93, 126, 129, 134, 187, 173, 94, 108, 117, 
                                                                                                  116, 141, 174, 106, 126, 65, 99, 120, 102, 109, 153, 100, 147, 187, 121, 108, 181, 128, 88, 170, 101, 121, 93), bp = c(72, 66, 66, 50, 70, 72, 84, 30, 88, 80, 66, 75, 58, 78, 60, 76, 68, 72, 64, 92, 110, 66, 70, 80, 50, 66, 66, 50, 64, 74, 88, 66, 85, 66, 86, 72, 66, 44, 78, 65, 72, 68, 70, 80, 78, 62, 50, 90, 72, 56, 58, 76, 54, 60, 76, 74, 30, 88, 70, 64, 74, 70, 60, 82, 52, 64, 70, 86, 82, 88, 74, 72, 90, 74, 80, 74, 64, 72, 110, 98, 76, 64, 80, 68, 72, 76, 60, 85, 62, 68, 74, 60, 66, 78, 52, 
                                                                                                                                                                                                                         70, 80, 80, 68, 84, 90, 64, 70, 50, 76, 85, 90, 70, 86, 80, 64, 56, 76, 70, 74, 64, 86, 62, 70, 60, 64, 62, 88, 74, 86, 56, 88, 62, 62, 70, 84, 58, 76, 68, 68, 68, 74, 50, 80, 66, 90, 75, 72, 64, 86, 70, 72, 58, 60, 70, 74, 88, 46, 62, 50, 76, 64, 108, 74, 54, 86, 82, 64, 82, 60, 100, 68, 62, 70, 54, 74, 100, 68, 64, 58, 56, 70, 84, 78, 68, 90, 72, 84, 84, 82, 64, 88, 68, 64, 78, 64, 82, 74, 74, 68, 104, 64, 78, 64, 74, 64, 68, 74, 72, 70, 78, 56, 64, 82, 70, 86, 70, 88, 82, 68, 62, 78, 65, 90, 68, 
                                                                                                                                                                                                                         70, 72, 74, 90, 72, 64, 78, 72, 54, 70, 88, 90, 70, 60, 60, 56, 80, 72, 85, 90, 78, 90, 76, 68, 70, 68, 62, 64, 68, 60, 72, 58, 60, 86, 44, 44, 86, 84, 78, 52, 72, 24, 88, 60, 78, 62, 82, 58, 80, 74, 62, 82, 70, 88, 65, 78, 82, 76, 74, 72, 50, 84, 60, 52, 58, 80, 82, 70, 58, 68, 106, 100, 76, 64, 74, 50, 90, 74, 80, 46, 64, 78, 62, 58, 50, 78, 72, 60, 86, 78, 84, 88, 56, 86, 72, 60, 80, 44, 58, 88, 84, 94, 70, 78, 62, 88, 88, 58, 74, 76, 72, 70), skin = c(35, 29, 23, 32, 45, 19, 47, 38, 41, 35, 15, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     26, 11, 31, 33, 37, 42, 47, 25, 18, 24, 39, 27, 11, 15, 21, 42, 10, 41, 27, 30, 13, 27, 20, 20, 33, 22, 13, 26, 28, 54, 25, 32, 15, 40, 28, 30, 51, 18, 29, 28, 34, 32, 23, 56, 30, 42, 24, 14, 37, 31, 26, 25, 30, 26, 35, 17, 28, 42, 44, 19, 41, 38, 40, 34, 18, 24, 42, 46, 41, 39, 44, 16, 20, 28, 29, 22, 54, 41, 30, 22, 33, 15, 27, 38, 39, 31, 37, 28, 21, 27, 24, 32, 22, 35, 15, 33, 33, 19, 14, 35, 39, 28, 32, 18, 42, 37, 32, 52, 24, 23, 10, 15, 26, 39, 17, 29, 30, 31, 38, 29, 33, 37, 23, 19, 28, 17, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     10, 31, 39, 33, 32, 21, 32, 36, 32, 19, 16, 18, 13, 21, 36, 19, 19, 40, 36, 33, 37, 25, 28, 16, 48, 22, 15, 37, 39, 22, 18, 24, 13, 29, 36, 23, 14, 24, 34, 31, 41, 25, 49, 39, 30, 23, 33, 32, 29, 41, 18, 46, 32, 30, 25, 16, 11, 8, 25, 27, 63, 37, 18, 13, 32, 33, 22, 40, 30, 13, 36, 40, 38, 31, 30, 37, 31, 42, 41, 32, 28, 30, 38, 18, 15, 32, 19, 32, 25, 39, 31, 19, 18, 34, 7, 32, 18, 18, 30, 37, 25, 32, 23, 29, 35, 27, 21, 28, 30, 24, 23, 40, 19, 30, 31, 17, 30, 47, 20, 27, 40, 50, 22, 45, 19, 19, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     32, 42, 25, 39, 22, 28, 26, 13, 24, 27, 47, 22, 40, 17, 32, 12, 30, 36, 35, 23, 27, 35, 45, 18, 27, 33, 26, 23, 35, 36, 39, 26, 19, 24, 19, 36, 21, 32, 27, 36, 20, 33, 39, 18, 46, 30, 29, 26, 37, 27, 27, 23, 17, 37, 20, 18, 37, 33, 41, 22, 39, 24, 44, 39, 26, 31, 48, 23, 31), bmi = c(33.6, 26.6, 28.1, 31, 30.5, 25.8, 45.8, 43.3, 39.3, 29, 23.2, 36, 24.8, 27.6, 24, 32.9, 38.2, 37.1, 34, 22.7, 45.4, 42, 28, 19.4, 24.2, 24.4, 34.7, 23, 41.5, 29, 32.5, 19.6, 28.9, 32.9, 35.1, 37.7, 25, 22.4, 29.3, 24.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  36.6, 38.5, 37.1, 32, 46.7, 31.6, 28.7, 49.7, 26.6, 28.7, 29.5, 31.2, 30.5, 28.2, 53.2, 33.6, 55, 34.5, 29.7, 34.5, 38.3, 30.8, 28.7, 39.5, 32.5, 30.5, 27.3, 34.3, 40.6, 50, 29, 40.9, 29.7, 37.2, 44.2, 29.9, 29.7, 32.7, 67.1, 32, 27.9, 34.8, 31, 27.3, 23.9, 37.5, 27.7, 42.8, 35.8, 30, 29, 28.8, 23.6, 34.6, 37.2, 36.7, 45.2, 46.2, 29.7, 35.9, 44.1, 29.2, 33.1, 27.1, 38.2, 30, 52.3, 35.4, 30.1, 24.4, 33.6, 30.1, 33.3, 32.1, 33.6, 40, 45.6, 25.2, 40.5, 26.5, 27.8, 25.3, 32.4, 26, 45.6, 20.8, 36.9, 36.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  35.5, 28, 30.7, 31.6, 39.7, 25.5, 30.5, 32.9, 26.6, 29.5, 35.9, 38.1, 26.8, 35.7, 25.6, 35.1, 45.5, 30.8, 23.1, 32.7, 23.9, 25.9, 25.9, 38.5, 28.7, 21.8, 33.3, 36.5, 31.2, 39.2, 34.9, 34, 27.5, 38.4, 35.8, 25.2, 37.2, 43.4, 20, 25.1, 24.3, 22.3, 32.3, 43.3, 31.6, 23.7, 27.7, 24.7, 34.9, 35, 31.6, 42.4, 35.7, 34.4, 42.4, 35.7, 38.5, 26.4, 45.3, 26, 40.6, 42.9, 34.1, 35, 30.4, 30, 24.5, 34.3, 33.2, 59.4, 33.6, 30.5, 21.2, 39.9, 25.9, 20.8, 35.3, 27.6, 21.8, 36.8, 41.3, 33.2, 28, 35.5, 35.2, 38.2, 42.3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  40.7, 46.5, 36.8, 33.5, 32.8, 28.9, 30.1, 29.3, 25.2, 37.2, 33.3, 37.3, 29.7, 25.6, 31.6, 30.3, 19.6, 25, 21.8, 29.8, 33.3, 36.3, 32.4, 34.9, 39.5, 32, 34.5, 43.6, 33.1, 27.4, 31.9, 29.9, 36.9, 46.2, 26.9, 38.6, 29.5, 34.7, 30.1, 35.5, 24, 33.3, 46.8, 39.4, 28.5, 33.6, 27.8, 27.1, 35.8, 40, 19.5, 41.5, 32.9, 32.5, 36.1, 20.1, 28.2, 43.5, 37.7, 24.7, 34.5, 27.5, 40.9, 19.5, 27.6, 37.8, 28.3, 33.8, 38.7, 21.8, 34.8, 32.5, 27.5, 34, 33.6, 35.5, 57.3, 49.6, 44.6, 33.2, 28.3, 30.4, 29.9, 39.8, 34.4, 38, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  29.6, 41.2, 26.4, 33.9, 33.8, 23.1, 35.5, 39.1, 36.1, 32.4, 44.5, 29, 27.4, 32, 36.6, 42.3, 30.8, 28.5, 40.6, 30, 49.3, 36.4, 39, 26, 43.3, 36.5, 28.4, 44, 32.9, 26.2, 30.4), ped = c(0.627, 0.351, 0.167, 0.248, 0.158, 0.587, 0.551, 0.183, 0.704, 0.263, 0.487, 0.546, 0.267, 0.512, 0.966, 0.665, 0.503, 1.39, 0.271, 0.235, 0.721, 1.893, 0.586, 0.491, 0.526, 0.342, 0.718, 0.248, 0.173, 0.203, 0.855, 0.334, 0.189, 0.867, 0.231, 0.37, 0.307, 0.14, 0.767, 0.237, 0.178, 0.324, 0.153, 0.443, 0.261, 0.13, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0.356, 0.325, 0.283, 0.801, 0.287, 0.192, 0.588, 0.443, 0.759, 0.404, 0.496, 0.403, 0.361, 0.356, 0.457, 0.597, 0.532, 0.286, 0.318, 1.4, 0.085, 1.189, 0.687, 0.337, 0.229, 0.817, 0.294, 0.204, 0.167, 0.722, 0.37, 0.719, 0.319, 1.321, 0.64, 0.905, 0.874, 0.787, 0.407, 0.605, 0.29, 0.375, 0.514, 0.464, 1.224, 0.687, 0.666, 0.101, 0.652, 2.329, 0.089, 0.238, 0.293, 0.586, 0.686, 0.192, 0.446, 1.318, 0.329, 1.213, 0.427, 0.282, 0.143, 0.249, 0.543, 0.557, 1.353, 0.612, 0.997, 1.101, 1.136, 0.128, 0.677, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0.296, 0.454, 0.881, 0.262, 0.647, 0.808, 0.34, 0.434, 0.757, 0.692, 0.337, 0.52, 0.422, 0.215, 0.326, 1.391, 0.875, 0.433, 0.626, 1.127, 0.15, 0.731, 0.148, 0.123, 0.692, 0.127, 0.122, 1.476, 0.166, 0.26, 0.472, 0.673, 0.349, 0.654, 0.279, 0.962, 0.875, 0.583, 0.305, 0.385, 0.499, 0.306, 2.137, 0.545, 0.299, 0.509, 1.021, 0.236, 1.268, 0.221, 0.205, 0.66, 0.239, 0.949, 0.389, 1.6, 0.944, 0.241, 0.286, 0.28, 0.702, 0.674, 0.528, 1.076, 0.258, 0.554, 0.219, 0.507, 0.561, 0.496, 0.516, 0.328, 0.233, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0.551, 0.527, 1.138, 0.435, 0.23, 2.42, 0.51, 0.285, 0.415, 0.381, 0.46, 0.733, 0.705, 0.258, 0.452, 0.6, 0.607, 0.17, 0.419, 0.344, 0.197, 0.233, 0.365, 0.536, 1.159, 0.629, 0.292, 0.145, 1.144, 0.547, 0.839, 0.313, 0.267, 0.738, 0.238, 0.297, 0.154, 0.268, 0.771, 0.582, 0.187, 0.444, 0.717, 1.251, 0.804, 0.549, 0.825, 0.159, 0.365, 0.423, 1.034, 0.16, 0.204, 0.591, 0.422, 0.471, 0.126, 0.497, 0.412, 0.43, 0.198, 0.892, 0.28, 0.813, 1.154, 0.925, 0.175, 1.699, 0.733, 0.559, 0.4, 0.514, 1.258, 0.482, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0.27, 0.593, 0.878, 0.557, 0.257, 1.282, 0.347, 0.362, 0.148, 0.238, 0.115, 0.871, 0.149, 0.73, 0.455, 0.26, 0.466, 0.24, 0.155, 0.217, 0.235, 0.141, 0.43, 0.631, 0.285, 0.88, 0.364, 0.366, 0.591, 0.181, 0.128, 0.268, 0.177, 0.176, 0.674, 0.439, 0.441, 0.352, 0.826, 0.97, 0.595, 0.415, 0.251, 0.496, 0.433, 0.646, 0.426, 0.515, 0.6, 0.453, 0.785, 0.4, 0.219, 1.174, 0.488, 0.358, 0.408, 0.261, 0.223, 0.222, 1.057, 0.766, 0.403, 0.171, 0.245, 0.315), age = c(50, 31, 21, 26, 53, 51, 31, 33, 27, 29, 22, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     60, 22, 45, 33, 46, 27, 56, 26, 48, 54, 25, 22, 22, 26, 30, 42, 21, 22, 32, 38, 25, 27, 28, 23, 27, 24, 22, 36, 22, 45, 26, 43, 34, 42, 24, 23, 31, 24, 21, 37, 23, 39, 22, 25, 23, 26, 40, 33, 30, 39, 21, 22, 38, 22, 34, 22, 42, 23, 36, 22, 47, 36, 45, 27, 41, 33, 36, 26, 33, 31, 26, 21, 32, 27, 57, 25, 24, 25, 32, 32, 61, 26, 22, 24, 31, 24, 46, 23, 51, 23, 21, 22, 33, 29, 49, 23, 34, 23, 24, 21, 30, 51, 24, 43, 24, 38, 21, 25, 29, 23, 22, 37, 51, 29, 26, 21, 25, 28, 29, 24, 25, 29, 47, 25, 30, 27, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     25, 43, 28, 43, 21, 24, 30, 23, 37, 46, 25, 22, 22, 36, 49, 22, 26, 28, 29, 29, 65, 30, 30, 22, 25, 21, 22, 22, 35, 22, 25, 25, 24, 35, 45, 28, 21, 25, 39, 25, 35, 38, 28, 28, 25, 22, 22, 37, 28, 26, 21, 21, 36, 38, 43, 38, 22, 36, 41, 24, 25, 22, 26, 23, 25, 81, 48, 39, 37, 21, 25, 28, 22, 63, 35, 29, 23, 24, 21, 58, 24, 42, 33, 45, 25, 39, 21, 28, 41, 40, 46, 24, 28, 53, 60, 25, 21, 22, 24, 23, 27, 56, 25, 29, 37, 53, 28, 21, 25, 23, 28, 42, 32, 21, 22, 22, 23, 25, 35, 52, 45, 24, 25, 34, 21, 24, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     21, 22, 25, 27, 36, 26, 50, 23, 50, 21, 29, 21, 24, 22, 32, 28, 27, 22, 42, 27, 25, 22, 24, 70, 40, 43, 49, 47, 22, 26, 22, 25, 29, 43, 31, 28, 22, 23, 40, 38, 21, 34, 31, 56, 24, 42, 25, 22, 24, 22, 21, 42, 21, 48, 26, 22, 39, 46, 27, 36, 28, 25, 26, 37, 22, 43, 63, 30, 23), type = c(2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 1, 1)))
package:MASS
TRUE
FALSE
Pima.tr
list(`package:MASS` = list(npreg = c(5, 7, 5, 0, 0, 5, 3, 1, 3, 2, 0, 9, 1, 12, 1, 4, 1, 11, 1, 0, 2, 1, 4, 0, 1, 9, 1, 0, 5, 2, 1, 3, 0, 3, 2, 13, 1, 1, 0, 0, 8, 1, 4, 1, 0, 2, 5, 2, 3, 1, 3, 2, 8, 1, 1, 4, 1, 1, 2, 8, 7, 1, 10, 6, 6, 5, 6, 3, 0, 0, 5, 3, 8, 2, 1, 1, 2, 2, 3, 12, 2, 4, 6, 10, 2, 2, 1, 7, 2, 1, 1, 4, 7, 1, 1, 12, 4, 2, 2, 10, 3, 4, 3, 3, 4, 6, 6, 0, 1, 1, 4, 4, 7, 8, 1, 0, 9, 4, 1, 9, 1, 1, 12, 1, 5, 2, 2, 1, 1, 7, 3, 7, 6, 2, 3, 0, 4, 0, 1, 0, 1, 0, 2, 1, 3, 6, 2, 0, 3, 8, 12, 9, 
                                     0, 0, 5, 7, 2, 2, 8, 3, 3, 2, 1, 4, 2, 4, 0, 6, 3, 1, 6, 5, 7, 4, 0, 7, 1, 7, 9, 2, 2, 12, 0, 8, 9, 0, 14, 14, 0, 1, 0, 5, 1, 2, 1, 2, 7, 0, 1, 8), glu = c(86, 195, 77, 165, 107, 97, 83, 193, 142, 128, 137, 154, 189, 92, 86, 99, 109, 143, 149, 139, 99, 100, 83, 101, 87, 164, 99, 140, 108, 110, 79, 148, 121, 158, 105, 145, 79, 71, 102, 119, 176, 97, 129, 97, 86, 125, 123, 92, 171, 199, 116, 83, 154, 114, 106, 127, 124, 109, 123, 167, 184, 96, 129, 92, 109, 139, 134, 106, 131, 135, 158, 112, 181, 121, 
                                                                                                                                                                                                 168, 144, 101, 96, 107, 121, 100, 154, 125, 125, 122, 114, 115, 114, 115, 130, 79, 112, 150, 91, 100, 140, 110, 94, 84, 148, 61, 117, 99, 80, 154, 103, 111, 124, 143, 81, 189, 116, 103, 124, 71, 137, 112, 148, 136, 145, 93, 107, 151, 97, 144, 112, 99, 109, 120, 187, 129, 179, 80, 105, 191, 95, 99, 137, 97, 100, 167, 180, 122, 90, 120, 154, 56, 177, 124, 85, 88, 152, 198, 188, 139, 168, 197, 142, 126, 158, 130, 100, 164, 95, 122, 85, 151, 144, 111, 107, 115, 105, 194, 184, 95, 124, 111, 137, 57, 157, 
                                                                                                                                                                                                 95, 140, 117, 100, 123, 138, 100, 175, 74, 133, 119, 155, 128, 112, 140, 141, 129, 106, 118, 155), bp = c(68, 70, 82, 76, 60, 76, 58, 50, 80, 78, 40, 78, 60, 62, 66, 76, 60, 94, 68, 62, 70, 66, 86, 64, 68, 84, 58, 65, 72, 74, 60, 66, 66, 64, 80, 82, 80, 48, 86, 66, 90, 68, 60, 64, 68, 60, 74, 76, 72, 76, 74, 66, 78, 66, 70, 88, 74, 38, 48, 106, 84, 64, 76, 62, 60, 80, 70, 54, 66, 94, 84, 74, 68, 70, 88, 82, 58, 68, 62, 78, 64, 72, 78, 70, 76, 68, 70, 76, 64, 60, 75, 78, 78, 54, 72, 82, 76, 76, 50, 
                                                                                                                                                                                                                                                                                                           84, 82, 62, 80, 82, 62, 72, 64, 70, 74, 74, 110, 72, 66, 76, 78, 84, 82, 60, 74, 80, 56, 72, 70, 70, 82, 86, 52, 56, 80, 68, 92, 95, 66, 58, 68, 80, 72, 68, 70, 88, 74, 90, 70, 62, 70, 78, 56, 60, 80, 55, 74, 78, 66, 82, 64, 88, 70, 82, 74, 76, 78, 54, 82, 60, 52, 58, 90, 72, 90, 68, 60, 72, 68, 78, 85, 70, 62, 90, 80, 74, 54, 85, 66, 74, 70, 60, 78, 62, 52, 102, 64, 84, 48, 68, 74, 58, 68, 70, 58, 62), skin = c(28, 33, 41, 43, 25, 27, 31, 16, 15, 37, 35, 30, 23, 7, 52, 15, 8, 33, 29, 17, 16, 29, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           19, 17, 34, 21, 10, 26, 43, 29, 42, 25, 30, 13, 45, 19, 25, 18, 17, 27, 34, 21, 12, 19, 32, 20, 40, 20, 33, 43, 15, 23, 32, 36, 28, 11, 36, 18, 32, 46, 33, 27, 28, 32, 27, 35, 23, 21, 40, 46, 41, 30, 36, 32, 29, 46, 17, 13, 13, 17, 23, 29, 31, 26, 27, 22, 30, 17, 22, 23, 30, 40, 29, 25, 12, 43, 20, 18, 23, 48, 28, 12, 11, 31, 31, 32, 39, 20, 22, 41, 31, 12, 32, 24, 50, 27, 32, 27, 50, 46, 11, 30, 40, 40, 26, 42, 15, 21, 48, 39, 49, 31, 30, 40, 15, 45, 17, 14, 15, 60, 17, 26, 27, 12, 30, 41, 28, 29, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           33, 20, 40, 34, 32, 14, 35, 42, 99, 18, 38, 36, 23, 28, 43, 32, 43, 22, 46, 27, 12, 19, 39, 29, 28, 39, 25, 33, 13, 41, 37, 35, 14, 33, 31, 40, 44, 35, 25, 30, 10, 28, 18, 44, 45, 22, 26, 34, 49, 37, 36, 26), bmi = c(30.2, 25.1, 35.8, 47.9, 26.4, 35.6, 34.3, 25.9, 32.4, 43.3, 43.1, 30.9, 30.1, 27.6, 41.3, 23.2, 25.4, 36.6, 29.3, 22.1, 20.4, 32, 29.3, 21, 37.6, 30.8, 25.4, 42.6, 36.1, 32.4, 43.5, 32.5, 34.3, 31.2, 33.7, 22.2, 25.4, 20.4, 29.3, 38.8, 33.7, 27.2, 27.5, 18.2, 35.8, 33.8, 34.1, 24.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    33.3, 42.9, 26.3, 32.2, 32.4, 38.1, 34.2, 34.5, 27.8, 23.1, 42.1, 37.6, 35.5, 33.2, 35.9, 32, 25, 31.6, 35.4, 30.9, 34.3, 40.6, 39.4, 31.6, 30.1, 39.1, 35, 46.1, 24.2, 21.1, 22.9, 26.5, 29.7, 31.3, 27.6, 31.1, 35.9, 28.7, 34.6, 23.8, 30.8, 28.6, 32, 39.4, 35.2, 25.2, 25.3, 39.2, 28.4, 31.6, 30.4, 37.6, 34.4, 29.7, 19.3, 34.2, 32.8, 37.7, 34.2, 27.4, 26.2, 46.3, 28.5, 22.1, 39.1, 28.7, 33.2, 27.3, 34.2, 30.9, 37.4, 37.9, 22.5, 30.8, 41.8, 38.1, 32, 38.4, 24.6, 25.2, 38.9, 37.7, 36.4, 34.2, 26.2, 34.9, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    30.9, 36.5, 25.6, 24.8, 18.2, 46.8, 23.4, 36.5, 36.8, 27.2, 42.9, 46.1, 24.2, 34.6, 33.2, 24.4, 35.3, 34.2, 41.3, 32, 28.6, 38.2, 34.7, 24.7, 25.9, 31.6, 28.4, 37.8, 32.8, 35.4, 36.2, 27.8, 42.1, 33.9, 28.4, 26.5, 33.7, 36.9, 35.9, 37, 37.4, 25.5, 24, 32, 32.8, 39.4, 26.1, 37.4, 30.8, 39.4, 33.1, 34.6, 36.6, 33.6, 27.8, 32.8, 34.9, 38.7, 40.5, 34.1, 24.1, 25.4, 38.5, 39.4, 33.3, 34), ped = c(0.364, 0.163, 0.156, 0.259, 0.133, 0.378, 0.336, 0.655, 0.2, 1.224, 2.288, 0.164, 0.398, 0.926, 0.917, 0.223, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0.947, 0.254, 0.349, 0.207, 0.235, 0.444, 0.317, 0.252, 0.401, 0.831, 0.551, 0.431, 0.263, 0.698, 0.678, 0.256, 0.203, 0.295, 0.711, 0.245, 0.583, 0.323, 0.695, 0.259, 0.467, 1.095, 0.527, 0.299, 0.238, 0.088, 0.269, 1.698, 0.199, 1.394, 0.107, 0.497, 0.443, 0.289, 0.142, 0.598, 0.1, 0.407, 0.52, 0.165, 0.355, 0.289, 0.28, 0.085, 0.206, 0.361, 0.542, 0.292, 0.196, 0.284, 0.395, 0.197, 0.615, 0.886, 0.905, 0.335, 0.614, 0.647, 0.678, 0.259, 0.368, 0.338, 0.565, 0.205, 0.483, 0.092, 0.529, 0.466, 0.421, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0.692, 0.396, 0.236, 0.692, 0.234, 0.658, 0.528, 0.118, 0.649, 0.968, 1.001, 0.243, 0.38, 0.284, 1.292, 0.237, 0.324, 0.26, 0.254, 0.256, 1.096, 0.68, 0.463, 0.344, 0.687, 0.422, 0.231, 0.26, 0.15, 0.399, 0.637, 0.417, 0.821, 0.742, 0.218, 0.452, 0.246, 0.637, 0.833, 1.162, 0.254, 0.968, 0.164, 0.313, 0.225, 0.299, 0.33, 0.294, 0.143, 0.147, 0.962, 0.447, 0.314, 0.34, 0.58, 0.452, 0.571, 0.332, 1.072, 0.305, 0.136, 0.378, 0.893, 0.502, 0.682, 0.411, 0.787, 0.575, 0.761, 0.162, 0.851, 0.323, 0.498, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0.341, 0.284, 0.816, 0.306, 0.371, 0.255, 0.495, 0.165, 0.245, 0.159, 0.745, 0.264, 0.247, 0.161, 0.138, 0.391, 0.096, 0.134, 0.748, 0.244, 0.493, 0.661, 0.374, 0.534, 0.412, 0.212, 0.269, 0.234, 0.725, 0.619, 0.613, 0.315, 0.828, 0.699, 0.439, 0.605, 0.261, 0.543), age = c(24, 55, 35, 26, 23, 52, 25, 24, 63, 31, 33, 45, 59, 44, 29, 21, 21, 51, 42, 21, 27, 42, 34, 21, 24, 32, 21, 24, 33, 27, 23, 22, 33, 24, 29, 57, 22, 22, 27, 22, 58, 22, 31, 21, 25, 31, 28, 28, 24, 22, 24, 22, 45, 21, 22, 28, 30, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  26, 26, 43, 41, 21, 39, 46, 27, 25, 29, 24, 22, 26, 29, 25, 60, 23, 52, 46, 23, 26, 23, 62, 21, 37, 49, 41, 26, 25, 32, 31, 21, 21, 22, 38, 54, 23, 28, 58, 27, 23, 21, 51, 46, 30, 30, 27, 23, 55, 24, 36, 21, 32, 37, 37, 31, 52, 21, 59, 36, 29, 24, 40, 22, 24, 38, 30, 58, 28, 21, 23, 41, 41, 32, 60, 41, 25, 34, 26, 28, 21, 21, 31, 33, 35, 27, 24, 30, 27, 22, 21, 26, 42, 48, 33, 28, 22, 26, 40, 62, 21, 39, 28, 34, 24, 50, 28, 28, 28, 21, 40, 29, 24, 40, 28, 41, 31, 24, 37, 23, 39, 41, 30, 22, 41, 22, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  43, 40, 21, 46, 38, 22, 45, 23, 34, 24, 26, 23, 24, 43, 22, 23, 46), type = c(1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2)))
package:MASS
TRUE
FALSE
Pima.tr2
list(`package:MASS` = list(npreg = c(5, 7, 5, 0, 0, 5, 3, 1, 3, 2, 0, 9, 1, 12, 1, 4, 1, 11, 1, 0, 2, 1, 4, 0, 1, 9, 1, 0, 5, 2, 1, 3, 0, 3, 2, 13, 1, 1, 0, 0, 8, 1, 4, 1, 0, 2, 5, 2, 3, 1, 3, 2, 8, 1, 1, 4, 1, 1, 2, 8, 7, 1, 10, 6, 6, 5, 6, 3, 0, 0, 5, 3, 8, 2, 1, 1, 2, 2, 3, 12, 2, 4, 6, 10, 2, 2, 1, 7, 2, 1, 1, 4, 7, 1, 1, 12, 4, 2, 2, 10, 3, 4, 3, 3, 4, 6, 6, 0, 1, 1, 4, 4, 7, 8, 1, 0, 9, 4, 1, 9, 1, 1, 12, 1, 5, 2, 2, 1, 1, 7, 3, 7, 6, 2, 3, 0, 4, 0, 1, 0, 1, 0, 2, 1, 3, 6, 2, 0, 3, 8, 12, 9, 
                                     0, 0, 5, 7, 2, 2, 8, 3, 3, 2, 1, 4, 2, 4, 0, 6, 3, 1, 6, 5, 7, 4, 0, 7, 1, 7, 9, 2, 2, 12, 0, 8, 9, 0, 14, 14, 0, 1, 0, 5, 1, 2, 1, 2, 7, 0, 1, 8, 2, 10, 0, 1, 5, 9, 1, 4, 3, 3, 5, 6, 8, 4, 0, 1, 9, 10, 3, 13, 5, 6, 8, 3, 5, 5, 0, 2, 4, 0, 10, 4, 7, 7, 1, 0, 2, 7, 6, 5, 3, 4, 4, 4, 0, 4, 2, 0, 2, 1, 6, 8, 4, 6, 4, 11, 6, 4, 2, 6, 4, 5, 0, 4, 8, 6, 0, 5, 13, 0, 2, 10, 10, 4, 4, 0, 2, 8, 1, 5, 4, 2, 7, 7, 2, 5, 0, 0, 4, 5, 0, 3, 4, 4, 8, 0, 6, 3, 0, 2), glu = c(86, 195, 77, 165, 107, 97, 83, 193, 142, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     128, 137, 154, 189, 92, 86, 99, 109, 143, 149, 139, 99, 100, 83, 101, 87, 164, 99, 140, 108, 110, 79, 148, 121, 158, 105, 145, 79, 71, 102, 119, 176, 97, 129, 97, 86, 125, 123, 92, 171, 199, 116, 83, 154, 114, 106, 127, 124, 109, 123, 167, 184, 96, 129, 92, 109, 139, 134, 106, 131, 135, 158, 112, 181, 121, 168, 144, 101, 96, 107, 121, 100, 154, 125, 125, 122, 114, 115, 114, 115, 130, 79, 112, 150, 91, 100, 140, 110, 94, 84, 148, 61, 117, 99, 80, 154, 103, 111, 124, 143, 81, 189, 116, 103, 124, 71, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     137, 112, 148, 136, 145, 93, 107, 151, 97, 144, 112, 99, 109, 120, 187, 129, 179, 80, 105, 191, 95, 99, 137, 97, 100, 167, 180, 122, 90, 120, 154, 56, 177, 124, 85, 88, 152, 198, 188, 139, 168, 197, 142, 126, 158, 130, 100, 164, 95, 122, 85, 151, 144, 111, 107, 115, 105, 194, 184, 95, 124, 111, 137, 57, 157, 95, 140, 117, 100, 123, 138, 100, 175, 74, 133, 119, 155, 128, 112, 140, 141, 129, 106, 118, 155, 134, 75, 146, 180, 104, 164, 80, 171, 139, 122, 116, 195, 125, 122, 107, 151, 165, 168, 102, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     76, 143, 124, 95, 78, 112, 73, 102, 109, 114, 102, 133, 118, 136, 100, 138, 131, 111, 133, 137, 115, 125, 142, 146, 128, 132, 134, 120, 111, 139, 106, 147, 107, 183, 96, 158, 127, 87, 123, 118, 103, 110, 147, 119, 156, 197, 102, 131, 136, 158, 93, 87, 108, 139, 110, 114, 101, 91, 133, 111, 147, 92, 90, 114, 125, 119, 115, 141, 167, 90, 132, 125, 150, 95, 136, 110, 125, 92, 141, 73, 129), bp = c(68, 70, 82, 76, 60, 76, 58, 50, 80, 78, 40, 78, 60, 62, 66, 76, 60, 94, 68, 62, 70, 66, 86, 64, 68, 84, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   58, 65, 72, 74, 60, 66, 66, 64, 80, 82, 80, 48, 86, 66, 90, 68, 60, 64, 68, 60, 74, 76, 72, 76, 74, 66, 78, 66, 70, 88, 74, 38, 48, 106, 84, 64, 76, 62, 60, 80, 70, 54, 66, 94, 84, 74, 68, 70, 88, 82, 58, 68, 62, 78, 64, 72, 78, 70, 76, 68, 70, 76, 64, 60, 75, 78, 78, 54, 72, 82, 76, 76, 50, 84, 82, 62, 80, 82, 62, 72, 64, 70, 74, 74, 110, 72, 66, 76, 78, 84, 82, 60, 74, 80, 56, 72, 70, 70, 82, 86, 52, 56, 80, 68, 92, 95, 66, 58, 68, 80, 72, 68, 70, 88, 74, 90, 70, 62, 70, 78, 56, 60, 80, 55, 74, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   78, 66, 82, 64, 88, 70, 82, 74, 76, 78, 54, 82, 60, 52, 58, 90, 72, 90, 68, 60, 72, 68, 78, 85, 70, 62, 90, 80, 74, 54, 85, 66, 74, 70, 60, 78, 62, 52, 102, 64, 84, 48, 68, 74, 58, 68, 70, 58, 62, 70, 82, 70, NA, 74, 78, 55, 72, 54, 78, 74, 70, 96, 68, 76, 60, 88, 74, 74, 60, 78, 72, 72, 70, 66, 60, 52, 92, 65, 75, 68, 70, 90, NA, 82, NA, 60, 84, 61, 98, 58, 86, 92, 70, 78, 72, 54, 65, 75, 76, 80, 80, NA, NA, 78, 106, 80, 62, 80, 66, 66, 78, NA, 75, 74, 82, 88, 82, 114, 60, NA, 66, 80, 92, 64, 62, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   62, 72, 94, 75, 80, 60, 64, 86, NA, 76, NA, NA, NA, 80, 96, 76, 64, 70, 76, 68, 92, NA, NA, 84), skin = c(28, 33, 41, 43, 25, 27, 31, 16, 15, 37, 35, 30, 23, 7, 52, 15, 8, 33, 29, 17, 16, 29, 19, 17, 34, 21, 10, 26, 43, 29, 42, 25, 30, 13, 45, 19, 25, 18, 17, 27, 34, 21, 12, 19, 32, 20, 40, 20, 33, 43, 15, 23, 32, 36, 28, 11, 36, 18, 32, 46, 33, 27, 28, 32, 27, 35, 23, 21, 40, 46, 41, 30, 36, 32, 29, 46, 17, 13, 13, 17, 23, 29, 31, 26, 27, 22, 30, 17, 22, 23, 30, 40, 29, 25, 12, 43, 20, 18, 23, 48, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             28, 12, 11, 31, 31, 32, 39, 20, 22, 41, 31, 12, 32, 24, 50, 27, 32, 27, 50, 46, 11, 30, 40, 40, 26, 42, 15, 21, 48, 39, 49, 31, 30, 40, 15, 45, 17, 14, 15, 60, 17, 26, 27, 12, 30, 41, 28, 29, 33, 20, 40, 34, 32, 14, 35, 42, 99, 18, 38, 36, 23, 28, 43, 32, 43, 22, 46, 27, 12, 19, 39, 29, 28, 39, 25, 33, 13, 41, 37, 35, 14, 33, 31, 40, 44, 35, 25, 30, 10, 28, 18, 44, 45, 22, 26, 34, 49, 37, 36, 26, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             NA, NA, NA, 23, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 23, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), bmi = c(30.2, 25.1, 35.8, 47.9, 26.4, 35.6, 34.3, 25.9, 32.4, 43.3, 43.1, 30.9, 30.1, 27.6, 41.3, 23.2, 25.4, 36.6, 29.3, 22.1, 20.4, 32, 29.3, 21, 37.6, 30.8, 25.4, 42.6, 36.1, 32.4, 43.5, 32.5, 34.3, 31.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              33.7, 22.2, 25.4, 20.4, 29.3, 38.8, 33.7, 27.2, 27.5, 18.2, 35.8, 33.8, 34.1, 24.2, 33.3, 42.9, 26.3, 32.2, 32.4, 38.1, 34.2, 34.5, 27.8, 23.1, 42.1, 37.6, 35.5, 33.2, 35.9, 32, 25, 31.6, 35.4, 30.9, 34.3, 40.6, 39.4, 31.6, 30.1, 39.1, 35, 46.1, 24.2, 21.1, 22.9, 26.5, 29.7, 31.3, 27.6, 31.1, 35.9, 28.7, 34.6, 23.8, 30.8, 28.6, 32, 39.4, 35.2, 25.2, 25.3, 39.2, 28.4, 31.6, 30.4, 37.6, 34.4, 29.7, 19.3, 34.2, 32.8, 37.7, 34.2, 27.4, 26.2, 46.3, 28.5, 22.1, 39.1, 28.7, 33.2, 27.3, 34.2, 30.9, 37.4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              37.9, 22.5, 30.8, 41.8, 38.1, 32, 38.4, 24.6, 25.2, 38.9, 37.7, 36.4, 34.2, 26.2, 34.9, 30.9, 36.5, 25.6, 24.8, 18.2, 46.8, 23.4, 36.5, 36.8, 27.2, 42.9, 46.1, 24.2, 34.6, 33.2, 24.4, 35.3, 34.2, 41.3, 32, 28.6, 38.2, 34.7, 24.7, 25.9, 31.6, 28.4, 37.8, 32.8, 35.4, 36.2, 27.8, 42.1, 33.9, 28.4, 26.5, 33.7, 36.9, 35.9, 37, 37.4, 25.5, 24, 32, 32.8, 39.4, 26.1, 37.4, 30.8, 39.4, 33.1, 34.6, 36.6, 33.6, 27.8, 32.8, 34.9, 38.7, 40.5, 34.1, 24.1, 25.4, 38.5, 39.4, 33.3, 34, 28.9, 33.3, 37.9, 43.3, 28.8, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              32.8, 19.1, 43.6, 25.6, 23, 25.6, 30.9, NA, 35, 45.3, 26.1, 30.4, 38, 29.5, 32.8, 45, 27.6, 36.8, 32.5, 37.8, 26.8, 25.1, 42.7, 21.9, NA, 27, 44.5, 29.9, 30, 40.1, 43.2, 26.2, 40.2, 24.2, 52.9, 31.6, 44, 31.2, 34.3, 32.4, 23.8, 26.8, 24.6, 25.6, 37.5, 29.5, 24.6, 28.4, 23.7, 32.9, 39, 23.2, 32, 42.9, 24.3, 31.9, 33.7, 32.4, 48.3, 25.9, 30.8, 31.6, NA, 42.3, 35.3, 28.9, 32.4, 27.1, 37.6, 28.9, 21.9, 27.3, 32.9, 32.8, 29.9, 42.2, 23.5, 27.4, 37.6, 19.6, 31.2, 42.4, 32.3, 28, 26.8, 22.5, 21, 32, 31.2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              27.8, 24.7, 19.9, 30, 21.1, 28), ped = c(0.364, 0.163, 0.156, 0.259, 0.133, 0.378, 0.336, 0.655, 0.2, 1.224, 2.288, 0.164, 0.398, 0.926, 0.917, 0.223, 0.947, 0.254, 0.349, 0.207, 0.235, 0.444, 0.317, 0.252, 0.401, 0.831, 0.551, 0.431, 0.263, 0.698, 0.678, 0.256, 0.203, 0.295, 0.711, 0.245, 0.583, 0.323, 0.695, 0.259, 0.467, 1.095, 0.527, 0.299, 0.238, 0.088, 0.269, 1.698, 0.199, 1.394, 0.107, 0.497, 0.443, 0.289, 0.142, 0.598, 0.1, 0.407, 0.52, 0.165, 0.355, 0.289, 0.28, 0.085, 0.206, 0.361, 0.542, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.292, 0.196, 0.284, 0.395, 0.197, 0.615, 0.886, 0.905, 0.335, 0.614, 0.647, 0.678, 0.259, 0.368, 0.338, 0.565, 0.205, 0.483, 0.092, 0.529, 0.466, 0.421, 0.692, 0.396, 0.236, 0.692, 0.234, 0.658, 0.528, 0.118, 0.649, 0.968, 1.001, 0.243, 0.38, 0.284, 1.292, 0.237, 0.324, 0.26, 0.254, 0.256, 1.096, 0.68, 0.463, 0.344, 0.687, 0.422, 0.231, 0.26, 0.15, 0.399, 0.637, 0.417, 0.821, 0.742, 0.218, 0.452, 0.246, 0.637, 0.833, 1.162, 0.254, 0.968, 0.164, 0.313, 0.225, 0.299, 0.33, 0.294, 0.143, 0.147, 0.962, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.447, 0.314, 0.34, 0.58, 0.452, 0.571, 0.332, 1.072, 0.305, 0.136, 0.378, 0.893, 0.502, 0.682, 0.411, 0.787, 0.575, 0.761, 0.162, 0.851, 0.323, 0.498, 0.341, 0.284, 0.816, 0.306, 0.371, 0.255, 0.495, 0.165, 0.245, 0.159, 0.745, 0.264, 0.247, 0.161, 0.138, 0.391, 0.096, 0.134, 0.748, 0.244, 0.493, 0.661, 0.374, 0.534, 0.412, 0.212, 0.269, 0.234, 0.725, 0.619, 0.613, 0.315, 0.828, 0.699, 0.439, 0.605, 0.261, 0.543, 0.542, 0.263, 0.334, 0.282, 0.153, 0.148, 0.258, 0.479, 0.402, 0.254, 0.201, 0.328, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.232, 0.394, 0.686, 0.179, 0.302, 0.537, 0.121, 0.18, 0.19, 0.368, 0.485, 0.27, 0.261, 0.268, 0.078, 0.845, 0.432, 0.572, 0.245, 0.904, 0.21, 0.484, 0.236, 0.27, 0.343, 0.696, 0.151, 0.209, 0.151, 0.645, 0.539, 0.303, 0.393, 0.277, 0.455, 0.66, 0.167, 0.197, 0.178, 0.856, 0.212, 0.19, 0.803, 0.19, 0.084, 0.226, 0.693, 0.249, 0.471, 0.218, 0.141, 0.238, 1.191, 0.18, 0.743, 0.64, 0.257, 0.263, 0.773, 0.272, 1.441, 0.191, 0.126, 0.336, 0.525, 0.27, 0.265, 0.434, 0.237, 0.191, 0.732, 0.304, 0.832, 0.343, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0.205, 0.839, 0.61, 0.186, 0.262, 0.207, 0.161, 1.182, 0.237, 0.206, 0.188, 0.761, 0.342, 0.284), age = c(24, 55, 35, 26, 23, 52, 25, 24, 63, 31, 33, 45, 59, 44, 29, 21, 21, 51, 42, 21, 27, 42, 34, 21, 24, 32, 21, 24, 33, 27, 23, 22, 33, 24, 29, 57, 22, 22, 27, 22, 58, 22, 31, 21, 25, 31, 28, 28, 24, 22, 24, 22, 45, 21, 22, 28, 30, 26, 26, 43, 41, 21, 39, 46, 27, 25, 29, 24, 22, 26, 29, 25, 60, 23, 52, 46, 23, 26, 23, 62, 21, 37, 49, 41, 26, 25, 32, 31, 21, 21, 22, 38, 54, 23, 28, 58, 27, 23, 21, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 51, 46, 30, 30, 27, 23, 55, 24, 36, 21, 32, 37, 37, 31, 52, 21, 59, 36, 29, 24, 40, 22, 24, 38, 30, 58, 28, 21, 23, 41, 41, 32, 60, 41, 25, 34, 26, 28, 21, 21, 31, 33, 35, 27, 24, 30, 27, 22, 21, 26, 42, 48, 33, 28, 22, 26, 40, 62, 21, 39, 28, 34, 24, 50, 28, 28, 28, 21, 40, 29, 24, 40, 28, 41, 31, 24, 37, 23, 39, 41, 30, 22, 41, 22, 43, 40, 21, 46, 38, 22, 45, 23, 34, 24, 26, 23, 24, 43, 22, 23, 46, 23, 38, 28, 41, 48, 45, 21, 26, 22, 40, 30, 31, 54, 29, 24, 22, 49, 34, 32, 41, 47, 29, 57, 39, 41, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 27, 21, 54, 37, 21, 36, 26, 50, 32, 28, 26, 23, 37, 55, 28, 24, 22, 61, 24, 21, 60, 27, 31, 29, 26, 50, 34, 36, 28, 31, 51, 32, 35, 21, 29, 29, 65, 24, 32, 39, 36, 32, 69, 44, 25, 25, 42, 57, 30, 24, 25, 22, 39, 45, 28, 29, 25, 34, 51, 72, 44, 29, 30, 31, 69, 21, 37, 31, 22, 58, 21, 28, 27, 25, 27), type = c(1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1)))
package:MASS
TRUE
FALSE
polr
list(`package:MASS` = function (formula, data, weights, start, ..., subset, na.action, contrasts = NULL, Hess = FALSE, model = TRUE, method = c("logistic", "probit", "loglog", "cloglog", "cauchit")) 
{
  m <- match.call(expand.dots = FALSE)
  method <- match.arg(method)
  if (is.matrix(eval.parent(m$data))) 
    m$data <- as.data.frame(data)
  m$start <- m$Hess <- m$method <- m$model <- m$... <- NULL
  m[[1]] <- quote(stats::model.frame)
  m <- eval.parent(m)
  Terms <- attr(m, "terms")
  x <- model.matrix(Terms, m, contrasts)
  xint <- match("(Intercept)", colnames(x), nomatch = 0)
  n <- nrow(x)
  pc <- ncol(x)
  cons <- attr(x, "contrasts")
  if (xint > 0) {
    x <- x[, -xint, drop = FALSE]
    pc <- pc - 1
  }
  else warning("an intercept is needed and assumed")
  wt <- model.weights(m)
  if (!length(wt)) 
    wt <- rep(1, n)
  offset <- model.offset(m)
  if (length(offset) <= 1) 
    offset <- rep(0, n)
  y <- model.response(m)
  if (!is.factor(y)) 
    stop("response must be a factor")
  lev <- levels(y)
  llev <- length(lev)
  if (llev <= 2) 
    stop("response must have 3 or more levels")
  y <- unclass(y)
  q <- llev - 1
  if (missing(start)) {
    q1 <- llev%/%2
    y1 <- (y > q1)
    X <- cbind(Intercept = rep(1, n), x)
    fit <- switch(method, logistic = glm.fit(X, y1, wt, family = binomial(), offset = offset), probit = glm.fit(X, y1, wt, family = binomial("probit"), offset = offset), loglog = glm.fit(X, y1, wt, family = binomial("probit"), offset = offset), cloglog = glm.fit(X, y1, wt, family = binomial("probit"), offset = offset), cauchit = glm.fit(X, y1, wt, family = binomial("cauchit"), offset = offset))
    if (!fit$converged) 
      stop("attempt to find suitable starting values failed")
    coefs <- fit$coefficients
    if (any(is.na(coefs))) {
      warning("design appears to be rank-deficient, so dropping some coefs")
      keep <- names(coefs)[!is.na(coefs)]
      coefs <- coefs[keep]
      x <- x[, keep[-1], drop = FALSE]
      pc <- ncol(x)
    }
    logit <- function(p) log(p/(1 - p))
    spacing <- logit((1:q)/(q + 1))
    if (method != "logistic") 
      spacing <- spacing/1.7
    gammas <- -coefs[1] + spacing - spacing[q1]
    start <- c(coefs[-1], gammas)
  }
  else if (length(start) != pc + q) 
    stop("'start' is not of the correct length")
  ans <- polr.fit(x, y, wt, start, offset, method, hessian = Hess, ...)
  beta <- ans$coefficients
  zeta <- ans$zeta
  deviance <- ans$deviance
  res <- ans$res
  niter <- c(f.evals = res$counts[1], g.evals = res$counts[2])
  eta <- if (pc) 
    offset + drop(x %*% beta)
  else offset + rep(0, n)
  pfun <- switch(method, logistic = plogis, probit = pnorm, loglog = pgumbel, cloglog = pGumbel, cauchit = pcauchy)
  cumpr <- matrix(pfun(matrix(zeta, n, q, byrow = TRUE) - eta), , q)
  fitted <- t(apply(cumpr, 1, function(x) diff(c(0, x, 1))))
  dimnames(fitted) <- list(row.names(m), lev)
  fit <- list(coefficients = beta, zeta = zeta, deviance = deviance, fitted.values = fitted, lev = lev, terms = Terms, df.residual = sum(wt) - pc - q, edf = pc + q, n = sum(wt), nobs = sum(wt), call = match.call(), method = method, convergence = res$convergence, niter = niter, lp = eta)
  if (Hess) {
    dn <- c(names(beta), names(zeta))
    H <- res$hessian
    dimnames(H) <- list(dn, dn)
    fit$Hessian <- H
  }
  if (model) 
    fit$model <- m
  fit$na.action <- attr(m, "na.action")
  fit$contrasts <- cons
  fit$xlevels <- .getXlevels(Terms, m)
  class(fit) <- "polr"
  fit
}, function (formula, data, weights, start, ..., subset, na.action, contrasts = NULL, Hess = FALSE, model = TRUE, method = c("logistic", "probit", "loglog", "cloglog", "cauchit")) 
{
  m <- match.call(expand.dots = FALSE)
  method <- match.arg(method)
  if (is.matrix(eval.parent(m$data))) 
    m$data <- as.data.frame(data)
  m$start <- m$Hess <- m$method <- m$model <- m$... <- NULL
  m[[1]] <- quote(stats::model.frame)
  m <- eval.parent(m)
  Terms <- attr(m, "terms")
  x <- model.matrix(Terms, m, contrasts)
  xint <- match("(Intercept)", colnames(x), nomatch = 0)
  n <- nrow(x)
  pc <- ncol(x)
  cons <- attr(x, "contrasts")
  if (xint > 0) {
    x <- x[, -xint, drop = FALSE]
    pc <- pc - 1
  }
  else warning("an intercept is needed and assumed")
  wt <- model.weights(m)
  if (!length(wt)) 
    wt <- rep(1, n)
  offset <- model.offset(m)
  if (length(offset) <= 1) 
    offset <- rep(0, n)
  y <- model.response(m)
  if (!is.factor(y)) 
    stop("response must be a factor")
  lev <- levels(y)
  llev <- length(lev)
  if (llev <= 2) 
    stop("response must have 3 or more levels")
  y <- unclass(y)
  q <- llev - 1
  if (missing(start)) {
    q1 <- llev%/%2
    y1 <- (y > q1)
    X <- cbind(Intercept = rep(1, n), x)
    fit <- switch(method, logistic = glm.fit(X, y1, wt, family = binomial(), offset = offset), probit = glm.fit(X, y1, wt, family = binomial("probit"), offset = offset), loglog = glm.fit(X, y1, wt, family = binomial("probit"), offset = offset), cloglog = glm.fit(X, y1, wt, family = binomial("probit"), offset = offset), cauchit = glm.fit(X, y1, wt, family = binomial("cauchit"), offset = offset))
    if (!fit$converged) 
      stop("attempt to find suitable starting values failed")
    coefs <- fit$coefficients
    if (any(is.na(coefs))) {
      warning("design appears to be rank-deficient, so dropping some coefs")
      keep <- names(coefs)[!is.na(coefs)]
      coefs <- coefs[keep]
      x <- x[, keep[-1], drop = FALSE]
      pc <- ncol(x)
    }
    logit <- function(p) log(p/(1 - p))
    spacing <- logit((1:q)/(q + 1))
    if (method != "logistic") 
      spacing <- spacing/1.7
    gammas <- -coefs[1] + spacing - spacing[q1]
    start <- c(coefs[-1], gammas)
  }
  else if (length(start) != pc + q) 
    stop("'start' is not of the correct length")
  ans <- polr.fit(x, y, wt, start, offset, method, hessian = Hess, ...)
  beta <- ans$coefficients
  zeta <- ans$zeta
  deviance <- ans$deviance
  res <- ans$res
  niter <- c(f.evals = res$counts[1], g.evals = res$counts[2])
  eta <- if (pc) 
    offset + drop(x %*% beta)
  else offset + rep(0, n)
  pfun <- switch(method, logistic = plogis, probit = pnorm, loglog = pgumbel, cloglog = pGumbel, cauchit = pcauchy)
  cumpr <- matrix(pfun(matrix(zeta, n, q, byrow = TRUE) - eta), , q)
  fitted <- t(apply(cumpr, 1, function(x) diff(c(0, x, 1))))
  dimnames(fitted) <- list(row.names(m), lev)
  fit <- list(coefficients = beta, zeta = zeta, deviance = deviance, fitted.values = fitted, lev = lev, terms = Terms, df.residual = sum(wt) - pc - q, edf = pc + q, n = sum(wt), nobs = sum(wt), call = match.call(), method = method, convergence = res$convergence, niter = niter, lp = eta)
  if (Hess) {
    dn <- c(names(beta), names(zeta))
    H <- res$hessian
    dimnames(H) <- list(dn, dn)
    fit$Hessian <- H
  }
  if (model) 
    fit$model <- m
  fit$na.action <- attr(m, "na.action")
  fit$contrasts <- cons
  fit$xlevels <- .getXlevels(Terms, m)
  class(fit) <- "polr"
  fit
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
psi.bisquare
list(`package:MASS` = function (u, c = 4.685, deriv = 0) 
{
  if (!deriv) 
    return((1 - pmin(1, abs(u/c))^2)^2)
  t <- (u/c)^2
  ifelse(t < 1, (1 - t) * (1 - 5 * t), 0)
}, function (u, c = 4.685, deriv = 0) 
{
  if (!deriv) 
    return((1 - pmin(1, abs(u/c))^2)^2)
  t <- (u/c)^2
  ifelse(t < 1, (1 - t) * (1 - 5 * t), 0)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
psi.hampel
list(`package:MASS` = function (u, a = 2, b = 4, c = 8, deriv = 0) 
{
  U <- pmin(abs(u) + 1e-50, c)
  if (!deriv) 
    return(ifelse(U <= a, U, ifelse(U <= b, a, a * (c - U)/(c - b)))/U)
  ifelse(abs(u) <= c, ifelse(U <= a, 1, ifelse(U <= b, 0, -a/(c - b))), 0)
}, function (u, a = 2, b = 4, c = 8, deriv = 0) 
{
  U <- pmin(abs(u) + 1e-50, c)
  if (!deriv) 
    return(ifelse(U <= a, U, ifelse(U <= b, a, a * (c - U)/(c - b)))/U)
  ifelse(abs(u) <= c, ifelse(U <= a, 1, ifelse(U <= b, 0, -a/(c - b))), 0)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
psi.huber
list(`package:MASS` = function (u, k = 1.345, deriv = 0) 
{
  if (!deriv) 
    return(pmin(1, k/abs(u)))
  abs(u) <= k
}, function (u, k = 1.345, deriv = 0) 
{
  if (!deriv) 
    return(pmin(1, k/abs(u)))
  abs(u) <= k
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
qda
list(`package:MASS` = function (x, ...) 
  UseMethod("qda"), function (x, ...) 
    UseMethod("qda"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
quine
list(`package:MASS` = list(Eth = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Sex = c(2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), Age = c(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4), Lrn = c(2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), Days = c(2, 11, 14, 5, 5, 13, 20, 22, 6, 6, 15, 7, 14, 6, 32, 53, 57, 14, 16, 16, 17, 40, 43, 46, 8, 23, 23, 28, 34, 36, 38, 3, 5, 11, 24, 45, 5, 6, 6, 9, 13, 23, 25, 32, 53, 54, 5, 5, 11, 17, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               19, 8, 13, 14, 20, 47, 48, 60, 81, 2, 0, 2, 3, 5, 10, 14, 21, 36, 40, 6, 17, 67, 0, 0, 2, 7, 11, 12, 0, 0, 5, 5, 5, 11, 17, 3, 4, 22, 30, 36, 8, 0, 1, 5, 7, 16, 27, 0, 30, 10, 14, 27, 41, 69, 25, 10, 11, 20, 33, 5, 7, 0, 1, 5, 5, 5, 5, 7, 11, 15, 5, 14, 6, 6, 7, 28, 0, 5, 14, 2, 2, 3, 8, 10, 12, 1, 1, 9, 22, 3, 3, 5, 15, 18, 22, 37)))
package:MASS
TRUE
FALSE
Rabbit
list(`package:MASS` = list(BPchange = c(0.5, 4.5, 10, 26, 37, 32, 1, 1.25, 4, 12, 27, 29, 0.75, 3, 3, 14, 22, 24, 1.25, 1.5, 6, 19, 33, 33, 1.5, 1.5, 5, 16, 20, 18, 1.25, 0.75, 4, 9, 25, 37, 1.4, 1.7, 1, 2, 15, 28, 0.75, 2.3, 3, 5, 26, 25, 2.6, 1.2, 2, 3, 11, 22, 2.4, 2.5, 1.5, 2, 9, 19), Dose = c(6.25, 12.5, 25, 50, 100, 200, 6.25, 12.5, 25, 50, 100, 200, 6.25, 12.5, 25, 50, 100, 200, 6.25, 12.5, 25, 50, 100, 200, 6.25, 12.5, 25, 50, 100, 200, 6.25, 12.5, 25, 50, 100, 200, 6.25, 12.5, 25, 50, 100, 
                                                                                                                                                                                                                                                                                                           200, 6.25, 12.5, 25, 50, 100, 200, 6.25, 12.5, 25, 50, 100, 200, 6.25, 12.5, 25, 50, 100, 200), Run = c(1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10), Treatment = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Animal = c(1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5)))
package:MASS
TRUE
FALSE
rational
list(`package:MASS` = function (x, cycles = 10, max.denominator = 2000, ...) 
{
  ans <- .rat(x, cycles, max.denominator)$rat
  do.call("structure", c(list(ans[, 1]/ans[, 2]), attributes(x)))
}, function (x, cycles = 10, max.denominator = 2000, ...) 
{
  ans <- .rat(x, cycles, max.denominator)$rat
  do.call("structure", c(list(ans[, 1]/ans[, 2]), attributes(x)))
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
renumerate
list(`package:MASS` = function (x) 
  UseMethod("renumerate"), function (x) 
    UseMethod("renumerate"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
rlm
list(`package:MASS` = function (x, ...) 
  UseMethod("rlm"), function (x, ...) 
    UseMethod("rlm"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
rms.curv
list(`package:MASS` = function (obj) 
{
  fit.val <- obj$m$fitted()
  v <- attr(fit.val, "gradient")
  if (is.null(v)) 
    stop("\"gradient\" attribute missing")
  a <- attr(fit.val, "hessian")
  if (is.null(a)) 
    stop("\"hessian\" attribute missing")
  p <- ncol(v)
  n <- nrow(v)
  s <- sqrt(deviance(obj)/(n - p))
  sp <- s * sqrt(p)
  D <- v
  for (j in 1:p) D <- cbind(D, a[, 1:j, j])
  qrd <- qr(D)
  Q <- qr.Q(qrd)
  rnk <- qrd$rank
  if (rnk <= p) 
    warning("regression apparently linear")
  Q1 <- Q[, 1:rnk]
  C <- array(0, c(rnk, p, p))
  for (j in 1:p) C[, , j] <- crossprod(Q1, a[, , j])
  C <- aperm(C, c(2, 3, 1))
  r11i <- solve(qr.R(qrd)[1:p, 1:p])
  ct <- 0
  for (j in 1:p) {
    C[, , j] <- crossprod(r11i, C[, , j]) %*% r11i * sp
    ct <- ct + 2 * sum(C[, , j]^2) + sum(diag(C[, , j]))^2
  }
  ci <- 0
  for (j in (p + 1):rnk) {
    C[, , j] <- crossprod(r11i, C[, , j]) %*% r11i * sp
    ci <- ci + 2 * sum(C[, , j]^2) + sum(diag(C[, , j]))^2
  }
  ct <- sqrt(ct/(p * (p + 2)))
  ci <- sqrt(ci/(p * (p + 2)))
  pe <- ct * sqrt(qf(19/20, p, n - p))
  ic <- ci * sqrt(qf(19/20, p, n - p))
  val <- list(pe = pe, ic = ic, ct = ct, ci = ci, C = C)
  class(val) <- "rms.curv"
  val
}, function (obj) 
{
  fit.val <- obj$m$fitted()
  v <- attr(fit.val, "gradient")
  if (is.null(v)) 
    stop("\"gradient\" attribute missing")
  a <- attr(fit.val, "hessian")
  if (is.null(a)) 
    stop("\"hessian\" attribute missing")
  p <- ncol(v)
  n <- nrow(v)
  s <- sqrt(deviance(obj)/(n - p))
  sp <- s * sqrt(p)
  D <- v
  for (j in 1:p) D <- cbind(D, a[, 1:j, j])
  qrd <- qr(D)
  Q <- qr.Q(qrd)
  rnk <- qrd$rank
  if (rnk <= p) 
    warning("regression apparently linear")
  Q1 <- Q[, 1:rnk]
  C <- array(0, c(rnk, p, p))
  for (j in 1:p) C[, , j] <- crossprod(Q1, a[, , j])
  C <- aperm(C, c(2, 3, 1))
  r11i <- solve(qr.R(qrd)[1:p, 1:p])
  ct <- 0
  for (j in 1:p) {
    C[, , j] <- crossprod(r11i, C[, , j]) %*% r11i * sp
    ct <- ct + 2 * sum(C[, , j]^2) + sum(diag(C[, , j]))^2
  }
  ci <- 0
  for (j in (p + 1):rnk) {
    C[, , j] <- crossprod(r11i, C[, , j]) %*% r11i * sp
    ci <- ci + 2 * sum(C[, , j]^2) + sum(diag(C[, , j]))^2
  }
  ct <- sqrt(ct/(p * (p + 2)))
  ci <- sqrt(ci/(p * (p + 2)))
  pe <- ct * sqrt(qf(19/20, p, n - p))
  ic <- ci * sqrt(qf(19/20, p, n - p))
  val <- list(pe = pe, ic = ic, ct = ct, ci = ci, C = C)
  class(val) <- "rms.curv"
  val
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
rnegbin
list(`package:MASS` = function (n, mu = n, theta = stop("'theta' must be specified")) 
{
  k <- if (length(n) > 1) 
    length(n)
  else n
  rpois(k, (mu * rgamma(k, theta))/theta)
}, function (n, mu = n, theta = stop("'theta' must be specified")) 
{
  k <- if (length(n) > 1) 
    length(n)
  else n
  rpois(k, (mu * rgamma(k, theta))/theta)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
road
list(`package:MASS` = list(deaths = c(968, 43, 588, 640, 4743, 566, 325, 118, 115, 1545, 1302, 262, 2207, 1410, 833, 669, 911, 1037, 1196, 616, 766, 2120, 841, 648, 1289, 259), drivers = c(158, 11, 91, 92, 952, 109, 167, 30, 35, 298, 203, 41, 544, 254, 150, 136, 147, 146, 46, 157, 255, 403, 189, 85, 234, 38), popden = c(64, 0.4, 12, 34, 100, 17, 518, 226, 12524, 91, 68, 8.1, 180, 129, 49, 27, 76, 72, 31, 314, 655, 137, 43, 46, 63, 4.6), rural = c(66, 5.9, 33, 73, 118, 73, 5.1, 3.4, 0, 57, 83, 40, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   102, 89, 100, 124, 65, 40, 19, 29, 17, 95, 110, 59, 100, 72), temp = c(62, 30, 64, 51, 65, 42, 37, 41, 44, 67, 54, 36, 33, 37, 30, 42, 44, 65, 30, 44, 37, 33, 22, 57, 40, 29), fuel = c(119, 6.2, 65, 74, 105, 78, 95, 20, 23, 216, 162, 29, 350, 196, 109, 94, 104, 109, 37, 113, 166, 306, 132, 77, 180, 31)))
package:MASS
TRUE
FALSE
rotifer
list(`package:MASS` = list(density = c(1.019, 1.02, 1.021, 1.03, 1.03, 1.03, 1.031, 1.04, 1.04, 1.041, 1.048, 1.049, 1.05, 1.05, 1.06, 1.061, 1.063, 1.07, 1.07, 1.07), pm.y = c(11, 7, 10, 19, 9, 21, 13, 34, 10, 36, 20, 54, 20, 9, 14, 10, 64, 68, 488, 88), pm.tot = c(58, 86, 76, 83, 56, 73, 29, 44, 31, 56, 27, 59, 22, 14, 17, 22, 66, 86, 492, 89), kc.y = c(13, 14, 30, 10, 14, 35, 26, 32, 22, 23, 7, 22, 9, 34, 71, 25, 94, 63, 178, 154), kc.tot = c(161, 248, 234, 283, 129, 161, 167, 286, 117, 162, 42, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  48, 49, 160, 74, 45, 101, 68, 190, 154)))
package:MASS
TRUE
FALSE
Rubber
list(`package:MASS` = list(loss = c(372, 206, 175, 154, 136, 112, 55, 45, 221, 166, 164, 113, 82, 32, 228, 196, 128, 97, 64, 249, 219, 186, 155, 114, 341, 340, 283, 267, 215, 148), hard = c(45, 55, 61, 66, 71, 71, 81, 86, 53, 60, 64, 68, 79, 81, 56, 68, 75, 83, 88, 59, 71, 80, 82, 89, 51, 59, 65, 74, 81, 86), tens = c(162, 233, 232, 231, 231, 237, 224, 219, 203, 189, 210, 210, 196, 180, 200, 173, 188, 161, 119, 161, 151, 165, 151, 128, 161, 146, 148, 144, 134, 127)))
package:MASS
TRUE
FALSE
sammon
list(`package:MASS` = function (d, y = cmdscale(d, k), k = 2, niter = 100, trace = TRUE, magic = 0.2, tol = 1e-04) 
{
  call <- match.call()
  if (any(is.infinite(d))) 
    stop("Infs not allowed in 'd'")
  if (any(is.na(d)) && missing(y)) 
    stop("an initial configuration must be supplied if there are NAs in 'd'")
  if (!is.matrix(y)) 
    stop("'y' must be a matrix")
  if (is.null(n <- attr(d, "Size"))) {
    x <- as.matrix(d)
    if ((n <- nrow(x)) != ncol(x)) 
      stop("distances must be result of 'dist' or a square matrix")
    rn <- rownames(x)
  }
  else {
    x <- matrix(0, n, n)
    x[row(x) > col(x)] <- d
    x <- x + t(x)
    rn <- attr(d, "Labels")
  }
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid size")
  ab <- x[row(x) < col(x)] <= 0
  if (any(ab, na.rm = TRUE)) {
    ab <- !is.na(ab) & ab
    aa <- cbind(as.vector(row(x)), as.vector(col(x)))[row(x) < col(x), ]
    aa <- aa[ab, , drop = FALSE]
    stop(gettextf("zero or negative distance between objects %d and %d", aa[1, 1], aa[1, 2]), domain = NA)
  }
  nas <- is.na(x)
  diag(nas) <- FALSE
  if (any(rowSums(!nas) < 2)) 
    stop("not enough non-missing data")
  if (any(dim(y) != c(n, k))) 
    stop("invalid initial configuration")
  if (any(!is.finite(y))) 
    stop("initial configuration must be complete")
  storage.mode(x) <- "double"
  storage.mode(y) <- "double"
  z <- .C(VR_sammon, x = x, n, as.integer(k), y = y, as.integer(niter), e = double(1), as.integer(trace), as.double(magic), as.double(tol), NAOK = TRUE)
  points <- z$y
  dimnames(points) <- list(rn, NULL)
  list(points = points, stress = z$e, call = call)
}, function (d, y = cmdscale(d, k), k = 2, niter = 100, trace = TRUE, magic = 0.2, tol = 1e-04) 
{
  call <- match.call()
  if (any(is.infinite(d))) 
    stop("Infs not allowed in 'd'")
  if (any(is.na(d)) && missing(y)) 
    stop("an initial configuration must be supplied if there are NAs in 'd'")
  if (!is.matrix(y)) 
    stop("'y' must be a matrix")
  if (is.null(n <- attr(d, "Size"))) {
    x <- as.matrix(d)
    if ((n <- nrow(x)) != ncol(x)) 
      stop("distances must be result of 'dist' or a square matrix")
    rn <- rownames(x)
  }
  else {
    x <- matrix(0, n, n)
    x[row(x) > col(x)] <- d
    x <- x + t(x)
    rn <- attr(d, "Labels")
  }
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid size")
  ab <- x[row(x) < col(x)] <= 0
  if (any(ab, na.rm = TRUE)) {
    ab <- !is.na(ab) & ab
    aa <- cbind(as.vector(row(x)), as.vector(col(x)))[row(x) < col(x), ]
    aa <- aa[ab, , drop = FALSE]
    stop(gettextf("zero or negative distance between objects %d and %d", aa[1, 1], aa[1, 2]), domain = NA)
  }
  nas <- is.na(x)
  diag(nas) <- FALSE
  if (any(rowSums(!nas) < 2)) 
    stop("not enough non-missing data")
  if (any(dim(y) != c(n, k))) 
    stop("invalid initial configuration")
  if (any(!is.finite(y))) 
    stop("initial configuration must be complete")
  storage.mode(x) <- "double"
  storage.mode(y) <- "double"
  z <- .C(VR_sammon, x = x, n, as.integer(k), y = y, as.integer(niter), e = double(1), as.integer(trace), as.double(magic), as.double(tol), NAOK = TRUE)
  points <- z$y
  dimnames(points) <- list(rn, NULL)
  list(points = points, stress = z$e, call = call)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
select
list(`package:MASS` = function (obj) 
  UseMethod("select"), function (obj) 
    UseMethod("select"))
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
Shepard
list(`package:MASS` = function (d, x, p = 2) 
{
  n <- as.integer(nrow(x))
  if (is.na(n)) 
    stop("invalid row(x)")
  k <- ncol(x)
  y <- dist(x, method = "minkowski", p = p)
  ord <- order(d)
  y <- y[ord]
  nd <- length(ord)
  if (is.na(nd)) 
    stop("invalid length(d)")
  Z <- .C(VR_mds_fn, as.double(y), yf = as.double(y), as.integer(nd), ssq = double(1), as.integer(order(ord) - 1), as.double(x), as.integer(n), as.integer(k), g = double(n * k), as.integer(1), as.double(2))
  list(x = d[ord], y = y, yf = Z$yf)
}, function (d, x, p = 2) 
{
  n <- as.integer(nrow(x))
  if (is.na(n)) 
    stop("invalid row(x)")
  k <- ncol(x)
  y <- dist(x, method = "minkowski", p = p)
  ord <- order(d)
  y <- y[ord]
  nd <- length(ord)
  if (is.na(nd)) 
    stop("invalid length(d)")
  Z <- .C(VR_mds_fn, as.double(y), yf = as.double(y), as.integer(nd), ssq = double(1), as.integer(order(ord) - 1), as.double(x), as.integer(n), as.integer(k), g = double(n * k), as.integer(1), as.double(2))
  list(x = d[ord], y = y, yf = Z$yf)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
ships
list(`package:MASS` = list(type = c(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5), year = c(60, 60, 65, 65, 70, 70, 75, 75, 60, 60, 65, 65, 70, 70, 75, 75, 60, 60, 65, 65, 70, 70, 75, 75, 60, 60, 65, 65, 70, 70, 75, 75, 60, 60, 65, 65, 70, 70, 75, 75), period = c(60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75, 60, 75), service = c(127, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               63, 1095, 1095, 1512, 3353, 0, 2244, 44882, 17176, 28609, 20370, 7064, 13099, 0, 7117, 1179, 552, 781, 676, 783, 1948, 0, 274, 251, 105, 288, 192, 349, 1208, 0, 2051, 45, 0, 789, 437, 1157, 2161, 0, 542), incidents = c(0, 0, 3, 4, 6, 18, 0, 11, 39, 29, 58, 53, 12, 44, 0, 18, 1, 1, 0, 1, 6, 2, 0, 1, 0, 0, 0, 0, 2, 11, 0, 4, 0, 0, 7, 7, 5, 12, 0, 1)))
package:MASS
TRUE
FALSE
shoes
list(`package:MASS` = list(A = c(13.2, 8.2, 10.9, 14.3, 10.7, 6.6, 9.5, 10.8, 8.8, 13.3), B = c(14, 8.8, 11.2, 14.2, 11.8, 6.4, 9.8, 11.3, 9.3, 13.6)))
package:MASS
TRUE
FALSE
shrimp
list(`package:MASS` = c(32.2, 33, 30.8, 33.8, 32.2, 33.3, 31.7, 35.7, 32.4, 31.2, 26.6, 30.7, 32.5, 30.7, 31.2, 30.3, 32.3, 31.7))
package:MASS
TRUE
FALSE
shuttle
list(`package:MASS` = list(stability = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                         2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), error = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 
                                                                                                                                                                                                                                                                                                                                                                      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 4, 4, 4, 4, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 4, 4, 4, 4, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 4, 4, 4, 4, 
                                                                                                                                                                                                                                                                                                                                                                      2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 4, 4, 4, 4, 2, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2), sign = c(2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1), wind = c(1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1), magn = c(1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              3, 3, 3, 3, 3, 3, 3, 3, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 1, 2, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 2, 4), vis = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), use = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)))
package:MASS
TRUE
FALSE
Sitka
list(`package:MASS` = list(size = c(4.51, 4.98, 5.41, 5.9, 6.15, 4.24, 4.2, 4.68, 4.92, 4.96, 3.98, 4.36, 4.79, 4.99, 5.03, 4.36, 4.77, 5.1, 5.3, 5.36, 4.34, 4.95, 5.42, 5.97, 6.28, 4.59, 5.08, 5.36, 5.76, 6, 4.41, 4.56, 4.95, 5.23, 5.33, 4.24, 4.64, 4.95, 5.38, 5.48, 4.82, 5.17, 5.76, 6.12, 6.24, 3.84, 4.17, 4.67, 4.67, 4.8, 4.07, 4.31, 4.9, 5.1, 5.1, 4.28, 4.8, 5.27, 5.55, 5.65, 4.47, 4.89, 5.23, 5.55, 5.74, 4.46, 4.84, 5.11, 5.34, 5.46, 4.6, 4.08, 4.17, 4.35, 4.59, 3.73, 4.15, 4.61, 4.87, 4.93, 
                                    4.67, 4.88, 5.18, 5.34, 5.49, 2.96, 3.47, 3.76, 3.89, 4.3, 3.24, 3.93, 4.76, 4.62, 4.64, 4.36, 4.77, 5.02, 5.26, 5.45, 4.04, 4.64, 4.86, 5.09, 5.25, 3.53, 4.25, 4.68, 4.97, 5.18, 4.22, 4.69, 5.07, 5.37, 5.58, 2.79, 3.1, 3.3, 3.38, 3.55, 3.3, 3.9, 4.34, 4.96, 5.4, 3.34, 3.81, 4.21, 4.54, 4.86, 3.76, 4.36, 4.7, 5.44, 5.32, 4.49, 4.76, 5.15, 5.37, 5.56, 4.88, 5.14, 5.52, 6.08, 6.17, 4.88, 5.32, 5.63, 5.75, 5.94, 3.8, 4.16, 4.45, 4.89, 5.05, 4.46, 4.62, 5, 5.4, 5.49, 4.29, 4.82, 5.32, 5.46, 5.5, 4.06, 
                                    4.58, 4.81, 5.12, 5.27, 5.16, 5.43, 5.71, 6.08, 6.21, 3.81, 4.12, 4.42, 4.62, 4.6, 5.09, 5.62, 5.9, 6.36, 6.49, 4.13, 4.71, 5.27, 5.56, 5.72, 4.85, 5.36, 5.52, 5.96, 6.13, 4.11, 4.62, 4.95, 5.28, 5.43, 4.95, 5.39, 5.82, 6.42, 6.48, 4.36, 4.65, 5.04, 5.38, 5.47, 4.05, 4.65, 5.09, 5.44, 5.6, 3.76, 4.27, 4.59, 5.1, 5.25, 2.84, 3.25, 3.69, 4.16, 4.21, 4.33, 4.8, 5.09, 5.42, 5.61, 3.99, 4.55, 4.91, 5.26, 5.3, 3.5, 3.75, 3.97, 4.71, 4.85, 3.31, 3.45, 4.16, 4.48, 4.54, 3.03, 3.55, 3.97, 4.4, 4.58, 3.27, 
                                    3.83, 4.44, 4.8, 4.89, 3.56, 4.18, 4.7, 5.27, 5.28, 3.39, 3.73, 3.92, 4.11, 4.15, 3.72, 4.16, 4.55, 5.03, 5.02, 4.53, 5.05, 5.18, 5.41, 5.42, 4.97, 5.32, 5.83, 6.29, 6.45, 4.37, 4.81, 5.03, 5.19, 5.4, 4.58, 4.99, 5.37, 5.68, 5.93, 4, 4.5, 4.92, 5.44, 5.87, 4.73, 5.05, 5.33, 5.92, 6.01, 5.15, 5.63, 6.11, 6.39, 6.61, 4.1, 4.46, 4.84, 5.29, 5.48, 3.22, 3.85, 4.47, 4.85, 5.11, 2.23, 2.89, 3.16, 3.4, 3.52, 3.65, 4.36, 4.76, 5.18, 5.44, 3.4, 3.92, 4.5, 4.97, 5.14, 5.16, 5.49, 5.74, 6.05, 6.21, 4.04, 4.52, 
                                    5.15, 5.59, 5.87, 4.52, 4.91, 5.04, 5.71, 5.97, 4.56, 5.12, 5.4, 5.69, 5.89, 4.9, 5.35, 5.71, 6.12, 6.25, 4.83, 5.1, 5.43, 5.59, 6.04, 5.46, 5.79, 6.12, 6.41, 6.63, 4.17, 4.67, 5.16, 5.56, 5.75, 3.35, 4.05, 4.51, 5.22, 5.44, 3.33, 3.82, 4.38, 4.99, 5.17, 3.41, 3.68, 4.03, 4.28, 4.54, 4.5, 4.8, 5.28, 5.83, 6.16, 2.99, 3.61, 4.48, 4.91, 5.06), Time = c(152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 
                                                                                                                                                                                                                                                                                                                                                                                                     152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 
                                                                                                                                                                                                                                                                                                                                                                                                     174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 
                                                                                                                                                                                                                                                                                                                                                                                                     201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 
                                                                                                                                                                                                                                                                                                                                                                                                     227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258, 152, 174, 201, 227, 258), tree = c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     37, 37, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     62, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 68, 68, 68, 68, 68, 69, 69, 69, 69, 69, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 73, 73, 73, 73, 73, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 76, 76, 76, 76, 76, 77, 77, 77, 77, 77, 78, 78, 78, 78, 78, 79, 79, 79, 79, 79), treat = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))
package:MASS
TRUE
FALSE
Sitka89
list(`package:MASS` = list(size = c(6.16, 6.18, 6.48, 6.65, 6.87, 6.95, 6.99, 7.04, 5.2, 5.22, 5.39, 5.65, 5.71, 5.78, 5.82, 5.85, 5.87, 5.88, 6.04, 6.34, 6.49, 6.58, 6.65, 6.61, 5.53, 5.56, 5.68, 5.93, 6.21, 6.26, 6.2, 6.19, 6.5, 6.5, 6.79, 6.83, 7.1, 7.17, 7.21, 7.16, 6.33, 6.34, 6.39, 6.78, 6.91, 6.99, 7.01, 7.05, 6.13, 6.14, 6.36, 6.57, 6.78, 6.82, 6.81, 6.86, 5.61, 5.63, 5.82, 6.18, 6.42, 6.48, 6.47, 6.46, 6.48, 6.5, 6.77, 7.14, 7.26, 7.3, 6.91, 7.28, 4.94, 4.94, 5.05, 5.33, 5.53, 5.56, 5.57, 
                                    5.6, 5.26, 5.26, 5.38, 5.66, 5.81, 5.84, 5.93, 5.89, 5.76, 5.77, 5.98, 6.18, 6.39, 6.43, 6.44, 6.41, 5.99, 6.01, 6.08, 6.39, 6.45, 6.57, 6.57, 6.58, 5.47, 5.49, 5.7, 5.93, 6.06, 6.15, 6.12, 6.12, 4.65, 4.69, 5.01, 5.21, 5.38, 5.58, 5.46, 5.5, 5.24, 5.25, 5.25, 5.45, 5.65, 5.65, 5.76, 5.83, 6.44, 6.44, 6.61, 6.74, 7.06, 7.11, 7.04, 7.11, 4.15, 4.15, 4.41, 4.72, 4.76, 4.93, 4.98, 5.07, 4.63, 4.64, 4.77, 5.08, 5.27, 5.3, 5.43, 5.2, 5.44, 5.44, 5.49, 5.73, 5.77, 6.01, 5.96, 5.96, 5.25, 5.27, 5.5, 5.65, 
                                    5.69, 5.97, 5.97, 5.89, 5.64, 5.64, 5.53, 5.74, 5.78, 5.94, 6.18, 5.99, 5.76, 5.8, 6.11, 6.37, 6.35, 6.58, 6.55, 6.55, 3.61, 3.65, 3.93, 4.18, 4.13, 4.36, 4.43, 4.39, 5.46, 5.49, 5.77, 6.03, 6.07, 6.2, 6.26, 6.28, 4.93, 4.96, 5.15, 5.48, 5.49, 5.7, 5.74, 5.74, 5.65, 5.67, 5.63, 6.04, 6.02, 6.05, 6.03, 5.91, 5.73, 5.73, 5.8, 5.97, 6.1, 6.16, 6.22, 6.13, 6.32, 6.33, 6.37, 6.68, 6.83, 6.94, 6.93, 6.95, 6.09, 6.09, 6.14, 6.51, 6.61, 6.68, 6.64, 6.74, 5.06, 5.06, 5.13, 5.32, 5.46, 5.46, 5.42, 5.49, 5.68, 
                                    5.72, 5.95, 6.13, 6.32, 6.33, 6.33, 6.3, 5.54, 5.54, 5.54, 5.6, 5.57, 5.55, 5.55, 5.55, 5.48, 5.51, 5.58, 5.93, 6.36, 6.17, 6.07, 6.13, 6.37, 6.38, 6.41, 6.64, 6.82, 6.89, 7.11, 7.14, 4.74, 4.76, 4.94, 5.1, 5.21, 5.23, 5.22, 5.23, 6.72, 6.72, 6.74, 6.87, 6.87, 6.87, 6.83, 6.97, 6.06, 6.06, 6.21, 6.44, 6.66, 6.71, 6.65, 6.64, 6.22, 6.24, 6.41, 6.58, 6.78, 6.83, 6.82, 6.8, 5.8, 5.8, 5.87, 6.2, 6.44, 6.44, 6.4, 6.44, 6.61, 6.61, 6.66, 6.73, 6.83, 6.9, 6.83, 6.63, 5.48, 5.48, 5.47, 5.84, 5.97, 5.93, 
                                    5.95, 6.01, 5.79, 5.8, 6.07, 6.14, 6.3, 6.32, 6.34, 6.42, 5.41, 5.44, 5.48, 5.93, 5.97, 6.08, 6.29, 6.24, 4.3, 4.3, 4.45, 4.59, 4.74, 4.84, 4.64, 4.64, 5.85, 5.88, 6.01, 6.22, 6.45, 6.55, 6.55, 6.55, 5.69, 5.69, 5.9, 5.89, 5.98, 6.05, 6.25, 6.25, 5.01, 5.02, 5.27, 5.45, 5.59, 5.67, 5.83, 5.86, 4.72, 4.74, 4.93, 5.07, 5.26, 5.26, 5.35, 5.35, 4.47, 4.47, 4.66, 4.8, 5.1, 5.08, 5.12, 5.12, 5.08, 5.09, 5.34, 5.63, 5.81, 5.93, 5.94, 5.94, 5.5, 5.5, 5.77, 5.98, 6.05, 6.19, 6.14, 6.14, 4.49, 4.52, 4.82, 
                                    5.18, 5.26, 5.32, 5.28, 5.28, 5.16, 5.16, 5.28, 5.52, 5.7, 5.7, 5.67, 5.67, 5.71, 5.71, 5.96, 6.17, 6.34, 6.44, 6.46, 6.43, 6.61, 6.61, 6.79, 7.13, 7.24, 7.32, 7.29, 7.35, 5.57, 5.59, 5.82, 6.03, 6.17, 6.32, 6.25, 6.29, 6.14, 6.17, 6.43, 6.56, 6.69, 6.81, 6.82, 6.76, 6.02, 6.04, 6.11, 6.47, 6.61, 6.66, 6.7, 6.65, 6.26, 6.26, 6.36, 6.49, 6.63, 6.92, 6.92, 6.92, 6.82, 6.82, 6.95, 7.11, 7.44, 7.53, 7.46, 7.56, 5.68, 5.68, 5.85, 5.99, 6.08, 6.25, 6.15, 6.18, 5.28, 5.28, 5.45, 5.74, 5.95, 6.05, 6.07, 
                                    6.02, 3.89, 3.93, 4.22, 4.51, 4.65, 4.7, 4.73, 4.68, 5.7, 5.7, 5.89, 6.09, 6.39, 6.57, 6.36, 6.44, 5.34, 5.35, 5.61, 5.83, 6.03, 6.09, 5.98, 5.95, 6.37, 6.37, 6.52, 6.65, 6.86, 6.87, 6.88, 6.84, 5.96, 5.96, 6.17, 6.37, 6.53, 6.6, 6.52, 6.59, 6.11, 6.12, 6.24, 6.44, 6.54, 6.65, 6.63, 6.64, 6.16, 6.17, 6.13, 6.44, 6.72, 6.81, 6.87, 6.8, 6.39, 6.39, 6.52, 6.86, 7.05, 7.09, 6.9, 6.88, 6.21, 6.21, 6.46, 6.45, 6.59, 6.7, 6.63, 6.66, 6.73, 6.73, 6.77, 6.68, 6.75, 6.75, 6.62, 6.6, 6, 6.02, 6.14, 6.28, 6.55, 
                                    6.66, 6.63, 6.63, 5.79, 5.82, 6.05, 6.29, 6.22, 6.39, 6.47, 6.42, 5.4, 5.4, 5.73, 5.85, 5.75, 5.99, 6.1, 6.15, 4.52, 4.57, 5.01, 5.13, 5.11, 5.3, 5.46, 5.35, 6.33, 6.34, 6.56, 6.63, 6.75, 6.89, 6.96, 6.94, 5.23, 5.25, 5.56, 5.95, 5.98, 6.21, 6.28, 6.34), Time = c(469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 
                                                                                                                                                                                                                                                                                                            469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 
                                                                                                                                                                                                                                                                                                            613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 
                                                                                                                                                                                                                                                                                                            528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 
                                                                                                                                                                                                                                                                                                            674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 
                                                                                                                                                                                                                                                                                                            579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 
                                                                                                                                                                                                                                                                                                            496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674, 469, 496, 528, 556, 579, 613, 639, 674), tree = c(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 68, 68, 68, 68, 68, 68, 68, 68, 69, 69, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 69, 69, 69, 69, 69, 69, 70, 70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 72, 72, 72, 73, 73, 73, 73, 73, 73, 73, 73, 74, 74, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 75, 75, 75, 76, 76, 76, 76, 76, 76, 76, 76, 77, 77, 77, 77, 77, 77, 77, 77, 78, 78, 78, 78, 78, 78, 78, 78, 79, 79, 79, 79, 79, 79, 79, 79), treat = c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))
package:MASS
TRUE
FALSE
Skye
list(`package:MASS` = list(A = c(52, 52, 47, 45, 40, 37, 27, 27, 23, 22, 21, 25, 24, 22, 22, 20, 16, 17, 14, 13, 13, 14, 24), F = c(42, 44, 48, 49, 50, 54, 58, 54, 59, 59, 60, 53, 54, 55, 56, 58, 62, 57, 54, 55, 52, 47, 56), M = c(6, 4, 5, 6, 10, 9, 15, 19, 18, 19, 19, 22, 22, 23, 22, 22, 22, 26, 32, 32, 35, 39, 20)))
package:MASS
TRUE
FALSE
snails
list(`package:MASS` = list(Species = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Exposure = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                     1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4), Rel.Hum = c(60, 60, 60, 65.8, 65.8, 65.8, 70.5, 70.5, 70.5, 75.8, 75.8, 75.8, 60, 60, 60, 65.8, 65.8, 65.8, 70.5, 70.5, 70.5, 75.8, 75.8, 75.8, 60, 60, 60, 65.8, 65.8, 65.8, 70.5, 70.5, 70.5, 75.8, 75.8, 75.8, 60, 60, 60, 65.8, 65.8, 65.8, 70.5, 70.5, 70.5, 75.8, 75.8, 75.8, 60, 60, 60, 65.8, 65.8, 65.8, 70.5, 70.5, 70.5, 75.8, 75.8, 75.8, 60, 60, 60, 65.8, 65.8, 65.8, 70.5, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                70.5, 70.5, 75.8, 75.8, 75.8, 60, 60, 60, 65.8, 65.8, 65.8, 70.5, 70.5, 70.5, 75.8, 75.8, 75.8, 60, 60, 60, 65.8, 65.8, 65.8, 70.5, 70.5, 70.5, 75.8, 75.8, 75.8), Temp = c(10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            20, 10, 15, 20, 10, 15, 20, 10, 15, 20, 10, 15, 20), Deaths = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 4, 5, 0, 2, 4, 0, 2, 3, 0, 1, 2, 7, 7, 7, 4, 4, 7, 3, 3, 5, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 2, 1, 0, 0, 1, 1, 0, 1, 7, 11, 11, 4, 5, 9, 2, 4, 6, 2, 3, 5, 12, 14, 16, 10, 12, 12, 5, 7, 9, 4, 5, 7), N = c(20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20)))
package:MASS
TRUE
FALSE
SP500
list(`package:MASS` = c(-0.258890812009049, -0.865030658884791, -0.980413859884877, 0.45043207078832, -1.18566663869508, -0.662909749729135, 0.350655682365808, -2.49845956488199, -0.865678370822298, 1.10661402242806, -0.987990046477449, 0.233869761268224, 0.283461966753862, -2.61989802650939, 0.371607249487838, -0.407935658703096, -1.27374730004819, -0.0859053866415493, -0.184331849428876, -0.684997587273539, 1.87104804998093, -0.0881633206512689, 0.645740522776528, 0.280640526995146, -0.662123928872393, 
                        1.23303894112494, -0.236984706913468, 0.1980258080585, -1.06675714029683, 0.284374718945291, 0.298629243240889, 0.863703074994771, -0.65008242600948, -1.43181753201533, -0.0976115747210571, -0.603029208510453, -0.477034066118342, 1.38478362499219, 0.48260151639159, 0.492336568008689, 0.255781551666789, 0.83797701106576, -0.537892762349745, 1.24765267242566, -0.290422205078755, 0.980486872045105, -0.69006466696635, 0.218740849855159, -0.791502197836103, 0.25859392893528, 0.355587537981084, 1.12945699033862, 
                        0.47268995576033, -0.572180804957245, -0.537201685262012, -1.19925041505002, 0.45474213091703, 0.121508498316558, 1.13970576778444, 0.146305805176006, -0.354428526095507, -0.24973203524441, -0.365437162547977, 1.44798379461299, -0.744822569086523, -0.105599728213868, -0.190949074631686, 0.378604898649204, 0.204846144439319, -0.043860291058273, 0.705274977748882, 0.116096837791879, -0.0174059354678846, -1.15554247566081, -0.774889338673823, -0.882345558944042, -1.22192552679241, -0.208645242833949, 
                        0.504235733740632, 0.267689459797182, -1.15101794893002, 0.512192176094217, 0.437373444381883, 0.668938945495512, 0.325349141553399, 0.836849800416672, 0.630415096734716, 0.43367489658559, 0.248222417812105, 0.279606403401278, 2.35129109847492, 0.778214044205505, -0.132575509876975, -0.0790647807607847, 0.132680302327337, 0.0479474279750036, 0.94297959639027, 0.120039655412008, 0.239647888198657, -0.245227933956471, -1.07435920270076, 1.6973968479447, 0.0582112530470802, 0.102480309208452, 0.532863393131944, 
                        1.16076642774692, -0.207073258015722, -0.45926816647901, -0.49717864839014, -1.23017094525784, 0.810732707882078, 1.26945706528581, -0.369281688887568, -0.549602922337744, 0.00275554208419848, -1.67552788198568, 0.444538370976311, 0.175592670226443, 0.380783427705733, -1.40804114208102, -0.881685424470202, -0.0709854225755535, 0.871046231286243, 0.698685446733105, 0.108991836402517, 0.423658585622455, 0.172294054015243, -1.25169269425358, 0.767403289935586, 0.306432532177681, -0.846361946697449, 
                        1.32086856021925, 1.15872324553541, 0.510407112847933, 0.445495534830531, -0.388339456358722, -0.901965827311457, 0.301560115580468, -1.02073988205893, -1.75756351425935, 0.135002129912021, 0.364718168848199, -0.330996094621039, -0.696415022988095, 0.595214665772037, 0.168610409483616, -0.177048397309765, -1.14286958236232, -1.90142730556566, -3.07109474667424, 0.119535023049, 1.04579223425017, 0.468826877097062, -1.30875642955957, 0.984645240974036, 0.162186904313444, 0.197218402285504, -2.28130943364464, 
                        -1.3813796951756, 0.207209752050197, -2.04506104712907, -1.66354614002131, -3.04380387593826, 1.43882722102049, 3.13794606256668, -0.0311148451435983, 0.883001105335524, -1.704816526654, 1.20075670409454, 0.164175673831046, 0.401557344429548, -1.21890320458213, 0.913248356327223, -0.548813060674824, -0.183609057759693, 0.466143359370896, -1.21338377920672, -0.572796933380992, 0.296249822717964, 0.260854682227585, -0.629725002903658, -1.63040167381263, -0.0513808617598421, -2.18547121099464, 1.19769727373331, 
                        -1.04351041467865, -1.34978865641608, 1.67378952894523, 2.86336571951846, 0.0856938876530045, -1.21608239688955, 0.413402501944304, -0.381294619183326, 0.633622395715605, -2.70959704620397, -1.55579613348031, -1.6548166494359, 1.53490057630723, 1.06091238080186, -1.4315614402463, -0.0535403573223903, 2.30944920840219, 2.18053995554808, 0.726997653841366, -0.765407487230796, 0.0768049192902076, -0.780388372066465, -1.77600296471923, -0.933091720285173, 0.719546293602225, -0.0197348946468168, 0.988519063883331, 
                        1.56094109270768, 0.874790075142418, -0.948570693434725, -1.81667156322369, 0.521496569901192, 1.97318705721106, 1.81300566210938, -0.568156593871549, 0.855710708373092, -1.06053518244575, 0.031538777187734, 0.69761147699321, -1.27000840372791, 0.228086391529203, -0.294709702633966, 0.446478789849181, 0.501096209337781, -0.0471661041681948, -0.482369269249894, 1.81640970419235, 0.581756808466061, 0.691831493372508, 1.08797757473686, -0.257970673724284, -0.401937144754339, 0.347222571074912, -0.747718375351614, 
                        1.14220817504416, -0.257759456163065, -0.768109116621485, -0.24508314454943, 1.22854289566359, 0.0454373351248094, -0.0242306761544242, 0.492544848783361, -0.559209497778124, 0.287552222353238, -0.776773635960737, 0.13089604766936, 0.45527744285323, -1.14823013710446, -1.40047942620969, -0.283088024052969, -1.74726335606437, -0.171336146239298, -1.0887893123507, 0.97122261148872, 0.222307002123312, -0.873006245514674, 0.396027472982752, 0.774730021968217, 3.66420971725212, 1.29053593592321, -0.35278723136889, 
                        -0.83413438431954, 0.57705317145853, 1.3744783971064, 0.38458719236889, -0.011902990640511, -0.056558561943465, 1.49836567568746, 0.881963546553965, -0.256193915783687, 1.53028051667388, 0.834767568995076, 1.92018080197265, -0.433815875079979, 0.790650465193554, 2.53609404894393, -0.839150521405774, 0.95845639239025, -1.30927624460622, 1.32011517806578, 0.0893764024557875, -1.15721547875252, -0.0465683261624328, 0.186143329321986, 0.439345237407363, -1.21907628341056, 1.34968854687676, -0.18236011640429, 
                        0.921990423618801, -0.308191647020717, 1.98116526076655, -0.146103706474321, -0.0691415834372933, -0.255706928878485, -0.532150845995094, -0.788709185498959, 1.21946179460686, -0.286069680565415, 0.024093482829457, -0.39694299135995, -1.49454521408572, 0.362146588495893, -0.364874468796739, 0.245211685956459, 0.637454519170522, 1.73432570044207, -0.252777358038081, -0.0346403403546525, -1.05021594324306, 2.18442356526509, -0.147671563146901, 0.218792511263022, -1.16802408517351, 0.875313935909183, 
                        -1.35600705826855, -0.1098150664121, 1.19343966905747, 0.730845040326411, 0.207460781613822, 1.67275397852284, 0.727444183608217, -0.510971570469732, -1.10269540695303, -0.849511741543818, 0.212400599053275, 0.261602200151145, -0.921254268242055, -0.0606644089978126, -1.4242681106972, 0.448598883143436, 1.31018376951282, 0.0604618780001509, 0.073556457895485, -0.189254603854483, -0.728812309701343, 0.314885882610749, 1.24450251441637, -1.97901029127703, 0.271096511546265, -1.37365531500073, -0.824117392076307, 
                        0.977382368771451, 0.0537215624405896, -0.0295432878456126, 0.821266470150128, 0.223541088909318, -0.327498129365367, 0.672472465753593, 1.17194499352813, 0.222300772832629, 1.08347925791339, 0.738941814216254, -0.455077981376384, -0.082495493206558, -0.685793870857943, -0.379852678609716, -1.100841982222, -0.226913026123565, 0.652960377919776, -1.16142258404235, 0.259850599626787, 1.22646026243265, -0.566618341337133, -0.405947415343366, -0.928782815047491, 0.0879402063309165, 0.618720191452216, 
                        -1.81922766917078, -0.0782103358412556, 0.253287481823605, 0.753364868247175, -0.86915081184582, 1.80492965240191, -0.119143767651675, -1.10283483227383, 0.200693127396079, 1.02657745781896, -0.485379906584971, -0.0984238956889705, 0.32681938457344, 0.866332245451407, 0.561209906829596, -0.222533570032635, -0.0943990000874528, 1.09322072400415, -0.298860654624189, -0.349368104023373, -0.907785323566301, -0.205788532640749, 0.610849714056005, -0.00787515258515725, 0.581092620371226, 0.919678102279775, 
                        0.28921905247552, -0.178080647890244, 0.0154978690740215, -0.549053487461393, 1.4336054107555, -0.0153613764094729, -0.317997908635714, -0.566690507322942, 0.232216220149262, 0.411502046650192, 0.0718390835493743, -0.146298294897562, -0.967861886825361, -2.39103313809963, 0.783176380383832, 2.89882898821814, 0.189277731974435, 0.723109452574988, -0.0812162172507236, -0.200785417749305, 0.906679631504037, -0.0428692117369067, -0.262659577702706, -0.832936073380885, -0.557460657063746, -0.21306370448082, 
                        -0.0102796052721565, -0.136304623312444, -1.03735101716787, 0.137724961677677, 0.582578709710369, -0.972858645178931, 0.569298494829784, -0.0726065792710173, 0.372844924695759, 0.160103326646155, 0.0928457280293671, -0.51690386983303, 0.462754338450466, -0.214307005684322, -0.100857295488499, -0.152772592796957, 0.506618122452185, 0.34489005437548, -0.241813201462016, -0.980945580253767, -0.841043457307045, -0.460073108593662, 0.307826124124766, -1.02183153747246, 0.990303201119236, 0.236220582283764, 
                        1.30744648150287, 1.16788897546236, 0.456744137442033, -0.224283914999113, 0.147879989214328, -0.633851736236846, -0.563092057999093, 0.0283589210042123, -0.742555254746513, -0.226188560822393, 1.3751961539989, 0.501921668317351, 0.377339696110379, -0.129868494590024, -0.28835009835948, -0.266120934947889, -0.403086593092006, 0.323624877920903, 0.957018367297291, -0.211032228939612, 0.0585234301254012, 0.916624552709422, 0.168733906431662, -0.0654450285138886, -3.72717135239054, 0.682418713742816, 
                        -1.52227457682637, -0.234844095004227, 0.403380501885398, -1.03677204792794, -0.212913265080594, 0.695608805129933, -0.373752936706495, -0.353831993189591, 1.63361725508544, -0.11543104277667, -0.23389364564812, -0.707631078399551, 0.452088702421349, -0.22182326619804, -0.0952179504865924, -0.0529380637031451, 1.01416740172313, 0.762385875904936, -0.00260101699778303, -0.448384484279529, 0.193156072687728, -0.250652872745416, 1.17471073803754, 2.49547305046072, 0.630536536071258, 1.37037845936634, 
                        0.399359584146008, 2.11302895766137, 0.468621311078721, 0.0407502852166175, 0.497251801536525, -0.32963125511829, -0.134073952281, 0.167564371941964, -0.117265572064706, -0.602852758287931, -0.183256224125028, 1.46148891374107, 0.078458415122995, -0.610266739391196, 0.155303649789307, -0.598646456309737, -0.89747285142332, 1.32168468244478, -0.761025891433764, 0.125234831646637, -0.118005480477734, -0.00722935116890255, -1.1196045705085, 0.311450930625501, -0.692347963068229, 0.18330466693639, 1.04934286484086, 
                        -0.00241636361453246, -0.00483290240040901, -0.661892804503594, 0.649809526537215, -0.00241683080988153, 0.811182823070844, -0.828102274437548, -0.292918131900333, -1.24413089648279, 0.21578155594435, 1.37201724092488, -0.598550246381446, 0.203957822311907, -0.442435571971611, 1.18674194908053, -0.359378590139769, -0.280681562514662, -0.0605950451795678, 0.0969344556697394, -0.856265418009272, -0.691314775205853, -0.51051347080886, 0.190205701758472, 0.413742740195033, -0.705374601278663, -0.0346568970693184, 
                        0.481642959918105, 0.135429640388551, 0.781895474584626, -0.105040743477503, 0.158739883140857, 0.36536394315787, -0.338525182947524, -0.251590894687936, -0.33317032288771, 0.0833967033054606, -1.07474905541975, -0.12399257633211, 0.171069473595242, 0.13367662154975, -0.927025638971823, 0.261829212605669, 1.001073850622, -1.87400494496162, -0.898360740514548, 1.54441281857496, 0.906917376081751, 0.441774229352632, 1.54193190201681, 0.938860722346746, -0.0576701284725978, -1.41853217393457, 0.0195017308404211, 
                        -0.109746739953032, 0.435836630543385, -0.628794935714527, -0.139454681487106, 0.161456074997446, 0.708782332278712, 0.708613918381751, -0.58491006414938, 1.05614407636372, -0.0167916042373761, -0.0119957295346751, -0.225787951418344, 0.0480827031742237, 0.584754943499988, -0.527086200762295, 0.0384273607533459, -0.797988781124293, -0.740987076590738, 0.661079087594008, 0.858684935571929, -0.235645006608465, -0.673923733262249, 0.3435681200056, -0.632399767020786, 0.184560143696721, 1.10266405380877, 
                        -0.334098785697368, 0.46838493124266, -0.914787313376131, 0.263256561366898, -0.321314524195593, 0.0532210864824911, -0.029026172135449, -0.80153935240288, -0.687624297274603, 0.441015047755311, 0.173422449150795, 0.129260428948186, -0.481304602432697, -1.49525349912958, -0.3236974017371, 0.673604078150003, -0.0669086969092625, 0.158525744087257, -0.0495123048190216, -0.178447554045036, 0.0818279922172316, 1.35158817203926, -0.195819321396851, 1.1546741039532, -0.26920527990324, 0.501448465382026, 
                        -1.13731481064523, 0.273357585040301, 0.958152167780479, 0.0941062987951824, 0.0602780039709927, 0.675037095762043, -0.138958789939725, 0.105434688191419, -0.460896682224554, -0.450945457129581, 0.00241688922200112, -0.686321189442918, 0.279462156826593, -0.116550129743498, -0.0145783220609097, 1.44262265958721, 1.12177419260666, 0.399456892328232, 0.0683857454168546, 0.207229557264377, -0.171875962024792, -0.51267019144845, -0.379696224935522, -0.407400470569552, 0.128832178143767, -0.124057654998389, 
                        -0.267724977047923, -0.0119687376715305, 0.520511179486949, 0.197466310521932, 0.142504299244095, -0.750423399351341, 0.016737402155087, -0.818623961606768, -1.0005291987464, 0.216458197439362, 0.460539887095468, 0.0048365254411209, 0.316284049894389, -0.19544687534756, 0.491508036829558, 0.458006915375187, 0, -0.215553456871298, -0.63498385378411, 0.462205926371606, 0.858538592436897, -0.0881445627806343, 1.34700503843534, -1.30173190964626, 0.0357274712323274, 0.00238137762709201, 0.71186499983007, 
                        -0.186966814614387, -1.19151157039834, 0.0718924519929942, 0.246438138383542, -0.989417547720262, 0.546350806071771, 0.0431955083388225, 0.239635868330801, -0.362071634864947, -1.40792881597189, -0.709014754442272, -0.0957348953143367, -0.722184965931483, 0.862074304390692, -1.25617081029201, 1.18011491781465, 0.455470092200816, 0.0171009076113116, 0.0561681150827553, 0.518672098941053, 0.786253158359695, 0.120415206130531, 0.0457197866352565, -0.185414888714153, -0.193003678730008, 0.975664385314445, 
                        0.0788860376772504, 0.391119241288695, 0.173604961615137, -0.519333182379356, 0.967408279200654, -0.671677083464584, -0.671424096261042, 0.294452304433968, -0.181835632454419, 0.241577787099612, 0.00716666069751071, 0.85155482350201, 0.15856677917423, -0.104105060863269, -0.41513029455027, -0.335734585256908, 0.850240242897282, 0.179571439695714, 0.715078435740502, -0.359252297108981, 0.579331052354615, 0.373491878883403, 0.225752117753864, 0.276259302116522, -0.132230657337828, -0.206815694106055, 
                        0.00465224470893588, 0.498858303359206, 0.749395346808601, 0.385189058165292, -0.30711428612733, -0.23210664340283, -0.209588155536089, -0.205407598445895, -0.0623981716782573, -0.243030359524532, 0.902018919431669, 1.33455460192007, -0.131522275699591, -0.0885347556724092, -0.29112764210808, 0.168411509991273, -0.141082260692293, -0.266779312968168, 0.191605898035974, -0.711242178160809, -0.0757671459405529, -0.239157543968549, 0.0414336032444673, -0.876052987967135, -0.390798143274829, 0.441861184027825, 
                        0.0208819128590498, 0.460611644512632, 0.669760953324161, 0.277176642653298, -0.0709390297371826, -0.392215831306952, -0.405297043000452, 0.487996732995555, 0.142267118993367, 0.890294882043019, -0.0136369835203709, -0.419106369337285, 0.12546051350828, 0.0273522977635388, 0.848751265579484, 0.0067791248175908, 1.04524694260037, 0.526340480917664, -0.140235306624703, -0.240861866261444, -0.564277455067597, 0.201893379179641, 0.319950154915283, -0.690399944871434, -2.42928769390582, -0.140681057784153, 
                        -0.323624877920814, 0.535723813943534, 0.234628497672063, -0.101144783575702, 1.38638921617771, 0.33287697317439, 0.234837302523161, -0.309468390964884, 1.32374869570961, 0.303179152377009, -0.428285285490038, -0.275337350060845, 1.90942947301593, -0.0681985704733101, 0.423836458481919, -0.57359643009196, -0.861053408025558, 0.35505884670135, -0.0132919805246878, -0.680244486855575, 0.795382997903626, -0.379128459714106, -0.289191134297528, -0.0267367765952819, -0.153875346753818, 0.625175850108928, 
                        -0.689918833896375, 0.665519122135549, 0.265857435541061, -0.0663981255857315, -0.30377973847342, -1.99851889295601, 0.203693715187203, -0.255815409189175, 0.355248198561586, -0.201227783063018, 1.4670958817355, 0.189396106036188, -0.124738288548887, -0.0579671387154867, 0.120355732539412, -0.330210027846878, -0.528817222312128, -0.330809433816182, -0.944418121452628, -0.554485784424319, -0.801777845810037, 1.02576769992728, 0.00228302683709103, 0.198424076689197, 0.295763968617191, 0.514361299435606, 
                        0.35871038226718, 0.105787961293302, -0.283854298591812, -0.214551162397481, 0.110720712692913, 0.351684387903983, 0.0989698222850777, -1.26015490628717, 0.0751032705222698, 0.184105605852825, -0.0113547332327713, 1.63312147579422, 0.6724885056971, -1.05976918585569, 0.483308915370451, 0.189552378771296, 1.01742002996179, -0.22741081721982, -0.491913245425035, 0.80529627026138, 0.00440683941551612, -0.300108352436546, -0.538475623867107, -0.527987859811319, -0.667864427773157, 0.240317244429189, 
                        -0.0897706420536437, 0.42122306410608, 0.100562038486807, -0.322155136671309, 0.259595088157738, 0.247776279983913, -1.08942818306748, 0.57085220757962, -0.0650114913891109, -0.616341702774648, 0.770954920511446, 0.219185523102894, 0.94502899101947, -0.257052460552298, -0.0355074236437325, -0.335723732593518, -0.71072869187887, -0.994068618408495, 0.316649213981979, 1.30348351891554, -0.118204641585962, 0.193960533001114, -0.19842382244617, 0.443123964568581, -0.191259927089771, -0.775448872739837, 
                        0.0627957588644534, 0.286565221739288, -0.0290668427630258, -0.598864623290485, 0.580973135118246, 0.444102985011607, -0.189450983302208, -0.234524302572936, 0.679721369472475, -0.469740503326932, 0.449749166173063, -0.19568172395612, -0.16261796167818, -0.0914494805387633, 0.122656988426773, 0.453636535103996, -0.282169110865471, 0.22446698538241, -0.333548595913591, 0.262484857635403, 0.496388910938528, 0.165652543098283, 0.640146493470084, 0.0854822676358502, -0.0591722477516044, -0.204083942722466, 
                        0.992357870432148, 0.0782693811019364, 0.197574887593355, -0.108509309893812, 0.294870340708631, 0.358740902963106, -0.0884850766154521, -0.400238513626139, 0.00867077083697154, -0.613138702533522, -0.408667810912089, 0.185965157788726, 0.918176203113585, 0.0736106032502626, -0.468567823333554, 0.368964064801158, -0.47121245024444, -0.130681960531653, -0.827246806276438, -0.462555890806815, 0.714956573499137, 0.337002747990489, -0.0240339972971348, 0.907089956317364, -0.0584839673130943, -0.308146591646619, 
                        -0.256789834701365, 0.510754090630794, 0.0130064382052098, -0.0303509877240593, -0.0997895824396799, -0.339160252062243, 0.245788549930914, 0.123752987493386, 0.0520607387029415, 0.0802072424612277, 1.15047804637589, 0.570313294878932, -0.223892625112043, -0.479319600413852, -0.0300338956220614, -0.15245378343316, -0.450126213637869, 0.200545637420912, 0.0215401185538866, 0.0667448970316897, 0.669286236037703, 0.0213775707343267, 0.271098327049923, -0.140794016047519, -1.16377754763706, -1.20152231443758, 
                        0.45362431395235, 0.139163735521208, 0.02607165374231, 0.733729821685181, -0.233170795223803, 0.592654989438657, -0.353014982270494, 0.642674352509331, -0.414363751052438, -0.256346876266633, -0.220250137620859, -0.752935543638156, 0.412972244025411, 0.288069162485538, 0.151282689698551, -0.250821788649258, -0.0238175146466624, 0.0216525204379536, 0.263783936738715, 0.383621160118519, 0.33071369746196, 0.0707251500242201, -0.100744877499004, -0.453535012796813, -0.0538729258485304, 0.380797121186838, 
                        -0.568501466527938, -0.263812457037371, 0.32426150896443, 0.653962662786078, -0.113705857374935, -0.118133504583096, 0.43318889983448, 0.0128383438712021, 0.673834006461327, 0.0849726014504171, -0.0764720914147254, -0.413109337320705, -0.468404967245295, -0.216763866007863, 0.311048913813661, 0.141261099642787, -0.0920110906173832, 0.593372213348786, 1.13631574884492, -0.240151790160592, 0.00843614890309041, -0.359165433004538, 0.515105954342587, -0.339587548582276, 0.200517190292171, 0.0105424068411963, 
                        0.143266500149597, -0.0547541342520219, -0.580973229896919, -0.222719603354626, 0.482990389423588, 0.810317509362335, 0.345278920060821, 0.606056150017764, -0.414053419691385, 0.4949990348873, -0.267993637143338, -2.29358200274214, 0.414202404050368, -0.150613619757234, 0.364476680741266, -0.815550872659987, 0.266209653438665, 0.0106336597966994, 0.485813737247565, 0.0571241195676642, -0.519547784730978, -0.565015415270942, 0.802857956782521, -0.163455961670511, -1.37549631077958, 0.389109731753745, 
                        0.229316117249301, -0.579661985052571, 0.0796341177408344, -0.388006781108086, 0.372945730033436, 0.465841018456281, -0.220842937557908, 0.252963883902968, -0.678871731578301, 0.546038289443462, 0.203463227295853, -0.081335620922296, 0.514721937752771, 0.314786715611337, 0.0339717188710509, -0.536399753558037, 0.0554761360163525, -0.0554761360163525, -0.898289868062196, -0.815201340214688, -0.126007533672912, -1.64829262149873, -1.54340892094247, 0.0493649877636671, -1.54859598137671, 2.11231802988125, 
                        -0.0535511091182883, 0.629639538008675, -0.841894547038002, 0.617636889910855, -0.512570207617724, -0.293120825650917, 0.0268865389681849, -0.0448149151535127, -0.837239316266292, 0.0180790960944144, -0.13114755978112, 1.52019903191958, -0.245437224372935, 1.12847455616167, -0.185721603716083, -0.614894775120423, 0.402218295391066, 0.466851157121884, 0.00220738369858253, -0.289582960033741, -0.0752962055284634, -0.791819083699252, -1.23577639335153, 0.830777126369142, -1.01860035624961, 0.510597105875288, 
                        0.0878487256487759, 0.0787729466928511, 1.09190443356955, 0.956754358202172, 0.613074203443098, -0.342330814894609, -0.378805016239259, 0.354622016769923, 0.335839639587387, 0.157652758731341, 0.0590557656683366, -0.181653092639777, 0.2472297322198, 0.00437024735671088, 0.540435842168918, -0.272032028127711, -0.146114365918493, -0.251292100727785, 0.174878722485872, 0.176753671103569, 0.0937054014544358, 0.709738510553137, -0.381373839781496, 0.286166648775055, -0.756212995473415, -0.649942655350522, 
                        -0.913087219864028, 0.386984550259584, -0.766575891431032, -1.53068214975676, 1.01336657148057, -0.277597617204606, 0.349110794319873, -0.753451260291893, 0.43347962809106, 0.0380922509283899, -0.0537815139013631, 0.50306978015513, 0.260599526052818, -0.331993041199841, -0.0245532975196028, 0.173975152058237, 1.03754228461002, 0.165276545220117, 0.233125971556714, -0.299203813656135, -0.499194816597015, 0.223399524458578, 0.110409409264012, 0.251278566354785, -0.196119541491679, -0.174406455299891, 
                        0.368324541629672, 0.881101590653532, 0.598302610415402, -0.0976594367796402, 0.19305653440318, -0.663154031105595, -0.28618573531114, 0.17486725477216, 0.00655157729454459, 0.518395445511022, -0.308971285199533, 0.664627454681277, -0.153817853697191, 0.816207675142167, 0.0344019440491117, -0.430877285100895, 0.110050181037202, -0.293736712279458, 0.472579453793109, 0.968364573795721, -0.202751080543084, 1.21460702447047, 0.166598167994181, 0.311362883823385, -0.121905097277608, -0.489111931592134, 
                        -0.461786958564048, 0.184546905004446, -0.184546905004446, 0.455446541573856, -1.05384904275363, -0.421666096366646, 0.278456248124392, 0.275549938849995, 1.27384857504991, -0.765331431198923, -0.0721837745239817, -1.60352821987759, -0.410891346027942, -0.0411821448712324, -0.347471411778866, 0.249867048706953, 0.266559911646347, 0.602015002062384, -0.560902363674742, 0.101627123725923, -0.209854585100633, -1.56060482879976, -0.235654380013273, -0.256104701292159, 0.603885201946941, 0.862017721045838, 
                        1.45975365453452, -0.0687240969428515, 0.497182945593266, 0.279648806950838, -0.0298488371829997, -0.27759407973349, 0.55867258342932, -0.732025506960543, -0.420718846689017, -0.877160703388125, 0.151784581810066, 0.235892551089023, 0.69577111382797, 1.68582779679554, -0.300173564924577, -0.835490685488871, -0.408587307538522, 0.299651344697427, -1.21052016246033, 0.170746245622144, 0.555604840420454, -0.0537028099475201, -0.221560261429588, -0.435946823024835, 0.794928732809286, -0.216954771642808, 
                        0.126793118582302, -0.441245240710497, -0.454035200118508, -0.689305489776704, -1.80764287480466, -0.0355547658242195, 0.523155191105129, 0.412599184263041, 0.222141668115317, -0.325683011286504, -1.05694472827036, 0.970945979874838, 0.00441199179439522, -0.0463356252015323, -0.415773427750121, -1.28921801685786, 0.338409798424077, 0.560000571037733, 0.151174969321488, 1.06506221567848, 0.0812909932605521, 0.756999261133995, -0.194172700119122, -0.177047291632615, 0.547611845067753, 0.0152291442603314, 
                        0.0326260728715333, 0.572483402410384, -0.348738074515342, 0.0672429338917091, -0.412846616546325, -0.0348439647245513, 0.347894504085744, -0.0803430910162994, 0.0738311905158717, 0.0325552628456904, 0.184279897354767, -0.00433209868591078, -0.00433228636484984, 0.933588781870665, 0.729142055413412, 0.142639709951542, -0.0723589033018612, -0.589329743581413, -0.465801020370726, 0.223511805924126, 0.00858663919469649, 0.338583844297347, 0.188082469739381, 0.441031491147559, -0.400469168718676, 0.406846651953341, 
                        -0.00425161029804499, 0.50679186915783, 1.23183261163664, 0.51886466546307, -0.0686106373398943, 0.0790020831110461, -0.208034359078013, 0.264129514550948, 0.039455514419906, 0.186683314951264, 0.411544490936677, 0.14024090732736, -0.672052488611641, 0.15549039610816, 0.485643500908228, 0.378609065609048, 0.246148921230915, -0.884852262769886, 0.737235629096045, -0.357642410315506, -0.107130359037733, 0.0597599317151421, 0.0432521504091454, -0.725397135906203, 0.211342100502776, 0.00413950119071416, 
                        1.31795930738754, 0.0979971904236265, 0.577859869944586, -0.205124111038835, 0.715091825580227, 0.0222013664843423, 0.125042873723835, -0.215897825006373, 0.121121600692931, 0.056473247300648, 1.00711038604482, 0.444148633377939, 0.139013030032231, -0.154912545130514, -0.17904395337407, -0.301117952590069, 0.227417908420335, 0.673229364596484, 0.065294172341801, 0.100825392814663, 0.0671604963515371, 0.116436274169374, -0.292334338198774, 0.32388692281442, 0.405352778565327, -0.610622760836499, -0.150271901733401, 
                        -0.0890833383998313, 0.0732520993743435, 0.631302773345599, 0.861584761532619, -0.154147875868116, 0.10929389432528, 0.173453820005509, 0.225623965163102, -0.0874661124597331, 0.116604490823846, 1.08564436779561, 0.0115271560712671, -0.080718010263503, 0.735579134632935, -0.0763708605929558, 0.152683440609014, 0.00190706854965583, 0.224779125425822, 0.415840491384056, 0.0852329277968522, -0.212270041610019, -1.43125741364676, -0.0750888104824377, 0.855361741537397, 0.93895618757589, 0.00378357926642536, 
                        -0.00378357926642536, -0.93895618757589, -0.0133686009958112, 1.85817755387179, 0.016871467576518, -0.183864967370617, 0.578593706704389, -0.00933576063788522, -0.452895934513364, -0.146412910488891, -0.831852687509116, 0.555336611655477, 0.969143330016919, 0.0783202218083368, 0.121089071139302, 0.503274194719427, 0.993510775639184, -0.044028619313341, -0.183661526795564, 1.29493613518603, -0.247097638398586, -1.02026775468413, -0.312914406408282, 0.423121423054695, -0.158001135203278, 0.161672611504304, 
                        0.428634888388846, 0.031068671150436, 1.22226266227328, 0.428690450823055, 0.147275431627492, -0.433465610314165, 1.09531691012163, 0.0196097657260807, -0.198056965954851, 0.504183286252502, -0.759917319309888, -1.3484484679088, 0.463550607338448, 0.0144513891649822, 0.542221549128907, 0.799839644711753, 0.0908516063951481, 0.640737706761119, -0.405974940430198, -0.154668072327002, -0.431488589583218, -0.150209248227817, -0.00894814550278511, 0.0339986940618431, 0.194822085447122, 0.0642616183911038, 
                        -0.121417745476204, -0.404597923843664, -0.420652090761653, 0.830609789496073, -0.209244382485441, 0.250326448955285, -0.166218391993222, 0.0304046503572408, -0.196899787954674, 0.252319774534904, -0.426271847091897, 0.0574197037129132, 0.472458733451031, -0.187642462240944, 0.16978691358176, 0.164150912925543, 0.171001110425895, 0.348221934505144, 0.940863596729891, 0.175540270118901, 0.0210441401614858, 0.41820931142631, 0.214549310882184, 0.452009601149683, 0.391247642633274, 0.832778948703883, 
                        -0.0445602255950917, -0.0994751908597991, 0.245079259237269, 0.438953026389566, -0.644573386704383, -0.218076378785614, 0.013751138787832, -0.0687746111253773, -0.0636586541348017, 0.827832066488821, -0.249513066523832, -0.461355898805316, 0.10652372878166, -0.149508968312517, 0.199295659126886, -0.0240318594949329, -0.709821563103308, -0.147072844858176, 0.335356154499422, 0.626206285221098, 0.239808268401287, -0.251813790956135, 0.641131952250262, 0.112415061829019, 0.544951225117352, -0.541546680049354, 
                        -0.409375251895217, 0.252646088637221, -0.696318499380322, -0.99208018713286, 0.515384824936405, 0.610518255585202, -0.300493894282017, 0.466665226000096, 0.937022376289942, 0.144032423717189, -0.35792172422493, -0.364323935894717, 0.915093437855496, 0.261610147769975, -0.0910639365447885, -0.0708848825482278, -0.509484086862511, 0.789355461356678, 0.567448849091079, 0.455984955901467, -0.538048953673886, 0.566374969642602, -0.307014857720667, 0.262022730583755, 0.224758479352882, 0.849504599525641, 
                        0.19603165845723, -0.374275999355955, 0.265600024160761, 1.09777780635305, 0.649690434951999, 0.403923448377608, -0.648685899867019, 0.212377982797385, 0.32983053345168, -0.119518709212496, 0.469177866147419, -0.770222036209312, -0.094059653724532, -1.55830320850541, 0.840216965245855, -0.983692561905158, 0.748094213370454, 0.23886664281223, 0.383282834153409, 0.0374339823548731, -0.0667399202732177, 0.294297192208415, 0.776288406663639, 0.0950042340287283, -0.584334441785295, -0.160400549616213, 
                        0.283361994050146, -1.46756060443467, -1.81638035376963, 0.700986078454502, -0.146118747458957, -0.331217066696077, 1.42686942363976, -0.340794363468877, 0.307918011132813, 0.588492522697415, 0.256278553299527, -0.0994951924776721, 1.16326600734764, -0.473731473920314, 0.741132847836035, 0.417389676786506, 0.94550159476281, 0.927212310307013, 0.382901729512408, -0.411206731824265, 0.875309948654657, 0.761015041366875, 0.555445551909006, 0.94028257855836, 0.0457163764020052, 0.770974057602825, -0.14221310151985, 
                        -0.749192389519138, -0.651926710198047, -0.514124121758464, -1.13765457228494, 1.15617194780855, 1.64660634040059, 0.0333854351554308, -1.31651182879757, -0.496263636964756, -0.385452377015305, -0.672281901469773, 0.613326953752491, 0.994464564629904, 0.762287481231905, -0.57960538162467, 0.252747808121612, -3.13120402466751, 1.02394261042527, -0.458849298924768, 0.228904806607222, 0.362664729772799, 0.0873430609999559, 1.73409389848, -0.147200909785017, -0.262739555141778, -0.121616123735979, 0.220032247318525, 
                        -0.0891854963549044, 0.449728695622209, -0.623715421062787, 0.00462303039725498, -0.531505222067707, 1.2669211890243, 0.233768126075162, 0.094574194397623, -0.00304938478690175, -1.7876024046509, -0.318711742617417, -1.36242102999216, -0.366891640960532, 0.872320953203332, 0.903695956229456, 0.389906434985576, -0.526967433001602, 0.311231013275926, 0.226588544039696, 0.436209081725636, 0.567925372355838, -0.216631542372792, 0.414416113728677, 0.0903294022363887, 0.107064753807151, 0.00152866631513149, 
                        0.0626552073983433, -1.7258279130747, -0.272371589619258, -0.127881243839845, -0.398727728491011, 1.0147940214849, 0.103859071038936, 1.02503344444189, 1.43425113884561, 0.616378890827729, -0.0270469265822193, -0.0856968938461655, 0.608807062767358, 0.631866549485505, -0.0579533566011925, 0.837791131597676, -0.357348913224431, 0.370614151686599, -0.929867369016346, -0.641716624308231, 0.56284346462343, -0.384839603255038, -0.215439939702566, 0.728230998379864, 0.870471817659713, -0.800613982938359, 
                        0.0415942487093979, -0.170944024027708, -0.177198083785601, -0.288057750994586, -0.167544318752455, -0.310398593759142, -0.103680672844053, -0.467142694867029, -0.0151055120301002, 0.0211470780058676, 0.713353514902959, 0.300968266176493, -0.0553341373394467, -0.613715191632291, 0.624186160879603, 0.310638102808891, 0.779797640368596, -0.336423706882627, -0.179790688916182, -2.24998963993608, -0.748106513519176, 0.33810433879129, 0.199876478837879, -1.59637108280277, 0.0805040837372317, -2.569126951862, 
                        -0.227314371786935, 0.903019348806211, 1.48559043457164, -0.753343290972275, -0.779571728026252, -1.09469299802418, -0.0351011555075331, 0.71870688275073, 0.746607838832336, -0.787809664972983, 0.687114228666363, 0.73556843915048, 1.56130833452881, 1.90023317597454, -0.341720424461922, 0.325115021629507, 0.268367492621824, -0.23666866143941, -0.0739795759533202, 0.552766361880686, -0.840144613051486, 0.279826236667269, 0.0347345453644898, 0.441435303912652, 0.205738214470319, -0.133606571099332, 
                        -0.0931798438275067, 0.839982479563517, -0.54571006541968, -0.473361216289181, 0.378868060011417, -0.238880530659547, -1.1208624315918, -0.826343684439834, 0.417843893748593, 0.135843663331148, -0.945564686593059, 0.956241195994689, 1.22477733054955, 0.00753255949197396, 0.521378398240646, 0.578291100028849, 1.38939417389778, 0.504207675635548, -0.152166944762566, -0.215477835661737, 0.224262994605517, 0.588309982040514, -0.0800867892329471, -0.126813855737318, 0.0320830662496441, 0.00437416617531383, 
                        0.0481032041635743, 0.165996892913434, 0.254284834165652, 0.712899504672571, -0.177388115364519, 1.24513887755331, 0.267653918328392, -0.384621337697855, -0.558188914422342, -0.306177692740128, 0.867221099419879, 0.410198552671659, -0.137969313051034, 0.261553262868741, 0.365594852441564, 0.54027116697517, -0.136555308514019, -0.46314029214054, 0.0990211137323449, -0.706606419113331, -0.195266629414892, -0.523538937738088, 0.606253107967802, -0.0855676036236375, 0.621548471176148, -0.212910998500959, 
                        0.419709939055757, 1.04303239265047, 1.4526956098015, 0.4214185711227, 0.434702803878562, 0.143571116280405, -0.316128986512787, 0.214966981986731, 0.647577944191813, 0.236172488465947, -0.0813757979045704, 0.694982448181936, 0.240897492869063, -0.161431393098965, 0.801892354488309, 1.10244448834864, -0.141441804424947, -0.127071547781199, 0.267192391867965, -0.0607830460447545, -1.10046032265529, -0.425880192102213, -0.0966780428176328, -0.644215761853584, 1.36436558064608, -0.296533978060332, -0.91516291121545, 
                        -1.55510164364854, -0.0905387114812584, -1.05683852262057, 0.699371207660793, 0.754679139933234, 1.92519314993218, 0.416157107567994, -0.260731934923175, 0.54875133530885, 0.635765488829865, 0.128255152744749, -0.389239489478665, -1.75437226936284, -0.504822591298293, 1.48416235037709, -0.0508130092233827, 0.743567201836637, -0.641966989896403, 0.856809786448931, 0.614126802208315, 0.00131664702669454, 1.2235409809211, -0.216137474607692, 0.33182632353812, 0.830578155075479, 0.068260707023704, 0.772085763315111, 
                        0.447433743045877, -1.10885589952998, -0.909519989995466, -0.716363431831457, 0, 0.973003149625828, 1.49938248075134, 0.253450047475656, 0.0724780531317748, 0.321068302891803, -1.40094410112317, 0.239985228401629, 1.19896193875952, -0.524448976334746, 0.528248488731098, 1.65544236174142, 1.12103936951593, -0.412269916772523, 0.961374244053737, -0.466607754829074, -1.19979895136622, -0.128383322818326, 1.05580832516061, 0.21574183464006, -0.785064395211688, -1.32564802472936, -0.535977927122744, 0.566159393416577, 
                        -0.549722111094564, 1.38613843162592, -0.428603323954846, 0.799490392208391, 1.07252884632398, -0.284309633414992, -0.876460178596883, -1.84467717117176, 0.456174617300142, 0.319722340731499, -0.763232478081566, -0.493834433205986, -0.397853140799587, 0.185096590264511, 0.862233038506854, -0.23038568128424, 0.181061984042419, -2.12488338392411, -2.18950614603184, 0.332287549607635, -1.2624774403525, 0.027991975816466, 1.00516686173, 0.55656939920512, 0.522167062442591, -0.723121994030151, -0.297576160706914, 
                        -2.7662376523514, 0.82086083783981, 1.46687537939778, 1.16055970816413, -0.230774376332565, 0.598126263750132, -0.782077857529728, 1.85545199698236, -0.125302777576586, -0.318483976043371, -0.756243231870179, 0.98679237747028, 2.69191307505592, 0.913889486328046, -0.351278902603713, 1.79216711040722, 2.10808288579099, -0.305178005918627, -1.47746970726264, 0.567280294788741, 0.549532093418037, 1.54956061224754, -0.542259781327203, 0.348676641468781, 0.696102744094329, -1.45130356708867, 0.423326869995222, 
                        1.00184129178658, -0.274834944947866, -0.440595097260665, 1.35142813553237, 0.315900164869998, -0.294651699401438, -0.370132097198894, 0.496349313702549, -0.226596896277442, -0.104028759145169, -0.637167777183922, 0.394407534570096, 1.71388434411996, 0.569464384378371, 0.273119867956328, 0.495723963680827, 1.58471796664639, 1.10428705428811, 0.0705025292608852, 0.0581551416586557, -0.601073871038782, 0.999420758272862, 0.0790342281593581, -2.25967798943669, 1.99673105123202, -0.823381842556792, -0.599098070383608, 
                        0.408813768841476, -0.243731925401658, 0.663227235038111, 1.44844487445903, 1.41576817652291, -0.516096316987547, 0.715478624944588, -1.22764082244222, 0.685219995976105, 0.31686050788835, 0.185280098342666, 0.800377346307535, 1.16305979881659, -0.533134760266663, -1.76623917825358, -0.258171937036433, 2.27848637029746, 0.275856344807224, 0.398538511161473, -0.160716125893234, -0.249568184823623, 0.621695264900701, 1.05565274274202, 0.211895600106171, -0.754164872455831, 0.333080668847607, 0.217589052931011, 
                        0.831294750542266, -0.955272996685697, -1.8730020730219, 0.369947068349585, -1.12368571127792, -0.487950983034668, 0.297814265027974, -2.62506993784291, 1.28827679253414, 1.47079072314504, 1.43031129893689, -1.53403566076964, -0.163367792299685, -0.366654421716994, -0.778978180536605, 0.0744503844496869, -1.10380405050572, -0.465854852726188, 3.0773343158998, 0.0301815205154377, 0.323877338952272, -0.195707404716749, 0.231151829840925, 0.259542621644382, -1.57507371922847, -0.703205527133122, 1.232795357034, 
                        -0.449102551246394, 2.77383081537197, -0.279566430813905, 0.45389938743563, 0.33934061438643, 0.51628182717387, -0.366999824723635, -0.785699118380112, -0.698051591682969, 0.776370905629697, 0.855390349648388, -0.637688810562942, 0.854584769856359, 0.527176864359546, 0.474685257380259, 0.790624022181063, 1.06657588158683, -0.94841688750007, -0.331197653168314, -0.375722985351779, 0.1157575009886, 0.224930191099393, -0.47107525130663, -1.09008507969444, -1.16774430181508, 1.2054236717594, 1.72939487946087, 
                        -0.390567127254116, -1.85501208041234, -0.956500081701428, -7.11274461287603, 4.98869307177774, -0.292231102966412, -1.69848940619675, 1.20333630431499, 2.6296151056374, 0.188322970939403, 0.212368411450115, -0.502981191097529, -1.12783553425846, -0.690239887726474, 0.28727708370555, -1.94787930964582, 1.17414742808286, 1.2672187614692, 1.90451463435677, -0.845884168942224, 0.675584940671659, 1.51192486942744, 0.427664576651221, -1.71963017674255, 0.437420657506848, 0.0862041830870908, 0.394328894221818, 
                        2.0071444777912, -0.317501358450833, 0.522467764487811, -0.376435796619923, 1.09256078140199, -0.144444017464629, -0.673086829890579, -0.615759795473547, -1.54310419317891, -0.162445734317807, 1.04342602990348, 0.481509449913986, -0.258587841524704, -1.06621030456742, -0.89586736446261, 0.7282402953531, -1.53952418048302, -0.687030904721908, 0.402320301275783, 1.78752887648779, 1.81795786246051, -0.0422403896517487, 0.47392235588033, 0.207980158059051, -1.07942292631584, -0.26727735042309, -0.828108167157726, 
                        -3.0112587684612, 1.2341471122248, 1.36519808912423, 0.609406826147652, -0.755503496640575, 1.12748548278496, 1.76180134642561, -0.799220427277003, -0.803582678279202, -0.567523638382461, -0.0668567931554342, 1.2534108028567, 0.867211879348417, 0.818160910172416, -0.530073426607913, 2.11862280725033, 0.471287744540305, 0.089423226188412, -0.334255499129288, 0.884926409718911, -0.170027719886168, 0.814883188865778, 0.0980863434565826, 0.404080485246983, -0.396237732436688, 0.261399664227646, 0.907132809467459, 
                        -0.368867994785305, 0.57503467559572, 0.379280016521832, -0.732830659162254, 1.19029503285866, 0.551740045743632, 0.0638700504550727, -0.15641097302348, 0.411484016486519, -0.446805706758013, -1.17943337448425, 1.97448468514345, -0.320683386774068, 1.12825780132058, 0.395739291368358, 0.135616068372269, -0.122514078722791, 0.992614813298065, 0.109273435206081, 0.468151383421578, 0.388000082209139, 0.8607116044268, -0.328973145036748, 0.917687704971826, -0.337020947922717, -0.102599964510119, -0.488107915510128, 
                        -0.168110261423848, 0.742481831235686, 0.579213348358643, 1.06456556150265, 0.239888464402416, -0.117642878349944, -1.06055419792472, -0.714547179178915, 0.815438090440246, -0.0882739793220289, 0.544612748799977, 0.319453353675758, -1.00113519051375, 1.30443063629793, 0.0828002558022511, 0.268406432245882, 0.342901528169826, -0.974177970710155, -1.04872834324299, -1.94679960453215, -0.13169711571237, 0.872590673342266, 1.55280793332011, 0.828579368135429, 0.0954049656194833, -0.58724588557677, -0.952980073165488, 
                        -0.889072518166323, 1.18007251566059, -0.135453654931528, 0.823427662510579, 0.27476355862559, -0.133260015338088, -0.776249349489788, -0.262807493612183, 0.334034815455908, 0.856155782933143, -0.395756437207506, -0.374813369393401, -1.49243637609322, -0.163750751284564, 0.490450013399624, -0.619627100142406, 0.0146667889161733, 0.205109494121913, -0.964184036108673, 1.11134706168521, 1.72323602837912, 0.166847606409348, 0.240809738012349, -0.549607110860961, -1.60412346475587, 0.388434987945807, 
                        -2.00663947432904, 0.977555599487268, 1.77887772731182, -0.0668630416872595, -0.518347165612809, 0.232319761819078, 1.46491124622044, 1.18898384750681, -0.318280142789806, 0.346522746945599, 0.465733402181367, -0.409272111952497, 1.28988819607878, -0.186494053999908, 0.947158464421261, -0.230969959815841, 1.00990070054872, -0.672708069047001, 0.496795962551921, 0.0738349564777252, 1.0577321303928, -0.235505275933345, 0.778365808693682, 0.232838796908919, -0.22354860945164, -1.62018213052821, -0.0850095579605359, 
                        -2.1122135358473, 0.0920830566481179, 0.56554364548953, -1.49552075794412, -0.446031465035279, 1.56429544209242, -1.96859185900413, -0.737091971430459, -3.69178043373042, 0.86462427148648, 0.755394967659662, -0.0165207335581563, -0.580875152922999, -1.3159307414929, 1.41559116610068, -0.86238973103967, -1.13770488878382, 1.94935403687877, 1.60470656607652, -0.285550788320688, -0.590047655106218, -0.953597918577564, 0.636128595996155, 0.431914618782692, -0.795579840301297, -3.91251625112758, -1.49297608671652, 
                        -7.04375903730208, 3.79028122280358, -0.380906775732104, -0.833363501813089, -0.855767817452868, 4.96459618350586, -1.70081846976169, -2.61897076334039, 2.90280529784823, 2.02677162047324, 0.770053142538796, 0.748865805023691, -2.57819400534025, 0.119668865067801, 0.371824027438006, 0.559041543225547, 3.47982355427554, -2.21650663452504, 0.194493874395452, 0.376414385134627, 0.0314628812106754, -3.09894451495687, -3.05704149182651, 1.63000909057587, -1.41025660334675, -0.402402793210577, -1.42284540459681, 
                        -1.16470758943956, 2.56723790696718, 1.34404929291154, -0.2920940993004, 1.07283327409116, 4.08820605411844, 0.848900725506319, 0.563525356085925, 0.144851223641584, 0.561428004198472, 0.796876307714012, -0.726802166408103, 0.153990483021804, -0.653052852819158, 0.257800961181953, 1.65647560619684, 1.16635946426911, 1.17000615311156, -0.0683933001227821, 0.702399378521079, 1.34784417539642, 0.629491365926782, -0.951922686981987, -0.17179852440643, -0.648224105742656, -0.293032648732883, 0.715877551893662, 
                        0.897604618714887, 0.303271607579347, 0.451879217127083, 0.707855064164242, 0.944674060327433, 2.09722963728032, -0.440284112050993, 0.327445795684422, 0.458978613406913, -2.43649466038125, 0.996198771778722, -0.343486250953973, -1.81878804745077, 2.28642291852905, 0.927076051678011, -0.53354171175668, 0.178445374156055, -1.57294461697708, 0.123526702618548, -2.18931809212579, 1.87763488061679, -0.0765667178670881, 1.54064671966871, 0.67989839654734, 1.23889541690261, 0.060671292289527, 2.05343322428035, 
                        -0.184943082929045, -0.0636277634282756, 1.32292287247564, -0.798794742747777, -0.219408822112754, -0.0919697459966784, 1.34905478406688, 2.18989173234405, -0.205344535525676, 0.421248491139714, -0.883040984542127, -1.94702142792043, -0.413111816301193, -1.8156381029578, 2.53083209776728, 0.700531066299792, 0.36833041458566, -1.7225060479432, -0.810458233390232, 0.714878388599516, 1.47451279665782, -0.732527679705175, 1.77000004652141, 1.12142188421629, -0.520246879805786, -0.868647941791245, 0.79556546929398, 
                        -1.87106737562175, -0.73074295482094, 0.351969821751652, -2.2465181267596, 0.607456093677161, 2.4613870196073, -1.92504847723045, 0.949845328940224, -1.44696145520378, 1.07667282848931, 0.156672755649723, 2.62183723194509, -0.0754918803448135, -1.40777658754505, -0.671624303096774, -0.53878963367211, -0.175389721216934, -0.866087650974912, 0.179357621862675, 1.53094319505644, 2.28628059797416, 0.56758810807942, -0.225554909738257, 0.54545306429068, 0.838845399844068, -0.238401205391803, 0.973930099724374, 
                        -0.0673390392902817, -0.657401952893544, 1.43287449428895, -1.3196717299099, -0.175634602018526, -2.72529224148563, 0.509735449128801, 1.67284189243029, -0.558927756868677, 2.11117109490369, -0.72158785976244, -1.11167229131697, 0.569749108178375, 2.09580723300915, -0.244788887718439, 0.680588535910776, 1.279750286895, 0.324626166752662, 0.759521638043115, -0.650558885848618, -1.59659287479856, -0.421682145917757, -0.291462628498529, -2.26348374037482, 1.28601545049243, 2.26707006037747, 1.68467846254323, 
                        -0.145083927396161, 0.234827428854967, 0.202729572452576, -0.876296736614801, -0.599911218811933, -0.57132130264641, 1.44622400886787, -1.6846782194424, 1.1428439885834, -1.13909030528125, 0.967490410258343, -0.350054355148899, 1.13580680285548, 0.617002189040239, 0.260657061577607, -2.20016563348766, 0.126247080029795, -0.461687210068717, 0.814928601032694, -0.4025260181451, -0.639913465259312, -1.79303536271904, -1.71749267176518, 1.57274325822998, -1.80580816587739, 1.5817614213474, -0.583954511767804, 
                        0.0424862988078978, 0.364638945470031, 2.14754246250486, 0.508589631624279, -1.29647157866764, 0.0993941591025838, -1.20697565883496, -0.707119559041924, 0.0278245816513589, 0.551797821124556, 2.22309911147578, 0.710781890771361, 0.219178986928714, 0.457680304390618, -0.977332650453633, -0.211319928467368, -1.30474057605685, -0.0357266383893773, 1.21210857333756, 1.49846250942298, 1.56087980423356, 0.599202132732302, 0.740215054359705, -0.223074635382936, 0.556039909922035, -0.103215457075301, 0.633379534594258, 
                        -0.298318079628501, -0.396754869357352, 0.330261464411397, 0.815592581372737, 0.64771828770942, -0.787570010908478, -2.19418085384371, 0.158903526773635, -1.33711932080161, -0.296551611599671, -0.678820959885496, 1.11268026136067, 0.187666829262412, -1.80094505880835, -0.922190260535238, -0.0504371860721164, -0.442981144959198, -1.28260071275488, 0.639931318160425, -1.02678790397386, -0.191679330767958, -1.26938813629591, 1.58711370582401, -0.289990165106779, 2.24851809132218, 0.232466391434549, 
                        1.00115605576887, -0.845727864950785, -0.696426210072687, 0.978881585258851, 1.75098936345899, 0.240847193216265, 1.33248368055359, -1.44182102647692, -1.01392606749657, -1.81497260284003, -0.273026871009741, 0.804083563531499, -0.902586329573385, 2.84959591665093, -0.50153556964414, -0.467602722425742, 0.260791214042033, 0.296371154799147, -0.558650309085529, -0.584984618642714, -1.38044433663103, 0.0386883882767641, 1.27662911716744, 0.0082367696933261, -2.11501162587577, 0.223827387388731, -2.32360352850964, 
                        -0.238489109312034, 0.464722959880159, -0.0865325077089807, -1.08447410135186, 1.12424157909734, 0.00779569054625284, 1.68434961259214, -0.249429320208705, 1.83121134942175, -0.587204302441791, 1.3852787414713, -0.0606462210162917, -1.67435234105779, -2.11584171026908, -0.165825251995155, -2.84589880664656, 0.537270334667372, 0.571668654201662, 2.20414686182373, -0.452383944717649, 1.3956269632069, -0.618047033778524, -0.910106688043655, 1.14791342009441, 3.46585662377246, 1.51479404307882, -0.648499724001894, 
                        -0.472268130705444, 0.53206769321914, 0.567420208957614, 0.555461439071792, 0.493587292337061, -0.855494607813601, 0.597356764369383, 0.580780747685772, 1.05130724325742, -0.119693970462098, 1.82491225181787, -0.661304242024663, 1.00365838184304, -0.206537618995561, -0.0745706943600766, -1.15375822416866, 0.881737422329198, -0.0324663869880837, -0.622424073918193, -1.34150533392958, 0.620787915794629, 0.806628381326213, 1.70708565051294, -0.698028129772688, -0.999831806539309, -0.376104671853916, 
                        0.300854781887772, 0.632180927795289, -0.1285192920502, -0.8551033338005, 0.721465937871191, 0.384872531605573, 0.158461338667859, -0.207106501372323, 1.07592778463514, 0.178433319571258, 1.54442957461063, -0.0850643521919103, 0.0384251195220564, 0.397108480441055, 0.0689907231430809, 0.32586642418897, -0.959497456801017, -3.90992268757211, 0.192037981152726, 0.0955246084130223, 2.67299352626784, 1.1127821298329, -1.31486342692311, -0.439597894777588, 1.20962081152154, 1.06147838843596, -0.685551038023835, 
                        0.0522150171256897, -0.712055864526651, -0.291659512656928, -2.80226152948817, 0.604648372905192, -0.422157464623751, -0.394627026319938, -2.78407959631295, 2.49049036709277, 1.05716921142296, -0.0113539597056622, 1.11853647924134, -0.0421150167315254, -0.0091272585639679, 1.21985071366462, -2.1035109710188, 0.362024619907775, -2.11923264857265, 0.203092548903871, 0.867487057124627, -1.03093696588612, 0.0425082771456253, -3.08470706554269, 0.450661558944354, 0.628121466797271, -0.534981306308779, 
                        -1.49400387142782, 1.09570315385721, 1.35350771570346, 0.930218937356919, 0.186167858329167, 1.9642829679662, -1.27766918664625, -2.59652724608896, 0.814016073205703, 2.52795764786162, -0.473405824136997, -0.824134020465017, -1.78437486671719, 2.39826272135319, 4.65458094686992, 0.410546123246025, -0.536785377086879, 2.52445197011912, 0.452161557943587, 1.764252379055, 0.00720175723190053, -0.235963561367836, -1.06413810652422, 0.0523829270163034, -1.37498662078688, 0.713882154487955, 0.491921579095056, 
                        -0.749162033511031, -0.493612886495143, 0.934858299625319, 0.994808862928309, -0.787210145746275, -0.257566572235568, -2.25229889053438, -1.83381576485111, -6.00451339356312, 3.25481958159068, 2.82602651521948, -0.985689801946332, 0.494059376538658, -0.326770294956891, 3.27343229552959, -1.11965722183163, 0.268634535128331, -0.856261765791722, 1.0833199608955, -1.50695585416871, -2.18014569026161, -0.391550663626017, 1.62272225855578, -0.592272803869598, -0.84829035891465, -2.0815078978587, 1.77441001293257, 
                        0.929739407967478, 2.18571200283186, 0.93750686654559, -1.25197253449274, -0.73414286700455, -2.12794933087475, -0.443785076218628, -1.9362093812437, 1.81691385353577, -1.26090925645679, -0.253665602003572, 3.1733050741467, -0.130141943413609, 1.96632122456162, 1.94464907284591, -0.654016572837968, -0.669296663160601, 0.923125495696286, -0.660752549747823, -0.323440812083486, -0.754408579773891, 1.60802520923271, 0.0748304445152392, 0.555393100834234, -0.969703744588823, 1.46013724590608, -0.678609602982227, 
                        0.215222682803962, -1.83882014322982, -0.739551209776845, 0.954857278525978, -0.327614149165001, 0.293938677304251, -0.858072163706058, 0.842948874499339, 1.02184779109757, -1.5989256086911, 0.719283820392214, 1.51455594242966, -0.222032773343539, 0.355826521214109, 0.80974280629702, 0.195398822860593, 0.940848374513603, 0.0337695792274495, -1.1151059383673, -0.791750615826903, 0.914186912404169, -1.03369471657757, -1.07999745605136, 0.69281198321649, -1.50674724118112, -0.192967765354979, -2.07220492970084, 
                        0.767529165005598, 0.506810243625555, 0.0417130150653477, 0.958758891942413, 0.711375702306238, 1.11412487293876, 0.234966956171601, -0.671931397004322, -0.860522438611522, 0.79056648084288, 1.33092333752645, -0.47916919359583, -0.309012889773985, 1.09009386131733, -0.291185329196253, 0.51885647292309, -0.0900717632561054, 0.521954515440726, 0.155260989029937, -0.123392922554366, 0.505870890147797, -0.281091347905171, -0.481339914807499, 0.999256726248099, 0.203393247560246, -0.904278170185613, -0.988895576927717, 
                        0.685199491249922, -0.534534023726518, -0.351235044841669, -0.489357308063631, 0.196838514463238, -0.272441145255531, -1.02217622054122, -1.46378269886158, 1.05977765129452, -0.588067261283864, -0.157909831150516, -0.0227761348503108, -0.671113245205213, -0.82477859533796, -0.0448527924878483, 2.19915547936358, -1.5047955636871, -0.0194935845838629, -0.682577431225084, 0.549501868571944, 0.13655683861078, -1.91833020318644, -0.495194927296083, -1.07636255469137, -1.63035436218388, -2.58405022000643, 
                        3.28363974756174, 0.0327416793585833, -1.80949593055049, -0.582446578056572, 3.41533584652165, 0.586570898061645, -0.0823572848595688, 0.168223067614104, -2.40544635939983, -0.0337077831531474, 1.10350169713458, 1.37355303905213, 2.17401403933923, -0.573911812333261, 0.498327076850646, -0.114185251687626, 0.384766536924097, -0.0223459006677196, -1.59023466225339, -0.650670405052267, -2.47001118685661, -1.08346292540409, 2.31814082401867, 0.494814841297497, -1.26643088921261, -0.335761837166348, -1.85221910072118, 
                        0.351677146951612, -1.8721681317297, 1.45716188368565, 0.535170041283095, -0.959390016802875, 0.436143812028256, -2.03102341421051, 0.0212913185452912, 0.737826239382144, 3.81832867140215, -1.83876148344355, -0.58701249448383, 1.94150800384811, 0.749797155870624, -0.655673321365313, -0.819433621096, -1.41139436935269, -2.16963898311269, 0.803832951087013, -1.30426375382617, -3.17961377699838, 0.796980120220692, 2.40943766222239, 0.705039660239404, 1.0385440398915, 0.398026915379734, -1.05030161213815, 
                        -2.84323275514282))
package:MASS
TRUE
FALSE
stdres
list(`package:MASS` = function (object) 
  lmwork(object)$stdres, function (object) 
    lmwork(object)$stdres)
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
steam
list(`package:MASS` = list(Temp = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 85, 90, 95, 100, 105), Press = c(4.14, 8.52, 16.31, 32.18, 64.62, 98.76, 151.13, 224.74, 341.35, 423.36, 522.78, 674.32, 782.04, 920.01)))
package:MASS
TRUE
FALSE
stepAIC
list(`package:MASS` = function (object, scope, scale = 0, direction = c("both", "backward", "forward"), trace = 1, keep = NULL, steps = 1000, use.start = FALSE, k = 2, ...) 
{
  mydeviance <- function(x, ...) {
    dev <- deviance(x)
    if (!is.null(dev)) 
      dev
    else extractAIC(x, k = 0)[2]
  }
  cut.string <- function(string) {
    if (length(string) > 1) 
      string[-1] <- paste("\n", string[-1], sep = "")
    string
  }
  re.arrange <- function(keep) {
    namr <- names(k1 <- keep[[1]])
    namc <- names(keep)
    nc <- length(keep)
    nr <- length(k1)
    array(unlist(keep, recursive = FALSE), c(nr, nc), list(namr, namc))
  }
  step.results <- function(models, fit, object, usingCp = FALSE) {
    change <- sapply(models, "[[", "change")
    rd <- sapply(models, "[[", "deviance")
    dd <- c(NA, abs(diff(rd)))
    rdf <- sapply(models, "[[", "df.resid")
    ddf <- c(NA, abs(diff(rdf)))
    AIC <- sapply(models, "[[", "AIC")
    heading <- c("Stepwise Model Path \nAnalysis of Deviance Table", "\nInitial Model:", deparse(formula(object)), "\nFinal Model:", deparse(formula(fit)), "\n")
    aod <- if (usingCp) 
      data.frame(Step = change, Df = ddf, Deviance = dd, `Resid. Df` = rdf, `Resid. Dev` = rd, Cp = AIC, check.names = FALSE)
    else data.frame(Step = change, Df = ddf, Deviance = dd, `Resid. Df` = rdf, `Resid. Dev` = rd, AIC = AIC, check.names = FALSE)
    attr(aod, "heading") <- heading
    class(aod) <- c("Anova", "data.frame")
    fit$anova <- aod
    fit
  }
  Terms <- terms(object)
  object$formula <- Terms
  if (inherits(object, "lme")) 
    object$call$fixed <- Terms
  else if (inherits(object, "gls")) 
    object$call$model <- Terms
  else object$call$formula <- Terms
  if (use.start) 
    warning("'use.start' cannot be used with R's version of 'glm'")
  md <- missing(direction)
  direction <- match.arg(direction)
  backward <- direction == "both" | direction == "backward"
  forward <- direction == "both" | direction == "forward"
  if (missing(scope)) {
    fdrop <- numeric()
    fadd <- attr(Terms, "factors")
    if (md) 
      forward <- FALSE
  }
  else {
    if (is.list(scope)) {
      fdrop <- if (!is.null(fdrop <- scope$lower)) 
        attr(terms(update.formula(object, fdrop)), "factors")
      else numeric()
      fadd <- if (!is.null(fadd <- scope$upper)) 
        attr(terms(update.formula(object, fadd)), "factors")
    }
    else {
      fadd <- if (!is.null(fadd <- scope)) 
        attr(terms(update.formula(object, scope)), "factors")
      fdrop <- numeric()
    }
  }
  models <- vector("list", steps)
  if (!is.null(keep)) 
    keep.list <- vector("list", steps)
  n <- nobs(object, use.fallback = TRUE)
  fit <- object
  bAIC <- extractAIC(fit, scale, k = k, ...)
  edf <- bAIC[1]
  bAIC <- bAIC[2]
  if (is.na(bAIC)) 
    stop("AIC is not defined for this model, so 'stepAIC' cannot proceed")
  if (bAIC == -Inf) 
    stop("AIC is -infinity for this model, so 'stepAIC' cannot proceed")
  nm <- 1
  Terms <- terms(fit)
  if (trace) {
    cat("Start:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), "\n\n", sep = "")
    utils::flush.console()
  }
  models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - edf, change = "", AIC = bAIC)
  if (!is.null(keep)) 
    keep.list[[nm]] <- keep(fit, bAIC)
  usingCp <- FALSE
  while (steps > 0) {
    steps <- steps - 1
    AIC <- bAIC
    ffac <- attr(Terms, "factors")
    if (!is.null(sp <- attr(Terms, "specials")) && !is.null(st <- sp$strata)) 
      ffac <- ffac[-st, ]
    scope <- factor.scope(ffac, list(add = fadd, drop = fdrop))
    aod <- NULL
    change <- NULL
    if (backward && length(scope$drop)) {
      aod <- dropterm(fit, scope$drop, scale = scale, trace = max(0, trace - 1), k = k, ...)
      rn <- row.names(aod)
      row.names(aod) <- c(rn[1], paste("-", rn[-1], sep = " "))
      if (any(aod$Df == 0, na.rm = TRUE)) {
        zdf <- aod$Df == 0 & !is.na(aod$Df)
        nc <- match(c("Cp", "AIC"), names(aod))
        nc <- nc[!is.na(nc)][1]
        ch <- abs(aod[zdf, nc] - aod[1, nc]) > 0.01
        if (any(is.finite(ch) & ch)) {
          warning("0 df terms are changing AIC")
          zdf <- zdf[!ch]
        }
        if (length(zdf) > 0) 
          change <- rev(rownames(aod)[zdf])[1]
      }
    }
    if (is.null(change)) {
      if (forward && length(scope$add)) {
        aodf <- addterm(fit, scope$add, scale = scale, trace = max(0, trace - 1), k = k, ...)
        rn <- row.names(aodf)
        row.names(aodf) <- c(rn[1], paste("+", rn[-1], sep = " "))
        aod <- if (is.null(aod)) 
          aodf
        else rbind(aod, aodf[-1, , drop = FALSE])
      }
      attr(aod, "heading") <- NULL
      if (is.null(aod) || ncol(aod) == 0) 
        break
      nzdf <- if (!is.null(aod$Df)) 
        aod$Df != 0 | is.na(aod$Df)
      aod <- aod[nzdf, ]
      if (is.null(aod) || ncol(aod) == 0) 
        break
      nc <- match(c("Cp", "AIC"), names(aod))
      nc <- nc[!is.na(nc)][1]
      o <- order(aod[, nc])
      if (trace) {
        print(aod[o, ])
        utils::flush.console()
      }
      if (o[1] == 1) 
        break
      change <- rownames(aod)[o[1]]
    }
    usingCp <- match("Cp", names(aod), 0) > 0
    fit <- update(fit, paste("~ .", change), evaluate = FALSE)
    fit <- eval.parent(fit)
    nnew <- nobs(fit, use.fallback = TRUE)
    if (all(is.finite(c(n, nnew))) && nnew != n) 
      stop("number of rows in use has changed: remove missing values?")
    Terms <- terms(fit)
    bAIC <- extractAIC(fit, scale, k = k, ...)
    edf <- bAIC[1]
    bAIC <- bAIC[2]
    if (trace) {
      cat("\nStep:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), "\n\n", sep = "")
      utils::flush.console()
    }
    if (bAIC >= AIC + 1e-07) 
      break
    nm <- nm + 1
    models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - edf, change = change, AIC = bAIC)
    if (!is.null(keep)) 
      keep.list[[nm]] <- keep(fit, bAIC)
  }
  if (!is.null(keep)) 
    fit$keep <- re.arrange(keep.list[seq(nm)])
  step.results(models = models[seq(nm)], fit, object, usingCp)
}, function (object, scope, scale = 0, direction = c("both", "backward", "forward"), trace = 1, keep = NULL, steps = 1000, use.start = FALSE, k = 2, ...) 
{
  mydeviance <- function(x, ...) {
    dev <- deviance(x)
    if (!is.null(dev)) 
      dev
    else extractAIC(x, k = 0)[2]
  }
  cut.string <- function(string) {
    if (length(string) > 1) 
      string[-1] <- paste("\n", string[-1], sep = "")
    string
  }
  re.arrange <- function(keep) {
    namr <- names(k1 <- keep[[1]])
    namc <- names(keep)
    nc <- length(keep)
    nr <- length(k1)
    array(unlist(keep, recursive = FALSE), c(nr, nc), list(namr, namc))
  }
  step.results <- function(models, fit, object, usingCp = FALSE) {
    change <- sapply(models, "[[", "change")
    rd <- sapply(models, "[[", "deviance")
    dd <- c(NA, abs(diff(rd)))
    rdf <- sapply(models, "[[", "df.resid")
    ddf <- c(NA, abs(diff(rdf)))
    AIC <- sapply(models, "[[", "AIC")
    heading <- c("Stepwise Model Path \nAnalysis of Deviance Table", "\nInitial Model:", deparse(formula(object)), "\nFinal Model:", deparse(formula(fit)), "\n")
    aod <- if (usingCp) 
      data.frame(Step = change, Df = ddf, Deviance = dd, `Resid. Df` = rdf, `Resid. Dev` = rd, Cp = AIC, check.names = FALSE)
    else data.frame(Step = change, Df = ddf, Deviance = dd, `Resid. Df` = rdf, `Resid. Dev` = rd, AIC = AIC, check.names = FALSE)
    attr(aod, "heading") <- heading
    class(aod) <- c("Anova", "data.frame")
    fit$anova <- aod
    fit
  }
  Terms <- terms(object)
  object$formula <- Terms
  if (inherits(object, "lme")) 
    object$call$fixed <- Terms
  else if (inherits(object, "gls")) 
    object$call$model <- Terms
  else object$call$formula <- Terms
  if (use.start) 
    warning("'use.start' cannot be used with R's version of 'glm'")
  md <- missing(direction)
  direction <- match.arg(direction)
  backward <- direction == "both" | direction == "backward"
  forward <- direction == "both" | direction == "forward"
  if (missing(scope)) {
    fdrop <- numeric()
    fadd <- attr(Terms, "factors")
    if (md) 
      forward <- FALSE
  }
  else {
    if (is.list(scope)) {
      fdrop <- if (!is.null(fdrop <- scope$lower)) 
        attr(terms(update.formula(object, fdrop)), "factors")
      else numeric()
      fadd <- if (!is.null(fadd <- scope$upper)) 
        attr(terms(update.formula(object, fadd)), "factors")
    }
    else {
      fadd <- if (!is.null(fadd <- scope)) 
        attr(terms(update.formula(object, scope)), "factors")
      fdrop <- numeric()
    }
  }
  models <- vector("list", steps)
  if (!is.null(keep)) 
    keep.list <- vector("list", steps)
  n <- nobs(object, use.fallback = TRUE)
  fit <- object
  bAIC <- extractAIC(fit, scale, k = k, ...)
  edf <- bAIC[1]
  bAIC <- bAIC[2]
  if (is.na(bAIC)) 
    stop("AIC is not defined for this model, so 'stepAIC' cannot proceed")
  if (bAIC == -Inf) 
    stop("AIC is -infinity for this model, so 'stepAIC' cannot proceed")
  nm <- 1
  Terms <- terms(fit)
  if (trace) {
    cat("Start:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), "\n\n", sep = "")
    utils::flush.console()
  }
  models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - edf, change = "", AIC = bAIC)
  if (!is.null(keep)) 
    keep.list[[nm]] <- keep(fit, bAIC)
  usingCp <- FALSE
  while (steps > 0) {
    steps <- steps - 1
    AIC <- bAIC
    ffac <- attr(Terms, "factors")
    if (!is.null(sp <- attr(Terms, "specials")) && !is.null(st <- sp$strata)) 
      ffac <- ffac[-st, ]
    scope <- factor.scope(ffac, list(add = fadd, drop = fdrop))
    aod <- NULL
    change <- NULL
    if (backward && length(scope$drop)) {
      aod <- dropterm(fit, scope$drop, scale = scale, trace = max(0, trace - 1), k = k, ...)
      rn <- row.names(aod)
      row.names(aod) <- c(rn[1], paste("-", rn[-1], sep = " "))
      if (any(aod$Df == 0, na.rm = TRUE)) {
        zdf <- aod$Df == 0 & !is.na(aod$Df)
        nc <- match(c("Cp", "AIC"), names(aod))
        nc <- nc[!is.na(nc)][1]
        ch <- abs(aod[zdf, nc] - aod[1, nc]) > 0.01
        if (any(is.finite(ch) & ch)) {
          warning("0 df terms are changing AIC")
          zdf <- zdf[!ch]
        }
        if (length(zdf) > 0) 
          change <- rev(rownames(aod)[zdf])[1]
      }
    }
    if (is.null(change)) {
      if (forward && length(scope$add)) {
        aodf <- addterm(fit, scope$add, scale = scale, trace = max(0, trace - 1), k = k, ...)
        rn <- row.names(aodf)
        row.names(aodf) <- c(rn[1], paste("+", rn[-1], sep = " "))
        aod <- if (is.null(aod)) 
          aodf
        else rbind(aod, aodf[-1, , drop = FALSE])
      }
      attr(aod, "heading") <- NULL
      if (is.null(aod) || ncol(aod) == 0) 
        break
      nzdf <- if (!is.null(aod$Df)) 
        aod$Df != 0 | is.na(aod$Df)
      aod <- aod[nzdf, ]
      if (is.null(aod) || ncol(aod) == 0) 
        break
      nc <- match(c("Cp", "AIC"), names(aod))
      nc <- nc[!is.na(nc)][1]
      o <- order(aod[, nc])
      if (trace) {
        print(aod[o, ])
        utils::flush.console()
      }
      if (o[1] == 1) 
        break
      change <- rownames(aod)[o[1]]
    }
    usingCp <- match("Cp", names(aod), 0) > 0
    fit <- update(fit, paste("~ .", change), evaluate = FALSE)
    fit <- eval.parent(fit)
    nnew <- nobs(fit, use.fallback = TRUE)
    if (all(is.finite(c(n, nnew))) && nnew != n) 
      stop("number of rows in use has changed: remove missing values?")
    Terms <- terms(fit)
    bAIC <- extractAIC(fit, scale, k = k, ...)
    edf <- bAIC[1]
    bAIC <- bAIC[2]
    if (trace) {
      cat("\nStep:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), "\n\n", sep = "")
      utils::flush.console()
    }
    if (bAIC >= AIC + 1e-07) 
      break
    nm <- nm + 1
    models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - edf, change = change, AIC = bAIC)
    if (!is.null(keep)) 
      keep.list[[nm]] <- keep(fit, bAIC)
  }
  if (!is.null(keep)) 
    fit$keep <- re.arrange(keep.list[seq(nm)])
  step.results(models = models[seq(nm)], fit, object, usingCp)
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
stormer
list(`package:MASS` = list(Viscosity = c(14.7, 27.5, 42, 75.7, 89.7, 146.6, 158.3, 14.7, 27.5, 42, 75.7, 89.7, 146.6, 158.3, 161.1, 298.3, 75.7, 89.7, 146.6, 158.3, 161.1, 298.3, 298.3), Wt = c(20, 20, 20, 20, 20, 20, 20, 50, 50, 50, 50, 50, 50, 50, 50, 50, 100, 100, 100, 100, 100, 100, 100), Time = c(35.6, 54.3, 75.6, 121.2, 150.8, 229, 270, 17.6, 24.3, 31.4, 47.2, 58.3, 85.6, 101.1, 92.2, 187.2, 24.6, 30, 41.7, 50.3, 45.1, 89, 86.5)))
package:MASS
TRUE
FALSE
studres
list(`package:MASS` = function (object) 
  lmwork(object)$studres, function (object) 
    lmwork(object)$studres)
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
survey
list(`package:MASS` = list(Sex = c(1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 2, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, NA, 2, 2, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 2, 1, 1, 2, 2, 
                                   2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 2, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 1), Wr.Hnd = c(18.5, 19.5, 18, 18.8, 20, 18, 17.7, 17, 20, 18.5, 17, 21, 16, 19.5, 16, 17.5, 18, 19.4, 20.5, 21, 21.5, 20.1, 18.5, 21.5, 17, 18.5, 21, 20.8, 17.8, 19.5, 18.5, 18.8, 17.1, 20.1, 18, 22.2, 16, 19.4, 22, 19, 17.5, 17.8, NA, 20.1, 13, 17, 23.2, 22.5, 
                                                                                                                                                                                                                                                                                                     18, 18, 22, 20.5, 17, 20.5, 22.5, 18.5, 15.5, 19.5, 19.5, 20.6, 22.8, 18.5, 19.6, 18.7, 17.3, 19.5, 19, 18.5, 19, 21, 18, 19.4, 17, 16.5, 15.6, 17.5, 17, 18.6, 18.3, 20, 19.5, 19.2, 17.5, 17, 23, 17.7, 18.2, 18.3, 18, 18, 20.5, 17.5, 18.2, 18.2, 21.3, 19, 20, 17.5, 19.5, 19.4, 21.9, 18.9, 16, 17.5, 17.5, 19.5, 16.2, 17, 17.5, 19.7, 18.5, 19.2, 17.2, 20.5, 16, 16.9, 17, 23, 18.5, 21, 20, 22.5, 18.5, 19.8, 18.5, 19.3, 16, 18.8, 17.5, 16.4, 22, 19, 18.9, 15.4, 17.9, 23.1, 19.8, 22, 20, 19.5, 18, 18.3, 
                                                                                                                                                                                                                                                                                                     19, 21.4, 20, 18.5, 22.5, 19.5, 18, 18, 21.8, 13, 16.3, 21.5, 18.9, 20.5, 14, 18.9, 20, 18.5, 17.5, 18.1, 20.2, 16.5, 19.1, 17.6, 19.5, 16.5, 19, 19, 16.5, 20.5, 15.5, 18, 17.5, 19, 20.5, 16.7, 20.5, 17, 19, 14, 17.5, 18.5, 18, 20.5, 17, 18.5, 18, 18.5, 20, 22, 17.9, 17.6, 16.7, 17, 15, 16, 19.1, 17.5, 16.2, 21, 18.8, 18.5, 17, 17.5, 17.5, 17.5, 17.5, 20.8, 18.6, 17.5, 18, 17, 18, 19.5, 16.3, 18.2, 17, 23.2, 23.2, 15.9, 17.5, 17.5, 17.6, 17.5, 18.8, 20, 18.6, 18.6, 18.8, 18, 18, 18.5, 17.5, 21, 17.6
                                   ), NW.Hnd = c(18, 20.5, 13.3, 18.9, 20, 17.7, 17.7, 17.3, 19.5, 18.5, 17.2, 21, 16, 20.2, 15.5, 17, 18, 19.2, 20.5, 20.9, 22, 20.7, 18, 21.2, 17.5, 18.5, 20.7, 21.4, 17.8, 19.5, 18, 18.2, 17.5, 20, 19, 21, 16.5, 18.5, 22, 19, 16, 18, NA, 20.2, 13, 17.5, 22.7, 23, 17.6, 17.9, 21.5, 20, 18, 19.5, 22.5, 18.5, 15.4, 19.7, 19, 21, 23.2, 18.2, 19.7, 18, 18, 19.8, 19.1, 18, 19, 19.5, 17.5, 19.5, 16.6, 17, 15.8, 17.5, 17.6, 18, 18.5, 20.5, 19.5, 18.9, 17.5, 17.4, 23.5, 17, 18, 18.5, 18, 17.7, 20, 18, 17.5, 
                                                 18.5, 20.8, 18.8, 19.5, 17.5, 19.4, 19.6, 22.2, 19.1, 16, 17.3, 17, 18.5, 16.4, 15.9, 17.5, 20.1, 18.5, 19.6, 16.7, 21, 15.5, 16, 16.7, 22, 18, 20.4, 20, 22.5, 18, 20, 18.1, 19.4, 16, 19.1, 17, 16.5, 21.5, 19.5, 20, 16.4, 17.8, 22.5, 19, 22, 19.5, 18.5, 18.6, 19, 18.8, 21, 19.5, 18.5, 22.6, 20.2, 18, 18.5, 22.3, 12.5, 16.2, 21.6, 19.1, 20, 15.5, 19.2, 20.5, 19, 17.1, 18.2, 20.3, 16.9, 19.1, 17.2, 19.2, 15, 18.5, 18.5, 17, 19.5, 15.5, 17.5, 18, 18.5, 20.5, 17, 20.5, 16.5, 19.5, 13.5, 17.6, 19, 18.5, 
                                                 20.7, 17, 18.5, 18.5, 18, 19.5, 22.5, 18.4, 17.8, 15.1, 17.6, 13, 15.5, 19, 16.5, 15.8, 21, 17.8, 18, 17.5, 17, 17.6, 17.6, 17, 20.7, 18.6, 17.5, 18.5, 17.5, 17.8, 20, 16.2, 19.8, 17.3, 23.2, 23.3, 16.5, 18.4, 17.6, 17.2, 17.8, 18.3, 19.8, 18.8, 19.6, 18.5, 16, 18, 18, 16.5, 21.5, 17.3), W.Hnd = c(2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, NA, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
                                                                                                                                                                                                                                                                                                                                                            2, 2, 2), Fold = c(3, 3, 1, 3, 2, 1, 1, 3, 3, 3, 1, 3, 1, 1, 3, 3, 1, 3, 1, 3, 3, 1, 1, 3, 3, 2, 3, 3, 1, 1, 3, 1, 3, 3, 1, 1, 1, 3, 3, 3, 1, 3, 3, 1, 1, 3, 1, 3, 3, 3, 3, 1, 1, 1, 3, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 2, 1, 3, 1, 1, 1, 3, 3, 1, 3, 2, 1, 1, 3, 1, 3, 3, 3, 3, 1, 3, 1, 3, 2, 3, 3, 2, 1, 3, 3, 1, 3, 3, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 1, 3, 3, 1, 3, 3, 1, 1, 3, 1, 1, 1, 3, 1, 3, 1, 1, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 3, 3, 3, 1, 3, 3, 1, 3, 1, 3, 3, 1, 1, 3, 1, 3, 1, 1, 3, 1, 3, 
                                                                                                                                                                                                                                                                                                                                                                               2, 1, 3, 2, 3, 3, 1, 1, 3, 1, 1, 2, 3, 3, 1, 2, 1, 3, 3, 3, 3, 1, 1, 2, 3, 1, 3, 3, 2, 3, 1, 3, 1, 2, 1, 3, 2, 3, 3, 3, 1, 3, 2, 3, 3, 1, 3, 1, 3, 1, 3, 3, 3, 1, 2, 1, 3, 1, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 1, 3, 3, 1, 1, 3, 3, 3), Pulse = c(92, 104, 87, NA, 35, 64, 83, 74, 72, 90, 80, 68, NA, 66, 60, NA, 89, 74, NA, 78, 72, 72, 64, 62, 64, 90, 90, 62, 76, 79, 76, 78, 72, 70, 54, 66, NA, 72, 80, NA, NA, 72, 60, 80, 70, NA, 84, 96, 60, 50, 55, 68, 78, 56, 65, NA, 70, 72, 62, NA, 66, 72, 70, NA, 64, NA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              NA, 64, NA, 80, 64, NA, 68, 40, 88, 68, 76, NA, 68, NA, 66, 76, 98, NA, 90, 76, 70, 75, 60, 92, 75, NA, 70, NA, 65, NA, 68, 60, NA, 68, NA, 60, NA, 72, 80, 80, NA, 85, 64, 67, 76, 80, 75, 60, 60, 70, 70, 83, 100, 100, 80, 76, 92, 59, 66, NA, 68, 66, 74, 90, 86, 60, 86, 80, 85, 90, 73, 72, NA, 68, 84, NA, 65, 96, 68, 75, 64, 60, 92, 64, 76, 80, 92, 69, 68, 76, NA, 74, NA, 84, 80, NA, 72, 60, NA, 81, 70, 65, NA, 72, NA, 80, 50, 48, 68, 104, 76, 84, NA, 70, 68, 87, 79, 70, 90, 72, 79, 65, 62, 63, 92, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              60, 68, 72, NA, 76, 80, 71, 80, 80, 61, 48, 76, 86, 80, 83, 76, 84, 97, NA, 74, 83, 78, 65, 68, NA, NA, 88, NA, 75, NA, 70, 88, NA, NA, 96, 80, 68, 70, 71, 80, NA, 85, 88, NA, 90, 85), Clap = c(1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 1, 3, 2, 3, 3, 2, 3, 1, 3, 1, 3, 3, 3, 1, 2, 3, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 2, 3, 2, 3, 3, NA, 3, 1, 2, 1, 3, 3, 1, 1, 3, 1, 3, 3, 2, 2, 3, 3, 1, 2, 2, 3, 1, 2, 3, 2, 3, 3, 1, 1, 3, 3, 1, 1, 3, 3, 2, 2, 3, 1, 3, 1, 2, 3, 3, 3, 1, 3, 1, 1, 3, 3, 3, 3, 3, 2, 3, 3, 2, 3, 2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                3, 3, 1, 3, 3, 3, 2, 1, 1, 3, 3, 3, 1, 3, 3, 1, 2, 3, 2, 3, 3, 3, 1, 3, 3, 2, 3, 3, 3, 3, 3, 1, 1, 3, 2, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 2, 1, 3, 3, 3, 3, 3, 2, 3, 3, 3, 1, 3, 2, 2, 3, 1, 3, 3, 2, 3, 3, 3, 3, 2, 2, 1, 3, 1, 1, 3, 3, 2, 3, 1, 3, 3, 3, 3, 3, 2, 3, 3, 1, 1, 3, 3, 2, 3, 3, 2, 3, 2, 3, 3, 3, 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3), Exer = c(3, 2, 2, 2, 3, 3, 1, 1, 3, 3, 1, 1, 3, 3, 3, 1, 1, 3, 3, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               3, 2, 1, 1, 3, 3, 1, 3, 1, 3, 1, 3, 3, 3, 3, 1, 1, 1, 2, 3, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 3, 2, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 3, 1, 3, 3, 1, 1, 3, 3, 3, 3, 3, 1, 3, 1, 1, 1, 1, 3, 2, 3, 1, 3, 3, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 3, 1, 3, 3, 1, 1, 1, 2, 3, 2, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 3, 1, 2, 1, 1, 3, 2, 1, 2, 3, 3, 1, 3, 3, 3, 3, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 3, 3, 3, 2, 1, 1, 3, 3, 2, 3, 2, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               1, 1, 3, 3, 3, 1, 3, 2, 3, 1, 3, 3, 2, 1, 3, 3, 1, 3, 3, 3, 2, 1, 1, 1, 2, 1, 3, 1, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 3, 1), Smoke = c(2, 4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 1, 2, 4, 3, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 4, 2, 3, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, NA, 2, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 4, 2, 2, 2, 2, 2, 2, 2, 1, 2, 3, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 3, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 3, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 4, 2, 2, 2, 1, 2, 2, 4, 2, 2, 2, 3, 2, 2, 2, 4, 2, 2, 2, 3, 4, 2, 2, 2, 4, 2, 4, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 3, 2, 2, 2, 4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 4, 3, 2, 2, 2, 2, 2, 2, 2), Height = c(173, 177.8, NA, 160, 165, 172.72, 182.88, 157, 175, 167, 156.2, NA, 155, 155, NA, 156, 157, 182.88, 190.5, 177, 190.5, 180.34, 180.34, 184, NA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          NA, 172.72, 175.26, NA, 167, NA, 180, 166.4, 180, NA, 190, 168, 182.5, 185, 171, 169, 154.94, 172, 176.5, 180.34, 180.34, 180, 170, 168, 165, 200, 190, 170.18, 179, 182, 171, 157.48, NA, 177.8, 175.26, 187, 167.64, 178, 170, 164, 183, 172, NA, 180, NA, 170, 176, 171, 167.64, 165, 170, 165, 165.1, 165.1, 185.42, NA, 176.5, NA, NA, 167.64, 167, 162.56, 170, 179, NA, 183, NA, 165, 168, 179, NA, 190, 166.5, 165, 175.26, 187, 170, 159, 175, 163, 170, 172, NA, 180, 180.34, 175, 190.5, 170.18, 185, 162.56, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          158, 159, 193.04, 171, 184, NA, 177, 172, 180, 175.26, 180.34, 172.72, 178.5, 157, 152, 187.96, 178, NA, 160.02, 175.26, 189, 172, 182.88, 170, 167, 175, 165, 172.72, 180, 172, 185, 187.96, 185.42, 165, 164, 195, 165, 152.4, 172.72, 180.34, 173, NA, 167.64, 187.96, 187, 167, 168, 191.8, 169.2, 177, 168, 170, 160.02, 189, 180.34, 168, 182.88, NA, 165, 157.48, 170, 172.72, 164, NA, 162.56, 172, 165.1, 162.5, 170, 175, 168, 163, 165, 173, 196, 179.1, 180, 176, 160.02, 157.48, 165, 170.18, 154.94, 170, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          164, 167, 174, NA, 160, 179.1, 168, 153.5, 160, 165, 171.5, 160, 163, NA, 165, 168.9, 170, NA, 185, 173, 188, 171, 167.64, 162.56, 150, NA, NA, 170.18, 185, 167, 185, 169, 180.34, 165.1, 160, 170, 183, 168.5), M.I = c(2, 1, NA, 2, 2, 1, 1, 2, 2, 2, 1, NA, 2, 2, NA, 2, 2, 1, 1, 2, 1, 1, 1, 2, NA, NA, 1, 1, NA, 2, NA, 2, 1, 2, NA, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, NA, 1, 1, 2, 1, 2, 2, 2, 2, 2, NA, 2, NA, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, NA, 1, NA, NA, 1, 2, 1, 2, 2, NA, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2, NA, 2, 2, 2, NA, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, NA, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, NA, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, NA, 1, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 2, NA, 1, 1, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 1, NA, 2, 1, 2, 1, 2, NA, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, NA, 2, 2, 2, 2, 2, 2, 2, 2, 2, NA, 2, 1, 2, NA, 2, 2, 2, 2, 1, 1, 2, NA, NA, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2), Age = c(18.25, 17.583, 16.917, 20.333, 23.667, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   21, 18.833, 35.833, 19, 22.333, 28.5, 18.25, 18.75, 17.5, 17.167, 17.167, 19.333, 18.333, 19.75, 17.917, 17.917, 18.167, 17.833, 18.25, 19.167, 17.583, 17.5, 18.083, 21.917, 19.25, 41.583, 17.5, 39.75, 17.167, 17.75, 18, 19, 17.917, 35.5, 19.917, 17.5, 17.083, 28.583, 17.5, 17.417, 18.5, 18.917, 19.417, 18.417, 30.75, 18.5, 17.5, 18.333, 17.417, 20, 18.333, 17.167, 17.417, 17.667, 18.417, 20.333, 17.333, 17.5, 19.833, 18.583, 18, 30.667, 16.917, 19.917, 18.333, 17.583, 17.833, 17.667, 17.417, 17.75, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   20.667, 23.583, 17.167, 17.083, 18.75, 16.75, 20.167, 17.667, 17.167, 17.167, 17.25, 18, 18.75, 21.583, 17.583, 19.667, 18, 19.667, 17.083, 22.833, 17.083, 19.417, 23.25, 18.083, 19.083, 18.917, 17.75, 20.833, 20.167, 17.667, 18.25, 17, 18.5, 18.583, 17.75, 24.167, 18.167, 21.167, 17.917, 17.417, 20.5, 22.917, 18.917, 18.917, 20.083, 17.5, 18.25, 17.5, 17.417, 21, 19.833, 17.667, 18.083, 18, 18.333, 20, 18.75, 19.083, 18.5, 18.417, 19.167, 21.5, 19.333, 21.417, 18.667, 17.5, 21.083, 17.25, 19, 19.167, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   19, 23, 32.667, 20, 20.167, 25.5, 18.167, 23.5, 70.417, 43.833, 23.583, 21.083, 44.25, 19.667, 17.917, 18.417, 21.167, 17.5, 29.083, 19.917, 18.5, 18.167, 32.75, 17.417, 17.333, 73, 18.667, 18.5, 18.667, 17.75, 17.25, 36.583, 23.083, 19.25, 17.167, 23.417, 17.083, 17.25, 23.833, 18.75, 21.167, 24.667, 18.5, 20.333, 20.083, 18.917, 27.333, 18.917, 17.25, 18.167, 26.5, 17, 17.167, 19.167, 17.5, 19.25, 21.333, 18.583, 20.167, 18.667, 17.083, 17.417, 18.583, 19.5, 18.5, 17.167, 17.25, 17.5, 20.417, 17.083, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   21.25, 19.25, 19.333, 19.167, 18.917, 20.917, 17.333, 18.167, 20.75, 19.917, 18.667, 18.417, 17.417, 20.333, 19.333, 18.167, 20.75, 17.667, 16.917, 18.583, 17.167, 17.75)))
package:MASS
TRUE
FALSE
synth.te
list(`package:MASS` = list(xs = c(-0.970990139, -0.631997027, -0.77360576, -0.606211523, -0.539409005, -0.96032585, -1.041375608, -0.822600536, -0.943714771, -0.968763299, -0.85363798, -0.77199493, -0.718952712, -0.539520701, -0.540093447, -0.792923186, -0.86147285, -0.470131571, -0.770683778, -0.80303123, -0.962520756, -0.681960494, -0.433007837, -0.33683164, -0.696425307, -0.355766886, -0.547898136, -0.799663889, -0.780012402, -0.853938355, -0.896295454, -0.82402827, -0.901075546, -0.55671872, 
                                  -0.871004652, -0.800820459, -0.699003238, -0.759409251, -0.77526809, -0.893576947, -0.284857192, -0.66557175, -0.741374392, -0.767733049, -0.779306345, -0.892190952, -0.122811626, -0.731730651, -1.011976425, -0.573762197, -0.641425285, -0.985902178, -0.661140507, -0.749218489, -0.540329548, -0.592092859, -0.860077357, -0.867516891, -0.590055695, -0.775966325, -0.849687489, -0.74628304, -0.700854929, -0.923680439, -0.912092992, -0.650765709, -0.980330108, -0.744408938, -0.604170665, -0.735903002, 
                                  -0.643607616, -0.963376987, -0.426980732, -0.654762824, -0.843491783, -0.553968009, -0.716946447, -0.77532879, -0.640289822, -0.516878864, -0.952125366, -0.723017513, -0.65880524, -0.464552773, -0.564517221, -0.814096964, -0.396184143, -0.996637001, -0.815950989, -0.526626592, -0.667763995, -0.658898181, -0.923935948, -0.909973792, -0.410551229, -0.46206444, -0.366146922, -0.59586137, -0.704392096, -0.841225771, -0.969828933, -0.557037265, -0.671104208, -0.503286446, -0.950325858, -0.67581312, -0.831561973, 
                                  -0.43507409, -0.793021028, -0.848627588, -0.820269797, -0.422092727, -0.408676218, -0.546953839, -0.73544413, -0.58220547, -0.338346632, -0.535045557, -0.493743519, -0.760932705, -0.515677444, -0.673504588, -0.459705697, -0.694881314, -0.387447545, -0.596036129, -0.664372536, -0.883742635, -0.509344933, -0.925124882, -0.841007867, -0.894120137, -0.646573229, -1.017873059, -0.582528753, -0.897329196, -0.46501686, -0.726508681, -0.514352969, -0.739246011, -0.537049319, -0.923407832, -0.663217181, -0.871900824, 
                                  -0.574764695, -0.778723382, -0.717491428, -0.29398519, -0.732183039, -0.672451661, -0.392906014, -0.821496561, -0.44164984, -0.734149425, -0.353467324, -0.756729286, -0.985271855, -0.734362749, -0.843814454, -0.871470989, -0.643774042, -0.617659001, -0.282068649, -0.402555368, -0.458583969, -0.846296983, -1.048542317, -0.799795307, -0.852040552, -0.616474678, -0.691690351, -0.809142202, -0.837139722, -0.743520251, -0.66065023, -0.594815839, -0.597128033, -0.921420258, -0.877566913, -0.765371773, 
                                  -0.69984055, -0.523434825, -0.656387744, -1.03696764, -0.715165192, -0.747858131, -0.625684541, -0.756699924, -0.67969067, -0.612004202, -0.647906789, -0.691066413, -0.675112764, -0.85107279, -0.837051482, -0.961405831, -0.642774716, -0.892075711, -0.927798777, -0.751800726, -0.80534103, -0.692838235, -0.703943931, -0.694804098, -0.567758798, -0.82238, -0.565082539, -0.724181702, -0.916357511, -0.430182548, -0.632645741, -0.850972862, -0.60969102, -0.705661024, -0.693161871, -0.633922642, -0.710406768, 
                                  -1.055052036, -0.621276063, -0.613423246, -0.989565379, -0.923580375, -0.889581095, -0.930040388, -0.691421356, -1.031412255, -0.701394895, -0.627721178, -0.829380326, -0.612200851, -0.528139634, -0.616674472, -0.649202842, -0.655384302, -0.75008524, -0.471920626, -0.219905912, -0.87170126, -0.730197977, -0.620676222, -0.657830687, -0.475352116, -0.734794644, -0.772673638, -0.62071047, -0.529626406, -0.730846476, -0.938694493, -0.723706354, -0.979569099, 0.448754392, -0.077907282, 0.316786631, 0.229597046, 
                                  0.197949376, 0.048404642, 0.270601003, 0.516192043, 0.154718993, -0.005611276, 0.365076313, 0.086615547, 0.198645891, 0.13187066, 0.585894768, -0.023498655, 0.394174061, 0.595983773, 0.388419733, 0.270452263, 0.336909893, 0.481432232, 0.24686524, -0.020439631, 0.389941424, 0.048115168, 0.284816331, 0.529166911, 0.349208427, 0.323888259, 0.321213977, 0.303365953, -0.075979803, 0.317894059, 0.136145272, 0.086777443, 0.330555298, 0.202260475, 0.276704436, 0.24481459, 0.429043775, 0.340412789, 0.382064022, 
                                  0.381833239, 0.424417864, 0.206306313, 0.091614953, 0.627597689, 0.270244718, 0.127928396, 0.399192895, 0.450618123, 0.254900382, 0.25952339, 0.417004689, 0.346581338, 0.748854615, 0.428530072, 0.127369504, 0.528722462, 0.61816822, 0.286029472, 0.142578461, 0.282764909, 0.788220007, 0.11916522, 0.244772936, 0.160442893, 0.4540673, -0.057868287, -0.111365306, 0.198824819, 0.595468169, 0.085627364, 0.465261497, 0.359673625, 0.111822093, 0.509269078, 0.470888018, 0.393262912, 0.311897634, 0.151594554, 
                                  0.084423498, 0.208641564, 0.361230606, 0.425667999, 0.399549324, 0.279615939, 0.109049911, 0.102929855, 0.551085316, 0.579201159, 0.356514867, 0.259861364, 0.545480531, 0.398789597, 0.383441254, 0.405415302, 0.249091946, 0.293535767, 0.149869213, 0.224986842, 0.240826479, 0.122917552, 0.301231733, 0.257698819, 0.446288764, 0.511214849, 0.474675267, 0.373402327, 0.453575217, 0.363708989, 0.323172397, 0.263568182, 0.375989273, 0.483416817, 0.412708967, 0.29459071, 0.148425126, 0.476236614, 0.051021769, 
                                  0.488029582, 0.193703118, 0.390385684, 0.166515062, 0.378346001, 0.059890677, -0.077252668, 0.519325984, 0.27195542, 0.027254987, 0.437437673, 0.02837064, 0.433657082, 0.280505393, 0.300735977, 0.182031568, 0.316158641, 0.530601146, 0.210237556, 0.399444521, 0.272113433, 0.418146305, 0.504825239, 0.166974207, 0.106527356, 0.607348514, 0.517847638, 0.231553652, 0.255029497, 0.287511011, 0.200852107, 0.226547849, 0.011878373, 0.38056991, 0.519215428, 0.62385488, 0.183173455, 0.226420389, 0.455356509, 
                                  0.332301375, 0.376306021, 0.428169526, 0.145829529, 0.49375754, 0.529391969, 0.40982616, 0.612354746, 0.221568084, 0.427545649, 0.533325611, 0.462109537, 0.18236212, 0.31010779, 0.15979955, 0.254288145, 0.316374077, 0.28594226, 0.552541865, -0.00409046, 0.060484031, 0.545097739, 0.268284924, 0.159022649, 0.492658208, -0.128240252, 0.44776008, 0.239374886, 0.138634894, 0.417284343, 0.178303979, 0.221552636, -0.009120409, 0.292748806, 0.300563713, 0.242506812, 0.234494302, 0.352550448, 0.185994378, 
                                  0.409680307, 0.16391995, 0.169756191, 0.354398935, 0.38887006, 0.344788486, 0.193145216, 0.430800164, 0.232808591, 0.326059317, 0.330837091, 0.323691216, 0.36773709, 0.530750561, 0.089596372, 0.432192982, 0.186694048, 0.458275145, 0.480078071, 0.582758378, 0.437808065, 0.208830936, 0.377797466, 0.183803076, 0.155682547, 0.071926861, 0.364435618, 0.408213991, 0.466073956, 0.614281743, -0.047151673, 0.32691715, 0.458840582, 0.109537926, 0.161895892, 0.450055408, 0.368869484, 0.334209119, -0.031121068, 
                                  0.17675385, 0.552527788, 0.304266409, 0.210462653, 0.06395371, -0.063149684, 0.07353571, 0.665453703, 0.539642761, 0.250981585, 0.392679888, 0.431409216, -0.516451834, -0.116775286, -0.327960793, -0.394572192, -0.110201988, -0.160538577, -0.124742465, -0.109742769, -0.687328305, -0.358374262, -0.33583652, -0.321604223, -0.091546228, -0.660890881, -0.561938441, -0.244433911, -0.39288546, -0.429608736, -0.090462865, -0.436484641, -0.519966218, -0.418391404, -0.405807798, -0.085688384, -0.210347223, 
                                  -0.53189666, -0.294588066, -0.092753982, -0.314549926, -0.262918395, -0.389819133, -0.162163174, -0.418250429, -0.356533257, -0.461800168, -0.149067005, -0.376621128, -0.235807559, -0.433816383, 0.003602461, -0.286855152, -0.42406679, -0.270030002, -0.239212386, -0.255304685, -0.196569409, -0.125203354, -0.338351441, -0.383184405, -0.398513962, 0.027844709, -0.295483256, -0.552989277, -0.004901838, -0.029384352, -0.444694587, -0.338928122, 0.122195503, -0.186584991, -0.295015658, -0.10263067, -0.430785693, 
                                  -0.099297566, -0.009264193, -0.560973647, -0.536294204, -0.563297476, -0.292902091, -0.107464304, -0.261216307, -0.105100716, -0.362473095, -0.548222187, -0.522717054, -0.406753361, -0.272149948, -0.058505372, -0.286284031, -0.145641743, -0.254951568, -0.200910922, -0.397769966, -0.547436085, -0.231129177, -0.473894736, -0.231075189, -0.268776826, -0.180889587, -0.326237906, -0.252657163, -0.294967226, -0.441714737, -0.434336942, -0.080950672, -0.256056671, -0.767972482, -0.250929687, -0.233531508, 
                                  -0.166252171, -0.39938987, -0.383257048, -0.246208261, -0.112873567, -0.096666032, -0.457949369, -0.255003562, -0.073434667, -0.409375468, -0.363348126, -0.257217769, -0.3493313, -0.151880213, -0.404171363, -0.46232091, -0.546143281, -0.229962943, -0.246561278, -0.392635644, -0.175983074, -0.160444346, -0.341235994, -0.333233675, -0.27422603, -0.394217634, -0.17711092, -0.403972304, -0.387046408, -0.044038573, -0.278389636, -0.27224947, -0.191592271, -0.590368203, -0.37418884, -0.351703587, -0.281959049, 
                                  -0.751945036, -0.306929899, -0.762727447, -0.56444838, 0.040323664, -0.462188702, -0.447915766, -0.217001799, -0.11250922, -0.131149777, -0.403054671, 0.008848708, 0.09064759, -0.358620932, -0.441265488, -0.47984242, -0.588843824, -0.562606783, -0.514270007, -0.392905106, -0.075132059, -0.19683087, -0.301481674, -0.181585205, -0.114373131, -0.331936585, -0.266807581, -0.475109818, -0.557037972, -0.193240214, -0.029348731, -0.383376526, -0.035071125, -0.060506093, -0.160710931, -0.210362275, -0.283272444, 
                                  -0.520613526, -0.263870495, -0.060226406, -0.429473669, -0.325250467, 0.094837102, -0.326848641, -0.537630937, -0.589458171, -0.255109811, -0.350722503, -0.111745167, -0.213435551, -0.272518877, -0.440414101, -0.30336279, -0.22120004, -0.286914561, 0.096845361, -0.363110834, -0.211246704, -0.222052903, -0.32182833, -0.47373795, -0.212793549, 0.00846387, -0.20569342, -0.378486601, -0.229442899, -0.162703081, -0.321296905, -0.400332594, -0.312050685, -0.039349153, -0.273914659, -0.348565665, -0.413758325, 
                                  -0.098831839, -0.287690535, -0.383124103, -0.561271474, -0.166431846, -0.63511472, -0.332175204, -0.474805835, -0.116004389, -0.477937453, -0.126810442, -0.156822576, -0.293523863, -0.129615545, -0.108242313, -0.501979824, -0.138108021, -0.179322731, -0.458093963, -0.028565637, -0.426175577, -0.310680953, -0.180247439, -0.217870537, -0.315992257, 0.236276902, -0.185456072, -0.203065705, -0.296142711, -0.448939545, 0.077064746, 0.0340245, -0.439519067, -0.471452461, -0.263821096, -0.676333519, -0.394630195, 
                                  -0.334698783, 0.043828297, 0.073254562, -0.358305948, 0.289824646, 0.479141353, 0.180670084, 0.19982583, 0.735249202, 0.249991814, 0.413137889, 0.518581462, 0.465359263, 0.348309276, 0.174782318, 0.549911988, 0.203934276, 0.338644108, 0.161322119, 0.350961307, 0.090257414, 0.764373743, 0.414756998, 0.679361421, 0.640285978, 0.63087604, 0.366370214, 0.314611449, 0.745924055, 0.489768059, 0.075247977, 0.499573139, 0.350405143, 0.636928363, 0.224908918, -0.032261912, 0.627052189, 0.263348975, 0.520257017, 
                                  0.151882522, 0.098482589, 0.201212077, 0.371298202, 0.497766489, 0.409493154, 0.340849813, 0.391675543, 0.516131854, 0.522760611, 0.446358722, 0.224400728, 0.583149627, 0.420184227, 0.340883764, 0.407626346, 0.226804848, 0.46155003, 0.275762111, 0.304760108, 0.636786149, 0.544820787, 0.816098957, 0.454637082, 0.416886517, 0.585814059, 0.158972903, 0.218197123, 0.436713777, 0.46535934, 0.346901746, 0.599207277, 0.463002935, 0.694263789, 1.000277812, 0.503660224, 0.60941901, 0.352923549, 0.313797682, 
                                  0.275593847, 0.310310776, 0.200769573, 0.393611386, 0.29328418, 0.150904334, 0.359648477, 0.425437016, 0.550057275, 0.369377777, 0.483823544, 0.665201554, 0.367662676, 0.60365412, 0.361992913, 0.365320313, 0.565587013, 0.459978544, 0.389662454, 0.662029374, 0.193287037, 0.770581129, 0.517729293, 0.666759179, 0.507357601, 0.074897782, 0.267419803, 0.570998498, 0.234076185, 0.204728441, 0.463600872, 0.55169527, 0.375064997, 0.548113044, 0.436411367, 0.171669265, 0.22862817, 0.258176, 0.427636052, 0.551129128, 
                                  0.382357212, 0.62718752, 0.759430378, 0.385966401, 0.216206061, 0.107421934, 0.466619974, 0.483552867, 0.188288155, 0.123111648, 0.149201404, 0.541125439, 0.707584972, 0.250259605, 0.388929309, 0.163559795, 0.290938989, 0.671326658, 0.419646183, 0.2975763, 0.488205349, 0.274956333, 0.364636103, 0.020765563, 0.503582267, 0.129743512, 0.205737679, 0.491663362, 0.54192882, 0.352448258, 0.340546986, 0.087362845, 0.544510425, 0.426834451, 0.505026501, 0.393952243, 0.341212359, 0.443882109, 0.216623801, 
                                  0.325421774, 0.339954219, 0.757953402, 0.16651156, 0.394924171, 0.581373272, 0.469451043, 0.180074959, 0.314960733, 0.781475499, 0.261043992, 0.149151175, 0.23637187, 0.64632377, 0.518347874, 0.089471338, 0.498070451, 0.248059552, 0.550195316, 0.280602842, 0.431834416, 0.267799611, 0.507750995, -0.064478127, 0.342112413, 0.332313982, 0.665012582, 0.382910589, 0.361027556, 0.571981147, 0.536918322, 0.33187267, 0.044037168, 0.410716663, 0.455083777, 0.474594596, 0.413672127, 0.682171442, 0.425353451, 
                                  0.26227742, 0.007860344, 0.38099959, 0.53843728, 0.180415465, 0.237060285, 0.829663295, 0.307664951, 0.239849381, 0.275375404, 0.416984789, 0.476493007, 0.564497576, 0.198295169, 0.294198911, 0.684760671, 0.168075136, 0.502763522, 0.129722603, 0.285983065, 0.097239329, 0.210574775, 0.593896992, 0.35883679, 0.197591638, 0.540587182, 0.175106338, 0.448304389, 0.289880687, 0.300130047, 0.15251107, 0.495317475, 0.072423805, 0.500846416, 0.159104712, 0.710308164, 0.750642087, 0.559868855, 0.400801648, 
                                  0.356480531, 0.844132265, 0.426337951, 0.461052514, 0.205997206, 0.118613656, 0.44442848, 0.278467451, 0.329683958, 0.338924385, 0.427674817, 0.32416998, 0.526486063, 0.664857776, 0.327675416, 0.247589562, 0.418514564, 0.232314519, 0.762040971), ys = c(0.42942495, 0.251952852, 0.690750778, 0.175677956, 0.376744239, 0.11004071, 0.328508085, 0.1758742, -0.180633309, 0.296070217, 0.644010559, 0.476344773, 0.090457675, 0.447837856, 0.551067215, 0.531235891, 0.287352652, 0.54425126, 0.482733051, 0.228632039, 
                                                                                                                                                                                                                                                                                               0.367759881, 0.495354977, 0.213645636, 0.293614869, 0.315194495, 0.269794553, 0.277054714, 0.292931173, 0.038437662, 0.198423604, 0.286916469, 0.295231859, 0.321018371, 0.358145252, 0.258992681, 0.363123198, 0.417050087, 0.366156047, 0.306716684, -0.096908084, 0.307321395, 0.365820514, 0.298498149, 0.245811163, 0.319092986, 0.201459901, 0.516497113, 0.05599255, 0.344692082, 0.059676643, 0.333730563, 0.162020997, 0.136840396, 0.185148533, 0.387396621, 0.447510299, 0.218917745, -0.137491677, 0.466004783, 
                                                                                                                                                                                                                                                                                               0.403399745, 0.315466589, 0.256242513, 0.518361424, 0.449453255, 0.407980138, 0.412200546, 0.299281948, 0.203087089, 0.326156917, 0.655288145, 0.513819006, 0.249000843, 0.282178155, 0.562181098, 0.345421521, 0.538960351, 0.122102049, 0.498892271, 0.435762487, 0.182337108, 0.298280511, 0.256182935, 0.269147489, 0.218324319, 0.196511498, 0.228304066, 0.511765539, 0.209223029, 0.23596682, 0.418687316, 0.428833798, 0.031828081, 0.530254142, 0.451785093, 0.252159645, 0.230673805, -0.036140226, 0.400288539, 
                                                                                                                                                                                                                                                                                               0.238984335, 0.577095745, 0.155360193, 0.314190393, 0.361767035, 0.566417412, 0.078493347, 0.31930825, 0.143581661, 0.492855894, 0.118140919, 0.082762982, 0.395714263, 0.477760711, 0.374918252, 0.473748255, 0.266138774, 0.271991191, 0.24242686, 0.118043648, 0.717856305, 0.41624553, 0.184242721, 0.296239478, 0.186931282, 0.38184098, 0.080890693, 0.184974829, 0.423940859, 0.614943083, 0.290033636, 0.604748154, 0.290327096, 0.157169952, 0.609447746, 0.148721295, 0.184940557, 0.532091737, 0.285520226, 
                                                                                                                                                                                                                                                                                               0.181867205, 0.156961029, 0.408845252, 0.30741718, 0.492249753, 0.241275721, 0.191786697, 0.216699985, 0.417127421, 0.169911784, 0.341692708, 0.611673182, 0.29033039, 0.314507904, 0.383502471, 0.131552989, 0.138366727, 0.403725989, 0.140926608, 0.307051129, 0.131915653, 0.508797861, 0.409534472, 0.386072579, 0.067340392, 0.693923139, 0.204385656, 0.42073938, 0.277152491, 0.338822747, 0.309430762, 0.307281614, 0.25295251, 0.272750414, 0.441901584, 0.269171931, 0.247417602, -0.028489077, 0.109164679, 
                                                                                                                                                                                                                                                                                               -0.037465241, -0.06984429, 0.304297059, 0.596974416, 0.167126769, -0.064742897, 0.012460495, 0.141450813, 0.217239838, 0.569994813, 0.32012245, 0.174518616, 0.438410861, -0.134269826, 0.239638558, 0.255635309, 0.550169559, 0.474955936, 0.408050507, 0.588207922, 0.163487304, 0.064132978, 0.072240031, 0.409258566, 0.064157327, 0.171715163, 0.476730183, 0.268655402, 0.207116645, 0.268404036, 0.327015498, 0.625763803, 0.236124996, 0.268033748, 0.522382761, 0.345168936, 0.501872186, 0.220694983, 0.100244402, 
                                                                                                                                                                                                                                                                                               0.390701059, 0.01518024, 0.51783314, 0.167382599, 0.26613495, 0.16669358, 0.412606504, 0.426760653, 0.240533824, 0.006339557, 0.482277646, 0.46235601, 0.243813111, 0.487867261, 0.121715064, 0.449962538, 0.058254182, 0.263909873, 0.225793561, 0.119545244, 0.278830975, 0.315052974, 0.240570129, 0.295504781, 0.046383576, 0.265899761, 0.279850946, 0.365235616, 0.355477724, 0.770796635, 0.091067609, 0.642803364, 0.324275071, -0.017999841, -0.003034376, 0.015050386, 0.245842052, 0.252917817, 0.067681573, 
                                                                                                                                                                                                                                                                                               0.310003887, -0.037865268, 0.260199166, 0.258256258, 0.040306842, 0.223658499, -0.001956641, 0.138482814, 0.047611642, 0.40225536, 0.433203159, 0.379919943, 0.533936878, 0.680516952, 0.321931614, 0.360309566, 0.176262915, 0.326027716, 0.5327004, 0.132155124, 0.309223343, 0.104763308, -0.048775617, 0.285314795, 0.063167392, 0.192358455, 0.101190083, 0.286689359, 0.312196126, 0.110578558, 0.223509762, 0.397316175, -0.018831347, 0.212061643, 0.541792424, -0.03343489, 0.183967494, 0.23747421, 0.123295299, 
                                                                                                                                                                                                                                                                                               0.085809636, 0.321954582, 0.348957865, 0.309132098, 0.472188745, 0.361936451, 0.368238186, 0.120050819, 0.452328633, 0.410220018, 0.124427489, 0.3008059, 0.283479475, 0.246812787, 0.636260298, 0.32173205, 0.227075837, 0.327309276, 0.21564345, 0.112955825, 0.091628143, 0.464545152, 0.239567886, 0.014906673, 0.455259044, 0.332582882, 0.498675578, 0.079756044, 0.476017542, 0.162120124, 0.315262031, 0.123331422, 0.364504393, 0.296370162, 0.464037322, 0.285556829, 0.093782124, 0.286626364, 0.268411495, 
                                                                                                                                                                                                                                                                                               0.319282396, 0.230226362, 0.506867239, 0.239049251, 0.136827304, 0.310402719, 0.630255432, 0.446152743, 0.313983603, 0.179353765, 0.178396614, 0.096917764, 0.272730569, 0.149343536, 0.243298247, 0.351024129, 0.423059272, 0.133960638, 0.305675082, 0.464864831, 0.233973445, 0.406179372, 0.178773911, 0.537312141, 0.206483371, 0.156330717, 0.454212426, 0.107531816, 0.013564367, 0.324209899, 0.308234424, 0.09732156, 0.511128488, -0.027606822, 0.353260156, 0.338631607, 0.313998286, 0.009138517, 0.518229423, 
                                                                                                                                                                                                                                                                                               0.492206314, 0.35612744, 0.402548715, 0.077486533, 0.205554127, 0.615481812, 0.325973024, 0.352901733, 0.031010063, 0.289394991, -0.027210937, 0.166304765, 0.604909277, 0.022916023, 0.188023897, 0.292354741, 0.423973591, 0.287109075, 0.384357431, 0.496882692, 0.437262474, 0.145521656, 0.154106314, 0.18064138, 0.500370591, 0.184680121, 0.396858357, 0.403086636, 0.430592319, 0.219412906, 0.272097495, 0.244596483, 0.352803074, 0.434089493, 0.072764703, 0.338983888, 0.255322403, 0.075341621, 0.367957232, 
                                                                                                                                                                                                                                                                                               -0.011058516, 0.18846077, 0.054583036, 0.368253163, 0.376063674, 0.074698658, 0.280322788, 0.120926664, 0.273458368, 0.106200846, 0.591671136, 0.35795556, 0.29852096, 0.301510248, 0.257640193, 0.37430808, 0.029411804, 0.338773678, -0.016858031, 0.399012387, 0.277592649, 0.218461339, 0.26790334, 0.531382417, 0.486286052, 0.533333926, 0.284865402, 0.462386877, 0.395550274, 0.200022118, 0.306720386, 0.396534895, 0.724738825, 0.41443264, 0.214325496, 0.232690286, 0.247006083, 0.351581175, 0.269914887, 
                                                                                                                                                                                                                                                                                               0.212370722, 0.026130185, 0.104358886, 0.227524046, 0.042378087, 0.246053805, 0.271352787, 0.263193765, 0.445516712, 0.563886858, 0.256040145, 0.35687292, -0.088857683, 0.327389964, 0.33842391, 0.394261493, 0.438187113, 0.324647633, 0.374810492, 0.390433695, 0.389265557, 0.010096493, 0.474572076, -0.09008397, 0.537563127, 0.572783083, -0.123841713, 0.254483065, 0.398618252, 0.283302172, 0.214579449, 0.468066389, 0.443470083, 0.18950591, 0.123705078, 0.501518844, 0.557190529, 0.413960488, 0.228014456, 
                                                                                                                                                                                                                                                                                               0.43019999, 0.224902508, 0.22028721, 0.415336683, 0.045543235, 0.351389125, 0.252143534, 0.203720086, 0.279986737, 0.069569958, 0.090261998, 0.288456378, 0.501256111, 0.483404773, 0.546240228, 0.755243715, 0.55340223, 0.579525838, 0.323661757, 0.696514698, 0.807033124, 0.807265743, 0.392482381, 0.591913273, 0.562483354, 0.611049023, 0.907495412, 0.451367292, 0.550604753, 0.644152661, 0.52225159, 0.520039359, 0.940830736, 1.011277424, 0.738999068, 0.847932361, 0.416696729, 0.452618557, 0.84601285, 
                                                                                                                                                                                                                                                                                               0.693082777, 0.797236706, 0.787474678, 0.579880509, 0.315021403, 0.684349895, 0.896022491, 0.782142975, 0.837864969, 0.553207248, 0.642937572, 0.568682995, 0.804352974, 0.710632583, 0.994872459, 0.833427152, 0.378268423, 0.82210536, 0.703182679, 0.844725933, 0.680964321, 0.839383812, 0.75028445, 0.537770177, 0.84672223, 0.794817114, 0.608282407, 0.614072912, 0.779042878, 0.78972599, 0.784475027, 0.560614872, 0.840559001, 0.675938267, 0.645617846, 0.894434898, 1.012595196, 0.807423104, 0.529432752, 
                                                                                                                                                                                                                                                                                               0.646381268, 0.620924549, 0.615869773, 0.699646352, 0.868085863, 0.683245848, 0.726739882, 0.636324411, 0.85897587, 1.009788333, 0.722037722, 0.564831018, 0.527786275, 0.909735133, 0.911648155, 0.39811728, 0.779495789, 0.491139768, 0.682466158, 0.453157246, 0.676814477, 0.88046241, 0.599734095, 0.575832499, 0.707617098, 0.64925839, 0.859634714, 0.608362742, 0.465280126, 0.818894418, 0.807765177, 0.536107452, 0.578022234, 0.961981117, 0.918196737, 0.728269018, 0.825689335, 0.707306804, 0.704015342, 
                                                                                                                                                                                                                                                                                               0.504258034, 0.722783609, 0.526062925, 0.881713044, 0.607597755, 0.703112332, 0.492886, 0.737139545, 0.42367311, 0.835222198, 0.611218821, 0.550748181, 0.396901704, 0.659236133, 0.85698944, 0.536421185, 0.558945553, 0.677337101, 1.084965709, 1.174990894, 0.705580257, 0.654499407, 0.753839485, 0.349432166, 0.234622985, 0.380898603, 0.698331693, 0.819242381, 0.730361507, 0.469288157, 0.885219702, 0.574182522, 0.890352701, 0.729602705, 0.779572618, 0.998868915, 0.843500207, 0.7966238, 0.611900551, 0.948975611, 
                                                                                                                                                                                                                                                                                               0.786868546, 0.652933806, 0.654317764, 0.936462477, 0.326283245, 0.788087594, 0.64821463, 0.754763105, 0.324312047, 0.821041597, 0.68570299, 0.71411282, 0.552313534, 0.65998877, 0.736877415, 0.44020952, 0.545085006, 0.947483833, 0.778719573, 0.574512048, 0.829601881, 0.624385592, 0.812800625, 0.772166835, 0.530042141, 0.56744685, 0.798839816, 0.837372559, 0.687937002, 0.688228649, 0.65471794, 0.791105596, 0.750572909, 0.82355328, 0.827068887, 0.897096209, 0.737443245, 0.739648314, 0.705987527, 0.466547665, 
                                                                                                                                                                                                                                                                                               0.683481004, 0.974317798, 0.576264653, 0.987888085, 0.619578181, 0.511673423, 0.661562448, 0.813171823, 0.686080299, 0.62435751, 0.506318972, 0.77469347, 0.614591369, 0.644919563, 0.778361218, 0.594732866, 0.930991126, 0.828610911, 0.688297191, 0.61849475, 0.959790721, 0.599403497, 0.612606769, 0.696448995, 0.854519409, 0.883301183, 0.672367628, 1.067278573, 0.897151624, 0.688087392, 0.501477407, 0.711218005, 0.70836399, 0.702949001, 0.971409951, 0.457687275, 0.856486819, 0.891819146, 0.644814421, 
                                                                                                                                                                                                                                                                                               0.370050434, 0.612928438, 0.366517387, 0.571370985, 0.486501211, 0.461765467, 0.544905689, 0.876336671, 0.390856979, 0.736172703, 0.714179743, 0.702294953, 0.317910002, 0.648026589, 0.650603998, 0.797884087, 0.788213418, 0.946446539, 0.708540945, 0.56577811, 1.064998541, 0.732544473, 0.63831366, 0.782970773, 0.639405607, 0.638878595, 0.645297701, 0.769272264, 0.518893193, 0.747216818, 0.833027044, 0.350660256, 0.854044549, 0.38636275, 0.854392557, 0.680024754, 0.544423218, 0.472172493, 0.410263392, 
                                                                                                                                                                                                                                                                                               1.028370469, 0.950855699, 0.686427652, 0.846995122, 0.615571296, 0.893306725, 0.659759084, 0.804268545, 0.710028594, 0.772543364, 0.755070836, 0.706345767, 0.684198041, 0.621422345, 0.679632119, 0.443980792, 0.603842916, 0.840917922, 0.655726651, 0.808688697, 0.455434849, 0.762965338, 0.966544141, 0.517323437, 0.549826846, 0.76138994, 0.76907636, 0.3051187, 0.766677739, 0.48977392, 0.412661585, 0.520845425, 0.869775036, 0.559199836, 0.871728559, 0.768544337, 0.582414682, 1.016274588, 0.997357208, 
                                                                                                                                                                                                                                                                                               0.728402685, 0.773039119, 0.405069957, 0.52115393, 0.902598154, 0.643244361, 0.627059827, 0.498139441, 0.472857968, 0.877325952, 0.791103192, 0.582375556, 0.61910853, 0.776639489, 0.605698565, 0.972725613, 0.550710864, 0.669240364, 0.451743317, 0.560098, 0.639530833, 0.428469344, 0.624510853, 0.757815199, 1.068014129, 0.489922085, 0.564537846, 0.874953285, 0.984800311, 0.605205704, 0.953322346, 0.717383758, 0.776401643, 0.609337149, 0.432857589, 0.439204275, 0.607744455, 0.193465958, 0.766374185, 
                                                                                                                                                                                                                                                                                               0.421990201, 0.697573566, 0.545080251, 0.660104813, 0.678276952, 0.709447233, 0.738395921, 0.504291821, 0.726624656, 0.6691258, 0.905961669, 0.680851488, 0.915150466, 0.831022543, 0.877530083, 0.706265086, 0.683542273, 0.523946916, 0.706402907, 0.696358973, 0.750019031, 0.726640752, 1.041844415, 0.485587245, 0.85779647, 0.897903714, 0.649098802, 0.886147391, 0.525437056, 0.649300564, 0.519368234, 0.704849311, 0.618943465, 0.674098357, 0.64104895, 1.048980926, 0.738434506, 0.980538827, 0.768820434, 
                                                                                                                                                                                                                                                                                               0.85841666, 0.887569891, 0.833301601, 0.815635781, 0.928912516, 0.622947292, 0.552039161, 0.400801476, 0.462402974, 0.478205376, 0.652800375, 0.919029482, 0.592238748, 0.438954474, 0.610581184, 0.722352081, 0.31057094, 0.697519317, 0.203961507, 0.701709243, 0.487823226, 0.515215865, 0.641423278, 0.565006133, 0.500219969, 0.64611363, 0.67563972, 0.795156547, 0.769434777, 0.686613394, 0.91790351, 0.919406796, 1.074871466, 0.883671133, 0.475484999, 0.975832107, 0.522312176, 0.876936157, 0.658664051, 
                                                                                                                                                                                                                                                                                               0.90262072, 0.746906831, 0.737298487, 0.603132684, 0.533887741, 0.603699345, 0.826989974, 0.834070122, 0.661643764, 0.509083774, 0.878512787, 0.749228951, 0.645111929, 0.794214002, 0.898472992, 0.57036793, 0.476641964, 0.798924771, 0.551831167, 0.889946347, 0.867650039, 0.972182362, 0.53531635, 0.637457666, 0.806598462, 0.653580787, 0.90799736, 0.914334885, 0.752505492, 0.697894513, 1.074702414, 0.753987444, 0.806554305, 0.452953422, 0.858473259, 0.915314697, 0.534934547, 0.374100529, 0.892746414, 
                                                                                                                                                                                                                                                                                               0.794230658, 0.712129784, 0.69711045, 0.796121883, 0.681159777, 0.792652629, 0.530407106, 0.671400853, 0.710584968, 0.774780451, 0.609394118, 0.663333083, 0.204721503, 0.934825869, 0.851596486, 0.631046756, 0.678667079, 0.689706961, 0.628206422, 0.777809751, 0.82803727, 0.783081248, 0.786167018, 0.911823818, 0.561509712, 0.777438407, 0.615763585, 0.785369909, 0.832647177, 0.747145725, 0.75594387, 0.704522943, 0.73941888, 0.962589298, 0.808410845, 0.856427139, 0.773954077, 0.608013752, 0.279270348, 
                                                                                                                                                                                                                                                                                               1.044157214, 0.819642835, 0.573218465), yc = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                                                                                                                                                                                                                                                                                                                                              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                                                                                                                                                                                                                                                                                                                                              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                                                                                                                                                                                                                                                                                                                                              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                                                                                                                                                                              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))
package:MASS
TRUE
FALSE
synth.tr
list(`package:MASS` = list(xs = c(0.05100797, -0.74807425, -0.77293371, 0.2183736, 0.37268336, -0.62931544, -0.43307167, -0.8415197, 0.47525648, 0.32082976, 0.32061253, -0.89077472, 0.17850119, 0.31558002, 0.55777224, 0.03191877, 0.25090585, 0.23571547, -0.07236203, 0.50440241, -0.63223351, -0.76784656, -0.70017557, -0.64713491, -0.76739248, -0.51788734, 0.17516644, -0.6803119, 0.01595199, -0.71481078, 0.07837946, -0.80872251, -0.84211234, -0.98591577, 0.29104081, 0.24321541, -0.60104419, -1.24652451, 
                                  -0.82769016, -0.62117301, -0.70584105, 0.06718867, 0.30505147, 0.60788138, -0.78937483, -0.53123209, 0.25202071, -0.57880357, -0.83176749, -0.69859164, -0.73642607, -0.93496195, 0.43959309, -0.54690854, -0.0840555, 0.32211458, 0.10764739, -0.7186403, -0.87877752, -0.69846046, 0.39757434, -0.50451354, 0.25023622, 0.61709156, 0.3183286, -0.57453363, 0.09761865, 0.48449339, 0.52400684, -0.78138463, -0.49704591, -0.96984525, 0.43541407, -0.67942462, -0.62529036, -0.02318116, 0.23200141, 0.09384354, 0.14234301, 
                                  -0.61686357, 0.23636288, 0.38914177, -0.95178678, 0.24087822, 0.12446266, -0.6056643, -0.71397188, 0.31008428, 0.18018786, -0.42663885, 0.0614323, 0.07736952, 0.4281497, -0.80250753, 0.40142623, 0.37084776, -0.80774748, 0.50163585, 0.58238323, -0.591361, -0.87037236, -0.72086765, 0.27778443, 0.33240813, -0.14092068, -0.59759518, -0.85581534, -0.88912232, 0.2134568, -0.53467949, 0.31686848, -0.68121733, -0.97586127, 0.41457183, 0.32751292, -0.93209192, 0.58395341, -0.44437309, 0.29109441, -0.51080722, 
                                  -0.96597511, 0.18741315, 0.17965417, -0.72689602, -0.54339877, -0.59823393, -0.20194736, 0.47146103, -0.09821987, -0.35657658, 0.63881392, 0.62980614, -0.46223286, -0.07331555, -0.55405533, -0.43761773, -0.22237814, 0.09346162, 0.53174745, 0.40207539, 0.47555171, -0.23383266, -0.31579316, -0.4735172, 0.59239464, -0.22605324, -0.43995011, -0.54645044, 0.46404306, -0.15194296, 0.48536395, 0.34725649, 0.43897015, -0.21415914, 0.57380231, 0.38717361, 0.32038322, -0.20781491, -0.18651283, 0.24752692, 
                                  0.66049881, -0.28658801, -0.3258808, -0.25204565, 0.37259022, -0.29096564, -0.30469807, -0.21389978, -0.36830015, -0.46928218, 0.39350146, -0.45639966, 0.51128242, 0.22550468, 0.01462984, -0.19172785, 0.38323479, 0.49791612, 0.3533523, -0.34722575, 0.58380468, -0.13727764, 0.38827268, -0.53172709, -0.11684624, 0.54335864, -0.45399302, -0.219132, 0.30485742, 0.65676798, 0.61420447, -0.45809964, -0.21617465, -0.26016108, 0.31884531, -0.23727415, 0.58310323, 0.02841337, -0.41840136, 0.6741288, -0.25278281, 
                                  0.51609843, 0.20392294, -0.17207124, 0.27274507, 0.07634798, -0.36653499, 0.44290673, -0.19976385, -0.54075738, -0.07060266, 0.50715054, -0.06048611, 0.21532928, 0.46809108, -0.29888511, 0.8612962, 0.70120877, -0.11342797, 0.31234354, -0.12172541, 0.36867857, 0.57311489, -0.25841225, 0.30937186, 0.43319338, -0.30448035, 0.44276338, -0.19442057, -0.06105237, 0.07619347, 0.85826993, 0.370392, 0.51481515, 0.43127521, 0.42286091, 0.29815001, 0.37128253, -0.51528729, 0.38525783, -0.34825368, 0.68510504, 
                                  -0.36528923, -0.40903577, 0.43574387, 0.26887846, -0.49254862, 0.0761596, 0.49226224, -0.40249641), ys = c(0.16086164, 0.08904024, 0.26317168, 0.12706142, 0.496562, 0.63202159, 0.14479166, -0.19131316, 0.22483671, 0.32721288, 0.33407547, 0.41168783, 0.44691359, 0.38853383, 0.47272748, 0.01222964, 0.30716705, 0.22493837, 0.33376524, 0.08054579, 0.44552458, 0.23614689, 0.21038848, 0.15921366, 0.09259038, 0.03288107, 0.34534871, 0.47612156, 0.32167526, 0.51421443, 0.32284981, 0.47036593, 0.09294232, 
                                                                                                                                             0.48309267, 0.34275967, 0.51488295, 0.05060116, 0.45923165, 0.3618746, -0.10912158, 0.65907662, 0.6057485, 0.47417973, 0.39361588, 0.17591675, 0.42652809, 0.17029707, 0.26553665, 0.54447377, 0.38566851, 0.11857527, 0.11370707, 0.41430638, 0.24956276, 0.36521058, 0.69087105, 0.57946932, 0.25645757, 0.45064757, 0.9505387, 0.11810207, 0.57196376, 0.39783889, 0.10185808, 0.08790562, 0.18624195, 0.55176786, 0.35372973, 0.46616851, -0.07534713, 0.59948077, 0.46624927, 0.12192386, 0.30753942, 0.07099046, 
                                                                                                                                             0.40442601, 0.71066846, 0.46674396, 0.17898711, 0.25507763, 0.51543839, 0.40429568, -0.03772239, 0.7194889, 0.45178849, 0.26906478, 0.3087178, 0.34675335, 0.46204643, 0.64723225, 0.3249115, 0.32183287, 0.13445957, 0.66878999, 0.42516398, 0.26407123, 0.41485899, 0.23934856, 0.22842741, 0.30230321, 0.26941446, 0.19676678, 0.21792253, 0.27349865, 0.39247351, 0.14790267, 0.14513961, 0.26896001, 0.43611756, 0.57901229, 0.39705856, 0.0420984, 0.45964811, 0.2714123, 0.36780137, 0.09362034, 0.47147282, 0.23010142, 
                                                                                                                                             0.19365556, 0.41496003, 0.17931052, 0.29747132, 0.45175449, 0.35728387, 0.41012013, 0.98701425, 0.6210168, 0.48221146, 0.58755577, 0.63709705, 0.42112135, 0.28146085, 0.61661031, 0.55821736, 0.51253129, 0.87811781, 0.88850773, 0.67310494, 0.5437265, 0.51638462, 0.65056336, 0.6364258, 0.7503134, 0.63854125, 0.89256953, 0.79789454, 0.52099256, 0.74577198, 0.51065152, 0.81218439, 0.82018093, 0.70813773, 0.62817158, 0.64363951, 0.63713466, 0.58578395, 0.53529127, 0.65132467, 0.81754816, 0.39081936, 0.89919213, 
                                                                                                                                             0.73375946, 0.39865509, 0.67358326, 0.49785904, 1.0437206, 0.86858292, 1.09317811, 0.75639546, 0.88775091, 0.77975197, 0.80523454, 0.76606136, 0.46451215, 0.40190926, 0.80943313, 0.75601744, 0.61334375, 0.77324337, 0.70177856, 0.76357539, 0.71246351, 0.44977123, 0.61934293, 0.8785121, 0.41174865, 0.66512988, 0.83484947, 0.9802876, 0.75766017, 0.75039019, 0.77968606, 0.88626305, 0.81008591, 0.84517725, 0.80178784, 0.77709806, 0.7579262, 0.6804144, 0.60245461, 0.70526103, 0.6209239, 0.91641482, 1.00884096, 
                                                                                                                                             0.29346977, 0.56222204, 0.64831007, 0.80087721, 0.54295162, 0.65293033, 1.00296912, 0.35045758, 0.62982713, 0.60260249, 0.87182416, 0.73669866, 0.4728933, 0.74572893, 0.60067099, 0.90756345, 0.84112851, 0.37052586, 0.4094974, 0.67192335, 0.50823318, 0.77016967, 0.57820106, 0.58023403, 0.89876808, 0.74184946, 0.35386246, 0.95819523, 0.72342401, 0.76203996, 0.54259166, 0.65242185, 0.93453682, 0.70089181, 0.7647349, 0.65528189, 0.50529981, 0.7806744, 0.45703265, 0.74230433, 0.44689789, 0.4455923, 1.01443372, 
                                                                                                                                             0.6379518, 0.46876241, 0.71301084), yc = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                                        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))
package:MASS
TRUE
FALSE
theta.md
list(`package:MASS` = function (y, mu, dfr, weights, limit = 20, eps = .Machine$double.eps^0.25) 
{
  if (inherits(y, "lm")) {
    mu <- y$fitted.values
    dfr <- y$df.residual
    y <- if (is.null(y$y)) 
      mu + residuals(y)
    else y$y
  }
  if (missing(weights)) 
    weights <- rep(1, length(y))
  n <- sum(weights)
  t0 <- n/sum(weights * (y/mu - 1)^2)
  a <- 2 * sum(weights * y * log(pmax(1, y)/mu)) - dfr
  it <- 0
  del <- 1
  while ((it <- it + 1) < limit && abs(del) > eps) {
    t0 <- abs(t0)
    tmp <- log((y + t0)/(mu + t0))
    top <- a - 2 * sum(weights * (y + t0) * tmp)
    bot <- 2 * sum(weights * ((y - mu)/(mu + t0) - tmp))
    del <- top/bot
    t0 <- t0 - del
  }
  if (t0 < 0) {
    t0 <- 0
    warning("estimate truncated at zero")
    attr(t0, "warn") <- gettext("estimate truncated at zero")
  }
  t0
}, function (y, mu, dfr, weights, limit = 20, eps = .Machine$double.eps^0.25) 
{
  if (inherits(y, "lm")) {
    mu <- y$fitted.values
    dfr <- y$df.residual
    y <- if (is.null(y$y)) 
      mu + residuals(y)
    else y$y
  }
  if (missing(weights)) 
    weights <- rep(1, length(y))
  n <- sum(weights)
  t0 <- n/sum(weights * (y/mu - 1)^2)
  a <- 2 * sum(weights * y * log(pmax(1, y)/mu)) - dfr
  it <- 0
  del <- 1
  while ((it <- it + 1) < limit && abs(del) > eps) {
    t0 <- abs(t0)
    tmp <- log((y + t0)/(mu + t0))
    top <- a - 2 * sum(weights * (y + t0) * tmp)
    bot <- 2 * sum(weights * ((y - mu)/(mu + t0) - tmp))
    del <- top/bot
    t0 <- t0 - del
  }
  if (t0 < 0) {
    t0 <- 0
    warning("estimate truncated at zero")
    attr(t0, "warn") <- gettext("estimate truncated at zero")
  }
  t0
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
theta.ml
list(`package:MASS` = function (y, mu, n = sum(weights), weights, limit = 10, eps = .Machine$double.eps^0.25, trace = FALSE) 
{
  score <- function(n, th, mu, y, w) sum(w * (digamma(th + y) - digamma(th) + log(th) + 1 - log(th + mu) - (y + th)/(mu + th)))
  info <- function(n, th, mu, y, w) sum(w * (-trigamma(th + y) + trigamma(th) - 1/th + 2/(mu + th) - (y + th)/(mu + th)^2))
  if (inherits(y, "lm")) {
    mu <- y$fitted.values
    y <- if (is.null(y$y)) 
      mu + residuals(y)
    else y$y
  }
  if (missing(weights)) 
    weights <- rep(1, length(y))
  t0 <- n/sum(weights * (y/mu - 1)^2)
  it <- 0
  del <- 1
  if (trace) 
    message(sprintf("theta.ml: iter %d 'theta = %f'", it, signif(t0)), domain = NA)
  while ((it <- it + 1) < limit && abs(del) > eps) {
    t0 <- abs(t0)
    del <- score(n, t0, mu, y, weights)/(i <- info(n, t0, mu, y, weights))
    t0 <- t0 + del
    if (trace) 
      message("theta.ml: iter", it, " theta =", signif(t0))
  }
  if (t0 < 0) {
    t0 <- 0
    warning("estimate truncated at zero")
    attr(t0, "warn") <- gettext("estimate truncated at zero")
  }
  if (it == limit) {
    warning("iteration limit reached")
    attr(t0, "warn") <- gettext("iteration limit reached")
  }
  attr(t0, "SE") <- sqrt(1/i)
  t0
}, function (y, mu, n = sum(weights), weights, limit = 10, eps = .Machine$double.eps^0.25, trace = FALSE) 
{
  score <- function(n, th, mu, y, w) sum(w * (digamma(th + y) - digamma(th) + log(th) + 1 - log(th + mu) - (y + th)/(mu + th)))
  info <- function(n, th, mu, y, w) sum(w * (-trigamma(th + y) + trigamma(th) - 1/th + 2/(mu + th) - (y + th)/(mu + th)^2))
  if (inherits(y, "lm")) {
    mu <- y$fitted.values
    y <- if (is.null(y$y)) 
      mu + residuals(y)
    else y$y
  }
  if (missing(weights)) 
    weights <- rep(1, length(y))
  t0 <- n/sum(weights * (y/mu - 1)^2)
  it <- 0
  del <- 1
  if (trace) 
    message(sprintf("theta.ml: iter %d 'theta = %f'", it, signif(t0)), domain = NA)
  while ((it <- it + 1) < limit && abs(del) > eps) {
    t0 <- abs(t0)
    del <- score(n, t0, mu, y, weights)/(i <- info(n, t0, mu, y, weights))
    t0 <- t0 + del
    if (trace) 
      message("theta.ml: iter", it, " theta =", signif(t0))
  }
  if (t0 < 0) {
    t0 <- 0
    warning("estimate truncated at zero")
    attr(t0, "warn") <- gettext("estimate truncated at zero")
  }
  if (it == limit) {
    warning("iteration limit reached")
    attr(t0, "warn") <- gettext("iteration limit reached")
  }
  attr(t0, "SE") <- sqrt(1/i)
  t0
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
theta.mm
list(`package:MASS` = function (y, mu, dfr, weights, limit = 10, eps = .Machine$double.eps^0.25) 
{
  if (inherits(y, "lm")) {
    mu <- y$fitted.values
    dfr <- y$df.residual
    y <- if (is.null(y$y)) 
      mu + residuals(y)
    else y$y
  }
  if (missing(weights)) 
    weights <- rep(1, length(y))
  n <- sum(weights)
  t0 <- n/sum(weights * (y/mu - 1)^2)
  it <- 0
  del <- 1
  while ((it <- it + 1) < limit && abs(del) > eps) {
    t0 <- abs(t0)
    del <- (sum(weights * ((y - mu)^2/(mu + mu^2/t0))) - dfr)/sum(weights * (y - mu)^2/(mu + t0)^2)
    t0 <- t0 - del
  }
  if (t0 < 0) {
    t0 <- 0
    warning("estimate truncated at zero")
    attr(t0, "warn") <- gettext("estimate truncated at zero")
  }
  t0
}, function (y, mu, dfr, weights, limit = 10, eps = .Machine$double.eps^0.25) 
{
  if (inherits(y, "lm")) {
    mu <- y$fitted.values
    dfr <- y$df.residual
    y <- if (is.null(y$y)) 
      mu + residuals(y)
    else y$y
  }
  if (missing(weights)) 
    weights <- rep(1, length(y))
  n <- sum(weights)
  t0 <- n/sum(weights * (y/mu - 1)^2)
  it <- 0
  del <- 1
  while ((it <- it + 1) < limit && abs(del) > eps) {
    t0 <- abs(t0)
    del <- (sum(weights * ((y - mu)^2/(mu + mu^2/t0))) - dfr)/sum(weights * (y - mu)^2/(mu + t0)^2)
    t0 <- t0 - del
  }
  if (t0 < 0) {
    t0 <- 0
    warning("estimate truncated at zero")
    attr(t0, "warn") <- gettext("estimate truncated at zero")
  }
  t0
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
topo
list(`package:MASS` = list(x = c(0.3, 1.4, 2.4, 3.6, 5.7, 1.6, 2.9, 3.4, 3.4, 4.8, 5.3, 6.2, 0.2, 0.9, 2.3, 2.5, 3, 3.5, 4.1, 4.9, 6.3, 0.9, 1.7, 2.4, 3.7, 4.5, 5.2, 6.3, 0.3, 2, 3.8, 6.3, 0.6, 1.5, 2.1, 2.1, 3.1, 4.5, 5.5, 5.7, 6.2, 0.4, 1.4, 1.4, 2.1, 2.3, 3.1, 4.1, 5.4, 6, 5.7, 3.6), y = c(6.1, 6.2, 6.1, 6.2, 6.2, 5.2, 5.1, 5.3, 5.7, 5.6, 5, 5.2, 4.3, 4.2, 4.8, 4.5, 4.5, 4.5, 4.6, 4.2, 4.3, 3.2, 3.8, 3.8, 3.5, 3.2, 3.2, 3.4, 2.4, 2.7, 2.3, 2.2, 1.7, 1.8, 1.8, 1.1, 1.1, 1.8, 1.7, 1, 1, 0.5, 0.6, 
                                                                                                                                                                                                                                                                                                      0.1, 0.7, 0.3, 0, 0.8, 0.4, 0.1, 3, 6), z = c(870, 793, 755, 690, 800, 800, 730, 728, 710, 780, 804, 855, 830, 813, 762, 765, 740, 765, 760, 790, 820, 855, 812, 773, 812, 827, 805, 840, 890, 820, 873, 875, 873, 865, 841, 862, 908, 855, 850, 882, 910, 940, 915, 890, 880, 870, 880, 960, 890, 860, 830, 705)))
package:MASS
TRUE
FALSE
Traffic
list(`package:MASS` = list(year = c(1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 
                                    1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1961, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 
                                    1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962, 1962), day = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 1, 
                                                                                                                                                                                 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92), limit = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), y = c(9, 11, 9, 20, 31, 26, 18, 19, 18, 13, 29, 40, 28, 17, 15, 21, 24, 15, 32, 22, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        24, 11, 27, 12, 41, 15, 18, 11, 19, 19, 9, 21, 22, 23, 14, 19, 15, 13, 22, 42, 29, 21, 12, 16, 17, 27, 37, 32, 25, 20, 40, 21, 18, 35, 21, 25, 34, 42, 27, 34, 47, 36, 15, 26, 27, 18, 16, 32, 28, 17, 16, 19, 18, 22, 37, 29, 18, 14, 14, 18, 21, 39, 39, 21, 15, 17, 20, 24, 30, 25, 8, 21, 9, 20, 15, 14, 30, 23, 15, 14, 16, 20, 17, 23, 16, 20, 13, 13, 9, 10, 27, 12, 7, 11, 15, 19, 32, 22, 24, 9, 10, 14, 18, 26, 38, 31, 12, 8, 22, 17, 31, 49, 23, 14, 25, 24, 18, 19, 29, 17, 17, 15, 25, 9, 16, 25, 25, 16, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        22, 21, 17, 26, 41, 25, 12, 17, 21, 19, 24, 44, 31, 21, 20, 19, 20, 29, 48, 36, 15, 16, 29, 12, 24, 26, 16, 15, 12, 22, 24, 16, 25, 14, 15, 9)))
package:MASS
TRUE
FALSE
truehist
list(`package:MASS` = function (data, nbins = "Scott", h, x0 = -h/1000, breaks, prob = TRUE, xlim = range(breaks), ymax = max(est), col = "cyan", xlab = deparse(substitute(data)), bty = "n", ...) 
{
  plot.truehist <- function(breaks, est, xlim, ymax, bty, xlab, ylab = "", density = NULL, angle = 45, col = NULL, border = NULL, lty = NULL, lwd = par("lwd"), ...) {
    n <- length(breaks)
    dev.hold()
    on.exit(dev.flush())
    plot(xlim, c(0, ymax), type = "n", xlab = xlab, ylab = ylab, bty = bty, ...)
    rect(breaks[-n], 0, breaks[-1], est, density = density, angle = angle, col = col, border = border, lty = lty, lwd = lwd)
  }
  xlab
  data <- data[is.finite(data)]
  if (missing(breaks)) {
    if (missing(h)) {
      if (is.character(nbins)) 
        nbins <- switch(casefold(nbins), scott = nclass.scott(data), `freedman-diaconis` = , fd = nclass.FD(data))
      if (!is.finite(nbins) || nbins <= 0) 
        stop("'nbins' must result in a positive integer")
      h <- diff(pretty(data, nbins))[1]
    }
    if (!is.finite(h) || h <= 0) 
      stop("'h' must be strictly positive")
    first <- floor((min(data) - x0)/h)
    last <- ceiling((max(data) - x0)/h)
    breaks <- x0 + h * c(first:last)
  }
  if (any(diff(breaks) <= 0)) 
    stop("'breaks' must be strictly increasing")
  if (min(data) < min(breaks) || max(data) > max(breaks)) 
    stop("'breaks' do not cover the data")
  db <- diff(breaks)
  if (!prob && sqrt(var(db)) > mean(db)/1000) 
    warning("uneven breaks with 'prob = FALSE' will give a misleading plot")
  bin <- cut(data, breaks, include.lowest = TRUE)
  est <- tabulate(bin, length(levels(bin)))
  if (prob) 
    est <- est/(diff(breaks) * length(data))
  plot.truehist(breaks, est, xlim, ymax, bty = bty, xlab = xlab, col = col, ...)
  invisible()
}, function (data, nbins = "Scott", h, x0 = -h/1000, breaks, prob = TRUE, xlim = range(breaks), ymax = max(est), col = "cyan", xlab = deparse(substitute(data)), bty = "n", ...) 
{
  plot.truehist <- function(breaks, est, xlim, ymax, bty, xlab, ylab = "", density = NULL, angle = 45, col = NULL, border = NULL, lty = NULL, lwd = par("lwd"), ...) {
    n <- length(breaks)
    dev.hold()
    on.exit(dev.flush())
    plot(xlim, c(0, ymax), type = "n", xlab = xlab, ylab = ylab, bty = bty, ...)
    rect(breaks[-n], 0, breaks[-1], est, density = density, angle = angle, col = col, border = border, lty = lty, lwd = lwd)
  }
  xlab
  data <- data[is.finite(data)]
  if (missing(breaks)) {
    if (missing(h)) {
      if (is.character(nbins)) 
        nbins <- switch(casefold(nbins), scott = nclass.scott(data), `freedman-diaconis` = , fd = nclass.FD(data))
      if (!is.finite(nbins) || nbins <= 0) 
        stop("'nbins' must result in a positive integer")
      h <- diff(pretty(data, nbins))[1]
    }
    if (!is.finite(h) || h <= 0) 
      stop("'h' must be strictly positive")
    first <- floor((min(data) - x0)/h)
    last <- ceiling((max(data) - x0)/h)
    breaks <- x0 + h * c(first:last)
  }
  if (any(diff(breaks) <= 0)) 
    stop("'breaks' must be strictly increasing")
  if (min(data) < min(breaks) || max(data) > max(breaks)) 
    stop("'breaks' do not cover the data")
  db <- diff(breaks)
  if (!prob && sqrt(var(db)) > mean(db)/1000) 
    warning("uneven breaks with 'prob = FALSE' will give a misleading plot")
  bin <- cut(data, breaks, include.lowest = TRUE)
  est <- tabulate(bin, length(levels(bin)))
  if (prob) 
    est <- est/(diff(breaks) * length(data))
  plot.truehist(breaks, est, xlim, ymax, bty = bty, xlab = xlab, col = col, ...)
  invisible()
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
ucv
list(`package:MASS` = function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax) 
{
  fucv <- function(h, x, n, d) .C(VR_ucv_bin, as.integer(n), as.integer(length(x)), as.double(d), x, as.double(h), u = double(1))$u
  n <- length(x)
  if (!n) 
    stop("'x' has length zero")
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5) * 4
  storage.mode(x) <- "double"
  Z <- .C(VR_den_bin, as.integer(n), as.integer(nb), d = double(1), x, cnt = integer(nb))
  d <- Z$d
  cnt <- as.integer(Z$cnt)
  h <- optimize(fucv, c(lower, upper), tol = 0.1 * lower, x = cnt, n = n, d = d)$minimum
  if (h < 1.1 * lower | h > upper - 0.1 * lower) 
    warning("minimum occurred at one end of the range")
  h
}, function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax) 
{
  fucv <- function(h, x, n, d) .C(VR_ucv_bin, as.integer(n), as.integer(length(x)), as.double(d), x, as.double(h), u = double(1))$u
  n <- length(x)
  if (!n) 
    stop("'x' has length zero")
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5) * 4
  storage.mode(x) <- "double"
  Z <- .C(VR_den_bin, as.integer(n), as.integer(nb), d = double(1), x, cnt = integer(nb))
  d <- Z$d
  cnt <- as.integer(Z$cnt)
  h <- optimize(fucv, c(lower, upper), tol = 0.1 * lower, x = cnt, n = n, d = d)$minimum
  if (h < 1.1 * lower | h > upper - 0.1 * lower) 
    warning("minimum occurred at one end of the range")
  h
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
UScereal
list(`package:MASS` = list(mfr = c(3, 2, 2, 1, 2, 1, 6, 4, 5, 1, 1, 1, 1, 6, 2, 2, 1, 2, 2, 1, 6, 2, 2, 2, 4, 2, 4, 4, 1, 4, 4, 4, 5, 1, 4, 2, 1, 5, 1, 2, 1, 2, 2, 1, 4, 2, 5, 5, 2, 1, 2, 6, 2, 3, 3, 2, 2, 1, 1, 1, 1, 1, 6, 1, 1), calories = c(212.12121, 212.12121, 100, 146.66667, 110, 173.33333, 134.32836, 134.32836, 160, 88, 160, 220, 110, 110, 100, 110, 110, 220, 110, 133.33333, 133.33333, 110, 146.66667, 125, 179.10448, 179.10448, 146.66667, 113.63636, 146.66667, 113.63636, 440, 363.63636, 120, 
                                                                                                                                                                                                                                                    146.66667, 82.70677, 186.66667, 73.33333, 149.25373, 110, 238.80597, 100, 179.10448, 208.95522, 260, 179.10448, 100, 50, 200, 160, 200, 180, 97.34513, 110, 134.32836, 134.32836, 146.66667, 110, 110, 140, 100, 146.66667, 110, 149.25373, 100, 146.66667), protein = c(12.1212121, 12.1212121, 8, 2.6666667, 2, 4, 2.9850746, 4.4776119, 1.3333333, 4.8, 1.3333333, 6, 1, 2, 2, 1, 1, 6, 2, 2.6666667, 2.6666667, 2, 1.3333333, 3.75, 4.4776119, 4.4776119, 1.3333333, 2.2727273, 1.3333333, 3.4090909, 12, 9.0909091, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1, 4, 0.7518797, 4, 1.3333333, 5.9701493, 2, 4.4776119, 2, 2.9850746, 4.4776119, 6, 4.4776119, 3, 1, 8, 4, 6, 4, 0.8849558, 2, 4.4776119, 4.4776119, 2.6666667, 6, 2, 3, 3, 2.6666667, 1, 4.4776119, 3, 2.6666667), fat = c(3.030303, 3.030303, 0, 2.6666667, 0, 2.6666667, 1.4925373, 0, 2.6666667, 1.6, 4, 4, 1, 0, 0, 0, 1, 6, 0, 1.3333333, 0, 1, 0, 0, 2.9850746, 0, 1.3333333, 0, 1.3333333, 1.1363636, 0, 9.0909091, 2, 1.3333333, 0, 1.3333333, 0.6666667, 2.9850746, 1, 2.9850746, 1, 1.4925373, 2.9850746, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         4, 1.4925373, 0, 0, 2, 1.3333333, 4, 0, 0, 0, 0, 0, 1.3333333, 0, 1, 1, 1, 1.3333333, 1, 1.4925373, 1, 1.3333333), sodium = c(393.93939, 787.87879, 280, 240, 125, 280, 298.50746, 313.43284, 293.33333, 232, 280, 280, 180, 280, 290, 90, 180, 280, 220, 186.66667, 253.33333, 125, 266.66667, 0, 238.80597, 358.20896, 180, 51.13636, 373.33333, 159.09091, 680, 227.27273, 220, 333.33333, 135.33835, 226.66667, 173.33333, 223.8806, 180, 223.8806, 220, 283.58209, 328.35821, 340, 298.50746, 320, 0, 270, 280, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       280, 0, 212.38938, 290, 0, 0, 93.33333, 230, 200, 190, 200, 333.33333, 140, 343.28358, 200, 266.66667), fibre = c(30.30303, 27.272727, 28, 2, 1, 2.666667, 5.970149, 7.462687, 0, 1.6, 0, 4, 0, 0, 1, 1, 0, 8, 1, 2.666667, 1.333333, 1, 1.333333, 3.75, 7.462687, 7.462687, 0, 0, 0, 3.409091, 12, 9.090909, 1, 2, 0, 2.666667, 0, 2.985075, 0, 4.477612, 2, 0, 4.477612, 3, 8.955224, 1, 0, 4, 6.666667, 5, 4, 0, 0, 5.970149, 4.477612, 1.333333, 1, 0, 4, 3, 0, 0, 4.477612, 3, 1.333333), carbo = c(15.15152, 21.21212, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                16, 14, 11, 24, 22.38806, 19.40299, 16, 13.6, 17.33333, 26, 12, 22, 21, 13, 12, 20, 21, 14.66667, 24, 11, 18.66667, 17.5, 17.91045, 20.89552, 17.33333, 12.5, 20, 17.04545, 68, 39.39394, 12, 15.33333, 10.52632, 26.66667, 14, 17.91045, 12, 25.37313, 15, 22.38806, 31.34328, 27, 16.41791, 20, 13, 28, 18.66667, 21, 30, 20.35398, 22, 28.35821, 29.85075, 12, 16, 21, 15, 16, 28, 13, 25.37313, 17, 21.33333), sugars = c(18.181818, 15.151515, 0, 13.333333, 14, 10.666667, 8.955224, 7.462687, 16, 0.8, 12, 14, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              13, 3, 2, 12, 13, 14, 3, 13.333333, 6.666667, 13, 14.666667, 8.75, 14.925373, 17.910448, 16, 17.045455, 12, 5.681818, 12, 12.121212, 11, 13.333333, 8.270677, 12, 2, 8.955224, 12, 19.402985, 6, 13.432836, 10.447761, 20, 20.895522, 3, 0, 12, 16, 16, 12, 1.769912, 3, 0, 0, 20, 3, 3, 14, 3, 4, 12, 4.477612, 3, 10.666667), shelf = c(3, 3, 3, 1, 2, 3, 1, 3, 2, 1, 2, 3, 2, 1, 1, 2, 2, 3, 3, 3, 3, 2, 1, 2, 3, 3, 2, 1, 2, 3, 3, 3, 2, 1, 1, 3, 2, 2, 2, 3, 1, 2, 3, 3, 3, 3, 3, 3, 2, 3, 3, 1, 1, 1, 1, 2, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        3, 3, 3, 3, 2, 1, 1, 1), potassium = c(848.48485, 969.69697, 660, 93.33333, 30, 133.33333, 186.56716, 283.58209, 46.66667, 84, 60, 210, 55, 25, 35, 20, 65, 320, 30, 160, 106.66667, 30, 33.33333, 125, 298.50746, 283.58209, 33.33333, 45.45455, 60, 96.59091, 360, 303.0303, 45, 120, 26.31579, 126.66667, 26.66667, 141.79104, 55, 238.80597, 90, 59.70149, 194.02985, 240, 388.0597, 45, 15, 220, 320, 280, 220, 26.54867, 35, 208.95522, 179.10448, 53.33333, 55, 35, 230, 110, 80, 25, 171.64179, 110, 80), vitamins = c(2, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2)))
package:MASS
TRUE
FALSE
UScrime
list(`package:MASS` = list(M = c(151, 143, 142, 136, 141, 121, 127, 131, 157, 140, 124, 134, 128, 135, 152, 142, 143, 135, 130, 125, 126, 157, 132, 131, 130, 131, 135, 152, 119, 166, 140, 125, 147, 126, 123, 150, 177, 133, 149, 145, 148, 141, 162, 136, 139, 126, 130), So = c(1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0), Ed = c(91, 113, 89, 121, 121, 110, 111, 109, 90, 118, 105, 108, 113, 117, 87, 88, 110, 
                                                                                                                                                                                                                                                                                                                                                                                                                                         104, 116, 108, 108, 89, 96, 116, 116, 121, 109, 112, 107, 89, 93, 109, 104, 118, 102, 100, 87, 104, 88, 104, 122, 109, 99, 121, 88, 104, 121), Po1 = c(58, 103, 45, 149, 109, 118, 82, 115, 65, 71, 121, 75, 67, 62, 57, 81, 66, 123, 128, 113, 74, 47, 87, 78, 63, 160, 69, 82, 166, 58, 55, 90, 63, 97, 97, 109, 58, 51, 61, 82, 72, 56, 75, 95, 46, 106, 90), Po2 = c(56, 95, 44, 141, 101, 115, 79, 109, 62, 68, 116, 71, 60, 61, 53, 77, 63, 115, 128, 105, 67, 44, 83, 73, 57, 143, 71, 76, 157, 54, 54, 81, 64, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  97, 87, 98, 56, 47, 54, 74, 66, 54, 70, 96, 41, 97, 91), LF = c(510, 583, 533, 577, 591, 547, 519, 542, 553, 632, 580, 595, 624, 595, 530, 497, 537, 537, 536, 567, 602, 512, 564, 574, 641, 631, 540, 571, 521, 521, 535, 586, 560, 542, 526, 531, 638, 599, 515, 560, 601, 523, 522, 574, 480, 599, 623), M.F = c(950, 1012, 969, 994, 985, 964, 982, 969, 955, 1029, 966, 972, 972, 986, 986, 956, 977, 978, 934, 985, 984, 962, 953, 1038, 984, 1071, 965, 1018, 938, 973, 1045, 964, 972, 990, 948, 964, 974, 1024, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      953, 981, 998, 968, 996, 1012, 968, 989, 1049), Pop = c(33, 13, 18, 157, 18, 25, 4, 50, 39, 7, 101, 47, 28, 22, 30, 33, 10, 31, 51, 78, 34, 22, 43, 7, 14, 3, 6, 10, 168, 46, 6, 97, 23, 18, 113, 9, 24, 7, 36, 96, 9, 4, 40, 29, 19, 40, 3), NW = c(301, 102, 219, 80, 30, 44, 139, 179, 286, 15, 106, 59, 10, 46, 72, 321, 6, 170, 24, 94, 12, 423, 92, 36, 26, 77, 4, 79, 89, 254, 20, 82, 95, 21, 76, 24, 349, 40, 165, 126, 19, 2, 208, 36, 49, 24, 22), U1 = c(108, 96, 94, 102, 91, 84, 97, 79, 81, 100, 77, 83, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           77, 77, 92, 116, 114, 89, 78, 130, 102, 97, 83, 142, 70, 102, 80, 103, 92, 72, 135, 105, 76, 102, 124, 87, 76, 99, 86, 88, 84, 107, 73, 111, 135, 78, 113), U2 = c(41, 36, 33, 39, 20, 29, 38, 35, 28, 24, 35, 31, 25, 27, 43, 47, 35, 34, 34, 58, 33, 34, 32, 42, 21, 41, 22, 28, 36, 26, 40, 43, 24, 35, 50, 38, 28, 27, 35, 31, 20, 37, 27, 37, 53, 25, 40), GDP = c(394, 557, 318, 673, 578, 689, 620, 472, 421, 526, 657, 580, 507, 529, 405, 427, 487, 631, 627, 626, 557, 288, 513, 540, 486, 674, 564, 537, 637, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   396, 453, 617, 462, 589, 572, 559, 382, 425, 395, 488, 590, 489, 496, 622, 457, 593, 588), Ineq = c(261, 194, 250, 167, 174, 126, 168, 206, 239, 174, 170, 172, 206, 190, 264, 247, 166, 165, 135, 166, 195, 276, 227, 176, 196, 152, 139, 215, 154, 237, 200, 163, 233, 166, 158, 153, 254, 225, 251, 228, 144, 170, 224, 162, 249, 171, 160), Prob = c(0.084602, 0.029599, 0.083401, 0.015801, 0.041399, 0.034201, 0.0421, 0.040099, 0.071697, 0.044498, 0.016201, 0.031201, 0.045302, 0.0532, 0.0691, 0.052099, 0.076299, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            0.119804, 0.019099, 0.034801, 0.0228, 0.089502, 0.0307, 0.041598, 0.069197, 0.041698, 0.036099, 0.038201, 0.0234, 0.075298, 0.041999, 0.042698, 0.049499, 0.040799, 0.0207, 0.0069, 0.045198, 0.053998, 0.047099, 0.038801, 0.0251, 0.088904, 0.054902, 0.0281, 0.056202, 0.046598, 0.052802), Time = c(26.2011, 25.2999, 24.3006, 29.9012, 21.2998, 20.9995, 20.6993, 24.5988, 29.4001, 19.5994, 41.6, 34.2984, 36.2993, 21.501, 22.7008, 26.0991, 19.1002, 18.1996, 24.9008, 26.401, 37.5998, 37.0994, 25.1989, 17.6, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    21.9003, 22.1005, 28.4999, 25.8006, 36.7009, 28.3011, 21.7998, 30.9014, 25.5005, 21.6997, 37.4011, 44.0004, 31.6995, 16.6999, 27.3004, 29.3004, 30.0001, 12.1996, 31.9989, 30.0001, 32.5996, 16.6999, 16.0997), y = c(791, 1635, 578, 1969, 1234, 682, 963, 1555, 856, 705, 1674, 849, 511, 664, 798, 946, 539, 929, 750, 1225, 742, 439, 1216, 968, 523, 1993, 342, 1216, 1043, 696, 373, 754, 1072, 923, 653, 1272, 831, 566, 826, 1151, 880, 542, 823, 1030, 455, 508, 849)))
package:MASS
TRUE
FALSE
VA
list(`package:MASS` = list(stime = c(72, 411, 228, 126, 118, 10, 82, 110, 314, 100, 42, 8, 144, 25, 11, 30, 384, 4, 54, 13, 123, 97, 153, 59, 117, 16, 151, 22, 56, 21, 18, 139, 20, 31, 52, 287, 18, 51, 122, 27, 54, 7, 63, 392, 10, 8, 92, 35, 117, 132, 12, 162, 3, 95, 177, 162, 216, 553, 278, 12, 260, 200, 156, 182, 143, 105, 103, 250, 100, 999, 112, 87, 231, 242, 991, 111, 1, 587, 389, 33, 25, 357, 467, 201, 1, 30, 44, 283, 15, 25, 103, 21, 13, 87, 2, 20, 7, 24, 99, 8, 99, 61, 25, 95, 80, 51, 29, 
                                     24, 18, 83, 31, 51, 90, 52, 73, 8, 36, 48, 7, 140, 186, 84, 19, 45, 80, 52, 164, 19, 53, 15, 43, 340, 133, 111, 231, 378, 49), status = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                                                                                                                                                                               1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), treat = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), age = c(69, 64, 38, 63, 65, 49, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              69, 68, 43, 70, 81, 63, 63, 52, 48, 61, 42, 35, 63, 56, 55, 67, 63, 65, 46, 53, 69, 68, 43, 55, 42, 64, 65, 65, 55, 66, 60, 67, 53, 62, 67, 72, 48, 68, 67, 61, 60, 62, 38, 50, 63, 64, 43, 34, 66, 62, 52, 47, 63, 68, 45, 41, 66, 62, 60, 66, 38, 53, 37, 54, 60, 48, 52, 70, 50, 62, 65, 58, 62, 64, 63, 58, 64, 52, 35, 63, 70, 51, 40, 69, 36, 71, 62, 60, 44, 54, 66, 49, 72, 68, 62, 71, 70, 61, 71, 59, 67, 60, 69, 57, 39, 62, 50, 43, 70, 66, 61, 81, 58, 63, 60, 62, 42, 69, 63, 45, 68, 39, 66, 63, 49, 64, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              65, 64, 67, 65, 37), Karn = c(60, 70, 60, 60, 70, 20, 40, 80, 50, 70, 60, 40, 30, 80, 70, 60, 60, 40, 80, 60, 40, 60, 60, 30, 80, 30, 50, 60, 80, 40, 20, 80, 30, 75, 70, 60, 30, 60, 80, 60, 70, 50, 50, 40, 40, 20, 70, 40, 80, 80, 50, 80, 30, 80, 50, 80, 50, 70, 60, 40, 80, 80, 70, 90, 90, 80, 80, 70, 60, 90, 80, 80, 50, 50, 70, 70, 20, 60, 90, 30, 20, 70, 90, 80, 50, 70, 60, 90, 50, 30, 70, 20, 30, 60, 40, 30, 20, 60, 70, 80, 85, 70, 70, 70, 50, 30, 40, 40, 40, 99, 80, 60, 60, 60, 60, 50, 70, 10, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            40, 70, 90, 80, 50, 40, 40, 60, 70, 30, 60, 30, 60, 80, 75, 60, 70, 80, 30), diag.time = c(7, 5, 3, 9, 11, 5, 10, 29, 18, 6, 4, 58, 4, 9, 11, 3, 9, 2, 4, 4, 3, 5, 14, 2, 3, 4, 12, 4, 12, 2, 15, 2, 5, 3, 2, 25, 4, 1, 28, 8, 1, 7, 11, 4, 23, 19, 10, 6, 2, 5, 4, 5, 3, 4, 16, 5, 15, 2, 12, 12, 5, 12, 2, 2, 8, 11, 5, 8, 13, 12, 6, 3, 8, 1, 7, 3, 21, 3, 2, 6, 36, 13, 2, 28, 7, 11, 13, 2, 13, 2, 22, 4, 2, 2, 36, 9, 11, 8, 3, 2, 4, 2, 2, 1, 17, 87, 8, 2, 5, 3, 3, 5, 22, 3, 3, 5, 8, 4, 4, 3, 3, 4, 10, 3, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       4, 4, 15, 4, 12, 5, 11, 10, 1, 5, 18, 4, 3), cell = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4), prior = c(1, 2, 1, 2, 2, 1, 2, 1, 1, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   1, 1, 2, 1, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 1, 1)))
package:MASS
TRUE
FALSE
waders
list(`package:MASS` = list(S1 = c(12, 99, 197, 0, 77, 19, 1023, 87, 788, 82, 474, 77, 22, 0, 0), S2 = c(2027, 2112, 160, 17, 1948, 203, 2655, 745, 2174, 350, 930, 249, 144, 791, 360), S3 = c(0, 9, 0, 0, 0, 48, 0, 1447, 0, 760, 0, 160, 0, 0, 128), S4 = c(0, 87, 4, 3, 19, 45, 18, 125, 19, 197, 10, 136, 4, 0, 43), S5 = c(2070, 3481, 126, 50, 310, 20, 320, 4330, 224, 858, 316, 999, 1, 4, 364), S6 = c(39, 470, 17, 6, 1, 433, 49, 789, 178, 962, 161, 645, 1, 38, 1628), S7 = c(219, 2063, 1, 4, 1, 0, 8, 228, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          1, 10, 0, 15, 0, 1, 63), S8 = c(153, 28, 32, 7, 64, 0, 121, 529, 423, 511, 90, 851, 10, 56, 287), S9 = c(0, 17, 0, 0, 0, 11, 9, 289, 0, 251, 0, 101, 0, 1, 328), S10 = c(15, 145, 2, 1, 22, 167, 82, 904, 195, 987, 39, 723, 2, 30, 641), S11 = c(51, 31, 9, 2, 81, 12, 48, 34, 162, 191, 48, 266, 9, 54, 850), S12 = c(8336, 1515, 477, 16, 2792, 1, 3411, 1710, 2161, 34, 1183, 495, 125, 95, 83), S13 = c(2031, 1917, 1, 0, 221, 0, 14, 7869, 25, 87, 166, 83, 5, 0, 67), S14 = c(14941, 17321, 548, 0, 7422, 26, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               9101, 2247, 1784, 417, 4626, 1253, 411, 1726, 48), S15 = c(19, 3378, 13, 3, 10, 1790, 43, 4558, 3, 4496, 65, 1864, 0, 0, 6499), S16 = c(3566, 20164, 273, 69, 4519, 2916, 3230, 40880, 1254, 15835, 127, 4107, 3, 0, 9094), S17 = c(0, 177, 0, 1, 12, 473, 587, 7166, 0, 5327, 4, 1939, 0, 0, 5647), S18 = c(5, 1759, 0, 0, 0, 658, 10, 1632, 0, 1312, 0, 623, 0, 0, 1333), S19 = c(0, 53, 0, 0, 0, 55, 5, 498, 0, 1020, 0, 527, 0, 0, 582)))
package:MASS
TRUE
FALSE
whiteside
list(`package:MASS` = list(Insul = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2), Temp = c(-0.8, -0.7, 0.4, 2.5, 2.9, 3.2, 3.6, 3.9, 4.2, 4.3, 5.4, 6, 6, 6, 6.2, 6.3, 6.9, 7, 7.4, 7.5, 7.5, 7.6, 8, 8.5, 9.1, 10.2, -0.7, 0.8, 1, 1.4, 1.5, 1.6, 2.3, 2.5, 2.5, 3.1, 3.9, 4, 4, 4.2, 4.3, 4.6, 4.7, 4.9, 4.9, 4.9, 5, 5.3, 6.2, 7.1, 7.2, 7.5, 8, 8.7, 8.8, 9.7), Gas = c(7.2, 6.9, 6.4, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        6, 5.8, 5.8, 5.6, 4.7, 5.8, 5.2, 4.9, 4.9, 4.3, 4.4, 4.5, 4.6, 3.7, 3.9, 4.2, 4, 3.9, 3.5, 4, 3.6, 3.1, 2.6, 4.8, 4.6, 4.7, 4, 4.2, 4.2, 4.1, 4, 3.5, 3.2, 3.9, 3.5, 3.7, 3.5, 3.5, 3.7, 3.5, 3.4, 3.7, 4, 3.6, 3.7, 2.8, 3, 2.8, 2.6, 2.7, 2.8, 1.3, 1.5)))
package:MASS
TRUE
FALSE
width.SJ
list(`package:MASS` = function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax, method = c("ste", "dpi")) 
{
  fSD <- function(h, x, alph2, c1, n, d) (c1/SDh(x, alph2 * h^(5/7), n, d))^(1/5) - h
  SDh <- function(x, h, n, d) .C(VR_phi4_bin, as.integer(n), as.integer(length(x)), as.double(d), x, as.double(h), u = double(1))$u
  TDh <- function(x, h, n, d) .C(VR_phi6_bin, as.integer(n), as.integer(length(x)), as.double(d), x, as.double(h), u = double(1))$u
  method <- match.arg(method)
  n <- length(x)
  if (!n) 
    stop("'x' has length zero")
  storage.mode(x) <- "double"
  Z <- .C(VR_den_bin, as.integer(n), as.integer(nb), d = double(1), x, cnt = integer(nb))
  d <- Z$d
  cnt <- as.integer(Z$cnt)
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5)
  scale <- min(sqrt(var(x)), IQR(x)/1.349)
  a <- 1.24 * scale * n^(-1/7)
  b <- 1.23 * scale * n^(-1/9)
  c1 <- 1/(2 * sqrt(pi) * n)
  TD <- -TDh(cnt, b, n, d)
  alph2 <- 1.357 * (SDh(cnt, a, n, d)/TD)^(1/7)
  if (method == "dpi") 
    res <- (c1/SDh(cnt, (2.394/(n * TD))^(1/7), n, d))^(1/5)
  else {
    if (fSD(lower, cnt, alph2, c1, n, d) * fSD(upper, cnt, alph2, c1, n, d) > 0) 
      stop("no solution in the specified range of bandwidths")
    res <- uniroot(fSD, c(lower, upper), tol = 0.1 * lower, x = cnt, alph2 = alph2, c1 = c1, n = n, d = d)$root
  }
  4 * res
}, function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax, method = c("ste", "dpi")) 
{
  fSD <- function(h, x, alph2, c1, n, d) (c1/SDh(x, alph2 * h^(5/7), n, d))^(1/5) - h
  SDh <- function(x, h, n, d) .C(VR_phi4_bin, as.integer(n), as.integer(length(x)), as.double(d), x, as.double(h), u = double(1))$u
  TDh <- function(x, h, n, d) .C(VR_phi6_bin, as.integer(n), as.integer(length(x)), as.double(d), x, as.double(h), u = double(1))$u
  method <- match.arg(method)
  n <- length(x)
  if (!n) 
    stop("'x' has length zero")
  storage.mode(x) <- "double"
  Z <- .C(VR_den_bin, as.integer(n), as.integer(nb), d = double(1), x, cnt = integer(nb))
  d <- Z$d
  cnt <- as.integer(Z$cnt)
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5)
  scale <- min(sqrt(var(x)), IQR(x)/1.349)
  a <- 1.24 * scale * n^(-1/7)
  b <- 1.23 * scale * n^(-1/9)
  c1 <- 1/(2 * sqrt(pi) * n)
  TD <- -TDh(cnt, b, n, d)
  alph2 <- 1.357 * (SDh(cnt, a, n, d)/TD)^(1/7)
  if (method == "dpi") 
    res <- (c1/SDh(cnt, (2.394/(n * TD))^(1/7), n, d))^(1/5)
  else {
    if (fSD(lower, cnt, alph2, c1, n, d) * fSD(upper, cnt, alph2, c1, n, d) > 0) 
      stop("no solution in the specified range of bandwidths")
    res <- uniroot(fSD, c(lower, upper), tol = 0.1 * lower, x = cnt, alph2 = alph2, c1 = c1, n = n, d = d)$root
  }
  4 * res
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
write.matrix
list(`package:MASS` = function (x, file = "", sep = " ", blocksize) 
{
  x <- as.matrix(x)
  p <- ncol(x)
  cn <- colnames(x)
  if (!missing(blocksize) && blocksize > 0) {
    cat(cn, file = file, sep = c(rep(sep, p - 1), "\n"))
    nlines <- 0
    nr <- nrow(x)
    while (nlines < nr) {
      nb <- min(blocksize, nr - nlines)
      cat(format(t(x[nlines + (1:nb), ])), file = file, append = TRUE, sep = c(rep(sep, p - 1), "\n"))
      nlines <- nlines + nb
    }
  }
  else cat(c(cn, format(t(x))), file = file, sep = c(rep(sep, p - 1), "\n"))
}, function (x, file = "", sep = " ", blocksize) 
{
  x <- as.matrix(x)
  p <- ncol(x)
  cn <- colnames(x)
  if (!missing(blocksize) && blocksize > 0) {
    cat(cn, file = file, sep = c(rep(sep, p - 1), "\n"))
    nlines <- 0
    nr <- nrow(x)
    while (nlines < nr) {
      nb <- min(blocksize, nr - nlines)
      cat(format(t(x[nlines + (1:nb), ])), file = file, append = TRUE, sep = c(rep(sep, p - 1), "\n"))
      nlines <- nlines + nb
    }
  }
  else cat(c(cn, format(t(x))), file = file, sep = c(rep(sep, p - 1), "\n"))
})
c("package:MASS", "namespace:MASS")
c(TRUE, FALSE)
c(FALSE, TRUE)
wtloss
list(`package:MASS` = list(Days = c(0, 4, 7, 7, 11, 18, 24, 30, 32, 43, 46, 60, 64, 70, 71, 71, 73, 74, 84, 88, 95, 102, 106, 109, 115, 122, 133, 137, 140, 143, 147, 148, 149, 150, 153, 156, 161, 164, 165, 165, 170, 176, 179, 198, 214, 218, 221, 225, 233, 238, 241, 246), Weight = c(184.35, 182.51, 180.45, 179.91, 177.91, 175.81, 173.11, 170.06, 169.31, 165.1, 163.11, 158.3, 155.8, 154.31, 153.86, 154.2, 152.2, 152.8, 150.3, 147.8, 146.1, 145.6, 142.5, 142.3, 139.4, 137.9, 133.7, 133.7, 133.3, 131.2, 
                                                                                                                                                                                                                                                                                           133, 132.2, 130.8, 131.3, 129, 127.9, 126.9, 127.7, 129.5, 128.4, 125.4, 124.9, 124.9, 118.2, 118.2, 115.3, 115.7, 116, 115.5, 112.6, 114, 112.6)))
package:MASS
TRUE
FALSE


#############################################################################################3
library(methods)
.__C__(
  list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "(", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "language")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("("), "language", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = (NULL), validity = NULL, access = list(), className = "(", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "(", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            if (!is(value, "language")) 
              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("("), "language", dQuote(class(value))), domain = NA)
            value
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = (NULL), validity = NULL, access = list(), className = "(", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
  c("package:methods", "namespace:methods")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
  .__C__.environment
  list(`package:methods` = new("classRepresentation", slots = list(.xData = "environment"), contains = list(environment = new("SClassExtension", subClass = ".environment", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
    from@.xData, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.xData <- value
        from
      }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), refObject = new("SClassExtension", subClass = ".environment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- as(from, "environment", strict = strict)
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "environment", TRUE)
          as(.value, "refObject") <- value
          value <- .value
          {
            from@.xData <- value
            from
          }
        }, simple = FALSE, by = "environment", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".environment", package = "methods", subclasses = list(sourceEnvironment = new("SClassExtension", subClass = "sourceEnvironment", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
        {
          value <- new(".environment")
          for (what in ".xData") slot(value, what) <- slot(from, what)
          value
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            for (what in ".xData") slot(from, what) <- slot(value, what)
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), envRefClass = new("SClassExtension", subClass = "envRefClass", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
          {
            class(from) <- ".environment"
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in ".xData") slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refGeneratorSlot = new("SClassExtension", subClass = "refGeneratorSlot", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                class(from) <- "envRefClass"
                from
              }
              {
                class(from) <- ".environment"
                from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "envRefClass", TRUE)
                as(.value, ".environment") <- value
                value <- .value
                {
                  for (what in ".xData") slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), localRefClass = new("SClassExtension", subClass = "localRefClass", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  class(from) <- "envRefClass"
                  from
                }
                {
                  class(from) <- ".environment"
                  from
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "envRefClass", TRUE)
                  as(.value, ".environment") <- value
                  value <- .value
                  {
                    for (what in ".xData") slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.xData = "environment"), contains = list(environment = new("SClassExtension", subClass = ".environment", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                  from@.xData, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      from@.xData <- value
                      from
                    }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), refObject = new("SClassExtension", subClass = ".environment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- as(from, "environment", strict = strict)
                      from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "environment", TRUE)
                        as(.value, "refObject") <- value
                        value <- .value
                        {
                          from@.xData <- value
                          from
                        }
                      }, simple = FALSE, by = "environment", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".environment", package = "methods", subclasses = list(sourceEnvironment = new("SClassExtension", subClass = "sourceEnvironment", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        value <- new(".environment")
                        for (what in ".xData") slot(value, what) <- slot(from, what)
                        value
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          for (what in ".xData") slot(from, what) <- slot(value, what)
                          from
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), envRefClass = new("SClassExtension", subClass = "envRefClass", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          class(from) <- ".environment"
                          from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            for (what in ".xData") slot(from, what) <- slot(value, what)
                            from
                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refGeneratorSlot = new("SClassExtension", subClass = "refGeneratorSlot", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            from <- {
                              class(from) <- "envRefClass"
                              from
                            }
                            {
                              class(from) <- ".environment"
                              from
                            }
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "envRefClass", TRUE)
                              as(.value, ".environment") <- value
                              value <- .value
                              {
                                for (what in ".xData") slot(from, what) <- slot(value, what)
                                from
                              }
                            }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), localRefClass = new("SClassExtension", subClass = "localRefClass", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              from <- {
                                class(from) <- "envRefClass"
                                from
                              }
                              {
                                class(from) <- ".environment"
                                from
                              }
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "envRefClass", TRUE)
                                as(.value, ".environment") <- value
                                value <- .value
                                {
                                  for (what in ".xData") slot(from, what) <- slot(value, what)
                                  from
                                }
                              }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
  c("package:methods", "namespace:methods")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
  .__C__.externalptr
  list(`package:methods` = new("classRepresentation", slots = list(.xData = "externalptr"), contains = list(externalptr = new("SClassExtension", subClass = ".externalptr", superClass = "externalptr", package = "methods", coerce = function (from, strict = TRUE) 
    from@.xData, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.xData <- value
        from
      }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), refObject = new("SClassExtension", subClass = ".externalptr", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- as(from, "externalptr", strict = strict)
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "externalptr", TRUE)
          as(.value, "refObject") <- value
          value <- .value
          {
            from@.xData <- value
            from
          }
        }, simple = FALSE, by = "externalptr", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".externalptr", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.xData = "externalptr"), contains = list(externalptr = new("SClassExtension", subClass = ".externalptr", superClass = "externalptr", package = "methods", coerce = function (from, strict = TRUE) 
          from@.xData, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              from@.xData <- value
              from
            }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), refObject = new("SClassExtension", subClass = ".externalptr", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- as(from, "externalptr", strict = strict)
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "externalptr", TRUE)
                as(.value, "refObject") <- value
                value <- .value
                {
                  from@.xData <- value
                  from
                }
              }, simple = FALSE, by = "externalptr", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".externalptr", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
  c("package:methods", "namespace:methods")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
  .__C__.name
  list(`package:methods` = new("classRepresentation", slots = list(.xData = "name"), contains = list(name = new("SClassExtension", subClass = ".name", superClass = "name", package = "methods", coerce = function (from, strict = TRUE) 
    from@.xData, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.xData <- value
        from
      }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), language = new("SClassExtension", subClass = ".name", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- as(from, "name", strict = strict)
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "name", TRUE)
          as(.value, "language") <- value
          value <- .value
          {
            from@.xData <- value
            from
          }
        }, simple = FALSE, by = "name", dataPart = FALSE, distance = 2), refObject = new("SClassExtension", subClass = ".name", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- as(from, "name", strict = strict)
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "name", TRUE)
            as(.value, "refObject") <- value
            value <- .value
            {
              from@.xData <- value
              from
            }
          }, simple = FALSE, by = "name", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".name", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.xData = "name"), contains = list(name = new("SClassExtension", subClass = ".name", superClass = "name", package = "methods", coerce = function (from, strict = TRUE) 
            from@.xData, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                from@.xData <- value
                from
              }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), language = new("SClassExtension", subClass = ".name", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- as(from, "name", strict = strict)
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "name", TRUE)
                  as(.value, "language") <- value
                  value <- .value
                  {
                    from@.xData <- value
                    from
                  }
                }, simple = FALSE, by = "name", dataPart = FALSE, distance = 2), refObject = new("SClassExtension", subClass = ".name", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- as(from, "name", strict = strict)
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "name", TRUE)
                    as(.value, "refObject") <- value
                    value <- .value
                    {
                      from@.xData <- value
                      from
                    }
                  }, simple = FALSE, by = "name", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".name", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
  c("package:methods", "namespace:methods")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
  .__C__.NULL
  list(`package:methods` = new("classRepresentation", slots = list(.xData = "NULL"), contains = list(`NULL` = new("SClassExtension", subClass = ".NULL", superClass = "NULL", package = "methods", coerce = function (from, strict = TRUE) 
    from@.xData, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.xData <- value
        from
      }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), OptionalFunction = new("SClassExtension", subClass = ".NULL", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- as(from, "NULL", strict = strict)
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "NULL", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            from@.xData <- value
            from
          }
        }, simple = FALSE, by = "NULL", dataPart = FALSE, distance = 2), optionalMethod = new("SClassExtension", subClass = ".NULL", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- as(from, "NULL", strict = strict)
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "NULL", TRUE)
            as(.value, "optionalMethod") <- value
            value <- .value
            {
              from@.xData <- value
              from
            }
          }, simple = FALSE, by = "NULL", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".NULL", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.xData = "NULL"), contains = list(`NULL` = new("SClassExtension", subClass = ".NULL", superClass = "NULL", package = "methods", coerce = function (from, strict = TRUE) 
            from@.xData, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                from@.xData <- value
                from
              }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), OptionalFunction = new("SClassExtension", subClass = ".NULL", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- as(from, "NULL", strict = strict)
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "NULL", TRUE)
                  as(.value, "OptionalFunction") <- value
                  value <- .value
                  {
                    from@.xData <- value
                    from
                  }
                }, simple = FALSE, by = "NULL", dataPart = FALSE, distance = 2), optionalMethod = new("SClassExtension", subClass = ".NULL", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- as(from, "NULL", strict = strict)
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "NULL", TRUE)
                    as(.value, "optionalMethod") <- value
                    value <- .value
                    {
                      from@.xData <- value
                      from
                    }
                  }, simple = FALSE, by = "NULL", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".NULL", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
  c("package:methods", "namespace:methods")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
  .__C__.Other
  list(`package:methods` = new("classRepresentation", slots = list(label = "character"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".Other", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(label = "character"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = ".Other", package = "methods", 
                                                                                                                                                                                                                                                                                                                         subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
  c("package:methods", "namespace:methods")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
  .__C__{
    list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "{", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "language")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("{"), "language", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = {
        }, validity = NULL, access = list(), className = "{", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "{", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "language")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("{"), "language", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = {
            }, validity = NULL, access = list(), className = "{", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
    c("package:methods", "namespace:methods")
    c(TRUE, FALSE)
    c(FALSE, TRUE)
    .__C__<-
      list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "<-", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            if (!is(value, "language")) 
              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("<-"), "language", dQuote(class(value))), domain = NA)
            value
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = "<undef>" <- NULL, validity = NULL, access = list(), className = "<-", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "<-", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                if (!is(value, "language")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("<-"), "language", dQuote(class(value))), domain = NA)
                value
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = "<undef>" <- NULL, validity = NULL, access = list(), className = "<-", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
    c("package:methods", "namespace:methods")
    c(TRUE, FALSE)
    c(FALSE, TRUE)
    .__C__activeBindingFunction
    list(`package:methods` = new("classRepresentation", slots = list(.Data = "function"), contains = list(`function` = new("SClassExtension", subClass = "activeBindingFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
    {
      attributes(from) <- NULL
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.Data <- as(value, "function", strict = FALSE)
        from
      }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "activeBindingFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            from@.Data <- as(value, "function", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "activeBindingFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "function", TRUE)
            as(.value, "PossibleMethod") <- value
            value <- .value
            {
              from@.Data <- as(value, "function", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = getClass("S4")@prototype, validity = NULL, access = list(), className = "activeBindingFunction", package = "methods", subclasses = list(defaultBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "activeBindingFunction", package = "methods", coerce = function (from, strict = TRUE) 
          {
            value <- new("activeBindingFunction")
            for (what in ".Data") slot(value, what) <- slot(from, what)
            value
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in ".Data") slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function"), contains = list(`function` = new("SClassExtension", subClass = "activeBindingFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
            {
              attributes(from) <- NULL
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                from@.Data <- as(value, "function", strict = FALSE)
                from
              }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "activeBindingFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "function", TRUE)
                  as(.value, "OptionalFunction") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "function", strict = FALSE)
                    from
                  }
                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "activeBindingFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  if (strict) 
                    from <- from@.Data
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "function", TRUE)
                    as(.value, "PossibleMethod") <- value
                    value <- .value
                    {
                      from@.Data <- as(value, "function", strict = FALSE)
                      from
                    }
                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = getClass("S4")@prototype, validity = NULL, access = list(), className = "activeBindingFunction", package = "methods", subclasses = list(defaultBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "activeBindingFunction", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    value <- new("activeBindingFunction")
                    for (what in ".Data") slot(value, what) <- slot(from, what)
                    value
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      for (what in ".Data") slot(from, what) <- slot(value, what)
                      from
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
    c("package:methods", "namespace:methods")
    c(TRUE, FALSE)
    c(FALSE, TRUE)
    .__C__anova
    list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(data.frame = new("SClassExtension", subClass = "anova", superClass = "data.frame", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        S3Part(from, S3Class = "data.frame")
      else from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from) <- value
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "anova", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          if (strict) 
            S3Part(from, S3Class = "data.frame")
          else from
        }
        {
          if (strict) 
            S3Part(from, S3Class = "oldClass")
          else from
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "data.frame", TRUE)
          as(.value, "oldClass") <- value
          value <- .value
          {
            S3Part(from) <- value
            from
          }
        }, simple = TRUE, by = "data.frame", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "anova", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(data.frame = new("SClassExtension", subClass = "anova", superClass = "data.frame", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            S3Part(from, S3Class = "data.frame")
          else from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            S3Part(from) <- value
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "anova", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              if (strict) 
                S3Part(from, S3Class = "data.frame")
              else from
            }
            {
              if (strict) 
                S3Part(from, S3Class = "oldClass")
              else from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "data.frame", TRUE)
              as(.value, "oldClass") <- value
              value <- .value
              {
                S3Part(from) <- value
                from
              }
}, simple = TRUE, by = "data.frame", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "anova", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__anova.glm
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "anova.glm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "anova.glm", package = "methods", subclasses = list(anova.glm.null = new("SClassExtension", subClass = "anova.glm.null", superClass = "anova.glm", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "anova.glm")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "anova.glm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from) <- value
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "anova.glm", package = "methods", subclasses = list(anova.glm.null = new("SClassExtension", subClass = "anova.glm.null", superClass = "anova.glm", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "anova.glm")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__anova.glm.null
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(anova.glm = new("SClassExtension", subClass = "anova.glm.null", superClass = "anova.glm", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "anova.glm")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "anova.glm.null", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "anova.glm")
      else from
    }
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
      as({
        S3Part(from) <- value
        from
      }, "anova.glm.null"), simple = TRUE, by = "anova.glm", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "anova.glm.null", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(anova.glm = new("SClassExtension", subClass = "anova.glm.null", superClass = "anova.glm", package = "methods", coerce = function (from, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "anova.glm")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "anova.glm.null", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            if (strict) 
              S3Part(from, S3Class = "anova.glm")
            else from
          }
          {
            if (strict) 
              S3Part(from, S3Class = "oldClass")
            else from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
            as({
              S3Part(from) <- value
              from
            }, "anova.glm.null"), simple = TRUE, by = "anova.glm", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "anova.glm.null", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__ANY
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "ANY", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "ANY", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__aov
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(lm = new("SClassExtension", subClass = "aov", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "lm")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "aov", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "lm")
      else from
    }
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
      as({
        S3Part(from) <- value
        from
      }, "aov"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "aov", package = "methods", subclasses = list(maov = new("SClassExtension", subClass = "maov", superClass = "aov", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "aov")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(lm = new("SClassExtension", subClass = "aov", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            S3Part(from, S3Class = "lm")
          else from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            S3Part(from) <- value
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "aov", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              if (strict) 
                S3Part(from, S3Class = "lm")
              else from
            }
            {
              if (strict) 
                S3Part(from, S3Class = "oldClass")
              else from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
              as({
                S3Part(from) <- value
                from
              }, "aov"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "aov", package = "methods", subclasses = list(maov = new("SClassExtension", subClass = "maov", superClass = "aov", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  S3Part(from, S3Class = "aov")
                else from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  S3Part(from) <- value
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__array
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(structure = new("SClassExtension", subClass = "array", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "structure")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "structure", dQuote("array"), "structure", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "array", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
      as.vector(from), test = function (object) 
        TRUE, replace = function (from, to, value) 
          as({
            attributes(value) <- attributes(from)
            value
          }, "array"), simple = FALSE, by = "structure", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = numeric(0), validity = NULL, access = list(), className = "array", package = "methods", subclasses = list(matrix = new("SClassExtension", subClass = "matrix", superClass = "array", package = "methods", coerce = function (from, strict = TRUE) 
          {
            class(from) <- "array"
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              class(value) <- "matrix"
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), mts = new("SClassExtension", subClass = "mts", superClass = "array", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                .dm <- dim(from)
                .dn <- dimnames(from)
                attributes(from) <- NULL
                dim(from) <- .dm
                dimnames(from) <- .dn
                from
              }
              {
                class(from) <- "array"
                from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "matrix", TRUE)
                as(.value, "array") <- value
                value <- .value
                {
                  for (what in NULL) slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "matrix", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(structure = new("SClassExtension", subClass = "array", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
                from, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    if (!is(value, "structure")) 
                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "structure", dQuote("array"), "structure", dQuote(class(value))), domain = NA)
                    value
                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "array", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                    as.vector(from), test = function (object) 
                      TRUE, replace = function (from, to, value) 
                        as({
                          attributes(value) <- attributes(from)
                          value
                        }, "array"), simple = FALSE, by = "structure", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = numeric(0), validity = NULL, access = list(), className = "array", package = "methods", subclasses = list(matrix = new("SClassExtension", subClass = "matrix", superClass = "array", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          class(from) <- "array"
                          from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            class(value) <- "matrix"
                            value
                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), mts = new("SClassExtension", subClass = "mts", superClass = "array", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            from <- {
                              .dm <- dim(from)
                              .dn <- dimnames(from)
                              attributes(from) <- NULL
                              dim(from) <- .dm
                              dimnames(from) <- .dn
                              from
                            }
                            {
                              class(from) <- "array"
                              from
                            }
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "matrix", TRUE)
                              as(.value, "array") <- value
                              value <- .value
                              {
                                for (what in NULL) slot(from, what) <- slot(value, what)
                                from
                              }
                            }, simple = TRUE, by = "matrix", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__builtin
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = FALSE, prototype = .Primitive("<-"), validity = NULL, access = list(), className = "builtin", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = FALSE, prototype = .Primitive("<-"), validity = NULL, access = list(), className = "builtin", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, 
                                                                                                                                                                                                                                                                                            sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__call
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "call", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "language")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("call"), "language", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = `<undef>`(), validity = NULL, access = list(), className = "call", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "call", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "language")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("call"), "language", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = `<undef>`(), validity = NULL, access = list(), className = "call", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__character
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "character", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "vector")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("character"), "vector", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), data.frameRowLabels = new("SClassExtension", subClass = "character", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "data.frameRowLabels")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "data.frameRowLabels", dQuote("character"), "data.frameRowLabels", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), SuperClassMethod = new("SClassExtension", subClass = "character", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "SuperClassMethod")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "SuperClassMethod", dQuote("character"), "SuperClassMethod", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = character(0), validity = NULL, access = list(), className = "character", package = "methods", subclasses = list(signature = new("SClassExtension", subClass = "signature", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
            {
              attributes(from) <- NULL
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                from@.Data <- as(value, "character", strict = FALSE)
                from
              }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), className = new("SClassExtension", subClass = "className", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
              {
                attributes(from) <- NULL
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), ObjectsWithPackage = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  attributes(from) <- NULL
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    from@.Data <- as(value, "character", strict = FALSE)
                    from
                  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "character", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                    from, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        if (!is(value, "vector")) 
                          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("character"), "vector", dQuote(class(value))), domain = NA)
                        value
                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), data.frameRowLabels = new("SClassExtension", subClass = "character", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                        from, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            if (!is(value, "data.frameRowLabels")) 
                              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "data.frameRowLabels", dQuote("character"), "data.frameRowLabels", dQuote(class(value))), domain = NA)
                            value
                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), SuperClassMethod = new("SClassExtension", subClass = "character", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                            from, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                if (!is(value, "SuperClassMethod")) 
                                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "SuperClassMethod", dQuote("character"), "SuperClassMethod", dQuote(class(value))), domain = NA)
                                value
                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = character(0), validity = NULL, access = list(), className = "character", package = "methods", subclasses = list(signature = new("SClassExtension", subClass = "signature", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                attributes(from) <- NULL
                                from
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  from@.Data <- as(value, "character", strict = FALSE)
                                  from
                                }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), className = new("SClassExtension", subClass = "className", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  attributes(from) <- NULL
                                  from
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    from@.Data <- as(value, "character", strict = FALSE)
                                    from
                                  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), ObjectsWithPackage = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    attributes(from) <- NULL
                                    from
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      from@.Data <- as(value, "character", strict = FALSE)
                                      from
                                    }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__classGeneratorFunction
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", className = "character", package = "character"), contains = list(`function` = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "function", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      from <- from@.Data
    from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "function", TRUE)
      as(.value, "OptionalFunction") <- value
      value <- .value
      {
        from@.Data <- as(value, "function", strict = FALSE)
        from
      }
    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "function", TRUE)
        as(.value, "PossibleMethod") <- value
        value <- .value
        {
          from@.Data <- as(value, "function", strict = FALSE)
          from
        }
      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), optionalMethod = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          if (strict) 
            from <- from@.Data
          from
        }
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "PossibleMethod") <- value
          value <- .value
          {
            from@.Data <- as(value, "function", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "PossibleMethod", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "classGeneratorFunction", package = "methods", subclasses = list(refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "classGeneratorFunction", package = "methods", coerce = function (from, strict = TRUE) 
        {
          value <- new("classGeneratorFunction")
          for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
          value
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", className = "character", package = "character"), contains = list(`function` = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
          {
            attributes(from) <- NULL
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              from@.Data <- as(value, "function", strict = FALSE)
              from
            }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "function", TRUE)
                as(.value, "OptionalFunction") <- value
                value <- .value
                {
                  from@.Data <- as(value, "function", strict = FALSE)
                  from
                }
              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "function", TRUE)
                  as(.value, "PossibleMethod") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "function", strict = FALSE)
                    from
                  }
                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), optionalMethod = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    if (strict) 
                      from <- from@.Data
                    from
                  }
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "function", TRUE)
                    as(.value, "PossibleMethod") <- value
                    value <- .value
                    {
                      from@.Data <- as(value, "function", strict = FALSE)
                      from
                    }
                  }, simple = TRUE, by = "PossibleMethod", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "classGeneratorFunction", package = "methods", subclasses = list(refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "classGeneratorFunction", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    value <- new("classGeneratorFunction")
                    for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                    value
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                      from
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__className
list(`package:methods` = new("classRepresentation", slots = list(.Data = "character", package = "character"), contains = list(character = new("SClassExtension", subClass = "className", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "character", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "className", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      from <- from@.Data
    from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "character", TRUE)
      as(.value, "vector") <- value
      value <- .value
      {
        from@.Data <- as(value, "character", strict = FALSE)
        from
      }
    }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), data.frameRowLabels = new("SClassExtension", subClass = "className", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "character", TRUE)
        as(.value, "data.frameRowLabels") <- value
        value <- .value
        {
          from@.Data <- as(value, "character", strict = FALSE)
          from
        }
      }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), SuperClassMethod = new("SClassExtension", subClass = "className", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "character", TRUE)
          as(.value, "SuperClassMethod") <- value
          value <- .value
          {
            from@.Data <- as(value, "character", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "className", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "character", package = "character"), contains = list(character = new("SClassExtension", subClass = "className", superClass = "character", package = "methods", coerce = function (from, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             strict = TRUE) 
        {
          attributes(from) <- NULL
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            from@.Data <- as(value, "character", strict = FALSE)
            from
          }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "className", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "character", TRUE)
              as(.value, "vector") <- value
              value <- .value
              {
                from@.Data <- as(value, "character", strict = FALSE)
                from
              }
            }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), data.frameRowLabels = new("SClassExtension", subClass = "className", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "character", TRUE)
                as(.value, "data.frameRowLabels") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
              }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), SuperClassMethod = new("SClassExtension", subClass = "className", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "character", TRUE)
                  as(.value, "SuperClassMethod") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "character", strict = FALSE)
                    from
                  }
                }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "className", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__classPrototypeDef
list(`package:methods` = new("classRepresentation", slots = list(object = "ANY", slots = "character", dataPart = "logical"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "classPrototypeDef", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(object = "ANY", slots = "character", dataPart = "logical"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
                                                                                                                                                                                                                                                                                                                                                                        validity = NULL, access = list(), className = "classPrototypeDef", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__classRepresentation
list(`package:methods` = new("classRepresentation", slots = list(slots = "list", contains = "list", virtual = "logical", prototype = "ANY", validity = "OptionalFunction", access = "list", className = "character", package = "character", subclasses = "list", versionKey = "externalptr", sealed = "logical"), contains = list(), virtual = FALSE, prototype = new("classRepresentation", slots = list(), contains = list(), virtual = NA, prototype = NULL, validity = NULL, access = list(), className = character(0), 
                                                                                                                                                                                                                                                                                                                                                                      package = character(0), subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), validity = NULL, access = list(), className = "classRepresentation", package = "methods", subclasses = list(ClassUnionRepresentation = new("SClassExtension", subClass = "ClassUnionRepresentation", superClass = "classRepresentation", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                        class(from) <- "classRepresentation"
                                                                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                                                                      }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                          for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refClassRepresentation = new("SClassExtension", subClass = "refClassRepresentation", superClass = "classRepresentation", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                          value <- new("classRepresentation")
                                                                                                                                                                                                                                                                                                                                                                          for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                          value
                                                                                                                                                                                                                                                                                                                                                                        }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                            for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(slots = "list", contains = "list", virtual = "logical", prototype = "ANY", validity = "OptionalFunction", access = "list", className = "character", package = "character", subclasses = "list", versionKey = "externalptr", sealed = "logical"), contains = list(), virtual = FALSE, prototype = new("classRepresentation", slots = list(), contains = list(), 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             virtual = NA, prototype = NULL, validity = NULL, access = list(), className = character(0), package = character(0), subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), validity = NULL, access = list(), className = "classRepresentation", package = "methods", subclasses = list(ClassUnionRepresentation = new("SClassExtension", subClass = "ClassUnionRepresentation", superClass = "classRepresentation", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               class(from) <- "classRepresentation"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refClassRepresentation = new("SClassExtension", subClass = "refClassRepresentation", superClass = "classRepresentation", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- new("classRepresentation")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__ClassUnionRepresentation
list(`package:methods` = new("classRepresentation", slots = list(slots = "list", contains = "list", virtual = "logical", prototype = "ANY", validity = "OptionalFunction", access = "list", className = "character", package = "character", subclasses = "list", versionKey = "externalptr", sealed = "logical"), contains = list(classRepresentation = new("SClassExtension", subClass = "ClassUnionRepresentation", superClass = "classRepresentation", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "classRepresentation"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = function (object) 
  {
    if (isTRUE(object@virtual) && length(object@slots) == 0 && is.null(object@prototype)) 
      TRUE
    else "Class must be an empty virtual class with NULL prototype"
  }, access = list(), className = "ClassUnionRepresentation", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(slots = "list", contains = "list", virtual = "logical", prototype = "ANY", validity = "OptionalFunction", access = "list", className = "character", package = "character", subclasses = "list", versionKey = "externalptr", sealed = "logical"), contains = list(classRepresentation = new("SClassExtension", subClass = "ClassUnionRepresentation", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          superClass = "classRepresentation", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            class(from) <- "classRepresentation"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (isTRUE(object@virtual) && length(object@slots) == 0 && is.null(object@prototype)) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TRUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              else "Class must be an empty virtual class with NULL prototype"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, access = list(), className = "ClassUnionRepresentation", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__complex
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "complex", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "vector")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("complex"), "vector", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = complex(0), validity = NULL, access = list(), className = "complex", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "complex", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "vector")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("complex"), "vector", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = complex(0), validity = NULL, access = list(), className = "complex", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__conditionalExtension
list(`package:methods` = new("classRepresentation", slots = list(subClass = "character", superClass = "character", package = "character", coerce = "function", test = "function", replace = "function", simple = "logical", by = "character", dataPart = "logical", distance = "numeric"), contains = list(SClassExtension = new("SClassExtension", subClass = "conditionalExtension", superClass = "SClassExtension", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "SClassExtension"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c("subClass", "superClass", "package", "coerce", "test", "replace", "simple", "by", "dataPart", "distance")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "conditionalExtension", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(subClass = "character", superClass = "character", package = "character", coerce = "function", test = "function", replace = "function", simple = "logical", by = "character", dataPart = "logical", 
                                                                                                                                                                                                                                                                                                                                         distance = "numeric"), contains = list(SClassExtension = new("SClassExtension", subClass = "conditionalExtension", superClass = "SClassExtension", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                           class(from) <- "SClassExtension"
                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                             for (what in c("subClass", "superClass", "package", "coerce", "test", "replace", "simple", "by", "dataPart", "distance")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "conditionalExtension", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__data.frame
list(`package:methods` = new("classRepresentation", slots = list(.Data = "list", names = "character", row.names = "data.frameRowLabels", .S3Class = "character"), contains = list(list = new("SClassExtension", subClass = "data.frame", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "list", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), oldClass = new("SClassExtension", subClass = "data.frame", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "data.frame", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "list", TRUE)
        as(.value, "vector") <- value
        value <- .value
        {
          from@.Data <- as(value, "list", strict = FALSE)
          from
        }
      }, simple = TRUE, by = "list", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "data.frame", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "list", names = "character", row.names = "data.frameRowLabels", .S3Class = "character"), contains = list(list = new("SClassExtension", subClass = "data.frame", superClass = "list", package = "methods", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                        coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                          attributes(from) <- NULL
                                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                            from@.Data <- as(value, "list", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), oldClass = new("SClassExtension", subClass = "data.frame", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              S3Part(from, S3Class = "oldClass")
                                                                                                                                                                                                                                                                                                                                                                                                                                                            else from
                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              S3Part(from) <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "data.frame", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                .value <- as(from, "list", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                as(.value, "vector") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from@.Data <- as(value, "list", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                              }, simple = TRUE, by = "list", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "data.frame", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__data.frameRowLabels
list(`package:methods` = new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = character(0), validity = NULL, access = list(), className = "data.frameRowLabels", package = "methods", subclasses = list(character = new("SClassExtension", subClass = "character", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "data.frameRowLabels")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "data.frameRowLabels", dQuote("character"), "data.frameRowLabels", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), integer = new("SClassExtension", subClass = "integer", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "data.frameRowLabels")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "data.frameRowLabels", dQuote("integer"), "data.frameRowLabels", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), signature = new("SClassExtension", subClass = "signature", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "character", TRUE)
            as(.value, "data.frameRowLabels") <- value
            value <- .value
            {
              from@.Data <- as(value, "character", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), className = new("SClassExtension", subClass = "className", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "character", TRUE)
              as(.value, "data.frameRowLabels") <- value
              value <- .value
              {
                from@.Data <- as(value, "character", strict = FALSE)
                from
              }
            }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), ObjectsWithPackage = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "character", TRUE)
                as(.value, "data.frameRowLabels") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
              }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), factor = new("SClassExtension", subClass = "factor", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "integer", TRUE)
                  as(.value, "data.frameRowLabels") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "integer", strict = FALSE)
                    from
                  }
                }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), ordered = new("SClassExtension", subClass = "ordered", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  if (strict) 
                    from <- from@.Data
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "integer", TRUE)
                    as(.value, "data.frameRowLabels") <- value
                    value <- .value
                    {
                      .value <- as(from, "factor", TRUE)
                      as(.value, "integer") <- value
                      value <- .value
                      {
                        S3Part(from) <- value
                        from
                      }
                    }
                  }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = FALSE), new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = character(0), validity = NULL, access = list(), className = "data.frameRowLabels", package = "methods", subclasses = list(character = new("SClassExtension", subClass = "character", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                    from, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        if (!is(value, "data.frameRowLabels")) 
                          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "data.frameRowLabels", dQuote("character"), "data.frameRowLabels", dQuote(class(value))), domain = NA)
                        value
                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), integer = new("SClassExtension", subClass = "integer", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                        from, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            if (!is(value, "data.frameRowLabels")) 
                              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "data.frameRowLabels", dQuote("integer"), "data.frameRowLabels", dQuote(class(value))), domain = NA)
                            value
                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), signature = new("SClassExtension", subClass = "signature", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "character", TRUE)
                              as(.value, "data.frameRowLabels") <- value
                              value <- .value
                              {
                                from@.Data <- as(value, "character", strict = FALSE)
                                from
                              }
                            }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), className = new("SClassExtension", subClass = "className", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              if (strict) 
                                from <- from@.Data
                              from
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "character", TRUE)
                                as(.value, "data.frameRowLabels") <- value
                                value <- .value
                                {
                                  from@.Data <- as(value, "character", strict = FALSE)
                                  from
                                }
                              }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), ObjectsWithPackage = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                if (strict) 
                                  from <- from@.Data
                                from
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "character", TRUE)
                                  as(.value, "data.frameRowLabels") <- value
                                  value <- .value
                                  {
                                    from@.Data <- as(value, "character", strict = FALSE)
                                    from
                                  }
                                }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), factor = new("SClassExtension", subClass = "factor", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  if (strict) 
                                    from <- from@.Data
                                  from
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    .value <- as(from, "integer", TRUE)
                                    as(.value, "data.frameRowLabels") <- value
                                    value <- .value
                                    {
                                      from@.Data <- as(value, "integer", strict = FALSE)
                                      from
                                    }
                                  }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), ordered = new("SClassExtension", subClass = "ordered", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    if (strict) 
                                      from <- from@.Data
                                    from
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      .value <- as(from, "integer", TRUE)
                                      as(.value, "data.frameRowLabels") <- value
                                      value <- .value
                                      {
                                        .value <- as(from, "factor", TRUE)
                                        as(.value, "integer") <- value
                                        value <- .value
                                        {
                                          S3Part(from) <- value
                                          from
                                        }
                                      }
                                    }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__Date
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "Date", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "Date", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "Date", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "Date", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__defaultBindingFunction
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", field = "character", className = "character"), contains = list(activeBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "activeBindingFunction", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("activeBindingFunction")
  for (what in ".Data") slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in ".Data") slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      value <- new("activeBindingFunction")
      for (what in ".Data") slot(value, what) <- slot(from, what)
      value
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "activeBindingFunction", TRUE)
      as(.value, "function") <- value
      value <- .value
      {
        for (what in ".Data") slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "activeBindingFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- {
        value <- new("activeBindingFunction")
        for (what in ".Data") slot(value, what) <- slot(from, what)
        value
      }
      {
        if (strict) 
          from <- from@.Data
        from
      }
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "activeBindingFunction", TRUE)
        as(.value, "OptionalFunction") <- value
        value <- .value
        {
          for (what in ".Data") slot(from, what) <- slot(value, what)
          from
        }
      }, simple = TRUE, by = "activeBindingFunction", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("activeBindingFunction")
          for (what in ".Data") slot(value, what) <- slot(from, what)
          value
        }
        {
          if (strict) 
            from <- from@.Data
          from
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "activeBindingFunction", TRUE)
          as(.value, "PossibleMethod") <- value
          value <- .value
          {
            for (what in ".Data") slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "activeBindingFunction", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "defaultBindingFunction", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", field = "character", className = "character"), contains = list(activeBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           superClass = "activeBindingFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value <- new("activeBindingFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             for (what in ".Data") slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               for (what in ".Data") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- new("activeBindingFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 for (what in ".Data") slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 .value <- as(from, "activeBindingFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in ".Data") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = "activeBindingFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value <- new("activeBindingFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in ".Data") slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   .value <- as(from, "activeBindingFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     for (what in ".Data") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = "activeBindingFunction", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value <- new("activeBindingFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     for (what in ".Data") slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     .value <- as(from, "activeBindingFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       for (what in ".Data") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }, simple = TRUE, by = "activeBindingFunction", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "defaultBindingFunction", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__density
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "density", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "density", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "density", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "density", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__derivedDefaultMethod
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character"), contains = list(MethodDefinition = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "MethodDefinition"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      class(from) <- "MethodDefinition"
      from
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "MethodDefinition", TRUE)
      as(.value, "function") <- value
      value <- .value
      {
        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "function", TRUE)
        as(.value, "PossibleMethod") <- value
        value <- .value
        {
          .value <- as(from, "MethodDefinition", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
            from
          }
        }
      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            .value <- as(from, "MethodDefinition", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            class(from) <- "MethodDefinition"
            from
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "MethodDefinition", TRUE)
            as(.value, "optionalMethod") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "derivedDefaultMethod", package = "methods", subclasses = list(internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "derivedDefaultMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            value <- new("derivedDefaultMethod")
            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
            value
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "derivedDefaultMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              value <- new("derivedDefaultMethod")
              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
              value
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character"), contains = list(MethodDefinition = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
              {
                class(from) <- "MethodDefinition"
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    class(from) <- "MethodDefinition"
                    from
                  }
                  if (strict) 
                    from@.Data
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "MethodDefinition", TRUE)
                    as(.value, "function") <- value
                    value <- .value
                    {
                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                      from
                    }
                  }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "function", TRUE)
                      as(.value, "PossibleMethod") <- value
                      value <- .value
                      {
                        .value <- as(from, "MethodDefinition", TRUE)
                        as(.value, "function") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }
                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      if (strict) 
                        from <- from@.Data
                      from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "function", TRUE)
                        as(.value, "OptionalFunction") <- value
                        value <- .value
                        {
                          .value <- as(from, "MethodDefinition", TRUE)
                          as(.value, "function") <- value
                          value <- .value
                          {
                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                            from
                          }
                        }
                      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        from <- {
                          class(from) <- "MethodDefinition"
                          from
                        }
                        {
                          if (strict) 
                            from <- from@.Data
                          from
                        }
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "MethodDefinition", TRUE)
                          as(.value, "optionalMethod") <- value
                          value <- .value
                          {
                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                            from
                          }
                        }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "derivedDefaultMethod", package = "methods", subclasses = list(internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "derivedDefaultMethod", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          value <- new("derivedDefaultMethod")
                          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                          value
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                            from
                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "derivedDefaultMethod", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            value <- new("derivedDefaultMethod")
                            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                            value
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                              from
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__derivedDefaultMethodWithTrace
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character", original = "PossibleMethod", source = "environment"), contains = list(derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "derivedDefaultMethod", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("derivedDefaultMethod")
  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "traceable")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("derivedDefaultMethodWithTrace"), "traceable", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("derivedDefaultMethod")
          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
          value
        }
        {
          class(from) <- "MethodDefinition"
          from
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "derivedDefaultMethod", TRUE)
          as(.value, "MethodDefinition") <- value
          value <- .value
          {
            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("derivedDefaultMethod")
            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
            value
          }
          if (strict) 
            from@.Data
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "derivedDefaultMethod", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "derivedDefaultMethod", dataPart = TRUE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              value <- new("derivedDefaultMethod")
              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
              value
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "derivedDefaultMethod", TRUE)
              as(.value, "PossibleMethod") <- value
              value <- .value
              {
                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                from
              }
            }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 4), OptionalFunction = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                value <- new("derivedDefaultMethod")
                for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                value
              }
              {
                if (strict) 
                  from <- from@.Data
                from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "derivedDefaultMethod", TRUE)
                as(.value, "OptionalFunction") <- value
                value <- .value
                {
                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  value <- new("derivedDefaultMethod")
                  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                  value
                }
                {
                  from <- {
                    class(from) <- "MethodDefinition"
                    from
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "derivedDefaultMethod", TRUE)
                  as(.value, "optionalMethod") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "derivedDefaultMethodWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character", original = "PossibleMethod", source = "environment"), contains = list(
                  derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "derivedDefaultMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    value <- new("derivedDefaultMethod")
                    for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                    value
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                      from
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "traceable")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("derivedDefaultMethodWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- {
                            value <- new("derivedDefaultMethod")
                            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                            value
                          }
                          {
                            class(from) <- "MethodDefinition"
                            from
                          }
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "derivedDefaultMethod", TRUE)
                            as(.value, "MethodDefinition") <- value
                            value <- .value
                            {
                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                              from
                            }
                          }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            from <- {
                              value <- new("derivedDefaultMethod")
                              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                              value
                            }
                            if (strict) 
                              from@.Data
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "derivedDefaultMethod", TRUE)
                              as(.value, "function") <- value
                              value <- .value
                              {
                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                from
                              }
                            }, simple = TRUE, by = "derivedDefaultMethod", dataPart = TRUE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              from <- {
                                value <- new("derivedDefaultMethod")
                                for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                value
                              }
                              {
                                if (strict) 
                                  from <- from@.Data
                                from
                              }
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "derivedDefaultMethod", TRUE)
                                as(.value, "PossibleMethod") <- value
                                value <- .value
                                {
                                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                  from
                                }
                              }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 4), OptionalFunction = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                from <- {
                                  value <- new("derivedDefaultMethod")
                                  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                  value
                                }
                                {
                                  if (strict) 
                                    from <- from@.Data
                                  from
                                }
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "derivedDefaultMethod", TRUE)
                                  as(.value, "OptionalFunction") <- value
                                  value <- .value
                                  {
                                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  from <- {
                                    value <- new("derivedDefaultMethod")
                                    for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                    value
                                  }
                                  {
                                    from <- {
                                      class(from) <- "MethodDefinition"
                                      from
                                    }
                                    {
                                      if (strict) 
                                        from <- from@.Data
                                      from
                                    }
                                  }
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    .value <- as(from, "derivedDefaultMethod", TRUE)
                                    as(.value, "optionalMethod") <- value
                                    value <- .value
                                    {
                                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                      from
                                    }
                                  }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "derivedDefaultMethodWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__double
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(numeric = new("SClassExtension", subClass = "double", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "numeric"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    class(value) <- "double"
    value
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "double", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "vector")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("double"), "vector", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = numeric(0), validity = NULL, access = list(), className = "double", package = "methods", subclasses = list(integer = new("SClassExtension", subClass = "integer", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
        as.double(from), test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            class(value) <- "integer"
            value
          }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), factor = new("SClassExtension", subClass = "factor", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- as(from, "integer", strict = strict)
            as.double(from)
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "integer", TRUE)
              as(.value, "double") <- value
              value <- .value
              {
                from@.Data <- as(value, "integer", strict = FALSE)
                from
              }
            }, simple = FALSE, by = "integer", dataPart = FALSE, distance = 2), ordered = new("SClassExtension", subClass = "ordered", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- as(from, "factor", strict = strict)
              {
                from <- as(from, "integer", strict = strict)
                as.double(from)
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "factor", TRUE)
                as(.value, "double") <- value
                value <- .value
                {
                  S3Part(from) <- value
                  from
                }
              }, simple = FALSE, by = "factor", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(numeric = new("SClassExtension", subClass = "double", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
              {
                class(from) <- "numeric"
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  class(value) <- "double"
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "double", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "vector")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("double"), "vector", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = numeric(0), validity = NULL, access = list(), className = "double", package = "methods", subclasses = list(integer = new("SClassExtension", subClass = "integer", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
                      as.double(from), test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          class(value) <- "integer"
                          value
                        }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), factor = new("SClassExtension", subClass = "factor", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- as(from, "integer", strict = strict)
                          as.double(from)
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "integer", TRUE)
                            as(.value, "double") <- value
                            value <- .value
                            {
                              from@.Data <- as(value, "integer", strict = FALSE)
                              from
                            }
                          }, simple = FALSE, by = "integer", dataPart = FALSE, distance = 2), ordered = new("SClassExtension", subClass = "ordered", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            from <- as(from, "factor", strict = strict)
                            {
                              from <- as(from, "integer", strict = strict)
                              as.double(from)
                            }
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "factor", TRUE)
                              as(.value, "double") <- value
                              value <- .value
                              {
                                S3Part(from) <- value
                                from
                              }
                            }, simple = FALSE, by = "factor", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__dump.frames
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "dump.frames", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "dump.frames", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "dump.frames", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "dump.frames", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__EmptyMethodsList
list(`package:methods` = new("classRepresentation", slots = list(argument = "name", sublist = "list"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "EmptyMethodsList", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(argument = "name", sublist = "list"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, 
                                                                                                                                                                                                                                                                                                                                                 access = list(), className = "EmptyMethodsList", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__environment
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(refObject = new("SClassExtension", subClass = "environment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "refObject")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("environment"), "refObject", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <environment>, validity = NULL, access = list(), className = "environment", package = "methods", subclasses = list(.environment = new("SClassExtension", subClass = ".environment", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
      from@.xData, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          from@.xData <- value
          from
        }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), sourceEnvironment = new("SClassExtension", subClass = "sourceEnvironment", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- as(from, ".environment", strict = strict)
          from@.xData
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, ".environment", TRUE)
            as(.value, "environment") <- value
            value <- .value
            {
              for (what in ".xData") slot(from, what) <- slot(value, what)
              from
            }
          }, simple = FALSE, by = ".environment", dataPart = FALSE, distance = 2), envRefClass = new("SClassExtension", subClass = "envRefClass", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- as(from, ".environment", strict = strict)
            from@.xData
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, ".environment", TRUE)
              as(.value, "environment") <- value
              value <- .value
              {
                for (what in ".xData") slot(from, what) <- slot(value, what)
                from
              }
            }, simple = FALSE, by = ".environment", dataPart = FALSE, distance = 2), refGeneratorSlot = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- as(from, "envRefClass", strict = strict)
              {
                from <- as(from, ".environment", strict = strict)
                from@.xData
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "envRefClass", TRUE)
                as(.value, "environment") <- value
                value <- .value
                {
                  for (what in ".xData") slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = FALSE, by = "envRefClass", dataPart = FALSE, distance = 3), localRefClass = new("SClassExtension", subClass = "localRefClass", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- as(from, "envRefClass", strict = strict)
                {
                  from <- as(from, ".environment", strict = strict)
                  from@.xData
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "envRefClass", TRUE)
                  as(.value, "environment") <- value
                  value <- .value
                  {
                    for (what in ".xData") slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = FALSE, by = "envRefClass", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(refObject = new("SClassExtension", subClass = "environment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "refObject")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("environment"), "refObject", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <environment>, validity = NULL, access = list(), className = "environment", package = "methods", subclasses = list(.environment = new("SClassExtension", subClass = ".environment", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                      from@.xData, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          from@.xData <- value
                          from
                        }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), sourceEnvironment = new("SClassExtension", subClass = "sourceEnvironment", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- as(from, ".environment", strict = strict)
                          from@.xData
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, ".environment", TRUE)
                            as(.value, "environment") <- value
                            value <- .value
                            {
                              for (what in ".xData") slot(from, what) <- slot(value, what)
                              from
                            }
                          }, simple = FALSE, by = ".environment", dataPart = FALSE, distance = 2), envRefClass = new("SClassExtension", subClass = "envRefClass", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            from <- as(from, ".environment", strict = strict)
                            from@.xData
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, ".environment", TRUE)
                              as(.value, "environment") <- value
                              value <- .value
                              {
                                for (what in ".xData") slot(from, what) <- slot(value, what)
                                from
                              }
                            }, simple = FALSE, by = ".environment", dataPart = FALSE, distance = 2), refGeneratorSlot = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              from <- as(from, "envRefClass", strict = strict)
                              {
                                from <- as(from, ".environment", strict = strict)
                                from@.xData
                              }
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "envRefClass", TRUE)
                                as(.value, "environment") <- value
                                value <- .value
                                {
                                  for (what in ".xData") slot(from, what) <- slot(value, what)
                                  from
                                }
                              }, simple = FALSE, by = "envRefClass", dataPart = FALSE, distance = 3), localRefClass = new("SClassExtension", subClass = "localRefClass", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                from <- as(from, "envRefClass", strict = strict)
                                {
                                  from <- as(from, ".environment", strict = strict)
                                  from@.xData
                                }
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "envRefClass", TRUE)
                                  as(.value, "environment") <- value
                                  value <- .value
                                  {
                                    for (what in ".xData") slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }, simple = FALSE, by = "envRefClass", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__envRefClass
list(`package:methods` = new("refClassRepresentation", fieldClasses = list(), fieldPrototypes = <environment>, refMethods = <environment>, refSuperClasses = character(0), slots = list(.xData = "environment"), contains = list(.environment = new("SClassExtension", subClass = "envRefClass", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- ".environment"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in ".xData") slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refClass = new("SClassExtension", subClass = "envRefClass", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "refClass")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refClass", dQuote("envRefClass"), "refClass", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), environment = new("SClassExtension", subClass = "envRefClass", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- as(from, ".environment", strict = strict)
        from@.xData
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, ".environment", TRUE)
          as(.value, "environment") <- value
          value <- .value
          {
            for (what in ".xData") slot(from, what) <- slot(value, what)
            from
          }
        }, simple = FALSE, by = ".environment", dataPart = FALSE, distance = 2), refObject = new("SClassExtension", subClass = "envRefClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
              as({
                if (!is(value, "refObject")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                value
              }, "envRefClass"), simple = TRUE, by = "refClass", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "envRefClass", package = "methods", subclasses = list(refGeneratorSlot = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "envRefClass", package = "methods", coerce = function (from, strict = TRUE) 
              {
                class(from) <- "envRefClass"
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  for (what in ".xData") slot(from, what) <- slot(value, what)
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), localRefClass = new("SClassExtension", subClass = "localRefClass", superClass = "envRefClass", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  class(from) <- "envRefClass"
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    for (what in ".xData") slot(from, what) <- slot(value, what)
                    from
                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("refClassRepresentation", fieldClasses = list(), fieldPrototypes = <environment>, refMethods = <environment>, refSuperClasses = character(0), slots = list(.xData = "environment"), contains = list(.environment = new("SClassExtension", subClass = "envRefClass", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    class(from) <- ".environment"
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      for (what in ".xData") slot(from, what) <- slot(value, what)
                      from
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refClass = new("SClassExtension", subClass = "envRefClass", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "refClass")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refClass", dQuote("envRefClass"), "refClass", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), environment = new("SClassExtension", subClass = "envRefClass", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- as(from, ".environment", strict = strict)
                          from@.xData
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, ".environment", TRUE)
                            as(.value, "environment") <- value
                            value <- .value
                            {
                              for (what in ".xData") slot(from, what) <- slot(value, what)
                              from
                            }
                          }, simple = FALSE, by = ".environment", dataPart = FALSE, distance = 2), refObject = new("SClassExtension", subClass = "envRefClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                            from, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                                as({
                                  if (!is(value, "refObject")) 
                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                                  value
                                }, "envRefClass"), simple = TRUE, by = "refClass", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "envRefClass", package = "methods", subclasses = list(refGeneratorSlot = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "envRefClass", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  class(from) <- "envRefClass"
                                  from
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    for (what in ".xData") slot(from, what) <- slot(value, what)
                                    from
                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), localRefClass = new("SClassExtension", subClass = "localRefClass", superClass = "envRefClass", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    class(from) <- "envRefClass"
                                    from
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      for (what in ".xData") slot(from, what) <- slot(value, what)
                                      from
                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__expression
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "expression", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "vector")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("expression"), "vector", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = expression(), validity = NULL, access = list(), className = "expression", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "expression", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "vector")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("expression"), "vector", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = expression(), validity = NULL, access = list(), className = "expression", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__externalptr
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(refObject = new("SClassExtension", subClass = "externalptr", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "refObject")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("externalptr"), "refObject", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <pointer: (nil)>, validity = NULL, access = list(), className = "externalptr", package = "methods", subclasses = list(.externalptr = new("SClassExtension", subClass = ".externalptr", superClass = "externalptr", package = "methods", coerce = function (from, strict = TRUE) 
      from@.xData, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          from@.xData <- value
          from
        }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(refObject = new("SClassExtension", subClass = "externalptr", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "refObject")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("externalptr"), "refObject", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <pointer: (nil)>, validity = NULL, access = list(), className = "externalptr", package = "methods", subclasses = list(.externalptr = new("SClassExtension", subClass = ".externalptr", superClass = "externalptr", package = "methods", coerce = function (from, strict = TRUE) 
              from@.xData, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  from@.xData <- value
                  from
                }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__externalRefMethod
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", actual = "function", mayCall = "character", name = "character", refClassName = "character", superClassMethod = "SuperClassMethod"), contains = list(refMethodDef = new("SClassExtension", subClass = "externalRefMethod", superClass = "refMethodDef", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("refMethodDef")
  for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "externalRefMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      value <- new("refMethodDef")
      for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
      value
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "refMethodDef", TRUE)
      as(.value, "function") <- value
      value <- .value
      {
        for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "refMethodDef", dataPart = TRUE, distance = 2), SuperClassMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- {
        value <- new("refMethodDef")
        for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
        value
      }
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "refMethodDef", TRUE)
        as(.value, "SuperClassMethod") <- value
        value <- .value
        {
          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
          from
        }
      }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "externalRefMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("refMethodDef")
          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
          value
        }
        {
          if (strict) 
            from <- from@.Data
          from
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "refMethodDef", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("refMethodDef")
            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
            value
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "refMethodDef", TRUE)
            as(.value, "PossibleMethod") <- value
            value <- .value
            {
              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "externalRefMethod", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", actual = "function", mayCall = "character", name = "character", refClassName = "character", superClassMethod = "SuperClassMethod"), contains = list(refMethodDef = new("SClassExtension", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           subClass = "externalRefMethod", superClass = "refMethodDef", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "externalRefMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 .value <- as(from, "refMethodDef", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = "refMethodDef", dataPart = TRUE, distance = 2), SuperClassMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   .value <- as(from, "refMethodDef", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   as(.value, "SuperClassMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "externalRefMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     .value <- as(from, "refMethodDef", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .value <- as(from, "refMethodDef", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "externalRefMethod", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__factor
list(`package:methods` = new("classRepresentation", slots = list(.Data = "integer", levels = "character", .S3Class = "character"), contains = list(integer = new("SClassExtension", subClass = "factor", superClass = "integer", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "integer", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), oldClass = new("SClassExtension", subClass = "factor", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), double = new("SClassExtension", subClass = "factor", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- as(from, "integer", strict = strict)
      as.double(from)
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "integer", TRUE)
        as(.value, "double") <- value
        value <- .value
        {
          from@.Data <- as(value, "integer", strict = FALSE)
          from
        }
      }, simple = FALSE, by = "integer", dataPart = FALSE, distance = 2), numeric = new("SClassExtension", subClass = "factor", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        {
          class(from) <- "numeric"
          from
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "integer", TRUE)
          as(.value, "numeric") <- value
          value <- .value
          {
            from@.Data <- as(value, "integer", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), vector = new("SClassExtension", subClass = "factor", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "integer", TRUE)
            as(.value, "vector") <- value
            value <- .value
            {
              from@.Data <- as(value, "integer", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), data.frameRowLabels = new("SClassExtension", subClass = "factor", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "integer", TRUE)
              as(.value, "data.frameRowLabels") <- value
              value <- .value
              {
                from@.Data <- as(value, "integer", strict = FALSE)
                from
              }
            }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = function (object) 
            {
              levs <- levels(object)
              if (!is.character(levs)) 
                return("factor levels must be \"character\"")
              if (d <- anyDuplicated(levs)) 
                return(sprintf("duplicated level [%d] in factor", d))
              TRUE
            }, access = list(), className = "factor", package = "methods", subclasses = list(ordered = new("SClassExtension", subClass = "ordered", superClass = "factor", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                S3Part(from, S3Class = "factor")
              else from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                S3Part(from) <- value
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "integer", levels = "character", .S3Class = "character"), contains = list(integer = new("SClassExtension", subClass = "factor", superClass = "integer", package = "methods", coerce = function (from, strict = TRUE) 
              {
                attributes(from) <- NULL
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  from@.Data <- as(value, "integer", strict = FALSE)
                  from
                }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), oldClass = new("SClassExtension", subClass = "factor", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  if (strict) 
                    S3Part(from, S3Class = "oldClass")
                  else from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    S3Part(from) <- value
                    from
                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), double = new("SClassExtension", subClass = "factor", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- as(from, "integer", strict = strict)
                    as.double(from)
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "integer", TRUE)
                      as(.value, "double") <- value
                      value <- .value
                      {
                        from@.Data <- as(value, "integer", strict = FALSE)
                        from
                      }
                    }, simple = FALSE, by = "integer", dataPart = FALSE, distance = 2), numeric = new("SClassExtension", subClass = "factor", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      if (strict) 
                        from <- from@.Data
                      {
                        class(from) <- "numeric"
                        from
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "integer", TRUE)
                        as(.value, "numeric") <- value
                        value <- .value
                        {
                          from@.Data <- as(value, "integer", strict = FALSE)
                          from
                        }
                      }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), vector = new("SClassExtension", subClass = "factor", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        if (strict) 
                          from <- from@.Data
                        from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "integer", TRUE)
                          as(.value, "vector") <- value
                          value <- .value
                          {
                            from@.Data <- as(value, "integer", strict = FALSE)
                            from
                          }
                        }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), data.frameRowLabels = new("SClassExtension", subClass = "factor", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          if (strict) 
                            from <- from@.Data
                          from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "integer", TRUE)
                            as(.value, "data.frameRowLabels") <- value
                            value <- .value
                            {
                              from@.Data <- as(value, "integer", strict = FALSE)
                              from
                            }
                          }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = function (object) 
                          {
                            levs <- levels(object)
                            if (!is.character(levs)) 
                              return("factor levels must be \"character\"")
                            if (d <- anyDuplicated(levs)) 
                              return(sprintf("duplicated level [%d] in factor", d))
                            TRUE
                          }, access = list(), className = "factor", package = "methods", subclasses = list(ordered = new("SClassExtension", subClass = "ordered", superClass = "factor", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              S3Part(from, S3Class = "factor")
                            else from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              S3Part(from) <- value
                              from
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__for
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "for", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "language")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("for"), "language", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = for (NAME in logical()) NULL, validity = NULL, access = list(), className = "for", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "for", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "language")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("for"), "language", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = for (NAME in logical()) NULL, validity = NULL, access = list(), className = "for", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__formula
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "formula", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = list(), validity = NULL, access = list(), className = "formula", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "formula", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = list(), validity = NULL, access = list(), className = "formula", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__function
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(OptionalFunction = new("SClassExtension", subClass = "function", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "OptionalFunction")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "OptionalFunction", dQuote("function"), "OptionalFunction", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), PossibleMethod = new("SClassExtension", subClass = "function", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "PossibleMethod")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "PossibleMethod", dQuote("function"), "PossibleMethod", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = function () 
          NULL, validity = NULL, access = list(), className = "function", package = "methods", subclasses = list(classGeneratorFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
          {
            attributes(from) <- NULL
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              from@.Data <- as(value, "function", strict = FALSE)
              from
            }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "MethodDefinition", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
            {
              attributes(from) <- NULL
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                from@.Data <- as(value, "function", strict = FALSE)
                from
              }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), genericFunction = new("SClassExtension", subClass = "genericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
              {
                attributes(from) <- NULL
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  from@.Data <- as(value, "function", strict = FALSE)
                  from
                }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), functionWithTrace = new("SClassExtension", subClass = "functionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  attributes(from) <- NULL
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    from@.Data <- as(value, "function", strict = FALSE)
                    from
                  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), activeBindingFunction = new("SClassExtension", subClass = "activeBindingFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    attributes(from) <- NULL
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      from@.Data <- as(value, "function", strict = FALSE)
                      from
                    }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), refMethodDef = new("SClassExtension", subClass = "refMethodDef", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      attributes(from) <- NULL
                      from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        from@.Data <- as(value, "function", strict = FALSE)
                        from
                      }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        from <- {
                          class(from) <- "MethodDefinition"
                          from
                        }
                        if (strict) 
                          from@.Data
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "MethodDefinition", TRUE)
                          as(.value, "function") <- value
                          value <- .value
                          {
                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                            from
                          }
                        }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- {
                            value <- new("MethodDefinition")
                            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                            value
                          }
                          if (strict) 
                            from@.Data
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "MethodDefinition", TRUE)
                            as(.value, "function") <- value
                            value <- .value
                            {
                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                              from
                            }
                          }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            from <- {
                              class(from) <- "MethodDefinition"
                              from
                            }
                            if (strict) 
                              from@.Data
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "MethodDefinition", TRUE)
                              as(.value, "function") <- value
                              value <- .value
                              {
                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                from
                              }
                            }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), MethodDefinitionWithTrace = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              from <- {
                                value <- new("MethodDefinition")
                                for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                value
                              }
                              if (strict) 
                                from@.Data
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "MethodDefinition", TRUE)
                                as(.value, "function") <- value
                                value <- .value
                                {
                                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                  from
                                }
                              }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                from <- {
                                  class(from) <- "genericFunction"
                                  from
                                }
                                if (strict) 
                                  from@.Data
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "genericFunction", TRUE)
                                  as(.value, "function") <- value
                                  value <- .value
                                  {
                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  from <- {
                                    class(from) <- "genericFunction"
                                    from
                                  }
                                  if (strict) 
                                    from@.Data
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    .value <- as(from, "genericFunction", TRUE)
                                    as(.value, "function") <- value
                                    value <- .value
                                    {
                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                      from
                                    }
                                  }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    from <- {
                                      value <- new("genericFunction")
                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                      value
                                    }
                                    if (strict) 
                                      from@.Data
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      .value <- as(from, "genericFunction", TRUE)
                                      as(.value, "function") <- value
                                      value <- .value
                                      {
                                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                        from
                                      }
                                    }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), genericFunctionWithTrace = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                    {
                                      from <- {
                                        value <- new("genericFunction")
                                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                        value
                                      }
                                      if (strict) 
                                        from@.Data
                                    }, test = function (object) 
                                      TRUE, replace = function (from, to, value) 
                                      {
                                        .value <- as(from, "genericFunction", TRUE)
                                        as(.value, "function") <- value
                                        value <- .value
                                        {
                                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                          from
                                        }
                                      }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), defaultBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                      {
                                        from <- {
                                          value <- new("activeBindingFunction")
                                          for (what in ".Data") slot(value, what) <- slot(from, what)
                                          value
                                        }
                                        if (strict) 
                                          from@.Data
                                      }, test = function (object) 
                                        TRUE, replace = function (from, to, value) 
                                        {
                                          .value <- as(from, "activeBindingFunction", TRUE)
                                          as(.value, "function") <- value
                                          value <- .value
                                          {
                                            for (what in ".Data") slot(from, what) <- slot(value, what)
                                            from
                                          }
                                        }, simple = TRUE, by = "activeBindingFunction", dataPart = TRUE, distance = 2), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                        {
                                          from <- {
                                            from <- {
                                              value <- new("derivedDefaultMethod")
                                              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                              value
                                            }
                                            {
                                              class(from) <- "MethodDefinition"
                                              from
                                            }
                                          }
                                          if (strict) 
                                            from@.Data
                                        }, test = function (object) 
                                          TRUE, replace = function (from, to, value) 
                                          {
                                            .value <- as(from, "MethodDefinition", TRUE)
                                            as(.value, "function") <- value
                                            value <- .value
                                            {
                                              .value <- as(from, "derivedDefaultMethod", TRUE)
                                              as(.value, "MethodDefinition") <- value
                                              value <- .value
                                              {
                                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                from
                                              }
                                            }
                                          }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 3), MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                          {
                                            from <- {
                                              from <- {
                                                value <- new("MethodWithNext")
                                                for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                value
                                              }
                                              {
                                                value <- new("MethodDefinition")
                                                for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                value
                                              }
                                            }
                                            if (strict) 
                                              from@.Data
                                          }, test = function (object) 
                                            TRUE, replace = function (from, to, value) 
                                            {
                                              .value <- as(from, "MethodDefinition", TRUE)
                                              as(.value, "function") <- value
                                              value <- .value
                                              {
                                                .value <- as(from, "MethodWithNext", TRUE)
                                                as(.value, "MethodDefinition") <- value
                                                value <- .value
                                                {
                                                  for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                  from
                                                }
                                              }
                                            }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 3), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                            {
                                              from <- {
                                                from <- {
                                                  value <- new("derivedDefaultMethod")
                                                  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                  value
                                                }
                                                {
                                                  class(from) <- "MethodDefinition"
                                                  from
                                                }
                                              }
                                              if (strict) 
                                                from@.Data
                                            }, test = function (object) 
                                              TRUE, replace = function (from, to, value) 
                                              {
                                                .value <- as(from, "MethodDefinition", TRUE)
                                                as(.value, "function") <- value
                                                value <- .value
                                                {
                                                  .value <- as(from, "derivedDefaultMethod", TRUE)
                                                  as(.value, "MethodDefinition") <- value
                                                  value <- .value
                                                  {
                                                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                    from
                                                  }
                                                }
                                              }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 3), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                              {
                                                from <- {
                                                  from <- {
                                                    class(from) <- "groupGenericFunction"
                                                    from
                                                  }
                                                  {
                                                    value <- new("genericFunction")
                                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                    value
                                                  }
                                                }
                                                if (strict) 
                                                  from@.Data
                                              }, test = function (object) 
                                                TRUE, replace = function (from, to, value) 
                                                {
                                                  .value <- as(from, "genericFunction", TRUE)
                                                  as(.value, "function") <- value
                                                  value <- .value
                                                  {
                                                    .value <- as(from, "groupGenericFunction", TRUE)
                                                    as(.value, "genericFunction") <- value
                                                    value <- .value
                                                    {
                                                      for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                      from
                                                    }
                                                  }
                                                }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 3), standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                {
                                                  from <- {
                                                    from <- {
                                                      value <- new("standardGeneric")
                                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                      value
                                                    }
                                                    {
                                                      class(from) <- "genericFunction"
                                                      from
                                                    }
                                                  }
                                                  if (strict) 
                                                    from@.Data
                                                }, test = function (object) 
                                                  TRUE, replace = function (from, to, value) 
                                                  {
                                                    .value <- as(from, "genericFunction", TRUE)
                                                    as(.value, "function") <- value
                                                    value <- .value
                                                    {
                                                      .value <- as(from, "standardGeneric", TRUE)
                                                      as(.value, "genericFunction") <- value
                                                      value <- .value
                                                      {
                                                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                        from
                                                      }
                                                    }
                                                  }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 3), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                  {
                                                    from <- {
                                                      from <- {
                                                        value <- new("groupGenericFunction")
                                                        for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                        value
                                                      }
                                                      {
                                                        value <- new("genericFunction")
                                                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                        value
                                                      }
                                                    }
                                                    if (strict) 
                                                      from@.Data
                                                  }, test = function (object) 
                                                    TRUE, replace = function (from, to, value) 
                                                    {
                                                      .value <- as(from, "genericFunction", TRUE)
                                                      as(.value, "function") <- value
                                                      value <- .value
                                                      {
                                                        .value <- as(from, "groupGenericFunction", TRUE)
                                                        as(.value, "genericFunction") <- value
                                                        value <- .value
                                                        {
                                                          for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                          from
                                                        }
                                                      }
                                                    }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 3), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                    {
                                                      from <- {
                                                        value <- new("refMethodDef")
                                                        for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                        value
                                                      }
                                                      if (strict) 
                                                        from@.Data
                                                    }, test = function (object) 
                                                      TRUE, replace = function (from, to, value) 
                                                      {
                                                        .value <- as(from, "refMethodDef", TRUE)
                                                        as(.value, "function") <- value
                                                        value <- .value
                                                        {
                                                          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                          from
                                                        }
                                                      }, simple = TRUE, by = "refMethodDef", dataPart = TRUE, distance = 2), externalRefMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                      {
                                                        from <- {
                                                          value <- new("refMethodDef")
                                                          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                          value
                                                        }
                                                        if (strict) 
                                                          from@.Data
                                                      }, test = function (object) 
                                                        TRUE, replace = function (from, to, value) 
                                                        {
                                                          .value <- as(from, "refMethodDef", TRUE)
                                                          as(.value, "function") <- value
                                                          value <- .value
                                                          {
                                                            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                            from
                                                          }
                                                        }, simple = TRUE, by = "refMethodDef", dataPart = TRUE, distance = 2), refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                        {
                                                          from <- {
                                                            value <- new("classGeneratorFunction")
                                                            for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                            value
                                                          }
                                                          if (strict) 
                                                            from@.Data
                                                        }, test = function (object) 
                                                          TRUE, replace = function (from, to, value) 
                                                          {
                                                            .value <- as(from, "classGeneratorFunction", TRUE)
                                                            as(.value, "function") <- value
                                                            value <- .value
                                                            {
                                                              for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                              from
                                                            }
                                                          }, simple = TRUE, by = "classGeneratorFunction", dataPart = TRUE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(OptionalFunction = new("SClassExtension", subClass = "function", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                            from, test = function (object) 
                                                              TRUE, replace = function (from, to, value) 
                                                              {
                                                                if (!is(value, "OptionalFunction")) 
                                                                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "OptionalFunction", dQuote("function"), "OptionalFunction", dQuote(class(value))), domain = NA)
                                                                value
                                                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), PossibleMethod = new("SClassExtension", subClass = "function", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                from, test = function (object) 
                                                                  TRUE, replace = function (from, to, value) 
                                                                  {
                                                                    if (!is(value, "PossibleMethod")) 
                                                                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "PossibleMethod", dQuote("function"), "PossibleMethod", dQuote(class(value))), domain = NA)
                                                                    value
                                                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = function () 
                                                                    NULL, validity = NULL, access = list(), className = "function", package = "methods", subclasses = list(classGeneratorFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                    {
                                                                      attributes(from) <- NULL
                                                                      from
                                                                    }, test = function (object) 
                                                                      TRUE, replace = function (from, to, value) 
                                                                      {
                                                                        from@.Data <- as(value, "function", strict = FALSE)
                                                                        from
                                                                      }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "MethodDefinition", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                      {
                                                                        attributes(from) <- NULL
                                                                        from
                                                                      }, test = function (object) 
                                                                        TRUE, replace = function (from, to, value) 
                                                                        {
                                                                          from@.Data <- as(value, "function", strict = FALSE)
                                                                          from
                                                                        }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), genericFunction = new("SClassExtension", subClass = "genericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                        {
                                                                          attributes(from) <- NULL
                                                                          from
                                                                        }, test = function (object) 
                                                                          TRUE, replace = function (from, to, value) 
                                                                          {
                                                                            from@.Data <- as(value, "function", strict = FALSE)
                                                                            from
                                                                          }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), functionWithTrace = new("SClassExtension", subClass = "functionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                          {
                                                                            attributes(from) <- NULL
                                                                            from
                                                                          }, test = function (object) 
                                                                            TRUE, replace = function (from, to, value) 
                                                                            {
                                                                              from@.Data <- as(value, "function", strict = FALSE)
                                                                              from
                                                                            }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), activeBindingFunction = new("SClassExtension", subClass = "activeBindingFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                            {
                                                                              attributes(from) <- NULL
                                                                              from
                                                                            }, test = function (object) 
                                                                              TRUE, replace = function (from, to, value) 
                                                                              {
                                                                                from@.Data <- as(value, "function", strict = FALSE)
                                                                                from
                                                                              }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), refMethodDef = new("SClassExtension", subClass = "refMethodDef", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                              {
                                                                                attributes(from) <- NULL
                                                                                from
                                                                              }, test = function (object) 
                                                                                TRUE, replace = function (from, to, value) 
                                                                                {
                                                                                  from@.Data <- as(value, "function", strict = FALSE)
                                                                                  from
                                                                                }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                {
                                                                                  from <- {
                                                                                    class(from) <- "MethodDefinition"
                                                                                    from
                                                                                  }
                                                                                  if (strict) 
                                                                                    from@.Data
                                                                                }, test = function (object) 
                                                                                  TRUE, replace = function (from, to, value) 
                                                                                  {
                                                                                    .value <- as(from, "MethodDefinition", TRUE)
                                                                                    as(.value, "function") <- value
                                                                                    value <- .value
                                                                                    {
                                                                                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                      from
                                                                                    }
                                                                                  }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                  {
                                                                                    from <- {
                                                                                      value <- new("MethodDefinition")
                                                                                      for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                      value
                                                                                    }
                                                                                    if (strict) 
                                                                                      from@.Data
                                                                                  }, test = function (object) 
                                                                                    TRUE, replace = function (from, to, value) 
                                                                                    {
                                                                                      .value <- as(from, "MethodDefinition", TRUE)
                                                                                      as(.value, "function") <- value
                                                                                      value <- .value
                                                                                      {
                                                                                        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                        from
                                                                                      }
                                                                                    }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                    {
                                                                                      from <- {
                                                                                        class(from) <- "MethodDefinition"
                                                                                        from
                                                                                      }
                                                                                      if (strict) 
                                                                                        from@.Data
                                                                                    }, test = function (object) 
                                                                                      TRUE, replace = function (from, to, value) 
                                                                                      {
                                                                                        .value <- as(from, "MethodDefinition", TRUE)
                                                                                        as(.value, "function") <- value
                                                                                        value <- .value
                                                                                        {
                                                                                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                          from
                                                                                        }
                                                                                      }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), MethodDefinitionWithTrace = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                      {
                                                                                        from <- {
                                                                                          value <- new("MethodDefinition")
                                                                                          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                          value
                                                                                        }
                                                                                        if (strict) 
                                                                                          from@.Data
                                                                                      }, test = function (object) 
                                                                                        TRUE, replace = function (from, to, value) 
                                                                                        {
                                                                                          .value <- as(from, "MethodDefinition", TRUE)
                                                                                          as(.value, "function") <- value
                                                                                          value <- .value
                                                                                          {
                                                                                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                            from
                                                                                          }
                                                                                        }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                        {
                                                                                          from <- {
                                                                                            class(from) <- "genericFunction"
                                                                                            from
                                                                                          }
                                                                                          if (strict) 
                                                                                            from@.Data
                                                                                        }, test = function (object) 
                                                                                          TRUE, replace = function (from, to, value) 
                                                                                          {
                                                                                            .value <- as(from, "genericFunction", TRUE)
                                                                                            as(.value, "function") <- value
                                                                                            value <- .value
                                                                                            {
                                                                                              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                              from
                                                                                            }
                                                                                          }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                          {
                                                                                            from <- {
                                                                                              class(from) <- "genericFunction"
                                                                                              from
                                                                                            }
                                                                                            if (strict) 
                                                                                              from@.Data
                                                                                          }, test = function (object) 
                                                                                            TRUE, replace = function (from, to, value) 
                                                                                            {
                                                                                              .value <- as(from, "genericFunction", TRUE)
                                                                                              as(.value, "function") <- value
                                                                                              value <- .value
                                                                                              {
                                                                                                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                from
                                                                                              }
                                                                                            }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                            {
                                                                                              from <- {
                                                                                                value <- new("genericFunction")
                                                                                                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                value
                                                                                              }
                                                                                              if (strict) 
                                                                                                from@.Data
                                                                                            }, test = function (object) 
                                                                                              TRUE, replace = function (from, to, value) 
                                                                                              {
                                                                                                .value <- as(from, "genericFunction", TRUE)
                                                                                                as(.value, "function") <- value
                                                                                                value <- .value
                                                                                                {
                                                                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                  from
                                                                                                }
                                                                                              }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), genericFunctionWithTrace = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                              {
                                                                                                from <- {
                                                                                                  value <- new("genericFunction")
                                                                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                  value
                                                                                                }
                                                                                                if (strict) 
                                                                                                  from@.Data
                                                                                              }, test = function (object) 
                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                {
                                                                                                  .value <- as(from, "genericFunction", TRUE)
                                                                                                  as(.value, "function") <- value
                                                                                                  value <- .value
                                                                                                  {
                                                                                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                    from
                                                                                                  }
                                                                                                }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), defaultBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                {
                                                                                                  from <- {
                                                                                                    value <- new("activeBindingFunction")
                                                                                                    for (what in ".Data") slot(value, what) <- slot(from, what)
                                                                                                    value
                                                                                                  }
                                                                                                  if (strict) 
                                                                                                    from@.Data
                                                                                                }, test = function (object) 
                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                  {
                                                                                                    .value <- as(from, "activeBindingFunction", TRUE)
                                                                                                    as(.value, "function") <- value
                                                                                                    value <- .value
                                                                                                    {
                                                                                                      for (what in ".Data") slot(from, what) <- slot(value, what)
                                                                                                      from
                                                                                                    }
                                                                                                  }, simple = TRUE, by = "activeBindingFunction", dataPart = TRUE, distance = 2), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                  {
                                                                                                    from <- {
                                                                                                      from <- {
                                                                                                        value <- new("derivedDefaultMethod")
                                                                                                        for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                        value
                                                                                                      }
                                                                                                      {
                                                                                                        class(from) <- "MethodDefinition"
                                                                                                        from
                                                                                                      }
                                                                                                    }
                                                                                                    if (strict) 
                                                                                                      from@.Data
                                                                                                  }, test = function (object) 
                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                    {
                                                                                                      .value <- as(from, "MethodDefinition", TRUE)
                                                                                                      as(.value, "function") <- value
                                                                                                      value <- .value
                                                                                                      {
                                                                                                        .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                                        as(.value, "MethodDefinition") <- value
                                                                                                        value <- .value
                                                                                                        {
                                                                                                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                          from
                                                                                                        }
                                                                                                      }
                                                                                                    }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 3), MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                    {
                                                                                                      from <- {
                                                                                                        from <- {
                                                                                                          value <- new("MethodWithNext")
                                                                                                          for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                          value
                                                                                                        }
                                                                                                        {
                                                                                                          value <- new("MethodDefinition")
                                                                                                          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                          value
                                                                                                        }
                                                                                                      }
                                                                                                      if (strict) 
                                                                                                        from@.Data
                                                                                                    }, test = function (object) 
                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                      {
                                                                                                        .value <- as(from, "MethodDefinition", TRUE)
                                                                                                        as(.value, "function") <- value
                                                                                                        value <- .value
                                                                                                        {
                                                                                                          .value <- as(from, "MethodWithNext", TRUE)
                                                                                                          as(.value, "MethodDefinition") <- value
                                                                                                          value <- .value
                                                                                                          {
                                                                                                            for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                            from
                                                                                                          }
                                                                                                        }
                                                                                                      }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 3), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                      {
                                                                                                        from <- {
                                                                                                          from <- {
                                                                                                            value <- new("derivedDefaultMethod")
                                                                                                            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                            value
                                                                                                          }
                                                                                                          {
                                                                                                            class(from) <- "MethodDefinition"
                                                                                                            from
                                                                                                          }
                                                                                                        }
                                                                                                        if (strict) 
                                                                                                          from@.Data
                                                                                                      }, test = function (object) 
                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                        {
                                                                                                          .value <- as(from, "MethodDefinition", TRUE)
                                                                                                          as(.value, "function") <- value
                                                                                                          value <- .value
                                                                                                          {
                                                                                                            .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                                            as(.value, "MethodDefinition") <- value
                                                                                                            value <- .value
                                                                                                            {
                                                                                                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                              from
                                                                                                            }
                                                                                                          }
                                                                                                        }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 3), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                        {
                                                                                                          from <- {
                                                                                                            from <- {
                                                                                                              class(from) <- "groupGenericFunction"
                                                                                                              from
                                                                                                            }
                                                                                                            {
                                                                                                              value <- new("genericFunction")
                                                                                                              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                              value
                                                                                                            }
                                                                                                          }
                                                                                                          if (strict) 
                                                                                                            from@.Data
                                                                                                        }, test = function (object) 
                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                          {
                                                                                                            .value <- as(from, "genericFunction", TRUE)
                                                                                                            as(.value, "function") <- value
                                                                                                            value <- .value
                                                                                                            {
                                                                                                              .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                              as(.value, "genericFunction") <- value
                                                                                                              value <- .value
                                                                                                              {
                                                                                                                for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                from
                                                                                                              }
                                                                                                            }
                                                                                                          }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 3), standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                          {
                                                                                                            from <- {
                                                                                                              from <- {
                                                                                                                value <- new("standardGeneric")
                                                                                                                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                value
                                                                                                              }
                                                                                                              {
                                                                                                                class(from) <- "genericFunction"
                                                                                                                from
                                                                                                              }
                                                                                                            }
                                                                                                            if (strict) 
                                                                                                              from@.Data
                                                                                                          }, test = function (object) 
                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                            {
                                                                                                              .value <- as(from, "genericFunction", TRUE)
                                                                                                              as(.value, "function") <- value
                                                                                                              value <- .value
                                                                                                              {
                                                                                                                .value <- as(from, "standardGeneric", TRUE)
                                                                                                                as(.value, "genericFunction") <- value
                                                                                                                value <- .value
                                                                                                                {
                                                                                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                  from
                                                                                                                }
                                                                                                              }
                                                                                                            }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 3), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                            {
                                                                                                              from <- {
                                                                                                                from <- {
                                                                                                                  value <- new("groupGenericFunction")
                                                                                                                  for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                  value
                                                                                                                }
                                                                                                                {
                                                                                                                  value <- new("genericFunction")
                                                                                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                  value
                                                                                                                }
                                                                                                              }
                                                                                                              if (strict) 
                                                                                                                from@.Data
                                                                                                            }, test = function (object) 
                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                              {
                                                                                                                .value <- as(from, "genericFunction", TRUE)
                                                                                                                as(.value, "function") <- value
                                                                                                                value <- .value
                                                                                                                {
                                                                                                                  .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                  as(.value, "genericFunction") <- value
                                                                                                                  value <- .value
                                                                                                                  {
                                                                                                                    for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                    from
                                                                                                                  }
                                                                                                                }
                                                                                                              }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 3), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                              {
                                                                                                                from <- {
                                                                                                                  value <- new("refMethodDef")
                                                                                                                  for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                  value
                                                                                                                }
                                                                                                                if (strict) 
                                                                                                                  from@.Data
                                                                                                              }, test = function (object) 
                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                {
                                                                                                                  .value <- as(from, "refMethodDef", TRUE)
                                                                                                                  as(.value, "function") <- value
                                                                                                                  value <- .value
                                                                                                                  {
                                                                                                                    for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                    from
                                                                                                                  }
                                                                                                                }, simple = TRUE, by = "refMethodDef", dataPart = TRUE, distance = 2), externalRefMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                {
                                                                                                                  from <- {
                                                                                                                    value <- new("refMethodDef")
                                                                                                                    for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                    value
                                                                                                                  }
                                                                                                                  if (strict) 
                                                                                                                    from@.Data
                                                                                                                }, test = function (object) 
                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                  {
                                                                                                                    .value <- as(from, "refMethodDef", TRUE)
                                                                                                                    as(.value, "function") <- value
                                                                                                                    value <- .value
                                                                                                                    {
                                                                                                                      for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                      from
                                                                                                                    }
                                                                                                                  }, simple = TRUE, by = "refMethodDef", dataPart = TRUE, distance = 2), refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                  {
                                                                                                                    from <- {
                                                                                                                      value <- new("classGeneratorFunction")
                                                                                                                      for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                                                                                      value
                                                                                                                    }
                                                                                                                    if (strict) 
                                                                                                                      from@.Data
                                                                                                                  }, test = function (object) 
                                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                                    {
                                                                                                                      .value <- as(from, "classGeneratorFunction", TRUE)
                                                                                                                      as(.value, "function") <- value
                                                                                                                      value <- .value
                                                                                                                      {
                                                                                                                        for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                                                                                        from
                                                                                                                      }
                                                                                                                    }, simple = TRUE, by = "classGeneratorFunction", dataPart = TRUE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__functionWithTrace
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", original = "PossibleMethod", source = "environment"), contains = list(`function` = new("SClassExtension", subClass = "functionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "function", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), traceable = new("SClassExtension", subClass = "functionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "traceable")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("functionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "functionWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            from@.Data <- as(value, "function", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "functionWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "function", TRUE)
            as(.value, "PossibleMethod") <- value
            value <- .value
            {
              from@.Data <- as(value, "function", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "functionWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", original = "PossibleMethod", source = "environment"), contains = list(`function` = new("SClassExtension", subClass = "functionWithTrace", superClass = "function", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                      package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                                        attributes(from) <- NULL
                                                                                                                                                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                                                                                                                                                      }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                          from@.Data <- as(value, "function", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), traceable = new("SClassExtension", subClass = "functionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                          from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("functionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                              value
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "functionWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from@.Data <- as(value, "function", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "functionWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                                                                                                                                                              }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from@.Data <- as(value, "function", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "functionWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__genericFunction
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), contains = list(`function` = new("SClassExtension", subClass = "genericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "function", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "genericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      from <- from@.Data
    from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "function", TRUE)
      as(.value, "OptionalFunction") <- value
      value <- .value
      {
        from@.Data <- as(value, "function", strict = FALSE)
        from
      }
    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "genericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "function", TRUE)
        as(.value, "PossibleMethod") <- value
        value <- .value
        {
          from@.Data <- as(value, "function", strict = FALSE)
          from
        }
      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), optionalMethod = new("SClassExtension", subClass = "genericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "optionalMethod") <- value
          value <- .value
          {
            from@.Data <- as(value, "function", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "genericFunction", package = "methods", subclasses = list(standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
        {
          class(from) <- "genericFunction"
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
          {
            class(from) <- "genericFunction"
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
            {
              value <- new("genericFunction")
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
              value
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunctionWithTrace = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
              {
                value <- new("genericFunction")
                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                value
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    class(from) <- "groupGenericFunction"
                    from
                  }
                  {
                    value <- new("genericFunction")
                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                    value
                  }
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "groupGenericFunction", TRUE)
                    as(.value, "genericFunction") <- value
                    value <- .value
                    {
                      for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                      from
                    }
                  }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 2), standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- {
                      value <- new("standardGeneric")
                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                      value
                    }
                    {
                      class(from) <- "genericFunction"
                      from
                    }
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "standardGeneric", TRUE)
                      as(.value, "genericFunction") <- value
                      value <- .value
                      {
                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                        from
                      }
                    }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 2), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- {
                        value <- new("groupGenericFunction")
                        for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                        value
                      }
                      {
                        value <- new("genericFunction")
                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                        value
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "groupGenericFunction", TRUE)
                        as(.value, "genericFunction") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), contains = list(`function` = new("SClassExtension", subClass = "genericFunction", superClass = "function", package = "methods", coerce = function (from, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      strict = TRUE) 
                      {
                        attributes(from) <- NULL
                        from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          from@.Data <- as(value, "function", strict = FALSE)
                          from
                        }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "genericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          if (strict) 
                            from <- from@.Data
                          from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "function", TRUE)
                            as(.value, "OptionalFunction") <- value
                            value <- .value
                            {
                              from@.Data <- as(value, "function", strict = FALSE)
                              from
                            }
                          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "genericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "function", TRUE)
                              as(.value, "PossibleMethod") <- value
                              value <- .value
                              {
                                from@.Data <- as(value, "function", strict = FALSE)
                                from
                              }
                            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), optionalMethod = new("SClassExtension", subClass = "genericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              if (strict) 
                                from <- from@.Data
                              from
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "function", TRUE)
                                as(.value, "optionalMethod") <- value
                                value <- .value
                                {
                                  from@.Data <- as(value, "function", strict = FALSE)
                                  from
                                }
                              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "genericFunction", package = "methods", subclasses = list(standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                class(from) <- "genericFunction"
                                from
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                  from
                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  class(from) <- "genericFunction"
                                  from
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                    from
                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    value <- new("genericFunction")
                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                    value
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                      from
                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunctionWithTrace = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                    {
                                      value <- new("genericFunction")
                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                      value
                                    }, test = function (object) 
                                      TRUE, replace = function (from, to, value) 
                                      {
                                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                        from
                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                      {
                                        from <- {
                                          class(from) <- "groupGenericFunction"
                                          from
                                        }
                                        {
                                          value <- new("genericFunction")
                                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                          value
                                        }
                                      }, test = function (object) 
                                        TRUE, replace = function (from, to, value) 
                                        {
                                          .value <- as(from, "groupGenericFunction", TRUE)
                                          as(.value, "genericFunction") <- value
                                          value <- .value
                                          {
                                            for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                            from
                                          }
                                        }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 2), standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                        {
                                          from <- {
                                            value <- new("standardGeneric")
                                            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                            value
                                          }
                                          {
                                            class(from) <- "genericFunction"
                                            from
                                          }
                                        }, test = function (object) 
                                          TRUE, replace = function (from, to, value) 
                                          {
                                            .value <- as(from, "standardGeneric", TRUE)
                                            as(.value, "genericFunction") <- value
                                            value <- .value
                                            {
                                              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                              from
                                            }
                                          }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 2), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                          {
                                            from <- {
                                              value <- new("groupGenericFunction")
                                              for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                              value
                                            }
                                            {
                                              value <- new("genericFunction")
                                              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                              value
                                            }
                                          }, test = function (object) 
                                            TRUE, replace = function (from, to, value) 
                                            {
                                              .value <- as(from, "groupGenericFunction", TRUE)
                                              as(.value, "genericFunction") <- value
                                              value <- .value
                                              {
                                                for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                from
                                              }
                                            }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__genericFunctionWithTrace
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call", original = "PossibleMethod", source = "environment"), contains = list(genericFunction = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("genericFunction")
  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "traceable")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("genericFunctionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("genericFunction")
          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
          value
        }
        if (strict) 
          from@.Data
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "genericFunction", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("genericFunction")
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
            value
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "genericFunction", TRUE)
            as(.value, "OptionalFunction") <- value
            value <- .value
            {
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              value <- new("genericFunction")
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
              value
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "genericFunction", TRUE)
              as(.value, "PossibleMethod") <- value
              value <- .value
              {
                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                from
              }
            }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                value <- new("genericFunction")
                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                value
              }
              {
                if (strict) 
                  from <- from@.Data
                from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "genericFunction", TRUE)
                as(.value, "optionalMethod") <- value
                value <- .value
                {
                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "genericFunctionWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call", 
                                                                                                                                                                                                                                                                                                                                                             original = "PossibleMethod", source = "environment"), contains = list(genericFunction = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                               value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                               value
                                                                                                                                                                                                                                                                                                                                                             }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                 for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                 from
                                                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                 from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                     if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                       stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("genericFunctionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                     value
                                                                                                                                                                                                                                                                                                                                                                   }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                     from <- {
                                                                                                                                                                                                                                                                                                                                                                       value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                     if (strict) 
                                                                                                                                                                                                                                                                                                                                                                       from@.Data
                                                                                                                                                                                                                                                                                                                                                                   }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                       .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                       as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                       value <- .value
                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                       from <- {
                                                                                                                                                                                                                                                                                                                                                                         value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                         value
                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                         if (strict) 
                                                                                                                                                                                                                                                                                                                                                                           from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                         as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                         from <- {
                                                                                                                                                                                                                                                                                                                                                                           value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                           if (strict) 
                                                                                                                                                                                                                                                                                                                                                                             from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                           as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                           from <- {
                                                                                                                                                                                                                                                                                                                                                                             value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             if (strict) 
                                                                                                                                                                                                                                                                                                                                                                               from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                             as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                             value <- .value
                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "genericFunctionWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__glm
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(lm = new("SClassExtension", subClass = "glm", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "lm")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "glm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "lm")
      else from
    }
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
      as({
        S3Part(from) <- value
        from
      }, "glm"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "glm", package = "methods", subclasses = list(glm.null = new("SClassExtension", subClass = "glm.null", superClass = "glm", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "glm")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(lm = new("SClassExtension", subClass = "glm", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            S3Part(from, S3Class = "lm")
          else from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            S3Part(from) <- value
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "glm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              if (strict) 
                S3Part(from, S3Class = "lm")
              else from
            }
            {
              if (strict) 
                S3Part(from, S3Class = "oldClass")
              else from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
              as({
                S3Part(from) <- value
                from
              }, "glm"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "glm", package = "methods", subclasses = list(glm.null = new("SClassExtension", subClass = "glm.null", superClass = "glm", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  S3Part(from, S3Class = "glm")
                else from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  S3Part(from) <- value
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__glm.null
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(glm = new("SClassExtension", subClass = "glm.null", superClass = "glm", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "glm")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), lm = new("SClassExtension", subClass = "glm.null", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "glm")
      else from
    }
    {
      if (strict) 
        S3Part(from, S3Class = "lm")
      else from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
      as({
        S3Part(from) <- value
        from
      }, "glm.null"), simple = TRUE, by = "glm", dataPart = FALSE, distance = 2), oldClass = new("SClassExtension", subClass = "glm.null", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          if (strict) 
            S3Part(from, S3Class = "glm")
          else from
        }
        {
          from <- {
            if (strict) 
              S3Part(from, S3Class = "lm")
            else from
          }
          {
            if (strict) 
              S3Part(from, S3Class = "oldClass")
            else from
          }
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
          as(as({
            S3Part(from) <- value
            from
          }, "glm"), "glm.null"), simple = TRUE, by = "glm", dataPart = FALSE, distance = 3)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "glm.null", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(glm = new("SClassExtension", subClass = "glm.null", superClass = "glm", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              S3Part(from, S3Class = "glm")
            else from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              S3Part(from) <- value
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), lm = new("SClassExtension", subClass = "glm.null", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                if (strict) 
                  S3Part(from, S3Class = "glm")
                else from
              }
              {
                if (strict) 
                  S3Part(from, S3Class = "lm")
                else from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
                as({
                  S3Part(from) <- value
                  from
                }, "glm.null"), simple = TRUE, by = "glm", dataPart = FALSE, distance = 2), oldClass = new("SClassExtension", subClass = "glm.null", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    if (strict) 
                      S3Part(from, S3Class = "glm")
                    else from
                  }
                  {
                    from <- {
                      if (strict) 
                        S3Part(from, S3Class = "lm")
                      else from
                    }
                    {
                      if (strict) 
                        S3Part(from, S3Class = "oldClass")
                      else from
                    }
                  }
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                    as(as({
                      S3Part(from) <- value
                      from
                    }, "glm"), "glm.null"), simple = TRUE, by = "glm", dataPart = FALSE, distance = 3)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "glm.null", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__groupGenericFunction
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", groupMembers = "list", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), contains = list(genericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("genericFunction")
  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "groupGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      value <- new("genericFunction")
      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
      value
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "genericFunction", TRUE)
      as(.value, "function") <- value
      value <- .value
      {
        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "function", TRUE)
        as(.value, "OptionalFunction") <- value
        value <- .value
        {
          .value <- as(from, "genericFunction", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
            from
          }
        }
      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "groupGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "PossibleMethod") <- value
          value <- .value
          {
            .value <- as(from, "genericFunction", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "groupGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("genericFunction")
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
            value
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "genericFunction", TRUE)
            as(.value, "optionalMethod") <- value
            value <- .value
            {
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "groupGenericFunction", package = "methods", subclasses = list(nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "groupGenericFunction", package = "methods", coerce = function (from, strict = TRUE) 
          {
            class(from) <- "groupGenericFunction"
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "groupGenericFunction", package = "methods", coerce = function (from, strict = TRUE) 
            {
              value <- new("groupGenericFunction")
              for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
              value
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", groupMembers = "list", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), contains = list(genericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "genericFunction", package = "methods", 
                                                                                                                                                                                                                                                                                                                                                                                                                              coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                value
                                                                                                                                                                                                                                                                                                                                                                                                                              }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                  from
                                                                                                                                                                                                                                                                                                                                                                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "groupGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                  from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                    value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                    value
                                                                                                                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                                                                                                                  if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                    from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                    .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                    as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                    value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                  }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                    if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                      from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                                                                                                                  }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                      .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                      as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                      value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                        .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                        as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                        value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                                                                                                                                                                                                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "groupGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                      if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                        from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                                                                                                                    }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                        .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                        as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                        value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                          .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                          as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                          value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "groupGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                        from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                          value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                          value
                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                          if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                            from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                      }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                          .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                          as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                          value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "groupGenericFunction", package = "methods", subclasses = list(nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "groupGenericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                          class(from) <- "groupGenericFunction"
                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                        }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "groupGenericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                            value <- new("groupGenericFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                            value
                                                                                                                                                                                                                                                                                                                                                                                                                                          }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                              for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__groupGenericFunctionWithTrace
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", groupMembers = "list", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call", original = "PossibleMethod", source = "environment"), contains = list(groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "groupGenericFunction", package = "methods", coerce = function (from, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         strict = TRUE) 
{
  value <- new("groupGenericFunction")
  for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "traceable")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("groupGenericFunctionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunction = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("groupGenericFunction")
          for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
          value
        }
        {
          value <- new("genericFunction")
          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
          value
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "groupGenericFunction", TRUE)
          as(.value, "genericFunction") <- value
          value <- .value
          {
            for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("groupGenericFunction")
            for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
            value
          }
          if (strict) 
            from@.Data
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "groupGenericFunction", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "groupGenericFunction", dataPart = TRUE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              value <- new("groupGenericFunction")
              for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
              value
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "groupGenericFunction", TRUE)
              as(.value, "OptionalFunction") <- value
              value <- .value
              {
                for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                from
              }
            }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 4), PossibleMethod = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                value <- new("groupGenericFunction")
                for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                value
              }
              {
                if (strict) 
                  from <- from@.Data
                from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "groupGenericFunction", TRUE)
                as(.value, "PossibleMethod") <- value
                value <- .value
                {
                  for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  value <- new("groupGenericFunction")
                  for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                  value
                }
                {
                  from <- {
                    value <- new("genericFunction")
                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                    value
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "groupGenericFunction", TRUE)
                  as(.value, "optionalMethod") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "groupGenericFunctionWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", groupMembers = "list", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", 
                                                                                                                                                                                                                                                                                                                                                                         default = "optionalMethod", skeleton = "call", original = "PossibleMethod", source = "environment"), contains = list(groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "groupGenericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                           value <- new("groupGenericFunction")
                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                             from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                 if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                   stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("groupGenericFunctionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunction = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                 from <- {
                                                                                                                                                                                                                                                                                                                                                                                   value <- new("groupGenericFunction")
                                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                   value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                               }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                   .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                   as(.value, "genericFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                   value <- .value
                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                   from <- {
                                                                                                                                                                                                                                                                                                                                                                                     value <- new("groupGenericFunction")
                                                                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                     value
                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                   if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                     from@.Data
                                                                                                                                                                                                                                                                                                                                                                                 }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                     .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                     as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                     value <- .value
                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                   }, simple = TRUE, by = "groupGenericFunction", dataPart = TRUE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                     from <- {
                                                                                                                                                                                                                                                                                                                                                                                       value <- new("groupGenericFunction")
                                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                       if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                         from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                   }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                       .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                       as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                       value <- .value
                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 4), PossibleMethod = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                       from <- {
                                                                                                                                                                                                                                                                                                                                                                                         value <- new("groupGenericFunction")
                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                         value
                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                         if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                           from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                         as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                         from <- {
                                                                                                                                                                                                                                                                                                                                                                                           value <- new("groupGenericFunction")
                                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                           from <- {
                                                                                                                                                                                                                                                                                                                                                                                             value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                             if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                               from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                           as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "groupGenericFunctionWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__hsearch
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "hsearch", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "hsearch", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "hsearch", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "hsearch", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__if
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "if", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "language")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("if"), "language", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = if (NA) TRUE else FALSE, validity = NULL, access = list(), className = "if", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "if", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "language")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("if"), "language", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = if (NA) TRUE else FALSE, validity = NULL, access = list(), className = "if", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__integer
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(double = new("SClassExtension", subClass = "integer", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
  as.double(from), test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      class(value) <- "integer"
      value
    }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "integer", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
    {
      class(from) <- "numeric"
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        class(value) <- "integer"
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "integer", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            if (!is(value, "vector")) 
              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("integer"), "vector", dQuote(class(value))), domain = NA)
            value
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), data.frameRowLabels = new("SClassExtension", subClass = "integer", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                if (!is(value, "data.frameRowLabels")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "data.frameRowLabels", dQuote("integer"), "data.frameRowLabels", dQuote(class(value))), domain = NA)
                value
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = integer(0), validity = NULL, access = list(), className = "integer", package = "methods", subclasses = list(factor = new("SClassExtension", subClass = "factor", superClass = "integer", package = "methods", coerce = function (from, strict = TRUE) 
              {
                attributes(from) <- NULL
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  from@.Data <- as(value, "integer", strict = FALSE)
                  from
                }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), ordered = new("SClassExtension", subClass = "ordered", superClass = "integer", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    if (strict) 
                      S3Part(from, S3Class = "factor")
                    else from
                  }
                  if (strict) 
                    from@.Data
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "factor", TRUE)
                    as(.value, "integer") <- value
                    value <- .value
                    {
                      S3Part(from) <- value
                      from
                    }
                  }, simple = TRUE, by = "factor", dataPart = TRUE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(double = new("SClassExtension", subClass = "integer", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
                    as.double(from), test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        class(value) <- "integer"
                        value
                      }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "integer", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        class(from) <- "numeric"
                        from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          class(value) <- "integer"
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "integer", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                          from, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              if (!is(value, "vector")) 
                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("integer"), "vector", dQuote(class(value))), domain = NA)
                              value
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), data.frameRowLabels = new("SClassExtension", subClass = "integer", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                              from, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  if (!is(value, "data.frameRowLabels")) 
                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "data.frameRowLabels", dQuote("integer"), "data.frameRowLabels", dQuote(class(value))), domain = NA)
                                  value
                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = integer(0), validity = NULL, access = list(), className = "integer", package = "methods", subclasses = list(factor = new("SClassExtension", subClass = "factor", superClass = "integer", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  attributes(from) <- NULL
                                  from
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    from@.Data <- as(value, "integer", strict = FALSE)
                                    from
                                  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), ordered = new("SClassExtension", subClass = "ordered", superClass = "integer", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    from <- {
                                      if (strict) 
                                        S3Part(from, S3Class = "factor")
                                      else from
                                    }
                                    if (strict) 
                                      from@.Data
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      .value <- as(from, "factor", TRUE)
                                      as(.value, "integer") <- value
                                      value <- .value
                                      {
                                        S3Part(from) <- value
                                        from
                                      }
                                    }, simple = TRUE, by = "factor", dataPart = TRUE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__integrate
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "integrate", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "integrate", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "integrate", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "integrate", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__internalDispatchMethod
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", internal = "character", target = "signature", defined = "signature", generic = "character"), contains = list(derivedDefaultMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "derivedDefaultMethod", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("derivedDefaultMethod")
  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      value <- new("derivedDefaultMethod")
      for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
      value
    }
    {
      class(from) <- "MethodDefinition"
      from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "derivedDefaultMethod", TRUE)
      as(.value, "MethodDefinition") <- value
      value <- .value
      {
        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- {
        value <- new("derivedDefaultMethod")
        for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
        value
      }
      if (strict) 
        from@.Data
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "derivedDefaultMethod", TRUE)
        as(.value, "function") <- value
        value <- .value
        {
          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
          from
        }
      }, simple = TRUE, by = "derivedDefaultMethod", dataPart = TRUE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("derivedDefaultMethod")
          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
          value
        }
        {
          from <- {
            class(from) <- "MethodDefinition"
            from
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "derivedDefaultMethod", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 4), PossibleMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("derivedDefaultMethod")
            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
            value
          }
          {
            from <- {
              class(from) <- "MethodDefinition"
              from
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "derivedDefaultMethod", TRUE)
            as(.value, "PossibleMethod") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              value <- new("derivedDefaultMethod")
              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
              value
            }
            {
              from <- {
                class(from) <- "MethodDefinition"
                from
              }
              {
                if (strict) 
                  from <- from@.Data
                from
              }
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "derivedDefaultMethod", TRUE)
              as(.value, "optionalMethod") <- value
              value <- .value
              {
                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                from
              }
            }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "internalDispatchMethod", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", internal = "character", target = "signature", defined = "signature", generic = "character"), contains = list(derivedDefaultMethod = new("SClassExtension", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           subClass = "internalDispatchMethod", superClass = "derivedDefaultMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value <- new("derivedDefaultMethod")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- new("derivedDefaultMethod")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 class(from) <- "MethodDefinition"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 as(.value, "MethodDefinition") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value <- new("derivedDefaultMethod")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = "derivedDefaultMethod", dataPart = TRUE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value <- new("derivedDefaultMethod")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       class(from) <- "MethodDefinition"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 4), PossibleMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value <- new("derivedDefaultMethod")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         class(from) <- "MethodDefinition"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         value <- new("derivedDefaultMethod")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class(from) <- "MethodDefinition"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "internalDispatchMethod", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__language
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = `<UNDEFINED>`, validity = NULL, access = list(), className = "language", package = "methods", subclasses = list(name = new("SClassExtension", subClass = "name", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "language")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("name"), "language", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), call = new("SClassExtension", subClass = "call", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "language")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("call"), "language", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `{` = new("SClassExtension", subClass = "{", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "language")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("{"), "language", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `if` = new("SClassExtension", subClass = "if", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
              from, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  if (!is(value, "language")) 
                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("if"), "language", dQuote(class(value))), domain = NA)
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `<-` = new("SClassExtension", subClass = "<-", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "language")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("<-"), "language", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `for` = new("SClassExtension", subClass = "for", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "language")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("for"), "language", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `while` = new("SClassExtension", subClass = "while", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                          from, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              if (!is(value, "language")) 
                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("while"), "language", dQuote(class(value))), domain = NA)
                              value
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `repeat` = new("SClassExtension", subClass = "repeat", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                              from, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  if (!is(value, "language")) 
                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("repeat"), "language", dQuote(class(value))), domain = NA)
                                  value
                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `(` = new("SClassExtension", subClass = "(", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                  from, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      if (!is(value, "language")) 
                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("("), "language", dQuote(class(value))), domain = NA)
                                      value
                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), .name = new("SClassExtension", subClass = ".name", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                    {
                                      from <- as(from, "name", strict = strict)
                                      from
                                    }, test = function (object) 
                                      TRUE, replace = function (from, to, value) 
                                      {
                                        .value <- as(from, "name", TRUE)
                                        as(.value, "language") <- value
                                        value <- .value
                                        {
                                          from@.xData <- value
                                          from
                                        }
                                      }, simple = FALSE, by = "name", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = `<UNDEFINED>`, validity = NULL, access = list(), className = "language", package = "methods", subclasses = list(name = new("SClassExtension", subClass = "name", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                        from, test = function (object) 
                                          TRUE, replace = function (from, to, value) 
                                          {
                                            if (!is(value, "language")) 
                                              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("name"), "language", dQuote(class(value))), domain = NA)
                                            value
                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), call = new("SClassExtension", subClass = "call", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                            from, test = function (object) 
                                              TRUE, replace = function (from, to, value) 
                                              {
                                                if (!is(value, "language")) 
                                                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("call"), "language", dQuote(class(value))), domain = NA)
                                                value
                                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `{` = new("SClassExtension", subClass = "{", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                                from, test = function (object) 
                                                  TRUE, replace = function (from, to, value) 
                                                  {
                                                    if (!is(value, "language")) 
                                                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("{"), "language", dQuote(class(value))), domain = NA)
                                                    value
                                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `if` = new("SClassExtension", subClass = "if", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                                    from, test = function (object) 
                                                      TRUE, replace = function (from, to, value) 
                                                      {
                                                        if (!is(value, "language")) 
                                                          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("if"), "language", dQuote(class(value))), domain = NA)
                                                        value
                                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `<-` = new("SClassExtension", subClass = "<-", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                                        from, test = function (object) 
                                                          TRUE, replace = function (from, to, value) 
                                                          {
                                                            if (!is(value, "language")) 
                                                              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("<-"), "language", dQuote(class(value))), domain = NA)
                                                            value
                                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `for` = new("SClassExtension", subClass = "for", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                                            from, test = function (object) 
                                                              TRUE, replace = function (from, to, value) 
                                                              {
                                                                if (!is(value, "language")) 
                                                                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("for"), "language", dQuote(class(value))), domain = NA)
                                                                value
                                                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `while` = new("SClassExtension", subClass = "while", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                                                from, test = function (object) 
                                                                  TRUE, replace = function (from, to, value) 
                                                                  {
                                                                    if (!is(value, "language")) 
                                                                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("while"), "language", dQuote(class(value))), domain = NA)
                                                                    value
                                                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `repeat` = new("SClassExtension", subClass = "repeat", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                                                    from, test = function (object) 
                                                                      TRUE, replace = function (from, to, value) 
                                                                      {
                                                                        if (!is(value, "language")) 
                                                                          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("repeat"), "language", dQuote(class(value))), domain = NA)
                                                                        value
                                                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `(` = new("SClassExtension", subClass = "(", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                                                        from, test = function (object) 
                                                                          TRUE, replace = function (from, to, value) 
                                                                          {
                                                                            if (!is(value, "language")) 
                                                                              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("("), "language", dQuote(class(value))), domain = NA)
                                                                            value
                                                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), .name = new("SClassExtension", subClass = ".name", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
                                                                          {
                                                                            from <- as(from, "name", strict = strict)
                                                                            from
                                                                          }, test = function (object) 
                                                                            TRUE, replace = function (from, to, value) 
                                                                            {
                                                                              .value <- as(from, "name", TRUE)
                                                                              as(.value, "language") <- value
                                                                              value <- .value
                                                                              {
                                                                                from@.xData <- value
                                                                                from
                                                                              }
                                                                            }, simple = FALSE, by = "name", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__libraryIQR
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "libraryIQR", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "libraryIQR", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "libraryIQR", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "libraryIQR", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__LinearMethodsList
list(`package:methods` = new("classRepresentation", slots = list(methods = "list", arguments = "list", classes = "list", generic = "genericFunction"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "LinearMethodsList", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(methods = "list", arguments = "list", classes = "list", generic = "genericFunction"), 
                                                                                                                                                                                                                                                                                                                                                                                                  contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "LinearMethodsList", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__list
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "list", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "vector")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("list"), "vector", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = list(), validity = NULL, access = list(), className = "list", package = "methods", subclasses = list(data.frame = new("SClassExtension", subClass = "data.frame", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
    {
      attributes(from) <- NULL
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        from@.Data <- as(value, "list", strict = FALSE)
        from
      }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), namedList = new("SClassExtension", subClass = "namedList", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
      {
        attributes(from) <- NULL
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          from@.Data <- as(value, "list", strict = FALSE)
          from
        }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), listOfMethods = new("SClassExtension", subClass = "listOfMethods", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("namedList")
            for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
            value
          }
          if (strict) 
            from@.Data
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "namedList", TRUE)
            as(.value, "list") <- value
            value <- .value
            {
              for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "namedList", dataPart = TRUE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "list", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                if (!is(value, "vector")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("list"), "vector", dQuote(class(value))), domain = NA)
                value
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = list(), validity = NULL, access = list(), className = "list", package = "methods", subclasses = list(data.frame = new("SClassExtension", subClass = "data.frame", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
              {
                attributes(from) <- NULL
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  from@.Data <- as(value, "list", strict = FALSE)
                  from
                }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), namedList = new("SClassExtension", subClass = "namedList", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  attributes(from) <- NULL
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    from@.Data <- as(value, "list", strict = FALSE)
                    from
                  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), listOfMethods = new("SClassExtension", subClass = "listOfMethods", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- {
                      value <- new("namedList")
                      for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
                      value
                    }
                    if (strict) 
                      from@.Data
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "namedList", TRUE)
                      as(.value, "list") <- value
                      value <- .value
                      {
                        for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
                        from
                      }
                    }, simple = TRUE, by = "namedList", dataPart = TRUE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__listOfMethods
list(`package:methods` = new("classRepresentation", slots = list(.Data = "list", arguments = "character", signatures = "list", generic = "genericFunction", names = "character"), contains = list(namedList = new("SClassExtension", subClass = "listOfMethods", superClass = "namedList", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("namedList")
  for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), list = new("SClassExtension", subClass = "listOfMethods", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      value <- new("namedList")
      for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
      value
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "namedList", TRUE)
      as(.value, "list") <- value
      value <- .value
      {
        for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "namedList", dataPart = TRUE, distance = 2), vector = new("SClassExtension", subClass = "listOfMethods", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- {
        value <- new("namedList")
        for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
        value
      }
      {
        if (strict) 
          from <- from@.Data
        from
      }
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "namedList", TRUE)
        as(.value, "vector") <- value
        value <- .value
        {
          for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
          from
        }
      }, simple = TRUE, by = "namedList", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "listOfMethods", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "list", arguments = "character", signatures = "list", generic = "genericFunction", names = "character"), contains = list(namedList = new("SClassExtension", subClass = "listOfMethods", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     superClass = "namedList", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value <- new("namedList")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), list = new("SClassExtension", subClass = "listOfMethods", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           value <- new("namedList")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "namedList", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           as(.value, "list") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = "namedList", dataPart = TRUE, distance = 2), vector = new("SClassExtension", subClass = "listOfMethods", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value <- new("namedList")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             .value <- as(from, "namedList", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             as(.value, "vector") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = "namedList", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "listOfMethods", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__lm
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "lm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "lm", package = "methods", subclasses = list(mlm = new("SClassExtension", subClass = "mlm", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "lm")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), aov = new("SClassExtension", subClass = "aov", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        S3Part(from, S3Class = "lm")
      else from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from) <- value
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), glm = new("SClassExtension", subClass = "glm", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "lm")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), maov = new("SClassExtension", subClass = "maov", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            if (strict) 
              S3Part(from, S3Class = "mlm")
            else from
          }
          {
            if (strict) 
              S3Part(from, S3Class = "lm")
            else from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
            as({
              S3Part(from) <- value
              from
            }, "maov"), simple = TRUE, by = "mlm", dataPart = FALSE, distance = 2), glm.null = new("SClassExtension", subClass = "glm.null", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                if (strict) 
                  S3Part(from, S3Class = "glm")
                else from
              }
              {
                if (strict) 
                  S3Part(from, S3Class = "lm")
                else from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
                as({
                  S3Part(from) <- value
                  from
                }, "glm.null"), simple = TRUE, by = "glm", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "lm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  if (strict) 
                    S3Part(from, S3Class = "oldClass")
                  else from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    S3Part(from) <- value
                    from
                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "lm", package = "methods", subclasses = list(mlm = new("SClassExtension", subClass = "mlm", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    if (strict) 
                      S3Part(from, S3Class = "lm")
                    else from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      S3Part(from) <- value
                      from
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), aov = new("SClassExtension", subClass = "aov", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      if (strict) 
                        S3Part(from, S3Class = "lm")
                      else from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        S3Part(from) <- value
                        from
                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), glm = new("SClassExtension", subClass = "glm", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        if (strict) 
                          S3Part(from, S3Class = "lm")
                        else from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          S3Part(from) <- value
                          from
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), maov = new("SClassExtension", subClass = "maov", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- {
                            if (strict) 
                              S3Part(from, S3Class = "mlm")
                            else from
                          }
                          {
                            if (strict) 
                              S3Part(from, S3Class = "lm")
                            else from
                          }
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                            as({
                              S3Part(from) <- value
                              from
                            }, "maov"), simple = TRUE, by = "mlm", dataPart = FALSE, distance = 2), glm.null = new("SClassExtension", subClass = "glm.null", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              from <- {
                                if (strict) 
                                  S3Part(from, S3Class = "glm")
                                else from
                              }
                              {
                                if (strict) 
                                  S3Part(from, S3Class = "lm")
                                else from
                              }
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                                as({
                                  S3Part(from) <- value
                                  from
                                }, "glm.null"), simple = TRUE, by = "glm", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__localRefClass
list(`package:methods` = new("refClassRepresentation", fieldClasses = list(), fieldPrototypes = <environment>, refMethods = <environment>, refSuperClasses = "envRefClass", slots = list(.xData = "environment"), contains = list(envRefClass = new("SClassExtension", subClass = "localRefClass", superClass = "envRefClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "envRefClass"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in ".xData") slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), .environment = new("SClassExtension", subClass = "localRefClass", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      class(from) <- "envRefClass"
      from
    }
    {
      class(from) <- ".environment"
      from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "envRefClass", TRUE)
      as(.value, ".environment") <- value
      value <- .value
      {
        for (what in ".xData") slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), refClass = new("SClassExtension", subClass = "localRefClass", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- {
        class(from) <- "envRefClass"
        from
      }
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "envRefClass", TRUE)
        as(.value, "refClass") <- value
        value <- .value
        {
          for (what in ".xData") slot(from, what) <- slot(value, what)
          from
        }
      }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), environment = new("SClassExtension", subClass = "localRefClass", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- as(from, "envRefClass", strict = strict)
        {
          from <- as(from, ".environment", strict = strict)
          from@.xData
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "envRefClass", TRUE)
          as(.value, "environment") <- value
          value <- .value
          {
            for (what in ".xData") slot(from, what) <- slot(value, what)
            from
          }
        }, simple = FALSE, by = "envRefClass", dataPart = FALSE, distance = 3), refObject = new("SClassExtension", subClass = "localRefClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            class(from) <- "envRefClass"
            from
          }
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "envRefClass", TRUE)
            as(.value, "refObject") <- value
            value <- .value
            {
              for (what in ".xData") slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "localRefClass", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("refClassRepresentation", fieldClasses = list(), fieldPrototypes = <environment>, refMethods = <environment>, refSuperClasses = "envRefClass", slots = list(.xData = "environment"), contains = list(envRefClass = new("SClassExtension", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              subClass = "localRefClass", superClass = "envRefClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                class(from) <- "envRefClass"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), .environment = new("SClassExtension", subClass = "localRefClass", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    class(from) <- "envRefClass"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    class(from) <- ".environment"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .value <- as(from, "envRefClass", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    as(.value, ".environment") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), refClass = new("SClassExtension", subClass = "localRefClass", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      class(from) <- "envRefClass"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .value <- as(from, "envRefClass", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      as(.value, "refClass") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), environment = new("SClassExtension", subClass = "localRefClass", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from <- as(from, "envRefClass", strict = strict)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from <- as(from, ".environment", strict = strict)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from@.xData
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .value <- as(from, "envRefClass", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        as(.value, "environment") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }, simple = FALSE, by = "envRefClass", dataPart = FALSE, distance = 3), refObject = new("SClassExtension", subClass = "localRefClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          class(from) <- "envRefClass"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .value <- as(from, "envRefClass", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          as(.value, "refObject") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "localRefClass", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__logical
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "logical", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "vector")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("logical"), "vector", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = logical(0), validity = NULL, access = list(), className = "logical", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "logical", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "vector")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("logical"), "vector", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = logical(0), validity = NULL, access = list(), className = "logical", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__logLik
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "logLik", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "logLik", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "logLik", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "logLik", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__maov
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(mlm = new("SClassExtension", subClass = "maov", superClass = "mlm", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "mlm")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), aov = new("SClassExtension", subClass = "maov", superClass = "aov", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "aov")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), lm = new("SClassExtension", subClass = "maov", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- {
        if (strict) 
          S3Part(from, S3Class = "mlm")
        else from
      }
      {
        if (strict) 
          S3Part(from, S3Class = "lm")
        else from
      }
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
        as({
          S3Part(from) <- value
          from
        }, "maov"), simple = TRUE, by = "mlm", dataPart = FALSE, distance = 2), oldClass = new("SClassExtension", subClass = "maov", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            if (strict) 
              S3Part(from, S3Class = "mlm")
            else from
          }
          {
            from <- {
              if (strict) 
                S3Part(from, S3Class = "lm")
              else from
            }
            {
              if (strict) 
                S3Part(from, S3Class = "oldClass")
              else from
            }
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
            as(as({
              S3Part(from) <- value
              from
            }, "mlm"), "maov"), simple = TRUE, by = "mlm", dataPart = FALSE, distance = 3)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "maov", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(mlm = new("SClassExtension", subClass = "maov", superClass = "mlm", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                S3Part(from, S3Class = "mlm")
              else from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                S3Part(from) <- value
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), aov = new("SClassExtension", subClass = "maov", superClass = "aov", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  S3Part(from, S3Class = "aov")
                else from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  S3Part(from) <- value
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), lm = new("SClassExtension", subClass = "maov", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    if (strict) 
                      S3Part(from, S3Class = "mlm")
                    else from
                  }
                  {
                    if (strict) 
                      S3Part(from, S3Class = "lm")
                    else from
                  }
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                    as({
                      S3Part(from) <- value
                      from
                    }, "maov"), simple = TRUE, by = "mlm", dataPart = FALSE, distance = 2), oldClass = new("SClassExtension", subClass = "maov", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- {
                        if (strict) 
                          S3Part(from, S3Class = "mlm")
                        else from
                      }
                      {
                        from <- {
                          if (strict) 
                            S3Part(from, S3Class = "lm")
                          else from
                        }
                        {
                          if (strict) 
                            S3Part(from, S3Class = "oldClass")
                          else from
                        }
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                        as(as({
                          S3Part(from) <- value
                          from
                        }, "mlm"), "maov"), simple = TRUE, by = "mlm", dataPart = FALSE, distance = 3)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "maov", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__matrix
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(array = new("SClassExtension", subClass = "matrix", superClass = "array", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "array"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    class(value) <- "matrix"
    value
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), structure = new("SClassExtension", subClass = "matrix", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      class(from) <- "array"
      from
    }
    from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "array", TRUE)
      as(.value, "structure") <- value
      value <- .value
      {
        class(value) <- "matrix"
        value
      }
    }, simple = TRUE, by = "array", dataPart = FALSE, distance = 2), vector = new("SClassExtension", subClass = "matrix", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- as(from, "array", strict = strict)
      as.vector(from)
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "array", TRUE)
        as(.value, "vector") <- value
        value <- .value
        {
          class(value) <- "matrix"
          value
        }
      }, simple = FALSE, by = "array", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = numeric(0), validity = NULL, access = list(), className = "matrix", package = "methods", subclasses = list(mts = new("SClassExtension", subClass = "mts", superClass = "matrix", package = "methods", coerce = function (from, strict = TRUE) 
      {
        .dm <- dim(from)
        .dn <- dimnames(from)
        attributes(from) <- NULL
        dim(from) <- .dm
        dimnames(from) <- .dn
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          for (what in NULL) slot(from, what) <- slot(value, what)
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(array = new("SClassExtension", subClass = "matrix", superClass = "array", package = "methods", coerce = function (from, strict = TRUE) 
        {
          class(from) <- "array"
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            class(value) <- "matrix"
            value
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), structure = new("SClassExtension", subClass = "matrix", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              class(from) <- "array"
              from
            }
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "array", TRUE)
              as(.value, "structure") <- value
              value <- .value
              {
                class(value) <- "matrix"
                value
              }
            }, simple = TRUE, by = "array", dataPart = FALSE, distance = 2), vector = new("SClassExtension", subClass = "matrix", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- as(from, "array", strict = strict)
              as.vector(from)
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "array", TRUE)
                as(.value, "vector") <- value
                value <- .value
                {
                  class(value) <- "matrix"
                  value
                }
              }, simple = FALSE, by = "array", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = numeric(0), validity = NULL, access = list(), className = "matrix", package = "methods", subclasses = list(mts = new("SClassExtension", subClass = "mts", superClass = "matrix", package = "methods", coerce = function (from, strict = TRUE) 
              {
                .dm <- dim(from)
                .dn <- dimnames(from)
                attributes(from) <- NULL
                dim(from) <- .dm
                dimnames(from) <- .dn
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  for (what in NULL) slot(from, what) <- slot(value, what)
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__MethodDefinition
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character"), contains = list(`function` = new("SClassExtension", subClass = "MethodDefinition", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "function", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), PossibleMethod = new("SClassExtension", subClass = "MethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "PossibleMethod")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "PossibleMethod", dQuote("MethodDefinition"), "PossibleMethod", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "MethodDefinition", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            from@.Data <- as(value, "function", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodDefinition", package = "methods", subclasses = list(derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
        {
          class(from) <- "MethodDefinition"
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
          {
            value <- new("MethodDefinition")
            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
            value
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
            {
              class(from) <- "MethodDefinition"
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinitionWithTrace = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
              {
                value <- new("MethodDefinition")
                for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                value
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    value <- new("derivedDefaultMethod")
                    for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                    value
                  }
                  {
                    class(from) <- "MethodDefinition"
                    from
                  }
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "derivedDefaultMethod", TRUE)
                    as(.value, "MethodDefinition") <- value
                    value <- .value
                    {
                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                      from
                    }
                  }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 2), MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- {
                      value <- new("MethodWithNext")
                      for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                      value
                    }
                    {
                      value <- new("MethodDefinition")
                      for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                      value
                    }
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "MethodWithNext", TRUE)
                      as(.value, "MethodDefinition") <- value
                      value <- .value
                      {
                        for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                        from
                      }
                    }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 2), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- {
                        value <- new("derivedDefaultMethod")
                        for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                        value
                      }
                      {
                        class(from) <- "MethodDefinition"
                        from
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "derivedDefaultMethod", TRUE)
                        as(.value, "MethodDefinition") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character"), contains = list(`function` = new("SClassExtension", subClass = "MethodDefinition", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        attributes(from) <- NULL
                        from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          from@.Data <- as(value, "function", strict = FALSE)
                          from
                        }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), PossibleMethod = new("SClassExtension", subClass = "MethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                          from, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              if (!is(value, "PossibleMethod")) 
                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "PossibleMethod", dQuote("MethodDefinition"), "PossibleMethod", dQuote(class(value))), domain = NA)
                              value
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "MethodDefinition", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              if (strict) 
                                from <- from@.Data
                              from
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "function", TRUE)
                                as(.value, "OptionalFunction") <- value
                                value <- .value
                                {
                                  from@.Data <- as(value, "function", strict = FALSE)
                                  from
                                }
                              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodDefinition", package = "methods", subclasses = list(derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                class(from) <- "MethodDefinition"
                                from
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                  from
                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  value <- new("MethodDefinition")
                                  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                  value
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                    from
                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    class(from) <- "MethodDefinition"
                                    from
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                      from
                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinitionWithTrace = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                    {
                                      value <- new("MethodDefinition")
                                      for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                      value
                                    }, test = function (object) 
                                      TRUE, replace = function (from, to, value) 
                                      {
                                        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                        from
                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                      {
                                        from <- {
                                          value <- new("derivedDefaultMethod")
                                          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                          value
                                        }
                                        {
                                          class(from) <- "MethodDefinition"
                                          from
                                        }
                                      }, test = function (object) 
                                        TRUE, replace = function (from, to, value) 
                                        {
                                          .value <- as(from, "derivedDefaultMethod", TRUE)
                                          as(.value, "MethodDefinition") <- value
                                          value <- .value
                                          {
                                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                            from
                                          }
                                        }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 2), MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                        {
                                          from <- {
                                            value <- new("MethodWithNext")
                                            for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                            value
                                          }
                                          {
                                            value <- new("MethodDefinition")
                                            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                            value
                                          }
                                        }, test = function (object) 
                                          TRUE, replace = function (from, to, value) 
                                          {
                                            .value <- as(from, "MethodWithNext", TRUE)
                                            as(.value, "MethodDefinition") <- value
                                            value <- .value
                                            {
                                              for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                              from
                                            }
                                          }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 2), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                          {
                                            from <- {
                                              value <- new("derivedDefaultMethod")
                                              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                              value
                                            }
                                            {
                                              class(from) <- "MethodDefinition"
                                              from
                                            }
                                          }, test = function (object) 
                                            TRUE, replace = function (from, to, value) 
                                            {
                                              .value <- as(from, "derivedDefaultMethod", TRUE)
                                              as(.value, "MethodDefinition") <- value
                                              value <- .value
                                              {
                                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                from
                                              }
                                            }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__MethodDefinitionWithTrace
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character", original = "PossibleMethod", source = "environment"), contains = list(MethodDefinition = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("MethodDefinition")
  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "traceable")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("MethodDefinitionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("MethodDefinition")
          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
          value
        }
        if (strict) 
          from@.Data
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "MethodDefinition", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("MethodDefinition")
            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
            value
          }
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "MethodDefinition", TRUE)
            as(.value, "PossibleMethod") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              value <- new("MethodDefinition")
              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
              value
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "MethodDefinition", TRUE)
              as(.value, "OptionalFunction") <- value
              value <- .value
              {
                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                from
              }
            }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodDefinitionWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character", original = "PossibleMethod", source = "environment"), contains = list(MethodDefinition = new("SClassExtension", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  subClass = "MethodDefinitionWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    value <- new("MethodDefinition")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("MethodDefinitionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            value <- new("MethodDefinition")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .value <- as(from, "MethodDefinition", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              value <- new("MethodDefinition")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .value <- as(from, "MethodDefinition", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                value <- new("MethodDefinition")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .value <- as(from, "MethodDefinition", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodDefinitionWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__MethodSelectionReport
list(`package:methods` = new("classRepresentation", slots = list(generic = "character", allSelections = "character", target = "character", selected = "character", candidates = "list", note = "character"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodSelectionReport", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(generic = "character", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                allSelections = "character", target = "character", selected = "character", candidates = "list", note = "character"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodSelectionReport", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__MethodsList
list(`package:methods` = new("classRepresentation", slots = list(methods = "list", argument = "name", allMethods = "list"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodsList", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(methods = "list", argument = "name", allMethods = "list"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
                                                                                                                                                                                                                                                                                                                                                                 validity = NULL, access = list(), className = "MethodsList", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__MethodWithNext
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", nextMethod = "PossibleMethod", excluded = "list", target = "signature", defined = "signature", generic = "character"), contains = list(MethodDefinition = new("SClassExtension", subClass = "MethodWithNext", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("MethodDefinition")
  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "MethodWithNext", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      value <- new("MethodDefinition")
      for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
      value
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "MethodDefinition", TRUE)
      as(.value, "function") <- value
      value <- .value
      {
        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "MethodWithNext", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "function", TRUE)
        as(.value, "PossibleMethod") <- value
        value <- .value
        {
          .value <- as(from, "MethodDefinition", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
            from
          }
        }
      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "MethodWithNext", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            .value <- as(from, "MethodDefinition", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "MethodWithNext", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("MethodDefinition")
            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
            value
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "MethodDefinition", TRUE)
            as(.value, "optionalMethod") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodWithNext", package = "methods", subclasses = list(MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "MethodWithNext", package = "methods", coerce = function (from, strict = TRUE) 
          {
            value <- new("MethodWithNext")
            for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
            value
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", nextMethod = "PossibleMethod", excluded = "list", target = "signature", defined = "signature", generic = "character"), contains = list(MethodDefinition = new("SClassExtension", subClass = "MethodWithNext", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
            {
              value <- new("MethodDefinition")
              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
              value
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "MethodWithNext", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  value <- new("MethodDefinition")
                  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                  value
                }
                if (strict) 
                  from@.Data
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "MethodDefinition", TRUE)
                  as(.value, "function") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "MethodWithNext", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  if (strict) 
                    from <- from@.Data
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "function", TRUE)
                    as(.value, "PossibleMethod") <- value
                    value <- .value
                    {
                      .value <- as(from, "MethodDefinition", TRUE)
                      as(.value, "function") <- value
                      value <- .value
                      {
                        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                        from
                      }
                    }
                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "MethodWithNext", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "function", TRUE)
                      as(.value, "OptionalFunction") <- value
                      value <- .value
                      {
                        .value <- as(from, "MethodDefinition", TRUE)
                        as(.value, "function") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }
                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "MethodWithNext", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- {
                        value <- new("MethodDefinition")
                        for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                        value
                      }
                      {
                        if (strict) 
                          from <- from@.Data
                        from
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "MethodDefinition", TRUE)
                        as(.value, "optionalMethod") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodWithNext", package = "methods", subclasses = list(MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "MethodWithNext", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        value <- new("MethodWithNext")
                        for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                        value
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                          from
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__MethodWithNextWithTrace
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", nextMethod = "PossibleMethod", excluded = "list", target = "signature", defined = "signature", generic = "character", original = "PossibleMethod", source = "environment"), contains = list(MethodWithNext = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "MethodWithNext", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("MethodWithNext")
  for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "traceable")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("MethodWithNextWithTrace"), "traceable", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("MethodWithNext")
          for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
          value
        }
        {
          value <- new("MethodDefinition")
          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
          value
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "MethodWithNext", TRUE)
          as(.value, "MethodDefinition") <- value
          value <- .value
          {
            for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("MethodWithNext")
            for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
            value
          }
          if (strict) 
            from@.Data
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "MethodWithNext", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "MethodWithNext", dataPart = TRUE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              value <- new("MethodWithNext")
              for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
              value
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "MethodWithNext", TRUE)
              as(.value, "PossibleMethod") <- value
              value <- .value
              {
                for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                from
              }
            }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 4), OptionalFunction = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                value <- new("MethodWithNext")
                for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                value
              }
              {
                if (strict) 
                  from <- from@.Data
                from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "MethodWithNext", TRUE)
                as(.value, "OptionalFunction") <- value
                value <- .value
                {
                  for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  value <- new("MethodWithNext")
                  for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                  value
                }
                {
                  from <- {
                    value <- new("MethodDefinition")
                    for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                    value
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "MethodWithNext", TRUE)
                  as(.value, "optionalMethod") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodWithNextWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", nextMethod = "PossibleMethod", excluded = "list", target = "signature", defined = "signature", generic = "character", original = "PossibleMethod", source = "environment"), 
                                                                                                                                                                                                                                                                                                                         contains = list(MethodWithNext = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "MethodWithNext", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                           value <- new("MethodWithNext")
                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                             from, test = function (object) 
                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                 if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                   stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("MethodWithNextWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                 from <- {
                                                                                                                                                                                                                                                                                                                                   value <- new("MethodWithNext")
                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                   value <- new("MethodDefinition")
                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                               }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                   .value <- as(from, "MethodWithNext", TRUE)
                                                                                                                                                                                                                                                                                                                                   as(.value, "MethodDefinition") <- value
                                                                                                                                                                                                                                                                                                                                   value <- .value
                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                   from <- {
                                                                                                                                                                                                                                                                                                                                     value <- new("MethodWithNext")
                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                     value
                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                   if (strict) 
                                                                                                                                                                                                                                                                                                                                     from@.Data
                                                                                                                                                                                                                                                                                                                                 }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                     .value <- as(from, "MethodWithNext", TRUE)
                                                                                                                                                                                                                                                                                                                                     as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                     value <- .value
                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                   }, simple = TRUE, by = "MethodWithNext", dataPart = TRUE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                     from <- {
                                                                                                                                                                                                                                                                                                                                       value <- new("MethodWithNext")
                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                       if (strict) 
                                                                                                                                                                                                                                                                                                                                         from <- from@.Data
                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                   }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                       .value <- as(from, "MethodWithNext", TRUE)
                                                                                                                                                                                                                                                                                                                                       as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                       value <- .value
                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 4), OptionalFunction = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                       from <- {
                                                                                                                                                                                                                                                                                                                                         value <- new("MethodWithNext")
                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                         value
                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                         if (strict) 
                                                                                                                                                                                                                                                                                                                                           from <- from@.Data
                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "MethodWithNext", TRUE)
                                                                                                                                                                                                                                                                                                                                         as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                         from <- {
                                                                                                                                                                                                                                                                                                                                           value <- new("MethodWithNext")
                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                           from <- {
                                                                                                                                                                                                                                                                                                                                             value <- new("MethodDefinition")
                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                             if (strict) 
                                                                                                                                                                                                                                                                                                                                               from <- from@.Data
                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "MethodWithNext", TRUE)
                                                                                                                                                                                                                                                                                                                                           as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "MethodWithNextWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__missing
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "missing", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "missing", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__mlm
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(lm = new("SClassExtension", subClass = "mlm", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "lm")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "mlm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "lm")
      else from
    }
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
      as({
        S3Part(from) <- value
        from
      }, "mlm"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "mlm", package = "methods", subclasses = list(maov = new("SClassExtension", subClass = "maov", superClass = "mlm", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "mlm")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(lm = new("SClassExtension", subClass = "mlm", superClass = "lm", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            S3Part(from, S3Class = "lm")
          else from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            S3Part(from) <- value
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "mlm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              if (strict) 
                S3Part(from, S3Class = "lm")
              else from
            }
            {
              if (strict) 
                S3Part(from, S3Class = "oldClass")
              else from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
              as({
                S3Part(from) <- value
                from
              }, "mlm"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "mlm", package = "methods", subclasses = list(maov = new("SClassExtension", subClass = "maov", superClass = "mlm", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  S3Part(from, S3Class = "mlm")
                else from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  S3Part(from) <- value
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__mtable
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "mtable", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "mtable", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "mtable", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "mtable", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__mts
list(`package:methods` = new("classRepresentation", slots = list(.Data = "vector", tsp = "numeric", .S3Class = "character"), contains = list(matrix = new("SClassExtension", subClass = "mts", superClass = "matrix", package = "methods", coerce = function (from, strict = TRUE) 
{
  .dm <- dim(from)
  .dn <- dimnames(from)
  attributes(from) <- NULL
  dim(from) <- .dm
  dimnames(from) <- .dn
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in NULL) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), ts = new("SClassExtension", subClass = "mts", superClass = "ts", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "ts")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), array = new("SClassExtension", subClass = "mts", superClass = "array", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- {
        .dm <- dim(from)
        .dn <- dimnames(from)
        attributes(from) <- NULL
        dim(from) <- .dm
        dimnames(from) <- .dn
        from
      }
      {
        class(from) <- "array"
        from
      }
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "matrix", TRUE)
        as(.value, "array") <- value
        value <- .value
        {
          for (what in NULL) slot(from, what) <- slot(value, what)
          from
        }
      }, simple = TRUE, by = "matrix", dataPart = FALSE, distance = 2), structure = new("SClassExtension", subClass = "mts", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          if (strict) 
            S3Part(from, S3Class = "ts")
          else from
        }
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "ts", TRUE)
          as(.value, "structure") <- value
          value <- .value
          {
            S3Part(from) <- value
            from
          }
        }, simple = TRUE, by = "ts", dataPart = FALSE, distance = 2), oldClass = new("SClassExtension", subClass = "mts", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
        {
          S3Part(from)
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            S3Part(from, needClass = "ts") <- value
            from
          }, simple = TRUE, by = "ts", dataPart = FALSE, distance = 2), vector = new("SClassExtension", subClass = "mts", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- as(from, "ts", strict = strict)
            as.vector(from)
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "ts", TRUE)
              as(.value, "vector") <- value
              value <- .value
              {
                S3Part(from) <- value
                from
              }
            }, simple = FALSE, by = "ts", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "mts", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "vector", tsp = "numeric", .S3Class = "character"), contains = list(matrix = new("SClassExtension", subClass = "mts", superClass = "matrix", package = "methods", coerce = function (from, strict = TRUE) 
            {
              .dm <- dim(from)
              .dn <- dimnames(from)
              attributes(from) <- NULL
              dim(from) <- .dm
              dimnames(from) <- .dn
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in NULL) slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), ts = new("SClassExtension", subClass = "mts", superClass = "ts", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  S3Part(from, S3Class = "ts")
                else from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  S3Part(from) <- value
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), array = new("SClassExtension", subClass = "mts", superClass = "array", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    .dm <- dim(from)
                    .dn <- dimnames(from)
                    attributes(from) <- NULL
                    dim(from) <- .dm
                    dimnames(from) <- .dn
                    from
                  }
                  {
                    class(from) <- "array"
                    from
                  }
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "matrix", TRUE)
                    as(.value, "array") <- value
                    value <- .value
                    {
                      for (what in NULL) slot(from, what) <- slot(value, what)
                      from
                    }
                  }, simple = TRUE, by = "matrix", dataPart = FALSE, distance = 2), structure = new("SClassExtension", subClass = "mts", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- {
                      if (strict) 
                        S3Part(from, S3Class = "ts")
                      else from
                    }
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "ts", TRUE)
                      as(.value, "structure") <- value
                      value <- .value
                      {
                        S3Part(from) <- value
                        from
                      }
                    }, simple = TRUE, by = "ts", dataPart = FALSE, distance = 2), oldClass = new("SClassExtension", subClass = "mts", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      S3Part(from)
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        S3Part(from, needClass = "ts") <- value
                        from
                      }, simple = TRUE, by = "ts", dataPart = FALSE, distance = 2), vector = new("SClassExtension", subClass = "mts", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        from <- as(from, "ts", strict = strict)
                        as.vector(from)
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "ts", TRUE)
                          as(.value, "vector") <- value
                          value <- .value
                          {
                            S3Part(from) <- value
                            from
                          }
                        }, simple = FALSE, by = "ts", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "mts", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__name
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "name", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "language")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("name"), "language", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refObject = new("SClassExtension", subClass = "name", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "refObject")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("name"), "refObject", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = `<UNDEFINED>`, validity = NULL, access = list(), className = "name", package = "methods", subclasses = list(.name = new("SClassExtension", subClass = ".name", superClass = "name", package = "methods", coerce = function (from, strict = TRUE) 
          from@.xData, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              from@.xData <- value
              from
            }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "name", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
              from, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  if (!is(value, "language")) 
                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("name"), "language", dQuote(class(value))), domain = NA)
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refObject = new("SClassExtension", subClass = "name", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "refObject")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("name"), "refObject", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = `<UNDEFINED>`, validity = NULL, access = list(), className = "name", package = "methods", subclasses = list(.name = new("SClassExtension", subClass = ".name", superClass = "name", package = "methods", coerce = function (from, strict = TRUE) 
                      from@.xData, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          from@.xData <- value
                          from
                        }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__namedList
list(`package:methods` = new("classRepresentation", slots = list(.Data = "list", names = "character"), contains = list(list = new("SClassExtension", subClass = "namedList", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "list", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "namedList", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      from <- from@.Data
    from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "list", TRUE)
      as(.value, "vector") <- value
      value <- .value
      {
        from@.Data <- as(value, "list", strict = FALSE)
        from
      }
    }, simple = TRUE, by = "list", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "namedList", package = "methods", subclasses = list(listOfMethods = new("SClassExtension", subClass = "listOfMethods", superClass = "namedList", package = "methods", coerce = function (from, strict = TRUE) 
    {
      value <- new("namedList")
      for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
      value
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "list", names = "character"), contains = list(list = new("SClassExtension", subClass = "namedList", superClass = "list", package = "methods", coerce = function (from, strict = TRUE) 
      {
        attributes(from) <- NULL
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          from@.Data <- as(value, "list", strict = FALSE)
          from
        }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "namedList", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "list", TRUE)
            as(.value, "vector") <- value
            value <- .value
            {
              from@.Data <- as(value, "list", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "list", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "namedList", package = "methods", subclasses = list(listOfMethods = new("SClassExtension", subClass = "listOfMethods", superClass = "namedList", package = "methods", coerce = function (from, strict = TRUE) 
          {
            value <- new("namedList")
            for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
            value
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__nonstandardGeneric
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = new("nonstandardGenericFunction", .Data = function () 
  NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = NULL, skeleton = `<undef>`()), validity = NULL, access = list(), className = "nonstandardGeneric", package = "methods", subclasses = list(nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "nonstandardGeneric")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGenericFunction"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            if (!is(value, "nonstandardGeneric")) 
              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGroupGenericFunction"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
            value
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGenericWithTrace = new("SClassExtension", subClass = "nonstandardGenericWithTrace", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                if (!is(value, "nonstandardGeneric")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGenericWithTrace"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
                value
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = new("nonstandardGenericFunction", .Data = function () 
                NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = NULL, skeleton = `<undef>`()), validity = NULL, access = list(), className = "nonstandardGeneric", package = "methods", subclasses = list(nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "nonstandardGeneric")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGenericFunction"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "nonstandardGeneric")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGroupGenericFunction"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGenericWithTrace = new("SClassExtension", subClass = "nonstandardGenericWithTrace", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
                          from, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              if (!is(value, "nonstandardGeneric")) 
                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGenericWithTrace"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
                              value
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__nonstandardGenericFunction
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), contains = list(genericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "genericFunction"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGeneric = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "nonstandardGeneric")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGenericFunction"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          class(from) <- "genericFunction"
          from
        }
        if (strict) 
          from@.Data
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "genericFunction", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "function", TRUE)
            as(.value, "OptionalFunction") <- value
            value <- .value
            {
              .value <- as(from, "genericFunction", TRUE)
              as(.value, "function") <- value
              value <- .value
              {
                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                from
              }
            }
          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "function", TRUE)
              as(.value, "PossibleMethod") <- value
              value <- .value
              {
                .value <- as(from, "genericFunction", TRUE)
                as(.value, "function") <- value
                value <- .value
                {
                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                  from
                }
              }
            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                class(from) <- "genericFunction"
                from
              }
              {
                if (strict) 
                  from <- from@.Data
                from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "genericFunction", TRUE)
                as(.value, "optionalMethod") <- value
                value <- .value
                {
                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "nonstandardGenericFunction", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), 
                                                                                                                                                                                                                                                                                                                           contains = list(genericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                             class(from) <- "genericFunction"
                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                           }, test = function (object) 
                                                                                                                                                                                                                                                                                                                             TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                             }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGeneric = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                               from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                   if (!is(value, "nonstandardGeneric")) 
                                                                                                                                                                                                                                                                                                                                     stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGenericFunction"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                   from <- {
                                                                                                                                                                                                                                                                                                                                     class(from) <- "genericFunction"
                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                   if (strict) 
                                                                                                                                                                                                                                                                                                                                     from@.Data
                                                                                                                                                                                                                                                                                                                                 }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                     .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                     as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                     value <- .value
                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                   }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                     if (strict) 
                                                                                                                                                                                                                                                                                                                                       from <- from@.Data
                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                   }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                       .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                       as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                       value <- .value
                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                         as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                       if (strict) 
                                                                                                                                                                                                                                                                                                                                         from <- from@.Data
                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                         as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                           as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                         from <- {
                                                                                                                                                                                                                                                                                                                                           class(from) <- "genericFunction"
                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                           if (strict) 
                                                                                                                                                                                                                                                                                                                                             from <- from@.Data
                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "genericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                           as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "nonstandardGenericFunction", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__nonstandardGenericWithTrace
list(`package:methods` = new("classRepresentation", slots = list(original = "PossibleMethod", source = "environment"), contains = list(nonstandardGeneric = new("SClassExtension", subClass = "nonstandardGenericWithTrace", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "nonstandardGeneric")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGenericWithTrace"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "nonstandardGenericWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "traceable")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("nonstandardGenericWithTrace"), "traceable", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "nonstandardGenericWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(original = "PossibleMethod", source = "environment"), contains = list(nonstandardGeneric = new("SClassExtension", subClass = "nonstandardGenericWithTrace", superClass = "nonstandardGeneric", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                    package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                      from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                          if (!is(value, "nonstandardGeneric")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGenericWithTrace"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                          value
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "nonstandardGenericWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                          from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("nonstandardGenericWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                              value
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "nonstandardGenericWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__nonstandardGroupGenericFunction
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", groupMembers = "list", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), contains = list(groupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "groupGenericFunction", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "groupGenericFunction"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGeneric = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "nonstandardGeneric")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGroupGenericFunction"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          class(from) <- "groupGenericFunction"
          from
        }
        {
          value <- new("genericFunction")
          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
          value
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "groupGenericFunction", TRUE)
          as(.value, "genericFunction") <- value
          value <- .value
          {
            for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            class(from) <- "groupGenericFunction"
            from
          }
          if (strict) 
            from@.Data
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "groupGenericFunction", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "groupGenericFunction", dataPart = TRUE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "function", TRUE)
              as(.value, "OptionalFunction") <- value
              value <- .value
              {
                .value <- as(from, "groupGenericFunction", TRUE)
                as(.value, "function") <- value
                value <- .value
                {
                  for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                  from
                }
              }
            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), PossibleMethod = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "function", TRUE)
                as(.value, "PossibleMethod") <- value
                value <- .value
                {
                  .value <- as(from, "groupGenericFunction", TRUE)
                  as(.value, "function") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                    from
                  }
                }
              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  class(from) <- "groupGenericFunction"
                  from
                }
                {
                  from <- {
                    value <- new("genericFunction")
                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                    value
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "groupGenericFunction", TRUE)
                  as(.value, "optionalMethod") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "nonstandardGroupGenericFunction", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", groupMembers = "list", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", 
                                                                                                                                                                                                                                                                                                                                                                           default = "optionalMethod", skeleton = "call"), contains = list(groupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "groupGenericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             class(from) <- "groupGenericFunction"
                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                           }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                             TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                             }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGeneric = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "nonstandardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                               from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                   if (!is(value, "nonstandardGeneric")) 
                                                                                                                                                                                                                                                                                                                                                                                     stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "nonstandardGeneric", dQuote("nonstandardGroupGenericFunction"), "nonstandardGeneric", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                   value
                                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                   from <- {
                                                                                                                                                                                                                                                                                                                                                                                     class(from) <- "groupGenericFunction"
                                                                                                                                                                                                                                                                                                                                                                                     from
                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                     value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                                     for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                     value
                                                                                                                                                                                                                                                                                                                                                                                   }
                                                                                                                                                                                                                                                                                                                                                                                 }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                     .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                     as(.value, "genericFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                     value <- .value
                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                       for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                   }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                     from <- {
                                                                                                                                                                                                                                                                                                                                                                                       class(from) <- "groupGenericFunction"
                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                     }
                                                                                                                                                                                                                                                                                                                                                                                     if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                       from@.Data
                                                                                                                                                                                                                                                                                                                                                                                   }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                       .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                       as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                       value <- .value
                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = "groupGenericFunction", dataPart = TRUE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                       if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                         from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                       from
                                                                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                         as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                           as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), PossibleMethod = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                         if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                           from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                           as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                             .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                             as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                             value <- .value
                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                           from <- {
                                                                                                                                                                                                                                                                                                                                                                                             class(from) <- "groupGenericFunction"
                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                             from <- {
                                                                                                                                                                                                                                                                                                                                                                                               value <- new("genericFunction")
                                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                               value
                                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                               if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                 from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                             .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                             as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                             value <- .value
                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "nonstandardGroupGenericFunction", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__nonStructure
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "nonStructure", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "nonStructure", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, 
                                                                                                                                                                                                                                                                                     sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__NULL
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(OptionalFunction = new("SClassExtension", subClass = "NULL", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "OptionalFunction")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "OptionalFunction", dQuote("NULL"), "OptionalFunction", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), optionalMethod = new("SClassExtension", subClass = "NULL", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "optionalMethod")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("NULL"), "optionalMethod", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = NULL, validity = NULL, access = list(), className = "NULL", package = "methods", subclasses = list(.NULL = new("SClassExtension", subClass = ".NULL", superClass = "NULL", package = "methods", coerce = function (from, strict = TRUE) 
          from@.xData, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              from@.xData <- value
              from
            }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(OptionalFunction = new("SClassExtension", subClass = "NULL", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
              from, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  if (!is(value, "OptionalFunction")) 
                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "OptionalFunction", dQuote("NULL"), "OptionalFunction", dQuote(class(value))), domain = NA)
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), optionalMethod = new("SClassExtension", subClass = "NULL", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "optionalMethod")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("NULL"), "optionalMethod", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = NULL, validity = NULL, access = list(), className = "NULL", package = "methods", subclasses = list(.NULL = new("SClassExtension", subClass = ".NULL", superClass = "NULL", package = "methods", coerce = function (from, strict = TRUE) 
                      from@.xData, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          from@.xData <- value
                          from
                        }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__numeric
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "numeric", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "vector")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("numeric"), "vector", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = numeric(0), validity = NULL, access = list(), className = "numeric", package = "methods", subclasses = list(integer = new("SClassExtension", subClass = "integer", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
    {
      class(from) <- "numeric"
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        class(value) <- "integer"
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), double = new("SClassExtension", subClass = "double", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
      {
        class(from) <- "numeric"
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          class(value) <- "double"
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), factor = new("SClassExtension", subClass = "factor", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          {
            class(from) <- "numeric"
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "integer", TRUE)
            as(.value, "numeric") <- value
            value <- .value
            {
              from@.Data <- as(value, "integer", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), ordered = new("SClassExtension", subClass = "ordered", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              if (strict) 
                S3Part(from, S3Class = "factor")
              else from
            }
            {
              if (strict) 
                from <- from@.Data
              {
                class(from) <- "numeric"
                from
              }
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "factor", TRUE)
              as(.value, "numeric") <- value
              value <- .value
              {
                S3Part(from) <- value
                from
              }
            }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "numeric", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
              from, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  if (!is(value, "vector")) 
                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("numeric"), "vector", dQuote(class(value))), domain = NA)
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = numeric(0), validity = NULL, access = list(), className = "numeric", package = "methods", subclasses = list(integer = new("SClassExtension", subClass = "integer", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  class(from) <- "numeric"
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    class(value) <- "integer"
                    value
                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), double = new("SClassExtension", subClass = "double", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    class(from) <- "numeric"
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      class(value) <- "double"
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), factor = new("SClassExtension", subClass = "factor", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      if (strict) 
                        from <- from@.Data
                      {
                        class(from) <- "numeric"
                        from
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "integer", TRUE)
                        as(.value, "numeric") <- value
                        value <- .value
                        {
                          from@.Data <- as(value, "integer", strict = FALSE)
                          from
                        }
                      }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), ordered = new("SClassExtension", subClass = "ordered", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        from <- {
                          if (strict) 
                            S3Part(from, S3Class = "factor")
                          else from
                        }
                        {
                          if (strict) 
                            from <- from@.Data
                          {
                            class(from) <- "numeric"
                            from
                          }
                        }
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "factor", TRUE)
                          as(.value, "numeric") <- value
                          value <- .value
                          {
                            S3Part(from) <- value
                            from
                          }
                        }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__ObjectsWithPackage
list(`package:methods` = new("classRepresentation", slots = list(.Data = "character", package = "character"), contains = list(character = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "character", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      from <- from@.Data
    from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "character", TRUE)
      as(.value, "vector") <- value
      value <- .value
      {
        from@.Data <- as(value, "character", strict = FALSE)
        from
      }
    }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), data.frameRowLabels = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "character", TRUE)
        as(.value, "data.frameRowLabels") <- value
        value <- .value
        {
          from@.Data <- as(value, "character", strict = FALSE)
          from
        }
      }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), SuperClassMethod = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "character", TRUE)
          as(.value, "SuperClassMethod") <- value
          value <- .value
          {
            from@.Data <- as(value, "character", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "ObjectsWithPackage", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "character", package = "character"), contains = list(character = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "character", package = "methods", coerce = function (from, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              strict = TRUE) 
        {
          attributes(from) <- NULL
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            from@.Data <- as(value, "character", strict = FALSE)
            from
          }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "character", TRUE)
              as(.value, "vector") <- value
              value <- .value
              {
                from@.Data <- as(value, "character", strict = FALSE)
                from
              }
            }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), data.frameRowLabels = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "character", TRUE)
                as(.value, "data.frameRowLabels") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
              }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), SuperClassMethod = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "character", TRUE)
                  as(.value, "SuperClassMethod") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "character", strict = FALSE)
                    from
                  }
                }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "ObjectsWithPackage", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__oldClass
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "oldClass", package = "methods", subclasses = list(data.frame = new("SClassExtension", subClass = "data.frame", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), table = new("SClassExtension", subClass = "table", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), summary.table = new("SClassExtension", subClass = "summary.table", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from) <- value
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), formula = new("SClassExtension", subClass = "formula", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "oldClass")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), lm = new("SClassExtension", subClass = "lm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            S3Part(from, S3Class = "oldClass")
          else from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            S3Part(from) <- value
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), POSIXt = new("SClassExtension", subClass = "POSIXt", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              S3Part(from, S3Class = "oldClass")
            else from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              S3Part(from) <- value
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), Date = new("SClassExtension", subClass = "Date", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                S3Part(from, S3Class = "oldClass")
              else from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                S3Part(from) <- value
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), dump.frames = new("SClassExtension", subClass = "dump.frames", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  S3Part(from, S3Class = "oldClass")
                else from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  S3Part(from) <- value
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), anova.glm = new("SClassExtension", subClass = "anova.glm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  if (strict) 
                    S3Part(from, S3Class = "oldClass")
                  else from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    S3Part(from) <- value
                    from
                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), hsearch = new("SClassExtension", subClass = "hsearch", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    if (strict) 
                      S3Part(from, S3Class = "oldClass")
                    else from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      S3Part(from) <- value
                      from
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), integrate = new("SClassExtension", subClass = "integrate", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      if (strict) 
                        S3Part(from, S3Class = "oldClass")
                      else from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        S3Part(from) <- value
                        from
                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), packageInfo = new("SClassExtension", subClass = "packageInfo", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        if (strict) 
                          S3Part(from, S3Class = "oldClass")
                        else from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          S3Part(from) <- value
                          from
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), libraryIQR = new("SClassExtension", subClass = "libraryIQR", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          if (strict) 
                            S3Part(from, S3Class = "oldClass")
                          else from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            S3Part(from) <- value
                            from
                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), mtable = new("SClassExtension", subClass = "mtable", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              S3Part(from, S3Class = "oldClass")
                            else from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              S3Part(from) <- value
                              from
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), recordedplot = new("SClassExtension", subClass = "recordedplot", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              if (strict) 
                                S3Part(from, S3Class = "oldClass")
                              else from
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                S3Part(from) <- value
                                from
                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), socket = new("SClassExtension", subClass = "socket", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                if (strict) 
                                  S3Part(from, S3Class = "oldClass")
                                else from
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  S3Part(from) <- value
                                  from
                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), packageIQR = new("SClassExtension", subClass = "packageIQR", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  if (strict) 
                                    S3Part(from, S3Class = "oldClass")
                                  else from
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    S3Part(from) <- value
                                    from
                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), density = new("SClassExtension", subClass = "density", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    if (strict) 
                                      S3Part(from, S3Class = "oldClass")
                                    else from
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      S3Part(from) <- value
                                      from
                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), logLik = new("SClassExtension", subClass = "logLik", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                    {
                                      if (strict) 
                                        S3Part(from, S3Class = "oldClass")
                                      else from
                                    }, test = function (object) 
                                      TRUE, replace = function (from, to, value) 
                                      {
                                        S3Part(from) <- value
                                        from
                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), rle = new("SClassExtension", subClass = "rle", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                      {
                                        if (strict) 
                                          S3Part(from, S3Class = "oldClass")
                                        else from
                                      }, test = function (object) 
                                        TRUE, replace = function (from, to, value) 
                                        {
                                          S3Part(from) <- value
                                          from
                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), summaryDefault = new("SClassExtension", subClass = "summaryDefault", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                        {
                                          from <- {
                                            if (strict) 
                                              S3Part(from, S3Class = "table")
                                            else from
                                          }
                                          {
                                            if (strict) 
                                              S3Part(from, S3Class = "oldClass")
                                            else from
                                          }
                                        }, test = function (object) 
                                          TRUE, replace = function (from, to, value) 
                                          {
                                            .value <- as(from, "table", TRUE)
                                            as(.value, "oldClass") <- value
                                            value <- .value
                                            {
                                              S3Part(from) <- value
                                              from
                                            }
                                          }, simple = TRUE, by = "table", dataPart = FALSE, distance = 2), mlm = new("SClassExtension", subClass = "mlm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                          {
                                            from <- {
                                              if (strict) 
                                                S3Part(from, S3Class = "lm")
                                              else from
                                            }
                                            {
                                              if (strict) 
                                                S3Part(from, S3Class = "oldClass")
                                              else from
                                            }
                                          }, test = function (object) 
                                            TRUE, replace = function (from, to, value) 
                                              as({
                                                S3Part(from) <- value
                                                from
                                              }, "mlm"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2), aov = new("SClassExtension", subClass = "aov", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                              {
                                                from <- {
                                                  if (strict) 
                                                    S3Part(from, S3Class = "lm")
                                                  else from
                                                }
                                                {
                                                  if (strict) 
                                                    S3Part(from, S3Class = "oldClass")
                                                  else from
                                                }
                                              }, test = function (object) 
                                                TRUE, replace = function (from, to, value) 
                                                  as({
                                                    S3Part(from) <- value
                                                    from
                                                  }, "aov"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2), glm = new("SClassExtension", subClass = "glm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                  {
                                                    from <- {
                                                      if (strict) 
                                                        S3Part(from, S3Class = "lm")
                                                      else from
                                                    }
                                                    {
                                                      if (strict) 
                                                        S3Part(from, S3Class = "oldClass")
                                                      else from
                                                    }
                                                  }, test = function (object) 
                                                    TRUE, replace = function (from, to, value) 
                                                      as({
                                                        S3Part(from) <- value
                                                        from
                                                      }, "glm"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2), POSIXct = new("SClassExtension", subClass = "POSIXct", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                      {
                                                        from <- {
                                                          if (strict) 
                                                            S3Part(from, S3Class = "POSIXt")
                                                          else from
                                                        }
                                                        {
                                                          if (strict) 
                                                            S3Part(from, S3Class = "oldClass")
                                                          else from
                                                        }
                                                      }, test = function (object) 
                                                        TRUE, replace = function (from, to, value) 
                                                          as({
                                                            S3Part(from) <- value
                                                            from
                                                          }, "POSIXct"), simple = TRUE, by = "POSIXt", dataPart = FALSE, distance = 2), POSIXlt = new("SClassExtension", subClass = "POSIXlt", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                          {
                                                            from <- {
                                                              if (strict) 
                                                                S3Part(from, S3Class = "POSIXt")
                                                              else from
                                                            }
                                                            {
                                                              if (strict) 
                                                                S3Part(from, S3Class = "oldClass")
                                                              else from
                                                            }
                                                          }, test = function (object) 
                                                            TRUE, replace = function (from, to, value) 
                                                              as({
                                                                S3Part(from) <- value
                                                                from
                                                              }, "POSIXlt"), simple = TRUE, by = "POSIXt", dataPart = FALSE, distance = 2), anova.glm.null = new("SClassExtension", subClass = "anova.glm.null", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                              {
                                                                from <- {
                                                                  if (strict) 
                                                                    S3Part(from, S3Class = "anova.glm")
                                                                  else from
                                                                }
                                                                {
                                                                  if (strict) 
                                                                    S3Part(from, S3Class = "oldClass")
                                                                  else from
                                                                }
                                                              }, test = function (object) 
                                                                TRUE, replace = function (from, to, value) 
                                                                  as({
                                                                    S3Part(from) <- value
                                                                    from
                                                                  }, "anova.glm.null"), simple = TRUE, by = "anova.glm", dataPart = FALSE, distance = 2), maov = new("SClassExtension", subClass = "maov", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                  {
                                                                    from <- {
                                                                      from <- {
                                                                        if (strict) 
                                                                          S3Part(from, S3Class = "mlm")
                                                                        else from
                                                                      }
                                                                      {
                                                                        if (strict) 
                                                                          S3Part(from, S3Class = "lm")
                                                                        else from
                                                                      }
                                                                    }
                                                                    {
                                                                      if (strict) 
                                                                        S3Part(from, S3Class = "oldClass")
                                                                      else from
                                                                    }
                                                                  }, test = function (object) 
                                                                    TRUE, replace = function (from, to, value) 
                                                                      as({
                                                                        S3Part(from) <- value
                                                                        from
                                                                      }, "maov"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 3), glm.null = new("SClassExtension", subClass = "glm.null", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                      {
                                                                        from <- {
                                                                          from <- {
                                                                            if (strict) 
                                                                              S3Part(from, S3Class = "glm")
                                                                            else from
                                                                          }
                                                                          {
                                                                            if (strict) 
                                                                              S3Part(from, S3Class = "lm")
                                                                            else from
                                                                          }
                                                                        }
                                                                        {
                                                                          if (strict) 
                                                                            S3Part(from, S3Class = "oldClass")
                                                                          else from
                                                                        }
                                                                      }, test = function (object) 
                                                                        TRUE, replace = function (from, to, value) 
                                                                          as({
                                                                            S3Part(from) <- value
                                                                            from
                                                                          }, "glm.null"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "oldClass", package = "methods", subclasses = list(data.frame = new("SClassExtension", subClass = "data.frame", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                          {
                                                                            if (strict) 
                                                                              S3Part(from, S3Class = "oldClass")
                                                                            else from
                                                                          }, test = function (object) 
                                                                            TRUE, replace = function (from, to, value) 
                                                                            {
                                                                              S3Part(from) <- value
                                                                              from
                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), table = new("SClassExtension", subClass = "table", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                            {
                                                                              if (strict) 
                                                                                S3Part(from, S3Class = "oldClass")
                                                                              else from
                                                                            }, test = function (object) 
                                                                              TRUE, replace = function (from, to, value) 
                                                                              {
                                                                                S3Part(from) <- value
                                                                                from
                                                                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), summary.table = new("SClassExtension", subClass = "summary.table", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                              {
                                                                                if (strict) 
                                                                                  S3Part(from, S3Class = "oldClass")
                                                                                else from
                                                                              }, test = function (object) 
                                                                                TRUE, replace = function (from, to, value) 
                                                                                {
                                                                                  S3Part(from) <- value
                                                                                  from
                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), formula = new("SClassExtension", subClass = "formula", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                {
                                                                                  if (strict) 
                                                                                    S3Part(from, S3Class = "oldClass")
                                                                                  else from
                                                                                }, test = function (object) 
                                                                                  TRUE, replace = function (from, to, value) 
                                                                                  {
                                                                                    S3Part(from) <- value
                                                                                    from
                                                                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), lm = new("SClassExtension", subClass = "lm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                  {
                                                                                    if (strict) 
                                                                                      S3Part(from, S3Class = "oldClass")
                                                                                    else from
                                                                                  }, test = function (object) 
                                                                                    TRUE, replace = function (from, to, value) 
                                                                                    {
                                                                                      S3Part(from) <- value
                                                                                      from
                                                                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), POSIXt = new("SClassExtension", subClass = "POSIXt", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                    {
                                                                                      if (strict) 
                                                                                        S3Part(from, S3Class = "oldClass")
                                                                                      else from
                                                                                    }, test = function (object) 
                                                                                      TRUE, replace = function (from, to, value) 
                                                                                      {
                                                                                        S3Part(from) <- value
                                                                                        from
                                                                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), Date = new("SClassExtension", subClass = "Date", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                      {
                                                                                        if (strict) 
                                                                                          S3Part(from, S3Class = "oldClass")
                                                                                        else from
                                                                                      }, test = function (object) 
                                                                                        TRUE, replace = function (from, to, value) 
                                                                                        {
                                                                                          S3Part(from) <- value
                                                                                          from
                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), dump.frames = new("SClassExtension", subClass = "dump.frames", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                        {
                                                                                          if (strict) 
                                                                                            S3Part(from, S3Class = "oldClass")
                                                                                          else from
                                                                                        }, test = function (object) 
                                                                                          TRUE, replace = function (from, to, value) 
                                                                                          {
                                                                                            S3Part(from) <- value
                                                                                            from
                                                                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), anova.glm = new("SClassExtension", subClass = "anova.glm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                          {
                                                                                            if (strict) 
                                                                                              S3Part(from, S3Class = "oldClass")
                                                                                            else from
                                                                                          }, test = function (object) 
                                                                                            TRUE, replace = function (from, to, value) 
                                                                                            {
                                                                                              S3Part(from) <- value
                                                                                              from
                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), hsearch = new("SClassExtension", subClass = "hsearch", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                            {
                                                                                              if (strict) 
                                                                                                S3Part(from, S3Class = "oldClass")
                                                                                              else from
                                                                                            }, test = function (object) 
                                                                                              TRUE, replace = function (from, to, value) 
                                                                                              {
                                                                                                S3Part(from) <- value
                                                                                                from
                                                                                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), integrate = new("SClassExtension", subClass = "integrate", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                              {
                                                                                                if (strict) 
                                                                                                  S3Part(from, S3Class = "oldClass")
                                                                                                else from
                                                                                              }, test = function (object) 
                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                {
                                                                                                  S3Part(from) <- value
                                                                                                  from
                                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), packageInfo = new("SClassExtension", subClass = "packageInfo", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                {
                                                                                                  if (strict) 
                                                                                                    S3Part(from, S3Class = "oldClass")
                                                                                                  else from
                                                                                                }, test = function (object) 
                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                  {
                                                                                                    S3Part(from) <- value
                                                                                                    from
                                                                                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), libraryIQR = new("SClassExtension", subClass = "libraryIQR", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                  {
                                                                                                    if (strict) 
                                                                                                      S3Part(from, S3Class = "oldClass")
                                                                                                    else from
                                                                                                  }, test = function (object) 
                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                    {
                                                                                                      S3Part(from) <- value
                                                                                                      from
                                                                                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), mtable = new("SClassExtension", subClass = "mtable", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                    {
                                                                                                      if (strict) 
                                                                                                        S3Part(from, S3Class = "oldClass")
                                                                                                      else from
                                                                                                    }, test = function (object) 
                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                      {
                                                                                                        S3Part(from) <- value
                                                                                                        from
                                                                                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), recordedplot = new("SClassExtension", subClass = "recordedplot", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                      {
                                                                                                        if (strict) 
                                                                                                          S3Part(from, S3Class = "oldClass")
                                                                                                        else from
                                                                                                      }, test = function (object) 
                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                        {
                                                                                                          S3Part(from) <- value
                                                                                                          from
                                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), socket = new("SClassExtension", subClass = "socket", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                        {
                                                                                                          if (strict) 
                                                                                                            S3Part(from, S3Class = "oldClass")
                                                                                                          else from
                                                                                                        }, test = function (object) 
                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                          {
                                                                                                            S3Part(from) <- value
                                                                                                            from
                                                                                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), packageIQR = new("SClassExtension", subClass = "packageIQR", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                          {
                                                                                                            if (strict) 
                                                                                                              S3Part(from, S3Class = "oldClass")
                                                                                                            else from
                                                                                                          }, test = function (object) 
                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                            {
                                                                                                              S3Part(from) <- value
                                                                                                              from
                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), density = new("SClassExtension", subClass = "density", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                            {
                                                                                                              if (strict) 
                                                                                                                S3Part(from, S3Class = "oldClass")
                                                                                                              else from
                                                                                                            }, test = function (object) 
                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                              {
                                                                                                                S3Part(from) <- value
                                                                                                                from
                                                                                                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), logLik = new("SClassExtension", subClass = "logLik", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                              {
                                                                                                                if (strict) 
                                                                                                                  S3Part(from, S3Class = "oldClass")
                                                                                                                else from
                                                                                                              }, test = function (object) 
                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                {
                                                                                                                  S3Part(from) <- value
                                                                                                                  from
                                                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), rle = new("SClassExtension", subClass = "rle", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                {
                                                                                                                  if (strict) 
                                                                                                                    S3Part(from, S3Class = "oldClass")
                                                                                                                  else from
                                                                                                                }, test = function (object) 
                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                  {
                                                                                                                    S3Part(from) <- value
                                                                                                                    from
                                                                                                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), summaryDefault = new("SClassExtension", subClass = "summaryDefault", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                  {
                                                                                                                    from <- {
                                                                                                                      if (strict) 
                                                                                                                        S3Part(from, S3Class = "table")
                                                                                                                      else from
                                                                                                                    }
                                                                                                                    {
                                                                                                                      if (strict) 
                                                                                                                        S3Part(from, S3Class = "oldClass")
                                                                                                                      else from
                                                                                                                    }
                                                                                                                  }, test = function (object) 
                                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                                    {
                                                                                                                      .value <- as(from, "table", TRUE)
                                                                                                                      as(.value, "oldClass") <- value
                                                                                                                      value <- .value
                                                                                                                      {
                                                                                                                        S3Part(from) <- value
                                                                                                                        from
                                                                                                                      }
                                                                                                                    }, simple = TRUE, by = "table", dataPart = FALSE, distance = 2), mlm = new("SClassExtension", subClass = "mlm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                    {
                                                                                                                      from <- {
                                                                                                                        if (strict) 
                                                                                                                          S3Part(from, S3Class = "lm")
                                                                                                                        else from
                                                                                                                      }
                                                                                                                      {
                                                                                                                        if (strict) 
                                                                                                                          S3Part(from, S3Class = "oldClass")
                                                                                                                        else from
                                                                                                                      }
                                                                                                                    }, test = function (object) 
                                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                                        as({
                                                                                                                          S3Part(from) <- value
                                                                                                                          from
                                                                                                                        }, "mlm"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2), aov = new("SClassExtension", subClass = "aov", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                        {
                                                                                                                          from <- {
                                                                                                                            if (strict) 
                                                                                                                              S3Part(from, S3Class = "lm")
                                                                                                                            else from
                                                                                                                          }
                                                                                                                          {
                                                                                                                            if (strict) 
                                                                                                                              S3Part(from, S3Class = "oldClass")
                                                                                                                            else from
                                                                                                                          }
                                                                                                                        }, test = function (object) 
                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                            as({
                                                                                                                              S3Part(from) <- value
                                                                                                                              from
                                                                                                                            }, "aov"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2), glm = new("SClassExtension", subClass = "glm", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                            {
                                                                                                                              from <- {
                                                                                                                                if (strict) 
                                                                                                                                  S3Part(from, S3Class = "lm")
                                                                                                                                else from
                                                                                                                              }
                                                                                                                              {
                                                                                                                                if (strict) 
                                                                                                                                  S3Part(from, S3Class = "oldClass")
                                                                                                                                else from
                                                                                                                              }
                                                                                                                            }, test = function (object) 
                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                                as({
                                                                                                                                  S3Part(from) <- value
                                                                                                                                  from
                                                                                                                                }, "glm"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 2), POSIXct = new("SClassExtension", subClass = "POSIXct", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                {
                                                                                                                                  from <- {
                                                                                                                                    if (strict) 
                                                                                                                                      S3Part(from, S3Class = "POSIXt")
                                                                                                                                    else from
                                                                                                                                  }
                                                                                                                                  {
                                                                                                                                    if (strict) 
                                                                                                                                      S3Part(from, S3Class = "oldClass")
                                                                                                                                    else from
                                                                                                                                  }
                                                                                                                                }, test = function (object) 
                                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                                    as({
                                                                                                                                      S3Part(from) <- value
                                                                                                                                      from
                                                                                                                                    }, "POSIXct"), simple = TRUE, by = "POSIXt", dataPart = FALSE, distance = 2), POSIXlt = new("SClassExtension", subClass = "POSIXlt", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                    {
                                                                                                                                      from <- {
                                                                                                                                        if (strict) 
                                                                                                                                          S3Part(from, S3Class = "POSIXt")
                                                                                                                                        else from
                                                                                                                                      }
                                                                                                                                      {
                                                                                                                                        if (strict) 
                                                                                                                                          S3Part(from, S3Class = "oldClass")
                                                                                                                                        else from
                                                                                                                                      }
                                                                                                                                    }, test = function (object) 
                                                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                                                        as({
                                                                                                                                          S3Part(from) <- value
                                                                                                                                          from
                                                                                                                                        }, "POSIXlt"), simple = TRUE, by = "POSIXt", dataPart = FALSE, distance = 2), anova.glm.null = new("SClassExtension", subClass = "anova.glm.null", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                        {
                                                                                                                                          from <- {
                                                                                                                                            if (strict) 
                                                                                                                                              S3Part(from, S3Class = "anova.glm")
                                                                                                                                            else from
                                                                                                                                          }
                                                                                                                                          {
                                                                                                                                            if (strict) 
                                                                                                                                              S3Part(from, S3Class = "oldClass")
                                                                                                                                            else from
                                                                                                                                          }
                                                                                                                                        }, test = function (object) 
                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                            as({
                                                                                                                                              S3Part(from) <- value
                                                                                                                                              from
                                                                                                                                            }, "anova.glm.null"), simple = TRUE, by = "anova.glm", dataPart = FALSE, distance = 2), maov = new("SClassExtension", subClass = "maov", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                            {
                                                                                                                                              from <- {
                                                                                                                                                from <- {
                                                                                                                                                  if (strict) 
                                                                                                                                                    S3Part(from, S3Class = "mlm")
                                                                                                                                                  else from
                                                                                                                                                }
                                                                                                                                                {
                                                                                                                                                  if (strict) 
                                                                                                                                                    S3Part(from, S3Class = "lm")
                                                                                                                                                  else from
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                              {
                                                                                                                                                if (strict) 
                                                                                                                                                  S3Part(from, S3Class = "oldClass")
                                                                                                                                                else from
                                                                                                                                              }
                                                                                                                                            }, test = function (object) 
                                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                                                as({
                                                                                                                                                  S3Part(from) <- value
                                                                                                                                                  from
                                                                                                                                                }, "maov"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 3), glm.null = new("SClassExtension", subClass = "glm.null", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                {
                                                                                                                                                  from <- {
                                                                                                                                                    from <- {
                                                                                                                                                      if (strict) 
                                                                                                                                                        S3Part(from, S3Class = "glm")
                                                                                                                                                      else from
                                                                                                                                                    }
                                                                                                                                                    {
                                                                                                                                                      if (strict) 
                                                                                                                                                        S3Part(from, S3Class = "lm")
                                                                                                                                                      else from
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                  {
                                                                                                                                                    if (strict) 
                                                                                                                                                      S3Part(from, S3Class = "oldClass")
                                                                                                                                                    else from
                                                                                                                                                  }
                                                                                                                                                }, test = function (object) 
                                                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                                                    as({
                                                                                                                                                      S3Part(from) <- value
                                                                                                                                                      from
                                                                                                                                                    }, "glm.null"), simple = TRUE, by = "lm", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__OptionalFunction
list(`package:methods` = new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "OptionalFunction", package = "methods", subclasses = list(`NULL` = new("SClassExtension", subClass = "NULL", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "OptionalFunction")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "OptionalFunction", dQuote("NULL"), "OptionalFunction", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "function", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "OptionalFunction")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "OptionalFunction", dQuote("function"), "OptionalFunction", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), classGeneratorFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "function", TRUE)
            as(.value, "OptionalFunction") <- value
            value <- .value
            {
              from@.Data <- as(value, "function", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), MethodDefinition = new("SClassExtension", subClass = "MethodDefinition", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "function", TRUE)
              as(.value, "OptionalFunction") <- value
              value <- .value
              {
                from@.Data <- as(value, "function", strict = FALSE)
                from
              }
            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), genericFunction = new("SClassExtension", subClass = "genericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "function", TRUE)
                as(.value, "OptionalFunction") <- value
                value <- .value
                {
                  from@.Data <- as(value, "function", strict = FALSE)
                  from
                }
              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
              {
                if (strict) 
                  from <- from@.Data
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "function", TRUE)
                  as(.value, "OptionalFunction") <- value
                  value <- .value
                  {
                    .value <- as(from, "MethodDefinition", TRUE)
                    as(.value, "function") <- value
                    value <- .value
                    {
                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                      from
                    }
                  }
                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  if (strict) 
                    from <- from@.Data
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "function", TRUE)
                    as(.value, "OptionalFunction") <- value
                    value <- .value
                    {
                      .value <- as(from, "MethodDefinition", TRUE)
                      as(.value, "function") <- value
                      value <- .value
                      {
                        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                        from
                      }
                    }
                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "function", TRUE)
                      as(.value, "OptionalFunction") <- value
                      value <- .value
                      {
                        .value <- as(from, "MethodDefinition", TRUE)
                        as(.value, "function") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }
                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      if (strict) 
                        from <- from@.Data
                      from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "function", TRUE)
                        as(.value, "OptionalFunction") <- value
                        value <- .value
                        {
                          .value <- as(from, "genericFunction", TRUE)
                          as(.value, "function") <- value
                          value <- .value
                          {
                            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                            from
                          }
                        }
                      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        if (strict) 
                          from <- from@.Data
                        from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "function", TRUE)
                          as(.value, "OptionalFunction") <- value
                          value <- .value
                          {
                            .value <- as(from, "genericFunction", TRUE)
                            as(.value, "function") <- value
                            value <- .value
                            {
                              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                              from
                            }
                          }
                        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          if (strict) 
                            from <- from@.Data
                          from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "function", TRUE)
                            as(.value, "OptionalFunction") <- value
                            value <- .value
                            {
                              .value <- as(from, "genericFunction", TRUE)
                              as(.value, "function") <- value
                              value <- .value
                              {
                                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                from
                              }
                            }
                          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "function", TRUE)
                              as(.value, "OptionalFunction") <- value
                              value <- .value
                              {
                                .value <- as(from, "MethodDefinition", TRUE)
                                as(.value, "function") <- value
                                value <- .value
                                {
                                  .value <- as(from, "derivedDefaultMethod", TRUE)
                                  as(.value, "MethodDefinition") <- value
                                  value <- .value
                                  {
                                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }
                              }
                            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              if (strict) 
                                from <- from@.Data
                              from
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "function", TRUE)
                                as(.value, "OptionalFunction") <- value
                                value <- .value
                                {
                                  .value <- as(from, "groupGenericFunction", TRUE)
                                  as(.value, "function") <- value
                                  value <- .value
                                  {
                                    for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }
                              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), .NULL = new("SClassExtension", subClass = ".NULL", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                from <- as(from, "NULL", strict = strict)
                                from
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "NULL", TRUE)
                                  as(.value, "OptionalFunction") <- value
                                  value <- .value
                                  {
                                    from@.xData <- value
                                    from
                                  }
                                }, simple = FALSE, by = "NULL", dataPart = FALSE, distance = 2), defaultBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  from <- {
                                    value <- new("activeBindingFunction")
                                    for (what in ".Data") slot(value, what) <- slot(from, what)
                                    value
                                  }
                                  {
                                    if (strict) 
                                      from <- from@.Data
                                    from
                                  }
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    .value <- as(from, "activeBindingFunction", TRUE)
                                    as(.value, "OptionalFunction") <- value
                                    value <- .value
                                    {
                                      for (what in ".Data") slot(from, what) <- slot(value, what)
                                      from
                                    }
                                  }, simple = TRUE, by = "activeBindingFunction", dataPart = FALSE, distance = 3), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    from <- {
                                      value <- new("refMethodDef")
                                      for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                      value
                                    }
                                    {
                                      if (strict) 
                                        from <- from@.Data
                                      from
                                    }
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      .value <- as(from, "refMethodDef", TRUE)
                                      as(.value, "OptionalFunction") <- value
                                      value <- .value
                                      {
                                        for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                        from
                                      }
                                    }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), externalRefMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                    {
                                      from <- {
                                        value <- new("refMethodDef")
                                        for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                        value
                                      }
                                      {
                                        if (strict) 
                                          from <- from@.Data
                                        from
                                      }
                                    }, test = function (object) 
                                      TRUE, replace = function (from, to, value) 
                                      {
                                        .value <- as(from, "refMethodDef", TRUE)
                                        as(.value, "OptionalFunction") <- value
                                        value <- .value
                                        {
                                          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                          from
                                        }
                                      }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE), new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "OptionalFunction", package = "methods", subclasses = list(`NULL` = new("SClassExtension", subClass = "NULL", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                        from, test = function (object) 
                                          TRUE, replace = function (from, to, value) 
                                          {
                                            if (!is(value, "OptionalFunction")) 
                                              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "OptionalFunction", dQuote("NULL"), "OptionalFunction", dQuote(class(value))), domain = NA)
                                            value
                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "function", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                            from, test = function (object) 
                                              TRUE, replace = function (from, to, value) 
                                              {
                                                if (!is(value, "OptionalFunction")) 
                                                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "OptionalFunction", dQuote("function"), "OptionalFunction", dQuote(class(value))), domain = NA)
                                                value
                                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), classGeneratorFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                              {
                                                if (strict) 
                                                  from <- from@.Data
                                                from
                                              }, test = function (object) 
                                                TRUE, replace = function (from, to, value) 
                                                {
                                                  .value <- as(from, "function", TRUE)
                                                  as(.value, "OptionalFunction") <- value
                                                  value <- .value
                                                  {
                                                    from@.Data <- as(value, "function", strict = FALSE)
                                                    from
                                                  }
                                                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), MethodDefinition = new("SClassExtension", subClass = "MethodDefinition", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                {
                                                  if (strict) 
                                                    from <- from@.Data
                                                  from
                                                }, test = function (object) 
                                                  TRUE, replace = function (from, to, value) 
                                                  {
                                                    .value <- as(from, "function", TRUE)
                                                    as(.value, "OptionalFunction") <- value
                                                    value <- .value
                                                    {
                                                      from@.Data <- as(value, "function", strict = FALSE)
                                                      from
                                                    }
                                                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), genericFunction = new("SClassExtension", subClass = "genericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                  {
                                                    if (strict) 
                                                      from <- from@.Data
                                                    from
                                                  }, test = function (object) 
                                                    TRUE, replace = function (from, to, value) 
                                                    {
                                                      .value <- as(from, "function", TRUE)
                                                      as(.value, "OptionalFunction") <- value
                                                      value <- .value
                                                      {
                                                        from@.Data <- as(value, "function", strict = FALSE)
                                                        from
                                                      }
                                                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                    {
                                                      if (strict) 
                                                        from <- from@.Data
                                                      from
                                                    }, test = function (object) 
                                                      TRUE, replace = function (from, to, value) 
                                                      {
                                                        .value <- as(from, "function", TRUE)
                                                        as(.value, "OptionalFunction") <- value
                                                        value <- .value
                                                        {
                                                          .value <- as(from, "MethodDefinition", TRUE)
                                                          as(.value, "function") <- value
                                                          value <- .value
                                                          {
                                                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                            from
                                                          }
                                                        }
                                                      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                      {
                                                        if (strict) 
                                                          from <- from@.Data
                                                        from
                                                      }, test = function (object) 
                                                        TRUE, replace = function (from, to, value) 
                                                        {
                                                          .value <- as(from, "function", TRUE)
                                                          as(.value, "OptionalFunction") <- value
                                                          value <- .value
                                                          {
                                                            .value <- as(from, "MethodDefinition", TRUE)
                                                            as(.value, "function") <- value
                                                            value <- .value
                                                            {
                                                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                              from
                                                            }
                                                          }
                                                        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                        {
                                                          if (strict) 
                                                            from <- from@.Data
                                                          from
                                                        }, test = function (object) 
                                                          TRUE, replace = function (from, to, value) 
                                                          {
                                                            .value <- as(from, "function", TRUE)
                                                            as(.value, "OptionalFunction") <- value
                                                            value <- .value
                                                            {
                                                              .value <- as(from, "MethodDefinition", TRUE)
                                                              as(.value, "function") <- value
                                                              value <- .value
                                                              {
                                                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                from
                                                              }
                                                            }
                                                          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                          {
                                                            if (strict) 
                                                              from <- from@.Data
                                                            from
                                                          }, test = function (object) 
                                                            TRUE, replace = function (from, to, value) 
                                                            {
                                                              .value <- as(from, "function", TRUE)
                                                              as(.value, "OptionalFunction") <- value
                                                              value <- .value
                                                              {
                                                                .value <- as(from, "genericFunction", TRUE)
                                                                as(.value, "function") <- value
                                                                value <- .value
                                                                {
                                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                  from
                                                                }
                                                              }
                                                            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                            {
                                                              if (strict) 
                                                                from <- from@.Data
                                                              from
                                                            }, test = function (object) 
                                                              TRUE, replace = function (from, to, value) 
                                                              {
                                                                .value <- as(from, "function", TRUE)
                                                                as(.value, "OptionalFunction") <- value
                                                                value <- .value
                                                                {
                                                                  .value <- as(from, "genericFunction", TRUE)
                                                                  as(.value, "function") <- value
                                                                  value <- .value
                                                                  {
                                                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                    from
                                                                  }
                                                                }
                                                              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                              {
                                                                if (strict) 
                                                                  from <- from@.Data
                                                                from
                                                              }, test = function (object) 
                                                                TRUE, replace = function (from, to, value) 
                                                                {
                                                                  .value <- as(from, "function", TRUE)
                                                                  as(.value, "OptionalFunction") <- value
                                                                  value <- .value
                                                                  {
                                                                    .value <- as(from, "genericFunction", TRUE)
                                                                    as(.value, "function") <- value
                                                                    value <- .value
                                                                    {
                                                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                      from
                                                                    }
                                                                  }
                                                                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                {
                                                                  if (strict) 
                                                                    from <- from@.Data
                                                                  from
                                                                }, test = function (object) 
                                                                  TRUE, replace = function (from, to, value) 
                                                                  {
                                                                    .value <- as(from, "function", TRUE)
                                                                    as(.value, "OptionalFunction") <- value
                                                                    value <- .value
                                                                    {
                                                                      .value <- as(from, "MethodDefinition", TRUE)
                                                                      as(.value, "function") <- value
                                                                      value <- .value
                                                                      {
                                                                        .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                        as(.value, "MethodDefinition") <- value
                                                                        value <- .value
                                                                        {
                                                                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                          from
                                                                        }
                                                                      }
                                                                    }
                                                                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                  {
                                                                    if (strict) 
                                                                      from <- from@.Data
                                                                    from
                                                                  }, test = function (object) 
                                                                    TRUE, replace = function (from, to, value) 
                                                                    {
                                                                      .value <- as(from, "function", TRUE)
                                                                      as(.value, "OptionalFunction") <- value
                                                                      value <- .value
                                                                      {
                                                                        .value <- as(from, "groupGenericFunction", TRUE)
                                                                        as(.value, "function") <- value
                                                                        value <- .value
                                                                        {
                                                                          for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                          from
                                                                        }
                                                                      }
                                                                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), .NULL = new("SClassExtension", subClass = ".NULL", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                    {
                                                                      from <- as(from, "NULL", strict = strict)
                                                                      from
                                                                    }, test = function (object) 
                                                                      TRUE, replace = function (from, to, value) 
                                                                      {
                                                                        .value <- as(from, "NULL", TRUE)
                                                                        as(.value, "OptionalFunction") <- value
                                                                        value <- .value
                                                                        {
                                                                          from@.xData <- value
                                                                          from
                                                                        }
                                                                      }, simple = FALSE, by = "NULL", dataPart = FALSE, distance = 2), defaultBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                      {
                                                                        from <- {
                                                                          value <- new("activeBindingFunction")
                                                                          for (what in ".Data") slot(value, what) <- slot(from, what)
                                                                          value
                                                                        }
                                                                        {
                                                                          if (strict) 
                                                                            from <- from@.Data
                                                                          from
                                                                        }
                                                                      }, test = function (object) 
                                                                        TRUE, replace = function (from, to, value) 
                                                                        {
                                                                          .value <- as(from, "activeBindingFunction", TRUE)
                                                                          as(.value, "OptionalFunction") <- value
                                                                          value <- .value
                                                                          {
                                                                            for (what in ".Data") slot(from, what) <- slot(value, what)
                                                                            from
                                                                          }
                                                                        }, simple = TRUE, by = "activeBindingFunction", dataPart = FALSE, distance = 3), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                        {
                                                                          from <- {
                                                                            value <- new("refMethodDef")
                                                                            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                            value
                                                                          }
                                                                          {
                                                                            if (strict) 
                                                                              from <- from@.Data
                                                                            from
                                                                          }
                                                                        }, test = function (object) 
                                                                          TRUE, replace = function (from, to, value) 
                                                                          {
                                                                            .value <- as(from, "refMethodDef", TRUE)
                                                                            as(.value, "OptionalFunction") <- value
                                                                            value <- .value
                                                                            {
                                                                              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                              from
                                                                            }
                                                                          }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), externalRefMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                          {
                                                                            from <- {
                                                                              value <- new("refMethodDef")
                                                                              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                              value
                                                                            }
                                                                            {
                                                                              if (strict) 
                                                                                from <- from@.Data
                                                                              from
                                                                            }
                                                                          }, test = function (object) 
                                                                            TRUE, replace = function (from, to, value) 
                                                                            {
                                                                              .value <- as(from, "refMethodDef", TRUE)
                                                                              as(.value, "OptionalFunction") <- value
                                                                              value <- .value
                                                                              {
                                                                                for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                from
                                                                              }
                                                                            }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__optionalMethod
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "optionalMethod", package = "methods", subclasses = list(PossibleMethod = new("SClassExtension", subClass = "PossibleMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "optionalMethod")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("PossibleMethod"), "optionalMethod", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `NULL` = new("SClassExtension", subClass = "NULL", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "optionalMethod")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("NULL"), "optionalMethod", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "function", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
              as({
                if (!is(value, "optionalMethod")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("PossibleMethod"), "optionalMethod", dQuote(class(value))), domain = NA)
                value
              }, "function"), simple = TRUE, by = "PossibleMethod", dataPart = FALSE, distance = 2), classGeneratorFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  if (strict) 
                    from <- from@.Data
                  from
                }
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                  as({
                    if (!is(value, "optionalMethod")) 
                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("PossibleMethod"), "optionalMethod", dQuote(class(value))), domain = NA)
                    value
                  }, "classGeneratorFunction"), simple = TRUE, by = "PossibleMethod", dataPart = FALSE, distance = 3), MethodDefinition = new("SClassExtension", subClass = "MethodDefinition", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "function", TRUE)
                      as(.value, "optionalMethod") <- value
                      value <- .value
                      {
                        from@.Data <- as(value, "function", strict = FALSE)
                        from
                      }
                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- {
                        class(from) <- "MethodDefinition"
                        from
                      }
                      {
                        if (strict) 
                          from <- from@.Data
                        from
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "MethodDefinition", TRUE)
                        as(.value, "optionalMethod") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        from <- {
                          value <- new("derivedDefaultMethod")
                          for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                          value
                        }
                        {
                          from <- {
                            class(from) <- "MethodDefinition"
                            from
                          }
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }
                        }
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "derivedDefaultMethod", TRUE)
                          as(.value, "optionalMethod") <- value
                          value <- .value
                          {
                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                            from
                          }
                        }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 5), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- {
                            value <- new("MethodDefinition")
                            for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                            value
                          }
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "MethodDefinition", TRUE)
                            as(.value, "optionalMethod") <- value
                            value <- .value
                            {
                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                              from
                            }
                          }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            from <- {
                              class(from) <- "MethodDefinition"
                              from
                            }
                            {
                              if (strict) 
                                from <- from@.Data
                              from
                            }
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "MethodDefinition", TRUE)
                              as(.value, "optionalMethod") <- value
                              value <- .value
                              {
                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                from
                              }
                            }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4), genericFunction = new("SClassExtension", subClass = "genericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              if (strict) 
                                from <- from@.Data
                              from
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "function", TRUE)
                                as(.value, "optionalMethod") <- value
                                value <- .value
                                {
                                  from@.Data <- as(value, "function", strict = FALSE)
                                  from
                                }
                              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                from <- {
                                  class(from) <- "genericFunction"
                                  from
                                }
                                {
                                  if (strict) 
                                    from <- from@.Data
                                  from
                                }
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "genericFunction", TRUE)
                                  as(.value, "optionalMethod") <- value
                                  value <- .value
                                  {
                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  from <- {
                                    class(from) <- "genericFunction"
                                    from
                                  }
                                  {
                                    if (strict) 
                                      from <- from@.Data
                                    from
                                  }
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    .value <- as(from, "genericFunction", TRUE)
                                    as(.value, "optionalMethod") <- value
                                    value <- .value
                                    {
                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                      from
                                    }
                                  }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    from <- {
                                      value <- new("genericFunction")
                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                      value
                                    }
                                    {
                                      if (strict) 
                                        from <- from@.Data
                                      from
                                    }
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      .value <- as(from, "genericFunction", TRUE)
                                      as(.value, "optionalMethod") <- value
                                      value <- .value
                                      {
                                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                        from
                                      }
                                    }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                    {
                                      from <- {
                                        class(from) <- "groupGenericFunction"
                                        from
                                      }
                                      {
                                        from <- {
                                          value <- new("genericFunction")
                                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                          value
                                        }
                                        {
                                          if (strict) 
                                            from <- from@.Data
                                          from
                                        }
                                      }
                                    }, test = function (object) 
                                      TRUE, replace = function (from, to, value) 
                                      {
                                        .value <- as(from, "groupGenericFunction", TRUE)
                                        as(.value, "optionalMethod") <- value
                                        value <- .value
                                        {
                                          for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                          from
                                        }
                                      }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 5), .NULL = new("SClassExtension", subClass = ".NULL", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                      {
                                        from <- as(from, "NULL", strict = strict)
                                        from
                                      }, test = function (object) 
                                        TRUE, replace = function (from, to, value) 
                                        {
                                          .value <- as(from, "NULL", TRUE)
                                          as(.value, "optionalMethod") <- value
                                          value <- .value
                                          {
                                            from@.xData <- value
                                            from
                                          }
                                        }, simple = FALSE, by = "NULL", dataPart = FALSE, distance = 2), MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                        {
                                          from <- {
                                            value <- new("MethodWithNext")
                                            for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                            value
                                          }
                                          {
                                            from <- {
                                              value <- new("MethodDefinition")
                                              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                              value
                                            }
                                            {
                                              if (strict) 
                                                from <- from@.Data
                                              from
                                            }
                                          }
                                        }, test = function (object) 
                                          TRUE, replace = function (from, to, value) 
                                          {
                                            .value <- as(from, "MethodWithNext", TRUE)
                                            as(.value, "optionalMethod") <- value
                                            value <- .value
                                            {
                                              for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                              from
                                            }
                                          }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 5), genericFunctionWithTrace = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                          {
                                            from <- {
                                              value <- new("genericFunction")
                                              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                              value
                                            }
                                            {
                                              if (strict) 
                                                from <- from@.Data
                                              from
                                            }
                                          }, test = function (object) 
                                            TRUE, replace = function (from, to, value) 
                                            {
                                              .value <- as(from, "genericFunction", TRUE)
                                              as(.value, "optionalMethod") <- value
                                              value <- .value
                                              {
                                                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                from
                                              }
                                            }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4), standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                            {
                                              from <- {
                                                value <- new("standardGeneric")
                                                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                value
                                              }
                                              {
                                                from <- {
                                                  class(from) <- "genericFunction"
                                                  from
                                                }
                                                {
                                                  if (strict) 
                                                    from <- from@.Data
                                                  from
                                                }
                                              }
                                            }, test = function (object) 
                                              TRUE, replace = function (from, to, value) 
                                              {
                                                .value <- as(from, "standardGeneric", TRUE)
                                                as(.value, "optionalMethod") <- value
                                                value <- .value
                                                {
                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                  from
                                                }
                                              }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 5), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                              {
                                                from <- {
                                                  value <- new("groupGenericFunction")
                                                  for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                  value
                                                }
                                                {
                                                  from <- {
                                                    value <- new("genericFunction")
                                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                    value
                                                  }
                                                  {
                                                    if (strict) 
                                                      from <- from@.Data
                                                    from
                                                  }
                                                }
                                              }, test = function (object) 
                                                TRUE, replace = function (from, to, value) 
                                                {
                                                  .value <- as(from, "groupGenericFunction", TRUE)
                                                  as(.value, "optionalMethod") <- value
                                                  value <- .value
                                                  {
                                                    for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                    from
                                                  }
                                                }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 5), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                {
                                                  from <- {
                                                    value <- new("derivedDefaultMethod")
                                                    for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                    value
                                                  }
                                                  {
                                                    from <- {
                                                      class(from) <- "MethodDefinition"
                                                      from
                                                    }
                                                    {
                                                      if (strict) 
                                                        from <- from@.Data
                                                      from
                                                    }
                                                  }
                                                }, test = function (object) 
                                                  TRUE, replace = function (from, to, value) 
                                                  {
                                                    .value <- as(from, "derivedDefaultMethod", TRUE)
                                                    as(.value, "optionalMethod") <- value
                                                    value <- .value
                                                    {
                                                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                      from
                                                    }
                                                  }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 5), refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                  {
                                                    from <- {
                                                      value <- new("classGeneratorFunction")
                                                      for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                      value
                                                    }
                                                    {
                                                      from <- {
                                                        if (strict) 
                                                          from <- from@.Data
                                                        from
                                                      }
                                                      from
                                                    }
                                                  }, test = function (object) 
                                                    TRUE, replace = function (from, to, value) 
                                                    {
                                                      .value <- as(from, "classGeneratorFunction", TRUE)
                                                      as(.value, "optionalMethod") <- value
                                                      value <- .value
                                                      {
                                                        for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                        from
                                                      }
                                                    }, simple = TRUE, by = "classGeneratorFunction", dataPart = FALSE, distance = 4)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "optionalMethod", package = "methods", subclasses = list(PossibleMethod = new("SClassExtension", subClass = "PossibleMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                      from, test = function (object) 
                                                        TRUE, replace = function (from, to, value) 
                                                        {
                                                          if (!is(value, "optionalMethod")) 
                                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("PossibleMethod"), "optionalMethod", dQuote(class(value))), domain = NA)
                                                          value
                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `NULL` = new("SClassExtension", subClass = "NULL", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                          from, test = function (object) 
                                                            TRUE, replace = function (from, to, value) 
                                                            {
                                                              if (!is(value, "optionalMethod")) 
                                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("NULL"), "optionalMethod", dQuote(class(value))), domain = NA)
                                                              value
                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "function", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                              from, test = function (object) 
                                                                TRUE, replace = function (from, to, value) 
                                                                  as({
                                                                    if (!is(value, "optionalMethod")) 
                                                                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("PossibleMethod"), "optionalMethod", dQuote(class(value))), domain = NA)
                                                                    value
                                                                  }, "function"), simple = TRUE, by = "PossibleMethod", dataPart = FALSE, distance = 2), classGeneratorFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                  {
                                                                    from <- {
                                                                      if (strict) 
                                                                        from <- from@.Data
                                                                      from
                                                                    }
                                                                    from
                                                                  }, test = function (object) 
                                                                    TRUE, replace = function (from, to, value) 
                                                                      as({
                                                                        if (!is(value, "optionalMethod")) 
                                                                          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "optionalMethod", dQuote("PossibleMethod"), "optionalMethod", dQuote(class(value))), domain = NA)
                                                                        value
                                                                      }, "classGeneratorFunction"), simple = TRUE, by = "PossibleMethod", dataPart = FALSE, distance = 3), MethodDefinition = new("SClassExtension", subClass = "MethodDefinition", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                      {
                                                                        if (strict) 
                                                                          from <- from@.Data
                                                                        from
                                                                      }, test = function (object) 
                                                                        TRUE, replace = function (from, to, value) 
                                                                        {
                                                                          .value <- as(from, "function", TRUE)
                                                                          as(.value, "optionalMethod") <- value
                                                                          value <- .value
                                                                          {
                                                                            from@.Data <- as(value, "function", strict = FALSE)
                                                                            from
                                                                          }
                                                                        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                        {
                                                                          from <- {
                                                                            class(from) <- "MethodDefinition"
                                                                            from
                                                                          }
                                                                          {
                                                                            if (strict) 
                                                                              from <- from@.Data
                                                                            from
                                                                          }
                                                                        }, test = function (object) 
                                                                          TRUE, replace = function (from, to, value) 
                                                                          {
                                                                            .value <- as(from, "MethodDefinition", TRUE)
                                                                            as(.value, "optionalMethod") <- value
                                                                            value <- .value
                                                                            {
                                                                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                              from
                                                                            }
                                                                          }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                          {
                                                                            from <- {
                                                                              value <- new("derivedDefaultMethod")
                                                                              for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                              value
                                                                            }
                                                                            {
                                                                              from <- {
                                                                                class(from) <- "MethodDefinition"
                                                                                from
                                                                              }
                                                                              {
                                                                                if (strict) 
                                                                                  from <- from@.Data
                                                                                from
                                                                              }
                                                                            }
                                                                          }, test = function (object) 
                                                                            TRUE, replace = function (from, to, value) 
                                                                            {
                                                                              .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                              as(.value, "optionalMethod") <- value
                                                                              value <- .value
                                                                              {
                                                                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                from
                                                                              }
                                                                            }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 5), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                            {
                                                                              from <- {
                                                                                value <- new("MethodDefinition")
                                                                                for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                value
                                                                              }
                                                                              {
                                                                                if (strict) 
                                                                                  from <- from@.Data
                                                                                from
                                                                              }
                                                                            }, test = function (object) 
                                                                              TRUE, replace = function (from, to, value) 
                                                                              {
                                                                                .value <- as(from, "MethodDefinition", TRUE)
                                                                                as(.value, "optionalMethod") <- value
                                                                                value <- .value
                                                                                {
                                                                                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                  from
                                                                                }
                                                                              }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                              {
                                                                                from <- {
                                                                                  class(from) <- "MethodDefinition"
                                                                                  from
                                                                                }
                                                                                {
                                                                                  if (strict) 
                                                                                    from <- from@.Data
                                                                                  from
                                                                                }
                                                                              }, test = function (object) 
                                                                                TRUE, replace = function (from, to, value) 
                                                                                {
                                                                                  .value <- as(from, "MethodDefinition", TRUE)
                                                                                  as(.value, "optionalMethod") <- value
                                                                                  value <- .value
                                                                                  {
                                                                                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                    from
                                                                                  }
                                                                                }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4), genericFunction = new("SClassExtension", subClass = "genericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                {
                                                                                  if (strict) 
                                                                                    from <- from@.Data
                                                                                  from
                                                                                }, test = function (object) 
                                                                                  TRUE, replace = function (from, to, value) 
                                                                                  {
                                                                                    .value <- as(from, "function", TRUE)
                                                                                    as(.value, "optionalMethod") <- value
                                                                                    value <- .value
                                                                                    {
                                                                                      from@.Data <- as(value, "function", strict = FALSE)
                                                                                      from
                                                                                    }
                                                                                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                  {
                                                                                    from <- {
                                                                                      class(from) <- "genericFunction"
                                                                                      from
                                                                                    }
                                                                                    {
                                                                                      if (strict) 
                                                                                        from <- from@.Data
                                                                                      from
                                                                                    }
                                                                                  }, test = function (object) 
                                                                                    TRUE, replace = function (from, to, value) 
                                                                                    {
                                                                                      .value <- as(from, "genericFunction", TRUE)
                                                                                      as(.value, "optionalMethod") <- value
                                                                                      value <- .value
                                                                                      {
                                                                                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                        from
                                                                                      }
                                                                                    }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                    {
                                                                                      from <- {
                                                                                        class(from) <- "genericFunction"
                                                                                        from
                                                                                      }
                                                                                      {
                                                                                        if (strict) 
                                                                                          from <- from@.Data
                                                                                        from
                                                                                      }
                                                                                    }, test = function (object) 
                                                                                      TRUE, replace = function (from, to, value) 
                                                                                      {
                                                                                        .value <- as(from, "genericFunction", TRUE)
                                                                                        as(.value, "optionalMethod") <- value
                                                                                        value <- .value
                                                                                        {
                                                                                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                          from
                                                                                        }
                                                                                      }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                      {
                                                                                        from <- {
                                                                                          value <- new("genericFunction")
                                                                                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                          value
                                                                                        }
                                                                                        {
                                                                                          if (strict) 
                                                                                            from <- from@.Data
                                                                                          from
                                                                                        }
                                                                                      }, test = function (object) 
                                                                                        TRUE, replace = function (from, to, value) 
                                                                                        {
                                                                                          .value <- as(from, "genericFunction", TRUE)
                                                                                          as(.value, "optionalMethod") <- value
                                                                                          value <- .value
                                                                                          {
                                                                                            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                            from
                                                                                          }
                                                                                        }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                        {
                                                                                          from <- {
                                                                                            class(from) <- "groupGenericFunction"
                                                                                            from
                                                                                          }
                                                                                          {
                                                                                            from <- {
                                                                                              value <- new("genericFunction")
                                                                                              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                              value
                                                                                            }
                                                                                            {
                                                                                              if (strict) 
                                                                                                from <- from@.Data
                                                                                              from
                                                                                            }
                                                                                          }
                                                                                        }, test = function (object) 
                                                                                          TRUE, replace = function (from, to, value) 
                                                                                          {
                                                                                            .value <- as(from, "groupGenericFunction", TRUE)
                                                                                            as(.value, "optionalMethod") <- value
                                                                                            value <- .value
                                                                                            {
                                                                                              for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                              from
                                                                                            }
                                                                                          }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 5), .NULL = new("SClassExtension", subClass = ".NULL", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                          {
                                                                                            from <- as(from, "NULL", strict = strict)
                                                                                            from
                                                                                          }, test = function (object) 
                                                                                            TRUE, replace = function (from, to, value) 
                                                                                            {
                                                                                              .value <- as(from, "NULL", TRUE)
                                                                                              as(.value, "optionalMethod") <- value
                                                                                              value <- .value
                                                                                              {
                                                                                                from@.xData <- value
                                                                                                from
                                                                                              }
                                                                                            }, simple = FALSE, by = "NULL", dataPart = FALSE, distance = 2), MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                            {
                                                                                              from <- {
                                                                                                value <- new("MethodWithNext")
                                                                                                for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                value
                                                                                              }
                                                                                              {
                                                                                                from <- {
                                                                                                  value <- new("MethodDefinition")
                                                                                                  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                  value
                                                                                                }
                                                                                                {
                                                                                                  if (strict) 
                                                                                                    from <- from@.Data
                                                                                                  from
                                                                                                }
                                                                                              }
                                                                                            }, test = function (object) 
                                                                                              TRUE, replace = function (from, to, value) 
                                                                                              {
                                                                                                .value <- as(from, "MethodWithNext", TRUE)
                                                                                                as(.value, "optionalMethod") <- value
                                                                                                value <- .value
                                                                                                {
                                                                                                  for (what in c(".Data", "nextMethod", "excluded", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                  from
                                                                                                }
                                                                                              }, simple = TRUE, by = "MethodWithNext", dataPart = FALSE, distance = 5), genericFunctionWithTrace = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                              {
                                                                                                from <- {
                                                                                                  value <- new("genericFunction")
                                                                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                  value
                                                                                                }
                                                                                                {
                                                                                                  if (strict) 
                                                                                                    from <- from@.Data
                                                                                                  from
                                                                                                }
                                                                                              }, test = function (object) 
                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                {
                                                                                                  .value <- as(from, "genericFunction", TRUE)
                                                                                                  as(.value, "optionalMethod") <- value
                                                                                                  value <- .value
                                                                                                  {
                                                                                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                    from
                                                                                                  }
                                                                                                }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4), standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                {
                                                                                                  from <- {
                                                                                                    value <- new("standardGeneric")
                                                                                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                    value
                                                                                                  }
                                                                                                  {
                                                                                                    from <- {
                                                                                                      class(from) <- "genericFunction"
                                                                                                      from
                                                                                                    }
                                                                                                    {
                                                                                                      if (strict) 
                                                                                                        from <- from@.Data
                                                                                                      from
                                                                                                    }
                                                                                                  }
                                                                                                }, test = function (object) 
                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                  {
                                                                                                    .value <- as(from, "standardGeneric", TRUE)
                                                                                                    as(.value, "optionalMethod") <- value
                                                                                                    value <- .value
                                                                                                    {
                                                                                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                      from
                                                                                                    }
                                                                                                  }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 5), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                  {
                                                                                                    from <- {
                                                                                                      value <- new("groupGenericFunction")
                                                                                                      for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                      value
                                                                                                    }
                                                                                                    {
                                                                                                      from <- {
                                                                                                        value <- new("genericFunction")
                                                                                                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                        value
                                                                                                      }
                                                                                                      {
                                                                                                        if (strict) 
                                                                                                          from <- from@.Data
                                                                                                        from
                                                                                                      }
                                                                                                    }
                                                                                                  }, test = function (object) 
                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                    {
                                                                                                      .value <- as(from, "groupGenericFunction", TRUE)
                                                                                                      as(.value, "optionalMethod") <- value
                                                                                                      value <- .value
                                                                                                      {
                                                                                                        for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                        from
                                                                                                      }
                                                                                                    }, simple = TRUE, by = "groupGenericFunction", dataPart = FALSE, distance = 5), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                    {
                                                                                                      from <- {
                                                                                                        value <- new("derivedDefaultMethod")
                                                                                                        for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                                        value
                                                                                                      }
                                                                                                      {
                                                                                                        from <- {
                                                                                                          class(from) <- "MethodDefinition"
                                                                                                          from
                                                                                                        }
                                                                                                        {
                                                                                                          if (strict) 
                                                                                                            from <- from@.Data
                                                                                                          from
                                                                                                        }
                                                                                                      }
                                                                                                    }, test = function (object) 
                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                      {
                                                                                                        .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                                        as(.value, "optionalMethod") <- value
                                                                                                        value <- .value
                                                                                                        {
                                                                                                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                          from
                                                                                                        }
                                                                                                      }, simple = TRUE, by = "derivedDefaultMethod", dataPart = FALSE, distance = 5), refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                      {
                                                                                                        from <- {
                                                                                                          value <- new("classGeneratorFunction")
                                                                                                          for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                                                                          value
                                                                                                        }
                                                                                                        {
                                                                                                          from <- {
                                                                                                            if (strict) 
                                                                                                              from <- from@.Data
                                                                                                            from
                                                                                                          }
                                                                                                          from
                                                                                                        }
                                                                                                      }, test = function (object) 
                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                        {
                                                                                                          .value <- as(from, "classGeneratorFunction", TRUE)
                                                                                                          as(.value, "optionalMethod") <- value
                                                                                                          value <- .value
                                                                                                          {
                                                                                                            for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                                                                            from
                                                                                                          }
                                                                                                        }, simple = TRUE, by = "classGeneratorFunction", dataPart = FALSE, distance = 4)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__ordered
list(`package:methods` = new("classRepresentation", slots = list(.Data = "integer", levels = "character", .S3Class = "character"), contains = list(factor = new("SClassExtension", subClass = "ordered", superClass = "factor", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "factor")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), integer = new("SClassExtension", subClass = "ordered", superClass = "integer", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "factor")
      else from
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "factor", TRUE)
      as(.value, "integer") <- value
      value <- .value
      {
        S3Part(from) <- value
        from
      }
    }, simple = TRUE, by = "factor", dataPart = TRUE, distance = 2), oldClass = new("SClassExtension", subClass = "ordered", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
    {
      S3Part(from)
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from, needClass = "factor") <- value
        from
      }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 2), double = new("SClassExtension", subClass = "ordered", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- as(from, "factor", strict = strict)
        {
          from <- as(from, "integer", strict = strict)
          as.double(from)
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "factor", TRUE)
          as(.value, "double") <- value
          value <- .value
          {
            S3Part(from) <- value
            from
          }
        }, simple = FALSE, by = "factor", dataPart = FALSE, distance = 3), numeric = new("SClassExtension", subClass = "ordered", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            if (strict) 
              S3Part(from, S3Class = "factor")
            else from
          }
          {
            if (strict) 
              from <- from@.Data
            {
              class(from) <- "numeric"
              from
            }
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "factor", TRUE)
            as(.value, "numeric") <- value
            value <- .value
            {
              S3Part(from) <- value
              from
            }
          }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 3), vector = new("SClassExtension", subClass = "ordered", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              if (strict) 
                S3Part(from, S3Class = "factor")
              else from
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "factor", TRUE)
              as(.value, "vector") <- value
              value <- .value
              {
                S3Part(from) <- value
                from
              }
            }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 3), data.frameRowLabels = new("SClassExtension", subClass = "ordered", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "integer", TRUE)
                as(.value, "data.frameRowLabels") <- value
                value <- .value
                {
                  .value <- as(from, "factor", TRUE)
                  as(.value, "integer") <- value
                  value <- .value
                  {
                    S3Part(from) <- value
                    from
                  }
                }
              }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "ordered", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "integer", levels = "character", .S3Class = "character"), contains = list(factor = new("SClassExtension", subClass = "ordered", superClass = "factor", package = "methods", coerce = function (from, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            strict = TRUE) 
              {
                if (strict) 
                  S3Part(from, S3Class = "factor")
                else from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  S3Part(from) <- value
                  from
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), integer = new("SClassExtension", subClass = "ordered", superClass = "integer", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    if (strict) 
                      S3Part(from, S3Class = "factor")
                    else from
                  }
                  if (strict) 
                    from@.Data
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "factor", TRUE)
                    as(.value, "integer") <- value
                    value <- .value
                    {
                      S3Part(from) <- value
                      from
                    }
                  }, simple = TRUE, by = "factor", dataPart = TRUE, distance = 2), oldClass = new("SClassExtension", subClass = "ordered", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    S3Part(from)
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      S3Part(from, needClass = "factor") <- value
                      from
                    }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 2), double = new("SClassExtension", subClass = "ordered", superClass = "double", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- as(from, "factor", strict = strict)
                      {
                        from <- as(from, "integer", strict = strict)
                        as.double(from)
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "factor", TRUE)
                        as(.value, "double") <- value
                        value <- .value
                        {
                          S3Part(from) <- value
                          from
                        }
                      }, simple = FALSE, by = "factor", dataPart = FALSE, distance = 3), numeric = new("SClassExtension", subClass = "ordered", superClass = "numeric", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        from <- {
                          if (strict) 
                            S3Part(from, S3Class = "factor")
                          else from
                        }
                        {
                          if (strict) 
                            from <- from@.Data
                          {
                            class(from) <- "numeric"
                            from
                          }
                        }
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "factor", TRUE)
                          as(.value, "numeric") <- value
                          value <- .value
                          {
                            S3Part(from) <- value
                            from
                          }
                        }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 3), vector = new("SClassExtension", subClass = "ordered", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- {
                            if (strict) 
                              S3Part(from, S3Class = "factor")
                            else from
                          }
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "factor", TRUE)
                            as(.value, "vector") <- value
                            value <- .value
                            {
                              S3Part(from) <- value
                              from
                            }
                          }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 3), data.frameRowLabels = new("SClassExtension", subClass = "ordered", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "integer", TRUE)
                              as(.value, "data.frameRowLabels") <- value
                              value <- .value
                              {
                                .value <- as(from, "factor", TRUE)
                                as(.value, "integer") <- value
                                value <- .value
                                {
                                  S3Part(from) <- value
                                  from
                                }
                              }
                            }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "ordered", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__packageInfo
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "packageInfo", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "packageInfo", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "packageInfo", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "packageInfo", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__packageIQR
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "packageIQR", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "packageIQR", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "packageIQR", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "packageIQR", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__POSIXct
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(POSIXt = new("SClassExtension", subClass = "POSIXct", superClass = "POSIXt", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "POSIXt")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "POSIXct", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "POSIXt")
      else from
    }
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
      as({
        S3Part(from) <- value
        from
      }, "POSIXct"), simple = TRUE, by = "POSIXt", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "POSIXct", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(POSIXt = new("SClassExtension", subClass = "POSIXct", superClass = "POSIXt", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "POSIXt")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "POSIXct", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            if (strict) 
              S3Part(from, S3Class = "POSIXt")
            else from
          }
          {
            if (strict) 
              S3Part(from, S3Class = "oldClass")
            else from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
            as({
              S3Part(from) <- value
              from
            }, "POSIXct"), simple = TRUE, by = "POSIXt", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "POSIXct", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__POSIXlt
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(POSIXt = new("SClassExtension", subClass = "POSIXlt", superClass = "POSIXt", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "POSIXt")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "POSIXlt", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "POSIXt")
      else from
    }
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
      as({
        S3Part(from) <- value
        from
      }, "POSIXlt"), simple = TRUE, by = "POSIXt", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "POSIXlt", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(POSIXt = new("SClassExtension", subClass = "POSIXlt", superClass = "POSIXt", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "POSIXt")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "POSIXlt", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            if (strict) 
              S3Part(from, S3Class = "POSIXt")
            else from
          }
          {
            if (strict) 
              S3Part(from, S3Class = "oldClass")
            else from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
            as({
              S3Part(from) <- value
              from
            }, "POSIXlt"), simple = TRUE, by = "POSIXt", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "POSIXlt", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__POSIXt
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "POSIXt", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "POSIXt", package = "methods", subclasses = list(POSIXct = new("SClassExtension", subClass = "POSIXct", superClass = "POSIXt", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "POSIXt")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), POSIXlt = new("SClassExtension", subClass = "POSIXlt", superClass = "POSIXt", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        S3Part(from, S3Class = "POSIXt")
      else from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from) <- value
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "POSIXt", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "oldClass")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "POSIXt", package = "methods", subclasses = list(POSIXct = new("SClassExtension", subClass = "POSIXct", superClass = "POSIXt", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            S3Part(from, S3Class = "POSIXt")
          else from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            S3Part(from) <- value
            from
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), POSIXlt = new("SClassExtension", subClass = "POSIXlt", superClass = "POSIXt", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              S3Part(from, S3Class = "POSIXt")
            else from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              S3Part(from) <- value
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__PossibleMethod
list(`package:methods` = new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = function () 
  NULL, validity = NULL, access = list(), className = "PossibleMethod", package = "methods", subclasses = list(`function` = new("SClassExtension", subClass = "function", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "PossibleMethod")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "PossibleMethod", dQuote("function"), "PossibleMethod", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "MethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            if (!is(value, "PossibleMethod")) 
              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "PossibleMethod", dQuote("MethodDefinition"), "PossibleMethod", dQuote(class(value))), domain = NA)
            value
          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), classGeneratorFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "function", TRUE)
              as(.value, "PossibleMethod") <- value
              value <- .value
              {
                from@.Data <- as(value, "function", strict = FALSE)
                from
              }
            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), genericFunction = new("SClassExtension", subClass = "genericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "function", TRUE)
                as(.value, "PossibleMethod") <- value
                value <- .value
                {
                  from@.Data <- as(value, "function", strict = FALSE)
                  from
                }
              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  class(from) <- "MethodDefinition"
                  from
                }
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "MethodDefinition", TRUE)
                  as(.value, "PossibleMethod") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 2), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    value <- new("MethodDefinition")
                    for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                    value
                  }
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "MethodDefinition", TRUE)
                    as(.value, "PossibleMethod") <- value
                    value <- .value
                    {
                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                      from
                    }
                  }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 2), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- {
                      class(from) <- "MethodDefinition"
                      from
                    }
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "MethodDefinition", TRUE)
                      as(.value, "PossibleMethod") <- value
                      value <- .value
                      {
                        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                        from
                      }
                    }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 2), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      if (strict) 
                        from <- from@.Data
                      from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "function", TRUE)
                        as(.value, "PossibleMethod") <- value
                        value <- .value
                        {
                          .value <- as(from, "MethodDefinition", TRUE)
                          as(.value, "function") <- value
                          value <- .value
                          {
                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                            from
                          }
                        }
                      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        if (strict) 
                          from <- from@.Data
                        from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "function", TRUE)
                          as(.value, "PossibleMethod") <- value
                          value <- .value
                          {
                            .value <- as(from, "MethodDefinition", TRUE)
                            as(.value, "function") <- value
                            value <- .value
                            {
                              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                              from
                            }
                          }
                        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          if (strict) 
                            from <- from@.Data
                          from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "function", TRUE)
                            as(.value, "PossibleMethod") <- value
                            value <- .value
                            {
                              .value <- as(from, "MethodDefinition", TRUE)
                              as(.value, "function") <- value
                              value <- .value
                              {
                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                from
                              }
                            }
                          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "function", TRUE)
                              as(.value, "PossibleMethod") <- value
                              value <- .value
                              {
                                .value <- as(from, "genericFunction", TRUE)
                                as(.value, "function") <- value
                                value <- .value
                                {
                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                  from
                                }
                              }
                            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              if (strict) 
                                from <- from@.Data
                              from
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "function", TRUE)
                                as(.value, "PossibleMethod") <- value
                                value <- .value
                                {
                                  .value <- as(from, "genericFunction", TRUE)
                                  as(.value, "function") <- value
                                  value <- .value
                                  {
                                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }
                              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                if (strict) 
                                  from <- from@.Data
                                from
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "function", TRUE)
                                  as(.value, "PossibleMethod") <- value
                                  value <- .value
                                  {
                                    .value <- as(from, "genericFunction", TRUE)
                                    as(.value, "function") <- value
                                    value <- .value
                                    {
                                      for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                      from
                                    }
                                  }
                                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                {
                                  from <- {
                                    from <- {
                                      value <- new("derivedDefaultMethod")
                                      for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                      value
                                    }
                                    {
                                      class(from) <- "MethodDefinition"
                                      from
                                    }
                                  }
                                  from
                                }, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                  {
                                    .value <- as(from, "MethodDefinition", TRUE)
                                    as(.value, "PossibleMethod") <- value
                                    value <- .value
                                    {
                                      .value <- as(from, "derivedDefaultMethod", TRUE)
                                      as(.value, "MethodDefinition") <- value
                                      value <- .value
                                      {
                                        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                        from
                                      }
                                    }
                                  }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 3), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                  {
                                    if (strict) 
                                      from <- from@.Data
                                    from
                                  }, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      .value <- as(from, "function", TRUE)
                                      as(.value, "PossibleMethod") <- value
                                      value <- .value
                                      {
                                        .value <- as(from, "MethodDefinition", TRUE)
                                        as(.value, "function") <- value
                                        value <- .value
                                        {
                                          .value <- as(from, "derivedDefaultMethod", TRUE)
                                          as(.value, "MethodDefinition") <- value
                                          value <- .value
                                          {
                                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                            from
                                          }
                                        }
                                      }
                                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                    {
                                      if (strict) 
                                        from <- from@.Data
                                      from
                                    }, test = function (object) 
                                      TRUE, replace = function (from, to, value) 
                                      {
                                        .value <- as(from, "function", TRUE)
                                        as(.value, "PossibleMethod") <- value
                                        value <- .value
                                        {
                                          .value <- as(from, "groupGenericFunction", TRUE)
                                          as(.value, "function") <- value
                                          value <- .value
                                          {
                                            for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                            from
                                          }
                                        }
                                      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), defaultBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                      {
                                        from <- {
                                          value <- new("activeBindingFunction")
                                          for (what in ".Data") slot(value, what) <- slot(from, what)
                                          value
                                        }
                                        {
                                          if (strict) 
                                            from <- from@.Data
                                          from
                                        }
                                      }, test = function (object) 
                                        TRUE, replace = function (from, to, value) 
                                        {
                                          .value <- as(from, "activeBindingFunction", TRUE)
                                          as(.value, "PossibleMethod") <- value
                                          value <- .value
                                          {
                                            for (what in ".Data") slot(from, what) <- slot(value, what)
                                            from
                                          }
                                        }, simple = TRUE, by = "activeBindingFunction", dataPart = FALSE, distance = 3), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                        {
                                          from <- {
                                            value <- new("refMethodDef")
                                            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                            value
                                          }
                                          {
                                            if (strict) 
                                              from <- from@.Data
                                            from
                                          }
                                        }, test = function (object) 
                                          TRUE, replace = function (from, to, value) 
                                          {
                                            .value <- as(from, "refMethodDef", TRUE)
                                            as(.value, "PossibleMethod") <- value
                                            value <- .value
                                            {
                                              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                              from
                                            }
                                          }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), externalRefMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                          {
                                            from <- {
                                              value <- new("refMethodDef")
                                              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                              value
                                            }
                                            {
                                              if (strict) 
                                                from <- from@.Data
                                              from
                                            }
                                          }, test = function (object) 
                                            TRUE, replace = function (from, to, value) 
                                            {
                                              .value <- as(from, "refMethodDef", TRUE)
                                              as(.value, "PossibleMethod") <- value
                                              value <- .value
                                              {
                                                for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                from
                                              }
                                            }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE), new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = function () 
                                              NULL, validity = NULL, access = list(), className = "PossibleMethod", package = "methods", subclasses = list(`function` = new("SClassExtension", subClass = "function", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                from, test = function (object) 
                                                  TRUE, replace = function (from, to, value) 
                                                  {
                                                    if (!is(value, "PossibleMethod")) 
                                                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "PossibleMethod", dQuote("function"), "PossibleMethod", dQuote(class(value))), domain = NA)
                                                    value
                                                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinition = new("SClassExtension", subClass = "MethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                    from, test = function (object) 
                                                      TRUE, replace = function (from, to, value) 
                                                      {
                                                        if (!is(value, "PossibleMethod")) 
                                                          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "PossibleMethod", dQuote("MethodDefinition"), "PossibleMethod", dQuote(class(value))), domain = NA)
                                                        value
                                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), classGeneratorFunction = new("SClassExtension", subClass = "classGeneratorFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                      {
                                                        if (strict) 
                                                          from <- from@.Data
                                                        from
                                                      }, test = function (object) 
                                                        TRUE, replace = function (from, to, value) 
                                                        {
                                                          .value <- as(from, "function", TRUE)
                                                          as(.value, "PossibleMethod") <- value
                                                          value <- .value
                                                          {
                                                            from@.Data <- as(value, "function", strict = FALSE)
                                                            from
                                                          }
                                                        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), genericFunction = new("SClassExtension", subClass = "genericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                        {
                                                          if (strict) 
                                                            from <- from@.Data
                                                          from
                                                        }, test = function (object) 
                                                          TRUE, replace = function (from, to, value) 
                                                          {
                                                            .value <- as(from, "function", TRUE)
                                                            as(.value, "PossibleMethod") <- value
                                                            value <- .value
                                                            {
                                                              from@.Data <- as(value, "function", strict = FALSE)
                                                              from
                                                            }
                                                          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                          {
                                                            from <- {
                                                              class(from) <- "MethodDefinition"
                                                              from
                                                            }
                                                            from
                                                          }, test = function (object) 
                                                            TRUE, replace = function (from, to, value) 
                                                            {
                                                              .value <- as(from, "MethodDefinition", TRUE)
                                                              as(.value, "PossibleMethod") <- value
                                                              value <- .value
                                                              {
                                                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                from
                                                              }
                                                            }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 2), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                            {
                                                              from <- {
                                                                value <- new("MethodDefinition")
                                                                for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                value
                                                              }
                                                              from
                                                            }, test = function (object) 
                                                              TRUE, replace = function (from, to, value) 
                                                              {
                                                                .value <- as(from, "MethodDefinition", TRUE)
                                                                as(.value, "PossibleMethod") <- value
                                                                value <- .value
                                                                {
                                                                  for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                  from
                                                                }
                                                              }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 2), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                              {
                                                                from <- {
                                                                  class(from) <- "MethodDefinition"
                                                                  from
                                                                }
                                                                from
                                                              }, test = function (object) 
                                                                TRUE, replace = function (from, to, value) 
                                                                {
                                                                  .value <- as(from, "MethodDefinition", TRUE)
                                                                  as(.value, "PossibleMethod") <- value
                                                                  value <- .value
                                                                  {
                                                                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                    from
                                                                  }
                                                                }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 2), derivedDefaultMethod = new("SClassExtension", subClass = "derivedDefaultMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                {
                                                                  if (strict) 
                                                                    from <- from@.Data
                                                                  from
                                                                }, test = function (object) 
                                                                  TRUE, replace = function (from, to, value) 
                                                                  {
                                                                    .value <- as(from, "function", TRUE)
                                                                    as(.value, "PossibleMethod") <- value
                                                                    value <- .value
                                                                    {
                                                                      .value <- as(from, "MethodDefinition", TRUE)
                                                                      as(.value, "function") <- value
                                                                      value <- .value
                                                                      {
                                                                        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                        from
                                                                      }
                                                                    }
                                                                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), MethodWithNext = new("SClassExtension", subClass = "MethodWithNext", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                  {
                                                                    if (strict) 
                                                                      from <- from@.Data
                                                                    from
                                                                  }, test = function (object) 
                                                                    TRUE, replace = function (from, to, value) 
                                                                    {
                                                                      .value <- as(from, "function", TRUE)
                                                                      as(.value, "PossibleMethod") <- value
                                                                      value <- .value
                                                                      {
                                                                        .value <- as(from, "MethodDefinition", TRUE)
                                                                        as(.value, "function") <- value
                                                                        value <- .value
                                                                        {
                                                                          for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                          from
                                                                        }
                                                                      }
                                                                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), SealedMethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                    {
                                                                      if (strict) 
                                                                        from <- from@.Data
                                                                      from
                                                                    }, test = function (object) 
                                                                      TRUE, replace = function (from, to, value) 
                                                                      {
                                                                        .value <- as(from, "function", TRUE)
                                                                        as(.value, "PossibleMethod") <- value
                                                                        value <- .value
                                                                        {
                                                                          .value <- as(from, "MethodDefinition", TRUE)
                                                                          as(.value, "function") <- value
                                                                          value <- .value
                                                                          {
                                                                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                            from
                                                                          }
                                                                        }
                                                                      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), standardGeneric = new("SClassExtension", subClass = "standardGeneric", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                      {
                                                                        if (strict) 
                                                                          from <- from@.Data
                                                                        from
                                                                      }, test = function (object) 
                                                                        TRUE, replace = function (from, to, value) 
                                                                        {
                                                                          .value <- as(from, "function", TRUE)
                                                                          as(.value, "PossibleMethod") <- value
                                                                          value <- .value
                                                                          {
                                                                            .value <- as(from, "genericFunction", TRUE)
                                                                            as(.value, "function") <- value
                                                                            value <- .value
                                                                            {
                                                                              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                              from
                                                                            }
                                                                          }
                                                                        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), nonstandardGenericFunction = new("SClassExtension", subClass = "nonstandardGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                        {
                                                                          if (strict) 
                                                                            from <- from@.Data
                                                                          from
                                                                        }, test = function (object) 
                                                                          TRUE, replace = function (from, to, value) 
                                                                          {
                                                                            .value <- as(from, "function", TRUE)
                                                                            as(.value, "PossibleMethod") <- value
                                                                            value <- .value
                                                                            {
                                                                              .value <- as(from, "genericFunction", TRUE)
                                                                              as(.value, "function") <- value
                                                                              value <- .value
                                                                              {
                                                                                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                from
                                                                              }
                                                                            }
                                                                          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), groupGenericFunction = new("SClassExtension", subClass = "groupGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                          {
                                                                            if (strict) 
                                                                              from <- from@.Data
                                                                            from
                                                                          }, test = function (object) 
                                                                            TRUE, replace = function (from, to, value) 
                                                                            {
                                                                              .value <- as(from, "function", TRUE)
                                                                              as(.value, "PossibleMethod") <- value
                                                                              value <- .value
                                                                              {
                                                                                .value <- as(from, "genericFunction", TRUE)
                                                                                as(.value, "function") <- value
                                                                                value <- .value
                                                                                {
                                                                                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                  from
                                                                                }
                                                                              }
                                                                            }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                            {
                                                                              from <- {
                                                                                from <- {
                                                                                  value <- new("derivedDefaultMethod")
                                                                                  for (what in c(".Data", "target", "defined", "generic")) slot(value, what) <- slot(from, what)
                                                                                  value
                                                                                }
                                                                                {
                                                                                  class(from) <- "MethodDefinition"
                                                                                  from
                                                                                }
                                                                              }
                                                                              from
                                                                            }, test = function (object) 
                                                                              TRUE, replace = function (from, to, value) 
                                                                              {
                                                                                .value <- as(from, "MethodDefinition", TRUE)
                                                                                as(.value, "PossibleMethod") <- value
                                                                                value <- .value
                                                                                {
                                                                                  .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                  as(.value, "MethodDefinition") <- value
                                                                                  value <- .value
                                                                                  {
                                                                                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                    from
                                                                                  }
                                                                                }
                                                                              }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 3), internalDispatchMethod = new("SClassExtension", subClass = "internalDispatchMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                              {
                                                                                if (strict) 
                                                                                  from <- from@.Data
                                                                                from
                                                                              }, test = function (object) 
                                                                                TRUE, replace = function (from, to, value) 
                                                                                {
                                                                                  .value <- as(from, "function", TRUE)
                                                                                  as(.value, "PossibleMethod") <- value
                                                                                  value <- .value
                                                                                  {
                                                                                    .value <- as(from, "MethodDefinition", TRUE)
                                                                                    as(.value, "function") <- value
                                                                                    value <- .value
                                                                                    {
                                                                                      .value <- as(from, "derivedDefaultMethod", TRUE)
                                                                                      as(.value, "MethodDefinition") <- value
                                                                                      value <- .value
                                                                                      {
                                                                                        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                        from
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), nonstandardGroupGenericFunction = new("SClassExtension", subClass = "nonstandardGroupGenericFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                {
                                                                                  if (strict) 
                                                                                    from <- from@.Data
                                                                                  from
                                                                                }, test = function (object) 
                                                                                  TRUE, replace = function (from, to, value) 
                                                                                  {
                                                                                    .value <- as(from, "function", TRUE)
                                                                                    as(.value, "PossibleMethod") <- value
                                                                                    value <- .value
                                                                                    {
                                                                                      .value <- as(from, "groupGenericFunction", TRUE)
                                                                                      as(.value, "function") <- value
                                                                                      value <- .value
                                                                                      {
                                                                                        for (what in c(".Data", "groupMembers", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                        from
                                                                                      }
                                                                                    }
                                                                                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 4), defaultBindingFunction = new("SClassExtension", subClass = "defaultBindingFunction", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                  {
                                                                                    from <- {
                                                                                      value <- new("activeBindingFunction")
                                                                                      for (what in ".Data") slot(value, what) <- slot(from, what)
                                                                                      value
                                                                                    }
                                                                                    {
                                                                                      if (strict) 
                                                                                        from <- from@.Data
                                                                                      from
                                                                                    }
                                                                                  }, test = function (object) 
                                                                                    TRUE, replace = function (from, to, value) 
                                                                                    {
                                                                                      .value <- as(from, "activeBindingFunction", TRUE)
                                                                                      as(.value, "PossibleMethod") <- value
                                                                                      value <- .value
                                                                                      {
                                                                                        for (what in ".Data") slot(from, what) <- slot(value, what)
                                                                                        from
                                                                                      }
                                                                                    }, simple = TRUE, by = "activeBindingFunction", dataPart = FALSE, distance = 3), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                    {
                                                                                      from <- {
                                                                                        value <- new("refMethodDef")
                                                                                        for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                        value
                                                                                      }
                                                                                      {
                                                                                        if (strict) 
                                                                                          from <- from@.Data
                                                                                        from
                                                                                      }
                                                                                    }, test = function (object) 
                                                                                      TRUE, replace = function (from, to, value) 
                                                                                      {
                                                                                        .value <- as(from, "refMethodDef", TRUE)
                                                                                        as(.value, "PossibleMethod") <- value
                                                                                        value <- .value
                                                                                        {
                                                                                          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                          from
                                                                                        }
                                                                                      }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), externalRefMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                      {
                                                                                        from <- {
                                                                                          value <- new("refMethodDef")
                                                                                          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                          value
                                                                                        }
                                                                                        {
                                                                                          if (strict) 
                                                                                            from <- from@.Data
                                                                                          from
                                                                                        }
                                                                                      }, test = function (object) 
                                                                                        TRUE, replace = function (from, to, value) 
                                                                                        {
                                                                                          .value <- as(from, "refMethodDef", TRUE)
                                                                                          as(.value, "PossibleMethod") <- value
                                                                                          value <- .value
                                                                                          {
                                                                                            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                            from
                                                                                          }
                                                                                        }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__raw
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "raw", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "vector")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("raw"), "vector", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = raw(0), validity = NULL, access = list(), className = "raw", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "raw", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "vector")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("raw"), "vector", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = raw(0), validity = NULL, access = list(), className = "raw", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__recordedplot
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "recordedplot", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "recordedplot", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "recordedplot", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "recordedplot", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__refClass
list(`package:methods` = new("ClassUnionRepresentation", slots = list(), contains = list(refObject = new("SClassExtension", subClass = "refClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "refObject")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = new("envRefClass", .xData = <environment>), validity = NULL, access = list(), className = "refClass", package = "methods", subclasses = list(envRefClass = new("SClassExtension", subClass = "envRefClass", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "refClass")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refClass", dQuote("envRefClass"), "refClass", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "refClass")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refClass", dQuote("refObjectGenerator"), "refClass", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("ClassUnionRepresentation", slots = list(), contains = list(refObject = new("SClassExtension", subClass = "refClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
              from, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  if (!is(value, "refObject")) 
                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = new("envRefClass", .xData = <environment>), validity = NULL, access = list(), className = "refClass", package = "methods", subclasses = list(envRefClass = new("SClassExtension", subClass = "envRefClass", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "refClass")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refClass", dQuote("envRefClass"), "refClass", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "refClass")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refClass", dQuote("refObjectGenerator"), "refClass", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__refClassRepresentation
list(`package:methods` = new("classRepresentation", slots = list(fieldClasses = "list", fieldPrototypes = "environment", refMethods = "environment", refSuperClasses = "character", slots = "list", contains = "list", virtual = "logical", prototype = "ANY", validity = "OptionalFunction", access = "list", className = "character", package = "character", subclasses = "list", versionKey = "externalptr", sealed = "logical"), contains = list(classRepresentation = new("SClassExtension", subClass = "refClassRepresentation", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               superClass = "classRepresentation", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- new("classRepresentation")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refClassRepresentation", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(fieldClasses = "list", fieldPrototypes = "environment", refMethods = "environment", refSuperClasses = "character", slots = "list", contains = "list", virtual = "logical", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          prototype = "ANY", validity = "OptionalFunction", access = "list", className = "character", package = "character", subclasses = "list", versionKey = "externalptr", sealed = "logical"), contains = list(classRepresentation = new("SClassExtension", subClass = "refClassRepresentation", superClass = "classRepresentation", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            value <- new("classRepresentation")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              for (what in c("slots", "contains", "virtual", "prototype", "validity", "access", "className", "package", "subclasses", "versionKey", "sealed")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refClassRepresentation", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__refGeneratorSlot
list(`package:methods` = new("refClassRepresentation", fieldClasses = list(def = "ANY", className = "ANY"), fieldPrototypes = <environment>, refMethods = <environment>, refSuperClasses = "envRefClass", slots = list(.xData = "environment"), contains = list(envRefClass = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "envRefClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "envRefClass"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in ".xData") slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), .environment = new("SClassExtension", subClass = "refGeneratorSlot", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      class(from) <- "envRefClass"
      from
    }
    {
      class(from) <- ".environment"
      from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "envRefClass", TRUE)
      as(.value, ".environment") <- value
      value <- .value
      {
        for (what in ".xData") slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), refClass = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- {
        class(from) <- "envRefClass"
        from
      }
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "envRefClass", TRUE)
        as(.value, "refClass") <- value
        value <- .value
        {
          for (what in ".xData") slot(from, what) <- slot(value, what)
          from
        }
      }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), environment = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- as(from, "envRefClass", strict = strict)
        {
          from <- as(from, ".environment", strict = strict)
          from@.xData
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "envRefClass", TRUE)
          as(.value, "environment") <- value
          value <- .value
          {
            for (what in ".xData") slot(from, what) <- slot(value, what)
            from
          }
        }, simple = FALSE, by = "envRefClass", dataPart = FALSE, distance = 3), refObject = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            class(from) <- "envRefClass"
            from
          }
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "envRefClass", TRUE)
            as(.value, "refObject") <- value
            value <- .value
            {
              for (what in ".xData") slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refGeneratorSlot", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("refClassRepresentation", fieldClasses = list(def = "ANY", className = "ANY"), fieldPrototypes = <environment>, refMethods = <environment>, refSuperClasses = "envRefClass", slots = list(.xData = "environment"), contains = list(
            envRefClass = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "envRefClass", package = "methods", coerce = function (from, strict = TRUE) 
            {
              class(from) <- "envRefClass"
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in ".xData") slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), .environment = new("SClassExtension", subClass = "refGeneratorSlot", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  class(from) <- "envRefClass"
                  from
                }
                {
                  class(from) <- ".environment"
                  from
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "envRefClass", TRUE)
                  as(.value, ".environment") <- value
                  value <- .value
                  {
                    for (what in ".xData") slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), refClass = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    class(from) <- "envRefClass"
                    from
                  }
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "envRefClass", TRUE)
                    as(.value, "refClass") <- value
                    value <- .value
                    {
                      for (what in ".xData") slot(from, what) <- slot(value, what)
                      from
                    }
                  }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 2), environment = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- as(from, "envRefClass", strict = strict)
                    {
                      from <- as(from, ".environment", strict = strict)
                      from@.xData
                    }
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "envRefClass", TRUE)
                      as(.value, "environment") <- value
                      value <- .value
                      {
                        for (what in ".xData") slot(from, what) <- slot(value, what)
                        from
                      }
                    }, simple = FALSE, by = "envRefClass", dataPart = FALSE, distance = 3), refObject = new("SClassExtension", subClass = "refGeneratorSlot", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- {
                        class(from) <- "envRefClass"
                        from
                      }
                      from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "envRefClass", TRUE)
                        as(.value, "refObject") <- value
                        value <- .value
                        {
                          for (what in ".xData") slot(from, what) <- slot(value, what)
                          from
                        }
                      }, simple = TRUE, by = "envRefClass", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refGeneratorSlot", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__refMethodDef
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", mayCall = "character", name = "character", refClassName = "character", superClassMethod = "SuperClassMethod"), contains = list(`function` = new("SClassExtension", subClass = "refMethodDef", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "function", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), SuperClassMethod = new("SClassExtension", subClass = "refMethodDef", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "SuperClassMethod")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "SuperClassMethod", dQuote("refMethodDef"), "SuperClassMethod", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "refMethodDef", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            from@.Data <- as(value, "function", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "refMethodDef", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "function", TRUE)
            as(.value, "PossibleMethod") <- value
            value <- .value
            {
              from@.Data <- as(value, "function", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refMethodDef", package = "methods", subclasses = list(refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "refMethodDef", package = "methods", coerce = function (from, strict = TRUE) 
          {
            value <- new("refMethodDef")
            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
            value
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), externalRefMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "refMethodDef", package = "methods", coerce = function (from, strict = TRUE) 
            {
              value <- new("refMethodDef")
              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
              value
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", mayCall = "character", name = "character", refClassName = "character", superClassMethod = "SuperClassMethod"), contains = list(`function` = new("SClassExtension", subClass = "refMethodDef", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
              {
                attributes(from) <- NULL
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  from@.Data <- as(value, "function", strict = FALSE)
                  from
                }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), SuperClassMethod = new("SClassExtension", subClass = "refMethodDef", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "SuperClassMethod")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "SuperClassMethod", dQuote("refMethodDef"), "SuperClassMethod", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), OptionalFunction = new("SClassExtension", subClass = "refMethodDef", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      if (strict) 
                        from <- from@.Data
                      from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "function", TRUE)
                        as(.value, "OptionalFunction") <- value
                        value <- .value
                        {
                          from@.Data <- as(value, "function", strict = FALSE)
                          from
                        }
                      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "refMethodDef", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        if (strict) 
                          from <- from@.Data
                        from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "function", TRUE)
                          as(.value, "PossibleMethod") <- value
                          value <- .value
                          {
                            from@.Data <- as(value, "function", strict = FALSE)
                            from
                          }
                        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refMethodDef", package = "methods", subclasses = list(refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "refMethodDef", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          value <- new("refMethodDef")
                          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                          value
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                            from
                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), externalRefMethod = new("SClassExtension", subClass = "externalRefMethod", superClass = "refMethodDef", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            value <- new("refMethodDef")
                            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                            value
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                              from
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__refMethodDefWithTrace
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", mayCall = "character", name = "character", refClassName = "character", superClassMethod = "SuperClassMethod", original = "PossibleMethod", source = "environment"), contains = list(refMethodDef = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "refMethodDef", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("refMethodDef")
  for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "traceable")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("refMethodDefWithTrace"), "traceable", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("refMethodDef")
          for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
          value
        }
        if (strict) 
          from@.Data
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "refMethodDef", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "refMethodDef", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("refMethodDef")
            for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
            value
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "refMethodDef", TRUE)
            as(.value, "OptionalFunction") <- value
            value <- .value
            {
              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              value <- new("refMethodDef")
              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
              value
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "refMethodDef", TRUE)
              as(.value, "PossibleMethod") <- value
              value <- .value
              {
                for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                from
              }
            }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), SuperClassMethod = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                value <- new("refMethodDef")
                for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                value
              }
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "refMethodDef", TRUE)
                as(.value, "SuperClassMethod") <- value
                value <- .value
                {
                  for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refMethodDefWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", mayCall = "character", name = "character", refClassName = "character", superClassMethod = "SuperClassMethod", original = "PossibleMethod", source = "environment"), 
                                                                                                                                                                                                                                                                                                                    contains = list(refMethodDef = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "refMethodDef", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                      value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                      for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                      value
                                                                                                                                                                                                                                                                                                                    }, test = function (object) 
                                                                                                                                                                                                                                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                        for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                        from, test = function (object) 
                                                                                                                                                                                                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                            if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                              stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("refMethodDefWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                            value
                                                                                                                                                                                                                                                                                                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                            from <- {
                                                                                                                                                                                                                                                                                                                              value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                              for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                              value
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                            if (strict) 
                                                                                                                                                                                                                                                                                                                              from@.Data
                                                                                                                                                                                                                                                                                                                          }, test = function (object) 
                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                              .value <- as(from, "refMethodDef", TRUE)
                                                                                                                                                                                                                                                                                                                              as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                              value <- .value
                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = "refMethodDef", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                              from <- {
                                                                                                                                                                                                                                                                                                                                value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                                for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                value
                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                if (strict) 
                                                                                                                                                                                                                                                                                                                                  from <- from@.Data
                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                            }, test = function (object) 
                                                                                                                                                                                                                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                .value <- as(from, "refMethodDef", TRUE)
                                                                                                                                                                                                                                                                                                                                as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                value <- .value
                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                  for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                  from
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                              }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                from <- {
                                                                                                                                                                                                                                                                                                                                  value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                                  for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                  value
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                  if (strict) 
                                                                                                                                                                                                                                                                                                                                    from <- from@.Data
                                                                                                                                                                                                                                                                                                                                  from
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                              }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                  .value <- as(from, "refMethodDef", TRUE)
                                                                                                                                                                                                                                                                                                                                  as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                  value <- .value
                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                    for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 3), SuperClassMethod = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                  from <- {
                                                                                                                                                                                                                                                                                                                                    value <- new("refMethodDef")
                                                                                                                                                                                                                                                                                                                                    for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                    value
                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                  from
                                                                                                                                                                                                                                                                                                                                }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                    .value <- as(from, "refMethodDef", TRUE)
                                                                                                                                                                                                                                                                                                                                    as(.value, "SuperClassMethod") <- value
                                                                                                                                                                                                                                                                                                                                    value <- .value
                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                      for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                  }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refMethodDefWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__refObject
list(`package:methods` = new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = <environment>, validity = NULL, access = list(), className = "refObject", package = "methods", subclasses = list(environment = new("SClassExtension", subClass = "environment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "refObject")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("environment"), "refObject", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), externalptr = new("SClassExtension", subClass = "externalptr", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "refObject")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("externalptr"), "refObject", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), name = new("SClassExtension", subClass = "name", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "refObject")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("name"), "refObject", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refClass = new("SClassExtension", subClass = "refClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
              from, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  if (!is(value, "refObject")) 
                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), .environment = new("SClassExtension", subClass = ".environment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- as(from, "environment", strict = strict)
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "environment", TRUE)
                    as(.value, "refObject") <- value
                    value <- .value
                    {
                      from@.xData <- value
                      from
                    }
                  }, simple = FALSE, by = "environment", dataPart = FALSE, distance = 2), .externalptr = new("SClassExtension", subClass = ".externalptr", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- as(from, "externalptr", strict = strict)
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "externalptr", TRUE)
                      as(.value, "refObject") <- value
                      value <- .value
                      {
                        from@.xData <- value
                        from
                      }
                    }, simple = FALSE, by = "externalptr", dataPart = FALSE, distance = 2), .name = new("SClassExtension", subClass = ".name", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- as(from, "name", strict = strict)
                      from
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "name", TRUE)
                        as(.value, "refObject") <- value
                        value <- .value
                        {
                          from@.xData <- value
                          from
                        }
                      }, simple = FALSE, by = "name", dataPart = FALSE, distance = 2), sourceEnvironment = new("SClassExtension", subClass = "sourceEnvironment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        from <- as(from, "environment", strict = strict)
                        from
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          .value <- as(from, "environment", TRUE)
                          as(.value, "refObject") <- value
                          value <- .value
                          {
                            .value <- as(from, ".environment", TRUE)
                            as(.value, "environment") <- value
                            value <- .value
                            {
                              for (what in ".xData") slot(from, what) <- slot(value, what)
                              from
                            }
                          }
                        }, simple = FALSE, by = "environment", dataPart = FALSE, distance = 3), envRefClass = new("SClassExtension", subClass = "envRefClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                          from, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                              as({
                                if (!is(value, "refObject")) 
                                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                                value
                              }, "envRefClass"), simple = TRUE, by = "refClass", dataPart = FALSE, distance = 2), refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                from, test = function (object) 
                                  TRUE, replace = function (from, to, value) 
                                    as({
                                      if (!is(value, "refObject")) 
                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                                      value
                                    }, "refObjectGenerator"), simple = TRUE, by = "refClass", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE), new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = <environment>, validity = NULL, access = list(), className = "refObject", package = "methods", subclasses = list(environment = new("SClassExtension", subClass = "environment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                      from, test = function (object) 
                                        TRUE, replace = function (from, to, value) 
                                        {
                                          if (!is(value, "refObject")) 
                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("environment"), "refObject", dQuote(class(value))), domain = NA)
                                          value
                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), externalptr = new("SClassExtension", subClass = "externalptr", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                          from, test = function (object) 
                                            TRUE, replace = function (from, to, value) 
                                            {
                                              if (!is(value, "refObject")) 
                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("externalptr"), "refObject", dQuote(class(value))), domain = NA)
                                              value
                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), name = new("SClassExtension", subClass = "name", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                              from, test = function (object) 
                                                TRUE, replace = function (from, to, value) 
                                                {
                                                  if (!is(value, "refObject")) 
                                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("name"), "refObject", dQuote(class(value))), domain = NA)
                                                  value
                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refClass = new("SClassExtension", subClass = "refClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                  from, test = function (object) 
                                                    TRUE, replace = function (from, to, value) 
                                                    {
                                                      if (!is(value, "refObject")) 
                                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                                                      value
                                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), .environment = new("SClassExtension", subClass = ".environment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                    {
                                                      from <- as(from, "environment", strict = strict)
                                                      from
                                                    }, test = function (object) 
                                                      TRUE, replace = function (from, to, value) 
                                                      {
                                                        .value <- as(from, "environment", TRUE)
                                                        as(.value, "refObject") <- value
                                                        value <- .value
                                                        {
                                                          from@.xData <- value
                                                          from
                                                        }
                                                      }, simple = FALSE, by = "environment", dataPart = FALSE, distance = 2), .externalptr = new("SClassExtension", subClass = ".externalptr", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                      {
                                                        from <- as(from, "externalptr", strict = strict)
                                                        from
                                                      }, test = function (object) 
                                                        TRUE, replace = function (from, to, value) 
                                                        {
                                                          .value <- as(from, "externalptr", TRUE)
                                                          as(.value, "refObject") <- value
                                                          value <- .value
                                                          {
                                                            from@.xData <- value
                                                            from
                                                          }
                                                        }, simple = FALSE, by = "externalptr", dataPart = FALSE, distance = 2), .name = new("SClassExtension", subClass = ".name", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                        {
                                                          from <- as(from, "name", strict = strict)
                                                          from
                                                        }, test = function (object) 
                                                          TRUE, replace = function (from, to, value) 
                                                          {
                                                            .value <- as(from, "name", TRUE)
                                                            as(.value, "refObject") <- value
                                                            value <- .value
                                                            {
                                                              from@.xData <- value
                                                              from
                                                            }
                                                          }, simple = FALSE, by = "name", dataPart = FALSE, distance = 2), sourceEnvironment = new("SClassExtension", subClass = "sourceEnvironment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                          {
                                                            from <- as(from, "environment", strict = strict)
                                                            from
                                                          }, test = function (object) 
                                                            TRUE, replace = function (from, to, value) 
                                                            {
                                                              .value <- as(from, "environment", TRUE)
                                                              as(.value, "refObject") <- value
                                                              value <- .value
                                                              {
                                                                .value <- as(from, ".environment", TRUE)
                                                                as(.value, "environment") <- value
                                                                value <- .value
                                                                {
                                                                  for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                  from
                                                                }
                                                              }
                                                            }, simple = FALSE, by = "environment", dataPart = FALSE, distance = 3), envRefClass = new("SClassExtension", subClass = "envRefClass", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                              from, test = function (object) 
                                                                TRUE, replace = function (from, to, value) 
                                                                  as({
                                                                    if (!is(value, "refObject")) 
                                                                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                                                                    value
                                                                  }, "envRefClass"), simple = TRUE, by = "refClass", dataPart = FALSE, distance = 2), refObjectGenerator = new("SClassExtension", subClass = "refObjectGenerator", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                                    from, test = function (object) 
                                                                      TRUE, replace = function (from, to, value) 
                                                                        as({
                                                                          if (!is(value, "refObject")) 
                                                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                                                                          value
                                                                        }, "refObjectGenerator"), simple = TRUE, by = "refClass", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__refObjectGenerator
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", generator = "refGeneratorSlot", className = "character", package = "character"), contains = list(classGeneratorFunction = new("SClassExtension", subClass = "refObjectGenerator", superClass = "classGeneratorFunction", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("classGeneratorFunction")
  for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refClass = new("SClassExtension", subClass = "refObjectGenerator", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "refClass")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refClass", dQuote("refObjectGenerator"), "refClass", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "refObjectGenerator", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("classGeneratorFunction")
          for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
          value
        }
        if (strict) 
          from@.Data
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "classGeneratorFunction", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "classGeneratorFunction", dataPart = TRUE, distance = 2), refObject = new("SClassExtension", subClass = "refObjectGenerator", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
              as({
                if (!is(value, "refObject")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                value
              }, "refObjectGenerator"), simple = TRUE, by = "refClass", dataPart = FALSE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "refObjectGenerator", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  value <- new("classGeneratorFunction")
                  for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                  value
                }
                {
                  if (strict) 
                    from <- from@.Data
                  from
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "classGeneratorFunction", TRUE)
                  as(.value, "OptionalFunction") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "classGeneratorFunction", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "refObjectGenerator", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  from <- {
                    value <- new("classGeneratorFunction")
                    for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                    value
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "classGeneratorFunction", TRUE)
                    as(.value, "PossibleMethod") <- value
                    value <- .value
                    {
                      for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                      from
                    }
                  }, simple = TRUE, by = "classGeneratorFunction", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "refObjectGenerator", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    from <- {
                      value <- new("classGeneratorFunction")
                      for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                      value
                    }
                    {
                      from <- {
                        if (strict) 
                          from <- from@.Data
                        from
                      }
                      from
                    }
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "classGeneratorFunction", TRUE)
                      as(.value, "optionalMethod") <- value
                      value <- .value
                      {
                        for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                        from
                      }
                    }, simple = TRUE, by = "classGeneratorFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refObjectGenerator", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", generator = "refGeneratorSlot", className = "character", package = "character"), contains = list(classGeneratorFunction = new("SClassExtension", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       subClass = "refObjectGenerator", superClass = "classGeneratorFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         value <- new("classGeneratorFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refClass = new("SClassExtension", subClass = "refObjectGenerator", superClass = "refClass", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is(value, "refClass")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refClass", dQuote("refObjectGenerator"), "refClass", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "refObjectGenerator", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- new("classGeneratorFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 .value <- as(from, "classGeneratorFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = "classGeneratorFunction", dataPart = TRUE, distance = 2), refObject = new("SClassExtension", subClass = "refObjectGenerator", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     as({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is(value, "refObject")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "refObject", dQuote("refClass"), "refObject", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, "refObjectGenerator"), simple = TRUE, by = "refClass", dataPart = FALSE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "refObjectGenerator", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         value <- new("classGeneratorFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "classGeneratorFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = "classGeneratorFunction", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "refObjectGenerator", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           value <- new("classGeneratorFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "classGeneratorFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = "classGeneratorFunction", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "refObjectGenerator", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value <- new("classGeneratorFunction")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "className", "package")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             .value <- as(from, "classGeneratorFunction", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "className", "package")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = "classGeneratorFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "refObjectGenerator", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__repeat
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "repeat", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "language")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("repeat"), "language", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = repeat {
      break
    }, validity = NULL, access = list(), className = "repeat", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "repeat", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "language")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("repeat"), "language", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = repeat {
          break
        }, validity = NULL, access = list(), className = "repeat", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__rle
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "rle", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "rle", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "rle", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "rle", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__S3
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = getClass("S4")@prototype, validity = NULL, access = list(), className = "S3", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = getClass("S4")@prototype, validity = NULL, access = list(), className = "S3", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, 
                                                                                                                                                                                                                                                                                              sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__S4
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = getClass("S4")@prototype, validity = NULL, access = list(), className = "S4", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = getClass("S4")@prototype, validity = NULL, access = list(), className = "S4", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, 
                                                                                                                                                                                                                                                                                              sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__SClassExtension
list(`package:methods` = new("classRepresentation", slots = list(subClass = "character", superClass = "character", package = "character", coerce = "function", test = "function", replace = "function", simple = "logical", by = "character", dataPart = "logical", distance = "numeric"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "SClassExtension", package = "methods", subclasses = list(conditionalExtension = new("SClassExtension", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         subClass = "conditionalExtension", superClass = "SClassExtension", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           class(from) <- "SClassExtension"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             for (what in c("subClass", "superClass", "package", "coerce", "test", "replace", "simple", "by", "dataPart", "distance")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(subClass = "character", superClass = "character", package = "character", coerce = "function", test = "function", replace = "function", simple = "logical", by = "character", dataPart = "logical", distance = "numeric"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "SClassExtension", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      package = "methods", subclasses = list(conditionalExtension = new("SClassExtension", subClass = "conditionalExtension", superClass = "SClassExtension", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        class(from) <- "SClassExtension"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          for (what in c("subClass", "superClass", "package", "coerce", "test", "replace", "simple", "by", "dataPart", "distance")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__SealedMethodDefinition
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character"), contains = list(MethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "MethodDefinition"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      class(from) <- "MethodDefinition"
      from
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "MethodDefinition", TRUE)
      as(.value, "function") <- value
      value <- .value
      {
        for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "function", TRUE)
        as(.value, "PossibleMethod") <- value
        value <- .value
        {
          .value <- as(from, "MethodDefinition", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
            from
          }
        }
      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "OptionalFunction") <- value
          value <- .value
          {
            .value <- as(from, "MethodDefinition", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            class(from) <- "MethodDefinition"
            from
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "MethodDefinition", TRUE)
            as(.value, "optionalMethod") <- value
            value <- .value
            {
              for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "SealedMethodDefinition", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", target = "signature", defined = "signature", generic = "character"), contains = list(MethodDefinition = new("SClassExtension", subClass = "SealedMethodDefinition", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        superClass = "MethodDefinition", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          class(from) <- "MethodDefinition"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              class(from) <- "MethodDefinition"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .value <- as(from, "MethodDefinition", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = "MethodDefinition", dataPart = TRUE, distance = 2), PossibleMethod = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .value <- as(from, "MethodDefinition", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .value <- as(from, "function", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .value <- as(from, "MethodDefinition", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "SealedMethodDefinition", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from <- {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    class(from) <- "MethodDefinition"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .value <- as(from, "MethodDefinition", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }, simple = TRUE, by = "MethodDefinition", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "SealedMethodDefinition", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__signature
list(`package:methods` = new("classRepresentation", slots = list(.Data = "character", names = "character", package = "character"), contains = list(character = new("SClassExtension", subClass = "signature", superClass = "character", package = "methods", coerce = function (from, strict = TRUE) 
{
  attributes(from) <- NULL
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    from@.Data <- as(value, "character", strict = FALSE)
    from
  }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "signature", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      from <- from@.Data
    from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "character", TRUE)
      as(.value, "vector") <- value
      value <- .value
      {
        from@.Data <- as(value, "character", strict = FALSE)
        from
      }
    }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), data.frameRowLabels = new("SClassExtension", subClass = "signature", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "character", TRUE)
        as(.value, "data.frameRowLabels") <- value
        value <- .value
        {
          from@.Data <- as(value, "character", strict = FALSE)
          from
        }
      }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), SuperClassMethod = new("SClassExtension", subClass = "signature", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "character", TRUE)
          as(.value, "SuperClassMethod") <- value
          value <- .value
          {
            from@.Data <- as(value, "character", strict = FALSE)
            from
          }
        }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "signature", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "character", names = "character", package = "character"), contains = list(character = new("SClassExtension", subClass = "signature", superClass = "character", package = "methods", 
                                                                                                                                                                                                                                                                                                                                                                                                                                    coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                      attributes(from) <- NULL
                                                                                                                                                                                                                                                                                                                                                                                                                                      from
                                                                                                                                                                                                                                                                                                                                                                                                                                    }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                        from@.Data <- as(value, "character", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                                                                                                                                      }, simple = TRUE, by = character(0), dataPart = TRUE, distance = 1), vector = new("SClassExtension", subClass = "signature", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                        if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                          from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                                                                                                                                      }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                          .value <- as(from, "character", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                          as(.value, "vector") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                          value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                            from@.Data <- as(value, "character", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), data.frameRowLabels = new("SClassExtension", subClass = "signature", superClass = "data.frameRowLabels", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                          if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                            from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                        }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                            .value <- as(from, "character", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                            as(.value, "data.frameRowLabels") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                            value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                              from@.Data <- as(value, "character", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                              from
                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                          }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), SuperClassMethod = new("SClassExtension", subClass = "signature", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                            if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                                                                              from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                          }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                              .value <- as(from, "character", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                              as(.value, "SuperClassMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                              value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                from@.Data <- as(value, "character", strict = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "signature", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__socket
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "socket", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "socket", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "socket", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "socket", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__sourceEnvironment
list(`package:methods` = new("classRepresentation", slots = list(packageName = "character", dateCreated = "POSIXt", sourceFile = "character", .xData = "environment"), contains = list(.environment = new("SClassExtension", subClass = "sourceEnvironment", superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new(".environment")
  for (what in ".xData") slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in ".xData") slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), environment = new("SClassExtension", subClass = "sourceEnvironment", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- as(from, ".environment", strict = strict)
    from@.xData
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, ".environment", TRUE)
      as(.value, "environment") <- value
      value <- .value
      {
        for (what in ".xData") slot(from, what) <- slot(value, what)
        from
      }
    }, simple = FALSE, by = ".environment", dataPart = FALSE, distance = 2), refObject = new("SClassExtension", subClass = "sourceEnvironment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
    {
      from <- as(from, "environment", strict = strict)
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "environment", TRUE)
        as(.value, "refObject") <- value
        value <- .value
        {
          .value <- as(from, ".environment", TRUE)
          as(.value, "environment") <- value
          value <- .value
          {
            for (what in ".xData") slot(from, what) <- slot(value, what)
            from
          }
        }
      }, simple = FALSE, by = "environment", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "sourceEnvironment", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(packageName = "character", dateCreated = "POSIXt", sourceFile = "character", .xData = "environment"), contains = list(.environment = new("SClassExtension", subClass = "sourceEnvironment", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    superClass = ".environment", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      value <- new(".environment")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      for (what in ".xData") slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), environment = new("SClassExtension", subClass = "sourceEnvironment", superClass = "environment", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from <- as(from, ".environment", strict = strict)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        from@.xData
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .value <- as(from, ".environment", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          as(.value, "environment") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = FALSE, by = ".environment", dataPart = FALSE, distance = 2), refObject = new("SClassExtension", subClass = "sourceEnvironment", superClass = "refObject", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from <- as(from, "environment", strict = strict)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .value <- as(from, "environment", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            as(.value, "refObject") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .value <- as(from, ".environment", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              as(.value, "environment") <- value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              value <- .value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for (what in ".xData") slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                from
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }, simple = FALSE, by = "environment", dataPart = FALSE, distance = 3)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "sourceEnvironment", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__special
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = FALSE, prototype = .Primitive("if"), validity = NULL, access = list(), className = "special", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = FALSE, prototype = .Primitive("if"), validity = NULL, access = list(), className = "special", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, 
                                                                                                                                                                                                                                                                                            sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__standardGeneric
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), contains = list(genericFunction = new("SClassExtension", subClass = "standardGeneric", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
{
  class(from) <- "genericFunction"
  from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "standardGeneric", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      class(from) <- "genericFunction"
      from
    }
    if (strict) 
      from@.Data
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "genericFunction", TRUE)
      as(.value, "function") <- value
      value <- .value
      {
        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
        from
      }
    }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "standardGeneric", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        from <- from@.Data
      from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        .value <- as(from, "function", TRUE)
        as(.value, "OptionalFunction") <- value
        value <- .value
        {
          .value <- as(from, "genericFunction", TRUE)
          as(.value, "function") <- value
          value <- .value
          {
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
            from
          }
        }
      }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "standardGeneric", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          from <- from@.Data
        from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "function", TRUE)
          as(.value, "PossibleMethod") <- value
          value <- .value
          {
            .value <- as(from, "genericFunction", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }
          }
        }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "standardGeneric", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            class(from) <- "genericFunction"
            from
          }
          {
            if (strict) 
              from <- from@.Data
            from
          }
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "genericFunction", TRUE)
            as(.value, "optionalMethod") <- value
            value <- .value
            {
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "standardGeneric", package = "methods", subclasses = list(standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "standardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
          {
            value <- new("standardGeneric")
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
            value
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call"), contains = list(genericFunction = new("SClassExtension", subClass = "standardGeneric", superClass = "genericFunction", package = "methods", coerce = function (from, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               strict = TRUE) 
            {
              class(from) <- "genericFunction"
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), `function` = new("SClassExtension", subClass = "standardGeneric", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  class(from) <- "genericFunction"
                  from
                }
                if (strict) 
                  from@.Data
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "genericFunction", TRUE)
                  as(.value, "function") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "genericFunction", dataPart = TRUE, distance = 2), OptionalFunction = new("SClassExtension", subClass = "standardGeneric", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                {
                  if (strict) 
                    from <- from@.Data
                  from
                }, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    .value <- as(from, "function", TRUE)
                    as(.value, "OptionalFunction") <- value
                    value <- .value
                    {
                      .value <- as(from, "genericFunction", TRUE)
                      as(.value, "function") <- value
                      value <- .value
                      {
                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                        from
                      }
                    }
                  }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), PossibleMethod = new("SClassExtension", subClass = "standardGeneric", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      .value <- as(from, "function", TRUE)
                      as(.value, "PossibleMethod") <- value
                      value <- .value
                      {
                        .value <- as(from, "genericFunction", TRUE)
                        as(.value, "function") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }
                    }, simple = TRUE, by = "function", dataPart = FALSE, distance = 3), optionalMethod = new("SClassExtension", subClass = "standardGeneric", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                    {
                      from <- {
                        class(from) <- "genericFunction"
                        from
                      }
                      {
                        if (strict) 
                          from <- from@.Data
                        from
                      }
                    }, test = function (object) 
                      TRUE, replace = function (from, to, value) 
                      {
                        .value <- as(from, "genericFunction", TRUE)
                        as(.value, "optionalMethod") <- value
                        value <- .value
                        {
                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                          from
                        }
                      }, simple = TRUE, by = "genericFunction", dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "standardGeneric", package = "methods", subclasses = list(standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "standardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
                      {
                        value <- new("standardGeneric")
                        for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                        value
                      }, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                          from
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__standardGenericWithTrace
list(`package:methods` = new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call", original = "PossibleMethod", source = "environment"), contains = list(standardGeneric = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "standardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
{
  value <- new("standardGeneric")
  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
  value
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
    from, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        if (!is(value, "traceable")) 
          stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("standardGenericWithTrace"), "traceable", dQuote(class(value))), domain = NA)
        value
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunction = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          value <- new("standardGeneric")
          for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
          value
        }
        {
          class(from) <- "genericFunction"
          from
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "standardGeneric", TRUE)
          as(.value, "genericFunction") <- value
          value <- .value
          {
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
            from
          }
        }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            value <- new("standardGeneric")
            for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
            value
          }
          if (strict) 
            from@.Data
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "standardGeneric", TRUE)
            as(.value, "function") <- value
            value <- .value
            {
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
              from
            }
          }, simple = TRUE, by = "standardGeneric", dataPart = TRUE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
          {
            from <- {
              value <- new("standardGeneric")
              for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
              value
            }
            {
              if (strict) 
                from <- from@.Data
              from
            }
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "standardGeneric", TRUE)
              as(.value, "OptionalFunction") <- value
              value <- .value
              {
                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                from
              }
            }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 4), PossibleMethod = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              from <- {
                value <- new("standardGeneric")
                for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                value
              }
              {
                if (strict) 
                  from <- from@.Data
                from
              }
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "standardGeneric", TRUE)
                as(.value, "PossibleMethod") <- value
                value <- .value
                {
                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                  from
                }
              }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  value <- new("standardGeneric")
                  for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                  value
                }
                {
                  from <- {
                    class(from) <- "genericFunction"
                    from
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    from
                  }
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "standardGeneric", TRUE)
                  as(.value, "optionalMethod") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "standardGenericWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "function", generic = "character", package = "character", group = "list", valueClass = "character", signature = "character", default = "optionalMethod", skeleton = "call", 
                                                                                                                                                                                                                                                                                                                                                               original = "PossibleMethod", source = "environment"), contains = list(standardGeneric = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "standardGeneric", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                 value <- new("standardGeneric")
                                                                                                                                                                                                                                                                                                                                                                 for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                               }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                 TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                 }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), traceable = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                   from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                     TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                       if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                         stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("standardGenericWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                       value
                                                                                                                                                                                                                                                                                                                                                                     }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunction = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "genericFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                       from <- {
                                                                                                                                                                                                                                                                                                                                                                         value <- new("standardGeneric")
                                                                                                                                                                                                                                                                                                                                                                         for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                         value
                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                         class(from) <- "genericFunction"
                                                                                                                                                                                                                                                                                                                                                                         from
                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                     }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                       TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                         .value <- as(from, "standardGeneric", TRUE)
                                                                                                                                                                                                                                                                                                                                                                         as(.value, "genericFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                         value <- .value
                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                           from
                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                       }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 2), `function` = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "function", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                         from <- {
                                                                                                                                                                                                                                                                                                                                                                           value <- new("standardGeneric")
                                                                                                                                                                                                                                                                                                                                                                           for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                           value
                                                                                                                                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                                                                                                                                         if (strict) 
                                                                                                                                                                                                                                                                                                                                                                           from@.Data
                                                                                                                                                                                                                                                                                                                                                                       }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                         TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                           .value <- as(from, "standardGeneric", TRUE)
                                                                                                                                                                                                                                                                                                                                                                           as(.value, "function") <- value
                                                                                                                                                                                                                                                                                                                                                                           value <- .value
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                         }, simple = TRUE, by = "standardGeneric", dataPart = TRUE, distance = 3), OptionalFunction = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "OptionalFunction", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                         {
                                                                                                                                                                                                                                                                                                                                                                           from <- {
                                                                                                                                                                                                                                                                                                                                                                             value <- new("standardGeneric")
                                                                                                                                                                                                                                                                                                                                                                             for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                             value
                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             if (strict) 
                                                                                                                                                                                                                                                                                                                                                                               from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                             from
                                                                                                                                                                                                                                                                                                                                                                           }
                                                                                                                                                                                                                                                                                                                                                                         }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                           TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             .value <- as(from, "standardGeneric", TRUE)
                                                                                                                                                                                                                                                                                                                                                                             as(.value, "OptionalFunction") <- value
                                                                                                                                                                                                                                                                                                                                                                             value <- .value
                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                           }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 4), PossibleMethod = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "PossibleMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                             from <- {
                                                                                                                                                                                                                                                                                                                                                                               value <- new("standardGeneric")
                                                                                                                                                                                                                                                                                                                                                                               for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                               value
                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                               if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                 from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                               from
                                                                                                                                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                                                                                                                                           }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                             TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                               .value <- as(from, "standardGeneric", TRUE)
                                                                                                                                                                                                                                                                                                                                                                               as(.value, "PossibleMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                               value <- .value
                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                 for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                 from
                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                             }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 4), optionalMethod = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "optionalMethod", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                               from <- {
                                                                                                                                                                                                                                                                                                                                                                                 value <- new("standardGeneric")
                                                                                                                                                                                                                                                                                                                                                                                 for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(value, what) <- slot(from, what)
                                                                                                                                                                                                                                                                                                                                                                                 value
                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                 from <- {
                                                                                                                                                                                                                                                                                                                                                                                   class(from) <- "genericFunction"
                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                   if (strict) 
                                                                                                                                                                                                                                                                                                                                                                                     from <- from@.Data
                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                             }, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                               TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                 .value <- as(from, "standardGeneric", TRUE)
                                                                                                                                                                                                                                                                                                                                                                                 as(.value, "optionalMethod") <- value
                                                                                                                                                                                                                                                                                                                                                                                 value <- .value
                                                                                                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                                                                                                   for (what in c(".Data", "generic", "package", "group", "valueClass", "signature", "default", "skeleton")) slot(from, what) <- slot(value, what)
                                                                                                                                                                                                                                                                                                                                                                                   from
                                                                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                                                                               }, simple = TRUE, by = "standardGeneric", dataPart = FALSE, distance = 5)), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "standardGenericWithTrace", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__structure
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "structure", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  as.vector(from), test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      attributes(value) <- attributes(from)
      value
    }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = numeric(0), validity = NULL, access = list(), className = "structure", package = "methods", subclasses = list(array = new("SClassExtension", subClass = "array", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "structure")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "structure", dQuote("array"), "structure", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), matrix = new("SClassExtension", subClass = "matrix", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
        {
          from <- {
            class(from) <- "array"
            from
          }
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "array", TRUE)
            as(.value, "structure") <- value
            value <- .value
            {
              class(value) <- "matrix"
              value
            }
          }, simple = TRUE, by = "array", dataPart = FALSE, distance = 2), ts = new("SClassExtension", subClass = "ts", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                if (!is(value, "structure")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "structure", dQuote("ts"), "structure", dQuote(class(value))), domain = NA)
                value
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), mts = new("SClassExtension", subClass = "mts", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  .dm <- dim(from)
                  .dn <- dimnames(from)
                  attributes(from) <- NULL
                  dim(from) <- .dm
                  dimnames(from) <- .dn
                  from
                }
                {
                  from <- {
                    class(from) <- "array"
                    from
                  }
                  from
                }
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "matrix", TRUE)
                  as(.value, "structure") <- value
                  value <- .value
                  {
                    for (what in NULL) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "matrix", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(vector = new("SClassExtension", subClass = "structure", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                  as.vector(from), test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      attributes(value) <- attributes(from)
                      value
                    }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1)), virtual = TRUE, prototype = numeric(0), validity = NULL, access = list(), className = "structure", package = "methods", subclasses = list(array = new("SClassExtension", subClass = "array", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "structure")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "structure", dQuote("array"), "structure", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), matrix = new("SClassExtension", subClass = "matrix", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          from <- {
                            class(from) <- "array"
                            from
                          }
                          from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "array", TRUE)
                            as(.value, "structure") <- value
                            value <- .value
                            {
                              class(value) <- "matrix"
                              value
                            }
                          }, simple = TRUE, by = "array", dataPart = FALSE, distance = 2), ts = new("SClassExtension", subClass = "ts", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
                            from, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                if (!is(value, "structure")) 
                                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "structure", dQuote("ts"), "structure", dQuote(class(value))), domain = NA)
                                value
                              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), mts = new("SClassExtension", subClass = "mts", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                from <- {
                                  .dm <- dim(from)
                                  .dn <- dimnames(from)
                                  attributes(from) <- NULL
                                  dim(from) <- .dm
                                  dimnames(from) <- .dn
                                  from
                                }
                                {
                                  from <- {
                                    class(from) <- "array"
                                    from
                                  }
                                  from
                                }
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "matrix", TRUE)
                                  as(.value, "structure") <- value
                                  value <- .value
                                  {
                                    for (what in NULL) slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }, simple = TRUE, by = "matrix", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__summary.table
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "summary.table", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = list(n.vars = 1, n.cases = 0), validity = NULL, access = list(), className = "summary.table", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "summary.table", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "oldClass")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = list(n.vars = 1, n.cases = 0), validity = NULL, access = list(), className = "summary.table", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__summaryDefault
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(table = new("SClassExtension", subClass = "summaryDefault", superClass = "table", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "table")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "summaryDefault", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
  {
    from <- {
      if (strict) 
        S3Part(from, S3Class = "table")
      else from
    }
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      .value <- as(from, "table", TRUE)
      as(.value, "oldClass") <- value
      value <- .value
      {
        S3Part(from) <- value
        from
      }
    }, simple = TRUE, by = "table", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "summaryDefault", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(table = new("SClassExtension", subClass = "summaryDefault", superClass = "table", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        S3Part(from, S3Class = "table")
      else from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from) <- value
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "summaryDefault", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
      {
        from <- {
          if (strict) 
            S3Part(from, S3Class = "table")
          else from
        }
        {
          if (strict) 
            S3Part(from, S3Class = "oldClass")
          else from
        }
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          .value <- as(from, "table", TRUE)
          as(.value, "oldClass") <- value
          value <- .value
          {
            S3Part(from) <- value
            from
          }
        }, simple = TRUE, by = "table", dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "summaryDefault", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__SuperClassMethod
list(`package:methods` = new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = character(0), validity = NULL, access = list(), className = "SuperClassMethod", package = "methods", subclasses = list(character = new("SClassExtension", subClass = "character", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "SuperClassMethod")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "SuperClassMethod", dQuote("character"), "SuperClassMethod", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refMethodDef = new("SClassExtension", subClass = "refMethodDef", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "SuperClassMethod")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "SuperClassMethod", dQuote("refMethodDef"), "SuperClassMethod", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), signature = new("SClassExtension", subClass = "signature", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
        {
          if (strict) 
            from <- from@.Data
          from
        }, test = function (object) 
          TRUE, replace = function (from, to, value) 
          {
            .value <- as(from, "character", TRUE)
            as(.value, "SuperClassMethod") <- value
            value <- .value
            {
              from@.Data <- as(value, "character", strict = FALSE)
              from
            }
          }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), className = new("SClassExtension", subClass = "className", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
          {
            if (strict) 
              from <- from@.Data
            from
          }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              .value <- as(from, "character", TRUE)
              as(.value, "SuperClassMethod") <- value
              value <- .value
              {
                from@.Data <- as(value, "character", strict = FALSE)
                from
              }
            }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), ObjectsWithPackage = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                from <- from@.Data
              from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                .value <- as(from, "character", TRUE)
                as(.value, "SuperClassMethod") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
              }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
              {
                from <- {
                  value <- new("refMethodDef")
                  for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                  value
                }
                from
              }, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  .value <- as(from, "refMethodDef", TRUE)
                  as(.value, "SuperClassMethod") <- value
                  value <- .value
                  {
                    for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                    from
                  }
                }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE), new("ClassUnionRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = character(0), validity = NULL, access = list(), className = "SuperClassMethod", package = "methods", subclasses = list(character = new("SClassExtension", subClass = "character", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "SuperClassMethod")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "SuperClassMethod", dQuote("character"), "SuperClassMethod", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refMethodDef = new("SClassExtension", subClass = "refMethodDef", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "SuperClassMethod")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "SuperClassMethod", dQuote("refMethodDef"), "SuperClassMethod", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), signature = new("SClassExtension", subClass = "signature", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                        {
                          if (strict) 
                            from <- from@.Data
                          from
                        }, test = function (object) 
                          TRUE, replace = function (from, to, value) 
                          {
                            .value <- as(from, "character", TRUE)
                            as(.value, "SuperClassMethod") <- value
                            value <- .value
                            {
                              from@.Data <- as(value, "character", strict = FALSE)
                              from
                            }
                          }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), className = new("SClassExtension", subClass = "className", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              from <- from@.Data
                            from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              .value <- as(from, "character", TRUE)
                              as(.value, "SuperClassMethod") <- value
                              value <- .value
                              {
                                from@.Data <- as(value, "character", strict = FALSE)
                                from
                              }
                            }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), ObjectsWithPackage = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                            {
                              if (strict) 
                                from <- from@.Data
                              from
                            }, test = function (object) 
                              TRUE, replace = function (from, to, value) 
                              {
                                .value <- as(from, "character", TRUE)
                                as(.value, "SuperClassMethod") <- value
                                value <- .value
                                {
                                  from@.Data <- as(value, "character", strict = FALSE)
                                  from
                                }
                              }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "SuperClassMethod", package = "methods", coerce = function (from, strict = TRUE) 
                              {
                                from <- {
                                  value <- new("refMethodDef")
                                  for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(value, what) <- slot(from, what)
                                  value
                                }
                                from
                              }, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  .value <- as(from, "refMethodDef", TRUE)
                                  as(.value, "SuperClassMethod") <- value
                                  value <- .value
                                  {
                                    for (what in c(".Data", "mayCall", "name", "refClassName", "superClassMethod")) slot(from, what) <- slot(value, what)
                                    from
                                  }
                                }, simple = TRUE, by = "refMethodDef", dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__table
list(`package:methods` = new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "table", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
{
  if (strict) 
    S3Part(from, S3Class = "oldClass")
  else from
}, test = function (object) 
  TRUE, replace = function (from, to, value) 
  {
    S3Part(from) <- value
    from
  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = integer(0), validity = NULL, access = list(), className = "table", package = "methods", subclasses = list(summaryDefault = new("SClassExtension", subClass = "summaryDefault", superClass = "table", package = "methods", coerce = function (from, strict = TRUE) 
  {
    if (strict) 
      S3Part(from, S3Class = "table")
    else from
  }, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      S3Part(from) <- value
      from
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.S3Class = "character"), contains = list(oldClass = new("SClassExtension", subClass = "table", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from) <- value
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = integer(0), validity = NULL, access = list(), className = "table", package = "methods", subclasses = list(summaryDefault = new("SClassExtension", subClass = "summaryDefault", superClass = "table", package = "methods", coerce = function (from, strict = TRUE) 
      {
        if (strict) 
          S3Part(from, S3Class = "table")
        else from
      }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          S3Part(from) <- value
          from
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__traceable
list(`package:methods` = new("classRepresentation", slots = list(original = "PossibleMethod", source = "environment"), contains = list(), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "traceable", package = "methods", subclasses = list(functionWithTrace = new("SClassExtension", subClass = "functionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "traceable")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("functionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinitionWithTrace = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "traceable")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("MethodDefinitionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "traceable")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("MethodWithNextWithTrace"), "traceable", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunctionWithTrace = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
              from, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  if (!is(value, "traceable")) 
                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("genericFunctionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "traceable")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("standardGenericWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGenericWithTrace = new("SClassExtension", subClass = "nonstandardGenericWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "traceable")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("nonstandardGenericWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                          from, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              if (!is(value, "traceable")) 
                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("groupGenericFunctionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                              value
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                              from, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  if (!is(value, "traceable")) 
                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("derivedDefaultMethodWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                  value
                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                  from, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      if (!is(value, "traceable")) 
                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("refMethodDefWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                      value
                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(original = "PossibleMethod", source = "environment"), contains = list(), virtual = TRUE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "traceable", package = "methods", subclasses = list(functionWithTrace = new("SClassExtension", subClass = "functionWithTrace", superClass = "traceable", package = "methods", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                            coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                              from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("functionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodDefinitionWithTrace = new("SClassExtension", subClass = "MethodDefinitionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("MethodDefinitionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), MethodWithNextWithTrace = new("SClassExtension", subClass = "MethodWithNextWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("MethodWithNextWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), genericFunctionWithTrace = new("SClassExtension", subClass = "genericFunctionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("genericFunctionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), standardGenericWithTrace = new("SClassExtension", subClass = "standardGenericWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("standardGenericWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), nonstandardGenericWithTrace = new("SClassExtension", subClass = "nonstandardGenericWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("nonstandardGenericWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), groupGenericFunctionWithTrace = new("SClassExtension", subClass = "groupGenericFunctionWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("groupGenericFunctionWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), derivedDefaultMethodWithTrace = new("SClassExtension", subClass = "derivedDefaultMethodWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("derivedDefaultMethodWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), refMethodDefWithTrace = new("SClassExtension", subClass = "refMethodDefWithTrace", superClass = "traceable", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              from, test = function (object) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  if (!is(value, "traceable")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "traceable", dQuote("refMethodDefWithTrace"), "traceable", dQuote(class(value))), domain = NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  value
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__ts
list(`package:methods` = new("classRepresentation", slots = list(.Data = "vector", tsp = "numeric", .S3Class = "character"), contains = list(structure = new("SClassExtension", subClass = "ts", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "structure")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "structure", dQuote("ts"), "structure", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "ts", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
    {
      if (strict) 
        S3Part(from, S3Class = "oldClass")
      else from
    }, test = function (object) 
      TRUE, replace = function (from, to, value) 
      {
        S3Part(from) <- value
        from
      }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "ts", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
        as.vector(from), test = function (object) 
          TRUE, replace = function (from, to, value) 
            as({
              attributes(value) <- attributes(from)
              value
            }, "ts"), simple = FALSE, by = "structure", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = NA, validity = NULL, access = list(), className = "ts", package = "methods", subclasses = list(mts = new("SClassExtension", subClass = "mts", superClass = "ts", package = "methods", coerce = function (from, strict = TRUE) 
            {
              if (strict) 
                S3Part(from, S3Class = "ts")
              else from
            }, test = function (object) 
              TRUE, replace = function (from, to, value) 
              {
                S3Part(from) <- value
                from
              }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(.Data = "vector", tsp = "numeric", .S3Class = "character"), contains = list(structure = new("SClassExtension", subClass = "ts", superClass = "structure", package = "methods", coerce = function (from, strict = TRUE) 
                from, test = function (object) 
                  TRUE, replace = function (from, to, value) 
                  {
                    if (!is(value, "structure")) 
                      stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "structure", dQuote("ts"), "structure", dQuote(class(value))), domain = NA)
                    value
                  }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), oldClass = new("SClassExtension", subClass = "ts", superClass = "oldClass", package = "methods", coerce = function (from, strict = TRUE) 
                  {
                    if (strict) 
                      S3Part(from, S3Class = "oldClass")
                    else from
                  }, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      S3Part(from) <- value
                      from
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), vector = new("SClassExtension", subClass = "ts", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                      as.vector(from), test = function (object) 
                        TRUE, replace = function (from, to, value) 
                          as({
                            attributes(value) <- attributes(from)
                            value
                          }, "ts"), simple = FALSE, by = "structure", dataPart = FALSE, distance = 2)), virtual = FALSE, prototype = NA, validity = NULL, access = list(), className = "ts", package = "methods", subclasses = list(mts = new("SClassExtension", subClass = "mts", superClass = "ts", package = "methods", coerce = function (from, strict = TRUE) 
                          {
                            if (strict) 
                              S3Part(from, S3Class = "ts")
                            else from
                          }, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              S3Part(from) <- value
                              from
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__uninitializedField
list(`package:methods` = new("classRepresentation", slots = list(field = "character", className = "character"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, validity = NULL, access = list(), className = "uninitializedField", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE), new("classRepresentation", slots = list(field = "character", className = "character"), contains = list(), virtual = FALSE, prototype = <S4 object of class NULL>, 
                                                                                                                                                                                                                                                                                                                                                             validity = NULL, access = list(), className = "uninitializedField", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__vector
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = logical(0), validity = NULL, access = list(), className = "vector", package = "methods", subclasses = list(logical = new("SClassExtension", subClass = "logical", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "vector")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("logical"), "vector", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "numeric", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "vector")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("numeric"), "vector", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), character = new("SClassExtension", subClass = "character", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
          from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
              if (!is(value, "vector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("character"), "vector", dQuote(class(value))), domain = NA)
              value
            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), double = new("SClassExtension", subClass = "double", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
              from, test = function (object) 
                TRUE, replace = function (from, to, value) 
                {
                  if (!is(value, "vector")) 
                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("double"), "vector", dQuote(class(value))), domain = NA)
                  value
                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), complex = new("SClassExtension", subClass = "complex", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                  from, test = function (object) 
                    TRUE, replace = function (from, to, value) 
                    {
                      if (!is(value, "vector")) 
                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("complex"), "vector", dQuote(class(value))), domain = NA)
                      value
                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), integer = new("SClassExtension", subClass = "integer", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                      from, test = function (object) 
                        TRUE, replace = function (from, to, value) 
                        {
                          if (!is(value, "vector")) 
                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("integer"), "vector", dQuote(class(value))), domain = NA)
                          value
                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), raw = new("SClassExtension", subClass = "raw", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                          from, test = function (object) 
                            TRUE, replace = function (from, to, value) 
                            {
                              if (!is(value, "vector")) 
                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("raw"), "vector", dQuote(class(value))), domain = NA)
                              value
                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), expression = new("SClassExtension", subClass = "expression", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                              from, test = function (object) 
                                TRUE, replace = function (from, to, value) 
                                {
                                  if (!is(value, "vector")) 
                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("expression"), "vector", dQuote(class(value))), domain = NA)
                                  value
                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), list = new("SClassExtension", subClass = "list", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                  from, test = function (object) 
                                    TRUE, replace = function (from, to, value) 
                                    {
                                      if (!is(value, "vector")) 
                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("list"), "vector", dQuote(class(value))), domain = NA)
                                      value
                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), structure = new("SClassExtension", subClass = "structure", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                      as.vector(from), test = function (object) 
                                        TRUE, replace = function (from, to, value) 
                                        {
                                          attributes(value) <- attributes(from)
                                          value
                                        }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), array = new("SClassExtension", subClass = "array", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                          as.vector(from), test = function (object) 
                                            TRUE, replace = function (from, to, value) 
                                              as({
                                                attributes(value) <- attributes(from)
                                                value
                                              }, "array"), simple = FALSE, by = "structure", dataPart = FALSE, distance = 2), matrix = new("SClassExtension", subClass = "matrix", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                              {
                                                from <- as(from, "array", strict = strict)
                                                as.vector(from)
                                              }, test = function (object) 
                                                TRUE, replace = function (from, to, value) 
                                                {
                                                  .value <- as(from, "array", TRUE)
                                                  as(.value, "vector") <- value
                                                  value <- .value
                                                  {
                                                    class(value) <- "matrix"
                                                    value
                                                  }
                                                }, simple = FALSE, by = "array", dataPart = FALSE, distance = 3), signature = new("SClassExtension", subClass = "signature", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                {
                                                  if (strict) 
                                                    from <- from@.Data
                                                  from
                                                }, test = function (object) 
                                                  TRUE, replace = function (from, to, value) 
                                                  {
                                                    .value <- as(from, "character", TRUE)
                                                    as(.value, "vector") <- value
                                                    value <- .value
                                                    {
                                                      from@.Data <- as(value, "character", strict = FALSE)
                                                      from
                                                    }
                                                  }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), className = new("SClassExtension", subClass = "className", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                  {
                                                    if (strict) 
                                                      from <- from@.Data
                                                    from
                                                  }, test = function (object) 
                                                    TRUE, replace = function (from, to, value) 
                                                    {
                                                      .value <- as(from, "character", TRUE)
                                                      as(.value, "vector") <- value
                                                      value <- .value
                                                      {
                                                        from@.Data <- as(value, "character", strict = FALSE)
                                                        from
                                                      }
                                                    }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), ObjectsWithPackage = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                    {
                                                      if (strict) 
                                                        from <- from@.Data
                                                      from
                                                    }, test = function (object) 
                                                      TRUE, replace = function (from, to, value) 
                                                      {
                                                        .value <- as(from, "character", TRUE)
                                                        as(.value, "vector") <- value
                                                        value <- .value
                                                        {
                                                          from@.Data <- as(value, "character", strict = FALSE)
                                                          from
                                                        }
                                                      }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), ts = new("SClassExtension", subClass = "ts", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                        as.vector(from), test = function (object) 
                                                          TRUE, replace = function (from, to, value) 
                                                            as({
                                                              attributes(value) <- attributes(from)
                                                              value
                                                            }, "ts"), simple = FALSE, by = "structure", dataPart = FALSE, distance = 2), mts = new("SClassExtension", subClass = "mts", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                            {
                                                              from <- as(from, "matrix", strict = strict)
                                                              {
                                                                from <- as(from, "array", strict = strict)
                                                                as.vector(from)
                                                              }
                                                            }, test = function (object) 
                                                              TRUE, replace = function (from, to, value) 
                                                              {
                                                                .value <- as(from, "matrix", TRUE)
                                                                as(.value, "vector") <- value
                                                                value <- .value
                                                                {
                                                                  for (what in NULL) slot(from, what) <- slot(value, what)
                                                                  from
                                                                }
                                                              }, simple = FALSE, by = "matrix", dataPart = FALSE, distance = 4), factor = new("SClassExtension", subClass = "factor", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                              {
                                                                if (strict) 
                                                                  from <- from@.Data
                                                                from
                                                              }, test = function (object) 
                                                                TRUE, replace = function (from, to, value) 
                                                                {
                                                                  .value <- as(from, "integer", TRUE)
                                                                  as(.value, "vector") <- value
                                                                  value <- .value
                                                                  {
                                                                    from@.Data <- as(value, "integer", strict = FALSE)
                                                                    from
                                                                  }
                                                                }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), ordered = new("SClassExtension", subClass = "ordered", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                {
                                                                  from <- {
                                                                    if (strict) 
                                                                      S3Part(from, S3Class = "factor")
                                                                    else from
                                                                  }
                                                                  {
                                                                    if (strict) 
                                                                      from <- from@.Data
                                                                    from
                                                                  }
                                                                }, test = function (object) 
                                                                  TRUE, replace = function (from, to, value) 
                                                                  {
                                                                    .value <- as(from, "factor", TRUE)
                                                                    as(.value, "vector") <- value
                                                                    value <- .value
                                                                    {
                                                                      S3Part(from) <- value
                                                                      from
                                                                    }
                                                                  }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 3), data.frame = new("SClassExtension", subClass = "data.frame", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                  {
                                                                    if (strict) 
                                                                      from <- from@.Data
                                                                    from
                                                                  }, test = function (object) 
                                                                    TRUE, replace = function (from, to, value) 
                                                                    {
                                                                      .value <- as(from, "list", TRUE)
                                                                      as(.value, "vector") <- value
                                                                      value <- .value
                                                                      {
                                                                        from@.Data <- as(value, "list", strict = FALSE)
                                                                        from
                                                                      }
                                                                    }, simple = TRUE, by = "list", dataPart = FALSE, distance = 2), namedList = new("SClassExtension", subClass = "namedList", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                    {
                                                                      if (strict) 
                                                                        from <- from@.Data
                                                                      from
                                                                    }, test = function (object) 
                                                                      TRUE, replace = function (from, to, value) 
                                                                      {
                                                                        .value <- as(from, "list", TRUE)
                                                                        as(.value, "vector") <- value
                                                                        value <- .value
                                                                        {
                                                                          from@.Data <- as(value, "list", strict = FALSE)
                                                                          from
                                                                        }
                                                                      }, simple = TRUE, by = "list", dataPart = FALSE, distance = 2), listOfMethods = new("SClassExtension", subClass = "listOfMethods", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                      {
                                                                        from <- {
                                                                          value <- new("namedList")
                                                                          for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
                                                                          value
                                                                        }
                                                                        {
                                                                          if (strict) 
                                                                            from <- from@.Data
                                                                          from
                                                                        }
                                                                      }, test = function (object) 
                                                                        TRUE, replace = function (from, to, value) 
                                                                        {
                                                                          .value <- as(from, "namedList", TRUE)
                                                                          as(.value, "vector") <- value
                                                                          value <- .value
                                                                          {
                                                                            for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
                                                                            from
                                                                          }
                                                                        }, simple = TRUE, by = "namedList", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = logical(0), validity = NULL, access = list(), className = "vector", package = "methods", subclasses = list(logical = new("SClassExtension", subClass = "logical", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                          from, test = function (object) 
                                                                            TRUE, replace = function (from, to, value) 
                                                                            {
                                                                              if (!is(value, "vector")) 
                                                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("logical"), "vector", dQuote(class(value))), domain = NA)
                                                                              value
                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), numeric = new("SClassExtension", subClass = "numeric", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                              from, test = function (object) 
                                                                                TRUE, replace = function (from, to, value) 
                                                                                {
                                                                                  if (!is(value, "vector")) 
                                                                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("numeric"), "vector", dQuote(class(value))), domain = NA)
                                                                                  value
                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), character = new("SClassExtension", subClass = "character", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                  from, test = function (object) 
                                                                                    TRUE, replace = function (from, to, value) 
                                                                                    {
                                                                                      if (!is(value, "vector")) 
                                                                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("character"), "vector", dQuote(class(value))), domain = NA)
                                                                                      value
                                                                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), double = new("SClassExtension", subClass = "double", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                      from, test = function (object) 
                                                                                        TRUE, replace = function (from, to, value) 
                                                                                        {
                                                                                          if (!is(value, "vector")) 
                                                                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("double"), "vector", dQuote(class(value))), domain = NA)
                                                                                          value
                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), complex = new("SClassExtension", subClass = "complex", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                          from, test = function (object) 
                                                                                            TRUE, replace = function (from, to, value) 
                                                                                            {
                                                                                              if (!is(value, "vector")) 
                                                                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("complex"), "vector", dQuote(class(value))), domain = NA)
                                                                                              value
                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), integer = new("SClassExtension", subClass = "integer", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                              from, test = function (object) 
                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                {
                                                                                                  if (!is(value, "vector")) 
                                                                                                    stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("integer"), "vector", dQuote(class(value))), domain = NA)
                                                                                                  value
                                                                                                }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), raw = new("SClassExtension", subClass = "raw", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                  from, test = function (object) 
                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                    {
                                                                                                      if (!is(value, "vector")) 
                                                                                                        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("raw"), "vector", dQuote(class(value))), domain = NA)
                                                                                                      value
                                                                                                    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), expression = new("SClassExtension", subClass = "expression", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                      from, test = function (object) 
                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                        {
                                                                                                          if (!is(value, "vector")) 
                                                                                                            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("expression"), "vector", dQuote(class(value))), domain = NA)
                                                                                                          value
                                                                                                        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), list = new("SClassExtension", subClass = "list", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                          from, test = function (object) 
                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                            {
                                                                                                              if (!is(value, "vector")) 
                                                                                                                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "vector", dQuote("list"), "vector", dQuote(class(value))), domain = NA)
                                                                                                              value
                                                                                                            }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1), structure = new("SClassExtension", subClass = "structure", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                              as.vector(from), test = function (object) 
                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                {
                                                                                                                  attributes(value) <- attributes(from)
                                                                                                                  value
                                                                                                                }, simple = FALSE, by = character(0), dataPart = FALSE, distance = 1), array = new("SClassExtension", subClass = "array", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                  as.vector(from), test = function (object) 
                                                                                                                    TRUE, replace = function (from, to, value) 
                                                                                                                      as({
                                                                                                                        attributes(value) <- attributes(from)
                                                                                                                        value
                                                                                                                      }, "array"), simple = FALSE, by = "structure", dataPart = FALSE, distance = 2), matrix = new("SClassExtension", subClass = "matrix", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                      {
                                                                                                                        from <- as(from, "array", strict = strict)
                                                                                                                        as.vector(from)
                                                                                                                      }, test = function (object) 
                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                        {
                                                                                                                          .value <- as(from, "array", TRUE)
                                                                                                                          as(.value, "vector") <- value
                                                                                                                          value <- .value
                                                                                                                          {
                                                                                                                            class(value) <- "matrix"
                                                                                                                            value
                                                                                                                          }
                                                                                                                        }, simple = FALSE, by = "array", dataPart = FALSE, distance = 3), signature = new("SClassExtension", subClass = "signature", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                        {
                                                                                                                          if (strict) 
                                                                                                                            from <- from@.Data
                                                                                                                          from
                                                                                                                        }, test = function (object) 
                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                          {
                                                                                                                            .value <- as(from, "character", TRUE)
                                                                                                                            as(.value, "vector") <- value
                                                                                                                            value <- .value
                                                                                                                            {
                                                                                                                              from@.Data <- as(value, "character", strict = FALSE)
                                                                                                                              from
                                                                                                                            }
                                                                                                                          }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), className = new("SClassExtension", subClass = "className", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                          {
                                                                                                                            if (strict) 
                                                                                                                              from <- from@.Data
                                                                                                                            from
                                                                                                                          }, test = function (object) 
                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                            {
                                                                                                                              .value <- as(from, "character", TRUE)
                                                                                                                              as(.value, "vector") <- value
                                                                                                                              value <- .value
                                                                                                                              {
                                                                                                                                from@.Data <- as(value, "character", strict = FALSE)
                                                                                                                                from
                                                                                                                              }
                                                                                                                            }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), ObjectsWithPackage = new("SClassExtension", subClass = "ObjectsWithPackage", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                            {
                                                                                                                              if (strict) 
                                                                                                                                from <- from@.Data
                                                                                                                              from
                                                                                                                            }, test = function (object) 
                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                              {
                                                                                                                                .value <- as(from, "character", TRUE)
                                                                                                                                as(.value, "vector") <- value
                                                                                                                                value <- .value
                                                                                                                                {
                                                                                                                                  from@.Data <- as(value, "character", strict = FALSE)
                                                                                                                                  from
                                                                                                                                }
                                                                                                                              }, simple = TRUE, by = "character", dataPart = FALSE, distance = 2), ts = new("SClassExtension", subClass = "ts", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                as.vector(from), test = function (object) 
                                                                                                                                  TRUE, replace = function (from, to, value) 
                                                                                                                                    as({
                                                                                                                                      attributes(value) <- attributes(from)
                                                                                                                                      value
                                                                                                                                    }, "ts"), simple = FALSE, by = "structure", dataPart = FALSE, distance = 2), mts = new("SClassExtension", subClass = "mts", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                    {
                                                                                                                                      from <- as(from, "matrix", strict = strict)
                                                                                                                                      {
                                                                                                                                        from <- as(from, "array", strict = strict)
                                                                                                                                        as.vector(from)
                                                                                                                                      }
                                                                                                                                    }, test = function (object) 
                                                                                                                                      TRUE, replace = function (from, to, value) 
                                                                                                                                      {
                                                                                                                                        .value <- as(from, "matrix", TRUE)
                                                                                                                                        as(.value, "vector") <- value
                                                                                                                                        value <- .value
                                                                                                                                        {
                                                                                                                                          for (what in NULL) slot(from, what) <- slot(value, what)
                                                                                                                                          from
                                                                                                                                        }
                                                                                                                                      }, simple = FALSE, by = "matrix", dataPart = FALSE, distance = 4), factor = new("SClassExtension", subClass = "factor", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                      {
                                                                                                                                        if (strict) 
                                                                                                                                          from <- from@.Data
                                                                                                                                        from
                                                                                                                                      }, test = function (object) 
                                                                                                                                        TRUE, replace = function (from, to, value) 
                                                                                                                                        {
                                                                                                                                          .value <- as(from, "integer", TRUE)
                                                                                                                                          as(.value, "vector") <- value
                                                                                                                                          value <- .value
                                                                                                                                          {
                                                                                                                                            from@.Data <- as(value, "integer", strict = FALSE)
                                                                                                                                            from
                                                                                                                                          }
                                                                                                                                        }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), ordered = new("SClassExtension", subClass = "ordered", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                        {
                                                                                                                                          from <- {
                                                                                                                                            if (strict) 
                                                                                                                                              S3Part(from, S3Class = "factor")
                                                                                                                                            else from
                                                                                                                                          }
                                                                                                                                          {
                                                                                                                                            if (strict) 
                                                                                                                                              from <- from@.Data
                                                                                                                                            from
                                                                                                                                          }
                                                                                                                                        }, test = function (object) 
                                                                                                                                          TRUE, replace = function (from, to, value) 
                                                                                                                                          {
                                                                                                                                            .value <- as(from, "factor", TRUE)
                                                                                                                                            as(.value, "vector") <- value
                                                                                                                                            value <- .value
                                                                                                                                            {
                                                                                                                                              S3Part(from) <- value
                                                                                                                                              from
                                                                                                                                            }
                                                                                                                                          }, simple = TRUE, by = "factor", dataPart = FALSE, distance = 3), data.frame = new("SClassExtension", subClass = "data.frame", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                          {
                                                                                                                                            if (strict) 
                                                                                                                                              from <- from@.Data
                                                                                                                                            from
                                                                                                                                          }, test = function (object) 
                                                                                                                                            TRUE, replace = function (from, to, value) 
                                                                                                                                            {
                                                                                                                                              .value <- as(from, "list", TRUE)
                                                                                                                                              as(.value, "vector") <- value
                                                                                                                                              value <- .value
                                                                                                                                              {
                                                                                                                                                from@.Data <- as(value, "list", strict = FALSE)
                                                                                                                                                from
                                                                                                                                              }
                                                                                                                                            }, simple = TRUE, by = "list", dataPart = FALSE, distance = 2), namedList = new("SClassExtension", subClass = "namedList", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                            {
                                                                                                                                              if (strict) 
                                                                                                                                                from <- from@.Data
                                                                                                                                              from
                                                                                                                                            }, test = function (object) 
                                                                                                                                              TRUE, replace = function (from, to, value) 
                                                                                                                                              {
                                                                                                                                                .value <- as(from, "list", TRUE)
                                                                                                                                                as(.value, "vector") <- value
                                                                                                                                                value <- .value
                                                                                                                                                {
                                                                                                                                                  from@.Data <- as(value, "list", strict = FALSE)
                                                                                                                                                  from
                                                                                                                                                }
                                                                                                                                              }, simple = TRUE, by = "list", dataPart = FALSE, distance = 2), listOfMethods = new("SClassExtension", subClass = "listOfMethods", superClass = "vector", package = "methods", coerce = function (from, strict = TRUE) 
                                                                                                                                              {
                                                                                                                                                from <- {
                                                                                                                                                  value <- new("namedList")
                                                                                                                                                  for (what in c(".Data", "names")) slot(value, what) <- slot(from, what)
                                                                                                                                                  value
                                                                                                                                                }
                                                                                                                                                {
                                                                                                                                                  if (strict) 
                                                                                                                                                    from <- from@.Data
                                                                                                                                                  from
                                                                                                                                                }
                                                                                                                                              }, test = function (object) 
                                                                                                                                                TRUE, replace = function (from, to, value) 
                                                                                                                                                {
                                                                                                                                                  .value <- as(from, "namedList", TRUE)
                                                                                                                                                  as(.value, "vector") <- value
                                                                                                                                                  value <- .value
                                                                                                                                                  {
                                                                                                                                                    for (what in c(".Data", "names")) slot(from, what) <- slot(value, what)
                                                                                                                                                    from
                                                                                                                                                  }
                                                                                                                                                }, simple = TRUE, by = "namedList", dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__VIRTUAL
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "VIRTUAL", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(), virtual = TRUE, prototype = NULL, validity = NULL, access = list(), className = "VIRTUAL", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__C__while
list(`package:methods` = new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "while", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
  from, test = function (object) 
    TRUE, replace = function (from, to, value) 
    {
      if (!is(value, "language")) 
        stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("while"), "language", dQuote(class(value))), domain = NA)
      value
    }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = while (FALSE) NULL, validity = NULL, access = list(), className = "while", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE), new("classRepresentation", slots = list(), contains = list(language = new("SClassExtension", subClass = "while", superClass = "language", package = "methods", coerce = function (from, strict = TRUE) 
      from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
          if (!is(value, "language")) 
            stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", "language", dQuote("while"), "language", dQuote(class(value))), domain = NA)
          value
        }, simple = TRUE, by = character(0), dataPart = FALSE, distance = 1)), virtual = FALSE, prototype = while (FALSE) NULL, validity = NULL, access = list(), className = "while", package = "methods", subclasses = list(), versionKey = <pointer: (nil)>, sealed = TRUE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__$:base
list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>, <environment>)
c("package:lubridate", "package:methods", "namespace:Rcpp", "namespace:lubridate", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE, TRUE)
.__T__$<-:base
list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
.__T__[:base
       list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
       c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
       c(TRUE, TRUE, FALSE, FALSE)
       c(FALSE, FALSE, TRUE, TRUE)
       .__T__[[<-:base
               list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
               c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
               c(TRUE, TRUE, FALSE, FALSE)
               c(FALSE, FALSE, TRUE, TRUE)
               .__T__[<-:base
                      list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
                      c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
                      c(TRUE, TRUE, FALSE, FALSE)
                      c(FALSE, FALSE, TRUE, TRUE)
                      .__T__addNextMethod:methods
                      list(`package:methods` = <environment>, <environment>)
                      c("package:methods", "namespace:methods")
                      c(TRUE, FALSE)
                      c(FALSE, TRUE)
                      .__T__Arith:base
                      list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
                      c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
                      c(TRUE, TRUE, FALSE, FALSE)
                      c(FALSE, FALSE, TRUE, TRUE)
                      .__T__body<-:base
                      list(`package:methods` = <environment>, <environment>)
                      c("package:methods", "namespace:methods")
                      c(TRUE, FALSE)
                      c(FALSE, TRUE)
                      .__T__cbind2:methods
                      list(`package:methods` = <environment>, <environment>)
                      c("package:methods", "namespace:methods")
                      c(TRUE, FALSE)
                      c(FALSE, TRUE)
                      .__T__coerce:methods
                      list(`package:methods` = <environment>, <environment>)
                      c("package:methods", "namespace:methods")
                      c(TRUE, FALSE)
                      c(FALSE, TRUE)
                      .__T__coerce<-:methods
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__Compare:methods
list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>)
c("package:lubridate", "package:methods", "namespace:lubridate", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
.__T__Complex:base
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__initialize:methods
list(`package:methods` = <environment>, <environment>, <environment>, <environment>)
c("package:methods", "namespace:Rcpp", "namespace:lubridate", "namespace:methods")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE)
.__T__kronecker:base
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__loadMethod:methods
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__Logic:base
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__Math:base
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__Math2:methods
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__Ops:base
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__rbind2:methods
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__show:methods
list(`package:lubridate` = <environment>, `package:methods` = <environment>, <environment>, <environment>, <environment>)
c("package:lubridate", "package:methods", "namespace:Rcpp", "namespace:lubridate", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE, TRUE)
.__T__slotsFromS3:methods
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.__T__Summary:base
list(`package:methods` = <environment>, <environment>)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.classEnv
list(`package:methods` = function (Class, default = .requirePackage("methods"), mustFind = TRUE) 
{
  package <- {
    if (is.character(Class)) 
      packageSlot(Class)
    else Class@package
  }
  if (is.null(package)) {
    value <- default
    def <- getClassDef(Class, value, NULL)
    if (is.null(def)) {
      value <- .GlobalEnv
      def <- getClassDef(Class, value, NULL)
      if (is.null(def)) {
        value <- .requirePackage("methods")
        if (!identical(default, value)) 
          def <- getClassDef(Class, value, NULL)
      }
    }
    if (is.null(def) && mustFind) 
      stop(gettextf("unable to find an environment containing class %s", dQuote(Class)), domain = NA)
    value
  }
  else .requirePackage(package)
}, function (Class, default = .requirePackage("methods"), mustFind = TRUE) 
{
  package <- {
    if (is.character(Class)) 
      packageSlot(Class)
    else Class@package
  }
  if (is.null(package)) {
    value <- default
    def <- getClassDef(Class, value, NULL)
    if (is.null(def)) {
      value <- .GlobalEnv
      def <- getClassDef(Class, value, NULL)
      if (is.null(def)) {
        value <- .requirePackage("methods")
        if (!identical(default, value)) 
          def <- getClassDef(Class, value, NULL)
      }
    }
    if (is.null(def) && mustFind) 
      stop(gettextf("unable to find an environment containing class %s", dQuote(Class)), domain = NA)
    value
  }
  else .requirePackage(package)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.debugMethod
list(`package:methods` = function (fun, text = "", condition = NULL, signature, once = FALSE) 
{
  stopifnot(is.null(condition), identical(text, ""))
  if (is.primitive(fun)) 
    fun <- getGeneric(fun)
  if (!is(fun, "genericFunction")) 
    stop("Function must be an S4 generic")
  if (isdebugged(fun, signature = signature)) 
    return(invisible(NULL))
  m <- selectMethod(fun, signature)
  bd <- body(m)
  isrematch <- isRematched(m)
  if (isrematch) 
    bd <- body(bd[[2]][[3]])
  at <- if (is(bd, "{")) 
    2
  else numeric()
  tracer <- if (once) {
    if (isrematch) 
      quote(quote({
        untrace(sys.frame(2)$.Generic, signature = sys.frame(2)$.target)
        browser()
      }))
    else quote(quote({
      untrace(.Generic, signature = .target)
      browser()
    }))
  }
  else {
    quote(browser)
  }
  eval(substitute(trace(fun, tracer, signature = signature, print = TRUE, at = at), list(tracer = tracer)))
  invisible(NULL)
}, function (fun, text = "", condition = NULL, signature, once = FALSE) 
{
  stopifnot(is.null(condition), identical(text, ""))
  if (is.primitive(fun)) 
    fun <- getGeneric(fun)
  if (!is(fun, "genericFunction")) 
    stop("Function must be an S4 generic")
  if (isdebugged(fun, signature = signature)) 
    return(invisible(NULL))
  m <- selectMethod(fun, signature)
  bd <- body(m)
  isrematch <- isRematched(m)
  if (isrematch) 
    bd <- body(bd[[2]][[3]])
  at <- if (is(bd, "{")) 
    2
  else numeric()
  tracer <- if (once) {
    if (isrematch) 
      quote(quote({
        untrace(sys.frame(2)$.Generic, signature = sys.frame(2)$.target)
        browser()
      }))
    else quote(quote({
      untrace(.Generic, signature = .target)
      browser()
    }))
  }
  else {
    quote(browser)
  }
  eval(substitute(trace(fun, tracer, signature = signature, print = TRUE, at = at), list(tracer = tracer)))
  invisible(NULL)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.doTracePrint
list(`package:methods` = function (msg = "") 
{
  call <- deparse(sys.call(sys.parent(1)))
  if (length(call) > 1) 
    call <- paste(call[[1]], "....")
  cat("Tracing", call, msg, "\n")
}, function (msg = "") 
{
  call <- deparse(sys.call(sys.parent(1)))
  if (length(call) > 1) 
    call <- paste(call[[1]], "....")
  cat("Tracing", call, msg, "\n")
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.EmptyPrimitiveSkeletons
list(`package:methods` = list(f(x), fgets(x, value = value)), list(f(x), fgets(x, value = value)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.hasSlot
list(`package:methods` = function (object, name) 
  .Call(C_R_hasSlot, object, name), function (object, name) 
    .Call(C_R_hasSlot, object, name))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.isMethodDebugged
list(`package:methods` = function (fun, signature) 
{
  meth <- selectMethod(fun, signature)
  if (!is(meth, "MethodDefinitionWithTrace")) 
    return(FALSE)
  bd <- body(meth)
  if (isRematched(meth)) {
    is(bd[[3]], "{") && identical(bd[[3]][[2]][1], quote(.doTrace())) && identical(bd[[3]][[2]][[2]][1:3], quote(trace(.local, tracer = browser)))
  }
  else {
    fstexp <- bd
    while (is(bd, "{")) bd <- bd[[2]]
    identical(bd[1:2], quote(.doTrace(browser())))
  }
}, function (fun, signature) 
{
  meth <- selectMethod(fun, signature)
  if (!is(meth, "MethodDefinitionWithTrace")) 
    return(FALSE)
  bd <- body(meth)
  if (isRematched(meth)) {
    is(bd[[3]], "{") && identical(bd[[3]][[2]][1], quote(.doTrace())) && identical(bd[[3]][[2]][[2]][1:3], quote(trace(.local, tracer = browser)))
  }
  else {
    fstexp <- bd
    while (is(bd, "{")) bd <- bd[[2]]
    identical(bd[1:2], quote(.doTrace(browser())))
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.OldClassesList
list(`package:methods` = list(c("anova", "data.frame"), c("mlm", "lm"), c("aov", "lm"), c("maov", "mlm", "lm"), c("POSIXct", "POSIXt"), c("POSIXlt", "POSIXt"), "Date", "dump.frames", c("glm.null", "glm", "lm"), c("anova.glm.null", "anova.glm"), "hsearch", "integrate", "packageInfo", "libraryIQR", "packageIQR", "mtable", c("summaryDefault", "table"), "recordedplot", "socket", "packageIQR", "density", "logLik", "rle"), list(c("anova", "data.frame"), c("mlm", "lm"), c("aov", "lm"), c("maov", "mlm", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "lm"), c("POSIXct", "POSIXt"), c("POSIXlt", "POSIXt"), "Date", "dump.frames", c("glm.null", "glm", "lm"), c("anova.glm.null", "anova.glm"), "hsearch", "integrate", "packageInfo", "libraryIQR", "packageIQR", "mtable", c("summaryDefault", "table"), "recordedplot", "socket", "packageIQR", "density", "logLik", "rle"))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.S4methods
list(`package:methods` = function (generic.function, class) 
{
  info <- if (!missing(generic.function)) 
    .S4methodsForGeneric(generic.function, class)
  else if (!missing(class)) 
    .S4methodsForClass(generic.function, class)
  else stop("must supply 'generic.function' or 'class'")
  structure(rownames(info), info = info, byclass = missing(generic.function), class = "MethodsFunction")
}, function (generic.function, class) 
{
  info <- if (!missing(generic.function)) 
    .S4methodsForGeneric(generic.function, class)
  else if (!missing(class)) 
    .S4methodsForClass(generic.function, class)
  else stop("must supply 'generic.function' or 'class'")
  structure(rownames(info), info = info, byclass = missing(generic.function), class = "MethodsFunction")
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.selectSuperClasses
list(`package:methods` = function (ext, dropVirtual = FALSE, namesOnly = TRUE, directOnly = TRUE, simpleOnly = directOnly) 
{
  addCond <- function(xpr, prev) if (length(prev)) 
    substitute(P && N, list(P = prev, N = xpr))
  else xpr
  C <- if (dropVirtual) {
    isVirtualExt <- function(x) getClassDef(x@superClass, package = packageSlot(x))@virtual
    quote(!isVirtualExt(exti))
  }
  else expression()
  if (directOnly) 
    C <- addCond(quote(length(exti@by) == 0), C)
  if (simpleOnly) 
    C <- addCond(quote(exti@simple), C)
  if (length(C)) {
    F <- function(exti) {
    }
    body(F) <- C
    (if (namesOnly) 
      names(ext)
      else ext)[vapply(ext, F, NA, USE.NAMES = FALSE)]
  }
  else if (namesOnly) 
    names(ext)
  else ext
}, function (ext, dropVirtual = FALSE, namesOnly = TRUE, directOnly = TRUE, simpleOnly = directOnly) 
{
  addCond <- function(xpr, prev) if (length(prev)) 
    substitute(P && N, list(P = prev, N = xpr))
  else xpr
  C <- if (dropVirtual) {
    isVirtualExt <- function(x) getClassDef(x@superClass, package = packageSlot(x))@virtual
    quote(!isVirtualExt(exti))
  }
  else expression()
  if (directOnly) 
    C <- addCond(quote(length(exti@by) == 0), C)
  if (simpleOnly) 
    C <- addCond(quote(exti@simple), C)
  if (length(C)) {
    F <- function(exti) {
    }
    body(F) <- C
    (if (namesOnly) 
      names(ext)
      else ext)[vapply(ext, F, NA, USE.NAMES = FALSE)]
  }
  else if (namesOnly) 
    names(ext)
  else ext
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.ShortPrimitiveSkeletons
list(`package:methods` = list(f(x, i), fgets(x, i, value = value)), list(f(x, i), fgets(x, i, value = value)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.slotNames
list(`package:methods` = function (x) 
{
  classDef <- getClassDef(if (!isS4(x) && is.character(x) && length(x) == 1) 
    x
    else class(x))
  if (is.null(classDef)) 
    character()
  else names(classDef@slots)
}, function (x) 
{
  classDef <- getClassDef(if (!isS4(x) && is.character(x) && length(x) == 1) 
    x
    else class(x))
  if (is.null(classDef)) 
    character()
  else names(classDef@slots)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.TraceWithMethods
list(`package:methods` = function (what, tracer = NULL, exit = NULL, at = numeric(), print = TRUE, signature = NULL, where = .GlobalEnv, edit = FALSE, from = NULL, untrace = FALSE, classMethod = FALSE) 
{
  fromPackage <- if (is.function(where)) {
    where <- if (is(where, "genericFunction")) 
      parent.env(environment(where))
    else environment(where)
    getPackageName(where)
  }
  else ""
  doEdit <- !isFALSE(edit)
  whereF <- NULL
  pname <- character()
  def <- NULL
  tracingWhere <- "in package"
  refCase <- isS4(where) && (is(where, "envRefClass") || is(where, "refClassRepresentation"))
  if (refCase) {
    if (!is.null(signature)) 
      stop("argument 'signature' is not meaningful for tracing reference methods")
    .where <- where
    if (is(.where, "refGeneratorSlot") && !classMethod) 
      .where <- .where$def
    if (is(.where, "refClassRepresentation")) {
      pname <- .where@className
      .where <- .where@refMethods
      tracingWhere <- "for class"
    }
    else {
      tracingWhere <- "for object from class"
      pname <- class(.where)
    }
    def <- eval(substitute(.dollarForEnvRefClass(.where, what)))
    if (!is(def, "refMethodDef")) {
      thisName <- substitute(what)
      stop(gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)), dQuote(class(where))), domain = NA)
    }
    what <- def@name
    whereF <- .where
  }
  else if (is.function(what)) {
    def <- what
    if (is(def, "genericFunction")) {
      what <- def@generic
      whereF <- .genEnv(what, where)
      pname <- def@package
    }
    else {
      fname <- substitute(what)
      if (is.name(fname)) {
        what <- as.character(fname)
        temp <- .findFunEnvAndName(what, where)
        whereF <- temp$whereF
        pname <- temp$pname
      }
      else if (is.call(fname) && identical(fname[[1]], as.name("::"))) {
        whereF <- as.character(fname[[2]])
        require(whereF, character.only = TRUE)
        whereF <- as.environment(paste0("package:", whereF))
        pname <- fname[[2]]
        what <- as.character(fname[[3]])
      }
      else if (is.call(fname) && identical(fname[[1]], as.name(":::"))) {
        pname <- paste(fname[[2]], "(not-exported)")
        whereF <- loadNamespace(as.character(fname[[2]]))
        what <- as.character(fname[[3]])
      }
      else stop("argument 'what' should be the name of a function")
    }
  }
  else {
    what <- as(what, "character")
    if (length(what) != 1) {
      for (f in what) {
        if (nargs() == 1) 
          trace(f)
        else Recall(f, tracer, exit, at, print, signature, where, edit, from, untrace)
      }
      return(what)
    }
    temp <- .findFunEnvAndName(what, where, signature)
    whereF <- temp$whereF
    pname <- temp$pname
    fname <- what
  }
  if (what %in% .InvalidTracedFunctions) 
    stop(gettextf("tracing the internal function %s is not allowed", sQuote(what)), domain = NA)
  if (.traceTraceState) {
    message(".TraceWithMethods: after computing what, whereF", domain = NA)
    browser()
  }
  if (nargs() == 1) 
    return(if (untrace) .primUntrace(what) else .primTrace(what))
  if (is.null(whereF)) {
    allWhere <- findFunction(what, where = where)
    if (length(allWhere) == 0) 
      stop(gettextf("no function definition for %s found", sQuote(what)), domain = NA)
    whereF <- as.environment(allWhere[[1]])
  }
  if (is.null(tracer) && is.null(exit) && isFALSE(edit)) 
    tracer <- quote({
    })
  if (is.null(def)) 
    def <- getFunction(what, where = whereF)
  if (is(def, "traceable") && isFALSE(edit) && !untrace) 
    def <- .untracedFunction(def)
  if (!is.null(signature)) {
    fdef <- if (!is(def, "genericFunction")) 
      getGeneric(as.character(fname), TRUE, where)
    else def
    def <- selectMethod(what, signature, fdef = fdef, optional = TRUE)
    if (isRematched(def)) {
      expr <- substitute(trace(.local, tracer = tr, at = at, exit = ex, print = pr, edit = ed, where = sys.frame(sys.nframe())), list(tr = substitute(tracer), ex = exit, at = at, pr = print, ed = edit))
      at <- 3
      tracer <- expr
      print <- FALSE
    }
    if (is.null(def)) {
      warning(gettextf("cannot untrace method for %s; no method defined for this signature: %s", sQuote(what), paste(signature, collapse = ", ")), domain = NA)
      return(def)
    }
    signature <- def@target
  }
  if (untrace) {
    if (.traceTraceState) {
      message(".TraceWithMethods: untrace case", domain = NA)
      browser()
    }
    if (is.null(signature)) {
      if (is(def, "traceable")) {
        newFun <- .untracedFunction(def)
      }
      else {
        .primUntrace(what)
        return(what)
      }
    }
    else {
      if (is(def, "traceable")) 
        newFun <- .untracedFunction(def)
      else {
        warning(gettextf("the method for %s for this signature was not being traced", sQuote(what)), domain = NA)
        return(what)
      }
    }
  }
  else {
    if (!is.null(exit)) {
      if (is.function(exit)) {
        tname <- substitute(exit)
        if (is.name(tname)) 
          exit <- tname
        exit <- substitute(TRACE(), list(TRACE = exit))
      }
    }
    if (!is.null(tracer)) {
      if (is.function(tracer)) {
        tname <- substitute(tracer)
        if (is.name(tname)) 
          tracer <- tname
        tracer <- substitute(TRACE(), list(TRACE = tracer))
      }
    }
    original <- .untracedFunction(def)
    traceClass <- .traceClassName(class(original))
    if (is.null(getClassDef(traceClass))) 
      traceClass <- .makeTraceClass(traceClass, class(original))
    if (doEdit && is.environment(edit)) {
      def <- .findNewDefForTrace(what, signature, edit, fromPackage)
      environment(def) <- environment(original)
      if (is.null(c(tracer, exit))) {
        newFun <- new(traceClass, original)
        newFun@.Data <- def
      }
      else {
        newFun <- new(traceClass, def = def, tracer = tracer, exit = exit, at = at, print = print, doEdit = FALSE)
        newFun@original <- original
      }
      newFun@source <- edit
    }
    else newFun <- new(traceClass, def = if (doEdit) 
      def
      else original, tracer = tracer, exit = exit, at = at, print = print, doEdit = edit)
  }
  global <- identical(whereF, .GlobalEnv)
  if (.traceTraceState) {
    message(".TraceWithMethods: about to assign or setMethod", domain = NA)
    browser()
  }
  if (is.null(signature)) {
    if (bindingIsLocked(what, whereF)) 
      .assignOverBinding(what, newFun, whereF, global)
    else assign(what, newFun, whereF)
    if (length(pname) != 0) {
      spname <- sub("^namespace:", "", pname)
      ipkgs <- tryCatch(getNamespaceUsers(spname), error = function(e) {
        c()
      })
      for (importingPkg in ipkgs) {
        .updateInImportsEnv(what, newFun, importingPkg)
      }
    }
    if (length(grep("[^.]+[.][^.]+", what)) > 0) {
      S3MTableName <- ".__S3MethodsTable__."
      if (!is.null(tbl <- get0(S3MTableName, envir = whereF, inherits = FALSE))) {
        if (exists(what, envir = tbl, inherits = FALSE)) {
          tracedFun <- get(what, envir = whereF, inherits = TRUE)
          assign(what, tracedFun, envir = tbl)
        }
      }
    }
  }
  else {
    if (untrace && is(newFun, "MethodDefinition") && !identical(newFun@target, newFun@defined)) 
      newFun <- NULL
    setMethod(fdef, signature, newFun, where = new.env())
  }
  if (!global) {
    action <- if (untrace) 
      "Untracing"
    else "Tracing"
    nameSpaceCase <- FALSE
    location <- if (.identC(fromPackage, "")) {
      if (length(pname) == 0 && !is.null(whereF)) 
        pname <- getPackageName(whereF)
      nameSpaceCase <- isNamespace(whereF) && !is.na(match(pname, loadedNamespaces())) && identical(whereF, getNamespace(pname))
      if (length(pname) == 0) 
        ""
      else {
        if (nameSpaceCase) 
          paste0(" in environment <namespace:", pname, ">")
        else paste0(" ", tracingWhere, " \"", pname, "\"")
      }
    }
    else paste0(" as seen from package \"", fromPackage, "\"")
    object <- if (refCase) 
      "reference method"
    else if (is.null(signature)) 
      "function"
    else "specified method for function"
    object <- paste0(" ", object, " \"", what, "\" ")
    .message(action, object, location)
    if (nameSpaceCase && !untrace && is.null(signature) && exists(what, envir = .GlobalEnv)) {
      untcall <- paste0("untrace(\"", what, "\", where = getNamespace(\"", pname, "\"))")
      .message("Warning: Tracing only in the namespace; to untrace you will need:\n    ", untcall, "\n")
    }
  }
  what
}, function (what, tracer = NULL, exit = NULL, at = numeric(), print = TRUE, signature = NULL, where = .GlobalEnv, edit = FALSE, from = NULL, untrace = FALSE, classMethod = FALSE) 
{
  fromPackage <- if (is.function(where)) {
    where <- if (is(where, "genericFunction")) 
      parent.env(environment(where))
    else environment(where)
    getPackageName(where)
  }
  else ""
  doEdit <- !isFALSE(edit)
  whereF <- NULL
  pname <- character()
  def <- NULL
  tracingWhere <- "in package"
  refCase <- isS4(where) && (is(where, "envRefClass") || is(where, "refClassRepresentation"))
  if (refCase) {
    if (!is.null(signature)) 
      stop("argument 'signature' is not meaningful for tracing reference methods")
    .where <- where
    if (is(.where, "refGeneratorSlot") && !classMethod) 
      .where <- .where$def
    if (is(.where, "refClassRepresentation")) {
      pname <- .where@className
      .where <- .where@refMethods
      tracingWhere <- "for class"
    }
    else {
      tracingWhere <- "for object from class"
      pname <- class(.where)
    }
    def <- eval(substitute(.dollarForEnvRefClass(.where, what)))
    if (!is(def, "refMethodDef")) {
      thisName <- substitute(what)
      stop(gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)), dQuote(class(where))), domain = NA)
    }
    what <- def@name
    whereF <- .where
  }
  else if (is.function(what)) {
    def <- what
    if (is(def, "genericFunction")) {
      what <- def@generic
      whereF <- .genEnv(what, where)
      pname <- def@package
    }
    else {
      fname <- substitute(what)
      if (is.name(fname)) {
        what <- as.character(fname)
        temp <- .findFunEnvAndName(what, where)
        whereF <- temp$whereF
        pname <- temp$pname
      }
      else if (is.call(fname) && identical(fname[[1]], as.name("::"))) {
        whereF <- as.character(fname[[2]])
        require(whereF, character.only = TRUE)
        whereF <- as.environment(paste0("package:", whereF))
        pname <- fname[[2]]
        what <- as.character(fname[[3]])
      }
      else if (is.call(fname) && identical(fname[[1]], as.name(":::"))) {
        pname <- paste(fname[[2]], "(not-exported)")
        whereF <- loadNamespace(as.character(fname[[2]]))
        what <- as.character(fname[[3]])
      }
      else stop("argument 'what' should be the name of a function")
    }
  }
  else {
    what <- as(what, "character")
    if (length(what) != 1) {
      for (f in what) {
        if (nargs() == 1) 
          trace(f)
        else Recall(f, tracer, exit, at, print, signature, where, edit, from, untrace)
      }
      return(what)
    }
    temp <- .findFunEnvAndName(what, where, signature)
    whereF <- temp$whereF
    pname <- temp$pname
    fname <- what
  }
  if (what %in% .InvalidTracedFunctions) 
    stop(gettextf("tracing the internal function %s is not allowed", sQuote(what)), domain = NA)
  if (.traceTraceState) {
    message(".TraceWithMethods: after computing what, whereF", domain = NA)
    browser()
  }
  if (nargs() == 1) 
    return(if (untrace) .primUntrace(what) else .primTrace(what))
  if (is.null(whereF)) {
    allWhere <- findFunction(what, where = where)
    if (length(allWhere) == 0) 
      stop(gettextf("no function definition for %s found", sQuote(what)), domain = NA)
    whereF <- as.environment(allWhere[[1]])
  }
  if (is.null(tracer) && is.null(exit) && isFALSE(edit)) 
    tracer <- quote({
    })
  if (is.null(def)) 
    def <- getFunction(what, where = whereF)
  if (is(def, "traceable") && isFALSE(edit) && !untrace) 
    def <- .untracedFunction(def)
  if (!is.null(signature)) {
    fdef <- if (!is(def, "genericFunction")) 
      getGeneric(as.character(fname), TRUE, where)
    else def
    def <- selectMethod(what, signature, fdef = fdef, optional = TRUE)
    if (isRematched(def)) {
      expr <- substitute(trace(.local, tracer = tr, at = at, exit = ex, print = pr, edit = ed, where = sys.frame(sys.nframe())), list(tr = substitute(tracer), ex = exit, at = at, pr = print, ed = edit))
      at <- 3
      tracer <- expr
      print <- FALSE
    }
    if (is.null(def)) {
      warning(gettextf("cannot untrace method for %s; no method defined for this signature: %s", sQuote(what), paste(signature, collapse = ", ")), domain = NA)
      return(def)
    }
    signature <- def@target
  }
  if (untrace) {
    if (.traceTraceState) {
      message(".TraceWithMethods: untrace case", domain = NA)
      browser()
    }
    if (is.null(signature)) {
      if (is(def, "traceable")) {
        newFun <- .untracedFunction(def)
      }
      else {
        .primUntrace(what)
        return(what)
      }
    }
    else {
      if (is(def, "traceable")) 
        newFun <- .untracedFunction(def)
      else {
        warning(gettextf("the method for %s for this signature was not being traced", sQuote(what)), domain = NA)
        return(what)
      }
    }
  }
  else {
    if (!is.null(exit)) {
      if (is.function(exit)) {
        tname <- substitute(exit)
        if (is.name(tname)) 
          exit <- tname
        exit <- substitute(TRACE(), list(TRACE = exit))
      }
    }
    if (!is.null(tracer)) {
      if (is.function(tracer)) {
        tname <- substitute(tracer)
        if (is.name(tname)) 
          tracer <- tname
        tracer <- substitute(TRACE(), list(TRACE = tracer))
      }
    }
    original <- .untracedFunction(def)
    traceClass <- .traceClassName(class(original))
    if (is.null(getClassDef(traceClass))) 
      traceClass <- .makeTraceClass(traceClass, class(original))
    if (doEdit && is.environment(edit)) {
      def <- .findNewDefForTrace(what, signature, edit, fromPackage)
      environment(def) <- environment(original)
      if (is.null(c(tracer, exit))) {
        newFun <- new(traceClass, original)
        newFun@.Data <- def
      }
      else {
        newFun <- new(traceClass, def = def, tracer = tracer, exit = exit, at = at, print = print, doEdit = FALSE)
        newFun@original <- original
      }
      newFun@source <- edit
    }
    else newFun <- new(traceClass, def = if (doEdit) 
      def
      else original, tracer = tracer, exit = exit, at = at, print = print, doEdit = edit)
  }
  global <- identical(whereF, .GlobalEnv)
  if (.traceTraceState) {
    message(".TraceWithMethods: about to assign or setMethod", domain = NA)
    browser()
  }
  if (is.null(signature)) {
    if (bindingIsLocked(what, whereF)) 
      .assignOverBinding(what, newFun, whereF, global)
    else assign(what, newFun, whereF)
    if (length(pname) != 0) {
      spname <- sub("^namespace:", "", pname)
      ipkgs <- tryCatch(getNamespaceUsers(spname), error = function(e) {
        c()
      })
      for (importingPkg in ipkgs) {
        .updateInImportsEnv(what, newFun, importingPkg)
      }
    }
    if (length(grep("[^.]+[.][^.]+", what)) > 0) {
      S3MTableName <- ".__S3MethodsTable__."
      if (!is.null(tbl <- get0(S3MTableName, envir = whereF, inherits = FALSE))) {
        if (exists(what, envir = tbl, inherits = FALSE)) {
          tracedFun <- get(what, envir = whereF, inherits = TRUE)
          assign(what, tracedFun, envir = tbl)
        }
      }
    }
  }
  else {
    if (untrace && is(newFun, "MethodDefinition") && !identical(newFun@target, newFun@defined)) 
      newFun <- NULL
    setMethod(fdef, signature, newFun, where = new.env())
  }
  if (!global) {
    action <- if (untrace) 
      "Untracing"
    else "Tracing"
    nameSpaceCase <- FALSE
    location <- if (.identC(fromPackage, "")) {
      if (length(pname) == 0 && !is.null(whereF)) 
        pname <- getPackageName(whereF)
      nameSpaceCase <- isNamespace(whereF) && !is.na(match(pname, loadedNamespaces())) && identical(whereF, getNamespace(pname))
      if (length(pname) == 0) 
        ""
      else {
        if (nameSpaceCase) 
          paste0(" in environment <namespace:", pname, ">")
        else paste0(" ", tracingWhere, " \"", pname, "\"")
      }
    }
    else paste0(" as seen from package \"", fromPackage, "\"")
    object <- if (refCase) 
      "reference method"
    else if (is.null(signature)) 
      "function"
    else "specified method for function"
    object <- paste0(" ", object, " \"", what, "\" ")
    .message(action, object, location)
    if (nameSpaceCase && !untrace && is.null(signature) && exists(what, envir = .GlobalEnv)) {
      untcall <- paste0("untrace(\"", what, "\", where = getNamespace(\"", pname, "\"))")
      .message("Warning: Tracing only in the namespace; to untrace you will need:\n    ", untcall, "\n")
    }
  }
  what
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.undebugMethod
list(`package:methods` = function (fun, signature) 
{
  if (!isdebugged(fun, signature)) {
    warning("method is not being debugged")
  }
  else {
    if (is.primitive(fun)) 
      fun <- getGeneric(fun)
    untrace(fun, signature = signature)
  }
}, function (fun, signature) 
{
  if (!isdebugged(fun, signature)) {
    warning("method is not being debugged")
  }
  else {
    if (is.primitive(fun)) 
      fun <- getGeneric(fun)
    untrace(fun, signature = signature)
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.untracedFunction
list(`package:methods` = function (f) 
{
  while (is(f, "traceable")) f <- f@original
  f
}, function (f) 
{
  while (is(f, "traceable")) f <- f@original
  f
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
.valueClassTest
list(`package:methods` = function (object, classes, fname) 
{
  if (length(classes)) {
    for (Cl in classes) if (is(object, Cl)) 
      return(object)
    stop(gettextf("invalid value from generic function %s, class %s, expected %s", sQuote(fname), dQuote(class(object)), paste(dQuote(classes), collapse = " or ")), domain = NA)
  }
  object
}, function (object, classes, fname) 
{
  if (length(classes)) {
    for (Cl in classes) if (is(object, Cl)) 
      return(object)
    stop(gettextf("invalid value from generic function %s, class %s, expected %s", sQuote(fname), dQuote(class(object)), paste(dQuote(classes), collapse = " or ")), domain = NA)
  }
  object
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
addNextMethod
list(`package:methods` = new("standardGeneric", .Data = function (method, f = "<unknown>", mlist, optional = FALSE, envir) 
  standardGeneric("addNextMethod"), generic = "addNextMethod", package = "methods", group = list(), valueClass = character(0), signature = c("method", "f", "mlist", "optional", "envir"), default = NULL, skeleton = (function (method, f = "<unknown>", mlist, optional = FALSE, envir) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "addNextMethod"), domain = NA))(method, f, mlist, optional, envir)), new("standardGeneric", .Data = function (method, f = "<unknown>", mlist, optional = FALSE, envir) 
      standardGeneric("addNextMethod"), generic = "addNextMethod", package = "methods", group = list(), valueClass = character(0), signature = c("method", "f", "mlist", "optional", "envir"), default = NULL, skeleton = (function (method, f = "<unknown>", mlist, optional = FALSE, envir) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "addNextMethod"), domain = NA))(method, f, mlist, optional, envir)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
allNames
list(`package:methods` = function (x) 
{
  value <- names(x)
  if (is.null(value)) 
    character(length(x))
  else value
}, function (x) 
{
  value <- names(x)
  if (is.null(value)) 
    character(length(x))
  else value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Arith
list(`package:lubridate` = new("groupGenericFunction", .Data = function (e1, e2) 
  standardGeneric("Arith"), groupMembers = list("+", "-", "*", "^", "%%", "%/%", "/"), generic = "Arith", package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Arith"), domain = NA))(e1, e2)), `package:methods` = new("groupGenericFunction", .Data = function (e1, e2) 
      standardGeneric("Arith"), groupMembers = list("+", "-", "*", "^", "%%", "%/%", "/"), generic = "Arith", package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Arith"), domain = NA))(e1, e2)), new("groupGenericFunction", .Data = function (e1, e2) 
          standardGeneric("Arith"), groupMembers = list("+", "-", "*", "^", "%%", "%/%", "/"), generic = "Arith", package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
            stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Arith"), domain = NA))(e1, e2)))
c("package:lubridate", "package:methods", "namespace:methods")
c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, TRUE)
as
list(`package:methods` = function (object, Class, strict = TRUE, ext = possibleExtends(thisClass, Class)) 
{
  thisClass <- .class1(object)
  if (.identC(thisClass, Class) || .identC(Class, "ANY")) 
    return(object)
  where <- .classEnv(thisClass, mustFind = FALSE)
  coerceFun <- getGeneric("coerce", where = where)
  coerceMethods <- .getMethodsTable(coerceFun, environment(coerceFun), inherited = TRUE)
  asMethod <- .quickCoerceSelect(thisClass, Class, coerceFun, coerceMethods, where)
  if (is.null(asMethod)) {
    sig <- c(from = thisClass, to = Class)
    asMethod <- selectMethod("coerce", sig, optional = TRUE, useInherited = FALSE, fdef = coerceFun, mlist = getMethodsForDispatch(coerceFun))
    if (is.null(asMethod)) {
      canCache <- TRUE
      inherited <- FALSE
      if (is(object, Class)) {
        ClassDef <- getClassDef(Class, where)
        if (isFALSE(ext)) 
          stop(sprintf("internal problem in as(): %s is(object, \"%s\") is TRUE, but the metadata asserts that the 'is' relation is FALSE", dQuote(thisClass), Class), domain = NA)
        else if (isTRUE(ext)) 
          asMethod <- .makeAsMethod(quote(from), TRUE, Class, ClassDef, where)
        else {
          test <- ext@test
          asMethod <- .makeAsMethod(ext@coerce, ext@simple, Class, ClassDef, where)
          canCache <- (!is.function(test)) || isTRUE(body(test))
        }
      }
      if (is.null(asMethod) && extends(Class, thisClass)) {
        ClassDef <- getClassDef(Class, where)
        asMethod <- .asFromReplace(thisClass, Class, ClassDef, where)
      }
      if (is.null(asMethod)) {
        asMethod <- selectMethod("coerce", sig, optional = TRUE, c(from = TRUE, to = FALSE), fdef = coerceFun, mlist = coerceMethods)
        inherited <- TRUE
      }
      else if (canCache) 
        asMethod <- .asCoerceMethod(asMethod, thisClass, ClassDef, FALSE, where)
      if (is.null(asMethod)) 
        stop(gettextf("no method or default for coercing %s to %s", dQuote(thisClass), dQuote(Class)), domain = NA)
      else if (canCache) {
        cacheMethod("coerce", sig, asMethod, fdef = coerceFun, inherited = inherited)
      }
    }
  }
  if (strict) 
    asMethod(object)
  else asMethod(object, strict = FALSE)
}, function (object, Class, strict = TRUE, ext = possibleExtends(thisClass, Class)) 
{
  thisClass <- .class1(object)
  if (.identC(thisClass, Class) || .identC(Class, "ANY")) 
    return(object)
  where <- .classEnv(thisClass, mustFind = FALSE)
  coerceFun <- getGeneric("coerce", where = where)
  coerceMethods <- .getMethodsTable(coerceFun, environment(coerceFun), inherited = TRUE)
  asMethod <- .quickCoerceSelect(thisClass, Class, coerceFun, coerceMethods, where)
  if (is.null(asMethod)) {
    sig <- c(from = thisClass, to = Class)
    asMethod <- selectMethod("coerce", sig, optional = TRUE, useInherited = FALSE, fdef = coerceFun, mlist = getMethodsForDispatch(coerceFun))
    if (is.null(asMethod)) {
      canCache <- TRUE
      inherited <- FALSE
      if (is(object, Class)) {
        ClassDef <- getClassDef(Class, where)
        if (isFALSE(ext)) 
          stop(sprintf("internal problem in as(): %s is(object, \"%s\") is TRUE, but the metadata asserts that the 'is' relation is FALSE", dQuote(thisClass), Class), domain = NA)
        else if (isTRUE(ext)) 
          asMethod <- .makeAsMethod(quote(from), TRUE, Class, ClassDef, where)
        else {
          test <- ext@test
          asMethod <- .makeAsMethod(ext@coerce, ext@simple, Class, ClassDef, where)
          canCache <- (!is.function(test)) || isTRUE(body(test))
        }
      }
      if (is.null(asMethod) && extends(Class, thisClass)) {
        ClassDef <- getClassDef(Class, where)
        asMethod <- .asFromReplace(thisClass, Class, ClassDef, where)
      }
      if (is.null(asMethod)) {
        asMethod <- selectMethod("coerce", sig, optional = TRUE, c(from = TRUE, to = FALSE), fdef = coerceFun, mlist = coerceMethods)
        inherited <- TRUE
      }
      else if (canCache) 
        asMethod <- .asCoerceMethod(asMethod, thisClass, ClassDef, FALSE, where)
      if (is.null(asMethod)) 
        stop(gettextf("no method or default for coercing %s to %s", dQuote(thisClass), dQuote(Class)), domain = NA)
      else if (canCache) {
        cacheMethod("coerce", sig, asMethod, fdef = coerceFun, inherited = inherited)
      }
    }
  }
  if (strict) 
    asMethod(object)
  else asMethod(object, strict = FALSE)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
as<-
  list(`package:methods` = function (object, Class, value) 
  {
    thisClass <- .class1(object)
    if (!.identC(.class1(value), Class)) 
      value <- as(value, Class, strict = FALSE)
    where <- .classEnv(class(object))
    coerceFun <- getGeneric("coerce<-", where = where)
    coerceMethods <- getMethodsForDispatch(coerceFun)
    asMethod <- .quickCoerceSelect(thisClass, Class, coerceFun, coerceMethods, where)
    if (is.null(asMethod)) {
      sig <- c(from = thisClass, to = Class)
      canCache <- TRUE
      inherited <- FALSE
      asMethod <- selectMethod("coerce<-", sig, TRUE, FALSE, fdef = coerceFun, mlist = coerceMethods)
      if (is.null(asMethod)) {
        if (is(object, Class)) {
          asMethod <- possibleExtends(thisClass, Class)
          if (isTRUE(asMethod)) {
            class(value) <- class(object)
            return(value)
          }
          else {
            test <- asMethod@test
            asMethod <- asMethod@replace
            canCache <- (!is.function(test)) || isTRUE(body(test))
            if (canCache) {
              ClassDef <- getClassDef(Class, where)
              asMethod <- .asCoerceMethod(asMethod, thisClass, ClassDef, TRUE, where)
            }
          }
        }
        else {
          asMethod <- selectMethod("coerce<-", sig, TRUE, c(from = TRUE, to = FALSE), doCache = TRUE)
          inherited <- TRUE
        }
      }
      if (canCache && !is.null(asMethod)) 
        cacheMethod("coerce<-", sig, asMethod, fdef = coerceFun, inherited = inherited)
    }
    if (is.null(asMethod)) 
      stop(gettextf("no method or default for as() replacement of %s with Class=\"%s\"", dQuote(thisClass), Class), domain = NA)
    asMethod(object, Class, value)
  }, function (object, Class, value) 
  {
    thisClass <- .class1(object)
    if (!.identC(.class1(value), Class)) 
      value <- as(value, Class, strict = FALSE)
    where <- .classEnv(class(object))
    coerceFun <- getGeneric("coerce<-", where = where)
    coerceMethods <- getMethodsForDispatch(coerceFun)
    asMethod <- .quickCoerceSelect(thisClass, Class, coerceFun, coerceMethods, where)
    if (is.null(asMethod)) {
      sig <- c(from = thisClass, to = Class)
      canCache <- TRUE
      inherited <- FALSE
      asMethod <- selectMethod("coerce<-", sig, TRUE, FALSE, fdef = coerceFun, mlist = coerceMethods)
      if (is.null(asMethod)) {
        if (is(object, Class)) {
          asMethod <- possibleExtends(thisClass, Class)
          if (isTRUE(asMethod)) {
            class(value) <- class(object)
            return(value)
          }
          else {
            test <- asMethod@test
            asMethod <- asMethod@replace
            canCache <- (!is.function(test)) || isTRUE(body(test))
            if (canCache) {
              ClassDef <- getClassDef(Class, where)
              asMethod <- .asCoerceMethod(asMethod, thisClass, ClassDef, TRUE, where)
            }
          }
        }
        else {
          asMethod <- selectMethod("coerce<-", sig, TRUE, c(from = TRUE, to = FALSE), doCache = TRUE)
          inherited <- TRUE
        }
      }
      if (canCache && !is.null(asMethod)) 
        cacheMethod("coerce<-", sig, asMethod, fdef = coerceFun, inherited = inherited)
    }
    if (is.null(asMethod)) 
      stop(gettextf("no method or default for as() replacement of %s with Class=\"%s\"", dQuote(thisClass), Class), domain = NA)
    asMethod(object, Class, value)
  })
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
asMethodDefinition
list(`package:methods` = function (def, signature = list(.anyClassName), sealed = FALSE, fdef = def) 
{
  switch(typeof(def), builtin = , special = , `NULL` = return(def), closure = {
  }, stop(gettextf("invalid object for formal method definition: type %s", dQuote(typeof(def))), domain = NA))
  if (is(def, "MethodDefinition")) {
    value <- def
    if (missing(signature)) 
      signature <- value@defined
  }
  else value <- new("MethodDefinition", def)
  if (sealed) 
    value <- new("SealedMethodDefinition", value)
  if (is(signature, "signature")) 
    classes <- signature
  else classes <- .MakeSignature(new("signature"), def, signature, fdef)
  value@target <- classes
  value@defined <- classes
  value
}, function (def, signature = list(.anyClassName), sealed = FALSE, fdef = def) 
{
  switch(typeof(def), builtin = , special = , `NULL` = return(def), closure = {
  }, stop(gettextf("invalid object for formal method definition: type %s", dQuote(typeof(def))), domain = NA))
  if (is(def, "MethodDefinition")) {
    value <- def
    if (missing(signature)) 
      signature <- value@defined
  }
  else value <- new("MethodDefinition", def)
  if (sealed) 
    value <- new("SealedMethodDefinition", value)
  if (is(signature, "signature")) 
    classes <- signature
  else classes <- .MakeSignature(new("signature"), def, signature, fdef)
  value@target <- classes
  value@defined <- classes
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
assignClassDef
list(`package:methods` = function (Class, def, where = .GlobalEnv, force = FALSE, doSubclasses = is(def, "ClassUnionRepresentation")) 
{
  if (!is(def, "classRepresentation")) 
    stop(gettextf("trying to assign an object of class %s as the definition of class %s: must supply a \"classRepresentation\" object", dQuote(class(def)), dQuote(Class)), domain = NA)
  clName <- def@className
  attributes(clName) <- NULL
  if (!.identC(Class, clName)) 
    stop(gettextf("assigning as %s a class representation with internal name %s", dQuote(Class), dQuote(def@className)), domain = NA)
  where <- as.environment(where)
  mname <- classMetaName(Class)
  if (exists(mname, envir = where, inherits = FALSE) && bindingIsLocked(mname, where)) {
    if (force) 
      .assignOverBinding(mname, def, where, FALSE)
    else stop(gettextf("class %s has a locked definition in package %s", dQuote(Class), sQuote(getPackageName(where))))
  }
  else assign(mname, def, where)
  if (cacheOnAssign(where)) 
    .cacheClass(clName, def, doSubclasses, where)
}, function (Class, def, where = .GlobalEnv, force = FALSE, doSubclasses = is(def, "ClassUnionRepresentation")) 
{
  if (!is(def, "classRepresentation")) 
    stop(gettextf("trying to assign an object of class %s as the definition of class %s: must supply a \"classRepresentation\" object", dQuote(class(def)), dQuote(Class)), domain = NA)
  clName <- def@className
  attributes(clName) <- NULL
  if (!.identC(Class, clName)) 
    stop(gettextf("assigning as %s a class representation with internal name %s", dQuote(Class), dQuote(def@className)), domain = NA)
  where <- as.environment(where)
  mname <- classMetaName(Class)
  if (exists(mname, envir = where, inherits = FALSE) && bindingIsLocked(mname, where)) {
    if (force) 
      .assignOverBinding(mname, def, where, FALSE)
    else stop(gettextf("class %s has a locked definition in package %s", dQuote(Class), sQuote(getPackageName(where))))
  }
  else assign(mname, def, where)
  if (cacheOnAssign(where)) 
    .cacheClass(clName, def, doSubclasses, where)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
assignMethodsMetaData
list(`package:methods` = function (f, value, fdef, where) 
{
  where <- as.environment(where)
  if (is(value, "MethodsList")) {
    .MlistDeprecated()
    mname <- methodsPackageMetaName("M", fdef@generic, fdef@package)
    if (exists(mname, envir = where, inherits = FALSE) && bindingIsLocked(mname, where)) {
    }
    else assign(mname, value, where)
  }
  if (dispatchIsInternal(fdef)) 
    setPrimitiveMethods(f, fdef@default, "reset", fdef, NULL)
  if (is(fdef, "groupGenericFunction")) 
    cacheGenericsMetaData(f, fdef, where = where, package = fdef@package)
}, function (f, value, fdef, where) 
{
  where <- as.environment(where)
  if (is(value, "MethodsList")) {
    .MlistDeprecated()
    mname <- methodsPackageMetaName("M", fdef@generic, fdef@package)
    if (exists(mname, envir = where, inherits = FALSE) && bindingIsLocked(mname, where)) {
    }
    else assign(mname, value, where)
  }
  if (dispatchIsInternal(fdef)) 
    setPrimitiveMethods(f, fdef@default, "reset", fdef, NULL)
  if (is(fdef, "groupGenericFunction")) 
    cacheGenericsMetaData(f, fdef, where = where, package = fdef@package)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
balanceMethodsList
list(`package:methods` = function (mlist, args, check = TRUE) 
{
  .MlistDeprecated("balanceMethodsList()")
  moreArgs <- args[-1]
  if (length(moreArgs) == 0) 
    return(mlist)
  methods <- mlist@methods
  if (check && length(methods)) {
    depth <- 0
    el <- methods[[1]]
    while (is(el, "MethodsList")) {
      mm <- el@methods
      if (length(mm) == 0) 
        break
      depth <- depth + 1
      el <- mm[[1]]
    }
    if (depth >= length(args)) 
      return(mlist)
  }
  for (i in seq_along(methods)) {
    el <- methods[[i]]
    if (is(el, "MethodsList")) 
      el <- Recall(el, moreArgs, FALSE)
    else {
      if (is(el, "MethodDefinition")) {
        el@target[moreArgs] <- "ANY"
        el@defined[moreArgs] <- "ANY"
      }
      for (what in rev(moreArgs)) el <- new("MethodsList", argument = as.name(what), methods = list(ANY = el))
    }
    methods[[i]] <- el
  }
  mlist@methods <- methods
  mlist
}, function (mlist, args, check = TRUE) 
{
  .MlistDeprecated("balanceMethodsList()")
  moreArgs <- args[-1]
  if (length(moreArgs) == 0) 
    return(mlist)
  methods <- mlist@methods
  if (check && length(methods)) {
    depth <- 0
    el <- methods[[1]]
    while (is(el, "MethodsList")) {
      mm <- el@methods
      if (length(mm) == 0) 
        break
      depth <- depth + 1
      el <- mm[[1]]
    }
    if (depth >= length(args)) 
      return(mlist)
  }
  for (i in seq_along(methods)) {
    el <- methods[[i]]
    if (is(el, "MethodsList")) 
      el <- Recall(el, moreArgs, FALSE)
    else {
      if (is(el, "MethodDefinition")) {
        el@target[moreArgs] <- "ANY"
        el@defined[moreArgs] <- "ANY"
      }
      for (what in rev(moreArgs)) el <- new("MethodsList", argument = as.name(what), methods = list(ANY = el))
    }
    methods[[i]] <- el
  }
  mlist@methods <- methods
  mlist
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
body<-
  list(`package:methods` = new("standardGeneric", .Data = function (fun, envir = environment(fun), value) 
    standardGeneric("body<-"), generic = "body<-", package = "base", group = list(), valueClass = character(0), signature = c("fun", "envir", "value"), default = new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      if (is.expression(value)) {
        if (length(value) > 1) 
          warning("using the first element of 'value' of type \"expression\"")
        value <- value[[1]]
      }
      as.function(c(as.list(formals(fun)), list(value)), envir)
    }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "body<-"), skeleton = (new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      if (is.expression(value)) {
        if (length(value) > 1) 
          warning("using the first element of 'value' of type \"expression\"")
        value <- value[[1]]
      }
      as.function(c(as.list(formals(fun)), list(value)), envir)
    }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "body<-"))(fun, envir, value)), `package:base` = function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      if (is.expression(value)) {
        if (length(value) > 1) 
          warning("using the first element of 'value' of type \"expression\"")
        value <- value[[1]]
      }
      as.function(c(as.list(formals(fun)), list(value)), envir)
    }, function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      if (is.expression(value)) {
        if (length(value) > 1) 
          warning("using the first element of 'value' of type \"expression\"")
        value <- value[[1]]
      }
      as.function(c(as.list(formals(fun)), list(value)), envir)
    }, new("standardGeneric", .Data = function (fun, envir = environment(fun), value) 
      standardGeneric("body<-"), generic = "body<-", package = "base", group = list(), valueClass = character(0), signature = c("fun", "envir", "value"), default = new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
      {
        if (!is.function(fun)) 
          warning("'fun' is not a function")
        if (is.expression(value)) {
          if (length(value) > 1) 
            warning("using the first element of 'value' of type \"expression\"")
          value <- value[[1]]
        }
        as.function(c(as.list(formals(fun)), list(value)), envir)
      }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "body<-"), skeleton = (new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
      {
        if (!is.function(fun)) 
          warning("'fun' is not a function")
        if (is.expression(value)) {
          if (length(value) > 1) 
            warning("using the first element of 'value' of type \"expression\"")
          value <- value[[1]]
        }
        as.function(c(as.list(formals(fun)), list(value)), envir)
      }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "body<-"))(fun, envir, value)))
c("package:methods", "package:base", "namespace:base", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
cacheGenericsMetaData
list(`package:methods` = function (f, fdef, attach = TRUE, where = topenv(parent.frame()), package, methods) 
{
  if (!is(fdef, "genericFunction")) {
    warning(gettextf("no methods found for %s; cacheGenericsMetaData() will have no effect", sQuote(f)), domain = NA)
    return(FALSE)
  }
  if (missing(package)) 
    package <- fdef@package
  deflt <- finalDefaultMethod(fdef@default)
  if (dispatchIsInternal(fdef)) {
    if (missing(methods)) 
      setPrimitiveMethods(f, deflt, "reset", fdef, NULL)
    else setPrimitiveMethods(f, deflt, "set", fdef, methods)
  }
  else if (isGroup(f, fdef = fdef)) {
    members <- fdef@groupMembers
    for (ff in members) {
      ffdef <- getGeneric(ff, where = where)
      if (is(ffdef, "genericFunction")) 
        Recall(ff, ffdef, attach, where, methods = .getMethodsTable(ffdef))
    }
  }
  TRUE
}, function (f, fdef, attach = TRUE, where = topenv(parent.frame()), package, methods) 
{
  if (!is(fdef, "genericFunction")) {
    warning(gettextf("no methods found for %s; cacheGenericsMetaData() will have no effect", sQuote(f)), domain = NA)
    return(FALSE)
  }
  if (missing(package)) 
    package <- fdef@package
  deflt <- finalDefaultMethod(fdef@default)
  if (dispatchIsInternal(fdef)) {
    if (missing(methods)) 
      setPrimitiveMethods(f, deflt, "reset", fdef, NULL)
    else setPrimitiveMethods(f, deflt, "set", fdef, methods)
  }
  else if (isGroup(f, fdef = fdef)) {
    members <- fdef@groupMembers
    for (ff in members) {
      ffdef <- getGeneric(ff, where = where)
      if (is(ffdef, "genericFunction")) 
        Recall(ff, ffdef, attach, where, methods = .getMethodsTable(ffdef))
    }
  }
  TRUE
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
cacheMetaData
list(`package:methods` = function (where, attach = TRUE, searchWhere = as.environment(where), doCheck = TRUE) 
{
  pkg <- getPackageName(where)
  classes <- getClasses(where)
  lev <- 0
  if (attach) {
    msg <- Sys.getenv("_R_TRACE_LOADNAMESPACE_", "")
    if (nzchar(msg)) {
      if (pkg %in% c("base", "tools", "utils", "grDevices", "graphics", "stats", "datasets", "methods", "grid", "splines", "stats4", "tcltk", "compiler", "parallel")) 
        lev <- 0
      else {
        lev <- as.integer(msg)
        if (is.na(lev)) 
          lev <- 0
      }
    }
    for (cl in classes) {
      if (lev > 2) 
        message("--- caching class ", sQuote(cl))
      cldef <- get(classMetaName(cl), where)
      if (is(cldef, "classRepresentation")) 
        .cacheClass(cl, cldef, is(cldef, "ClassUnionRepresentation"), where)
      if (lev > 2) 
        message("--- done caching class ", sQuote(cl))
    }
  }
  else {
    for (cl in classes) {
      cldef <- getClassDef(cl, searchWhere)
      if (is(cldef, "classRepresentation") && identical(cldef@package, pkg)) {
        .uncacheClass(cl, cldef)
        .removeSuperclassBackRefs(cl, cldef, searchWhere)
        if (is(cldef, "ClassUnionRepresentation")) {
          subclasses <- names(cldef@subclasses)
          for (subclass in subclasses) .removeSuperClass(subclass, cl)
        }
      }
    }
  }
  generics <- .getGenerics(where)
  packages <- attr(generics, "package")
  if (length(packages) < length(generics)) 
    packages <- rep(packages, length.out = length(generics))
  if (attach && exists(".requireCachedGenerics", where, inherits = FALSE)) {
    others <- get(".requireCachedGenerics", where)
    generics <- c(generics, others)
    packages <- c(packages, attr(others, "package"))
  }
  dups <- duplicated(generics) & duplicated(packages)
  generics <- generics[!dups]
  for (i in seq_along(generics)) {
    f <- generics[[i]]
    fpkg <- packages[[i]]
    .tr <- attach && (lev > 2 || lev == -5)
    if (!identical(fpkg, pkg) && doCheck) {
      if (.tr) 
        message("--- getting generic ", sQuote(f), " (and methods)")
      if (attach) {
        env <- as.environment(where)
        if (exists(f, envir = env, inherits = FALSE)) {
          def <- get(f, envir = env)
          fdef <- .genericOrImplicit(f, fpkg, env)
          if (is.function(def)) {
            if (identical(environment(def), environment(fdef))) 
              next
            else if (is(fdef, "genericFunction")) {
              .assignOverBinding(f, fdef, env, FALSE)
            }
          }
        }
        else fdef <- getGeneric(f, FALSE, searchWhere, fpkg)
      }
      else fdef <- getGeneric(f, FALSE, searchWhere, fpkg)
    }
    else fdef <- getGeneric(f, FALSE, searchWhere, fpkg)
    if (!is(fdef, "genericFunction")) 
      next
    if (attach) {
      .cacheGeneric(f, fdef)
    }
    else .uncacheGeneric(f, fdef)
    methods <- .updateMethodsInTable(fdef, where, attach)
    cacheGenericsMetaData(f, fdef, attach, where, fdef@package, methods)
    if (.tr) 
      message("--- done getting generic ", sQuote(f))
  }
  .doLoadActions(where, attach)
  invisible(NULL)
}, function (where, attach = TRUE, searchWhere = as.environment(where), doCheck = TRUE) 
{
  pkg <- getPackageName(where)
  classes <- getClasses(where)
  lev <- 0
  if (attach) {
    msg <- Sys.getenv("_R_TRACE_LOADNAMESPACE_", "")
    if (nzchar(msg)) {
      if (pkg %in% c("base", "tools", "utils", "grDevices", "graphics", "stats", "datasets", "methods", "grid", "splines", "stats4", "tcltk", "compiler", "parallel")) 
        lev <- 0
      else {
        lev <- as.integer(msg)
        if (is.na(lev)) 
          lev <- 0
      }
    }
    for (cl in classes) {
      if (lev > 2) 
        message("--- caching class ", sQuote(cl))
      cldef <- get(classMetaName(cl), where)
      if (is(cldef, "classRepresentation")) 
        .cacheClass(cl, cldef, is(cldef, "ClassUnionRepresentation"), where)
      if (lev > 2) 
        message("--- done caching class ", sQuote(cl))
    }
  }
  else {
    for (cl in classes) {
      cldef <- getClassDef(cl, searchWhere)
      if (is(cldef, "classRepresentation") && identical(cldef@package, pkg)) {
        .uncacheClass(cl, cldef)
        .removeSuperclassBackRefs(cl, cldef, searchWhere)
        if (is(cldef, "ClassUnionRepresentation")) {
          subclasses <- names(cldef@subclasses)
          for (subclass in subclasses) .removeSuperClass(subclass, cl)
        }
      }
    }
  }
  generics <- .getGenerics(where)
  packages <- attr(generics, "package")
  if (length(packages) < length(generics)) 
    packages <- rep(packages, length.out = length(generics))
  if (attach && exists(".requireCachedGenerics", where, inherits = FALSE)) {
    others <- get(".requireCachedGenerics", where)
    generics <- c(generics, others)
    packages <- c(packages, attr(others, "package"))
  }
  dups <- duplicated(generics) & duplicated(packages)
  generics <- generics[!dups]
  for (i in seq_along(generics)) {
    f <- generics[[i]]
    fpkg <- packages[[i]]
    .tr <- attach && (lev > 2 || lev == -5)
    if (!identical(fpkg, pkg) && doCheck) {
      if (.tr) 
        message("--- getting generic ", sQuote(f), " (and methods)")
      if (attach) {
        env <- as.environment(where)
        if (exists(f, envir = env, inherits = FALSE)) {
          def <- get(f, envir = env)
          fdef <- .genericOrImplicit(f, fpkg, env)
          if (is.function(def)) {
            if (identical(environment(def), environment(fdef))) 
              next
            else if (is(fdef, "genericFunction")) {
              .assignOverBinding(f, fdef, env, FALSE)
            }
          }
        }
        else fdef <- getGeneric(f, FALSE, searchWhere, fpkg)
      }
      else fdef <- getGeneric(f, FALSE, searchWhere, fpkg)
    }
    else fdef <- getGeneric(f, FALSE, searchWhere, fpkg)
    if (!is(fdef, "genericFunction")) 
      next
    if (attach) {
      .cacheGeneric(f, fdef)
    }
    else .uncacheGeneric(f, fdef)
    methods <- .updateMethodsInTable(fdef, where, attach)
    cacheGenericsMetaData(f, fdef, attach, where, fdef@package, methods)
    if (.tr) 
      message("--- done getting generic ", sQuote(f))
  }
  .doLoadActions(where, attach)
  invisible(NULL)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
cacheMethod
list(`package:methods` = function (f, sig, def, args = names(sig), fdef, inherited = FALSE) 
{
  ev <- environment(fdef)
  .cacheMethodInTable(fdef, sig, def, .getMethodsTable(fdef, ev, inherited = inherited))
  if (!inherited) 
    .cacheMethodInTable(fdef, sig, def, .getMethodsTable(fdef, ev, inherited = TRUE))
}, function (f, sig, def, args = names(sig), fdef, inherited = FALSE) 
{
  ev <- environment(fdef)
  .cacheMethodInTable(fdef, sig, def, .getMethodsTable(fdef, ev, inherited = inherited))
  if (!inherited) 
    .cacheMethodInTable(fdef, sig, def, .getMethodsTable(fdef, ev, inherited = TRUE))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
callGeneric
list(`package:methods` = function (...) 
{
  call <- sys.call(sys.parent(1))
  .local <- identical(call[[1]], quote(.local))
  methodCtxInd <- 1 + if (.local) 
    1
  else 0
  callerCtxInd <- methodCtxInd + 1
  methodCall <- sys.call(sys.parent(methodCtxInd))
  if (fromNextMethod(methodCall)) {
    methodCtxInd <- methodCtxInd + 1
  }
  methodFrame <- parent.frame(methodCtxInd)
  genericName <- getGenericFromCall(methodCall, methodFrame)
  if (is.null(genericName)) {
    stop("callGeneric() must be called from within a method body")
  }
  if (nargs() == 0) {
    callerFrame <- sys.frame(sys.parent(callerCtxInd))
    methodDef <- sys.function(sys.parent(1))
    call <- match.call(methodDef, methodCall, expand.dots = FALSE, envir = callerFrame)
    call[-1] <- lapply(names(call[-1]), as.name)
  }
  else {
    call <- sys.call()
  }
  call[[1]] <- as.name(genericName)
  eval(call, parent.frame())
}, function (...) 
{
  call <- sys.call(sys.parent(1))
  .local <- identical(call[[1]], quote(.local))
  methodCtxInd <- 1 + if (.local) 
    1
  else 0
  callerCtxInd <- methodCtxInd + 1
  methodCall <- sys.call(sys.parent(methodCtxInd))
  if (fromNextMethod(methodCall)) {
    methodCtxInd <- methodCtxInd + 1
  }
  methodFrame <- parent.frame(methodCtxInd)
  genericName <- getGenericFromCall(methodCall, methodFrame)
  if (is.null(genericName)) {
    stop("callGeneric() must be called from within a method body")
  }
  if (nargs() == 0) {
    callerFrame <- sys.frame(sys.parent(callerCtxInd))
    methodDef <- sys.function(sys.parent(1))
    call <- match.call(methodDef, methodCall, expand.dots = FALSE, envir = callerFrame)
    call[-1] <- lapply(names(call[-1]), as.name)
  }
  else {
    call <- sys.call()
  }
  call[[1]] <- as.name(genericName)
  eval(call, parent.frame())
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
callNextMethod
list(`package:methods` = function (...) 
{
  method <- nextMethod <- NULL
  dotNextMethod <- as.name(".nextMethod")
  parent <- sys.parent(1)
  methodFun <- maybeMethod <- sys.function(parent)
  if (is(maybeMethod, "MethodDefinition")) {
    callEnv <- methodEnv <- parent.frame(1)
    mcall <- sys.call(parent)
    dotsenv <- parent.frame(2)
    i <- 1
  }
  else {
    callEnv <- parent.frame(1)
    methodEnv <- parent.frame(2)
    mcall <- sys.call(sys.parent(2))
    dotsenv <- parent.frame(3)
    maybeMethod <- sys.function(sys.parent(2))
    i <- 2
  }
  if (!is.null(method <- methodEnv$.Method)) {
    nextMethod <- callEnv$.nextMethod
    f <- methodEnv$.Generic
  }
  else if (identical(mcall[[1]], dotNextMethod)) {
    nextMethodEnv <- parent.frame(i + 1)
    nextMethod <- nextMethodEnv$.nextMethod
    f <- nextMethodEnv$.Generic
  }
  else if (is(maybeMethod, "MethodDefinition")) {
    f <- maybeMethod@generic
    method <- maybeMethod
  }
  else {
    if (is.primitive(mcall[[1]])) {
      f <- .primname(mcall[[1]])
    }
    else {
      f <- as.character(mcall[[1]])
    }
    fdef <- genericForBasic(f)
    if (is.null(fdef)) 
      stop(gettextf("a call to callNextMethod() appears in a call to %s, but the call does not seem to come from either a generic function or another 'callNextMethod'", sQuote(f)), domain = NA)
    f <- fdef@generic
    method <- maybeMethod
  }
  if (is(method, "MethodDefinition")) {
    if (is.null(nextMethod)) {
      if (!is(method, "MethodWithNext")) {
        method <- addNextMethod(method, f, envir = methodEnv)
        cacheMethod(f, method@target, method, fdef = getGeneric(f), inherited = TRUE)
      }
      nextMethod <- method@nextMethod
      assign(".nextMethod", nextMethod, envir = callEnv)
      assign(".Generic", f, envir = callEnv)
    }
  }
  else if (is.null(method)) {
    if (is.null(nextMethod)) 
      stop("call to 'callNextMethod' does not appear to be in a 'method' or 'callNextMethod' context")
    method <- nextMethod
    if (!is(method, "MethodWithNext")) {
      method <- addNextMethod(method, f, envir = methodEnv)
    }
    nextMethod <- method@nextMethod
    assign(".nextMethod", nextMethod, envir = callEnv)
    assign(".Generic", f, envir = callEnv)
    assign(".nextMethod", method, envir = nextMethodEnv)
    assign(".Generic", f, envir = nextMethodEnv)
  }
  else stop(gettextf("bad object found as method (class %s)", dQuote(class(method))), domain = NA)
  if (is.null(nextMethod)) 
    stop("No next method available")
  subsetCase <- !is.na(match(f, .BasicSubsetFunctions))
  if (nargs() > 0) {
    call <- sys.call()
    call[[1]] <- as.name(".nextMethod")
    eval(call, callEnv)
  }
  else {
    if (subsetCase) {
      call <- as.list(mcall)
      if ((f == "[") && length(names(call) > 0)) 
        call <- .doSubNextCall(call, method)
      else {
        fnames <- c("", formalArgs(method))
        i <- match("...", fnames)
        if (is.na(i) || i > length(call)) 
          length(fnames) <- length(call)
        else {
          i <- i - 1
          length(fnames) <- i
          fnames <- c(fnames, rep("", length(call) - i))
        }
        if (endsWith(f, "<-")) 
          fnames[length(fnames)] <- "value"
        names(call) <- fnames
        call <- as.call(call)
      }
    }
    else call <- match.call(methodFun, mcall, expand.dots = FALSE, envir = dotsenv)
    .Call(C_R_nextMethodCall, call, callEnv)
  }
}, function (...) 
{
  method <- nextMethod <- NULL
  dotNextMethod <- as.name(".nextMethod")
  parent <- sys.parent(1)
  methodFun <- maybeMethod <- sys.function(parent)
  if (is(maybeMethod, "MethodDefinition")) {
    callEnv <- methodEnv <- parent.frame(1)
    mcall <- sys.call(parent)
    dotsenv <- parent.frame(2)
    i <- 1
  }
  else {
    callEnv <- parent.frame(1)
    methodEnv <- parent.frame(2)
    mcall <- sys.call(sys.parent(2))
    dotsenv <- parent.frame(3)
    maybeMethod <- sys.function(sys.parent(2))
    i <- 2
  }
  if (!is.null(method <- methodEnv$.Method)) {
    nextMethod <- callEnv$.nextMethod
    f <- methodEnv$.Generic
  }
  else if (identical(mcall[[1]], dotNextMethod)) {
    nextMethodEnv <- parent.frame(i + 1)
    nextMethod <- nextMethodEnv$.nextMethod
    f <- nextMethodEnv$.Generic
  }
  else if (is(maybeMethod, "MethodDefinition")) {
    f <- maybeMethod@generic
    method <- maybeMethod
  }
  else {
    if (is.primitive(mcall[[1]])) {
      f <- .primname(mcall[[1]])
    }
    else {
      f <- as.character(mcall[[1]])
    }
    fdef <- genericForBasic(f)
    if (is.null(fdef)) 
      stop(gettextf("a call to callNextMethod() appears in a call to %s, but the call does not seem to come from either a generic function or another 'callNextMethod'", sQuote(f)), domain = NA)
    f <- fdef@generic
    method <- maybeMethod
  }
  if (is(method, "MethodDefinition")) {
    if (is.null(nextMethod)) {
      if (!is(method, "MethodWithNext")) {
        method <- addNextMethod(method, f, envir = methodEnv)
        cacheMethod(f, method@target, method, fdef = getGeneric(f), inherited = TRUE)
      }
      nextMethod <- method@nextMethod
      assign(".nextMethod", nextMethod, envir = callEnv)
      assign(".Generic", f, envir = callEnv)
    }
  }
  else if (is.null(method)) {
    if (is.null(nextMethod)) 
      stop("call to 'callNextMethod' does not appear to be in a 'method' or 'callNextMethod' context")
    method <- nextMethod
    if (!is(method, "MethodWithNext")) {
      method <- addNextMethod(method, f, envir = methodEnv)
    }
    nextMethod <- method@nextMethod
    assign(".nextMethod", nextMethod, envir = callEnv)
    assign(".Generic", f, envir = callEnv)
    assign(".nextMethod", method, envir = nextMethodEnv)
    assign(".Generic", f, envir = nextMethodEnv)
  }
  else stop(gettextf("bad object found as method (class %s)", dQuote(class(method))), domain = NA)
  if (is.null(nextMethod)) 
    stop("No next method available")
  subsetCase <- !is.na(match(f, .BasicSubsetFunctions))
  if (nargs() > 0) {
    call <- sys.call()
    call[[1]] <- as.name(".nextMethod")
    eval(call, callEnv)
  }
  else {
    if (subsetCase) {
      call <- as.list(mcall)
      if ((f == "[") && length(names(call) > 0)) 
        call <- .doSubNextCall(call, method)
      else {
        fnames <- c("", formalArgs(method))
        i <- match("...", fnames)
        if (is.na(i) || i > length(call)) 
          length(fnames) <- length(call)
        else {
          i <- i - 1
          length(fnames) <- i
          fnames <- c(fnames, rep("", length(call) - i))
        }
        if (endsWith(f, "<-")) 
          fnames[length(fnames)] <- "value"
        names(call) <- fnames
        call <- as.call(call)
      }
    }
    else call <- match.call(methodFun, mcall, expand.dots = FALSE, envir = dotsenv)
    .Call(C_R_nextMethodCall, call, callEnv)
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
canCoerce
list(`package:methods` = function (object, Class) 
{
  is(object, Class) || !is.null(selectMethod("coerce", c(.class1(object), Class), optional = TRUE, useInherited = c(from = TRUE, to = FALSE)))
}, function (object, Class) 
{
  is(object, Class) || !is.null(selectMethod("coerce", c(.class1(object), Class), optional = TRUE, useInherited = c(from = TRUE, to = FALSE)))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
cbind2
list(`package:methods` = new("standardGeneric", .Data = function (x, y, ...) 
  standardGeneric("cbind2"), generic = "cbind2", package = "methods", group = list(), valueClass = character(0), signature = c("x", "y"), default = NULL, skeleton = (function (x, y, ...) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "cbind2"), domain = NA))(x, y, ...)), new("standardGeneric", .Data = function (x, y, ...) 
      standardGeneric("cbind2"), generic = "cbind2", package = "methods", group = list(), valueClass = character(0), signature = c("x", "y"), default = NULL, skeleton = (function (x, y, ...) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "cbind2"), domain = NA))(x, y, ...)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkAtAssignment
list(`package:methods` = function (cl, name, valueClass) 
{
  ClassDef <- getClass(cl)
  slotClass <- ClassDef@slots[[name]]
  if (is.null(slotClass)) 
    stop(gettextf("%s is not a slot in class %s", sQuote(name), dQuote(cl)), domain = NA)
  if (.identC(slotClass, valueClass)) 
    return(TRUE)
  ok <- possibleExtends(valueClass, slotClass, ClassDef2 = getClassDef(slotClass, where = .classEnv(ClassDef)))
  if (isFALSE(ok)) 
    stop(gettextf("assignment of an object of class %s is not valid for @%s in an object of class %s; is(value, \"%s\") is not TRUE", dQuote(valueClass), sQuote(name), dQuote(cl), slotClass), domain = NA)
  TRUE
}, function (cl, name, valueClass) 
{
  ClassDef <- getClass(cl)
  slotClass <- ClassDef@slots[[name]]
  if (is.null(slotClass)) 
    stop(gettextf("%s is not a slot in class %s", sQuote(name), dQuote(cl)), domain = NA)
  if (.identC(slotClass, valueClass)) 
    return(TRUE)
  ok <- possibleExtends(valueClass, slotClass, ClassDef2 = getClassDef(slotClass, where = .classEnv(ClassDef)))
  if (isFALSE(ok)) 
    stop(gettextf("assignment of an object of class %s is not valid for @%s in an object of class %s; is(value, \"%s\") is not TRUE", dQuote(valueClass), sQuote(name), dQuote(cl), slotClass), domain = NA)
  TRUE
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkSlotAssignment
list(`package:methods` = function (obj, name, value) 
{
  cl <- class(obj)
  ClassDef <- getClass(cl)
  slotClass <- ClassDef@slots[[name]]
  if (is.null(slotClass)) 
    stop(gettextf("%s is not a slot in class %s", sQuote(name), dQuote(cl)), domain = NA)
  valueClass <- class(value)
  if (.identC(slotClass, valueClass)) 
    return(value)
  ok <- possibleExtends(valueClass, slotClass, ClassDef2 = getClassDef(slotClass, where = .classEnv(ClassDef)))
  if (isFALSE(ok)) 
    stop(gettextf("assignment of an object of class %s is not valid for slot %s in an object of class %s; is(value, \"%s\") is not TRUE", dQuote(valueClass), sQuote(name), dQuote(cl), slotClass), domain = NA)
  else if (isTRUE(ok)) 
    value
  else as(value, slotClass, strict = FALSE, ext = ok)
}, function (obj, name, value) 
{
  cl <- class(obj)
  ClassDef <- getClass(cl)
  slotClass <- ClassDef@slots[[name]]
  if (is.null(slotClass)) 
    stop(gettextf("%s is not a slot in class %s", sQuote(name), dQuote(cl)), domain = NA)
  valueClass <- class(value)
  if (.identC(slotClass, valueClass)) 
    return(value)
  ok <- possibleExtends(valueClass, slotClass, ClassDef2 = getClassDef(slotClass, where = .classEnv(ClassDef)))
  if (isFALSE(ok)) 
    stop(gettextf("assignment of an object of class %s is not valid for slot %s in an object of class %s; is(value, \"%s\") is not TRUE", dQuote(valueClass), sQuote(name), dQuote(cl), slotClass), domain = NA)
  else if (isTRUE(ok)) 
    value
  else as(value, slotClass, strict = FALSE, ext = ok)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
classesToAM
list(`package:methods` = function (classes, includeSubclasses = FALSE, abbreviate = 2) 
{
  .mergeMatrices <- function(m1, m2) {
    if (nrow(m1) == 0) 
      return(m2)
    dn1 <- dimnames(m1)
    dn2 <- dimnames(m2)
    rows <- unique(c(dn1[[1]], dn2[[1]]))
    columns <- unique(c(dn1[[2]], dn2[[2]]))
    value <- matrix(0, length(rows), length(columns), dimnames = list(rows, columns))
    value[dn1[[1]], dn1[[2]]] <- m1
    value[dn2[[1]], dn2[[2]]] <- m2
    value
  }
  if (length(includeSubclasses) == 1) 
    includeSubclasses <- rep.int(includeSubclasses, length(classes))
  if (!is(includeSubclasses, "logical") || length(includeSubclasses) != length(classes)) 
    stop("argument 'includeSubclasses' must be a logical, either one value or a vector of the same length as argument 'classes'")
  value <- matrix(0, 0, 0)
  for (i in seq_along(classes)) {
    class <- classes[[i]]
    classDef <- getClass(class)
    value <- .mergeMatrices(value, .oneClassToAM(classDef, includeSubclasses[[i]]))
  }
  abbr <- match(as.integer(abbreviate), 0:3) - 1
  if (length(abbr) != 1 || is.na(abbr)) 
    stop("argument 'abbreviate' must be 0, 1, 2, or 3")
  if (abbr%%2) 
    dimnames(value)[[1]] <- abbreviate(dimnames(value)[[1]])
  if (abbr%/%2) 
    dimnames(value)[[2]] <- abbreviate(dimnames(value)[[2]])
  value
}, function (classes, includeSubclasses = FALSE, abbreviate = 2) 
{
  .mergeMatrices <- function(m1, m2) {
    if (nrow(m1) == 0) 
      return(m2)
    dn1 <- dimnames(m1)
    dn2 <- dimnames(m2)
    rows <- unique(c(dn1[[1]], dn2[[1]]))
    columns <- unique(c(dn1[[2]], dn2[[2]]))
    value <- matrix(0, length(rows), length(columns), dimnames = list(rows, columns))
    value[dn1[[1]], dn1[[2]]] <- m1
    value[dn2[[1]], dn2[[2]]] <- m2
    value
  }
  if (length(includeSubclasses) == 1) 
    includeSubclasses <- rep.int(includeSubclasses, length(classes))
  if (!is(includeSubclasses, "logical") || length(includeSubclasses) != length(classes)) 
    stop("argument 'includeSubclasses' must be a logical, either one value or a vector of the same length as argument 'classes'")
  value <- matrix(0, 0, 0)
  for (i in seq_along(classes)) {
    class <- classes[[i]]
    classDef <- getClass(class)
    value <- .mergeMatrices(value, .oneClassToAM(classDef, includeSubclasses[[i]]))
  }
  abbr <- match(as.integer(abbreviate), 0:3) - 1
  if (length(abbr) != 1 || is.na(abbr)) 
    stop("argument 'abbreviate' must be 0, 1, 2, or 3")
  if (abbr%%2) 
    dimnames(value)[[1]] <- abbreviate(dimnames(value)[[1]])
  if (abbr%/%2) 
    dimnames(value)[[2]] <- abbreviate(dimnames(value)[[2]])
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
classLabel
list(`package:methods` = function (Class) 
{
  if (is.character(Class) && length(Class)) {
    className <- Class[[1]]
    packageName <- attr(Class, "package")
    if (is.null(packageName)) 
      packageName <- ""
  }
  else {
    if (is(Class, "classRepresentation")) {
      className <- Class@className
      packageName <- Class@package
    }
    else stop(gettextf("invalid call to 'classLabel': expected a name or a class definition, got an object of class %s", classLabel(class(Class))), domain = NA)
  }
  if (.showPackage(className)) {
    packageName <- if (identical(packageName, ".GlobalEnv")) 
      " (from the global environment)"
    else paste0(" (from package \"", packageName, "\")")
    paste0("\"", className, "\"", packageName)
  }
  else paste0("\"", className, "\"")
}, function (Class) 
{
  if (is.character(Class) && length(Class)) {
    className <- Class[[1]]
    packageName <- attr(Class, "package")
    if (is.null(packageName)) 
      packageName <- ""
  }
  else {
    if (is(Class, "classRepresentation")) {
      className <- Class@className
      packageName <- Class@package
    }
    else stop(gettextf("invalid call to 'classLabel': expected a name or a class definition, got an object of class %s", classLabel(class(Class))), domain = NA)
  }
  if (.showPackage(className)) {
    packageName <- if (identical(packageName, ".GlobalEnv")) 
      " (from the global environment)"
    else paste0(" (from package \"", packageName, "\")")
    paste0("\"", className, "\"", packageName)
  }
  else paste0("\"", className, "\"")
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
classMetaName
list(`package:methods` = function (name) 
  methodsPackageMetaName("C", name), function (name) 
    methodsPackageMetaName("C", name))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
className
list(`package:methods` = function (class, package) 
{
  if (is(class, "character")) {
    className <- as.character(class)
    if (missing(package)) 
      package <- packageSlot(class)
    if (is.null(package)) {
      if (exists(className, envir = .classTable, inherits = FALSE)) 
        classDef <- get(className, envir = .classTable)
      else {
        classDef <- findClass(className, topenv(parent.frame()))
        if (length(classDef) == 1) 
          classDef <- classDef[[1]]
      }
      if (is(classDef, "classRepresentation")) 
        package <- classDef@package
      else if (length(classDef) > 1) {
        pkgs <- sapply(classDef, function(cl) cl@package)
        warning(gettextf("multiple class definitions for %s from packages: %s; picking the first", dQuote(className), paste(sQuote(pkgs), collapse = ", ")), domain = NA)
        package <- pkgs[[1]]
      }
      else stop(gettextf("no package name supplied and no class definition found for %s", dQuote(className)), domain = NA)
    }
  }
  else if (is(class, classDef)) {
    className <- class@className
    if (missing(package)) 
      package <- class@package
  }
  new("className", .Data = className, package = package)
}, function (class, package) 
{
  if (is(class, "character")) {
    className <- as.character(class)
    if (missing(package)) 
      package <- packageSlot(class)
    if (is.null(package)) {
      if (exists(className, envir = .classTable, inherits = FALSE)) 
        classDef <- get(className, envir = .classTable)
      else {
        classDef <- findClass(className, topenv(parent.frame()))
        if (length(classDef) == 1) 
          classDef <- classDef[[1]]
      }
      if (is(classDef, "classRepresentation")) 
        package <- classDef@package
      else if (length(classDef) > 1) {
        pkgs <- sapply(classDef, function(cl) cl@package)
        warning(gettextf("multiple class definitions for %s from packages: %s; picking the first", dQuote(className), paste(sQuote(pkgs), collapse = ", ")), domain = NA)
        package <- pkgs[[1]]
      }
      else stop(gettextf("no package name supplied and no class definition found for %s", dQuote(className)), domain = NA)
    }
  }
  else if (is(class, classDef)) {
    className <- class@className
    if (missing(package)) 
      package <- class@package
  }
  new("className", .Data = className, package = package)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
coerce
list(`package:methods` = new("nonstandardGenericFunction", .Data = function (from, to, strict = TRUE) 
{
  if (TRUE) {
    warning("direct use of coerce() is deprecated:  use as(from, class(to)) instead", domain = NA)
    return(as(from, class(to), strict = strict))
  }
  standardGeneric("coerce")
}, generic = "coerce", package = "methods", group = list(), valueClass = character(0), signature = c("from", "to", "strict"), default = NULL, skeleton = (function (from, to, strict = TRUE) 
  stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "coerce"), domain = NA))(from, to, strict)), new("nonstandardGenericFunction", .Data = function (from, to, strict = TRUE) 
  {
    if (TRUE) {
      warning("direct use of coerce() is deprecated:  use as(from, class(to)) instead", domain = NA)
      return(as(from, class(to), strict = strict))
    }
    standardGeneric("coerce")
  }, generic = "coerce", package = "methods", group = list(), valueClass = character(0), signature = c("from", "to", "strict"), default = NULL, skeleton = (function (from, to, strict = TRUE) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "coerce"), domain = NA))(from, to, strict)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
coerce<-
  list(`package:methods` = new("nonstandardGenericFunction", .Data = function (from, to, value) 
  {
    if (TRUE) {
      warning("direct use of coerce() is deprecated:  use as(from, class(to)) <- value instead", domain = NA)
      return(`as<-`(from, class(to), value))
    }
    standardGeneric("coerce<-")
  }, generic = "coerce<-", package = "methods", group = list(), valueClass = character(0), signature = c("from", "to", "value"), default = NULL, skeleton = (function (from, to, value) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "coerce<-"), domain = NA))(from, to, value)), new("nonstandardGenericFunction", .Data = function (from, to, value) 
    {
      if (TRUE) {
        warning("direct use of coerce() is deprecated:  use as(from, class(to)) <- value instead", domain = NA)
        return(`as<-`(from, class(to), value))
      }
      standardGeneric("coerce<-")
    }, generic = "coerce<-", package = "methods", group = list(), valueClass = character(0), signature = c("from", "to", "value"), default = NULL, skeleton = (function (from, to, value) 
      stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "coerce<-"), domain = NA))(from, to, value)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Compare
list(`package:lubridate` = new("groupGenericFunction", .Data = function (e1, e2) 
  standardGeneric("Compare"), groupMembers = list("==", ">", "<", "!=", "<=", ">="), generic = "Compare", package = "methods", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Compare"), domain = NA))(e1, e2)), `package:methods` = new("groupGenericFunction", .Data = function (e1, e2) 
      standardGeneric("Compare"), groupMembers = list("==", ">", "<", "!=", "<=", ">="), generic = "Compare", package = "methods", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Compare"), domain = NA))(e1, e2)), new("groupGenericFunction", .Data = function (e1, e2) 
          standardGeneric("Compare"), groupMembers = list("==", ">", "<", "!=", "<=", ">="), generic = "Compare", package = "methods", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
            stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Compare"), domain = NA))(e1, e2)))
c("package:lubridate", "package:methods", "namespace:methods")
c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, TRUE)
completeClassDefinition
list(`package:methods` = function (Class, ClassDef = getClassDef(Class), where, doExtends = TRUE) 
{
  ClassDef <- .completeClassSlots(ClassDef, where)
  immediate <- ClassDef@contains
  properties <- ClassDef@slots
  prototype <- makePrototypeFromClassDef(properties, ClassDef, immediate, where)
  virtual <- ClassDef@virtual
  extends <- if (doExtends) 
    completeExtends(ClassDef, where = where)
  else ClassDef@contains
  subclasses <- if (doExtends) 
    completeSubclasses(ClassDef, where = where)
  else ClassDef@subclasses
  if (is.na(virtual)) 
    virtual <- testVirtual(properties, immediate, prototype, where)
  ClassDef <- .mergeClassDefSlots(ClassDef, slots = properties, contains = extends, prototype = prototype, virtual = virtual, subclasses = subclasses)
  if (any(!is.na(match(names(ClassDef@subclasses), names(ClassDef@contains)))) && getOption("warn") > 0) {
    bad <- names(ClassDef@subclasses)[!is.na(match(names(ClassDef@subclasses), names(ClassDef@contains)))]
    warning(gettextf("potential cycle in class inheritance: %s has duplicates in superclasses and subclasses (%s)", dQuote(Class), paste(bad, collapse = ", ")), domain = NA)
  }
  ClassDef
}, function (Class, ClassDef = getClassDef(Class), where, doExtends = TRUE) 
{
  ClassDef <- .completeClassSlots(ClassDef, where)
  immediate <- ClassDef@contains
  properties <- ClassDef@slots
  prototype <- makePrototypeFromClassDef(properties, ClassDef, immediate, where)
  virtual <- ClassDef@virtual
  extends <- if (doExtends) 
    completeExtends(ClassDef, where = where)
  else ClassDef@contains
  subclasses <- if (doExtends) 
    completeSubclasses(ClassDef, where = where)
  else ClassDef@subclasses
  if (is.na(virtual)) 
    virtual <- testVirtual(properties, immediate, prototype, where)
  ClassDef <- .mergeClassDefSlots(ClassDef, slots = properties, contains = extends, prototype = prototype, virtual = virtual, subclasses = subclasses)
  if (any(!is.na(match(names(ClassDef@subclasses), names(ClassDef@contains)))) && getOption("warn") > 0) {
    bad <- names(ClassDef@subclasses)[!is.na(match(names(ClassDef@subclasses), names(ClassDef@contains)))]
    warning(gettextf("potential cycle in class inheritance: %s has duplicates in superclasses and subclasses (%s)", dQuote(Class), paste(bad, collapse = ", ")), domain = NA)
  }
  ClassDef
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
completeExtends
list(`package:methods` = function (ClassDef, class2, extensionDef, where) 
{
  ext <- ClassDef@contains
  for (i in seq_along(ext)) {
    if (.isIndirectExtension(ext[[i]])) {
      ClassDef <- .uncompleteClassDefinition(ClassDef, "contains")
      break
    }
  }
  exts <- .walkClassGraph(ClassDef, "contains", where, attr(ext, "conflicts"))
  if (length(exts)) {
    if ("oldClass" %in% names(exts) && length(ClassDef@slots) > 1) 
      exts <- .S3Extends(ClassDef, exts, where)
  }
  if (!missing(class2) && length(ClassDef@subclasses)) {
    strictBy <- TRUE
    subclasses <- .transitiveSubclasses(ClassDef@className, class2, extensionDef, ClassDef@subclasses, strictBy)
    for (i in seq_along(subclasses)) {
      obji <- subclasses[[i]]
      if (!extends(obji@subClass, class2)) 
        setIs(obji@subClass, class2, extensionObject = obji, doComplete = FALSE, where = where)
    }
  }
  exts
}, function (ClassDef, class2, extensionDef, where) 
{
  ext <- ClassDef@contains
  for (i in seq_along(ext)) {
    if (.isIndirectExtension(ext[[i]])) {
      ClassDef <- .uncompleteClassDefinition(ClassDef, "contains")
      break
    }
  }
  exts <- .walkClassGraph(ClassDef, "contains", where, attr(ext, "conflicts"))
  if (length(exts)) {
    if ("oldClass" %in% names(exts) && length(ClassDef@slots) > 1) 
      exts <- .S3Extends(ClassDef, exts, where)
  }
  if (!missing(class2) && length(ClassDef@subclasses)) {
    strictBy <- TRUE
    subclasses <- .transitiveSubclasses(ClassDef@className, class2, extensionDef, ClassDef@subclasses, strictBy)
    for (i in seq_along(subclasses)) {
      obji <- subclasses[[i]]
      if (!extends(obji@subClass, class2)) 
        setIs(obji@subClass, class2, extensionObject = obji, doComplete = FALSE, where = where)
    }
  }
  exts
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
completeSubclasses
list(`package:methods` = function (classDef, class2, extensionDef, where, classDef2 = getClassDef(class2, where)) 
{
  ext <- classDef@subclasses
  for (i in seq_along(ext)) {
    if (.isIndirectExtension(ext[[i]])) {
      classDef <- .uncompleteClassDefinition(classDef, "subclasses")
      break
    }
  }
  subclasses <- .walkClassGraph(classDef, "subclasses", where)
  if (!missing(class2) && length(classDef@contains)) {
    strictBy <- TRUE
    contains <- .transitiveExtends(class2, classDef@className, extensionDef, classDef@contains, strictBy)
    for (i in seq_along(contains)) {
      obji <- contains[[i]]
      cli <- contains[[i]]@superClass
      cliDef <- getClassDef(cli, package = packageSlot(obji))
      subcl <- cliDef@subclasses[[class2]]
      if (is.null(subcl)) {
        exti <- extends(classDef2, cliDef, fullInfo = TRUE)
        if (identical(exti, FALSE) || (is(exti, "SClassExtension") && exti@distance > 1 && classDef@className == exti@by)) 
          setIs(class2, cli, extensionObject = obji, doComplete = FALSE, where = where)
      }
    }
  }
  subclasses
}, function (classDef, class2, extensionDef, where, classDef2 = getClassDef(class2, where)) 
{
  ext <- classDef@subclasses
  for (i in seq_along(ext)) {
    if (.isIndirectExtension(ext[[i]])) {
      classDef <- .uncompleteClassDefinition(classDef, "subclasses")
      break
    }
  }
  subclasses <- .walkClassGraph(classDef, "subclasses", where)
  if (!missing(class2) && length(classDef@contains)) {
    strictBy <- TRUE
    contains <- .transitiveExtends(class2, classDef@className, extensionDef, classDef@contains, strictBy)
    for (i in seq_along(contains)) {
      obji <- contains[[i]]
      cli <- contains[[i]]@superClass
      cliDef <- getClassDef(cli, package = packageSlot(obji))
      subcl <- cliDef@subclasses[[class2]]
      if (is.null(subcl)) {
        exti <- extends(classDef2, cliDef, fullInfo = TRUE)
        if (identical(exti, FALSE) || (is(exti, "SClassExtension") && exti@distance > 1 && classDef@className == exti@by)) 
          setIs(class2, cli, extensionObject = obji, doComplete = FALSE, where = where)
      }
    }
  }
  subclasses
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Complex
list(`package:methods` = new("groupGenericFunction", .Data = function (z) 
  standardGeneric("Complex"), groupMembers = list("Arg", "Conj", "Im", "Mod", "Re"), generic = "Complex", package = "base", group = list(), valueClass = character(0), signature = "z", default = NULL, skeleton = (function (z) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Complex"), domain = NA))(z)), new("groupGenericFunction", .Data = function (z) 
      standardGeneric("Complex"), groupMembers = list("Arg", "Conj", "Im", "Mod", "Re"), generic = "Complex", package = "base", group = list(), valueClass = character(0), signature = "z", default = NULL, skeleton = (function (z) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Complex"), domain = NA))(z)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
conformMethod
list(`package:methods` = function (signature, mnames, fnames, f = "<unspecified>", fdef, method) 
{
  sig0 <- signature
  fsig <- fdef@signature
  if (is.na(match("...", mnames)) && !is.na(match("...", fnames))) 
    fnames <- fnames[-match("...", fnames)]
  imf <- match(fnames, mnames)
  omitted <- is.na(imf)
  if (is.unsorted(imf[!omitted])) 
    stop(.renderSignature(f, signature), "formal arguments in method and generic do not appear in the same order", call. = FALSE)
  if (!any(omitted)) 
    return(signature)
  sigNames <- names(signature)
  omittedSig <- sigNames %in% fnames[omitted]
  if (!any(omittedSig)) 
    return(signature)
  if (any(iiN <- is.na(match(signature[omittedSig], c("ANY", "missing"))))) {
    bad <- omittedSig & iiN
    bad2 <- paste0(fnames[bad], " = \"", signature[bad], "\"", collapse = ", ")
    stop(.renderSignature(f, sig0), gettextf("formal arguments (%s) omitted in the method definition cannot be in the signature", bad2), call. = TRUE, domain = NA)
  }
  else if (any(omittedSig <- omittedSig & signature != "missing")) {
    .message("Note: ", .renderSignature(f, sig0), gettextf("expanding the signature to include omitted arguments in definition: %s", paste(sigNames[omittedSig], "= \"missing\"", collapse = ", ")))
    signature[omittedSig] <- "missing"
  }
  n <- length(signature)
  while (.identC(signature[[n]], "ANY")) n <- n - 1
  length(signature) <- n
  length(fsig) <- n
  setNames(signature, fsig)
}, function (signature, mnames, fnames, f = "<unspecified>", fdef, method) 
{
  sig0 <- signature
  fsig <- fdef@signature
  if (is.na(match("...", mnames)) && !is.na(match("...", fnames))) 
    fnames <- fnames[-match("...", fnames)]
  imf <- match(fnames, mnames)
  omitted <- is.na(imf)
  if (is.unsorted(imf[!omitted])) 
    stop(.renderSignature(f, signature), "formal arguments in method and generic do not appear in the same order", call. = FALSE)
  if (!any(omitted)) 
    return(signature)
  sigNames <- names(signature)
  omittedSig <- sigNames %in% fnames[omitted]
  if (!any(omittedSig)) 
    return(signature)
  if (any(iiN <- is.na(match(signature[omittedSig], c("ANY", "missing"))))) {
    bad <- omittedSig & iiN
    bad2 <- paste0(fnames[bad], " = \"", signature[bad], "\"", collapse = ", ")
    stop(.renderSignature(f, sig0), gettextf("formal arguments (%s) omitted in the method definition cannot be in the signature", bad2), call. = TRUE, domain = NA)
  }
  else if (any(omittedSig <- omittedSig & signature != "missing")) {
    .message("Note: ", .renderSignature(f, sig0), gettextf("expanding the signature to include omitted arguments in definition: %s", paste(sigNames[omittedSig], "= \"missing\"", collapse = ", ")))
    signature[omittedSig] <- "missing"
  }
  n <- length(signature)
  while (.identC(signature[[n]], "ANY")) n <- n - 1
  length(signature) <- n
  length(fsig) <- n
  setNames(signature, fsig)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
defaultDumpName
list(`package:methods` = function (generic, signature) 
{
  if (missing(signature)) 
    paste(generic, "R", sep = ".", collapse = ".")
  else paste(generic, paste(signature, collapse = "."), "R", sep = ".")
}, function (generic, signature) 
{
  if (missing(signature)) 
    paste(generic, "R", sep = ".", collapse = ".")
  else paste(generic, paste(signature, collapse = "."), "R", sep = ".")
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
defaultPrototype
list(`package:methods` = function () 
  .defaultPrototype, function () 
    .defaultPrototype)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
doPrimitiveMethod
list(`package:methods` = function (name, def, call = sys.call(sys.parent()), ev = sys.frame(sys.parent(2))) 
{
  cat("called doPrimitiveMethod\n\n")
  if (!is.null(prev <- ev[[name]])) {
    on.exit(assign(name, prev, envir = ev))
  }
  else on.exit(rm(list = name, envir = ev))
  assign(name, def, envir = ev)
  eval(call, ev)
}, function (name, def, call = sys.call(sys.parent()), ev = sys.frame(sys.parent(2))) 
{
  cat("called doPrimitiveMethod\n\n")
  if (!is.null(prev <- ev[[name]])) {
    on.exit(assign(name, prev, envir = ev))
  }
  else on.exit(rm(list = name, envir = ev))
  assign(name, def, envir = ev)
  eval(call, ev)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
dumpMethod
list(`package:methods` = function (f, signature = character(), file = defaultDumpName(f, signature), where = topenv(parent.frame()), def = getMethod(f, signature, where = where, optional = TRUE)) 
{
  if (!is.function(def)) 
    def <- getMethod(f, character(), where = where, optional = TRUE)
  closeit <- TRUE
  isSTDOUT <- FALSE
  if (is.character(file)) {
    if (!(isSTDOUT <- file == "")) 
      file <- file(file, "w")
  }
  else if (inherits(file, "connection")) {
    if (!isOpen(file)) 
      open(file, "w")
    else closeit <- FALSE
  }
  else stop("'file' must be a character string or a connection")
  if (!isSTDOUT) {
    sink(file)
    on.exit({
      sink()
      if (closeit) close(file)
    })
  }
  cat("setMethod(\"", f, "\", ", deparse(signature), ",\n", sep = "")
  dput(def@.Data)
  cat(")\n", sep = "")
  if (!isSTDOUT) {
    on.exit()
    sink()
    if (closeit) 
      close(file)
  }
  invisible(file)
}, function (f, signature = character(), file = defaultDumpName(f, signature), where = topenv(parent.frame()), def = getMethod(f, signature, where = where, optional = TRUE)) 
{
  if (!is.function(def)) 
    def <- getMethod(f, character(), where = where, optional = TRUE)
  closeit <- TRUE
  isSTDOUT <- FALSE
  if (is.character(file)) {
    if (!(isSTDOUT <- file == "")) 
      file <- file(file, "w")
  }
  else if (inherits(file, "connection")) {
    if (!isOpen(file)) 
      open(file, "w")
    else closeit <- FALSE
  }
  else stop("'file' must be a character string or a connection")
  if (!isSTDOUT) {
    sink(file)
    on.exit({
      sink()
      if (closeit) close(file)
    })
  }
  cat("setMethod(\"", f, "\", ", deparse(signature), ",\n", sep = "")
  dput(def@.Data)
  cat(")\n", sep = "")
  if (!isSTDOUT) {
    on.exit()
    sink()
    if (closeit) 
      close(file)
  }
  invisible(file)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
dumpMethods
list(`package:methods` = function (f, file = "", signature = NULL, methods = findMethods(f, where = where), where = topenv(parent.frame())) 
{
  if (length(signature) > 0) 
    warning("argument 'signature' is not meaningful with the current implementation and is ignored \n(extract a subset of the methods list instead)")
  closeit <- TRUE
  isSTDOUT <- FALSE
  if (is.character(file)) {
    if (!(isSTDOUT <- file == "")) 
      file <- file(file, "w")
  }
  else if (inherits(file, "connection")) {
    if (!isOpen(file)) 
      open(file, "w")
    else closeit <- FALSE
  }
  else stop("'file' must be a character string or a connection")
  if (!isSTDOUT) {
    sink(file)
    on.exit({
      sink()
      if (closeit) close(file)
    })
  }
  sigs <- methods@signatures
  for (i in seq_along(methods)) dumpMethod(f, sigs[[i]], file = "", def = methods[[i]])
}, function (f, file = "", signature = NULL, methods = findMethods(f, where = where), where = topenv(parent.frame())) 
{
  if (length(signature) > 0) 
    warning("argument 'signature' is not meaningful with the current implementation and is ignored \n(extract a subset of the methods list instead)")
  closeit <- TRUE
  isSTDOUT <- FALSE
  if (is.character(file)) {
    if (!(isSTDOUT <- file == "")) 
      file <- file(file, "w")
  }
  else if (inherits(file, "connection")) {
    if (!isOpen(file)) 
      open(file, "w")
    else closeit <- FALSE
  }
  else stop("'file' must be a character string or a connection")
  if (!isSTDOUT) {
    sink(file)
    on.exit({
      sink()
      if (closeit) close(file)
    })
  }
  sigs <- methods@signatures
  for (i in seq_along(methods)) dumpMethod(f, sigs[[i]], file = "", def = methods[[i]])
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
el
list(`package:methods` = function (object, where) 
  object[where][[1]], function (object, where) 
    object[where][[1]])
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
el<-
  list(`package:methods` = .Primitive("[[<-"), .Primitive("[[<-"))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
elNamed
list(`package:methods` = function (x, name, mustFind = FALSE) 
{
  i <- match(name, names(x))
  if (is.na(i)) {
    if (mustFind) 
      stop(gettextf("%s is not one of the element names", sQuote(name)), domain = NA)
    else NULL
  }
  else x[[i]]
}, function (x, name, mustFind = FALSE) 
{
  i <- match(name, names(x))
  if (is.na(i)) {
    if (mustFind) 
      stop(gettextf("%s is not one of the element names", sQuote(name)), domain = NA)
    else NULL
  }
  else x[[i]]
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
elNamed<-
  list(`package:methods` = function (x, name, value) 
  {
    x[[name]] <- value
    x
  }, function (x, name, value) 
  {
    x[[name]] <- value
    x
  })
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
empty.dump
list(`package:methods` = function () 
  list(), function () 
    list())
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
emptyMethodsList
list(`package:methods` = function (mlist, thisClass = "ANY", sublist = list()) 
{
  .MlistDeprecated("emptyMethodsList()")
  sublist[thisClass] <- list(NULL)
  new("EmptyMethodsList", argument = mlist@argument, sublist = sublist)
}, function (mlist, thisClass = "ANY", sublist = list()) 
{
  .MlistDeprecated("emptyMethodsList()")
  sublist[thisClass] <- list(NULL)
  new("EmptyMethodsList", argument = mlist@argument, sublist = sublist)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
evalOnLoad
list(`package:methods` = function (expr, where = topenv(parent.frame()), aname = "") 
{
  f <- function(env) NULL
  body(f, where) <- substitute(eval(EXPR, ENV), list(EXPR = expr, ENV = where))
  setLoadAction(f, aname, where)
}, function (expr, where = topenv(parent.frame()), aname = "") 
{
  f <- function(env) NULL
  body(f, where) <- substitute(eval(EXPR, ENV), list(EXPR = expr, ENV = where))
  setLoadAction(f, aname, where)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
evalqOnLoad
list(`package:methods` = function (expr, where = topenv(parent.frame()), aname = "") 
  evalOnLoad(substitute(expr), where, aname), function (expr, where = topenv(parent.frame()), aname = "") 
    evalOnLoad(substitute(expr), where, aname))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
evalSource
list(`package:methods` = function (source, package = "", lock = TRUE, cache = FALSE) 
{
  if (!nzchar(package)) 
    envp <- .GlobalEnv
  else {
    pstring <- paste0("package:", package)
    packageIsVisible <- pstring %in% search()
    if (packageIsVisible) {
      envp <- as.environment(pstring)
    }
    else {
      envp <- tryCatch(asNamespace(package), error = function(cond) NULL)
    }
    if (is.null(envp)) 
      stop(gettextf("package %s is not attached and no namespace found for it", sQuote(package)), domain = NA)
  }
  env <- new("sourceEnvironment", new.env(parent = envp), packageName = package, sourceFile = (if (is.character(source)) 
    source
    else ""))
  env$.packageName <- package
  setCacheOnAssign(env, cache)
  if (is(source, "character")) 
    for (text in source) sys.source(text, envir = env)
  else if (is(source, "connection")) 
    sys.source(source, envir = env)
  else if (!is(source, "environment")) 
    stop(gettextf("invalid 'source' argument: expected file names or a connection but got an object of class %s", dQuote(class(source)[[1]])), domain = NA)
  if (lock) 
    lockEnvironment(env, bindings = TRUE)
  env
}, function (source, package = "", lock = TRUE, cache = FALSE) 
{
  if (!nzchar(package)) 
    envp <- .GlobalEnv
  else {
    pstring <- paste0("package:", package)
    packageIsVisible <- pstring %in% search()
    if (packageIsVisible) {
      envp <- as.environment(pstring)
    }
    else {
      envp <- tryCatch(asNamespace(package), error = function(cond) NULL)
    }
    if (is.null(envp)) 
      stop(gettextf("package %s is not attached and no namespace found for it", sQuote(package)), domain = NA)
  }
  env <- new("sourceEnvironment", new.env(parent = envp), packageName = package, sourceFile = (if (is.character(source)) 
    source
    else ""))
  env$.packageName <- package
  setCacheOnAssign(env, cache)
  if (is(source, "character")) 
    for (text in source) sys.source(text, envir = env)
  else if (is(source, "connection")) 
    sys.source(source, envir = env)
  else if (!is(source, "environment")) 
    stop(gettextf("invalid 'source' argument: expected file names or a connection but got an object of class %s", dQuote(class(source)[[1]])), domain = NA)
  if (lock) 
    lockEnvironment(env, bindings = TRUE)
  env
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
existsFunction
list(`package:methods` = function (f, generic = TRUE, where = topenv(parent.frame())) 
  length(findFunction(f, generic, where)) > 0, function (f, generic = TRUE, where = topenv(parent.frame())) 
    length(findFunction(f, generic, where)) > 0)
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
existsMethod
list(`package:methods` = function (f, signature = character(), where = topenv(parent.frame())) 
{
  if (missing(where)) 
    method <- getMethod(f, signature, optional = TRUE)
  else method <- getMethod(f, signature, where = where, optional = TRUE)
  !is.null(method)
}, function (f, signature = character(), where = topenv(parent.frame())) 
{
  if (missing(where)) 
    method <- getMethod(f, signature, optional = TRUE)
  else method <- getMethod(f, signature, where = where, optional = TRUE)
  !is.null(method)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
extends
list(`package:methods` = function (class1, class2, maybe = TRUE, fullInfo = FALSE) 
{
  if (is.character(class1)) {
    if (length(class1) > 1) 
      class1 <- class1[[1]]
    classDef1 <- getClassDef(class1)
  }
  else if (is(class1, "classRepresentation")) {
    classDef1 <- class1
    class1 <- classDef1@className
  }
  else stop("'class1' must be the name of a class or a class definition")
  if (missing(class2)) {
    if (is.null(classDef1)) 
      return(class1)
    ext <- classDef1@contains
    if (!isTRUE(maybe) && length(ext) > 0) {
      noTest <- vapply(ext, function(obj) isTRUE(body(obj@test)), NA)
      ext <- ext[noTest]
    }
    if (fullInfo) {
      ext[[class1]] <- TRUE
      return(ext)
    }
    else return(c(class1, names(ext)))
  }
  value <- NULL
  if (is.character(class2) && length(class2) == 1) {
    if (.identC(class1[[1]], class2) || .identC(class2, "ANY")) 
      return(TRUE)
    if (!is.null(classDef1) && class2 %in% names(classDef1@contains)) 
      value <- classDef1@contains[[class2]]
    else classDef2 <- getClassDef(class2)
  }
  else if (is(class2, "classRepresentation")) {
    classDef2 <- class2
    class2 <- class2@className
  }
  else stop("'class2' must be the name of a class or a class definition")
  if (is.null(value)) 
    value <- possibleExtends(class1, class2, classDef1, classDef2)
  if (fullInfo) 
    value
  else if (is.logical(value)) 
    value
  else if (value@simple || isTRUE(body(value@test))) 
    TRUE
  else maybe
}, function (class1, class2, maybe = TRUE, fullInfo = FALSE) 
{
  if (is.character(class1)) {
    if (length(class1) > 1) 
      class1 <- class1[[1]]
    classDef1 <- getClassDef(class1)
  }
  else if (is(class1, "classRepresentation")) {
    classDef1 <- class1
    class1 <- classDef1@className
  }
  else stop("'class1' must be the name of a class or a class definition")
  if (missing(class2)) {
    if (is.null(classDef1)) 
      return(class1)
    ext <- classDef1@contains
    if (!isTRUE(maybe) && length(ext) > 0) {
      noTest <- vapply(ext, function(obj) isTRUE(body(obj@test)), NA)
      ext <- ext[noTest]
    }
    if (fullInfo) {
      ext[[class1]] <- TRUE
      return(ext)
    }
    else return(c(class1, names(ext)))
  }
  value <- NULL
  if (is.character(class2) && length(class2) == 1) {
    if (.identC(class1[[1]], class2) || .identC(class2, "ANY")) 
      return(TRUE)
    if (!is.null(classDef1) && class2 %in% names(classDef1@contains)) 
      value <- classDef1@contains[[class2]]
    else classDef2 <- getClassDef(class2)
  }
  else if (is(class2, "classRepresentation")) {
    classDef2 <- class2
    class2 <- class2@className
  }
  else stop("'class2' must be the name of a class or a class definition")
  if (is.null(value)) 
    value <- possibleExtends(class1, class2, classDef1, classDef2)
  if (fullInfo) 
    value
  else if (is.logical(value)) 
    value
  else if (value@simple || isTRUE(body(value@test))) 
    TRUE
  else maybe
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
externalRefMethod
list(`package:methods` = new("classGeneratorFunction", .Data = function (...) 
  new("externalRefMethod", ...), className = "externalRefMethod", package = "methods"), new("classGeneratorFunction", .Data = function (...) 
    new("externalRefMethod", ...), className = "externalRefMethod", package = "methods"))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
finalDefaultMethod
list(`package:methods` = function (method) 
{
  repeat {
    if (is.function(method) || is.null(method)) 
      break
    if (is(method, "MethodsList")) {
      .MlistDeprecated()
      method <- slot(method, "methods")[["ANY"]]
    }
    else stop(gettextf("default method must be a method definition, a primitive or NULL: got an object of class %s", dQuote(class(method))), domain = NA)
  }
  method
}, function (method) 
{
  repeat {
    if (is.function(method) || is.null(method)) 
      break
    if (is(method, "MethodsList")) {
      .MlistDeprecated()
      method <- slot(method, "methods")[["ANY"]]
    }
    else stop(gettextf("default method must be a method definition, a primitive or NULL: got an object of class %s", dQuote(class(method))), domain = NA)
  }
  method
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
findClass
list(`package:methods` = function (Class, where = topenv(parent.frame()), unique = "") 
{
  if (is(Class, "classRepresentation")) {
    pkg <- Class@package
    classDef <- Class
    Class <- Class@className
  }
  else {
    pkg <- packageSlot(Class)
    if (is.null(pkg)) 
      pkg <- ""
    classDef <- getClassDef(Class, where, pkg)
  }
  where <- if (missing(where) && nzchar(pkg)) 
    .requirePackage(pkg)
  else as.environment(where)
  what <- classMetaName(Class)
  where <- .findAll(what, where)
  if (length(where) > 1 && nzchar(pkg)) {
    pkgs <- sapply(where, function(db) get(what, db)@package)
    where <- where[match(pkg, pkgs, 0)]
  }
  else pkgs <- pkg
  if (length(where) == 0) {
    if (is.null(classDef)) 
      classDef <- getClassDef(Class)
    if (nzchar(unique)) {
      if (is(classDef, "classRepresentation")) 
        stop(gettextf("class %s is defined, with package %s, but no corresponding metadata object was found (not exported?)", dQuote(Class), sQuote(classDef@package)), domain = NA)
      else stop(gettextf("no definition of %s to use for %s", dQuote(Class), unique), domain = NA)
    }
  }
  else if (length(where) > 1) {
    pkgs <- sapply(where, getPackageName, create = FALSE)
    where <- where[!(nzchar(pkgs) & duplicated(pkgs))]
    if (length(where) > 1) 
      if (nzchar(unique)) {
        pkgs <- base::unique(pkgs)
        where <- where[1]
        warning(sprintf(ngettext(length(pkgs), "multiple definition of class %s visible (%s); using the definition\n   in package %s for %s", "multiple definitions of class %s visible (%s); using the definition\n   in package %s for %s"), dQuote(Class), paste(sQuote(pkgs), collapse = ", "), sQuote(pkgs[[1]]), unique), domain = NA)
      }
  }
  where
}, function (Class, where = topenv(parent.frame()), unique = "") 
{
  if (is(Class, "classRepresentation")) {
    pkg <- Class@package
    classDef <- Class
    Class <- Class@className
  }
  else {
    pkg <- packageSlot(Class)
    if (is.null(pkg)) 
      pkg <- ""
    classDef <- getClassDef(Class, where, pkg)
  }
  where <- if (missing(where) && nzchar(pkg)) 
    .requirePackage(pkg)
  else as.environment(where)
  what <- classMetaName(Class)
  where <- .findAll(what, where)
  if (length(where) > 1 && nzchar(pkg)) {
    pkgs <- sapply(where, function(db) get(what, db)@package)
    where <- where[match(pkg, pkgs, 0)]
  }
  else pkgs <- pkg
  if (length(where) == 0) {
    if (is.null(classDef)) 
      classDef <- getClassDef(Class)
    if (nzchar(unique)) {
      if (is(classDef, "classRepresentation")) 
        stop(gettextf("class %s is defined, with package %s, but no corresponding metadata object was found (not exported?)", dQuote(Class), sQuote(classDef@package)), domain = NA)
      else stop(gettextf("no definition of %s to use for %s", dQuote(Class), unique), domain = NA)
    }
  }
  else if (length(where) > 1) {
    pkgs <- sapply(where, getPackageName, create = FALSE)
    where <- where[!(nzchar(pkgs) & duplicated(pkgs))]
    if (length(where) > 1) 
      if (nzchar(unique)) {
        pkgs <- base::unique(pkgs)
        where <- where[1]
        warning(sprintf(ngettext(length(pkgs), "multiple definition of class %s visible (%s); using the definition\n   in package %s for %s", "multiple definitions of class %s visible (%s); using the definition\n   in package %s for %s"), dQuote(Class), paste(sQuote(pkgs), collapse = ", "), sQuote(pkgs[[1]]), unique), domain = NA)
      }
  }
  where
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
findFunction
list(`package:methods` = function (f, generic = TRUE, where = topenv(parent.frame())) 
{
  allWhere <- .findAll(f, where)
  ok <- logical(length(allWhere))
  for (i in seq_along(allWhere)) {
    wherei <- allWhere[[i]]
    if (!is.null(fdef <- wherei[[f]])) {
      ok[i] <- is.function(fdef) && (generic || is.primitive(fdef) || !isGeneric(f, wherei, fdef))
    }
  }
  allWhere[ok]
}, function (f, generic = TRUE, where = topenv(parent.frame())) 
{
  allWhere <- .findAll(f, where)
  ok <- logical(length(allWhere))
  for (i in seq_along(allWhere)) {
    wherei <- allWhere[[i]]
    if (!is.null(fdef <- wherei[[f]])) {
      ok[i] <- is.function(fdef) && (generic || is.primitive(fdef) || !isGeneric(f, wherei, fdef))
    }
  }
  allWhere[ok]
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
findMethod
list(`package:methods` = function (f, signature, where = topenv(parent.frame())) 
{
  if (is(f, "genericFunction")) {
    fdef <- f
    f <- fdef@generic
  }
  else fdef <- getGeneric(f, where = where)
  if (is.null(fdef)) {
    warning(gettextf("no generic function %s found", sQuote(f)), domain = NA)
    return(character())
  }
  fM <- .TableMetaName(fdef@generic, fdef@package)
  where <- .findAll(fM, where)
  found <- logical(length(where))
  for (i in seq_along(where)) {
    wherei <- where[[i]]
    table <- get(fM, wherei, inherits = FALSE)
    mi <- .findMethodForFdef(signature, table, fdef)
    found[i] <- !is.null(mi)
  }
  value <- where[found]
  what <- vapply(value, class, "", USE.NAMES = FALSE)
  if (identical(what, "numeric") || identical(what, "character")) 
    unlist(value)
  else value
}, function (f, signature, where = topenv(parent.frame())) 
{
  if (is(f, "genericFunction")) {
    fdef <- f
    f <- fdef@generic
  }
  else fdef <- getGeneric(f, where = where)
  if (is.null(fdef)) {
    warning(gettextf("no generic function %s found", sQuote(f)), domain = NA)
    return(character())
  }
  fM <- .TableMetaName(fdef@generic, fdef@package)
  where <- .findAll(fM, where)
  found <- logical(length(where))
  for (i in seq_along(where)) {
    wherei <- where[[i]]
    table <- get(fM, wherei, inherits = FALSE)
    mi <- .findMethodForFdef(signature, table, fdef)
    found[i] <- !is.null(mi)
  }
  value <- where[found]
  what <- vapply(value, class, "", USE.NAMES = FALSE)
  if (identical(what, "numeric") || identical(what, "character")) 
    unlist(value)
  else value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
findMethods
list(`package:methods` = function (f, where, classes = character(), inherited = FALSE, package = "") 
{
  if (is(f, "genericFunction")) {
    fdef <- f
    f <- fdef@generic
  }
  else if (.isSingleString(f)) {
    if (missing(where)) 
      fdef <- getGeneric(f, package = package)
    else {
      fdef <- getGeneric(f, where = where, package = package)
      if (is.null(fdef)) 
        fdef <- getGeneric(f, package = package)
    }
  }
  else if (!is.function(f)) 
    stop(gettextf("argument %s must be a generic function or a single character string; got an object of class %s", sQuote("f"), dQuote(class(f))), domain = NA)
  else {
    fdef <- f
    f <- deparse1(substitute(f))
  }
  if (!is(fdef, "genericFunction")) {
    warning(gettextf("non-generic function '%s' given to findMethods()", f), domain = NA)
    return(list())
  }
  object <- new("listOfMethods", arguments = fdef@signature, generic = fdef)
  if (missing(where)) 
    table <- get(if (inherited) 
      ".AllMTable"
      else ".MTable", envir = environment(fdef))
  else {
    if (!isFALSE(inherited)) 
      stop(gettextf("only FALSE is meaningful for 'inherited', when 'where' is supplied (got %s)", inherited), domain = NA)
    where <- as.environment(where)
    what <- .TableMetaName(f, fdef@package)
    if (is.null(table <- where[[what]])) 
      return(object)
  }
  objNames <- sort(names(table))
  if (length(classes)) {
    classesPattern <- paste0("#", classes, "#", collapse = "|")
    which <- grep(classesPattern, paste0("#", objNames, "#"))
    objNames <- objNames[which]
  }
  object@.Data <- mget(objNames, table)
  object@names <- objNames
  object@signatures <- strsplit(objNames, "#", fixed = TRUE)
  object
}, function (f, where, classes = character(), inherited = FALSE, package = "") 
{
  if (is(f, "genericFunction")) {
    fdef <- f
    f <- fdef@generic
  }
  else if (.isSingleString(f)) {
    if (missing(where)) 
      fdef <- getGeneric(f, package = package)
    else {
      fdef <- getGeneric(f, where = where, package = package)
      if (is.null(fdef)) 
        fdef <- getGeneric(f, package = package)
    }
  }
  else if (!is.function(f)) 
    stop(gettextf("argument %s must be a generic function or a single character string; got an object of class %s", sQuote("f"), dQuote(class(f))), domain = NA)
  else {
    fdef <- f
    f <- deparse1(substitute(f))
  }
  if (!is(fdef, "genericFunction")) {
    warning(gettextf("non-generic function '%s' given to findMethods()", f), domain = NA)
    return(list())
  }
  object <- new("listOfMethods", arguments = fdef@signature, generic = fdef)
  if (missing(where)) 
    table <- get(if (inherited) 
      ".AllMTable"
      else ".MTable", envir = environment(fdef))
  else {
    if (!isFALSE(inherited)) 
      stop(gettextf("only FALSE is meaningful for 'inherited', when 'where' is supplied (got %s)", inherited), domain = NA)
    where <- as.environment(where)
    what <- .TableMetaName(f, fdef@package)
    if (is.null(table <- where[[what]])) 
      return(object)
  }
  objNames <- sort(names(table))
  if (length(classes)) {
    classesPattern <- paste0("#", classes, "#", collapse = "|")
    which <- grep(classesPattern, paste0("#", objNames, "#"))
    objNames <- objNames[which]
  }
  object@.Data <- mget(objNames, table)
  object@names <- objNames
  object@signatures <- strsplit(objNames, "#", fixed = TRUE)
  object
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
findMethodSignatures
list(`package:methods` = function (..., target = TRUE, methods = findMethods(...)) 
{
  what <- methods@arguments
  if (target) 
    sigs <- methods@signatures
  else {
    anySig <- rep("ANY", length(what))
    for (m in methods) if (!is.primitive(m)) {
      length(anySig) <- length(m@defined)
      break
    }
    sigs <- lapply(methods, function(x) if (is.primitive(x)) 
      anySig
      else as.character(x@defined))
  }
  lens <- unique(vapply(sigs, length, 1, USE.NAMES = FALSE))
  if (length(lens) == 0) 
    return(matrix(character(), 0, length(methods@arguments)))
  if (length(lens) > 1) {
    lens <- max(lens)
    anys <- rep("ANY", lens)
    sigs <- lapply(sigs, function(x) {
      if (length(x) < lens) {
        anys[seq_along(x)] <- x
        anys
      }
      else x
    })
  }
  length(what) <- lens
  t(matrix(unlist(sigs), nrow = lens, dimnames = list(what, NULL)))
}, function (..., target = TRUE, methods = findMethods(...)) 
{
  what <- methods@arguments
  if (target) 
    sigs <- methods@signatures
  else {
    anySig <- rep("ANY", length(what))
    for (m in methods) if (!is.primitive(m)) {
      length(anySig) <- length(m@defined)
      break
    }
    sigs <- lapply(methods, function(x) if (is.primitive(x)) 
      anySig
      else as.character(x@defined))
  }
  lens <- unique(vapply(sigs, length, 1, USE.NAMES = FALSE))
  if (length(lens) == 0) 
    return(matrix(character(), 0, length(methods@arguments)))
  if (length(lens) > 1) {
    lens <- max(lens)
    anys <- rep("ANY", lens)
    sigs <- lapply(sigs, function(x) {
      if (length(x) < lens) {
        anys[seq_along(x)] <- x
        anys
      }
      else x
    })
  }
  length(what) <- lens
  t(matrix(unlist(sigs), nrow = lens, dimnames = list(what, NULL)))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
findUnique
list(`package:methods` = function (what, message, where = topenv(parent.frame())) 
{
  where <- .findAll(what, where = where)
  if (length(where) > 1) {
    if (missing(message)) 
      message <- sQuote(what)
    if (is.list(where)) 
      where <- unlist(where)
    if (is.numeric(where)) 
      where <- search()[where]
    warning(message, sprintf(" found on: %s; using the first one", paste(sQuote(where), collapse = ", ")), domain = NA)
    where <- where[1]
  }
  where
}, function (what, message, where = topenv(parent.frame())) 
{
  where <- .findAll(what, where = where)
  if (length(where) > 1) {
    if (missing(message)) 
      message <- sQuote(what)
    if (is.list(where)) 
      where <- unlist(where)
    if (is.numeric(where)) 
      where <- search()[where]
    warning(message, sprintf(" found on: %s; using the first one", paste(sQuote(where), collapse = ", ")), domain = NA)
    where <- where[1]
  }
  where
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
fixPre1.8
list(`package:methods` = function (names, where = topenv(parent.frame())) 
{
  done <- character()
  for (what in names) {
    objWhere <- .findAll(what, where)
    if (length(objWhere) == 0) {
      warning(gettextf("object %s not found", sQuote(what)), domain = NA)
      next
    }
    objWhere <- objWhere[[1]]
    obj <- get(what, objWhere)
    if (is.null(attr(obj, "class"))) 
      next
    Class <- class(obj)
    if (is.null(attr(Class, "package"))) {
      if (isClass(Class, where = where)) {
        ClassDef <- getClass(Class, where = where)
        ok <- !(isVirtualClass(ClassDef) || !isTRUE(validObject(obj, test = TRUE)))
        if (ok) {
          class(obj) <- ClassDef@className
          assign(what, obj, objWhere)
          done <- c(done, what)
        }
        else warning(gettextf("object %s not changed (it is not consistent with the current definition of class %s from %s)", sQuote(what), dQuote(Class), sQuote(ClassDef@package)), domain = NA)
      }
      else warning(gettextf("no definition for the class of %s (class %s) found", sQuote(what), dQuote(class)), domain = NA)
    }
    else warning(gettextf("object %s not changed (it does not appear to be from a version of R earlier than 1.8.0)", sQuote(what)), domain = NA)
  }
  done
}, function (names, where = topenv(parent.frame())) 
{
  done <- character()
  for (what in names) {
    objWhere <- .findAll(what, where)
    if (length(objWhere) == 0) {
      warning(gettextf("object %s not found", sQuote(what)), domain = NA)
      next
    }
    objWhere <- objWhere[[1]]
    obj <- get(what, objWhere)
    if (is.null(attr(obj, "class"))) 
      next
    Class <- class(obj)
    if (is.null(attr(Class, "package"))) {
      if (isClass(Class, where = where)) {
        ClassDef <- getClass(Class, where = where)
        ok <- !(isVirtualClass(ClassDef) || !isTRUE(validObject(obj, test = TRUE)))
        if (ok) {
          class(obj) <- ClassDef@className
          assign(what, obj, objWhere)
          done <- c(done, what)
        }
        else warning(gettextf("object %s not changed (it is not consistent with the current definition of class %s from %s)", sQuote(what), dQuote(Class), sQuote(ClassDef@package)), domain = NA)
      }
      else warning(gettextf("no definition for the class of %s (class %s) found", sQuote(what), dQuote(class)), domain = NA)
    }
    else warning(gettextf("object %s not changed (it does not appear to be from a version of R earlier than 1.8.0)", sQuote(what)), domain = NA)
  }
  done
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
formalArgs
list(`package:methods` = function (def) 
  names(formals(def, envir = parent.frame())), function (def) 
    names(formals(def, envir = parent.frame())))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
functionBody
list(`package:methods` = function (fun = sys.function(sys.parent())) 
{
  if (is.character(fun)) 
    fun <- get(fun, mode = "function", envir = parent.frame())
  .Internal(body(fun))
}, function (fun = sys.function(sys.parent())) 
{
  if (is.character(fun)) 
    fun <- get(fun, mode = "function", envir = parent.frame())
  .Internal(body(fun))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
functionBody<-
  list(`package:methods` = function (fun, envir = environment(fun), value) 
  {
    if (!is.function(fun)) 
      warning("'fun' is not a function")
    if (is.expression(value)) {
      if (length(value) > 1) 
        warning("using the first element of 'value' of type \"expression\"")
      value <- value[[1]]
    }
    as.function(c(as.list(formals(fun)), list(value)), envir)
  }, function (fun, envir = environment(fun), value) 
  {
    if (!is.function(fun)) 
      warning("'fun' is not a function")
    if (is.expression(value)) {
      if (length(value) > 1) 
        warning("using the first element of 'value' of type \"expression\"")
      value <- value[[1]]
    }
    as.function(c(as.list(formals(fun)), list(value)), envir)
  })
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
generic.skeleton
list(`package:methods` = function (name, fdef, fdefault) 
{
  anames <- formalArgs(fdef)
  skeleton <- lapply(as.list(c(name, anames)), as.name)
  dots <- match("...", anames)
  if (!is.na(dots) && dots < length(anames)) {
    anames[1:dots] <- ""
    names(skeleton) <- c("", anames)
  }
  if (is.null(fdefault)) {
    fdefault <- fdef
    msg <- "invalid call in method dispatch to '%s' (no default method)"
    body(fdefault) <- substitute(stop(gettextf(MSG, NAME), domain = NA), list(MSG = msg, NAME = name))
    environment(fdefault) <- baseenv()
  }
  skeleton[[1]] <- fdefault
  as.call(skeleton)
}, function (name, fdef, fdefault) 
{
  anames <- formalArgs(fdef)
  skeleton <- lapply(as.list(c(name, anames)), as.name)
  dots <- match("...", anames)
  if (!is.na(dots) && dots < length(anames)) {
    anames[1:dots] <- ""
    names(skeleton) <- c("", anames)
  }
  if (is.null(fdefault)) {
    fdefault <- fdef
    msg <- "invalid call in method dispatch to '%s' (no default method)"
    body(fdefault) <- substitute(stop(gettextf(MSG, NAME), domain = NA), list(MSG = msg, NAME = name))
    environment(fdefault) <- baseenv()
  }
  skeleton[[1]] <- fdefault
  as.call(skeleton)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getAllSuperClasses
list(`package:methods` = function (ClassDef, simpleOnly = TRUE) 
{
  temp <- superClassDepth(ClassDef, simpleOnly = simpleOnly)
  unique(temp$label[sort.list(temp$depth)])
}, function (ClassDef, simpleOnly = TRUE) 
{
  temp <- superClassDepth(ClassDef, simpleOnly = simpleOnly)
  unique(temp$label[sort.list(temp$depth)])
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getClass
list(`package:methods` = function (Class, .Force = FALSE, where = .classEnv(Class, topenv(parent.frame()), FALSE)) 
{
  value <- getClassDef(Class, where)
  if (is.null(value)) {
    if (!.Force) 
      stop(gettextf("%s is not a defined class", dQuote(Class)), domain = NA)
    else value <- makeClassRepresentation(Class, package = "base", virtual = TRUE, where = where)
  }
  value
}, function (Class, .Force = FALSE, where = .classEnv(Class, topenv(parent.frame()), FALSE)) 
{
  value <- getClassDef(Class, where)
  if (is.null(value)) {
    if (!.Force) 
      stop(gettextf("%s is not a defined class", dQuote(Class)), domain = NA)
    else value <- makeClassRepresentation(Class, package = "base", virtual = TRUE, where = where)
  }
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getClassDef
list(`package:methods` = function (Class, where = topenv(parent.frame()), package = packageSlot(Class), inherits = TRUE) 
{
  if (inherits) {
    value <- .getClassesFromCache(Class)
    if (is.list(value)) 
      value <- .resolveClassList(value, where, package)
  }
  else value <- NULL
  if (is.null(value)) {
    cname <- classMetaName(if (length(Class) > 1) 
      Class[[1]]
      else Class)
    if (is.character(where)) {
      package <- where
    }
    if (isTRUE(nzchar(package))) {
      package <- .requirePackage(package)
    }
    if (is.environment(package)) {
      value <- get0(cname, package, inherits = inherits)
    }
    if (is.null(value)) 
      value <- get0(cname, where, inherits = inherits)
  }
  value
}, function (Class, where = topenv(parent.frame()), package = packageSlot(Class), inherits = TRUE) 
{
  if (inherits) {
    value <- .getClassesFromCache(Class)
    if (is.list(value)) 
      value <- .resolveClassList(value, where, package)
  }
  else value <- NULL
  if (is.null(value)) {
    cname <- classMetaName(if (length(Class) > 1) 
      Class[[1]]
      else Class)
    if (is.character(where)) {
      package <- where
    }
    if (isTRUE(nzchar(package))) {
      package <- .requirePackage(package)
    }
    if (is.environment(package)) {
      value <- get0(cname, package, inherits = inherits)
    }
    if (is.null(value)) 
      value <- get0(cname, where, inherits = inherits)
  }
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getClasses
list(`package:methods` = function (where = .externalCallerEnv(), inherits = missing(where)) 
{
  pat <- paste0("^", classMetaName(""))
  if (!is.environment(where)) 
    where <- as.environment(where)
  if (inherits) {
    evList <- .parentEnvList(where)
    clNames <- character()
    for (ev in evList) clNames <- c(clNames, grep(pat, names(ev), value = TRUE))
    clNames <- unique(clNames)
  }
  else clNames <- grep(pat, names(where), value = TRUE)
  substring(clNames, nchar(pat, "c"))
}, function (where = .externalCallerEnv(), inherits = missing(where)) 
{
  pat <- paste0("^", classMetaName(""))
  if (!is.environment(where)) 
    where <- as.environment(where)
  if (inherits) {
    evList <- .parentEnvList(where)
    clNames <- character()
    for (ev in evList) clNames <- c(clNames, grep(pat, names(ev), value = TRUE))
    clNames <- unique(clNames)
  }
  else clNames <- grep(pat, names(where), value = TRUE)
  substring(clNames, nchar(pat, "c"))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getDataPart
list(`package:methods` = function (object, NULL.for.none = FALSE) 
{
  if (typeof(object) == "S4") {
    value <- attr(object, ".Data")
    if (is.null(value)) {
      value <- attr(object, ".xData")
      if (is.null(value) && !NULL.for.none) 
        stop("Data part is undefined for general S4 object")
    }
    return(if (identical(value, .pseudoNULL)) NULL else value)
  }
  temp <- getClass(class(object))@slots
  if (length(temp) == 0) 
    return(object)
  if (is.na(match(".Data", names(temp)))) {
    if (NULL.for.none) 
      return(NULL)
    else stop(gettextf("no '.Data' slot defined for class %s", dQuote(class(object))), domain = NA)
  }
  dataPart <- temp[[".Data"]]
  switch(dataPart, numeric = , vector = , integer = , character = , logical = , complex = , list = attributes(object) <- NULL, matrix = , array = {
    value <- object
    attributes(value) <- NULL
    attr(value, "dim") <- attr(object, "dim")
    attr(value, "dimnames") <- attr(object, "dimnames")
    object <- value
  }, ts = {
    value <- object
    attributes(value) <- NULL
    attr(value, "ts") <- attr(object, "ts")
    object <- value
  }, if (is.na(match(dataPart, .BasicClasses))) {
    attrVals <- attributes(object)
    attrs <- names(attrVals)
    attrs <- attrs[is.na(match(attrs, c("class", names(temp))))]
    attributes(object) <- attrVals[attrs]
  } else attributes(object) <- NULL)
  object
}, function (object, NULL.for.none = FALSE) 
{
  if (typeof(object) == "S4") {
    value <- attr(object, ".Data")
    if (is.null(value)) {
      value <- attr(object, ".xData")
      if (is.null(value) && !NULL.for.none) 
        stop("Data part is undefined for general S4 object")
    }
    return(if (identical(value, .pseudoNULL)) NULL else value)
  }
  temp <- getClass(class(object))@slots
  if (length(temp) == 0) 
    return(object)
  if (is.na(match(".Data", names(temp)))) {
    if (NULL.for.none) 
      return(NULL)
    else stop(gettextf("no '.Data' slot defined for class %s", dQuote(class(object))), domain = NA)
  }
  dataPart <- temp[[".Data"]]
  switch(dataPart, numeric = , vector = , integer = , character = , logical = , complex = , list = attributes(object) <- NULL, matrix = , array = {
    value <- object
    attributes(value) <- NULL
    attr(value, "dim") <- attr(object, "dim")
    attr(value, "dimnames") <- attr(object, "dimnames")
    object <- value
  }, ts = {
    value <- object
    attributes(value) <- NULL
    attr(value, "ts") <- attr(object, "ts")
    object <- value
  }, if (is.na(match(dataPart, .BasicClasses))) {
    attrVals <- attributes(object)
    attrs <- names(attrVals)
    attrs <- attrs[is.na(match(attrs, c("class", names(temp))))]
    attributes(object) <- attrVals[attrs]
  } else attributes(object) <- NULL)
  object
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getFunction
list(`package:methods` = function (name, generic = TRUE, mustFind = TRUE, where = topenv(parent.frame())) 
{
  if (!nzchar(name)) 
    stop(gettextf("expected a non-empty character string for argument name"), domain = NA)
  found <- FALSE
  where <- as.environment(where)
  f <- NULL
  lastEnv <- if (isNamespace(where)) 
    function(where) isBaseNamespace(where)
  else function(where) identical(where, baseenv())
  repeat {
    if (!is.null(f <- get0(name, envir = where, mode = "function", inherits = FALSE))) 
      found <- generic || !is(f, "genericFunction")
    if (found || lastEnv(where)) 
      break
    where <- parent.env(where)
  }
  if (!found && mustFind) 
    stop(if (generic) 
      gettextf("no function %s found", sQuote(name))
      else gettextf("no non-generic function %s found", sQuote(name)), domain = NA)
  f
}, function (name, generic = TRUE, mustFind = TRUE, where = topenv(parent.frame())) 
{
  if (!nzchar(name)) 
    stop(gettextf("expected a non-empty character string for argument name"), domain = NA)
  found <- FALSE
  where <- as.environment(where)
  f <- NULL
  lastEnv <- if (isNamespace(where)) 
    function(where) isBaseNamespace(where)
  else function(where) identical(where, baseenv())
  repeat {
    if (!is.null(f <- get0(name, envir = where, mode = "function", inherits = FALSE))) 
      found <- generic || !is(f, "genericFunction")
    if (found || lastEnv(where)) 
      break
    where <- parent.env(where)
  }
  if (!found && mustFind) 
    stop(if (generic) 
      gettextf("no function %s found", sQuote(name))
      else gettextf("no non-generic function %s found", sQuote(name)), domain = NA)
  f
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getGeneric
list(`package:methods` = function (f, mustFind = FALSE, where, package = "") 
{
  if (is.function(f)) {
    if (is(f, "genericFunction")) 
      return(f)
    else if (is.primitive(f)) 
      return(genericForBasic(.primname(f), mustFind = mustFind))
    else stop("argument 'f' must be a string, generic function, or primitive: got an ordinary function")
  }
  value <- if (missing(where)) 
    .getGeneric(f, , package)
  else .getGeneric(f, where, package)
  if (is.null(value) && !is.null(baseDef <- baseenv()[[f]])) {
    if (is.function(baseDef)) {
      value <- genericForBasic(f, mustFind = FALSE)
      if (is(value, "genericFunction")) 
        value <- .cacheGeneric(f, value)
    }
  }
  if (is.function(value)) 
    value
  else {
    if (nzchar(package) && is.na(match(package, c("methods", "base")))) {
      value <- tryCatch({
        ev <- getNamespace(package)
        .getGeneric(f, ev, package)
      }, error = function(e) NULL)
    }
    if (is.function(value)) 
      value
    else if (mustFind) 
      stop(gettextf("no generic function found for %s", sQuote(f)), domain = NA)
    else NULL
  }
}, function (f, mustFind = FALSE, where, package = "") 
{
  if (is.function(f)) {
    if (is(f, "genericFunction")) 
      return(f)
    else if (is.primitive(f)) 
      return(genericForBasic(.primname(f), mustFind = mustFind))
    else stop("argument 'f' must be a string, generic function, or primitive: got an ordinary function")
  }
  value <- if (missing(where)) 
    .getGeneric(f, , package)
  else .getGeneric(f, where, package)
  if (is.null(value) && !is.null(baseDef <- baseenv()[[f]])) {
    if (is.function(baseDef)) {
      value <- genericForBasic(f, mustFind = FALSE)
      if (is(value, "genericFunction")) 
        value <- .cacheGeneric(f, value)
    }
  }
  if (is.function(value)) 
    value
  else {
    if (nzchar(package) && is.na(match(package, c("methods", "base")))) {
      value <- tryCatch({
        ev <- getNamespace(package)
        .getGeneric(f, ev, package)
      }, error = function(e) NULL)
    }
    if (is.function(value)) 
      value
    else if (mustFind) 
      stop(gettextf("no generic function found for %s", sQuote(f)), domain = NA)
    else NULL
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getGenerics
list(`package:methods` = function (where, searchForm = FALSE) 
{
  if (missing(where)) {
    fdefs <- as.list(.genericTable, all.names = TRUE, sorted = TRUE)
    fnames <- mapply(function(nm, obj) {
      if (is.list(obj)) 
        names(obj)
      else nm
    }, names(fdefs), fdefs, SIMPLIFY = FALSE)
    packages <- lapply(fdefs, .packageForGeneric)
    new("ObjectsWithPackage", unlist(fnames), package = unlist(packages))
  }
  else {
    if (is.environment(where)) 
      where <- list(where)
    these <- unlist(lapply(where, objects, all.names = TRUE), use.names = FALSE)
    metaNameUndo(unique(these), prefix = "T", searchForm = searchForm)
  }
}, function (where, searchForm = FALSE) 
{
  if (missing(where)) {
    fdefs <- as.list(.genericTable, all.names = TRUE, sorted = TRUE)
    fnames <- mapply(function(nm, obj) {
      if (is.list(obj)) 
        names(obj)
      else nm
    }, names(fdefs), fdefs, SIMPLIFY = FALSE)
    packages <- lapply(fdefs, .packageForGeneric)
    new("ObjectsWithPackage", unlist(fnames), package = unlist(packages))
  }
  else {
    if (is.environment(where)) 
      where <- list(where)
    these <- unlist(lapply(where, objects, all.names = TRUE), use.names = FALSE)
    metaNameUndo(unique(these), prefix = "T", searchForm = searchForm)
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getGroup
list(`package:methods` = function (fdef, recursive = FALSE, where = topenv(parent.frame())) 
{
  if (is.character(fdef)) 
    fdef <- getGeneric(fdef, where = where)
  if (is(fdef, "genericFunction")) 
    group <- fdef@group
  else group <- list()
  if (recursive && length(group)) {
    allGroups <- group
    for (gp in group) {
      fgp <- getGeneric(gp, where = where)
      if (is(fgp, "groupGenericFunction")) 
        allGroups <- c(allGroups, Recall(fgp, TRUE, where))
    }
    if (length(allGroups) > 1) {
      ids <- sapply(allGroups, function(x) {
        pkg <- packageSlot(x)
        if (is.null(pkg)) 
          x
        else paste(x, pkg, sep = ":")
      })
      allGroups <- allGroups[!duplicated(ids)]
    }
    allGroups
  }
  else group
}, function (fdef, recursive = FALSE, where = topenv(parent.frame())) 
{
  if (is.character(fdef)) 
    fdef <- getGeneric(fdef, where = where)
  if (is(fdef, "genericFunction")) 
    group <- fdef@group
  else group <- list()
  if (recursive && length(group)) {
    allGroups <- group
    for (gp in group) {
      fgp <- getGeneric(gp, where = where)
      if (is(fgp, "groupGenericFunction")) 
        allGroups <- c(allGroups, Recall(fgp, TRUE, where))
    }
    if (length(allGroups) > 1) {
      ids <- sapply(allGroups, function(x) {
        pkg <- packageSlot(x)
        if (is.null(pkg)) 
          x
        else paste(x, pkg, sep = ":")
      })
      allGroups <- allGroups[!duplicated(ids)]
    }
    allGroups
  }
  else group
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getGroupMembers
list(`package:methods` = function (group, recursive = FALSE, character = TRUE) 
{
  .recMembers <- function(members, where) {
    all = vector("list", length(members))
    for (i in seq_along(members)) {
      what <- members[[i]]
      f <- getGeneric(what, FALSE, where)
      if (!is.null(f)) 
        all[[i]] <- what
      if (is(f, "groupGenericFunction")) {
        newMem <- f@groupMembers
        all <- c(all, Recall(newMem, where))
      }
    }
    all
  }
  f <- getGeneric(group)
  if (is.null(f)) {
    warning(gettextf("%s is not a generic function (or not visible here)", sQuote(f)), domain = NA)
    return(character())
  }
  else if (!is(f, "groupGenericFunction")) 
    character()
  else {
    members <- f@groupMembers
    if (recursive) {
      where <- f@package
      if (identical(where, "base")) {
        where <- "methods"
        members <- .recMembers(members, .methodsNamespace)
      }
      else members <- .recMembers(members, .requirePackage(where))
    }
    if (character) 
      sapply(members, function(x) {
        if (is(x, "character")) 
          x
        else if (is(x, "genericFunction")) 
          x@generic
        else stop(gettextf("invalid element in the \"groupMembers\" slot (class %s)", dQuote(class(x))), domain = NA)
      })
    else members
  }
}, function (group, recursive = FALSE, character = TRUE) 
{
  .recMembers <- function(members, where) {
    all = vector("list", length(members))
    for (i in seq_along(members)) {
      what <- members[[i]]
      f <- getGeneric(what, FALSE, where)
      if (!is.null(f)) 
        all[[i]] <- what
      if (is(f, "groupGenericFunction")) {
        newMem <- f@groupMembers
        all <- c(all, Recall(newMem, where))
      }
    }
    all
  }
  f <- getGeneric(group)
  if (is.null(f)) {
    warning(gettextf("%s is not a generic function (or not visible here)", sQuote(f)), domain = NA)
    return(character())
  }
  else if (!is(f, "groupGenericFunction")) 
    character()
  else {
    members <- f@groupMembers
    if (recursive) {
      where <- f@package
      if (identical(where, "base")) {
        where <- "methods"
        members <- .recMembers(members, .methodsNamespace)
      }
      else members <- .recMembers(members, .requirePackage(where))
    }
    if (character) 
      sapply(members, function(x) {
        if (is(x, "character")) 
          x
        else if (is(x, "genericFunction")) 
          x@generic
        else stop(gettextf("invalid element in the \"groupMembers\" slot (class %s)", dQuote(class(x))), domain = NA)
      })
    else members
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getLoadActions
list(`package:methods` = function (where = topenv(parent.frame())) 
{
  actionListName <- .actionMetaName("")
  if (!exists(actionListName, envir = where, inherits = FALSE)) 
    return(list())
  actions <- get(actionListName, envir = where)
  if (length(actions)) {
    allExists <- sapply(actions, function(what) exists(.actionMetaName(what), envir = where, inherits = FALSE))
    if (!all(allExists)) {
      warning(gettextf("some actions are missing: %s", paste(actions[!allExists], collapse = ", ")), domain = NA)
      actions <- actions[allExists]
    }
    allFuns <- lapply(actions, function(what) get(.actionMetaName(what), envir = where))
    names(allFuns) <- actions
    allFuns
  }
  else list()
}, function (where = topenv(parent.frame())) 
{
  actionListName <- .actionMetaName("")
  if (!exists(actionListName, envir = where, inherits = FALSE)) 
    return(list())
  actions <- get(actionListName, envir = where)
  if (length(actions)) {
    allExists <- sapply(actions, function(what) exists(.actionMetaName(what), envir = where, inherits = FALSE))
    if (!all(allExists)) {
      warning(gettextf("some actions are missing: %s", paste(actions[!allExists], collapse = ", ")), domain = NA)
      actions <- actions[allExists]
    }
    allFuns <- lapply(actions, function(what) get(.actionMetaName(what), envir = where))
    names(allFuns) <- actions
    allFuns
  }
  else list()
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getMethod
list(`package:methods` = function (f, signature = character(), where = topenv(parent.frame()), optional = FALSE, mlist, fdef) 
{
  if (!missing(where)) {
    env <- .NamespaceOrEnvironment(where)
    if (is.null(env)) 
      stop(gettextf("no environment or package corresponding to argument where=%s", deparse(where)), domain = NA)
    where <- env
  }
  if (missing(fdef)) {
    if (missing(where)) 
      fdef <- getGeneric(f, FALSE)
    else {
      fdef <- getGeneric(f, FALSE, where = where)
      if (is.null(fdef)) 
        fdef <- getGeneric(f, FALSE)
    }
  }
  if (!is(fdef, "genericFunction")) {
    if (optional) 
      return(NULL)
    if (!is.character(f)) 
      f <- deparse1(substitute(f))
    stop(gettextf("no generic function found for '%s'", f), domain = NA)
  }
  if (missing(mlist)) 
    mlist <- if (missing(where)) 
      getMethodsForDispatch(fdef)
  else .getMethodsTableMetaData(fdef, where, optional)
  if (is.environment(mlist)) {
    signature <- matchSignature(signature, fdef)
    value <- .findMethodInTable(signature, mlist, fdef)
    if (is.null(value) && !optional) {
      if (!is.character(f)) 
        f <- deparse1(substitute(f))
      stop(gettextf("no method found for function '%s' and signature %s", f, paste(signature, collapse = ", ")))
    }
    return(value)
  }
  else if (is.null(mlist)) 
    return(mlist)
  stop("defunct methods list search", domain = NA)
}, function (f, signature = character(), where = topenv(parent.frame()), optional = FALSE, mlist, fdef) 
{
  if (!missing(where)) {
    env <- .NamespaceOrEnvironment(where)
    if (is.null(env)) 
      stop(gettextf("no environment or package corresponding to argument where=%s", deparse(where)), domain = NA)
    where <- env
  }
  if (missing(fdef)) {
    if (missing(where)) 
      fdef <- getGeneric(f, FALSE)
    else {
      fdef <- getGeneric(f, FALSE, where = where)
      if (is.null(fdef)) 
        fdef <- getGeneric(f, FALSE)
    }
  }
  if (!is(fdef, "genericFunction")) {
    if (optional) 
      return(NULL)
    if (!is.character(f)) 
      f <- deparse1(substitute(f))
    stop(gettextf("no generic function found for '%s'", f), domain = NA)
  }
  if (missing(mlist)) 
    mlist <- if (missing(where)) 
      getMethodsForDispatch(fdef)
  else .getMethodsTableMetaData(fdef, where, optional)
  if (is.environment(mlist)) {
    signature <- matchSignature(signature, fdef)
    value <- .findMethodInTable(signature, mlist, fdef)
    if (is.null(value) && !optional) {
      if (!is.character(f)) 
        f <- deparse1(substitute(f))
      stop(gettextf("no method found for function '%s' and signature %s", f, paste(signature, collapse = ", ")))
    }
    return(value)
  }
  else if (is.null(mlist)) 
    return(mlist)
  stop("defunct methods list search", domain = NA)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getMethods
list(`package:methods` = function (f, where = topenv(parent.frame()), table = FALSE) 
{
  if (!table) 
    .MlistDefunct("getMethods", "findMethods")
  nowhere <- missing(where)
  fdef <- getGeneric(f, where = where)
  f <- fdef@generic
  if (!is.null(fdef)) {
    if (table) 
      return(getMethodsForDispatch(fdef, TRUE))
  }
}, function (f, where = topenv(parent.frame()), table = FALSE) 
{
  if (!table) 
    .MlistDefunct("getMethods", "findMethods")
  nowhere <- missing(where)
  fdef <- getGeneric(f, where = where)
  f <- fdef@generic
  if (!is.null(fdef)) {
    if (table) 
      return(getMethodsForDispatch(fdef, TRUE))
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getMethodsForDispatch
list(`package:methods` = function (fdef, inherited = FALSE) 
{
  .getMethodsTable(fdef, environment(fdef), inherited = inherited)
}, function (fdef, inherited = FALSE) 
{
  .getMethodsTable(fdef, environment(fdef), inherited = inherited)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getMethodsMetaData
list(`package:methods` = function (f, where = topenv(parent.frame())) 
{
  fdef <- getGeneric(f, where = where)
  if (is.null(fdef)) 
    return(NULL)
  if (.noMlists()) {
    warning(sprintf("Methods list objects are not maintained in this version of R:  request for function %s may return incorrect information", sQuote(fdef@generic)), domain = NA)
  }
  mname <- methodsPackageMetaName("M", fdef@generic, fdef@package)
  if (exists(mname, where = where, inherits = missing(where))) 
    get(mname, where)
  else if (missing(where)) 
    .makeMlistFromTable(fdef)
  else .makeMlistFromTable(fdef, where)
}, function (f, where = topenv(parent.frame())) 
{
  fdef <- getGeneric(f, where = where)
  if (is.null(fdef)) 
    return(NULL)
  if (.noMlists()) {
    warning(sprintf("Methods list objects are not maintained in this version of R:  request for function %s may return incorrect information", sQuote(fdef@generic)), domain = NA)
  }
  mname <- methodsPackageMetaName("M", fdef@generic, fdef@package)
  if (exists(mname, where = where, inherits = missing(where))) 
    get(mname, where)
  else if (missing(where)) 
    .makeMlistFromTable(fdef)
  else .makeMlistFromTable(fdef, where)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getPackageName
list(`package:methods` = function (where = topenv(parent.frame()), create = TRUE) 
{
  env <- as.environment(where)
  pkg <- get0(".packageName", env, inherits = FALSE)
  saved <- !is.null(pkg)
  if (saved) {
    return(pkg)
  }
  else {
    pkg <- if (identical(where, 1) || identical(env, topenv(parent.frame()))) 
      Sys.getenv("R_PACKAGE_NAME")
    else ""
  }
  envName <- environmentName(env)
  if (nzchar(envName) && regexpr("package:", envName, fixed = TRUE) == 1) 
    pkg <- .rmpkg(envName)
  if (!nzchar(pkg)) {
    if (identical(env, .GlobalEnv)) 
      pkg <- ".GlobalEnv"
    else if (identical(env, .BaseNamespaceEnv)) 
      pkg <- "base"
    else {
      if (is.numeric(where)) 
        pkg <- search()[[where]]
      else if (is.environment(where)) {
        for (db in search()) if (identical(as.environment(db), where)) {
          pkg <- db
          break
        }
      }
      else if (nzchar(envName)) 
        pkg <- envName
      else pkg <- as.character(where)
      pkg <- .rmpkg(pkg)
    }
  }
  if (!nzchar(pkg)) {
    top <- topenv(env)
    if (!identical(top, env)) {
      pkg <- getPackageName(top, create = create)
    }
  }
  if (!nzchar(pkg) && create) {
    pkg <- as.character(Sys.time())
    warning(gettextf("Created a package name, %s, when none found", sQuote(pkg)), domain = NA)
    if (!saved && !environmentIsLocked(env)) 
      setPackageName(pkg, env)
  }
  pkg
}, function (where = topenv(parent.frame()), create = TRUE) 
{
  env <- as.environment(where)
  pkg <- get0(".packageName", env, inherits = FALSE)
  saved <- !is.null(pkg)
  if (saved) {
    return(pkg)
  }
  else {
    pkg <- if (identical(where, 1) || identical(env, topenv(parent.frame()))) 
      Sys.getenv("R_PACKAGE_NAME")
    else ""
  }
  envName <- environmentName(env)
  if (nzchar(envName) && regexpr("package:", envName, fixed = TRUE) == 1) 
    pkg <- .rmpkg(envName)
  if (!nzchar(pkg)) {
    if (identical(env, .GlobalEnv)) 
      pkg <- ".GlobalEnv"
    else if (identical(env, .BaseNamespaceEnv)) 
      pkg <- "base"
    else {
      if (is.numeric(where)) 
        pkg <- search()[[where]]
      else if (is.environment(where)) {
        for (db in search()) if (identical(as.environment(db), where)) {
          pkg <- db
          break
        }
      }
      else if (nzchar(envName)) 
        pkg <- envName
      else pkg <- as.character(where)
      pkg <- .rmpkg(pkg)
    }
  }
  if (!nzchar(pkg)) {
    top <- topenv(env)
    if (!identical(top, env)) {
      pkg <- getPackageName(top, create = create)
    }
  }
  if (!nzchar(pkg) && create) {
    pkg <- as.character(Sys.time())
    warning(gettextf("Created a package name, %s, when none found", sQuote(pkg)), domain = NA)
    if (!saved && !environmentIsLocked(env)) 
      setPackageName(pkg, env)
  }
  pkg
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getRefClass
list(`package:methods` = function (Class, where = topenv(parent.frame())) 
{
  if (is(Class, "refClassRepresentation")) {
    classDef <- Class
    Class <- classDef@className
  }
  else if (is.character(Class)) {
    classDef <- getClass(Class, where = where)
    if (!is(classDef, "refClassRepresentation")) 
      stop(gettextf("class %s is defined but is not a reference class", dQuote(Class)), domain = NA)
  }
  else stop(gettextf("class must be a reference class representation or a character string; got an object of class %s", dQuote(class(Class))), domain = NA)
  generator <- new("refGeneratorSlot")
  env <- as.environment(generator)
  env$className <- Class
  env$def <- classDef
  classFun <- classGeneratorFunction(Class, where)
  classFun@package <- classDef@package
  new("refObjectGenerator", classFun, generator = generator)
}, function (Class, where = topenv(parent.frame())) 
{
  if (is(Class, "refClassRepresentation")) {
    classDef <- Class
    Class <- classDef@className
  }
  else if (is.character(Class)) {
    classDef <- getClass(Class, where = where)
    if (!is(classDef, "refClassRepresentation")) 
      stop(gettextf("class %s is defined but is not a reference class", dQuote(Class)), domain = NA)
  }
  else stop(gettextf("class must be a reference class representation or a character string; got an object of class %s", dQuote(class(Class))), domain = NA)
  generator <- new("refGeneratorSlot")
  env <- as.environment(generator)
  env$className <- Class
  env$def <- classDef
  classFun <- classGeneratorFunction(Class, where)
  classFun@package <- classDef@package
  new("refObjectGenerator", classFun, generator = generator)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getSlots
list(`package:methods` = function (x) 
{
  classDef <- if (isClassDef(x)) 
    x
  else getClass(x)
  props <- classDef@slots
  value <- as.character(props)
  names(value) <- names(props)
  value
}, function (x) 
{
  classDef <- if (isClassDef(x)) 
    x
  else getClass(x)
  props <- classDef@slots
  value <- as.character(props)
  names(value) <- names(props)
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
getValidity
list(`package:methods` = function (ClassDef) 
{
  ClassDef@validity
}, function (ClassDef) 
{
  ClassDef@validity
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
hasArg
list(`package:methods` = function (name) 
{
  aname <- as.character(substitute(name))
  fnames <- names(formals(sys.function(sys.parent())))
  if (is.na(match(aname, fnames))) {
    if (is.na(match("...", fnames))) 
      FALSE
    else {
      dotsCall <- eval(quote(substitute(list(...))), sys.parent())
      !is.na(match(aname, names(dotsCall)))
    }
  }
  else eval(substitute(!missing(name)), sys.frame(sys.parent()))
}, function (name) 
{
  aname <- as.character(substitute(name))
  fnames <- names(formals(sys.function(sys.parent())))
  if (is.na(match(aname, fnames))) {
    if (is.na(match("...", fnames))) 
      FALSE
    else {
      dotsCall <- eval(quote(substitute(list(...))), sys.parent())
      !is.na(match(aname, names(dotsCall)))
    }
  }
  else eval(substitute(!missing(name)), sys.frame(sys.parent()))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
hasLoadAction
list(`package:methods` = function (aname, where = topenv(parent.frame())) 
  exists(.actionMetaName(aname), envir = where, inherits = FALSE), function (aname, where = topenv(parent.frame())) 
    exists(.actionMetaName(aname), envir = where, inherits = FALSE))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
hasMethod
list(`package:methods` = function (f, signature = character(), where = .genEnv(f, topenv(parent.frame()))) 
{
  fdef <- getGeneric(f, where = where)
  if (is.null(fdef)) 
    FALSE
  else !is.null(selectMethod(f, signature, optional = TRUE, fdef = fdef))
}, function (f, signature = character(), where = .genEnv(f, topenv(parent.frame()))) 
{
  fdef <- getGeneric(f, where = where)
  if (is.null(fdef)) 
    FALSE
  else !is.null(selectMethod(f, signature, optional = TRUE, fdef = fdef))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
hasMethods
list(`package:methods` = function (f, where, package = "") 
{
  fdef <- NULL
  nowhere <- missing(where)
  if (is(f, "genericFunction")) {
    fdef <- f
    f <- fdef@generic
    if (missing(package)) 
      package <- fdef@package
  }
  else if (!.isSingleString(f)) 
    stop(gettextf("argument 'f' must be a generic function or %s", .notSingleString(f)), domain = NA)
  else if (missing(package)) {
    package <- packageSlot(f)
    if (is.null(package)) {
      if (missing(where)) 
        fdef <- getGeneric(f)
      else {
        fdef <- getGeneric(f, where = where)
        if (is.null(fdef)) 
          fdef <- getGeneric(f)
      }
      if (is(fdef, "genericFunction")) 
        package <- fdef@package
      else stop(gettextf("'%s' is not a known generic function {and 'package' not specified}", f), domain = NA)
    }
  }
  what <- .TableMetaName(f, package)
  testEv <- function(ev) exists(what, envir = ev, inherits = FALSE) && length(names(get(what, envir = ev))) > 0
  if (nowhere) {
    for (i in seq_along(search())) {
      if (testEv(as.environment(i))) 
        return(TRUE)
    }
    return(FALSE)
  }
  else testEv(as.environment(where))
}, function (f, where, package = "") 
{
  fdef <- NULL
  nowhere <- missing(where)
  if (is(f, "genericFunction")) {
    fdef <- f
    f <- fdef@generic
    if (missing(package)) 
      package <- fdef@package
  }
  else if (!.isSingleString(f)) 
    stop(gettextf("argument 'f' must be a generic function or %s", .notSingleString(f)), domain = NA)
  else if (missing(package)) {
    package <- packageSlot(f)
    if (is.null(package)) {
      if (missing(where)) 
        fdef <- getGeneric(f)
      else {
        fdef <- getGeneric(f, where = where)
        if (is.null(fdef)) 
          fdef <- getGeneric(f)
      }
      if (is(fdef, "genericFunction")) 
        package <- fdef@package
      else stop(gettextf("'%s' is not a known generic function {and 'package' not specified}", f), domain = NA)
    }
  }
  what <- .TableMetaName(f, package)
  testEv <- function(ev) exists(what, envir = ev, inherits = FALSE) && length(names(get(what, envir = ev))) > 0
  if (nowhere) {
    for (i in seq_along(search())) {
      if (testEv(as.environment(i))) 
        return(TRUE)
    }
    return(FALSE)
  }
  else testEv(as.environment(where))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
implicitGeneric
list(`package:methods` = function (name, where = topenv(parent.frame()), generic = getGeneric(name, where = where)) 
{
  if (!nzchar(name)) 
    stop(gettextf("expected a non-empty character string for argument name"), domain = NA)
  if (!missing(generic) && is(generic, "genericFunction") && !.identC(name, generic@generic)) 
    stop(gettextf("generic function supplied was not created for %s", sQuote(name)), domain = NA)
  createGeneric <- (missing(generic) || !is(generic, "genericFunction")) && !isGeneric(name, where)
  if (createGeneric) {
    fdefault <- getFunction(name, where = where, mustFind = FALSE)
    if (is.null(fdefault)) 
      return(NULL)
    env <- environment(fdefault)
    fdefault <- .derivedDefaultMethod(fdefault)
    if (isBaseFun(fdefault)) {
      value <- genericForBasic(name)
      if (is.function(value)) {
        if (!missing(generic) && !identical(value, generic)) 
          stop(gettextf("%s is a primitive function; its generic form cannot be redefined", sQuote(name)), domain = NA)
        generic <- value
        fdefault <- generic@default
      }
      package <- "base"
    }
    else package <- getPackageName(env)
    group <- .getImplicitGroup(name, if (identical(package, "base")) 
      .methodsNamespace
      else environment(fdefault))
    if (missing(generic)) {
      generic <- .getImplicitGeneric(name, env, package)
      if (is.null(generic)) {
        generic <- makeGeneric(name, fdefault = fdefault, package = package, group = group)
        .cacheImplicitGeneric(name, generic)
      }
    }
    else {
      generic <- makeGeneric(name, generic, fdefault, package = package, group = group)
      .cacheImplicitGeneric(name, generic)
    }
  }
  generic
}, function (name, where = topenv(parent.frame()), generic = getGeneric(name, where = where)) 
{
  if (!nzchar(name)) 
    stop(gettextf("expected a non-empty character string for argument name"), domain = NA)
  if (!missing(generic) && is(generic, "genericFunction") && !.identC(name, generic@generic)) 
    stop(gettextf("generic function supplied was not created for %s", sQuote(name)), domain = NA)
  createGeneric <- (missing(generic) || !is(generic, "genericFunction")) && !isGeneric(name, where)
  if (createGeneric) {
    fdefault <- getFunction(name, where = where, mustFind = FALSE)
    if (is.null(fdefault)) 
      return(NULL)
    env <- environment(fdefault)
    fdefault <- .derivedDefaultMethod(fdefault)
    if (isBaseFun(fdefault)) {
      value <- genericForBasic(name)
      if (is.function(value)) {
        if (!missing(generic) && !identical(value, generic)) 
          stop(gettextf("%s is a primitive function; its generic form cannot be redefined", sQuote(name)), domain = NA)
        generic <- value
        fdefault <- generic@default
      }
      package <- "base"
    }
    else package <- getPackageName(env)
    group <- .getImplicitGroup(name, if (identical(package, "base")) 
      .methodsNamespace
      else environment(fdefault))
    if (missing(generic)) {
      generic <- .getImplicitGeneric(name, env, package)
      if (is.null(generic)) {
        generic <- makeGeneric(name, fdefault = fdefault, package = package, group = group)
        .cacheImplicitGeneric(name, generic)
      }
    }
    else {
      generic <- makeGeneric(name, generic, fdefault, package = package, group = group)
      .cacheImplicitGeneric(name, generic)
    }
  }
  generic
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
inheritedSlotNames
list(`package:methods` = function (Class, where = topenv(parent.frame())) 
{
  ext <- if (isClassDef(Class)) 
    Class@contains
  else if (isClass(Class, where = where)) 
    getClass(Class, where = where)@contains
  supcl <- .selectSuperClasses(ext, namesOnly = FALSE)
  supdefs <- lapply(supcl, function(s) {
    getClassDef(s@superClass, package = packageSlot(s))
  })
  unique(unlist(lapply(supdefs, slotNames), use.names = FALSE))
}, function (Class, where = topenv(parent.frame())) 
{
  ext <- if (isClassDef(Class)) 
    Class@contains
  else if (isClass(Class, where = where)) 
    getClass(Class, where = where)@contains
  supcl <- .selectSuperClasses(ext, namesOnly = FALSE)
  supdefs <- lapply(supcl, function(s) {
    getClassDef(s@superClass, package = packageSlot(s))
  })
  unique(unlist(lapply(supdefs, slotNames), use.names = FALSE))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
initFieldArgs
list(`package:methods` = function (.Object, classDef, selfEnv, ...) 
  initRefFields(.Object, classDef, selfEnv, list(...)), function (.Object, classDef, selfEnv, ...) 
    initRefFields(.Object, classDef, selfEnv, list(...)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
initialize
list(`package:methods` = new("nonstandardGenericFunction", .Data = function (.Object, ...) 
{
  value <- standardGeneric("initialize")
  if (!identical(class(value), class(.Object))) {
    cv <- class(value)
    co <- class(.Object)
    if (.identC(cv[[1]], co)) {
      if (length(cv) == 1 && is.na(match(cv, .BasicClasses))) {
        warning(gettextf("missing package slot (%s) in object of class %s (package info added)", packageSlot(co), dQuote(class(.Object))), domain = NA)
        class(value) <- class(.Object)
      }
      else return(value)
    }
    else stop(gettextf("'initialize' method returned an object of class %s instead of the required class %s", paste(dQuote(class(value)), collapse = ", "), dQuote(class(.Object))), domain = NA)
  }
  value
}, generic = "initialize", package = "methods", group = list(), valueClass = character(0), signature = ".Object", default = new("derivedDefaultMethod", .Data = function (.Object, ...) 
{
  args <- list(...)
  if (length(args)) {
    Class <- class(.Object)
    if (!is.na(match(Class, .BasicClasses))) 
      return(newBasic(Class, ...))
    ClassDef <- getClass(Class)
    snames <- allNames(args)
    which <- nzchar(snames)
    elements <- args[which]
    supers <- args[!which]
    thisExtends <- names(ClassDef@contains)
    slotDefs <- ClassDef@slots
    dataPart <- slotDefs[[".Data"]]
    if (is.null(dataPart)) 
      dataPart <- "missing"
    if (length(supers)) {
      for (i in rev(seq_along(supers))) {
        obj <- supers[[i]]
        Classi <- class(obj)
        if (length(Classi) > 1) 
          Classi <- Classi[[1]]
        if (.identC(Classi, Class)) 
          .Object <- obj
        else if (extends(Classi, Class)) 
          .Object <- as(obj, Class, strict = FALSE)
        else if (extends(Class, Classi)) 
          as(.Object, Classi) <- obj
        else if (extends(Classi, dataPart)) 
          .Object@.Data <- obj
        else {
          extendsi <- extends(Classi)[-1]
          which <- match(thisExtends, extendsi)
          which <- seq_along(which)[!is.na(which)]
          if (length(which)) {
            Classi <- thisExtends[which[1]]
            as(.Object, Classi) <- obj
          }
          else stop(gettextf("cannot use object of class %s in new():  class %s does not extend that class", dQuote(Classi), dQuote(Class)), domain = NA)
        }
      }
    }
    if (length(elements)) {
      snames <- names(elements)
      if (anyDuplicated(snames)) 
        stop(gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]), collapse = ", ")), domain = NA)
      which <- match(snames, names(slotDefs))
      if (anyNA(which)) 
        stop(sprintf(ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s", "invalid names for slots of class %s: %s"), dQuote(Class), paste(snames[is.na(which)], collapse = ", ")), domain = NA)
      firstTime <- TRUE
      for (i in seq_along(snames)) {
        slotName <- snames[[i]]
        slotClass <- slotDefs[[slotName]]
        slotClassDef <- getClassDef(slotClass, package = packageSlot(slotClass))
        slotVal <- elements[[i]]
        if (!.identC(class(slotVal), slotClass) && !is.null(slotClassDef)) {
          valClass <- class(slotVal)
          valClassDef <- getClassDef(valClass, package = ClassDef@package)
          if (!identical(possibleExtends(valClass, slotClass, valClassDef, slotClassDef), FALSE)) 
            slotVal <- as(slotVal, slotClass, strict = FALSE)
        }
        if (firstTime) {
          slot(.Object, slotName, check = FALSE) <- slotVal
          firstTime <- FALSE
        }
        else {
          `slot<-`(.Object, slotName, check = FALSE, slotVal)
        }
      }
    }
    validObject(.Object)
  }
  .Object
}, target = new("signature", .Data = "ANY", names = ".Object", package = "methods"), defined = new("signature", .Data = "ANY", names = ".Object", package = "methods"), generic = "initialize"), skeleton = (new("derivedDefaultMethod", .Data = function (.Object, ...) 
{
  args <- list(...)
  if (length(args)) {
    Class <- class(.Object)
    if (!is.na(match(Class, .BasicClasses))) 
      return(newBasic(Class, ...))
    ClassDef <- getClass(Class)
    snames <- allNames(args)
    which <- nzchar(snames)
    elements <- args[which]
    supers <- args[!which]
    thisExtends <- names(ClassDef@contains)
    slotDefs <- ClassDef@slots
    dataPart <- slotDefs[[".Data"]]
    if (is.null(dataPart)) 
      dataPart <- "missing"
    if (length(supers)) {
      for (i in rev(seq_along(supers))) {
        obj <- supers[[i]]
        Classi <- class(obj)
        if (length(Classi) > 1) 
          Classi <- Classi[[1]]
        if (.identC(Classi, Class)) 
          .Object <- obj
        else if (extends(Classi, Class)) 
          .Object <- as(obj, Class, strict = FALSE)
        else if (extends(Class, Classi)) 
          as(.Object, Classi) <- obj
        else if (extends(Classi, dataPart)) 
          .Object@.Data <- obj
        else {
          extendsi <- extends(Classi)[-1]
          which <- match(thisExtends, extendsi)
          which <- seq_along(which)[!is.na(which)]
          if (length(which)) {
            Classi <- thisExtends[which[1]]
            as(.Object, Classi) <- obj
          }
          else stop(gettextf("cannot use object of class %s in new():  class %s does not extend that class", dQuote(Classi), dQuote(Class)), domain = NA)
        }
      }
    }
    if (length(elements)) {
      snames <- names(elements)
      if (anyDuplicated(snames)) 
        stop(gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]), collapse = ", ")), domain = NA)
      which <- match(snames, names(slotDefs))
      if (anyNA(which)) 
        stop(sprintf(ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s", "invalid names for slots of class %s: %s"), dQuote(Class), paste(snames[is.na(which)], collapse = ", ")), domain = NA)
      firstTime <- TRUE
      for (i in seq_along(snames)) {
        slotName <- snames[[i]]
        slotClass <- slotDefs[[slotName]]
        slotClassDef <- getClassDef(slotClass, package = packageSlot(slotClass))
        slotVal <- elements[[i]]
        if (!.identC(class(slotVal), slotClass) && !is.null(slotClassDef)) {
          valClass <- class(slotVal)
          valClassDef <- getClassDef(valClass, package = ClassDef@package)
          if (!identical(possibleExtends(valClass, slotClass, valClassDef, slotClassDef), FALSE)) 
            slotVal <- as(slotVal, slotClass, strict = FALSE)
        }
        if (firstTime) {
          slot(.Object, slotName, check = FALSE) <- slotVal
          firstTime <- FALSE
        }
        else {
          `slot<-`(.Object, slotName, check = FALSE, slotVal)
        }
      }
    }
    validObject(.Object)
  }
  .Object
}, target = new("signature", .Data = "ANY", names = ".Object", package = "methods"), defined = new("signature", .Data = "ANY", names = ".Object", package = "methods"), generic = "initialize"))(.Object, ...)), new("nonstandardGenericFunction", .Data = function (.Object, ...) 
{
  value <- standardGeneric("initialize")
  if (!identical(class(value), class(.Object))) {
    cv <- class(value)
    co <- class(.Object)
    if (.identC(cv[[1]], co)) {
      if (length(cv) == 1 && is.na(match(cv, .BasicClasses))) {
        warning(gettextf("missing package slot (%s) in object of class %s (package info added)", packageSlot(co), dQuote(class(.Object))), domain = NA)
        class(value) <- class(.Object)
      }
      else return(value)
    }
    else stop(gettextf("'initialize' method returned an object of class %s instead of the required class %s", paste(dQuote(class(value)), collapse = ", "), dQuote(class(.Object))), domain = NA)
  }
  value
}, generic = "initialize", package = "methods", group = list(), valueClass = character(0), signature = ".Object", default = new("derivedDefaultMethod", .Data = function (.Object, ...) 
{
  args <- list(...)
  if (length(args)) {
    Class <- class(.Object)
    if (!is.na(match(Class, .BasicClasses))) 
      return(newBasic(Class, ...))
    ClassDef <- getClass(Class)
    snames <- allNames(args)
    which <- nzchar(snames)
    elements <- args[which]
    supers <- args[!which]
    thisExtends <- names(ClassDef@contains)
    slotDefs <- ClassDef@slots
    dataPart <- slotDefs[[".Data"]]
    if (is.null(dataPart)) 
      dataPart <- "missing"
    if (length(supers)) {
      for (i in rev(seq_along(supers))) {
        obj <- supers[[i]]
        Classi <- class(obj)
        if (length(Classi) > 1) 
          Classi <- Classi[[1]]
        if (.identC(Classi, Class)) 
          .Object <- obj
        else if (extends(Classi, Class)) 
          .Object <- as(obj, Class, strict = FALSE)
        else if (extends(Class, Classi)) 
          as(.Object, Classi) <- obj
        else if (extends(Classi, dataPart)) 
          .Object@.Data <- obj
        else {
          extendsi <- extends(Classi)[-1]
          which <- match(thisExtends, extendsi)
          which <- seq_along(which)[!is.na(which)]
          if (length(which)) {
            Classi <- thisExtends[which[1]]
            as(.Object, Classi) <- obj
          }
          else stop(gettextf("cannot use object of class %s in new():  class %s does not extend that class", dQuote(Classi), dQuote(Class)), domain = NA)
        }
      }
    }
    if (length(elements)) {
      snames <- names(elements)
      if (anyDuplicated(snames)) 
        stop(gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]), collapse = ", ")), domain = NA)
      which <- match(snames, names(slotDefs))
      if (anyNA(which)) 
        stop(sprintf(ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s", "invalid names for slots of class %s: %s"), dQuote(Class), paste(snames[is.na(which)], collapse = ", ")), domain = NA)
      firstTime <- TRUE
      for (i in seq_along(snames)) {
        slotName <- snames[[i]]
        slotClass <- slotDefs[[slotName]]
        slotClassDef <- getClassDef(slotClass, package = packageSlot(slotClass))
        slotVal <- elements[[i]]
        if (!.identC(class(slotVal), slotClass) && !is.null(slotClassDef)) {
          valClass <- class(slotVal)
          valClassDef <- getClassDef(valClass, package = ClassDef@package)
          if (!identical(possibleExtends(valClass, slotClass, valClassDef, slotClassDef), FALSE)) 
            slotVal <- as(slotVal, slotClass, strict = FALSE)
        }
        if (firstTime) {
          slot(.Object, slotName, check = FALSE) <- slotVal
          firstTime <- FALSE
        }
        else {
          `slot<-`(.Object, slotName, check = FALSE, slotVal)
        }
      }
    }
    validObject(.Object)
  }
  .Object
}, target = new("signature", .Data = "ANY", names = ".Object", package = "methods"), defined = new("signature", .Data = "ANY", names = ".Object", package = "methods"), generic = "initialize"), skeleton = (new("derivedDefaultMethod", .Data = function (.Object, ...) 
{
  args <- list(...)
  if (length(args)) {
    Class <- class(.Object)
    if (!is.na(match(Class, .BasicClasses))) 
      return(newBasic(Class, ...))
    ClassDef <- getClass(Class)
    snames <- allNames(args)
    which <- nzchar(snames)
    elements <- args[which]
    supers <- args[!which]
    thisExtends <- names(ClassDef@contains)
    slotDefs <- ClassDef@slots
    dataPart <- slotDefs[[".Data"]]
    if (is.null(dataPart)) 
      dataPart <- "missing"
    if (length(supers)) {
      for (i in rev(seq_along(supers))) {
        obj <- supers[[i]]
        Classi <- class(obj)
        if (length(Classi) > 1) 
          Classi <- Classi[[1]]
        if (.identC(Classi, Class)) 
          .Object <- obj
        else if (extends(Classi, Class)) 
          .Object <- as(obj, Class, strict = FALSE)
        else if (extends(Class, Classi)) 
          as(.Object, Classi) <- obj
        else if (extends(Classi, dataPart)) 
          .Object@.Data <- obj
        else {
          extendsi <- extends(Classi)[-1]
          which <- match(thisExtends, extendsi)
          which <- seq_along(which)[!is.na(which)]
          if (length(which)) {
            Classi <- thisExtends[which[1]]
            as(.Object, Classi) <- obj
          }
          else stop(gettextf("cannot use object of class %s in new():  class %s does not extend that class", dQuote(Classi), dQuote(Class)), domain = NA)
        }
      }
    }
    if (length(elements)) {
      snames <- names(elements)
      if (anyDuplicated(snames)) 
        stop(gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]), collapse = ", ")), domain = NA)
      which <- match(snames, names(slotDefs))
      if (anyNA(which)) 
        stop(sprintf(ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s", "invalid names for slots of class %s: %s"), dQuote(Class), paste(snames[is.na(which)], collapse = ", ")), domain = NA)
      firstTime <- TRUE
      for (i in seq_along(snames)) {
        slotName <- snames[[i]]
        slotClass <- slotDefs[[slotName]]
        slotClassDef <- getClassDef(slotClass, package = packageSlot(slotClass))
        slotVal <- elements[[i]]
        if (!.identC(class(slotVal), slotClass) && !is.null(slotClassDef)) {
          valClass <- class(slotVal)
          valClassDef <- getClassDef(valClass, package = ClassDef@package)
          if (!identical(possibleExtends(valClass, slotClass, valClassDef, slotClassDef), FALSE)) 
            slotVal <- as(slotVal, slotClass, strict = FALSE)
        }
        if (firstTime) {
          slot(.Object, slotName, check = FALSE) <- slotVal
          firstTime <- FALSE
        }
        else {
          `slot<-`(.Object, slotName, check = FALSE, slotVal)
        }
      }
    }
    validObject(.Object)
  }
  .Object
}, target = new("signature", .Data = "ANY", names = ".Object", package = "methods"), defined = new("signature", .Data = "ANY", names = ".Object", package = "methods"), generic = "initialize"))(.Object, ...)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
initRefFields
list(`package:methods` = function (.Object, classDef, selfEnv, args) 
{
  if (length(args)) {
    snames <- allNames(args)
    which <- nzchar(snames)
    elements <- args[which]
    supers <- args[!which]
    elNames <- names(elements)
    for (super in supers) {
      if (!is(super, "refClass")) {
        warning(gettextf("unnamed arguments to $new() must be objects from a reference class; got an object of class %s", dQuote(class(super))), domain = NA)
        next
      }
      fields <- names(super$.refClassDef@fieldClasses)
      fields <- fields[is.na(match(fields, elNames))]
      for (field in fields) elements[[field]] <- super$field(field)
      elNames <- names(elements)
    }
    for (field in elNames) envRefSetField(.Object, field, classDef, selfEnv, elements[[field]])
  }
  .Object
}, function (.Object, classDef, selfEnv, args) 
{
  if (length(args)) {
    snames <- allNames(args)
    which <- nzchar(snames)
    elements <- args[which]
    supers <- args[!which]
    elNames <- names(elements)
    for (super in supers) {
      if (!is(super, "refClass")) {
        warning(gettextf("unnamed arguments to $new() must be objects from a reference class; got an object of class %s", dQuote(class(super))), domain = NA)
        next
      }
      fields <- names(super$.refClassDef@fieldClasses)
      fields <- fields[is.na(match(fields, elNames))]
      for (field in fields) elements[[field]] <- super$field(field)
      elNames <- names(elements)
    }
    for (field in elNames) envRefSetField(.Object, field, classDef, selfEnv, elements[[field]])
  }
  .Object
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
insertClassMethods
list(`package:methods` = function (methods, Class, value, fieldNames, returnAll) 
{
  theseMethods <- names(value)
  prevMethods <- names(methods)
  allMethods <- unique(c(theseMethods, prevMethods))
  returnMethods <- if (returnAll) 
    methods
  else value
  check <- TRUE
  for (method in theseMethods) {
    prevMethod <- methods[[method]]
    if (is.null(prevMethod)) {
      superClassMethod <- if (identical(method, "initialize")) 
        "initFields"
      else ""
    }
    else if (identical(prevMethod@refClassName, Class)) 
      superClassMethod <- prevMethod@superClassMethod
    else {
      superClassMethod <- superClassMethodName(prevMethod)
      returnMethods[[superClassMethod]] <- prevMethod
    }
    def <- makeClassMethod(value[[method]], method, Class, superClassMethod, allMethods)
    check <- check && .checkFieldsInMethod(def, fieldNames, allMethods)
    returnMethods[[method]] <- def
  }
  if (is.na(check) && .methodsIsLoaded()) 
    message(gettextf("code for methods in class %s was not checked for suspicious field assignments (recommended package %s not available?)", dQuote(Class), sQuote("codetools")), domain = NA)
  returnMethods
}, function (methods, Class, value, fieldNames, returnAll) 
{
  theseMethods <- names(value)
  prevMethods <- names(methods)
  allMethods <- unique(c(theseMethods, prevMethods))
  returnMethods <- if (returnAll) 
    methods
  else value
  check <- TRUE
  for (method in theseMethods) {
    prevMethod <- methods[[method]]
    if (is.null(prevMethod)) {
      superClassMethod <- if (identical(method, "initialize")) 
        "initFields"
      else ""
    }
    else if (identical(prevMethod@refClassName, Class)) 
      superClassMethod <- prevMethod@superClassMethod
    else {
      superClassMethod <- superClassMethodName(prevMethod)
      returnMethods[[superClassMethod]] <- prevMethod
    }
    def <- makeClassMethod(value[[method]], method, Class, superClassMethod, allMethods)
    check <- check && .checkFieldsInMethod(def, fieldNames, allMethods)
    returnMethods[[method]] <- def
  }
  if (is.na(check) && .methodsIsLoaded()) 
    message(gettextf("code for methods in class %s was not checked for suspicious field assignments (recommended package %s not available?)", dQuote(Class), sQuote("codetools")), domain = NA)
  returnMethods
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
insertMethod
list(`package:methods` = function (mlist, signature, args, def, cacheOnly = FALSE) 
{
  .MlistDeprecated("insertMethod()")
  if (.noMlists() && !identical(unique(signature), "ANY")) 
    return(mlist)
  if (identical(args[1], "...") && !identical(names(signature), "...")) {
    if (identical(signature[[1]], "ANY")) 
      stop(gettextf("inserting method with invalid signature matching argument '...' to class %s", dQuote(signature[[1]])), domain = NA)
    args <- args[-1]
    signature <- signature[-1]
    if (length(signature) == 0) 
      return(mlist)
  }
  if (length(signature) == 0) 
    stop("inserting method corresponding to empty signature")
  if (!is(mlist, "MethodsList")) 
    stop(gettextf("inserting method into non-methods-list object (class %s)", dQuote(.class1(mlist))), domain = NA)
  if (length(args) > 1 && !cacheOnly) 
    mlist <- balanceMethodsList(mlist, args)
  Class <- signature[[1]]
  methods <- if (cacheOnly) 
    mlist@allMethods
  else mlist@methods
  current <- methods[[Class]]
  if (is(current, "MethodsList")) {
    nextArg <- as.character(current@argument)
    sigArgs <- args
    n <- length(signature)
    length(sigArgs) <- n
    if (is.na(match(nextArg, sigArgs))) {
      n <- match(nextArg, args) - n
      if (is.na(n)) {
        n <- 1
        args <- c(args, nextArg)
      }
      signature <- c(signature, rep("ANY", n))
    }
  }
  if (length(signature) == 1) {
    if (is.null(current)) {
      if (!is.null(def)) 
        methods[[Class]] <- def
    }
    else {
      which <- match(Class, names(methods))
      if (is.null(def)) 
        methods <- methods[-which]
      else methods[[which]] <- def
    }
  }
  else {
    if (is.null(current)) 
      current <- new("MethodsList", argument = as.name(args[2]))
    else if (is.function(current)) 
      current <- new("MethodsList", argument = as.name(args[2]), methods = list(ANY = current))
    methods[[Class]] <- Recall(current, signature[-1], args[-1], def, cacheOnly)
  }
  mlist@allMethods <- methods
  if (!cacheOnly) 
    mlist@methods <- methods
  mlist
}, function (mlist, signature, args, def, cacheOnly = FALSE) 
{
  .MlistDeprecated("insertMethod()")
  if (.noMlists() && !identical(unique(signature), "ANY")) 
    return(mlist)
  if (identical(args[1], "...") && !identical(names(signature), "...")) {
    if (identical(signature[[1]], "ANY")) 
      stop(gettextf("inserting method with invalid signature matching argument '...' to class %s", dQuote(signature[[1]])), domain = NA)
    args <- args[-1]
    signature <- signature[-1]
    if (length(signature) == 0) 
      return(mlist)
  }
  if (length(signature) == 0) 
    stop("inserting method corresponding to empty signature")
  if (!is(mlist, "MethodsList")) 
    stop(gettextf("inserting method into non-methods-list object (class %s)", dQuote(.class1(mlist))), domain = NA)
  if (length(args) > 1 && !cacheOnly) 
    mlist <- balanceMethodsList(mlist, args)
  Class <- signature[[1]]
  methods <- if (cacheOnly) 
    mlist@allMethods
  else mlist@methods
  current <- methods[[Class]]
  if (is(current, "MethodsList")) {
    nextArg <- as.character(current@argument)
    sigArgs <- args
    n <- length(signature)
    length(sigArgs) <- n
    if (is.na(match(nextArg, sigArgs))) {
      n <- match(nextArg, args) - n
      if (is.na(n)) {
        n <- 1
        args <- c(args, nextArg)
      }
      signature <- c(signature, rep("ANY", n))
    }
  }
  if (length(signature) == 1) {
    if (is.null(current)) {
      if (!is.null(def)) 
        methods[[Class]] <- def
    }
    else {
      which <- match(Class, names(methods))
      if (is.null(def)) 
        methods <- methods[-which]
      else methods[[which]] <- def
    }
  }
  else {
    if (is.null(current)) 
      current <- new("MethodsList", argument = as.name(args[2]))
    else if (is.function(current)) 
      current <- new("MethodsList", argument = as.name(args[2]), methods = list(ANY = current))
    methods[[Class]] <- Recall(current, signature[-1], args[-1], def, cacheOnly)
  }
  mlist@allMethods <- methods
  if (!cacheOnly) 
    mlist@methods <- methods
  mlist
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
insertSource
list(`package:methods` = function (source, package = "", functions = allPlainObjects(), methods = (if (missing(functions)) allMethodTables() else NULL), force = missing(functions) & missing(methods)) 
{
  MPattern <- .TableMetaPattern()
  CPattern <- .ClassMetaPattern()
  allPlainObjects <- function() allObjects[!(grepl(MPattern, allObjects) | grepl(CPattern, allObjects) | ".cacheOnAssign" == allObjects)]
  allMethodTables <- function() allObjects[grepl(MPattern, allObjects)]
  differs <- function(f1, f2) !(identical(body(f1), body(f2)) && identical(args(f1), args(f2)))
  if (is.environment(source) && !nzchar(package)) {
    if (is(source, "sourceEnvironment")) 
      package <- source@packageName
    else if (exists(".packageName", envir = source, inherits = FALSE)) 
      package <- get(".packageName", envir = source)
  }
  if (is(source, "environment")) 
    env <- source
  else env <- evalSource(source, package, FALSE)
  envPackage <- getPackageName(env, FALSE)
  envp <- parent.env(env)
  if (identical(envp, .GlobalEnv) || !nzchar(envPackage)) {
    if (!nzchar(package)) 
      package <- .guessPackageName(env)
    if (identical(package, ".GlobalEnv")) 
      envns <- NULL
    else {
      pname <- paste0("package:", package)
      envp <- tryCatch(as.environment(pname), error = function(cond) NULL)
      if (is.null(envp)) {
        envp <- tryCatch(as.environment(pname), error = function(cond) NULL)
        if (is.null(envp)) 
          stop(gettextf("cannot find an environment corresponding to package name '%s\"", package), domain = NA)
      }
      envns <- tryCatch(asNamespace(package), error = function(cond) NULL)
    }
    if (nzchar(package)) 
      assign(".packageName", package, envir = env)
  }
  else {
    if (isNamespace(envp)) 
      envns <- envp
    else envns <- tryCatch(asNamespace(package), error = function(cond) NULL)
  }
  if (nzchar(envPackage) && envPackage != package) 
    warning(gettextf("supplied package, %s, differs from package inferred from source, %s", sQuote(package), sQuote(envPackage)), domain = NA)
  packageSlot(env) <- package
  allObjects <- names(env)
  if (!missing(functions)) {
    notThere <- is.na(match(functions, allObjects))
    if (any(notThere)) {
      warning(gettextf("cannot insert these (not found in source): %s", paste0("\"", functions[notThere], "\"", collapse = ", ")), domain = NA)
    }
  }
  .mnames <- allMethodTables()
  if (length(methods) > 0) {
    notThere <- vapply(methods, function(fname) length(grep(fname, .mnames, fixed = TRUE)) == 0, NA)
    if (any(notThere)) {
      warning(gettextf("cannot insert methods for these functions (methods table not found in source): %s", paste0("\"", methods[notThere], "\"", collapse = ", ")), domain = NA)
      methods <- methods[!notThere]
    }
    methodNames <- vapply(methods, function(fname) .mnames[[grep(fname, .mnames, fixed = TRUE)[[1]]]], "")
  }
  else {
    methodNames <- .mnames
    methods <- sub(.TableMetaPrefix(), "", methodNames)
    methods <- sub(":.*", "", methods)
  }
  notTraceable <- newObjects <- objectsDone <- character()
  for (i in seq_along(functions)) {
    this <- functions[[i]]
    thisWhere <- NULL
    if (is.null(envns) || exists(this, envir = envp, inherits = FALSE)) {
      envwhere <- envp
      thisWhere <- get(this, envir = envp)
    }
    else {
      envwhere <- envns
      if (is.environment(envns) && exists(this, envir = envns, inherits = FALSE)) 
        thisWhere <- get(this, envir = envns)
    }
    thisObj <- get(this, envir = env)
    if (is.function(thisObj) && is.function(thisWhere) && differs(thisObj, thisWhere)) {
      suppressMessages(.TraceWithMethods(this, where = envwhere, edit = env))
      objectsDone <- c(objectsDone, this)
    }
    else if (force) 
      assign(this, thisObj, envir = envwhere)
    else if (!is.function(thisObj)) 
      notTraceable <- c(notTraceable, this)
    else if (is.null(thisWhere)) 
      newObjects <- c(newObjects, this)
  }
  if (length(notTraceable) > 0) 
    message(gettextf("Non-function objects are not currently inserted (not traceable): %s", paste(notTraceable, collapse = ", ")), domain = NA)
  if (length(newObjects) > 0) 
    message(gettextf("New functions are not currently inserted (not untraceable): %s", paste(newObjects, collapse = ", ")), domain = NA)
  if (length(objectsDone) > 0) 
    message(gettextf("Modified functions inserted through trace(): %s", paste(objectsDone, collapse = ", ")), domain = NA)
  for (i in seq_along(methods)) {
    .copyMethods(methods[[i]], methodNames[[i]], env, envp)
  }
  if (!is.environment(source)) {
    lockEnvironment(env, bindings = TRUE)
    invisible(env)
  }
  else invisible(source)
}, function (source, package = "", functions = allPlainObjects(), methods = (if (missing(functions)) allMethodTables() else NULL), force = missing(functions) & missing(methods)) 
{
  MPattern <- .TableMetaPattern()
  CPattern <- .ClassMetaPattern()
  allPlainObjects <- function() allObjects[!(grepl(MPattern, allObjects) | grepl(CPattern, allObjects) | ".cacheOnAssign" == allObjects)]
  allMethodTables <- function() allObjects[grepl(MPattern, allObjects)]
  differs <- function(f1, f2) !(identical(body(f1), body(f2)) && identical(args(f1), args(f2)))
  if (is.environment(source) && !nzchar(package)) {
    if (is(source, "sourceEnvironment")) 
      package <- source@packageName
    else if (exists(".packageName", envir = source, inherits = FALSE)) 
      package <- get(".packageName", envir = source)
  }
  if (is(source, "environment")) 
    env <- source
  else env <- evalSource(source, package, FALSE)
  envPackage <- getPackageName(env, FALSE)
  envp <- parent.env(env)
  if (identical(envp, .GlobalEnv) || !nzchar(envPackage)) {
    if (!nzchar(package)) 
      package <- .guessPackageName(env)
    if (identical(package, ".GlobalEnv")) 
      envns <- NULL
    else {
      pname <- paste0("package:", package)
      envp <- tryCatch(as.environment(pname), error = function(cond) NULL)
      if (is.null(envp)) {
        envp <- tryCatch(as.environment(pname), error = function(cond) NULL)
        if (is.null(envp)) 
          stop(gettextf("cannot find an environment corresponding to package name '%s\"", package), domain = NA)
      }
      envns <- tryCatch(asNamespace(package), error = function(cond) NULL)
    }
    if (nzchar(package)) 
      assign(".packageName", package, envir = env)
  }
  else {
    if (isNamespace(envp)) 
      envns <- envp
    else envns <- tryCatch(asNamespace(package), error = function(cond) NULL)
  }
  if (nzchar(envPackage) && envPackage != package) 
    warning(gettextf("supplied package, %s, differs from package inferred from source, %s", sQuote(package), sQuote(envPackage)), domain = NA)
  packageSlot(env) <- package
  allObjects <- names(env)
  if (!missing(functions)) {
    notThere <- is.na(match(functions, allObjects))
    if (any(notThere)) {
      warning(gettextf("cannot insert these (not found in source): %s", paste0("\"", functions[notThere], "\"", collapse = ", ")), domain = NA)
    }
  }
  .mnames <- allMethodTables()
  if (length(methods) > 0) {
    notThere <- vapply(methods, function(fname) length(grep(fname, .mnames, fixed = TRUE)) == 0, NA)
    if (any(notThere)) {
      warning(gettextf("cannot insert methods for these functions (methods table not found in source): %s", paste0("\"", methods[notThere], "\"", collapse = ", ")), domain = NA)
      methods <- methods[!notThere]
    }
    methodNames <- vapply(methods, function(fname) .mnames[[grep(fname, .mnames, fixed = TRUE)[[1]]]], "")
  }
  else {
    methodNames <- .mnames
    methods <- sub(.TableMetaPrefix(), "", methodNames)
    methods <- sub(":.*", "", methods)
  }
  notTraceable <- newObjects <- objectsDone <- character()
  for (i in seq_along(functions)) {
    this <- functions[[i]]
    thisWhere <- NULL
    if (is.null(envns) || exists(this, envir = envp, inherits = FALSE)) {
      envwhere <- envp
      thisWhere <- get(this, envir = envp)
    }
    else {
      envwhere <- envns
      if (is.environment(envns) && exists(this, envir = envns, inherits = FALSE)) 
        thisWhere <- get(this, envir = envns)
    }
    thisObj <- get(this, envir = env)
    if (is.function(thisObj) && is.function(thisWhere) && differs(thisObj, thisWhere)) {
      suppressMessages(.TraceWithMethods(this, where = envwhere, edit = env))
      objectsDone <- c(objectsDone, this)
    }
    else if (force) 
      assign(this, thisObj, envir = envwhere)
    else if (!is.function(thisObj)) 
      notTraceable <- c(notTraceable, this)
    else if (is.null(thisWhere)) 
      newObjects <- c(newObjects, this)
  }
  if (length(notTraceable) > 0) 
    message(gettextf("Non-function objects are not currently inserted (not traceable): %s", paste(notTraceable, collapse = ", ")), domain = NA)
  if (length(newObjects) > 0) 
    message(gettextf("New functions are not currently inserted (not untraceable): %s", paste(newObjects, collapse = ", ")), domain = NA)
  if (length(objectsDone) > 0) 
    message(gettextf("Modified functions inserted through trace(): %s", paste(objectsDone, collapse = ", ")), domain = NA)
  for (i in seq_along(methods)) {
    .copyMethods(methods[[i]], methodNames[[i]], env, envp)
  }
  if (!is.environment(source)) {
    lockEnvironment(env, bindings = TRUE)
    invisible(env)
  }
  else invisible(source)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
is
list(`package:methods` = function (object, class2) 
{
  class1 <- class(object)
  S3Case <- length(class1) > 1
  if (S3Case) 
    class1 <- class1[[1]]
  if (missing(class2)) 
    return(extends(class1))
  stopifnot(length(class2) == 1)
  class1Def <- getClassDef(class1)
  class2Def <- NULL
  if (!is.character(class2)) {
    class2Def <- class2
    class2 <- class2Def@className
  }
  if (is.null(class1Def)) 
    return(inherits(object, class2))
  if (is.null(class2Def)) {
    class2Def <- getClassDef(class2, .classDefEnv(class1Def), if (!is.null(package <- packageSlot(class2))) 
      package
      else getPackageName(topenv(parent.frame())))
  }
  S3Case <- S3Case || (is.object(object) && !isS4(object))
  S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
  if (S3Case) 
    inherits(object, class2)
  else if (.identC(class1, class2) || .identC(class2, "ANY")) 
    TRUE
  else {
    if (!is.null(contained <- class1Def@contains[[class2]])) 
      contained@simple || contained@test(object)
    else if (is.null(class2Def)) 
      FALSE
    else if (!.identC(class(class2Def), "classRepresentation") && isClassUnion(class2Def)) 
      any(c(class1, names(class1Def@contains)) %in% names(class2Def@subclasses))
    else {
      ext <- class2Def@subclasses[[class1]]
      !is.null(ext) && (ext@simple || ext@test(object))
    }
  }
}, function (object, class2) 
{
  class1 <- class(object)
  S3Case <- length(class1) > 1
  if (S3Case) 
    class1 <- class1[[1]]
  if (missing(class2)) 
    return(extends(class1))
  stopifnot(length(class2) == 1)
  class1Def <- getClassDef(class1)
  class2Def <- NULL
  if (!is.character(class2)) {
    class2Def <- class2
    class2 <- class2Def@className
  }
  if (is.null(class1Def)) 
    return(inherits(object, class2))
  if (is.null(class2Def)) {
    class2Def <- getClassDef(class2, .classDefEnv(class1Def), if (!is.null(package <- packageSlot(class2))) 
      package
      else getPackageName(topenv(parent.frame())))
  }
  S3Case <- S3Case || (is.object(object) && !isS4(object))
  S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
  if (S3Case) 
    inherits(object, class2)
  else if (.identC(class1, class2) || .identC(class2, "ANY")) 
    TRUE
  else {
    if (!is.null(contained <- class1Def@contains[[class2]])) 
      contained@simple || contained@test(object)
    else if (is.null(class2Def)) 
      FALSE
    else if (!.identC(class(class2Def), "classRepresentation") && isClassUnion(class2Def)) 
      any(c(class1, names(class1Def@contains)) %in% names(class2Def@subclasses))
    else {
      ext <- class2Def@subclasses[[class1]]
      !is.null(ext) && (ext@simple || ext@test(object))
    }
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isClass
list(`package:methods` = function (Class, formal = TRUE, where = topenv(parent.frame())) 
  !is.null(getClassDef(Class, where)), function (Class, formal = TRUE, where = topenv(parent.frame())) 
    !is.null(getClassDef(Class, where)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isClassDef
list(`package:methods` = function (object) 
  is(object, "classRepresentation"), function (object) 
    is(object, "classRepresentation"))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isClassUnion
list(`package:methods` = function (Class) 
{
  if (is.character(Class)) 
    Class <- getClass(Class, TRUE)
  extends(class(Class), "ClassUnionRepresentation")
}, function (Class) 
{
  if (is.character(Class)) 
    Class <- getClass(Class, TRUE)
  extends(class(Class), "ClassUnionRepresentation")
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isGeneric
list(`package:methods` = function (f, where = topenv(parent.frame()), fdef = NULL, getName = FALSE) 
{
  if (is.null(fdef) && missing(where)) {
    fdef <- .getGenericFromCache(f, where)
    if (!is.null(fdef)) 
      return(if (getName) fdef@generic else TRUE)
  }
  if (is.null(fdef)) 
    fdef <- getFunction(f, where = where, mustFind = FALSE)
  if (is.null(fdef)) 
    return(FALSE)
  if (isBaseFun(fdef)) {
    if (is.character(f) && f %in% "as.double") 
      f <- "as.numeric"
    gen <- genericForBasic(f, mustFind = FALSE)
    return(is.function(gen) && length(names(.getMethodsTable(gen))) > 1)
  }
  if (!is(fdef, "genericFunction")) 
    return(FALSE)
  gen <- fdef@generic
  if (missing(f) || .identC(gen, f)) {
    if (getName) 
      gen
    else TRUE
  }
  else {
    warning(gettextf("function %s appears to be a generic function, but with generic name %s", sQuote(f), sQuote(gen)), domain = NA)
    FALSE
  }
}, function (f, where = topenv(parent.frame()), fdef = NULL, getName = FALSE) 
{
  if (is.null(fdef) && missing(where)) {
    fdef <- .getGenericFromCache(f, where)
    if (!is.null(fdef)) 
      return(if (getName) fdef@generic else TRUE)
  }
  if (is.null(fdef)) 
    fdef <- getFunction(f, where = where, mustFind = FALSE)
  if (is.null(fdef)) 
    return(FALSE)
  if (isBaseFun(fdef)) {
    if (is.character(f) && f %in% "as.double") 
      f <- "as.numeric"
    gen <- genericForBasic(f, mustFind = FALSE)
    return(is.function(gen) && length(names(.getMethodsTable(gen))) > 1)
  }
  if (!is(fdef, "genericFunction")) 
    return(FALSE)
  gen <- fdef@generic
  if (missing(f) || .identC(gen, f)) {
    if (getName) 
      gen
    else TRUE
  }
  else {
    warning(gettextf("function %s appears to be a generic function, but with generic name %s", sQuote(f), sQuote(gen)), domain = NA)
    FALSE
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isGrammarSymbol
list(`package:methods` = function (symbol) 
{
  if (typeof(symbol) != "symbol") 
    FALSE
  else switch(as.character(symbol), `{` = , `if` = , `for` = , `while` = , `repeat` = , return = , `next` = , `break` = , `<-` = , `<<-` = TRUE, FALSE)
}, function (symbol) 
{
  if (typeof(symbol) != "symbol") 
    FALSE
  else switch(as.character(symbol), `{` = , `if` = , `for` = , `while` = , `repeat` = , return = , `next` = , `break` = , `<-` = , `<<-` = TRUE, FALSE)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isGroup
list(`package:methods` = function (f, where = topenv(parent.frame()), fdef = getGeneric(f, where = where)) 
{
  is(fdef, "groupGenericFunction")
}, function (choice) 
{
  is.list(choice) || !is.null(names(choice)) || length(choice) > 1 || length(choice) == 0
}, function (f, where = topenv(parent.frame()), fdef = getGeneric(f, where = where)) 
{
  is(fdef, "groupGenericFunction")
})
c("package:methods", "namespace:shiny", "namespace:methods")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
isRematched
list(`package:methods` = function (definition) 
{
  bdy <- body(definition)
  if (.identC(class(bdy), "{") && length(bdy) > 1) {
    bdy <- bdy[[2]]
    .identC(class(bdy), "<-") && identical(bdy[[2]], as.name(".local"))
  }
  else FALSE
}, function (definition) 
{
  bdy <- body(definition)
  if (.identC(class(bdy), "{") && length(bdy) > 1) {
    bdy <- bdy[[2]]
    .identC(class(bdy), "<-") && identical(bdy[[2]], as.name(".local"))
  }
  else FALSE
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isSealedClass
list(`package:methods` = function (Class, where = topenv(parent.frame())) 
{
  if (is.character(Class)) 
    Class <- getClass(Class, TRUE, where)
  if (!is(Class, "classRepresentation")) 
    FALSE
  else Class@sealed
}, function (Class, where = topenv(parent.frame())) 
{
  if (is.character(Class)) 
    Class <- getClass(Class, TRUE, where)
  if (!is(Class, "classRepresentation")) 
    FALSE
  else Class@sealed
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isSealedMethod
list(`package:methods` = function (f, signature, fdef = getGeneric(f, FALSE, where = where), where = topenv(parent.frame())) 
{
  fGen <- getFunction(f, TRUE, FALSE, where = where)
  if (!is.primitive(fGen)) {
    mdef <- getMethod(f, signature, optional = TRUE, where = where, fdef = fGen)
    return(is(mdef, "SealedMethodDefinition"))
  }
  if (is(fdef, "genericFunction")) 
    signature <- matchSignature(signature, fdef)
  if (length(signature) == 0) 
    TRUE
  else if (f %in% .subsetFuns) 
    !anyNA(match(signature, .BasicClasses))
  else {
    sealed <- !is.na(match(signature[[1]], .BasicClasses))
    if (sealed && (!is.na(match("Ops", c(f, getGroup(f, TRUE)))) || !is.na(match(f, c("%*%", "crossprod"))))) 
      sealed <- sealed && (length(signature) > 1) && !is.na(match(signature[[2]], .BasicClasses))
    sealed
  }
}, function (f, signature, fdef = getGeneric(f, FALSE, where = where), where = topenv(parent.frame())) 
{
  fGen <- getFunction(f, TRUE, FALSE, where = where)
  if (!is.primitive(fGen)) {
    mdef <- getMethod(f, signature, optional = TRUE, where = where, fdef = fGen)
    return(is(mdef, "SealedMethodDefinition"))
  }
  if (is(fdef, "genericFunction")) 
    signature <- matchSignature(signature, fdef)
  if (length(signature) == 0) 
    TRUE
  else if (f %in% .subsetFuns) 
    !anyNA(match(signature, .BasicClasses))
  else {
    sealed <- !is.na(match(signature[[1]], .BasicClasses))
    if (sealed && (!is.na(match("Ops", c(f, getGroup(f, TRUE)))) || !is.na(match(f, c("%*%", "crossprod"))))) 
      sealed <- sealed && (length(signature) > 1) && !is.na(match(signature[[2]], .BasicClasses))
    sealed
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isVirtualClass
list(`package:methods` = function (Class, where = topenv(parent.frame())) 
{
  if (isClassDef(Class)) 
    Class@virtual
  else if (isClass(Class, where = where)) 
    getClass(Class, where = where)@virtual
  else TRUE
}, function (Class, where = topenv(parent.frame())) 
{
  if (isClassDef(Class)) 
    Class@virtual
  else if (isClass(Class, where = where)) 
    getClass(Class, where = where)@virtual
  else TRUE
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
isXS3Class
list(`package:methods` = function (classDef) 
{
  ".S3Class" %in% names(classDef@slots)
}, function (classDef) 
{
  ".S3Class" %in% names(classDef@slots)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
kronecker
list(`package:methods` = new("standardGeneric", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  standardGeneric("kronecker"), generic = "kronecker", package = "base", group = list(), valueClass = character(0), signature = c("X", "Y", "FUN", "make.dimnames"), default = new("derivedDefaultMethod", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
      return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
    }
    .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
  }, target = new("signature", .Data = "ANY", names = "X", package = "methods"), defined = new("signature", .Data = "ANY", names = "X", package = "methods"), generic = "kronecker"), skeleton = (new("derivedDefaultMethod", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
      return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
    }
    .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
  }, target = new("signature", .Data = "ANY", names = "X", package = "methods"), defined = new("signature", .Data = "ANY", names = "X", package = "methods"), generic = "kronecker"))(X, Y, FUN, make.dimnames, ...)), `package:base` = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
      return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
    }
    .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
  }, function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
      return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
    }
    .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
  }, new("standardGeneric", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
    standardGeneric("kronecker"), generic = "kronecker", package = "base", group = list(), valueClass = character(0), signature = c("X", "Y", "FUN", "make.dimnames"), default = new("derivedDefaultMethod", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
    {
      if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
        return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
      }
      .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
    }, target = new("signature", .Data = "ANY", names = "X", package = "methods"), defined = new("signature", .Data = "ANY", names = "X", package = "methods"), generic = "kronecker"), skeleton = (new("derivedDefaultMethod", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
    {
      if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
        return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
      }
      .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
    }, target = new("signature", .Data = "ANY", names = "X", package = "methods"), defined = new("signature", .Data = "ANY", names = "X", package = "methods"), generic = "kronecker"))(X, Y, FUN, make.dimnames, ...)))
c("package:methods", "package:base", "namespace:base", "namespace:methods")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
languageEl
list(`package:methods` = function (object, which) 
{
  data <- as.list(object)
  if (is.character(which)) 
    data[[which]]
  else if (typeof(object) == "language") {
    if (isGrammarSymbol(data[[1]])) 
      data[[which + 1]]
    else data[[which]]
  }
  else data[[which]]
}, function (object, which) 
{
  data <- as.list(object)
  if (is.character(which)) 
    data[[which]]
  else if (typeof(object) == "language") {
    if (isGrammarSymbol(data[[1]])) 
      data[[which + 1]]
    else data[[which]]
  }
  else data[[which]]
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
languageEl<-
  list(`package:methods` = function (object, which, value) 
  {
    data <- as.list(object)
    n <- length(data)
    type <- typeof(object)
    if (type == "closure") {
      ev <- environment(object)
      if (is.character(which)) {
        if (is.na(match(which, names(data)))) {
          body <- data[[n]]
          data <- data[-n]
          data[[which]] <- value
          data[[n + 1]] <- body
        }
        else data[[which]] <- value
      }
      else {
        if (which < 1 || which > n) 
          stop("invalid index for function argument")
        data[[which]] <- value
      }
      object <- as.function(data)
      environment(object) <- ev
      object
    }
    else if (type == "language") {
      if (is.character(which)) 
        data[[which]] <- value
      else if (isGrammarSymbol(data[[1]])) 
        data[[which + 1]] <- value
      else {
        if (identical(which, 1) && is.character(value)) 
          value <- as.symbol(value)
        data[[which]] <- value
      }
      as.call(data)
    }
    else {
      object[[which]] <- value
      object
    }
  }, function (object, which, value) 
  {
    data <- as.list(object)
    n <- length(data)
    type <- typeof(object)
    if (type == "closure") {
      ev <- environment(object)
      if (is.character(which)) {
        if (is.na(match(which, names(data)))) {
          body <- data[[n]]
          data <- data[-n]
          data[[which]] <- value
          data[[n + 1]] <- body
        }
        else data[[which]] <- value
      }
      else {
        if (which < 1 || which > n) 
          stop("invalid index for function argument")
        data[[which]] <- value
      }
      object <- as.function(data)
      environment(object) <- ev
      object
    }
    else if (type == "language") {
      if (is.character(which)) 
        data[[which]] <- value
      else if (isGrammarSymbol(data[[1]])) 
        data[[which + 1]] <- value
      else {
        if (identical(which, 1) && is.character(value)) 
          value <- as.symbol(value)
        data[[which]] <- value
      }
      as.call(data)
    }
    else {
      object[[which]] <- value
      object
    }
  })
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
linearizeMlist
list(`package:methods` = function (mlist, inherited = TRUE) 
{
  methods <- mlist@methods
  allMethods <- mlist@allMethods
  if (inherited && length(allMethods) >= length(methods)) {
    methods <- allMethods
  }
  preC <- function(y, x) c(x, y)
  cnames <- names(methods)
  value <- list()
  classes <- list()
  arguments <- list()
  argname <- as.character(mlist@argument)
  for (i in seq_along(cnames)) {
    mi <- methods[[i]]
    if (is.function(mi)) {
      value <- c(value, list(mi))
      classes <- c(classes, list(cnames[[i]]))
      arguments <- c(arguments, list(argname))
    }
    else if (is(mi, "MethodsList")) {
      .MlistDeprecated()
      mi <- Recall(mi, inherited)
      value <- c(value, mi@methods)
      classes <- c(classes, lapply(mi@classes, preC, cnames[[i]]))
      arguments <- c(arguments, lapply(mi@arguments, preC, argname))
    }
    else warning(gettextf("skipping methods list element %s of unexpected class %s\n\n", paste(cnames[i], collapse = ", "), dQuote(.class1(mi))), domain = NA)
  }
  new("LinearMethodsList", methods = value, classes = classes, arguments = arguments)
}, function (mlist, inherited = TRUE) 
{
  methods <- mlist@methods
  allMethods <- mlist@allMethods
  if (inherited && length(allMethods) >= length(methods)) {
    methods <- allMethods
  }
  preC <- function(y, x) c(x, y)
  cnames <- names(methods)
  value <- list()
  classes <- list()
  arguments <- list()
  argname <- as.character(mlist@argument)
  for (i in seq_along(cnames)) {
    mi <- methods[[i]]
    if (is.function(mi)) {
      value <- c(value, list(mi))
      classes <- c(classes, list(cnames[[i]]))
      arguments <- c(arguments, list(argname))
    }
    else if (is(mi, "MethodsList")) {
      .MlistDeprecated()
      mi <- Recall(mi, inherited)
      value <- c(value, mi@methods)
      classes <- c(classes, lapply(mi@classes, preC, cnames[[i]]))
      arguments <- c(arguments, lapply(mi@arguments, preC, argname))
    }
    else warning(gettextf("skipping methods list element %s of unexpected class %s\n\n", paste(cnames[i], collapse = ", "), dQuote(.class1(mi))), domain = NA)
  }
  new("LinearMethodsList", methods = value, classes = classes, arguments = arguments)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
listFromMethods
list(`package:methods` = function (generic, where, table) 
{
  fdef <- getGeneric(generic)
  if (missing(table)) 
    table <- if (missing(where)) 
      .getMethodsTable(fdef)
  else get(.TableMetaName(fdef@generic, fdef@package), envir = as.environment(where), inherits = FALSE)
  fev <- environment(fdef)
  nSigArgs <- .getGenericSigLength(fdef, fev)
  methods <- as.list(table, all.names = TRUE)
  names <- names(methods)
  if (nSigArgs > 1) {
    n <- length(names)
    sigs <- vector("list", n)
    namesCon <- textConnection(names)
    for (i in seq_len(n)) sigs[[i]] <- scan(namesCon, "", sep = "#", nmax = nSigArgs, quiet = TRUE)
  }
  else sigs <- as.list(names)
  new("LinearMethodsList", classes = sigs, methods = methods, arguments = .getGenericSigArgs(fdef, fev), generic = fdef)
}, function (generic, where, table) 
{
  fdef <- getGeneric(generic)
  if (missing(table)) 
    table <- if (missing(where)) 
      .getMethodsTable(fdef)
  else get(.TableMetaName(fdef@generic, fdef@package), envir = as.environment(where), inherits = FALSE)
  fev <- environment(fdef)
  nSigArgs <- .getGenericSigLength(fdef, fev)
  methods <- as.list(table, all.names = TRUE)
  names <- names(methods)
  if (nSigArgs > 1) {
    n <- length(names)
    sigs <- vector("list", n)
    namesCon <- textConnection(names)
    for (i in seq_len(n)) sigs[[i]] <- scan(namesCon, "", sep = "#", nmax = nSigArgs, quiet = TRUE)
  }
  else sigs <- as.list(names)
  new("LinearMethodsList", classes = sigs, methods = methods, arguments = .getGenericSigArgs(fdef, fev), generic = fdef)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
listFromMlist
list(`package:methods` = function (mlist, prefix = list(), sigs. = TRUE, methods. = TRUE) 
{
  methodSlot <- slot(mlist, "methods")
  mnames <- names(methodSlot)
  argName <- as.character(slot(mlist, "argument"))
  sigs <- list()
  methods <- list()
  for (i in seq_along(methodSlot)) {
    thisMethod <- methodSlot[i]
    thisClass <- mnames[[i]]
    prefix[[argName]] <- thisClass
    if (is.function(thisMethod)) {
      if (sigs.) 
        sigs <- c(sigs, list(prefix))
      if (methods.) 
        methods <- c(methods, list(thisMethod))
    }
    else {
      more <- Recall(thisMethod, prefix)
      if (sigs.) 
        sigs <- c(sigs, more[[1]])
      if (methods.) 
        methods <- c(methods, more[[2]])
    }
  }
  list(sigs, methods)
}, function (mlist, prefix = list(), sigs. = TRUE, methods. = TRUE) 
{
  methodSlot <- slot(mlist, "methods")
  mnames <- names(methodSlot)
  argName <- as.character(slot(mlist, "argument"))
  sigs <- list()
  methods <- list()
  for (i in seq_along(methodSlot)) {
    thisMethod <- methodSlot[i]
    thisClass <- mnames[[i]]
    prefix[[argName]] <- thisClass
    if (is.function(thisMethod)) {
      if (sigs.) 
        sigs <- c(sigs, list(prefix))
      if (methods.) 
        methods <- c(methods, list(thisMethod))
    }
    else {
      more <- Recall(thisMethod, prefix)
      if (sigs.) 
        sigs <- c(sigs, more[[1]])
      if (methods.) 
        methods <- c(methods, more[[2]])
    }
  }
  list(sigs, methods)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
loadMethod
list(`package:methods` = new("standardGeneric", .Data = function (method, fname, envir) 
  standardGeneric("loadMethod"), generic = "loadMethod", package = "methods", group = list(), valueClass = character(0), signature = c("method", "fname", "envir"), default = new("derivedDefaultMethod", .Data = function (method, fname, envir) 
    method, target = new("signature", .Data = "ANY", names = "method", package = "methods"), defined = new("signature", .Data = "ANY", names = "method", package = "methods"), generic = "loadMethod"), skeleton = (new("derivedDefaultMethod", .Data = function (method, fname, envir) 
      method, target = new("signature", .Data = "ANY", names = "method", package = "methods"), defined = new("signature", .Data = "ANY", names = "method", package = "methods"), generic = "loadMethod"))(method, fname, envir)), new("standardGeneric", .Data = function (method, fname, envir) 
        standardGeneric("loadMethod"), generic = "loadMethod", package = "methods", group = list(), valueClass = character(0), signature = c("method", "fname", "envir"), default = new("derivedDefaultMethod", .Data = function (method, fname, envir) 
          method, target = new("signature", .Data = "ANY", names = "method", package = "methods"), defined = new("signature", .Data = "ANY", names = "method", package = "methods"), generic = "loadMethod"), skeleton = (new("derivedDefaultMethod", .Data = function (method, fname, envir) 
            method, target = new("signature", .Data = "ANY", names = "method", package = "methods"), defined = new("signature", .Data = "ANY", names = "method", package = "methods"), generic = "loadMethod"))(method, fname, envir)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Logic
list(`package:methods` = new("groupGenericFunction", .Data = function (e1, e2) 
  standardGeneric("Logic"), groupMembers = list("&", "|"), generic = "Logic", package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Logic"), domain = NA))(e1, e2)), new("groupGenericFunction", .Data = function (e1, e2) 
      standardGeneric("Logic"), groupMembers = list("&", "|"), generic = "Logic", package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Logic"), domain = NA))(e1, e2)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeClassRepresentation
list(`package:methods` = function (name, slots = list(), superClasses = character(), prototype = NULL, package, validity = NULL, access = list(), version = .newExternalptr(), sealed = FALSE, virtual = NA, where) 
{
  if (any(superClasses %in% .AbnormalTypes)) 
    superClasses <- .addAbnormalDataType(superClasses)
  if (!is.null(prototype) || length(slots) || length(superClasses)) {
    pp <- reconcilePropertiesAndPrototype(name, slots, prototype, superClasses, where)
    slots <- pp$properties
    prototype <- pp$prototype
  }
  contains <- list()
  if (nzchar(package)) 
    packageSlot(name) <- package
  for (what in superClasses) {
    whatClassDef <- if (is(what, "classRepresentation")) 
      what
    else if (is.null(packageSlot(what))) 
      getClass(what, where = where)
    else getClass(what)
    what <- whatClassDef@className
    contains[[what]] <- makeExtends(name, slots = slots, classDef2 = whatClassDef, package = package)
  }
  validity <- .makeValidityMethod(name, validity)
  if (is.na(virtual)) {
    virtual <- testVirtual(slots, contains, prototype, where)
    if (virtual && !is.na(match("VIRTUAL", superClasses))) 
      contains[["VIRTUAL"]] <- NULL
  }
  if (!is.null(prototype) && is.na(match(name, .BasicClasses))) 
    prototype <- .asS4(prototype)
  if (".S3Class" %in% names(slots)) 
    prototype <- .addS3Class(name, prototype, contains, where)
  newClassRepresentation(className = name, slots = slots, contains = contains, prototype = prototype, virtual = virtual, validity = validity, access = access, package = package, versionKey = version, sealed = sealed)
}, function (name, slots = list(), superClasses = character(), prototype = NULL, package, validity = NULL, access = list(), version = .newExternalptr(), sealed = FALSE, virtual = NA, where) 
{
  if (any(superClasses %in% .AbnormalTypes)) 
    superClasses <- .addAbnormalDataType(superClasses)
  if (!is.null(prototype) || length(slots) || length(superClasses)) {
    pp <- reconcilePropertiesAndPrototype(name, slots, prototype, superClasses, where)
    slots <- pp$properties
    prototype <- pp$prototype
  }
  contains <- list()
  if (nzchar(package)) 
    packageSlot(name) <- package
  for (what in superClasses) {
    whatClassDef <- if (is(what, "classRepresentation")) 
      what
    else if (is.null(packageSlot(what))) 
      getClass(what, where = where)
    else getClass(what)
    what <- whatClassDef@className
    contains[[what]] <- makeExtends(name, slots = slots, classDef2 = whatClassDef, package = package)
  }
  validity <- .makeValidityMethod(name, validity)
  if (is.na(virtual)) {
    virtual <- testVirtual(slots, contains, prototype, where)
    if (virtual && !is.na(match("VIRTUAL", superClasses))) 
      contains[["VIRTUAL"]] <- NULL
  }
  if (!is.null(prototype) && is.na(match(name, .BasicClasses))) 
    prototype <- .asS4(prototype)
  if (".S3Class" %in% names(slots)) 
    prototype <- .addS3Class(name, prototype, contains, where)
  newClassRepresentation(className = name, slots = slots, contains = contains, prototype = prototype, virtual = virtual, validity = validity, access = access, package = package, versionKey = version, sealed = sealed)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeExtends
list(`package:methods` = function (Class, coerce = NULL, test = NULL, replace = NULL, by = character(), package, slots = getSlots(classDef1), classDef1 = getClass(Class), classDef2) 
{
  dataEquiv <- function(cl1, cl2) {
    .identC(cl1, cl2) || (extends(cl1, cl2) && !any(is.na(match(c(cl1, cl2), .BasicClasses))))
  }
  packageEnv <- .requirePackage(package)
  class1Defined <- missing(slots)
  if (class1Defined) {
    Class <- classDef1@className
    packageSlot(Class) <- packageSlot(classDef1)
  }
  to <- classDef2@className
  packageSlot(to) <- packageSlot(classDef2)
  simple <- is.null(coerce) && is.null(test) && is.null(replace) && (length(by) == 0)
  distance <- 1
  dataPartClass <- elNamed(slots, ".Data")
  dataPart <- FALSE
  if (simple && !is.null(dataPartClass)) {
    if (!(is.null(getClassDef(dataPartClass)) || is.null(getClassDef(to)))) {
      dataPart <- dataEquiv(dataPartClass, to)
    }
  }
  if (is.null(coerce)) {
    coerce <- .simpleExtCoerce
    if (isXS3Class(classDef2)) {
      body(coerce, envir = packageEnv) <- substitute({
        if (strict) S3Part(from, S3Class = S3CLASS) else from
      }, list(S3CLASS = to))
    }
    else if (!isVirtualClass(classDef2)) 
      body(coerce, envir = packageEnv) <- .simpleCoerceExpr(Class, to, names(slots), classDef2)
  }
  else if (is.function(coerce)) {
    if (length(formals(coerce)) == 1) {
      coerce <- .ChangeFormals(coerce, .simpleIsCoerce, "'coerce' argument to setIs ")
      tmp <- .simpleExtCoerce
      body(tmp, envir = environment(coerce)) <- body(coerce)
      coerce <- tmp
    }
    else coerce <- .ChangeFormals(coerce, .simpleExtCoerce, "'coerce' argument to setIs ")
  }
  else stop(gettextf("the 'coerce' argument to 'setIs' should be a function of one argument, got an object of class %s", dQuote(class(coerce))), domain = NA)
  if (is.null(test)) {
    test <- .simpleExtTest
    extClass <- "SClassExtension"
  }
  else {
    test <- .ChangeFormals(test, .simpleExtTest, "'test' argument to setIs ")
    extClass <- "conditionalExtension"
  }
  if (is.null(replace)) {
    if (dataPart) {
      extn <- classDef2@contains[[dataPartClass]]
      if (is(extn, "SClassExtension")) 
        easy <- extn@simple
      else easy <- FALSE
      if (easy) 
        replace <- .dataPartReplace$f1
      else {
        replace <- .dataPartReplace$f2
        bdy <- body(replace)
        body(replace, envir = environment(replace)) <- substituteDirect(bdy, list(THISCLASS = dataPartClass))
      }
    }
    else if (simple) {
      replace <- .simpleExtReplace
      if (isXS3Class(classDef2)) {
        S3Class <- attr(classDef2@prototype, ".S3Class")
        if (is.null(S3Class)) 
          S3Class <- to
        body(replace, envir = packageEnv) <- quote({
          S3Part(from) <- value
          from
        })
      }
      else if (isVirtualClass(classDef2)) {
        body(replace, envir = packageEnv) <- substitute({
          if (!is(value, TO)) stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", TO, dQuote(FROM), TO, dQuote(class(value))), domain = NA)
          value
        }, list(FROM = Class, TO = to))
      }
      else if (class1Defined && length(slots) == 0) {
        ext <- getAllSuperClasses(classDef1, TRUE)
        toSlots <- classDef2@slots
        sameSlots <- TRUE
        for (eclass in ext) {
          if (.identC(eclass, to)) 
            next
          edef <- getClassDef(eclass, where = packageEnv)
          if (!is.null(edef) && length(edef@slots) > 0) {
            sameSlots <- FALSE
            break
          }
        }
        if (sameSlots) 
          body(replace, envir = packageEnv) <- substitute({
            class(value) <- FROM
            value
          }, list(FROM = Class))
        else if (length(toSlots) == 0) 
          replace <- .ErrorReplace
      }
      else body(replace, envir = packageEnv) <- .simpleReplaceExpr(classDef2)
    }
    else replace <- .ErrorReplace
    if (identical(replace, .ErrorReplace)) 
      warning(gettextf("there is no automatic definition for 'as(object, \"%s\") <- value' when object has class %s and no 'replace' argument was supplied; replacement will be an error", to, dQuote(Class)), domain = NA)
  }
  else if (is.function(replace)) {
    if (length(formals(replace)) == 2) {
      replace <- .ChangeFormals(replace, .dataPartReplace$f2args, "'replace' argument to setIs ")
      tmp <- .ErrorReplace
      body(tmp, envir = environment(replace)) <- body(replace)
      replace <- tmp
    }
    else replace <- .ChangeFormals(replace, .ErrorReplace, "'replace' argument to setIs ")
  }
  else stop(gettextf("the 'replace' argument to setIs() should be a function of 2 or 3 arguments, got an object of class %s", dQuote(class(replace))), domain = NA)
  new(extClass, subClass = Class, superClass = to, package = package, coerce = coerce, test = test, replace = replace, simple = simple, by = by, dataPart = dataPart, distance = distance)
}, function (Class, coerce = NULL, test = NULL, replace = NULL, by = character(), package, slots = getSlots(classDef1), classDef1 = getClass(Class), classDef2) 
{
  dataEquiv <- function(cl1, cl2) {
    .identC(cl1, cl2) || (extends(cl1, cl2) && !any(is.na(match(c(cl1, cl2), .BasicClasses))))
  }
  packageEnv <- .requirePackage(package)
  class1Defined <- missing(slots)
  if (class1Defined) {
    Class <- classDef1@className
    packageSlot(Class) <- packageSlot(classDef1)
  }
  to <- classDef2@className
  packageSlot(to) <- packageSlot(classDef2)
  simple <- is.null(coerce) && is.null(test) && is.null(replace) && (length(by) == 0)
  distance <- 1
  dataPartClass <- elNamed(slots, ".Data")
  dataPart <- FALSE
  if (simple && !is.null(dataPartClass)) {
    if (!(is.null(getClassDef(dataPartClass)) || is.null(getClassDef(to)))) {
      dataPart <- dataEquiv(dataPartClass, to)
    }
  }
  if (is.null(coerce)) {
    coerce <- .simpleExtCoerce
    if (isXS3Class(classDef2)) {
      body(coerce, envir = packageEnv) <- substitute({
        if (strict) S3Part(from, S3Class = S3CLASS) else from
      }, list(S3CLASS = to))
    }
    else if (!isVirtualClass(classDef2)) 
      body(coerce, envir = packageEnv) <- .simpleCoerceExpr(Class, to, names(slots), classDef2)
  }
  else if (is.function(coerce)) {
    if (length(formals(coerce)) == 1) {
      coerce <- .ChangeFormals(coerce, .simpleIsCoerce, "'coerce' argument to setIs ")
      tmp <- .simpleExtCoerce
      body(tmp, envir = environment(coerce)) <- body(coerce)
      coerce <- tmp
    }
    else coerce <- .ChangeFormals(coerce, .simpleExtCoerce, "'coerce' argument to setIs ")
  }
  else stop(gettextf("the 'coerce' argument to 'setIs' should be a function of one argument, got an object of class %s", dQuote(class(coerce))), domain = NA)
  if (is.null(test)) {
    test <- .simpleExtTest
    extClass <- "SClassExtension"
  }
  else {
    test <- .ChangeFormals(test, .simpleExtTest, "'test' argument to setIs ")
    extClass <- "conditionalExtension"
  }
  if (is.null(replace)) {
    if (dataPart) {
      extn <- classDef2@contains[[dataPartClass]]
      if (is(extn, "SClassExtension")) 
        easy <- extn@simple
      else easy <- FALSE
      if (easy) 
        replace <- .dataPartReplace$f1
      else {
        replace <- .dataPartReplace$f2
        bdy <- body(replace)
        body(replace, envir = environment(replace)) <- substituteDirect(bdy, list(THISCLASS = dataPartClass))
      }
    }
    else if (simple) {
      replace <- .simpleExtReplace
      if (isXS3Class(classDef2)) {
        S3Class <- attr(classDef2@prototype, ".S3Class")
        if (is.null(S3Class)) 
          S3Class <- to
        body(replace, envir = packageEnv) <- quote({
          S3Part(from) <- value
          from
        })
      }
      else if (isVirtualClass(classDef2)) {
        body(replace, envir = packageEnv) <- substitute({
          if (!is(value, TO)) stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", TO, dQuote(FROM), TO, dQuote(class(value))), domain = NA)
          value
        }, list(FROM = Class, TO = to))
      }
      else if (class1Defined && length(slots) == 0) {
        ext <- getAllSuperClasses(classDef1, TRUE)
        toSlots <- classDef2@slots
        sameSlots <- TRUE
        for (eclass in ext) {
          if (.identC(eclass, to)) 
            next
          edef <- getClassDef(eclass, where = packageEnv)
          if (!is.null(edef) && length(edef@slots) > 0) {
            sameSlots <- FALSE
            break
          }
        }
        if (sameSlots) 
          body(replace, envir = packageEnv) <- substitute({
            class(value) <- FROM
            value
          }, list(FROM = Class))
        else if (length(toSlots) == 0) 
          replace <- .ErrorReplace
      }
      else body(replace, envir = packageEnv) <- .simpleReplaceExpr(classDef2)
    }
    else replace <- .ErrorReplace
    if (identical(replace, .ErrorReplace)) 
      warning(gettextf("there is no automatic definition for 'as(object, \"%s\") <- value' when object has class %s and no 'replace' argument was supplied; replacement will be an error", to, dQuote(Class)), domain = NA)
  }
  else if (is.function(replace)) {
    if (length(formals(replace)) == 2) {
      replace <- .ChangeFormals(replace, .dataPartReplace$f2args, "'replace' argument to setIs ")
      tmp <- .ErrorReplace
      body(tmp, envir = environment(replace)) <- body(replace)
      replace <- tmp
    }
    else replace <- .ChangeFormals(replace, .ErrorReplace, "'replace' argument to setIs ")
  }
  else stop(gettextf("the 'replace' argument to setIs() should be a function of 2 or 3 arguments, got an object of class %s", dQuote(class(replace))), domain = NA)
  new(extClass, subClass = Class, superClass = to, package = package, coerce = coerce, test = test, replace = replace, simple = simple, by = by, dataPart = dataPart, distance = distance)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeGeneric
list(`package:methods` = function (f, fdef, fdefault = fdef, group = list(), valueClass = character(), package = getPackageName(environment(fdef)), signature = NULL, genericFunction = NULL, simpleInheritanceOnly = NULL) 
{
  checkTrace <- function(fun, what, f) {
    if (is(fun, "traceable")) {
      warning(gettextf("the function being used as %s in making a generic function for %s is currently traced; the function used will have tracing removed", what, sQuote(f)), domain = NA)
      .untracedFunction(fun)
    }
    else fun
  }
  if (missing(fdef)) {
    if (missing(fdefault)) 
      stop(gettextf("must supply either a generic function or a function as default for %s", sQuote(f)), domain = NA)
    else if (isBaseFun(fdefault)) {
      fun <- genericForBasic(f)
      if (is.function(fun)) {
        return(fun)
      }
    }
    fdef <- fdefault
    body(fdef) <- substitute(standardGeneric(NAME), list(NAME = f))
    environment(fdef) <- .NamespaceOrPackage(package)
  }
  ev <- new.env()
  parent.env(ev) <- environment(fdef)
  environment(fdef) <- ev
  packageSlot(f) <- package
  assign(".Generic", f, envir = ev)
  fdef <- checkTrace(fdef)
  if (length(valueClass)) 
    fdef <- .ValidateValueClass(fdef, f, valueClass)
  group <- .asGroupArgument(group)
  if (is.null(genericFunction)) 
    value <- new("standardGeneric")
  else if (is(genericFunction, "genericFunction")) 
    value <- genericFunction
  else stop(gettextf("the %s argument must be NULL or a generic function object; got an object of class %s", sQuote("genericFunction"), dQuote(class(genericFunction))), domain = NA)
  value@.Data <- fdef
  value@generic <- f
  value@group <- group
  value@valueClass <- valueClass
  value@package <- package
  args <- formalArgs(fdef)
  if (is.null(signature)) 
    signature <- args
  else if (any(not.s.in.a <- is.na(match(signature, args)))) 
    stop(sprintf(ngettext(sum(not.s.in.a), "non-argument found in the signature: %s", "non-arguments found in the signature: %s"), paste(signature[not.s.in.a], collapse = ", ")), domain = NA)
  dots <- match("...", signature)
  if (!is.na(dots)) {
    if (length(signature) > 1) 
      signature <- signature[-dots]
  }
  if (length(signature) == 0) 
    stop("no suitable arguments to dispatch methods in this function")
  attr(signature, "simpleOnly") <- simpleInheritanceOnly
  value@signature <- signature
  if (is.null(fdefault)) {
  }
  else {
    fdefault <- checkTrace(fdefault)
    if (!identical(formalArgs(fdefault), formalArgs(fdef)) && !is.primitive(fdefault)) 
      stop(sprintf(ngettext(length(fdef), "the formal argument of the generic function for %s (%s) differs from that of the non-generic to be used as the default (%s)", "the formal arguments of the generic function for %s (%s) differ from those of the non-generic to be used as the default (%s)"), f, paste(formalArgs(fdef), collapse = ", "), paste(formalArgs(fdefault), collapse = ", ")), domain = NA)
    fdefault <- asMethodDefinition(fdefault, fdef = value)
    if (is(fdefault, "MethodDefinition")) 
      fdefault@generic <- value@generic
  }
  value@default <- fdefault
  assign(".Methods", fdefault, envir = ev)
  .setupMethodsTables(value, TRUE)
  value@skeleton <- generic.skeleton(f, fdef, fdefault)
  value
}, function (f, fdef, fdefault = fdef, group = list(), valueClass = character(), package = getPackageName(environment(fdef)), signature = NULL, genericFunction = NULL, simpleInheritanceOnly = NULL) 
{
  checkTrace <- function(fun, what, f) {
    if (is(fun, "traceable")) {
      warning(gettextf("the function being used as %s in making a generic function for %s is currently traced; the function used will have tracing removed", what, sQuote(f)), domain = NA)
      .untracedFunction(fun)
    }
    else fun
  }
  if (missing(fdef)) {
    if (missing(fdefault)) 
      stop(gettextf("must supply either a generic function or a function as default for %s", sQuote(f)), domain = NA)
    else if (isBaseFun(fdefault)) {
      fun <- genericForBasic(f)
      if (is.function(fun)) {
        return(fun)
      }
    }
    fdef <- fdefault
    body(fdef) <- substitute(standardGeneric(NAME), list(NAME = f))
    environment(fdef) <- .NamespaceOrPackage(package)
  }
  ev <- new.env()
  parent.env(ev) <- environment(fdef)
  environment(fdef) <- ev
  packageSlot(f) <- package
  assign(".Generic", f, envir = ev)
  fdef <- checkTrace(fdef)
  if (length(valueClass)) 
    fdef <- .ValidateValueClass(fdef, f, valueClass)
  group <- .asGroupArgument(group)
  if (is.null(genericFunction)) 
    value <- new("standardGeneric")
  else if (is(genericFunction, "genericFunction")) 
    value <- genericFunction
  else stop(gettextf("the %s argument must be NULL or a generic function object; got an object of class %s", sQuote("genericFunction"), dQuote(class(genericFunction))), domain = NA)
  value@.Data <- fdef
  value@generic <- f
  value@group <- group
  value@valueClass <- valueClass
  value@package <- package
  args <- formalArgs(fdef)
  if (is.null(signature)) 
    signature <- args
  else if (any(not.s.in.a <- is.na(match(signature, args)))) 
    stop(sprintf(ngettext(sum(not.s.in.a), "non-argument found in the signature: %s", "non-arguments found in the signature: %s"), paste(signature[not.s.in.a], collapse = ", ")), domain = NA)
  dots <- match("...", signature)
  if (!is.na(dots)) {
    if (length(signature) > 1) 
      signature <- signature[-dots]
  }
  if (length(signature) == 0) 
    stop("no suitable arguments to dispatch methods in this function")
  attr(signature, "simpleOnly") <- simpleInheritanceOnly
  value@signature <- signature
  if (is.null(fdefault)) {
  }
  else {
    fdefault <- checkTrace(fdefault)
    if (!identical(formalArgs(fdefault), formalArgs(fdef)) && !is.primitive(fdefault)) 
      stop(sprintf(ngettext(length(fdef), "the formal argument of the generic function for %s (%s) differs from that of the non-generic to be used as the default (%s)", "the formal arguments of the generic function for %s (%s) differ from those of the non-generic to be used as the default (%s)"), f, paste(formalArgs(fdef), collapse = ", "), paste(formalArgs(fdefault), collapse = ", ")), domain = NA)
    fdefault <- asMethodDefinition(fdefault, fdef = value)
    if (is(fdefault, "MethodDefinition")) 
      fdefault@generic <- value@generic
  }
  value@default <- fdefault
  assign(".Methods", fdefault, envir = ev)
  .setupMethodsTables(value, TRUE)
  value@skeleton <- generic.skeleton(f, fdef, fdefault)
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeMethodsList
list(`package:methods` = function (object, level = 1) 
{
  .MlistDeprecated("makeMethodsList()")
  mnames <- allNames(object)
  if (.noMlists()) {
    keep <- mnames %in% c("", "ANY")
    mnames <- mnames[keep]
    object <- object[keep]
  }
  value <- new("MethodsList")
  i <- match("", mnames)
  if (!is.na(i)) {
    mnames[[i]] <- "ANY"
    names(object) <- mnames
  }
  if (anyDuplicated(mnames)) 
    stop(gettextf("duplicate element names in 'MethodsList' at level %d: %s", level, paste("\"", unique(mnames[duplicated(mnames)]), "\"", collapse = ", ")), domain = NA)
  for (i in seq_along(object)) {
    eli <- object[[i]]
    if (is.function(eli) || is(eli, "MethodsList")) {
    }
    else if (is(eli, "list") || is(eli, "named")) 
      object[[i]] <- Recall(eli, NULL, level + 1)
    else stop(gettextf("element %d at level %d (class %s) cannot be interpreted as a function or named list", i, level, dQuote(class(eli))), domain = NA)
  }
  slot(value, "methods") <- object
  value
}, function (object, level = 1) 
{
  .MlistDeprecated("makeMethodsList()")
  mnames <- allNames(object)
  if (.noMlists()) {
    keep <- mnames %in% c("", "ANY")
    mnames <- mnames[keep]
    object <- object[keep]
  }
  value <- new("MethodsList")
  i <- match("", mnames)
  if (!is.na(i)) {
    mnames[[i]] <- "ANY"
    names(object) <- mnames
  }
  if (anyDuplicated(mnames)) 
    stop(gettextf("duplicate element names in 'MethodsList' at level %d: %s", level, paste("\"", unique(mnames[duplicated(mnames)]), "\"", collapse = ", ")), domain = NA)
  for (i in seq_along(object)) {
    eli <- object[[i]]
    if (is.function(eli) || is(eli, "MethodsList")) {
    }
    else if (is(eli, "list") || is(eli, "named")) 
      object[[i]] <- Recall(eli, NULL, level + 1)
    else stop(gettextf("element %d at level %d (class %s) cannot be interpreted as a function or named list", i, level, dQuote(class(eli))), domain = NA)
  }
  slot(value, "methods") <- object
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
makePrototypeFromClassDef
list(`package:methods` = function (slots, ClassDef, extends, where) 
{
  className <- ClassDef@className
  snames <- names(slots)
  supers <- names(extends)
  dataPartClass <- elNamed(slots, ".Data")
  prototype <- ClassDef@prototype
  dataPartDone <- is.null(dataPartClass) || is(prototype, dataPartClass)
  if (!.identC(class(prototype), className) && .isPrototype(prototype)) {
    pnames <- prototype@slots
    prototype <- prototype@object
  }
  else pnames <- names(attributes(prototype))
  if (length(slots) == 0 && !is.null(prototype)) 
    return(prototype)
  for (i in seq_along(extends)) {
    what <- el(supers, i)
    exti <- extends[[i]]
    if (isFALSE(exti@simple)) 
      next
    if (identical(what, "VIRTUAL")) {
    }
    else if (isClass(what, where = packageSlot(exti))) {
      cli <- getClassDef(what, package = packageSlot(exti))
      slotsi <- names(cli@slots)
      pri <- cli@prototype
      if (is.null(prototype)) {
        prototype <- pri
        pnames <- names(attributes(prototype))
      }
      else if (length(slots)) {
        for (slotName in slotsi) {
          if (identical(slotName, ".Data")) {
            if (!dataPartDone) {
              prototype <- setDataPart(prototype, getDataPart(pri), FALSE)
              dataPartDone <- TRUE
            }
          }
          else if (is.na(match(slotName, pnames))) {
            slot(prototype, slotName, check = FALSE) <- attr(pri, slotName)
            pnames <- c(pnames, slotName)
          }
        }
      }
      else if (!dataPartDone && extends(cli, dataPartClass)) {
        prototype <- setDataPart(prototype, pri, FALSE)
        dataPartDone <- TRUE
      }
    }
  }
  if (length(slots) == 0) 
    return(prototype)
  if (is.null(prototype)) 
    prototype <- defaultPrototype()
  pnames <- names(attributes(prototype))
  pslots <- if (.identC(class(prototype), className)) 
    names(attributes(unclass(prototype)))
  else if (isClass(class(prototype))) 
    names(getSlots(getClass(class(prototype))))
  if (!is.na(match(".Data", snames))) {
    dataPartClass <- elNamed(slots, ".Data")
    if (!(isVirtualClass(dataPartClass))) {
      if (isClass(class(prototype), where = where)) {
        prototypeClass <- getClass(class(prototype), where = where)
        OK <- extends(prototypeClass, dataPartClass)
      }
      else OK <- FALSE
      if (isFALSE(OK)) 
        stop(gettextf("in constructing the prototype for class %s: prototype has class %s, but the data part specifies class %s", dQuote(className), dQuote(.class1(prototype)), dQuote(dataPartClass)), domain = NA)
    }
    iData <- -match(".Data", snames)
    snames <- snames[iData]
    slots <- slots[iData]
  }
  for (j in seq_along(snames)) {
    name <- el(snames, j)
    i <- match(name, pnames)
    if (is.na(i)) {
      slot(prototype, name, check = FALSE) <- tryNew(el(slots, j), where)
    }
  }
  extra <- pnames[is.na(match(pnames, snames)) & !is.na(match(pnames, pslots))]
  if (length(extra) && is.na(match("oldClass", supers))) 
    warning(gettextf("in constructing the prototype for class %s, slots in prototype and not in class: %s", dQuote(className), paste(extra, collapse = ", ")), domain = NA)
  slotDefs <- ClassDef@slots
  slotNames <- names(slotDefs)
  pnames <- names(attributes(prototype))
  pnames <- pnames[!is.na(match(pnames, slotNames))]
  check <- rep.int(FALSE, length(pnames))
  for (what in pnames) {
    pwhat <- slot(prototype, what)
    slotClass <- getClassDef(slotDefs[[what]], where)
    if (is.null(slotClass) || !extends(class(pwhat), slotClass)) {
      if (is.null(pwhat)) {
      }
      else if (is(slotClass, "classRepresentation") && slotClass@virtual) {
      }
      else check[match(what, pnames)] <- TRUE
    }
  }
  if (any(check)) 
    stop(gettextf("in making the prototype for class %s elements of the prototype failed to match the corresponding slot class: %s", dQuote(className), paste(pnames[check], "(class", .dQ(slotDefs[match(pnames[check], slotNames)]), ")", collapse = ", ")), domain = NA)
  prototype
}, function (slots, ClassDef, extends, where) 
{
  className <- ClassDef@className
  snames <- names(slots)
  supers <- names(extends)
  dataPartClass <- elNamed(slots, ".Data")
  prototype <- ClassDef@prototype
  dataPartDone <- is.null(dataPartClass) || is(prototype, dataPartClass)
  if (!.identC(class(prototype), className) && .isPrototype(prototype)) {
    pnames <- prototype@slots
    prototype <- prototype@object
  }
  else pnames <- names(attributes(prototype))
  if (length(slots) == 0 && !is.null(prototype)) 
    return(prototype)
  for (i in seq_along(extends)) {
    what <- el(supers, i)
    exti <- extends[[i]]
    if (isFALSE(exti@simple)) 
      next
    if (identical(what, "VIRTUAL")) {
    }
    else if (isClass(what, where = packageSlot(exti))) {
      cli <- getClassDef(what, package = packageSlot(exti))
      slotsi <- names(cli@slots)
      pri <- cli@prototype
      if (is.null(prototype)) {
        prototype <- pri
        pnames <- names(attributes(prototype))
      }
      else if (length(slots)) {
        for (slotName in slotsi) {
          if (identical(slotName, ".Data")) {
            if (!dataPartDone) {
              prototype <- setDataPart(prototype, getDataPart(pri), FALSE)
              dataPartDone <- TRUE
            }
          }
          else if (is.na(match(slotName, pnames))) {
            slot(prototype, slotName, check = FALSE) <- attr(pri, slotName)
            pnames <- c(pnames, slotName)
          }
        }
      }
      else if (!dataPartDone && extends(cli, dataPartClass)) {
        prototype <- setDataPart(prototype, pri, FALSE)
        dataPartDone <- TRUE
      }
    }
  }
  if (length(slots) == 0) 
    return(prototype)
  if (is.null(prototype)) 
    prototype <- defaultPrototype()
  pnames <- names(attributes(prototype))
  pslots <- if (.identC(class(prototype), className)) 
    names(attributes(unclass(prototype)))
  else if (isClass(class(prototype))) 
    names(getSlots(getClass(class(prototype))))
  if (!is.na(match(".Data", snames))) {
    dataPartClass <- elNamed(slots, ".Data")
    if (!(isVirtualClass(dataPartClass))) {
      if (isClass(class(prototype), where = where)) {
        prototypeClass <- getClass(class(prototype), where = where)
        OK <- extends(prototypeClass, dataPartClass)
      }
      else OK <- FALSE
      if (isFALSE(OK)) 
        stop(gettextf("in constructing the prototype for class %s: prototype has class %s, but the data part specifies class %s", dQuote(className), dQuote(.class1(prototype)), dQuote(dataPartClass)), domain = NA)
    }
    iData <- -match(".Data", snames)
    snames <- snames[iData]
    slots <- slots[iData]
  }
  for (j in seq_along(snames)) {
    name <- el(snames, j)
    i <- match(name, pnames)
    if (is.na(i)) {
      slot(prototype, name, check = FALSE) <- tryNew(el(slots, j), where)
    }
  }
  extra <- pnames[is.na(match(pnames, snames)) & !is.na(match(pnames, pslots))]
  if (length(extra) && is.na(match("oldClass", supers))) 
    warning(gettextf("in constructing the prototype for class %s, slots in prototype and not in class: %s", dQuote(className), paste(extra, collapse = ", ")), domain = NA)
  slotDefs <- ClassDef@slots
  slotNames <- names(slotDefs)
  pnames <- names(attributes(prototype))
  pnames <- pnames[!is.na(match(pnames, slotNames))]
  check <- rep.int(FALSE, length(pnames))
  for (what in pnames) {
    pwhat <- slot(prototype, what)
    slotClass <- getClassDef(slotDefs[[what]], where)
    if (is.null(slotClass) || !extends(class(pwhat), slotClass)) {
      if (is.null(pwhat)) {
      }
      else if (is(slotClass, "classRepresentation") && slotClass@virtual) {
      }
      else check[match(what, pnames)] <- TRUE
    }
  }
  if (any(check)) 
    stop(gettextf("in making the prototype for class %s elements of the prototype failed to match the corresponding slot class: %s", dQuote(className), paste(pnames[check], "(class", .dQ(slotDefs[match(pnames[check], slotNames)]), ")", collapse = ", ")), domain = NA)
  prototype
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeStandardGeneric
list(`package:methods` = function (f, fdef) 
{
  fgen <- fdef
  body(fgen) <- substitute(standardGeneric(FNAME), list(FNAME = f))
  if (typeof(fdef) != "closure") {
    fgen <- genericForBasic(f)
    message(gettextf("making a generic for special function %s", sQuote(f)), domain = NA)
    setPrimitiveMethods(f, fdef, "reset", fgen, NULL)
  }
  fgen
}, function (f, fdef) 
{
  fgen <- fdef
  body(fgen) <- substitute(standardGeneric(FNAME), list(FNAME = f))
  if (typeof(fdef) != "closure") {
    fgen <- genericForBasic(f)
    message(gettextf("making a generic for special function %s", sQuote(f)), domain = NA)
    setPrimitiveMethods(f, fdef, "reset", fgen, NULL)
  }
  fgen
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
matchSignature
list(`package:methods` = function (signature, fun, where = baseenv()) 
{
  if (!is(fun, "genericFunction")) 
    stop(gettextf("trying to match a method signature to an object (of class %s) that is not a generic function", dQuote(class(fun))), domain = NA)
  anames <- fun@signature
  if (length(signature) == 0) 
    return(character())
  if (is(signature, "character")) {
    pkgs <- packageSlot(signature)
    if (is.null(pkgs)) 
      pkgs <- character(length(signature))
    else if (length(pkgs) != length(signature)) 
      stop("invalid 'package' slot or attribute, wrong length")
    sigClasses <- as.character(signature)
  }
  else if (is(signature, "list")) {
    sigClasses <- pkgs <- character(length(signature))
    for (i in seq_along(signature)) {
      cli <- signature[[i]]
      if (is(cli, "classRepresentation")) {
        sigClasses[[i]] <- cli@className
        pkgs[[i]] <- cli@package
      }
      else if (is(cli, "character") && length(cli) == 1) {
        sigClasses[[i]] <- cli
        pkgi <- packageSlot(cli)
        if (is.character(pkgi)) 
          pkgs[[i]] <- pkgi
      }
      else stop(gettextf("invalid element in a list for \"signature\" argument; element %d is neither a class definition nor a class name", i), domain = NA)
    }
  }
  else stop(gettextf("trying to match a method signature of class %s; expects a list or a character vector", dQuote(class(signature))), domain = NA)
  if (!identical(where, baseenv())) {
    unknown <- !nzchar(pkgs)
    for (i in seq_along(sigClasses)[unknown]) {
      cli <- getClassDef(sigClasses[[i]], where)
      if (!is.null(cli)) {
        pkgs[[i]] <- cli@package
        unknown[[i]] <- FALSE
      }
    }
    if (any(unknown)) {
      unknown <- unique(sigClasses[unknown])
      MSG <- if (identical(as.vector(coerce@generic), "coerce") && length(unknown) == 1) 
        message
      else function(...) warning(..., call. = FALSE)
      MSG(.renderSignature(fun@generic, signature), sprintf(ngettext(length(unknown), "no definition for class %s", "no definition for classes %s"), paste(dQuote(unknown), collapse = ", ")), domain = NA)
    }
  }
  signature <- as.list(signature)
  if (length(sigClasses) != length(signature)) 
    stop(gettextf("object to use as a method signature for function %s does not look like a legitimate signature (a vector of single class names): there were %d class names, but %d elements in the signature object", sQuote(fun@generic), length(sigClasses), length(signature)), domain = NA)
  if (length(signature) > length(anames)) 
    stop(gettextf("more elements in the method signature (%d) than in the generic signature (%d) for function %s", length(signature), length(anames), sQuote(fun@generic)), domain = NA)
  if (is.null(names(signature))) {
    which <- seq_along(signature)
  }
  else {
    sigList <- signature
    for (i in seq_along(sigList)) sigList[[i]] <- c(sigClasses[[i]], pkgs[[i]])
    fcall <- do.call("call", c("fun", sigList))
    argmatches <- charmatch(names(sigList), anames)
    if (anyNA(argmatches)) 
      stop(gettextf("there are named arguments (%s) in the method signature that are missing from the generic signature, for function %s", paste(sQuote(names(sigList)[is.na(argmatches)]), collapse = ", "), sQuote(fun@generic), domain = NA))
    ambig <- argmatches == 0 & names(sigList) != ""
    if (any(ambig)) 
      stop(gettextf("there are named arguments (%s) in the method signature that ambiguously match the generic signature, for function %s", paste(sQuote(names(sigList)[ambig]), collapse = ", "), sQuote(fun@generic), domain = NA))
    if (identical(anames, formalArgs(fun))) 
      smatch <- match.call(fun, fcall)
    else {
      fmatch <- fun
      ff <- as.list(anames)
      names(ff) <- anames
      formals(fmatch, envir = environment(fun)) <- ff
      smatch <- match.call(fmatch, fcall)
    }
    snames <- names(smatch)[-1]
    which <- match(snames, anames)
    if (anyNA(which)) 
      stop(sprintf(ngettext(sum(is.na(which)), "in the method signature for function %s invalid argument name in the signature: %s", "in the method signature for function %s invalid argument names in the signature: %s"), sQuote(fun@generic), paste(snames[is.na(which)], collapse = ", ")), domain = NA)
    smatch <- smatch[-1]
    for (i in seq_along(smatch)) {
      eli <- smatch[[i]]
      sigClasses[[i]] <- eli[[1]]
      pkgs[[i]] <- eli[[2]]
    }
  }
  n <- length(anames)
  value <- rep("ANY", n)
  valueP <- rep("methods", n)
  names(value) <- anames
  value[which] <- sigClasses
  valueP[which] <- pkgs
  unspec <- value == "ANY"
  while (n > 1 && unspec[[n]]) n <- n - 1
  length(value) <- length(valueP) <- n
  attr(value, "package") <- valueP
  value
}, function (signature, fun, where = baseenv()) 
{
  if (!is(fun, "genericFunction")) 
    stop(gettextf("trying to match a method signature to an object (of class %s) that is not a generic function", dQuote(class(fun))), domain = NA)
  anames <- fun@signature
  if (length(signature) == 0) 
    return(character())
  if (is(signature, "character")) {
    pkgs <- packageSlot(signature)
    if (is.null(pkgs)) 
      pkgs <- character(length(signature))
    else if (length(pkgs) != length(signature)) 
      stop("invalid 'package' slot or attribute, wrong length")
    sigClasses <- as.character(signature)
  }
  else if (is(signature, "list")) {
    sigClasses <- pkgs <- character(length(signature))
    for (i in seq_along(signature)) {
      cli <- signature[[i]]
      if (is(cli, "classRepresentation")) {
        sigClasses[[i]] <- cli@className
        pkgs[[i]] <- cli@package
      }
      else if (is(cli, "character") && length(cli) == 1) {
        sigClasses[[i]] <- cli
        pkgi <- packageSlot(cli)
        if (is.character(pkgi)) 
          pkgs[[i]] <- pkgi
      }
      else stop(gettextf("invalid element in a list for \"signature\" argument; element %d is neither a class definition nor a class name", i), domain = NA)
    }
  }
  else stop(gettextf("trying to match a method signature of class %s; expects a list or a character vector", dQuote(class(signature))), domain = NA)
  if (!identical(where, baseenv())) {
    unknown <- !nzchar(pkgs)
    for (i in seq_along(sigClasses)[unknown]) {
      cli <- getClassDef(sigClasses[[i]], where)
      if (!is.null(cli)) {
        pkgs[[i]] <- cli@package
        unknown[[i]] <- FALSE
      }
    }
    if (any(unknown)) {
      unknown <- unique(sigClasses[unknown])
      MSG <- if (identical(as.vector(coerce@generic), "coerce") && length(unknown) == 1) 
        message
      else function(...) warning(..., call. = FALSE)
      MSG(.renderSignature(fun@generic, signature), sprintf(ngettext(length(unknown), "no definition for class %s", "no definition for classes %s"), paste(dQuote(unknown), collapse = ", ")), domain = NA)
    }
  }
  signature <- as.list(signature)
  if (length(sigClasses) != length(signature)) 
    stop(gettextf("object to use as a method signature for function %s does not look like a legitimate signature (a vector of single class names): there were %d class names, but %d elements in the signature object", sQuote(fun@generic), length(sigClasses), length(signature)), domain = NA)
  if (length(signature) > length(anames)) 
    stop(gettextf("more elements in the method signature (%d) than in the generic signature (%d) for function %s", length(signature), length(anames), sQuote(fun@generic)), domain = NA)
  if (is.null(names(signature))) {
    which <- seq_along(signature)
  }
  else {
    sigList <- signature
    for (i in seq_along(sigList)) sigList[[i]] <- c(sigClasses[[i]], pkgs[[i]])
    fcall <- do.call("call", c("fun", sigList))
    argmatches <- charmatch(names(sigList), anames)
    if (anyNA(argmatches)) 
      stop(gettextf("there are named arguments (%s) in the method signature that are missing from the generic signature, for function %s", paste(sQuote(names(sigList)[is.na(argmatches)]), collapse = ", "), sQuote(fun@generic), domain = NA))
    ambig <- argmatches == 0 & names(sigList) != ""
    if (any(ambig)) 
      stop(gettextf("there are named arguments (%s) in the method signature that ambiguously match the generic signature, for function %s", paste(sQuote(names(sigList)[ambig]), collapse = ", "), sQuote(fun@generic), domain = NA))
    if (identical(anames, formalArgs(fun))) 
      smatch <- match.call(fun, fcall)
    else {
      fmatch <- fun
      ff <- as.list(anames)
      names(ff) <- anames
      formals(fmatch, envir = environment(fun)) <- ff
      smatch <- match.call(fmatch, fcall)
    }
    snames <- names(smatch)[-1]
    which <- match(snames, anames)
    if (anyNA(which)) 
      stop(sprintf(ngettext(sum(is.na(which)), "in the method signature for function %s invalid argument name in the signature: %s", "in the method signature for function %s invalid argument names in the signature: %s"), sQuote(fun@generic), paste(snames[is.na(which)], collapse = ", ")), domain = NA)
    smatch <- smatch[-1]
    for (i in seq_along(smatch)) {
      eli <- smatch[[i]]
      sigClasses[[i]] <- eli[[1]]
      pkgs[[i]] <- eli[[2]]
    }
  }
  n <- length(anames)
  value <- rep("ANY", n)
  valueP <- rep("methods", n)
  names(value) <- anames
  value[which] <- sigClasses
  valueP[which] <- pkgs
  unspec <- value == "ANY"
  while (n > 1 && unspec[[n]]) n <- n - 1
  length(value) <- length(valueP) <- n
  attr(value, "package") <- valueP
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Math
list(`package:methods` = new("groupGenericFunction", .Data = function (x) 
  standardGeneric("Math"), groupMembers = list("abs", "sign", "sqrt", "ceiling", "floor", "trunc", "cummax", "cummin", "cumprod", "cumsum", "exp", "expm1", "log", "log10", "log2", "log1p", "cos", "cosh", "sin", "sinh", "tan", "tanh", "acos", "acosh", "asin", "asinh", "atan", "atanh", "cospi", "sinpi", "tanpi", "gamma", "lgamma", "digamma", "trigamma"), generic = "Math", package = "base", group = list(), valueClass = character(0), signature = "x", default = NULL, skeleton = (function (x) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Math"), domain = NA))(x)), new("groupGenericFunction", .Data = function (x) 
      standardGeneric("Math"), groupMembers = list("abs", "sign", "sqrt", "ceiling", "floor", "trunc", "cummax", "cummin", "cumprod", "cumsum", "exp", "expm1", "log", "log10", "log2", "log1p", "cos", "cosh", "sin", "sinh", "tan", "tanh", "acos", "acosh", "asin", "asinh", "atan", "atanh", "cospi", "sinpi", "tanpi", "gamma", "lgamma", "digamma", "trigamma"), generic = "Math", package = "base", group = list(), valueClass = character(0), signature = "x", default = NULL, skeleton = (function (x) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Math"), domain = NA))(x)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Math2
list(`package:methods` = new("groupGenericFunction", .Data = function (x, digits) 
  standardGeneric("Math2"), groupMembers = list("round", "signif"), generic = "Math2", package = "methods", group = list(), valueClass = character(0), signature = c("x", "digits"), default = NULL, skeleton = (function (x, digits) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Math2"), domain = NA))(x, digits)), new("groupGenericFunction", .Data = function (x, digits) 
      standardGeneric("Math2"), groupMembers = list("round", "signif"), generic = "Math2", package = "methods", group = list(), valueClass = character(0), signature = c("x", "digits"), default = NULL, skeleton = (function (x, digits) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Math2"), domain = NA))(x, digits)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
mergeMethods
list(`package:methods` = function (m1, m2, genericLabel = character()) 
{
  .MlistDeprecated("mergeMethods()")
  if (length(genericLabel) && is(m2, "MethodsList")) 
    m2 <- .GenericInPrimitiveMethods(m2, genericLabel)
  if (is.null(m1) || is(m1, "EmptyMethodsList")) 
    return(m2)
  tmp <- listFromMlist(m2)
  sigs <- tmp[[1]]
  methods <- tmp[[2]]
  for (i in seq_along(sigs)) {
    sigi <- sigs[[i]]
    if (.noMlists() && !identical(unique(sigi), "ANY")) 
      next
    args <- names(sigi)
    m1 <- insertMethod(m1, as.character(sigi), args, methods[[i]], FALSE)
  }
  m1
}, function (m1, m2, genericLabel = character()) 
{
  .MlistDeprecated("mergeMethods()")
  if (length(genericLabel) && is(m2, "MethodsList")) 
    m2 <- .GenericInPrimitiveMethods(m2, genericLabel)
  if (is.null(m1) || is(m1, "EmptyMethodsList")) 
    return(m2)
  tmp <- listFromMlist(m2)
  sigs <- tmp[[1]]
  methods <- tmp[[2]]
  for (i in seq_along(sigs)) {
    sigi <- sigs[[i]]
    if (.noMlists() && !identical(unique(sigi), "ANY")) 
      next
    args <- names(sigi)
    m1 <- insertMethod(m1, as.character(sigi), args, methods[[i]], FALSE)
  }
  m1
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
metaNameUndo
list(`package:methods` = function (strings, prefix, searchForm = FALSE) 
{
  pattern <- methodsPackageMetaName(prefix, "")
  n <- nchar(pattern, "c")
  matched <- substr(strings, 1, n) == pattern
  value <- substring(strings[matched], n + 1)
  pkg <- sub("^[^:]*", "", value)
  if (searchForm) {
    global <- grep(".GlobalEnv", value)
    if (length(global)) {
      pkg[-global] <- paste0("package", pkg[-global])
      pkg[global] <- substring(pkg[global], 2)
    }
  }
  else pkg <- substring(pkg, 2)
  value <- sub(":.*", "", value)
  new("ObjectsWithPackage", value, package = pkg)
}, function (strings, prefix, searchForm = FALSE) 
{
  pattern <- methodsPackageMetaName(prefix, "")
  n <- nchar(pattern, "c")
  matched <- substr(strings, 1, n) == pattern
  value <- substring(strings[matched], n + 1)
  pkg <- sub("^[^:]*", "", value)
  if (searchForm) {
    global <- grep(".GlobalEnv", value)
    if (length(global)) {
      pkg[-global] <- paste0("package", pkg[-global])
      pkg[global] <- substring(pkg[global], 2)
    }
  }
  else pkg <- substring(pkg, 2)
  value <- sub(":.*", "", value)
  new("ObjectsWithPackage", value, package = pkg)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
method.skeleton
list(`package:methods` = function (generic, signature, file, external = FALSE, where = topenv(parent.frame())) 
{
  fdef <- getGeneric(generic, where = where)
  if (is.null(fdef)) {
    fdef <- implicitGeneric(generic, where = where)
    if (is.null(fdef)) 
      stop(gettextf("no function definition found for %s", sQuote(generic)), domain = NA)
  }
  else {
    generic <- fdef@generic
  }
  signature <- matchSignature(signature, fdef)
  if (length(signature) == 0) 
    signature <- "ANY"
  sigNames <- fdef@signature
  length(sigNames) <- length(signature)
  method <- function() {
  }
  formals(method) <- formals(fdef)
  body(method) <- quote({
    stop("need a definition for the method here")
  })
  methodName <- paste(c(generic, signature), collapse = "_")
  if (missing(file)) 
    file <- paste0(methodName, ".R")
  output <- c(paste0("setMethod(\"", generic, "\","), paste0("    signature(", paste0(sigNames, " = \"", signature, "\"", collapse = ", "), "),"))
  method <- deparse(method)
  if (isFALSE(external)) 
    output <- c(output, paste0("    ", method), ")")
  else {
    if (is(external, "character")) 
      methodName <- toString(external)
    method[[1]] <- paste0("`", methodName, "` <- ", method[[1]])
    output <- c(method, "", output, paste0("  `", methodName, "`)"))
  }
  writeLines(output, file)
  message(gettextf("Skeleton of method written to %s", if (is.character(file)) 
    file
    else "connection"), domain = NA)
  invisible(file)
}, function (generic, signature, file, external = FALSE, where = topenv(parent.frame())) 
{
  fdef <- getGeneric(generic, where = where)
  if (is.null(fdef)) {
    fdef <- implicitGeneric(generic, where = where)
    if (is.null(fdef)) 
      stop(gettextf("no function definition found for %s", sQuote(generic)), domain = NA)
  }
  else {
    generic <- fdef@generic
  }
  signature <- matchSignature(signature, fdef)
  if (length(signature) == 0) 
    signature <- "ANY"
  sigNames <- fdef@signature
  length(sigNames) <- length(signature)
  method <- function() {
  }
  formals(method) <- formals(fdef)
  body(method) <- quote({
    stop("need a definition for the method here")
  })
  methodName <- paste(c(generic, signature), collapse = "_")
  if (missing(file)) 
    file <- paste0(methodName, ".R")
  output <- c(paste0("setMethod(\"", generic, "\","), paste0("    signature(", paste0(sigNames, " = \"", signature, "\"", collapse = ", "), "),"))
  method <- deparse(method)
  if (isFALSE(external)) 
    output <- c(output, paste0("    ", method), ")")
  else {
    if (is(external, "character")) 
      methodName <- toString(external)
    method[[1]] <- paste0("`", methodName, "` <- ", method[[1]])
    output <- c(method, "", output, paste0("  `", methodName, "`)"))
  }
  writeLines(output, file)
  message(gettextf("Skeleton of method written to %s", if (is.character(file)) 
    file
    else "connection"), domain = NA)
  invisible(file)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
MethodAddCoerce
list(`package:methods` = function (method, argName, thisClass, methodClass) 
{
  if (.identC(thisClass, methodClass)) 
    return(method)
  ext <- possibleExtends(thisClass, methodClass)
  if (is.logical(ext) || ext@simple) 
    return(method)
  methodInsert <- function(method, addExpr) {
    if (is.function(method)) {
      newBody <- substitute({
        firstExpr
        secondExpr
      }, list(firstExpr = addExpr, secondExpr = body(method)))
      body(method, envir = environment(method)) <- newBody
    }
    else if (is(method, "MethodsList")) {
      .MlistDeprecated()
      methods <- method@allMethods
      for (i in seq_along(methods)) methods[[i]] <- Recall(methods[[i]], addExpr)
      method@allMethods <- methods
    }
    method
  }
  addExpr <- substitute(XXX <- as(XXX, CLASS), list(XXX = argName, CLASS = methodClass))
  methodInsert(method, addExpr)
}, function (method, argName, thisClass, methodClass) 
{
  if (.identC(thisClass, methodClass)) 
    return(method)
  ext <- possibleExtends(thisClass, methodClass)
  if (is.logical(ext) || ext@simple) 
    return(method)
  methodInsert <- function(method, addExpr) {
    if (is.function(method)) {
      newBody <- substitute({
        firstExpr
        secondExpr
      }, list(firstExpr = addExpr, secondExpr = body(method)))
      body(method, envir = environment(method)) <- newBody
    }
    else if (is(method, "MethodsList")) {
      .MlistDeprecated()
      methods <- method@allMethods
      for (i in seq_along(methods)) methods[[i]] <- Recall(methods[[i]], addExpr)
      method@allMethods <- methods
    }
    method
  }
  addExpr <- substitute(XXX <- as(XXX, CLASS), list(XXX = argName, CLASS = methodClass))
  methodInsert(method, addExpr)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
methodSignatureMatrix
list(`package:methods` = function (object, sigSlots = c("target", "defined")) 
{
  if (length(sigSlots)) {
    allSlots <- lapply(sigSlots, slot, object = object)
    n <- max(lengths(allSlots))
    mm <- unlist(lapply(allSlots, function(s) {
      length(s) <- n
      s[is.na(s)] <- "ANY"
      s
    }))
    mm <- matrix(mm, nrow = length(allSlots), byrow = TRUE)
    dimnames(mm) <- list(sigSlots, names(allSlots[[1]]))
    mm
  }
  else matrix(character(), 0, 0)
}, function (object, sigSlots = c("target", "defined")) 
{
  if (length(sigSlots)) {
    allSlots <- lapply(sigSlots, slot, object = object)
    n <- max(lengths(allSlots))
    mm <- unlist(lapply(allSlots, function(s) {
      length(s) <- n
      s[is.na(s)] <- "ANY"
      s
    }))
    mm <- matrix(mm, nrow = length(allSlots), byrow = TRUE)
    dimnames(mm) <- list(sigSlots, names(allSlots[[1]]))
    mm
  }
  else matrix(character(), 0, 0)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
MethodsList
list(`package:methods` = function (.ArgName, ...) 
{
  .MlistDeprecated("MethodsList()")
  value <- makeMethodsList(list(...))
  if (is.name(.ArgName)) {
  }
  else if (is.character(.ArgName) && length(.ArgName) == 1) 
    .ArgName <- as.name(.ArgName)
  else stop("invalid first argument: should be the name of the first argument in the dispatch")
  slot(value, "argument") <- .ArgName
  value
}, function (.ArgName, ...) 
{
  .MlistDeprecated("MethodsList()")
  value <- makeMethodsList(list(...))
  if (is.name(.ArgName)) {
  }
  else if (is.character(.ArgName) && length(.ArgName) == 1) 
    .ArgName <- as.name(.ArgName)
  else stop("invalid first argument: should be the name of the first argument in the dispatch")
  slot(value, "argument") <- .ArgName
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
MethodsListSelect
list(`package:methods` = function (f, env, mlist = NULL, fEnv = if (is(fdef, "genericFunction")) environment(fdef) else baseenv(), finalDefault = finalDefaultMethod(mlist), evalArgs = TRUE, useInherited = TRUE, fdef = getGeneric(f, where = env), resetAllowed = TRUE) 
{
  .MlistDeprecated("MethodsListSelect()")
  if (!resetAllowed) 
    resetMlist <- .getMethodsForDispatch(fdef)
  if (is.null(f)) {
  }
  else {
    fMethods <- .getMethodsForDispatch(fdef)
    if (is.null(mlist) || (evalArgs && is.function(fMethods))) 
      mlist <- fMethods
  }
  resetNeeded <- .setIfBase(f, fdef, mlist)
  if (resetNeeded) {
    on.exit(.setMethodsForDispatch(f, fdef, mlist))
  }
  if (!is(mlist, "MethodsList")) {
    if (is.function(mlist)) {
      on.exit()
      return(mlist)
    }
    if (is.null(f)) 
      stop("invalid method sublist")
    else if (!is.null(mlist)) 
      stop(gettextf("%f is not a valid generic function: methods list was an object of class %s", sQuote(f), dQuote(class(mlist))), domain = NA)
  }
  if (!is.logical(useInherited)) 
    stop(gettextf("%s must be TRUE, FALSE, or a named logical vector of those values; got an object of class %s", sQuote("useInherited"), dQuote(class(useInherited))), domain = NA)
  if (identical(mlist, .getMethodsForDispatch(fdef))) {
    resetNeeded <- TRUE
    .setMethodsForDispatch(f, fdef, finalDefault)
    if (is(mlist, "MethodsList")) {
      on.exit(.setMethodsForDispatch(f, fdef, mlist))
    }
  }
  argName <- slot(mlist, "argument")
  arg <- NULL
  if (evalArgs) {
    if (missingArg(argName, env, TRUE)) 
      thisClass <- "missing"
    else {
      arg <- eval(as.name(argName), env)
      if (missing(arg)) 
        return(finalDefault)
      thisClass <- .class1(arg)
    }
  }
  else thisClass <- get(as.character(argName), envir = env, inherits = FALSE)
  if (isTRUE(useInherited) || isFALSE(useInherited)) 
    thisInherit <- nextUseInherited <- useInherited
  else {
    which <- match(as.character(argName), names(useInherited))
    if (is.na(which)) {
      nextUseInherited <- useInherited
      thisInherit <- TRUE
    }
    else {
      thisInherit <- useInherited[[which]]
      nextUseInherited <- useInherited[-which]
    }
  }
  fromClass <- thisClass
  allMethods <- mlist@allMethods
  which <- match(thisClass, names(allMethods))
  inherited <- is.na(which)
  selection <- if (inherited) 
    NULL
  else allMethods[[which]]
  if (!inherited) {
    if (is.function(selection)) {
      if (is.null(f)) {
        mlist <- .trimMlist(mlist, fromClass)
      }
      value <- mlist
    }
    else {
      method <- Recall(NULL, env, selection, finalDefault = finalDefault, evalArgs = evalArgs, useInherited = nextUseInherited, fdef = fdef, )
      if (is(method, "EmptyMethodsList")) 
        value <- method
      else {
        mlist@allMethods[[which]] <- method
        value <- mlist
      }
    }
  }
  if (inherited || is(value, "EmptyMethodsList")) {
    method <- NULL
    if (thisInherit) {
      allSelections <- inheritedSubMethodLists(arg, fromClass, mlist, env)
      allClasses <- names(allSelections)
      for (i in seq_along(allSelections)) {
        selection <- allSelections[[i]]
        fromClass <- allClasses[[i]]
        if (is.function(selection)) 
          method <- selection
        else if (is(selection, "MethodsList")) {
          method <- Recall(NULL, env, selection, finalDefault = finalDefault, evalArgs = evalArgs, useInherited = nextUseInherited, fdef = fdef)
          if (is(method, "EmptyMethodsList")) 
            selection <- method
        }
        if (!is(selection, "EmptyMethodsList")) 
          break
      }
    }
    if ((is.null(selection) || is(selection, "EmptyMethodsList")) && !is.null(f) && !is.null(finalDefault)) {
      method <- finalDefault
      fromClass <- "ANY"
    }
    if (is.null(method) || is(method, "EmptyMethodsList")) 
      value <- emptyMethodsList(mlist, thisClass)
    else {
      method <- MethodAddCoerce(method, argName, thisClass, fromClass)
      value <- .insertCachedMethods(mlist, as.character(argName), thisClass, fromClass, method)
    }
  }
  if (!is.null(f)) {
    if (is(value, "EmptyMethodsList")) 
      value <- NULL
    if (resetNeeded) {
      on.exit()
      if (resetAllowed) {
        if (is.null(value)) 
          resetMlist <- mlist
        else resetMlist <- value
      }
      .setMethodsForDispatch(f, fdef, resetMlist)
      if (dispatchIsInternal(fdef)) 
        setPrimitiveMethods(f, finalDefault, "set", fdef, resetMlist)
    }
  }
  value
}, function (f, env, mlist = NULL, fEnv = if (is(fdef, "genericFunction")) environment(fdef) else baseenv(), finalDefault = finalDefaultMethod(mlist), evalArgs = TRUE, useInherited = TRUE, fdef = getGeneric(f, where = env), resetAllowed = TRUE) 
{
  .MlistDeprecated("MethodsListSelect()")
  if (!resetAllowed) 
    resetMlist <- .getMethodsForDispatch(fdef)
  if (is.null(f)) {
  }
  else {
    fMethods <- .getMethodsForDispatch(fdef)
    if (is.null(mlist) || (evalArgs && is.function(fMethods))) 
      mlist <- fMethods
  }
  resetNeeded <- .setIfBase(f, fdef, mlist)
  if (resetNeeded) {
    on.exit(.setMethodsForDispatch(f, fdef, mlist))
  }
  if (!is(mlist, "MethodsList")) {
    if (is.function(mlist)) {
      on.exit()
      return(mlist)
    }
    if (is.null(f)) 
      stop("invalid method sublist")
    else if (!is.null(mlist)) 
      stop(gettextf("%f is not a valid generic function: methods list was an object of class %s", sQuote(f), dQuote(class(mlist))), domain = NA)
  }
  if (!is.logical(useInherited)) 
    stop(gettextf("%s must be TRUE, FALSE, or a named logical vector of those values; got an object of class %s", sQuote("useInherited"), dQuote(class(useInherited))), domain = NA)
  if (identical(mlist, .getMethodsForDispatch(fdef))) {
    resetNeeded <- TRUE
    .setMethodsForDispatch(f, fdef, finalDefault)
    if (is(mlist, "MethodsList")) {
      on.exit(.setMethodsForDispatch(f, fdef, mlist))
    }
  }
  argName <- slot(mlist, "argument")
  arg <- NULL
  if (evalArgs) {
    if (missingArg(argName, env, TRUE)) 
      thisClass <- "missing"
    else {
      arg <- eval(as.name(argName), env)
      if (missing(arg)) 
        return(finalDefault)
      thisClass <- .class1(arg)
    }
  }
  else thisClass <- get(as.character(argName), envir = env, inherits = FALSE)
  if (isTRUE(useInherited) || isFALSE(useInherited)) 
    thisInherit <- nextUseInherited <- useInherited
  else {
    which <- match(as.character(argName), names(useInherited))
    if (is.na(which)) {
      nextUseInherited <- useInherited
      thisInherit <- TRUE
    }
    else {
      thisInherit <- useInherited[[which]]
      nextUseInherited <- useInherited[-which]
    }
  }
  fromClass <- thisClass
  allMethods <- mlist@allMethods
  which <- match(thisClass, names(allMethods))
  inherited <- is.na(which)
  selection <- if (inherited) 
    NULL
  else allMethods[[which]]
  if (!inherited) {
    if (is.function(selection)) {
      if (is.null(f)) {
        mlist <- .trimMlist(mlist, fromClass)
      }
      value <- mlist
    }
    else {
      method <- Recall(NULL, env, selection, finalDefault = finalDefault, evalArgs = evalArgs, useInherited = nextUseInherited, fdef = fdef, )
      if (is(method, "EmptyMethodsList")) 
        value <- method
      else {
        mlist@allMethods[[which]] <- method
        value <- mlist
      }
    }
  }
  if (inherited || is(value, "EmptyMethodsList")) {
    method <- NULL
    if (thisInherit) {
      allSelections <- inheritedSubMethodLists(arg, fromClass, mlist, env)
      allClasses <- names(allSelections)
      for (i in seq_along(allSelections)) {
        selection <- allSelections[[i]]
        fromClass <- allClasses[[i]]
        if (is.function(selection)) 
          method <- selection
        else if (is(selection, "MethodsList")) {
          method <- Recall(NULL, env, selection, finalDefault = finalDefault, evalArgs = evalArgs, useInherited = nextUseInherited, fdef = fdef)
          if (is(method, "EmptyMethodsList")) 
            selection <- method
        }
        if (!is(selection, "EmptyMethodsList")) 
          break
      }
    }
    if ((is.null(selection) || is(selection, "EmptyMethodsList")) && !is.null(f) && !is.null(finalDefault)) {
      method <- finalDefault
      fromClass <- "ANY"
    }
    if (is.null(method) || is(method, "EmptyMethodsList")) 
      value <- emptyMethodsList(mlist, thisClass)
    else {
      method <- MethodAddCoerce(method, argName, thisClass, fromClass)
      value <- .insertCachedMethods(mlist, as.character(argName), thisClass, fromClass, method)
    }
  }
  if (!is.null(f)) {
    if (is(value, "EmptyMethodsList")) 
      value <- NULL
    if (resetNeeded) {
      on.exit()
      if (resetAllowed) {
        if (is.null(value)) 
          resetMlist <- mlist
        else resetMlist <- value
      }
      .setMethodsForDispatch(f, fdef, resetMlist)
      if (dispatchIsInternal(fdef)) 
        setPrimitiveMethods(f, finalDefault, "set", fdef, resetMlist)
    }
  }
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
methodsPackageMetaName
list(`package:methods` = function (prefix, name, package = "") 
  .Call(C_R_methodsPackageMetaName, prefix, name, package), function (prefix, name, package = "") 
    .Call(C_R_methodsPackageMetaName, prefix, name, package))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
missingArg
list(`package:methods` = function (symbol, envir = parent.frame(), eval = FALSE) 
  .Call(C_R_missingArg, if (eval) symbol else substitute(symbol), envir), function (symbol, envir = parent.frame(), eval = FALSE) 
    .Call(C_R_missingArg, if (eval) symbol else substitute(symbol), envir))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
multipleClasses
list(`package:methods` = function (details = FALSE) 
{
  classes <- as.list(.classTable, all.names = TRUE)
  dups <- Filter(is.list, classes)
  if (details) 
    dups
  else names(dups)
}, function (details = FALSE) 
{
  classes <- as.list(.classTable, all.names = TRUE)
  dups <- Filter(is.list, classes)
  if (details) 
    dups
  else names(dups)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
new
list(`package:methods` = function (Class, ...) 
{
  ClassDef <- getClass(Class, where = topenv(parent.frame()))
  value <- .Call(C_new_object, ClassDef)
  initialize(value, ...)
}, function (Class, ...) 
{
  ClassDef <- getClass(Class, where = topenv(parent.frame()))
  value <- .Call(C_new_object, ClassDef)
  initialize(value, ...)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
newBasic
list(`package:methods` = function (Class, ...) 
{
  msg <- NULL
  value <- switch(Class, `NULL` = return(NULL), logical = , numeric = , character = , complex = , double = , integer = , raw = , list = as.vector(c(...), Class), expression = eval(substitute(expression(...))), externalptr = {
    if (nargs() > 1) stop("'externalptr' objects cannot be initialized from new()")
    .newExternalptr()
  }, single = as.single(c(...)), array = if (!missing(...)) array(...) else structure(numeric(), dim = 0), matrix = if (!missing(...)) matrix(...) else matrix(0, 0, 0), ts = if (!missing(...)) stats::ts(...) else structure(NA, tsp = c(1, 1, 1), class = "ts"), {
    args <- list(...)
    if (length(args) == 1 && is(args[[1]], Class)) {
      value <- as(args[[1]], Class)
    } else if (is.na(match(Class, .BasicClasses))) msg <- paste0("Calling new() on an undefined and non-basic class (\"", Class, "\")") else msg <- gettextf("initializing objects from class %s with these arguments is not supported", dQuote(Class))
  })
  if (is.null(msg)) 
    value
  else stop(msg, domain = NA)
}, function (Class, ...) 
{
  msg <- NULL
  value <- switch(Class, `NULL` = return(NULL), logical = , numeric = , character = , complex = , double = , integer = , raw = , list = as.vector(c(...), Class), expression = eval(substitute(expression(...))), externalptr = {
    if (nargs() > 1) stop("'externalptr' objects cannot be initialized from new()")
    .newExternalptr()
  }, single = as.single(c(...)), array = if (!missing(...)) array(...) else structure(numeric(), dim = 0), matrix = if (!missing(...)) matrix(...) else matrix(0, 0, 0), ts = if (!missing(...)) stats::ts(...) else structure(NA, tsp = c(1, 1, 1), class = "ts"), {
    args <- list(...)
    if (length(args) == 1 && is(args[[1]], Class)) {
      value <- as(args[[1]], Class)
    } else if (is.na(match(Class, .BasicClasses))) msg <- paste0("Calling new() on an undefined and non-basic class (\"", Class, "\")") else msg <- gettextf("initializing objects from class %s with these arguments is not supported", dQuote(Class))
  })
  if (is.null(msg)) 
    value
  else stop(msg, domain = NA)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
newClassRepresentation
list(`package:methods` = function (...) 
  new("classRepresentation", ...), function (...) 
    new("classRepresentation", ...))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
newEmptyObject
list(`package:methods` = function () 
{
  value <- list()
  value
}, function () 
{
  value <- list()
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Ops
list(`package:methods` = new("groupGenericFunction", .Data = function (e1, e2) 
  standardGeneric("Ops"), groupMembers = list("Arith", "Compare", "Logic"), generic = "Ops", package = "base", group = list(), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Ops"), domain = NA))(e1, e2)), new("groupGenericFunction", .Data = function (e1, e2) 
      standardGeneric("Ops"), groupMembers = list("Arith", "Compare", "Logic"), generic = "Ops", package = "base", group = list(), valueClass = character(0), signature = c("e1", "e2"), default = NULL, skeleton = (function (e1, e2) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Ops"), domain = NA))(e1, e2)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageSlot
list(`package:methods` = function (object) 
  attr(object, "package"), function (object) 
    attr(object, "package"))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageSlot<-
  list(`package:methods` = function (object, value) 
  {
    attr(object, "package") <- value
    object
  }, function (object, value) 
  {
    attr(object, "package") <- value
    object
  })
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
possibleExtends
list(`package:methods` = function (class1, class2, ClassDef1 = getClassDef(class1), ClassDef2 = getClassDef(class2, where = .classEnv(ClassDef1))) 
{
  if (.identC(class1[[1]], class2) || .identC(class2, "ANY")) 
    return(TRUE)
  if (is.null(ClassDef1)) 
    return(FALSE)
  ext <- ClassDef1@contains
  if (!is.null(contained <- ext[[class2]])) 
    contained
  else if (is.null(ClassDef2)) 
    FALSE
  else {
    subs <- ClassDef2@subclasses
    if (!.identC(class(ClassDef2), "classRepresentation") && isClassUnion(ClassDef2)) 
      any(c(class1, names(ext)) %in% names(subs))
    else {
      i <- match(class1, names(subs))
      i <- i[!is.na(i)]
      if (length(i)) 
        subs[[i[1]]]
      else FALSE
    }
  }
}, function (class1, class2, ClassDef1 = getClassDef(class1), ClassDef2 = getClassDef(class2, where = .classEnv(ClassDef1))) 
{
  if (.identC(class1[[1]], class2) || .identC(class2, "ANY")) 
    return(TRUE)
  if (is.null(ClassDef1)) 
    return(FALSE)
  ext <- ClassDef1@contains
  if (!is.null(contained <- ext[[class2]])) 
    contained
  else if (is.null(ClassDef2)) 
    FALSE
  else {
    subs <- ClassDef2@subclasses
    if (!.identC(class(ClassDef2), "classRepresentation") && isClassUnion(ClassDef2)) 
      any(c(class1, names(ext)) %in% names(subs))
    else {
      i <- match(class1, names(subs))
      i <- i[!is.na(i)]
      if (length(i)) 
        subs[[i[1]]]
      else FALSE
    }
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
prohibitGeneric
list(`package:methods` = function (name, where = topenv(parent.frame())) 
{
  .saveToImplicitGenerics(name, FALSE, where)
}, function (name, where = topenv(parent.frame())) 
{
  .saveToImplicitGenerics(name, FALSE, where)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
promptClass
list(`package:methods` = function (clName, filename = NULL, type = "class", keywords = "classes", where = topenv(parent.frame()), generatorName = clName) 
{
  classInSig <- function(g, where, cl) {
    cl %in% unique(unlist(findMethods(g, where)@signatures))
  }
  genWithClass <- function(cl, where) {
    allgen <- getGenerics(where = where)
    ok <- as.logical(unlist(lapply(allgen, classInSig, cl = cl, where = where)))
    allgen[ok]
  }
  sigsList <- function(g, where) {
    methods <- findMethods(g, where)
    value <- methods@signatures
    args <- methods@arguments
    if (length(value)) {
      length(args) <- length(value[[1]])
      value <- lapply(value, function(x) {
        names(x) <- args
        x
      })
    }
    value
  }
  slotClassWithSource <- function(clname) {
    clDef <- getClassDef(clname)
    extds <- names(clDef@contains)
    allslots <- getSlots(clDef)
    for (j in rev(seq_along(extds))) {
      i <- extds[[j]]
      slotsi <- getSlots(getClass(i))
      if (length(slotsi)) 
        allslots[names(slotsi)] <- paste0("\"", as.character(slotsi), "\", from class \"", i, "\"")
    }
    slotsi <- getSlots(clDef)
    if (length(slotsi)) 
      allslots[names(slotsi)] <- paste0("\"", as.character(slotsi), "\"")
    allslots
  }
  cleanPrompt <- function(object, name) {
    value <- utils::prompt(object, name = name, filename = NA)
    for (i in seq_along(value)) {
      item <- value[[i]]
      bad <- grepl("^ *%", item)
      if (any(bad)) 
        value[[i]] <- item[!bad]
    }
    value
  }
  pastePar <- function(x) {
    xn <- names(x)
    x <- as.character(x)
    xn <- if (length(xn) == length(x)) 
      paste(xn, "= ")
    else ""
    paste0("(", paste0(xn, "\"", x, "\"", collapse = ", "), ")")
  }
  escape <- function(txt) gsub("%", "\\%", txt, fixed = TRUE)
  if (is.null(filename)) 
    filename <- paste0(utils:::topicName(type, clName), ".Rd")
  if (!missing(where) && !is.na(match(clName, getClasses(where)))) 
    whereClass <- where
  else {
    whereClass <- utils::find(classMetaName(clName))
    if (length(whereClass) == 0) 
      stop(gettextf("no definition of class %s found", dQuote(clName)), domain = NA)
    else if (length(whereClass) > 1) {
      if (identical(where, topenv(parent.frame()))) {
        whereClass <- whereClass[[1]]
        warning(gettextf("multiple definitions of %s found; using the one on %s", dQuote(clName), whereClass), domain = NA)
      }
      else {
        if (exists(classMetaName(clName), where, inherits = FALSE)) 
          whereClass <- where
        else stop(sprintf(ngettext(length(whereClass), "no definition of class %s in the specified position, %s, definition on : %s", "no definition of class %s in the specified position, %s, definitions on : %s"), dQuote(clName), where, paste(whereClass, collapse = ", ")), domain = NA)
      }
    }
  }
  fullName <- utils:::topicName("class", clName)
  clDef <- getClass(clName, where = whereClass)
  .name <- paste0("\\name{", fullName, "}")
  .type <- paste0("\\docType{", type, "}")
  .alias <- paste0("\\alias{", fullName, "}")
  .title <- sprintf("\\title{Class \\code{\"%s\"}}", clName)
  .desc <- paste0("\\description{", "\n%%  ~~ A concise (1-5 lines) description of what the class is. ~~", "\n}")
  slotclasses <- getSlots(clDef)
  slotnames <- names(slotclasses)
  slotclasses <- as.character(slotclasses)
  nslots <- length(slotclasses)
  clNameQ <- paste0("\"", clName, "\"")
  .usage <- "\\section{Objects from the Class}"
  virtualClass <- isVirtualClass(clName)
  if (virtualClass) {
    .usage <- paste0(.usage, "{A virtual Class: No objects may be created from it.}")
    generator <- NULL
  }
  else {
    if (exists(generatorName, where, inherits = FALSE)) 
      generator <- get(generatorName, where, inherits = FALSE)
    else generator <- NULL
    if (is(generator, "classGeneratorFunction")) {
      promptGenerator <- cleanPrompt(generator, generatorName)
      callString <- .makeCallString(generator, generatorName)
      .alias <- c(.alias, promptGenerator$aliases)
    }
    else {
      initMethod <- unRematchDefinition(selectMethod("initialize", clName))
      argNames <- formalArgs(initMethod)
      argNames[[1]] <- clNameQ
      callString <- .makeCallString(initMethod, "new", argNames)
    }
    .usage <- c(paste0(.usage, "{"), paste0("Objects can be created by calls of the form \\code{", callString, "}."), "%%  ~~ describe objects here ~~ ", "}")
  }
  .slots <- if (nslots > 0) {
    slotclasses <- slotClassWithSource(clName)
    slotnames <- names(slotclasses)
    .slots.head <- c("\\section{Slots}{", "  \\describe{")
    .slots.body <- paste0("    \\item{\\code{", slotnames, "}:}", "{Object of class \\code{", slotclasses, "} ~~ }")
    .slots.tail <- c("  }", "}")
    c(.slots.head, .slots.body, .slots.tail)
  }
  else character()
  .extends <- clDef@contains
  if (length(.extends)) {
    .extends <- showExtends(.extends, printTo = FALSE)
    .extends <- c("\\section{Extends}{", paste0("Class \\code{\"\\linkS4class{", .extends$what, "}\"}, ", gsub("^(by class) (\".*\")$", "\\1 \\\\code{\\2}", .extends$how), "."), "}")
  }
  else .extends <- character()
  nmeths <- length(methnms <- genWithClass(clName, where = whereClass))
  .meths.head <- "\\section{Methods}{"
  .methAliases <- ""
  if (nmeths > 0) {
    .meths.body <- "  \\describe{"
    for (i in 1:nmeths) {
      .sig <- sigsList(methnms[i], where = whereClass)
      for (j in seq_along(.sig)) {
        if (!all(is.na(match(.sig[[j]], clName)))) {
          methn.i <- escape(methnms[i])
          .meths.body <- c(.meths.body, paste0("    \\item{", methn.i, "}{\\code{signature", pastePar(.sig[[j]]), "}: ... }"))
          cur <- paste(.sig[[j]], collapse = ",")
          .methAliases <- paste0(.methAliases, "\\alias{", methn.i, ",", cur, "-method}\n")
        }
      }
    }
    .meths.body <- c(.meths.body, "\t }")
  }
  else {
    .meths.head <- "\\section{Methods}{"
    .meths.body <- paste("No methods defined with class", clNameQ, "in the signature.")
  }
  .meths.tail <- "}"
  .keywords <- paste0("\\keyword{", keywords, "}")
  Rdtxt <- list(name = .name, version = "\\Rdversion{1.1}", type = .type, aliases = .alias, methAliases = .methAliases, title = .title, description = .desc, `section{Objects from the Class}` = .usage, `section{Slots}` = .slots, `section{Extends}` = .extends, `section{Methods}` = c(.meths.head, .meths.body, .meths.tail), references = paste("\\references{\n%%  ~~put references to the", "literature/web site here~~\n}"), author = "\\author{\n%%  ~~who you are~~\n}", note = c("\\note{\n%%  ~~further notes~~\n}", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "", paste("%% ~Make other sections like Warning with", "\\section{Warning }{....} ~"), ""), seealso = c("\\seealso{", paste("%%  ~~objects to See Also as", "\\code{\\link{~~fun~~}}, ~~~"), paste("%%  ~~or \\code{\\linkS4class{CLASSNAME}}", "for links to other classes ~~~"), "}"), examples = c("\\examples{", paste0("showClass(", clNameQ, ")"), "}"), keywords = .keywords)
  if (is(clDef, "refClassRepresentation")) 
    Rdtxt <- refClassPrompt(clDef, Rdtxt, nmeths, nslots, .meths.head)
  else if (is(generator, "classGeneratorFunction")) {
    what <- c("usage", "arguments")
    Rdtxt[what] <- promptGenerator[what]
  }
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  .message("A shell of class documentation has been written", .fileDesc(filename), ".\n")
  invisible(filename)
}, function (clName, filename = NULL, type = "class", keywords = "classes", where = topenv(parent.frame()), generatorName = clName) 
{
  classInSig <- function(g, where, cl) {
    cl %in% unique(unlist(findMethods(g, where)@signatures))
  }
  genWithClass <- function(cl, where) {
    allgen <- getGenerics(where = where)
    ok <- as.logical(unlist(lapply(allgen, classInSig, cl = cl, where = where)))
    allgen[ok]
  }
  sigsList <- function(g, where) {
    methods <- findMethods(g, where)
    value <- methods@signatures
    args <- methods@arguments
    if (length(value)) {
      length(args) <- length(value[[1]])
      value <- lapply(value, function(x) {
        names(x) <- args
        x
      })
    }
    value
  }
  slotClassWithSource <- function(clname) {
    clDef <- getClassDef(clname)
    extds <- names(clDef@contains)
    allslots <- getSlots(clDef)
    for (j in rev(seq_along(extds))) {
      i <- extds[[j]]
      slotsi <- getSlots(getClass(i))
      if (length(slotsi)) 
        allslots[names(slotsi)] <- paste0("\"", as.character(slotsi), "\", from class \"", i, "\"")
    }
    slotsi <- getSlots(clDef)
    if (length(slotsi)) 
      allslots[names(slotsi)] <- paste0("\"", as.character(slotsi), "\"")
    allslots
  }
  cleanPrompt <- function(object, name) {
    value <- utils::prompt(object, name = name, filename = NA)
    for (i in seq_along(value)) {
      item <- value[[i]]
      bad <- grepl("^ *%", item)
      if (any(bad)) 
        value[[i]] <- item[!bad]
    }
    value
  }
  pastePar <- function(x) {
    xn <- names(x)
    x <- as.character(x)
    xn <- if (length(xn) == length(x)) 
      paste(xn, "= ")
    else ""
    paste0("(", paste0(xn, "\"", x, "\"", collapse = ", "), ")")
  }
  escape <- function(txt) gsub("%", "\\%", txt, fixed = TRUE)
  if (is.null(filename)) 
    filename <- paste0(utils:::topicName(type, clName), ".Rd")
  if (!missing(where) && !is.na(match(clName, getClasses(where)))) 
    whereClass <- where
  else {
    whereClass <- utils::find(classMetaName(clName))
    if (length(whereClass) == 0) 
      stop(gettextf("no definition of class %s found", dQuote(clName)), domain = NA)
    else if (length(whereClass) > 1) {
      if (identical(where, topenv(parent.frame()))) {
        whereClass <- whereClass[[1]]
        warning(gettextf("multiple definitions of %s found; using the one on %s", dQuote(clName), whereClass), domain = NA)
      }
      else {
        if (exists(classMetaName(clName), where, inherits = FALSE)) 
          whereClass <- where
        else stop(sprintf(ngettext(length(whereClass), "no definition of class %s in the specified position, %s, definition on : %s", "no definition of class %s in the specified position, %s, definitions on : %s"), dQuote(clName), where, paste(whereClass, collapse = ", ")), domain = NA)
      }
    }
  }
  fullName <- utils:::topicName("class", clName)
  clDef <- getClass(clName, where = whereClass)
  .name <- paste0("\\name{", fullName, "}")
  .type <- paste0("\\docType{", type, "}")
  .alias <- paste0("\\alias{", fullName, "}")
  .title <- sprintf("\\title{Class \\code{\"%s\"}}", clName)
  .desc <- paste0("\\description{", "\n%%  ~~ A concise (1-5 lines) description of what the class is. ~~", "\n}")
  slotclasses <- getSlots(clDef)
  slotnames <- names(slotclasses)
  slotclasses <- as.character(slotclasses)
  nslots <- length(slotclasses)
  clNameQ <- paste0("\"", clName, "\"")
  .usage <- "\\section{Objects from the Class}"
  virtualClass <- isVirtualClass(clName)
  if (virtualClass) {
    .usage <- paste0(.usage, "{A virtual Class: No objects may be created from it.}")
    generator <- NULL
  }
  else {
    if (exists(generatorName, where, inherits = FALSE)) 
      generator <- get(generatorName, where, inherits = FALSE)
    else generator <- NULL
    if (is(generator, "classGeneratorFunction")) {
      promptGenerator <- cleanPrompt(generator, generatorName)
      callString <- .makeCallString(generator, generatorName)
      .alias <- c(.alias, promptGenerator$aliases)
    }
    else {
      initMethod <- unRematchDefinition(selectMethod("initialize", clName))
      argNames <- formalArgs(initMethod)
      argNames[[1]] <- clNameQ
      callString <- .makeCallString(initMethod, "new", argNames)
    }
    .usage <- c(paste0(.usage, "{"), paste0("Objects can be created by calls of the form \\code{", callString, "}."), "%%  ~~ describe objects here ~~ ", "}")
  }
  .slots <- if (nslots > 0) {
    slotclasses <- slotClassWithSource(clName)
    slotnames <- names(slotclasses)
    .slots.head <- c("\\section{Slots}{", "  \\describe{")
    .slots.body <- paste0("    \\item{\\code{", slotnames, "}:}", "{Object of class \\code{", slotclasses, "} ~~ }")
    .slots.tail <- c("  }", "}")
    c(.slots.head, .slots.body, .slots.tail)
  }
  else character()
  .extends <- clDef@contains
  if (length(.extends)) {
    .extends <- showExtends(.extends, printTo = FALSE)
    .extends <- c("\\section{Extends}{", paste0("Class \\code{\"\\linkS4class{", .extends$what, "}\"}, ", gsub("^(by class) (\".*\")$", "\\1 \\\\code{\\2}", .extends$how), "."), "}")
  }
  else .extends <- character()
  nmeths <- length(methnms <- genWithClass(clName, where = whereClass))
  .meths.head <- "\\section{Methods}{"
  .methAliases <- ""
  if (nmeths > 0) {
    .meths.body <- "  \\describe{"
    for (i in 1:nmeths) {
      .sig <- sigsList(methnms[i], where = whereClass)
      for (j in seq_along(.sig)) {
        if (!all(is.na(match(.sig[[j]], clName)))) {
          methn.i <- escape(methnms[i])
          .meths.body <- c(.meths.body, paste0("    \\item{", methn.i, "}{\\code{signature", pastePar(.sig[[j]]), "}: ... }"))
          cur <- paste(.sig[[j]], collapse = ",")
          .methAliases <- paste0(.methAliases, "\\alias{", methn.i, ",", cur, "-method}\n")
        }
      }
    }
    .meths.body <- c(.meths.body, "\t }")
  }
  else {
    .meths.head <- "\\section{Methods}{"
    .meths.body <- paste("No methods defined with class", clNameQ, "in the signature.")
  }
  .meths.tail <- "}"
  .keywords <- paste0("\\keyword{", keywords, "}")
  Rdtxt <- list(name = .name, version = "\\Rdversion{1.1}", type = .type, aliases = .alias, methAliases = .methAliases, title = .title, description = .desc, `section{Objects from the Class}` = .usage, `section{Slots}` = .slots, `section{Extends}` = .extends, `section{Methods}` = c(.meths.head, .meths.body, .meths.tail), references = paste("\\references{\n%%  ~~put references to the", "literature/web site here~~\n}"), author = "\\author{\n%%  ~~who you are~~\n}", note = c("\\note{\n%%  ~~further notes~~\n}", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "", paste("%% ~Make other sections like Warning with", "\\section{Warning }{....} ~"), ""), seealso = c("\\seealso{", paste("%%  ~~objects to See Also as", "\\code{\\link{~~fun~~}}, ~~~"), paste("%%  ~~or \\code{\\linkS4class{CLASSNAME}}", "for links to other classes ~~~"), "}"), examples = c("\\examples{", paste0("showClass(", clNameQ, ")"), "}"), keywords = .keywords)
  if (is(clDef, "refClassRepresentation")) 
    Rdtxt <- refClassPrompt(clDef, Rdtxt, nmeths, nslots, .meths.head)
  else if (is(generator, "classGeneratorFunction")) {
    what <- c("usage", "arguments")
    Rdtxt[what] <- promptGenerator[what]
  }
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  .message("A shell of class documentation has been written", .fileDesc(filename), ".\n")
  invisible(filename)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
promptMethods
list(`package:methods` = function (f, filename = NULL, methods) 
{
  escape <- function(txt) gsub("%", "\\%", txt, fixed = TRUE)
  packageString <- ""
  fdef <- getGeneric(f)
  if (!isGeneric(f, fdef = fdef)) 
    stop(gettextf("no generic function found corresponding to %s", sQuote(f)), domain = NA)
  if (missing(methods)) {
    methods <- findMethods(fdef)
    where <- .genEnv(fdef, topenv(parent.frame()))
    if (!identical(where, .GlobalEnv)) 
      packageString <- sprintf("in Package \\pkg{%s}", getPackageName(where))
  }
  fullName <- utils:::topicName("methods", f)
  n <- length(methods)
  labels <- character(n)
  aliases <- character(n)
  signatures <- findMethodSignatures(methods = methods, target = TRUE)
  args <- colnames(signatures)
  for (i in seq_len(n)) {
    sigi <- signatures[i, ]
    labels[[i]] <- sprintf("\\code{signature(%s)}", paste(sprintf("%s = \"%s\"", args, escape(sigi)), collapse = ", "))
    aliases[[i]] <- paste0("\\alias{", utils:::topicName("method", c(f, signatures[i, ])), "}")
  }
  text <- paste0("\n\\item{", labels, "}{\n%%  ~~describe this method here~~\n}")
  text <- c("\\section{Methods}{\n\\describe{", text, "}}")
  aliasText <- c(paste0("\\alias{", escape(fullName), "}"), escape(aliases))
  if (isFALSE(filename)) 
    return(c(aliasText, text))
  if (is.null(filename) || isTRUE(filename)) 
    filename <- paste0(fullName, ".Rd")
  Rdtxt <- list(name = paste0("\\name{", fullName, "}"), type = "\\docType{methods}", aliases = aliasText, title = sprintf("\\title{ ~~ Methods for Function \\code{%s} %s ~~}", f, packageString), description = paste0("\\description{\n ~~ Methods for function", " \\code{", f, "} ", sub("^in Package", "in package", packageString), " ~~\n}"), `section{Methods}` = text, keywords = c("\\keyword{methods}", "\\keyword{ ~~ other possible keyword(s) ~~ }"))
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  .message("A shell of methods documentation has been written", .fileDesc(filename), ".\n")
  invisible(filename)
}, function (f, filename = NULL, methods) 
{
  escape <- function(txt) gsub("%", "\\%", txt, fixed = TRUE)
  packageString <- ""
  fdef <- getGeneric(f)
  if (!isGeneric(f, fdef = fdef)) 
    stop(gettextf("no generic function found corresponding to %s", sQuote(f)), domain = NA)
  if (missing(methods)) {
    methods <- findMethods(fdef)
    where <- .genEnv(fdef, topenv(parent.frame()))
    if (!identical(where, .GlobalEnv)) 
      packageString <- sprintf("in Package \\pkg{%s}", getPackageName(where))
  }
  fullName <- utils:::topicName("methods", f)
  n <- length(methods)
  labels <- character(n)
  aliases <- character(n)
  signatures <- findMethodSignatures(methods = methods, target = TRUE)
  args <- colnames(signatures)
  for (i in seq_len(n)) {
    sigi <- signatures[i, ]
    labels[[i]] <- sprintf("\\code{signature(%s)}", paste(sprintf("%s = \"%s\"", args, escape(sigi)), collapse = ", "))
    aliases[[i]] <- paste0("\\alias{", utils:::topicName("method", c(f, signatures[i, ])), "}")
  }
  text <- paste0("\n\\item{", labels, "}{\n%%  ~~describe this method here~~\n}")
  text <- c("\\section{Methods}{\n\\describe{", text, "}}")
  aliasText <- c(paste0("\\alias{", escape(fullName), "}"), escape(aliases))
  if (isFALSE(filename)) 
    return(c(aliasText, text))
  if (is.null(filename) || isTRUE(filename)) 
    filename <- paste0(fullName, ".Rd")
  Rdtxt <- list(name = paste0("\\name{", fullName, "}"), type = "\\docType{methods}", aliases = aliasText, title = sprintf("\\title{ ~~ Methods for Function \\code{%s} %s ~~}", f, packageString), description = paste0("\\description{\n ~~ Methods for function", " \\code{", f, "} ", sub("^in Package", "in package", packageString), " ~~\n}"), `section{Methods}` = text, keywords = c("\\keyword{methods}", "\\keyword{ ~~ other possible keyword(s) ~~ }"))
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  .message("A shell of methods documentation has been written", .fileDesc(filename), ".\n")
  invisible(filename)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
prototype
list(`package:methods` = function (...) 
  .prototype(...), function (...) 
    .prototype(...))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Quote
list(`package:methods` = .Primitive("quote"), .Primitive("quote"))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
rbind2
list(`package:methods` = new("standardGeneric", .Data = function (x, y, ...) 
  standardGeneric("rbind2"), generic = "rbind2", package = "methods", group = list(), valueClass = character(0), signature = c("x", "y"), default = NULL, skeleton = (function (x, y, ...) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "rbind2"), domain = NA))(x, y, ...)), new("standardGeneric", .Data = function (x, y, ...) 
      standardGeneric("rbind2"), generic = "rbind2", package = "methods", group = list(), valueClass = character(0), signature = c("x", "y"), default = NULL, skeleton = (function (x, y, ...) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "rbind2"), domain = NA))(x, y, ...)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
reconcilePropertiesAndPrototype
list(`package:methods` = function (name, properties, prototype, superClasses, where) 
{
  StandardPrototype <- defaultPrototype()
  slots <- validSlotNames(allNames(properties))
  dataPartClass <- elNamed(properties, ".Data")
  dataPartValue <- FALSE
  if (!is.null(dataPartClass) && is.null(.validDataPartClass(dataPartClass, where))) 
    stop(gettextf("in defining class %s, the supplied data part class, %s is not valid (must be a basic class or a virtual class combining basic classes)", dQuote(name), dQuote(dataPartClass)), domain = NA)
  prototypeClass <- getClass(class(prototype), where = where)
  if ((!is.null(dataPartClass) || length(superClasses))) {
    for (cl in superClasses) {
      clDef <- getClassDef(cl, where = where)
      if (is.null(clDef)) 
        stop(gettextf("no definition was found for superclass %s in the specification of class %s", dQuote(cl), dQuote(name)), domain = NA)
      thisDataPart <- .validDataPartClass(clDef, where, dataPartClass)
      if (!is.null(thisDataPart)) {
        dataPartClass <- thisDataPart
        if (!is.null(clDef@prototype)) {
          protoClass <- class(clDef@prototype)[1]
          newObject <- if (protoClass %in% .AbnormalTypes) {
            indirect <- .indirectAbnormalClasses[protoClass]
            getClassDef(indirect)@prototype
          }
          else clDef@prototype
          dataPartValue <- TRUE
        }
      }
    }
    if (length(dataPartClass)) {
      if (is.na(match(".Data", slots))) {
        properties <- c(list(.Data = dataPartClass), properties)
        slots <- names(properties)
      }
      else if (!extends(elNamed(properties, ".Data"), dataPartClass)) 
        stop(gettextf("conflicting definition of data part: .Data = %s, superclass implies %s", dQuote(elNamed(properties, ".Data")), dQuote(dataPartClass)), domain = NA)
      if (is.null(prototype)) {
        if (dataPartValue) 
          prototype <- newObject
        else if (isVirtualClass(dataPartClass, where = where)) 
          prototype <- newBasic("logical")
        else prototype <- new(dataPartClass)
        prototypeClass <- getClass(class(prototype), where = where)
      }
      else {
        if (extends(prototypeClass, "classPrototypeDef")) {
          hasDataPart <- isTRUE(prototype@dataPart)
          if (!hasDataPart) {
            if (!dataPartValue) 
              newObject <- new(dataPartClass)
            pobject <- prototype@object
            anames <- names(attributes(pobject))
            attributes(newObject)[anames] <- attributes(pobject)
            prototype@object <- newObject
          }
          else if (!extends(getClass(class(prototype@object), where = where), dataPartClass)) 
            stop(gettextf("a prototype object was supplied with object slot of class %s, but the class definition requires an object that is class %s", dQuote(class(prototype@object)), dQuote(dataPartClass)), domain = NA)
        }
        else if (!extends(prototypeClass, dataPartClass)) 
          stop(gettextf("a prototype was supplied of class %s, but the class definition requires an object that is class %s", dQuote(class(prototype)), dQuote(dataPartClass)), domain = NA)
      }
    }
    if (is.null(prototype)) {
      prototype <- StandardPrototype
    }
  }
  allProps <- properties
  for (cl in superClasses) {
    clDef <- getClassDef(cl, where)
    if (is(clDef, "classRepresentation")) {
      theseProperties <- getSlots(clDef)
      theseSlots <- names(theseProperties)
      theseSlots <- theseSlots[theseSlots != ".Data"]
      dups <- !is.na(match(theseSlots, names(allProps)))
      for (dup in theseSlots[dups]) if (!extends(elNamed(allProps, dup), elNamed(theseProperties, dup))) 
        stop(gettextf("Definition of slot %s, in class %s, as %s conflicts with definition, inherited from class %s, as %s", sQuote(dup), dQuote(name), dQuote(elNamed(allProps, dup)), dQuote(cl), dQuote(elNamed(theseProperties, dup))), domain = NA)
      theseSlots <- theseSlots[!dups]
      if (length(theseSlots)) 
        allProps[theseSlots] <- theseProperties[theseSlots]
    }
    else stop(gettextf("class %s extends an undefined class (%s)", dQuote(name), dQuote(cl)), domain = NA)
  }
  undefinedPrototypeSlots <- setdiff(names(prototype), names(allProps))
  if (length(undefinedPrototypeSlots) > 0) {
    stop(gettextf("The prototype for class %s has undefined slot(s): %s", dQuote(name), paste0("'", undefinedPrototypeSlots, "'", collapse = ", ")))
  }
  if (is.null(dataPartClass)) {
    if (extends(prototypeClass, "classPrototypeDef")) {
    }
    else {
      if (is.list(prototype)) 
        prototype <- do.call("prototype", prototype)
      if (is.null(prototype)) 
        prototype <- StandardPrototype
    }
  }
  else {
    dataPartDef <- getClass(dataPartClass)
    checkDataPart <- !isXS3Class(dataPartDef)
    if (checkDataPart) 
      checkDataPart <- ((is.na(match(dataPartClass, .BasicClasses)) && !isVirtualClass(dataPartDef)) || length(dataPartDef@slots))
    if (checkDataPart) 
      stop(gettextf("%s is not eligible to be the data part of another class (must be a basic class or a virtual class with no slots)", dQuote(dataPartClass)), domain = NA)
    if (extends(prototypeClass, "classPrototypeDef")) {
    }
    else if (extends(prototypeClass, dataPartClass)) {
      if (extends(prototypeClass, "list") && length(names(prototype))) 
        warning("prototype is a list with named elements (could be ambiguous):  better to use function prototype() to avoid trouble.")
    }
    else if (is.list(prototype)) 
      prototype <- do.call("prototype", prototype)
  }
  if (extends(prototypeClass, "classPrototypeDef")) {
    pnames <- prototype@slots
    prototype <- prototype@object
    if (length(superClasses) == 0 && anyNA(match(pnames, slots))) 
      stop(sprintf(ngettext(sum(is.na(match(pnames, slots))), "named elements of prototype do not correspond to slot name: %s", "named elements of prototype do not correspond to slot names: %s"), paste(.dQ(pnames[is.na(match(pnames, slots))]), collapse = ", ")), domain = NA)
  }
  else pnames <- allNames(attributes(prototype))
  what <- seq_along(properties)
  props <- properties[what]
  what <- slots[what]
  nm <- names(attributes(prototype))
  for (i in seq_along(what)) {
    propName <- el(what, i)
    if (!identical(propName, ".Data") && !propName %in% nm) 
      slot(prototype, propName, FALSE) <- tryNew(el(props, i), where)
  }
  list(properties = properties, prototype = prototype)
}, function (name, properties, prototype, superClasses, where) 
{
  StandardPrototype <- defaultPrototype()
  slots <- validSlotNames(allNames(properties))
  dataPartClass <- elNamed(properties, ".Data")
  dataPartValue <- FALSE
  if (!is.null(dataPartClass) && is.null(.validDataPartClass(dataPartClass, where))) 
    stop(gettextf("in defining class %s, the supplied data part class, %s is not valid (must be a basic class or a virtual class combining basic classes)", dQuote(name), dQuote(dataPartClass)), domain = NA)
  prototypeClass <- getClass(class(prototype), where = where)
  if ((!is.null(dataPartClass) || length(superClasses))) {
    for (cl in superClasses) {
      clDef <- getClassDef(cl, where = where)
      if (is.null(clDef)) 
        stop(gettextf("no definition was found for superclass %s in the specification of class %s", dQuote(cl), dQuote(name)), domain = NA)
      thisDataPart <- .validDataPartClass(clDef, where, dataPartClass)
      if (!is.null(thisDataPart)) {
        dataPartClass <- thisDataPart
        if (!is.null(clDef@prototype)) {
          protoClass <- class(clDef@prototype)[1]
          newObject <- if (protoClass %in% .AbnormalTypes) {
            indirect <- .indirectAbnormalClasses[protoClass]
            getClassDef(indirect)@prototype
          }
          else clDef@prototype
          dataPartValue <- TRUE
        }
      }
    }
    if (length(dataPartClass)) {
      if (is.na(match(".Data", slots))) {
        properties <- c(list(.Data = dataPartClass), properties)
        slots <- names(properties)
      }
      else if (!extends(elNamed(properties, ".Data"), dataPartClass)) 
        stop(gettextf("conflicting definition of data part: .Data = %s, superclass implies %s", dQuote(elNamed(properties, ".Data")), dQuote(dataPartClass)), domain = NA)
      if (is.null(prototype)) {
        if (dataPartValue) 
          prototype <- newObject
        else if (isVirtualClass(dataPartClass, where = where)) 
          prototype <- newBasic("logical")
        else prototype <- new(dataPartClass)
        prototypeClass <- getClass(class(prototype), where = where)
      }
      else {
        if (extends(prototypeClass, "classPrototypeDef")) {
          hasDataPart <- isTRUE(prototype@dataPart)
          if (!hasDataPart) {
            if (!dataPartValue) 
              newObject <- new(dataPartClass)
            pobject <- prototype@object
            anames <- names(attributes(pobject))
            attributes(newObject)[anames] <- attributes(pobject)
            prototype@object <- newObject
          }
          else if (!extends(getClass(class(prototype@object), where = where), dataPartClass)) 
            stop(gettextf("a prototype object was supplied with object slot of class %s, but the class definition requires an object that is class %s", dQuote(class(prototype@object)), dQuote(dataPartClass)), domain = NA)
        }
        else if (!extends(prototypeClass, dataPartClass)) 
          stop(gettextf("a prototype was supplied of class %s, but the class definition requires an object that is class %s", dQuote(class(prototype)), dQuote(dataPartClass)), domain = NA)
      }
    }
    if (is.null(prototype)) {
      prototype <- StandardPrototype
    }
  }
  allProps <- properties
  for (cl in superClasses) {
    clDef <- getClassDef(cl, where)
    if (is(clDef, "classRepresentation")) {
      theseProperties <- getSlots(clDef)
      theseSlots <- names(theseProperties)
      theseSlots <- theseSlots[theseSlots != ".Data"]
      dups <- !is.na(match(theseSlots, names(allProps)))
      for (dup in theseSlots[dups]) if (!extends(elNamed(allProps, dup), elNamed(theseProperties, dup))) 
        stop(gettextf("Definition of slot %s, in class %s, as %s conflicts with definition, inherited from class %s, as %s", sQuote(dup), dQuote(name), dQuote(elNamed(allProps, dup)), dQuote(cl), dQuote(elNamed(theseProperties, dup))), domain = NA)
      theseSlots <- theseSlots[!dups]
      if (length(theseSlots)) 
        allProps[theseSlots] <- theseProperties[theseSlots]
    }
    else stop(gettextf("class %s extends an undefined class (%s)", dQuote(name), dQuote(cl)), domain = NA)
  }
  undefinedPrototypeSlots <- setdiff(names(prototype), names(allProps))
  if (length(undefinedPrototypeSlots) > 0) {
    stop(gettextf("The prototype for class %s has undefined slot(s): %s", dQuote(name), paste0("'", undefinedPrototypeSlots, "'", collapse = ", ")))
  }
  if (is.null(dataPartClass)) {
    if (extends(prototypeClass, "classPrototypeDef")) {
    }
    else {
      if (is.list(prototype)) 
        prototype <- do.call("prototype", prototype)
      if (is.null(prototype)) 
        prototype <- StandardPrototype
    }
  }
  else {
    dataPartDef <- getClass(dataPartClass)
    checkDataPart <- !isXS3Class(dataPartDef)
    if (checkDataPart) 
      checkDataPart <- ((is.na(match(dataPartClass, .BasicClasses)) && !isVirtualClass(dataPartDef)) || length(dataPartDef@slots))
    if (checkDataPart) 
      stop(gettextf("%s is not eligible to be the data part of another class (must be a basic class or a virtual class with no slots)", dQuote(dataPartClass)), domain = NA)
    if (extends(prototypeClass, "classPrototypeDef")) {
    }
    else if (extends(prototypeClass, dataPartClass)) {
      if (extends(prototypeClass, "list") && length(names(prototype))) 
        warning("prototype is a list with named elements (could be ambiguous):  better to use function prototype() to avoid trouble.")
    }
    else if (is.list(prototype)) 
      prototype <- do.call("prototype", prototype)
  }
  if (extends(prototypeClass, "classPrototypeDef")) {
    pnames <- prototype@slots
    prototype <- prototype@object
    if (length(superClasses) == 0 && anyNA(match(pnames, slots))) 
      stop(sprintf(ngettext(sum(is.na(match(pnames, slots))), "named elements of prototype do not correspond to slot name: %s", "named elements of prototype do not correspond to slot names: %s"), paste(.dQ(pnames[is.na(match(pnames, slots))]), collapse = ", ")), domain = NA)
  }
  else pnames <- allNames(attributes(prototype))
  what <- seq_along(properties)
  props <- properties[what]
  what <- slots[what]
  nm <- names(attributes(prototype))
  for (i in seq_along(what)) {
    propName <- el(what, i)
    if (!identical(propName, ".Data") && !propName %in% nm) 
      slot(prototype, propName, FALSE) <- tryNew(el(props, i), where)
  }
  list(properties = properties, prototype = prototype)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
registerImplicitGenerics
list(`package:methods` = function (what = .ImplicitGenericsTable(where), where = topenv(parent.frame())) 
{
  if (!is.environment(what)) 
    stop(gettextf("must provide an environment table; got class %s", dQuote(class(what))), domain = NA)
  objs <- as.list(what, all.names = TRUE)
  mapply(.cacheImplicitGeneric, names(objs), objs)
  NULL
}, function (what = .ImplicitGenericsTable(where), where = topenv(parent.frame())) 
{
  if (!is.environment(what)) 
    stop(gettextf("must provide an environment table; got class %s", dQuote(class(what))), domain = NA)
  objs <- as.list(what, all.names = TRUE)
  mapply(.cacheImplicitGeneric, names(objs), objs)
  NULL
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
rematchDefinition
list(`package:methods` = function (definition, generic, mnames, fnames, signature) 
{
  added <- anyNA(match(mnames, fnames))
  keepsDots <- !is.na(match("...", mnames))
  if (!added && keepsDots) {
    formals(definition) <- formals(generic)
    return(definition)
  }
  dotsPos <- match("...", fnames)
  if (added && is.na(dotsPos)) 
    stop(gettextf("methods can add arguments to the generic %s only if '...' is an argument to the generic", sQuote(generic@generic)), call. = TRUE)
  useNames <- (useNm <- !is.na(imf <- match(fnames, mnames))) | fnames == "..."
  if (is.unsorted(imf[useNm])) 
    stop(.renderSignature(generic@generic, signature), "formal arguments in method and generic do not appear in the same order", call. = FALSE)
  clArgs <- fnames[useNames]
  if (keepsDots && dotsPos < length(fnames)) {
    ntrail <- length(fnames) - dotsPos
    trailingArgs <- fnames[seq.int(to = length(fnames), length.out = ntrail)]
    if (!identical(mnames[seq.int(to = length(mnames), length.out = ntrail)], trailingArgs)) 
      stop(gettextf("%s arguments (%s) after %s in the generic must appear in the method, in the same place at the end of the argument list", .renderSignature(generic@generic, signature), paste(sQuote(trailingArgs), collapse = ", "), sQuote("...")), call. = FALSE, domain = NA)
    clNames <- character(length(clArgs))
    clNames[seq.int(to = length(clNames), length.out = ntrail)] <- trailingArgs
  }
  else clNames <- NULL
  if ((iMi <- match("missing", signature, nomatch = 0)) && length(iNm <- which(useNm)) && any(i <- (iMi <= iNm & iNm <= if (is.na(dotsPos)) length(fnames) else dotsPos - 1))) {
    if (is.null(clNames)) 
      clNames <- character(length(clArgs))
    im <- match(fnames[iNm][i], clArgs)
    clNames[im] <- clArgs[im]
  }
  if (!is.null(clNames)) 
    names(clArgs) <- clNames
  newCall <- as.call(lapply(c(".local", clArgs), as.name))
  newBody <- substitute({
    .local <- DEF
    NEWCALL
  }, list(DEF = definition, NEWCALL = newCall))
  generic <- .copyMethodDefaults(generic, definition)
  body(generic, envir = environment(definition)) <- newBody
  generic
}, function (definition, generic, mnames, fnames, signature) 
{
  added <- anyNA(match(mnames, fnames))
  keepsDots <- !is.na(match("...", mnames))
  if (!added && keepsDots) {
    formals(definition) <- formals(generic)
    return(definition)
  }
  dotsPos <- match("...", fnames)
  if (added && is.na(dotsPos)) 
    stop(gettextf("methods can add arguments to the generic %s only if '...' is an argument to the generic", sQuote(generic@generic)), call. = TRUE)
  useNames <- (useNm <- !is.na(imf <- match(fnames, mnames))) | fnames == "..."
  if (is.unsorted(imf[useNm])) 
    stop(.renderSignature(generic@generic, signature), "formal arguments in method and generic do not appear in the same order", call. = FALSE)
  clArgs <- fnames[useNames]
  if (keepsDots && dotsPos < length(fnames)) {
    ntrail <- length(fnames) - dotsPos
    trailingArgs <- fnames[seq.int(to = length(fnames), length.out = ntrail)]
    if (!identical(mnames[seq.int(to = length(mnames), length.out = ntrail)], trailingArgs)) 
      stop(gettextf("%s arguments (%s) after %s in the generic must appear in the method, in the same place at the end of the argument list", .renderSignature(generic@generic, signature), paste(sQuote(trailingArgs), collapse = ", "), sQuote("...")), call. = FALSE, domain = NA)
    clNames <- character(length(clArgs))
    clNames[seq.int(to = length(clNames), length.out = ntrail)] <- trailingArgs
  }
  else clNames <- NULL
  if ((iMi <- match("missing", signature, nomatch = 0)) && length(iNm <- which(useNm)) && any(i <- (iMi <= iNm & iNm <= if (is.na(dotsPos)) length(fnames) else dotsPos - 1))) {
    if (is.null(clNames)) 
      clNames <- character(length(clArgs))
    im <- match(fnames[iNm][i], clArgs)
    clNames[im] <- clArgs[im]
  }
  if (!is.null(clNames)) 
    names(clArgs) <- clNames
  newCall <- as.call(lapply(c(".local", clArgs), as.name))
  newBody <- substitute({
    .local <- DEF
    NEWCALL
  }, list(DEF = definition, NEWCALL = newCall))
  generic <- .copyMethodDefaults(generic, definition)
  body(generic, envir = environment(definition)) <- newBody
  generic
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
removeClass
list(`package:methods` = function (Class, where = topenv(parent.frame())) 
{
  if (missing(where)) {
    classEnv <- .classEnv(Class, where, FALSE)
    classWhere <- findClass(Class, where = classEnv)
    if (length(classWhere) == 0) {
      warning(gettextf("class definition for %s not found (no action taken)", dQuote(Class)), domain = NA)
      return(FALSE)
    }
    if (length(classWhere) > 1) 
      warning(gettextf("class %s has multiple definitions visible; only the first removed", dQuote(Class)), domain = NA)
    classWhere <- classWhere[[1]]
  }
  else classWhere <- where
  classDef <- getClassDef(Class, where = classWhere)
  if (length(classDef@subclasses)) {
    subclasses <- names(classDef@subclasses)
    found <- vapply(subclasses, isClass, NA, where = where, USE.NAMES = TRUE)
    for (what in subclasses[found]) .removeSuperClass(what, Class)
  }
  .removeSuperclassBackRefs(Class, classDef, classWhere)
  .uncacheClass(Class, classDef)
  .undefineMethod("initialize", Class, classWhere)
  what <- classMetaName(Class)
  rm(list = what, pos = classWhere)
  TRUE
}, function (Class, where = topenv(parent.frame())) 
{
  if (missing(where)) {
    classEnv <- .classEnv(Class, where, FALSE)
    classWhere <- findClass(Class, where = classEnv)
    if (length(classWhere) == 0) {
      warning(gettextf("class definition for %s not found (no action taken)", dQuote(Class)), domain = NA)
      return(FALSE)
    }
    if (length(classWhere) > 1) 
      warning(gettextf("class %s has multiple definitions visible; only the first removed", dQuote(Class)), domain = NA)
    classWhere <- classWhere[[1]]
  }
  else classWhere <- where
  classDef <- getClassDef(Class, where = classWhere)
  if (length(classDef@subclasses)) {
    subclasses <- names(classDef@subclasses)
    found <- vapply(subclasses, isClass, NA, where = where, USE.NAMES = TRUE)
    for (what in subclasses[found]) .removeSuperClass(what, Class)
  }
  .removeSuperclassBackRefs(Class, classDef, classWhere)
  .uncacheClass(Class, classDef)
  .undefineMethod("initialize", Class, classWhere)
  what <- classMetaName(Class)
  rm(list = what, pos = classWhere)
  TRUE
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
removeGeneric
list(`package:methods` = function (f, where = topenv(parent.frame())) 
{
  fdef <- NULL
  allEv <- findFunction(f, where = where)
  for (maybeEv in allEv) {
    fdef <- get(f, maybeEv)
    if (is(fdef, "genericFunction")) 
      break
  }
  found <- is(fdef, "genericFunction")
  if (found) {
    .removeMethodsMetaTable(fdef, where)
    oldMetaName <- methodsPackageMetaName("M", fdef@generic, fdef@package)
    if (exists(oldMetaName, where, inherits = FALSE)) 
      rm(list = oldMetaName, pos = where)
    .uncacheGeneric(f, fdef)
    rm(list = fdef@generic, pos = where)
  }
  else {
    if (!is.character(f)) 
      f <- deparse(f)
    warning(gettextf("generic function %s not found for removal", sQuote(f)), domain = NA)
  }
  return(found)
}, function (f, where = topenv(parent.frame())) 
{
  fdef <- NULL
  allEv <- findFunction(f, where = where)
  for (maybeEv in allEv) {
    fdef <- get(f, maybeEv)
    if (is(fdef, "genericFunction")) 
      break
  }
  found <- is(fdef, "genericFunction")
  if (found) {
    .removeMethodsMetaTable(fdef, where)
    oldMetaName <- methodsPackageMetaName("M", fdef@generic, fdef@package)
    if (exists(oldMetaName, where, inherits = FALSE)) 
      rm(list = oldMetaName, pos = where)
    .uncacheGeneric(f, fdef)
    rm(list = fdef@generic, pos = where)
  }
  else {
    if (!is.character(f)) 
      f <- deparse(f)
    warning(gettextf("generic function %s not found for removal", sQuote(f)), domain = NA)
  }
  return(found)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
removeMethod
list(`package:methods` = function (f, signature = character(), where = topenv(parent.frame())) 
{
  if (is.function(f)) {
    if (is(f, "genericFunction")) {
      fdef <- f
      f <- f@generic
    }
    else if (is.primitive(f)) {
      f <- .primname(f)
      fdef <- genericForBasic(f, mustFind = FALSE)
    }
    else stop("function supplied as argument 'f' must be a generic")
  }
  else fdef <- getGeneric(f, where = where)
  if (is.null(fdef)) {
    warning(gettextf("no generic function %s found", sQuote(f)), domain = NA)
    return(FALSE)
  }
  if (is.null(getMethod(fdef, signature, optional = TRUE))) {
    warning(gettextf("no method found for function %s and signature %s", sQuote(fdef@generic), paste(.dQ(signature), collapse = ", ")), domain = NA)
    return(FALSE)
  }
  setMethod(f, signature, NULL, where = where)
  TRUE
}, function (f, signature = character(), where = topenv(parent.frame())) 
{
  if (is.function(f)) {
    if (is(f, "genericFunction")) {
      fdef <- f
      f <- f@generic
    }
    else if (is.primitive(f)) {
      f <- .primname(f)
      fdef <- genericForBasic(f, mustFind = FALSE)
    }
    else stop("function supplied as argument 'f' must be a generic")
  }
  else fdef <- getGeneric(f, where = where)
  if (is.null(fdef)) {
    warning(gettextf("no generic function %s found", sQuote(f)), domain = NA)
    return(FALSE)
  }
  if (is.null(getMethod(fdef, signature, optional = TRUE))) {
    warning(gettextf("no method found for function %s and signature %s", sQuote(fdef@generic), paste(.dQ(signature), collapse = ", ")), domain = NA)
    return(FALSE)
  }
  setMethod(f, signature, NULL, where = where)
  TRUE
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
removeMethods
list(`package:methods` = function (f, where = topenv(parent.frame()), all = missing(where)) 
{
  fdef <- getGeneric(f, where = where)
  if (!is(fdef, "genericFunction")) {
    warning(gettextf("%s is not an S4 generic function in %s; methods not removed", sQuote(f), sQuote(getPackageName(where))), domain = NA)
    return(FALSE)
  }
  methods <- getMethodsForDispatch(fdef)
  default <- getMethod(fdef, "ANY", optional = TRUE)
  fMetaName <- .TableMetaName(fdef@generic, fdef@package)
  oldMetaName <- methodsPackageMetaName("M", fdef@generic, fdef@package)
  allWhere <- .findAll(fMetaName, where)
  if (!all) 
    allWhere <- allWhere[1]
  value <- rep(TRUE, length(allWhere))
  cacheGenericsMetaData(f, fdef, FALSE, where)
  .uncacheGeneric(f, fdef)
  doGeneric <- TRUE
  for (i in seq_along(allWhere)) {
    db <- as.environment(allWhere[[i]])
    if (environmentIsLocked(db)) {
      warning(gettextf("cannot remove methods for %s in locked environment/package %s", sQuote(f), sQuote(getPackageName(db))), domain = NA)
      value[[i]] <- FALSE
      next
    }
    if (exists(fMetaName, db, inherits = FALSE)) {
      theseMethods <- get(fMetaName, db)
      .mergeMethodsTable(fdef, methods, theseMethods, FALSE)
      rm(list = fMetaName, pos = db)
      if (exists(oldMetaName, db, inherits = FALSE)) 
        rm(list = oldMetaName, pos = db)
    }
  }
  all <- all && base::all(value)
  for (i in seq_along(allWhere)) {
    db <- as.environment(allWhere[[i]])
    if (doGeneric && isGeneric(f, db)) {
      if (all && is(default, "derivedDefaultMethod")) {
        default <- as(default, "function")
        rm(list = f, pos = db)
        if (!existsFunction(f, FALSE, db)) {
          message(gettextf("Restoring default function definition of %s", sQuote(f)), domain = NA)
          assign(f, default, db)
        }
      }
      else {
        resetGeneric(f, fdef, where = db, deflt = default)
      }
      doGeneric <- FALSE
    }
  }
  any(value)
}, function (f, where = topenv(parent.frame()), all = missing(where)) 
{
  fdef <- getGeneric(f, where = where)
  if (!is(fdef, "genericFunction")) {
    warning(gettextf("%s is not an S4 generic function in %s; methods not removed", sQuote(f), sQuote(getPackageName(where))), domain = NA)
    return(FALSE)
  }
  methods <- getMethodsForDispatch(fdef)
  default <- getMethod(fdef, "ANY", optional = TRUE)
  fMetaName <- .TableMetaName(fdef@generic, fdef@package)
  oldMetaName <- methodsPackageMetaName("M", fdef@generic, fdef@package)
  allWhere <- .findAll(fMetaName, where)
  if (!all) 
    allWhere <- allWhere[1]
  value <- rep(TRUE, length(allWhere))
  cacheGenericsMetaData(f, fdef, FALSE, where)
  .uncacheGeneric(f, fdef)
  doGeneric <- TRUE
  for (i in seq_along(allWhere)) {
    db <- as.environment(allWhere[[i]])
    if (environmentIsLocked(db)) {
      warning(gettextf("cannot remove methods for %s in locked environment/package %s", sQuote(f), sQuote(getPackageName(db))), domain = NA)
      value[[i]] <- FALSE
      next
    }
    if (exists(fMetaName, db, inherits = FALSE)) {
      theseMethods <- get(fMetaName, db)
      .mergeMethodsTable(fdef, methods, theseMethods, FALSE)
      rm(list = fMetaName, pos = db)
      if (exists(oldMetaName, db, inherits = FALSE)) 
        rm(list = oldMetaName, pos = db)
    }
  }
  all <- all && base::all(value)
  for (i in seq_along(allWhere)) {
    db <- as.environment(allWhere[[i]])
    if (doGeneric && isGeneric(f, db)) {
      if (all && is(default, "derivedDefaultMethod")) {
        default <- as(default, "function")
        rm(list = f, pos = db)
        if (!existsFunction(f, FALSE, db)) {
          message(gettextf("Restoring default function definition of %s", sQuote(f)), domain = NA)
          assign(f, default, db)
        }
      }
      else {
        resetGeneric(f, fdef, where = db, deflt = default)
      }
      doGeneric <- FALSE
    }
  }
  any(value)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
representation
list(`package:methods` = function (...) 
{
  value <- list(...)
  anames <- allNames(value)
  for (i in seq_along(value)) {
    ei <- value[[i]]
    if (!is.character(ei) || length(ei) != 1) 
      stop(gettextf("element %d of the representation was not a single character string", i), domain = NA)
  }
  includes <- as.character(value[!nzchar(anames)])
  if (anyDuplicated(includes)) 
    stop(gettextf("duplicate class names among superclasses: %s", paste(.dQ(includes[duplicated(includes)]), collapse = ", ")), domain = NA)
  slots <- anames[nzchar(anames)]
  if (anyDuplicated(slots)) {
    dslots <- slots[duplicated(slots)]
    stop(sprintf(ngettext(length(dslots), "duplicated slot name: %s", "duplicated slot names: %s"), paste(sQuote(dslots), collapse = "")), domain = NA)
  }
  value
}, function (...) 
{
  value <- list(...)
  anames <- allNames(value)
  for (i in seq_along(value)) {
    ei <- value[[i]]
    if (!is.character(ei) || length(ei) != 1) 
      stop(gettextf("element %d of the representation was not a single character string", i), domain = NA)
  }
  includes <- as.character(value[!nzchar(anames)])
  if (anyDuplicated(includes)) 
    stop(gettextf("duplicate class names among superclasses: %s", paste(.dQ(includes[duplicated(includes)]), collapse = ", ")), domain = NA)
  slots <- anames[nzchar(anames)]
  if (anyDuplicated(slots)) {
    dslots <- slots[duplicated(slots)]
    stop(sprintf(ngettext(length(dslots), "duplicated slot name: %s", "duplicated slot names: %s"), paste(sQuote(dslots), collapse = "")), domain = NA)
  }
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
requireMethods
list(`package:methods` = function (functions, signature, message = "", where = topenv(parent.frame())) 
{
  for (f in functions) {
    method <- getMethod(f, optional = TRUE)
    if (!is.function(method)) 
      method <- getGeneric(f, where = where)
    body(method) <- substitute(stop(methods:::.missingMethod(FF, MESSAGE, if (exists(".Method")) .Method), domain = NA), list(FF = f, MESSAGE = message))
    environment(method) <- .GlobalEnv
    setMethod(f, signature, method, where = where)
  }
  NULL
}, function (functions, signature, message = "", where = topenv(parent.frame())) 
{
  for (f in functions) {
    method <- getMethod(f, optional = TRUE)
    if (!is.function(method)) 
      method <- getGeneric(f, where = where)
    body(method) <- substitute(stop(methods:::.missingMethod(FF, MESSAGE, if (exists(".Method")) .Method), domain = NA), list(FF = f, MESSAGE = message))
    environment(method) <- .GlobalEnv
    setMethod(f, signature, method, where = where)
  }
  NULL
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
resetClass
list(`package:methods` = function (Class, classDef, where) 
{
  if (is(Class, "classRepresentation")) {
    classDef <- Class
    Class <- Class@className
    if (missing(where)) 
      where <- .classDefEnv(classDef)
  }
  else {
    if (missing(where)) {
      if (missing(classDef)) 
        where <- findClass(Class, unique = "resetting the definition")[[1]]
      else where <- .classDefEnv(classDef)
    }
    if (missing(classDef)) {
      classDef <- getClassDef(Class, where)
      if (is.null(classDef)) {
        warning(gettextf("class %s not found on %s; 'resetClass' will have no effect", dQuote(Class), sQuote(getPackageName(where))), domain = NA)
        return(classDef)
      }
    }
    else if (!is(classDef, "classRepresentation")) 
      stop(gettextf("argument 'classDef' must be a string or a class representation; got an object of class %s", dQuote(class(classDef))), domain = NA)
  }
  if (classDef@sealed) 
    warning(gettextf("class %s is sealed; 'resetClass' will have no effect", dQuote(Class)), domain = NA)
  else {
    classDef <- .uncompleteClassDefinition(classDef)
    classDef <- completeClassDefinition(Class, classDef, where)
    assignClassDef(Class, classDef, where)
  }
  classDef
}, function (Class, classDef, where) 
{
  if (is(Class, "classRepresentation")) {
    classDef <- Class
    Class <- Class@className
    if (missing(where)) 
      where <- .classDefEnv(classDef)
  }
  else {
    if (missing(where)) {
      if (missing(classDef)) 
        where <- findClass(Class, unique = "resetting the definition")[[1]]
      else where <- .classDefEnv(classDef)
    }
    if (missing(classDef)) {
      classDef <- getClassDef(Class, where)
      if (is.null(classDef)) {
        warning(gettextf("class %s not found on %s; 'resetClass' will have no effect", dQuote(Class), sQuote(getPackageName(where))), domain = NA)
        return(classDef)
      }
    }
    else if (!is(classDef, "classRepresentation")) 
      stop(gettextf("argument 'classDef' must be a string or a class representation; got an object of class %s", dQuote(class(classDef))), domain = NA)
  }
  if (classDef@sealed) 
    warning(gettextf("class %s is sealed; 'resetClass' will have no effect", dQuote(Class)), domain = NA)
  else {
    classDef <- .uncompleteClassDefinition(classDef)
    classDef <- completeClassDefinition(Class, classDef, where)
    assignClassDef(Class, classDef, where)
  }
  classDef
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
resetGeneric
list(`package:methods` = function (f, fdef = getGeneric(f, where = where), mlist = getMethodsForDispatch(fdef), where = topenv(parent.frame()), deflt = finalDefaultMethod(mlist)) 
{
  if (!is(fdef, "genericFunction")) {
    stop(gettextf("error in updating S4 generic function %s; the function definition is not an S4 generic function (class %s)", sQuote(f), dQuote(class(fdef))), domain = NA)
  }
  .updateMethodsInTable(fdef, attach = "reset")
  f
}, function (f, fdef = getGeneric(f, where = where), mlist = getMethodsForDispatch(fdef), where = topenv(parent.frame()), deflt = finalDefaultMethod(mlist)) 
{
  if (!is(fdef, "genericFunction")) {
    stop(gettextf("error in updating S4 generic function %s; the function definition is not an S4 generic function (class %s)", sQuote(f), dQuote(class(fdef))), domain = NA)
  }
  .updateMethodsInTable(fdef, attach = "reset")
  f
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
S3Class
list(`package:methods` = function (object) 
{
  value <- attr(object, ".S3Class")
  if (is.null(value)) {
    if (isS4(object)) {
      if (is.na(match(".Data", names(getClass(class(object))@slots)))) 
        stop(gettextf("'S3Class' only defined for extensions of %s or classes with a data part:  not true of class %s", dQuote("oldClass"), dQuote(class(object))), domain = NA)
      class(getDataPart(object))
    }
    else class(object)
  }
  else value
}, function (object) 
{
  value <- attr(object, ".S3Class")
  if (is.null(value)) {
    if (isS4(object)) {
      if (is.na(match(".Data", names(getClass(class(object))@slots)))) 
        stop(gettextf("'S3Class' only defined for extensions of %s or classes with a data part:  not true of class %s", dQuote("oldClass"), dQuote(class(object))), domain = NA)
      class(getDataPart(object))
    }
    else class(object)
  }
  else value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
S3Class<-
  list(`package:methods` = function (object, value) 
  {
    if (isS4(object)) {
      current <- attr(object, ".S3Class")
      if (is.null(current)) {
        if (is.na(match(value, .BasicClasses))) 
          stop(gettextf("'S3Class' can only assign to S4 objects that extend \"oldClass\"; not true of class %s", dQuote(class(object))), domain = NA)
        mode(object) <- value
      }
      else slot(object, ".S3Class") <- value
    }
    else class(object) <- value
    object
  }, function (object, value) 
  {
    if (isS4(object)) {
      current <- attr(object, ".S3Class")
      if (is.null(current)) {
        if (is.na(match(value, .BasicClasses))) 
          stop(gettextf("'S3Class' can only assign to S4 objects that extend \"oldClass\"; not true of class %s", dQuote(class(object))), domain = NA)
        mode(object) <- value
      }
      else slot(object, ".S3Class") <- value
    }
    else class(object) <- value
    object
  })
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
S3Part
list(`package:methods` = function (object, strictS3 = FALSE, S3Class) 
{
  if (!isS4(object)) 
    return(object)
  classDef <- getClass(class(object))
  oldClassCase <- extends(classDef, "oldClass")
  defltS3Class <- missing(S3Class)
  if (oldClassCase) {
    if (defltS3Class) 
      S3Class <- .S3Class(object)
    keepSlots <- slotNames(S3Class[[1]])
  }
  else {
    if (all(is.na(match(extends(classDef), .BasicClasses)))) 
      stop(gettextf("S3Part() is only defined for classes set up by setOldCLass(), basic classes or subclasses of these:  not true of class %s", dQuote(class(object))), domain = NA)
    if (missing(S3Class)) {
      S3Class <- classDef@slots$.Data
      if (is.null(S3Class)) 
        S3Class <- typeof(object)
      keepSlots <- character()
    }
    else keepSlots <- slotNames(S3Class[[1]])
  }
  if (!(defltS3Class || extends(classDef, S3Class))) 
    stop(gettextf("the 'S3Class' argument must be a superclass of %s:  not true of class %s", dQuote(class(object)), dQuote(S3Class)), domain = NA)
  if (strictS3) 
    keepSlots <- keepSlots[is.na(match(keepSlots, ".S3Class"))]
  deleteSlots = slotNames(classDef)
  deleteSlots <- deleteSlots[is.na(match(deleteSlots, keepSlots))]
  for (slot in deleteSlots) attr(object, slot) <- NULL
  if (strictS3) {
    object <- .notS4(object)
    class(object) <- S3Class
  }
  else class(object) <- S3Class[[1]]
  object
}, function (object, strictS3 = FALSE, S3Class) 
{
  if (!isS4(object)) 
    return(object)
  classDef <- getClass(class(object))
  oldClassCase <- extends(classDef, "oldClass")
  defltS3Class <- missing(S3Class)
  if (oldClassCase) {
    if (defltS3Class) 
      S3Class <- .S3Class(object)
    keepSlots <- slotNames(S3Class[[1]])
  }
  else {
    if (all(is.na(match(extends(classDef), .BasicClasses)))) 
      stop(gettextf("S3Part() is only defined for classes set up by setOldCLass(), basic classes or subclasses of these:  not true of class %s", dQuote(class(object))), domain = NA)
    if (missing(S3Class)) {
      S3Class <- classDef@slots$.Data
      if (is.null(S3Class)) 
        S3Class <- typeof(object)
      keepSlots <- character()
    }
    else keepSlots <- slotNames(S3Class[[1]])
  }
  if (!(defltS3Class || extends(classDef, S3Class))) 
    stop(gettextf("the 'S3Class' argument must be a superclass of %s:  not true of class %s", dQuote(class(object)), dQuote(S3Class)), domain = NA)
  if (strictS3) 
    keepSlots <- keepSlots[is.na(match(keepSlots, ".S3Class"))]
  deleteSlots = slotNames(classDef)
  deleteSlots <- deleteSlots[is.na(match(deleteSlots, keepSlots))]
  for (slot in deleteSlots) attr(object, slot) <- NULL
  if (strictS3) {
    object <- .notS4(object)
    class(object) <- S3Class
  }
  else class(object) <- S3Class[[1]]
  object
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
S3Part<-
  list(`package:methods` = function (object, strictS3 = FALSE, needClass = .S3Class(object), value) 
  {
    S3Class <- .S3Class(value)
    def <- getClassDef(S3Class[[1]])
    if (is.null(def) || !extends(def, needClass[[1]])) 
      stop(gettextf("replacement value must extend class %s, got %s", dQuote(needClass), dQuote(S3Class[[1]])), domain = NA)
    slots <- slotNames(class(object))
    if (!strictS3) {
      fromValue <- names(attributes(value))
      slots <- slots[is.na(match(slots, fromValue))]
    }
    slots <- c("class", slots)
    for (slot in slots) attr(value, slot) <- attr(object, slot)
    if (extends(def, "oldClass")) 
      attr(value, ".S3Class") <- S3Class
    if (isS4(object)) 
      value <- .asS4(value)
    value
  }, function (object, strictS3 = FALSE, needClass = .S3Class(object), value) 
  {
    S3Class <- .S3Class(value)
    def <- getClassDef(S3Class[[1]])
    if (is.null(def) || !extends(def, needClass[[1]])) 
      stop(gettextf("replacement value must extend class %s, got %s", dQuote(needClass), dQuote(S3Class[[1]])), domain = NA)
    slots <- slotNames(class(object))
    if (!strictS3) {
      fromValue <- names(attributes(value))
      slots <- slots[is.na(match(slots, fromValue))]
    }
    slots <- c("class", slots)
    for (slot in slots) attr(value, slot) <- attr(object, slot)
    if (extends(def, "oldClass")) 
      attr(value, ".S3Class") <- S3Class
    if (isS4(object)) 
      value <- .asS4(value)
    value
  })
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
sealClass
list(`package:methods` = function (Class, where = topenv(parent.frame())) 
{
  if (missing(where)) 
    where <- findClass(Class, unique = "sealing the class", where = where)
  classDef <- getClassDef(Class, where)
  if (!classDef@sealed) {
    classDef@sealed <- TRUE
    assignClassDef(Class, classDef, where)
  }
  invisible(classDef)
}, function (Class, where = topenv(parent.frame())) 
{
  if (missing(where)) 
    where <- findClass(Class, unique = "sealing the class", where = where)
  classDef <- getClassDef(Class, where)
  if (!classDef@sealed) {
    classDef@sealed <- TRUE
    assignClassDef(Class, classDef, where)
  }
  invisible(classDef)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
selectMethod
list(`package:methods` = function (f, signature, optional = FALSE, useInherited = TRUE, mlist = if (!is.null(fdef)) getMethodsForDispatch(fdef), fdef = getGeneric(f, !optional), verbose = FALSE, doCache = FALSE) 
{
  if (is.environment(mlist)) {
    fenv <- environment(fdef)
    nsig <- .getGenericSigLength(fdef, fenv, FALSE)
    if (verbose) 
      cat("* mlist environment with", length(mlist), "potential methods\n")
    if (length(signature) < nsig) 
      signature[(length(signature) + 1):nsig] <- "ANY"
    if (identical(fdef@signature, "...")) {
      method <- .selectDotsMethod(signature, mlist, if (useInherited) 
        getMethodsForDispatch(fdef, inherited = TRUE))
      if (is.null(method) && !optional) 
        stop(gettextf("no method for %s matches class %s", sQuote("..."), dQuote(signature)), domain = NA)
      return(method)
    }
    method <- .findMethodInTable(signature, mlist, fdef)
    if (is.null(method)) {
      if (missing(useInherited)) 
        useInherited <- (is.na(match(signature, "ANY")) & if (identical(fdef, coerce)) 
          c(TRUE, FALSE)
          else TRUE)
      if (verbose) 
        cat("  no direct match found to signature (", paste(signature, collapse = ", "), ")\n", sep = "")
      methods <- if (any(useInherited)) {
        allmethods <- .getMethodsTable(fdef, fenv, check = FALSE, inherited = TRUE)
        .findInheritedMethods(signature, fdef, mtable = allmethods, table = mlist, useInherited = useInherited, verbose = verbose, doCache = doCache)
      }
      if (length(methods)) 
        return(methods[[1]])
      else if (optional) 
        return(NULL)
      else stop(gettextf("no method found for signature %s", paste(signature, collapse = ", ")))
    }
    else return(method)
  }
  else if (is.null(mlist)) {
    if (optional) 
      return(mlist)
    else stop(gettextf("%s has no methods defined", sQuote(f)), domain = NA)
  }
  else stop("selectMethod(): mlist is not an environment or NULL :\n", "** should no longer happen!", domain = NA)
}, function (f, signature, optional = FALSE, useInherited = TRUE, mlist = if (!is.null(fdef)) getMethodsForDispatch(fdef), fdef = getGeneric(f, !optional), verbose = FALSE, doCache = FALSE) 
{
  if (is.environment(mlist)) {
    fenv <- environment(fdef)
    nsig <- .getGenericSigLength(fdef, fenv, FALSE)
    if (verbose) 
      cat("* mlist environment with", length(mlist), "potential methods\n")
    if (length(signature) < nsig) 
      signature[(length(signature) + 1):nsig] <- "ANY"
    if (identical(fdef@signature, "...")) {
      method <- .selectDotsMethod(signature, mlist, if (useInherited) 
        getMethodsForDispatch(fdef, inherited = TRUE))
      if (is.null(method) && !optional) 
        stop(gettextf("no method for %s matches class %s", sQuote("..."), dQuote(signature)), domain = NA)
      return(method)
    }
    method <- .findMethodInTable(signature, mlist, fdef)
    if (is.null(method)) {
      if (missing(useInherited)) 
        useInherited <- (is.na(match(signature, "ANY")) & if (identical(fdef, coerce)) 
          c(TRUE, FALSE)
          else TRUE)
      if (verbose) 
        cat("  no direct match found to signature (", paste(signature, collapse = ", "), ")\n", sep = "")
      methods <- if (any(useInherited)) {
        allmethods <- .getMethodsTable(fdef, fenv, check = FALSE, inherited = TRUE)
        .findInheritedMethods(signature, fdef, mtable = allmethods, table = mlist, useInherited = useInherited, verbose = verbose, doCache = doCache)
      }
      if (length(methods)) 
        return(methods[[1]])
      else if (optional) 
        return(NULL)
      else stop(gettextf("no method found for signature %s", paste(signature, collapse = ", ")))
    }
    else return(method)
  }
  else if (is.null(mlist)) {
    if (optional) 
      return(mlist)
    else stop(gettextf("%s has no methods defined", sQuote(f)), domain = NA)
  }
  else stop("selectMethod(): mlist is not an environment or NULL :\n", "** should no longer happen!", domain = NA)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
selectSuperClasses
list(`package:methods` = function (Class, dropVirtual = FALSE, namesOnly = TRUE, directOnly = TRUE, simpleOnly = directOnly, where = topenv(parent.frame())) 
{
  ext <- if (isClassDef(Class)) 
    Class@contains
  else if (isClass(Class, where = where)) 
    getClass(Class, where = where)@contains
  else stop("'Class' must be a valid class definition or class")
  .selectSuperClasses(ext, dropVirtual = dropVirtual, namesOnly = namesOnly, directOnly = directOnly, simpleOnly = simpleOnly)
}, function (Class, dropVirtual = FALSE, namesOnly = TRUE, directOnly = TRUE, simpleOnly = directOnly, where = topenv(parent.frame())) 
{
  ext <- if (isClassDef(Class)) 
    Class@contains
  else if (isClass(Class, where = where)) 
    getClass(Class, where = where)@contains
  else stop("'Class' must be a valid class definition or class")
  .selectSuperClasses(ext, dropVirtual = dropVirtual, namesOnly = namesOnly, directOnly = directOnly, simpleOnly = simpleOnly)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setAs
list(`package:methods` = function (from, to, def, replace = NULL, where = topenv(parent.frame())) 
{
  fromDef <- getClassDef(from, where)
  toDef <- getClassDef(to, where)
  extds <- possibleExtends(from, to, fromDef, toDef)
  if (is(extds, "SClassExtension")) {
    test <- extds@test
    if (is.null(replace)) 
      replace <- extds@replace
    test <- NULL
    setIs(from, to, test = test, coerce = def, replace = replace, where = where)
  }
  else if (isTRUE(extds)) {
    if (.identC(from, to)) 
      stop(gettextf("trying to set an 'as' relation from %s to itself", dQuote(.class1(from))), domain = NA)
    if (is.null(toDef)) 
      stop(gettextf("class %s is not defined in this environment", dQuote(to)), domain = NA)
    if (isClassUnion(toDef)) 
      stop(gettextf("class %s is a class union: 'coerce' relations to a class union are not meaningful", dQuote(to)), domain = NA)
    setIs(from, to, coerce = def, replace = replace, where = where)
  }
  args <- formalArgs(def)
  if (!is.na(match("strict", args))) 
    args <- args[-match("strict", args)]
  if (length(args) == 1) 
    def <- substituteFunctionArgs(def, "from", functionName = "coerce")
  else if (length(args) != 2 || !identical(args, c("from", "to"))) 
    stop(gettextf("'as' method should have one argument, or match the arguments of coerce(): got  (%s)", paste(formalArgs(def), collapse = ", ")), domain = NA)
  method <- as.list(coerce@.Data)
  method$to <- to
  method <- as.function(method)
  body(method, envir = environment(def)) <- body(def)
  setMethod("coerce", c(from, to), method, where = where)
  if (!is.null(replace)) {
    args <- formalArgs(replace)
    if (identical(args, c("from", "to", "value"))) 
      method <- replace
    else {
      if (length(args) != 2) 
        stop(gettextf("a 'replace' method definition in 'setAs' must be a function of two arguments, got %d", length(args)), domain = NA)
      replace <- body(replace)
      if (!identical(args, c("from", "value"))) {
        ll <- list(quote(from), quote(value))
        names(ll) <- args
        replace <- substituteDirect(replace, ll)
        warning(gettextf("argument names in 'replace' changed to agree with 'coerce<-' generic:\n%s", paste(deparse(replace), sep = "\n    ")), domain = NA)
      }
      method <- eval(function(from, to, value) NULL)
      body(method, envir = .GlobalEnv) <- replace
    }
    setMethod("coerce<-", c(from, to), method, where = where)
  }
}, function (from, to, def, replace = NULL, where = topenv(parent.frame())) 
{
  fromDef <- getClassDef(from, where)
  toDef <- getClassDef(to, where)
  extds <- possibleExtends(from, to, fromDef, toDef)
  if (is(extds, "SClassExtension")) {
    test <- extds@test
    if (is.null(replace)) 
      replace <- extds@replace
    test <- NULL
    setIs(from, to, test = test, coerce = def, replace = replace, where = where)
  }
  else if (isTRUE(extds)) {
    if (.identC(from, to)) 
      stop(gettextf("trying to set an 'as' relation from %s to itself", dQuote(.class1(from))), domain = NA)
    if (is.null(toDef)) 
      stop(gettextf("class %s is not defined in this environment", dQuote(to)), domain = NA)
    if (isClassUnion(toDef)) 
      stop(gettextf("class %s is a class union: 'coerce' relations to a class union are not meaningful", dQuote(to)), domain = NA)
    setIs(from, to, coerce = def, replace = replace, where = where)
  }
  args <- formalArgs(def)
  if (!is.na(match("strict", args))) 
    args <- args[-match("strict", args)]
  if (length(args) == 1) 
    def <- substituteFunctionArgs(def, "from", functionName = "coerce")
  else if (length(args) != 2 || !identical(args, c("from", "to"))) 
    stop(gettextf("'as' method should have one argument, or match the arguments of coerce(): got  (%s)", paste(formalArgs(def), collapse = ", ")), domain = NA)
  method <- as.list(coerce@.Data)
  method$to <- to
  method <- as.function(method)
  body(method, envir = environment(def)) <- body(def)
  setMethod("coerce", c(from, to), method, where = where)
  if (!is.null(replace)) {
    args <- formalArgs(replace)
    if (identical(args, c("from", "to", "value"))) 
      method <- replace
    else {
      if (length(args) != 2) 
        stop(gettextf("a 'replace' method definition in 'setAs' must be a function of two arguments, got %d", length(args)), domain = NA)
      replace <- body(replace)
      if (!identical(args, c("from", "value"))) {
        ll <- list(quote(from), quote(value))
        names(ll) <- args
        replace <- substituteDirect(replace, ll)
        warning(gettextf("argument names in 'replace' changed to agree with 'coerce<-' generic:\n%s", paste(deparse(replace), sep = "\n    ")), domain = NA)
      }
      method <- eval(function(from, to, value) NULL)
      body(method, envir = .GlobalEnv) <- replace
    }
    setMethod("coerce<-", c(from, to), method, where = where)
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setClass
list(`package:methods` = function (Class, representation = list(), prototype = NULL, contains = character(), validity = NULL, access = list(), where = topenv(parent.frame()), version = .newExternalptr(), sealed = FALSE, package = getPackageName(where), S3methods = FALSE, slots) 
{
  oldDef <- getClassDef(Class, where)
  if (is(oldDef, "classRepresentation") && oldDef@sealed) 
    stop(gettextf("%s has a sealed class definition and cannot be redefined", dQuote(Class)), domain = NA)
  if (!missing(slots)) {
    if (!missing(representation)) 
      stop("Argument \"representation\" cannot be used if argument \"slots\" is supplied")
    properties <- inferProperties(slots, "slot")
    classDef <- makeClassRepresentation(Class, properties, contains, prototype, package, validity, access, version, sealed, where = where)
  }
  else if (is(representation, "classRepresentation")) {
    classDef <- representation
    if (!(missing(prototype) && missing(contains) && missing(validity) && missing(access) && missing(version) && missing(package))) 
      stop("only arguments 'Class' and 'where' can be supplied when argument 'representation' is a 'classRepresentation' object")
    if (length(classDef@package) == 0) 
      classDef@package <- package
  }
  else {
    if (is.character(representation) && length(representation) == 1 && is.null(names(representation))) 
      representation <- list(representation)
    slots <- nzchar(allNames(representation))
    superClasses <- c(as.character(representation[!slots]), contains)
    properties <- representation[slots]
    classDef <- makeClassRepresentation(Class, properties, superClasses, prototype, package, validity, access, version, sealed, where = where)
  }
  superClasses <- names(classDef@contains)
  classDef <- completeClassDefinition(Class, classDef, where, doExtends = FALSE)
  .uncacheClass(Class, classDef)
  if (length(superClasses) > 0) {
    sealed <- classDef@sealed
    classDef@sealed <- FALSE
    assignClassDef(Class, classDef, where)
    badContains <- character()
    for (ext in classDef@contains) {
      class2 <- ext@superClass
      if (is(try(setIs(Class, class2, classDef = classDef, where = where)), "try-error")) 
        badContains <- c(badContains, class2)
      else {
        classDef <- getClassDef(Class, where = where)
        if (is.null(classDef)) 
          stop(sprintf("internal error: definition of class %s not properly assigned", dQuote(Class)), domain = NA)
      }
    }
    if (length(badContains)) {
      msg <- paste(.dQ(badContains), collapse = ", ")
      if (is(try(removeClass(Class, where)), "try-error")) 
        stop(gettextf("error in contained classes (%s) for class %s and unable to remove definition from %s", msg, dQuote(Class), sQuote(getPackageName(where))), domain = NA)
      if (is.null(oldDef)) 
        stop(gettextf("error in contained classes (%s) for class %s; class definition removed from %s", msg, dQuote(Class), sQuote(getPackageName(where))), domain = NA)
      else if (is(try(setClass(Class, oldDef, where = where)), "try-error")) 
        stop(gettextf("error in contained classes (%s) for class %s and unable to restore previous definition from %s", msg, dQuote(Class), sQuote(getPackageName(where))), domain = NA)
      else stop(gettextf("error in contained classes (%s) for class %s; previous definition restored to %s", msg, dQuote(Class), sQuote(getPackageName(where))), domain = NA)
    }
    if (length(attr(classDef@contains, "conflicts")) > 0) 
      .reportSuperclassConflicts(Class, classDef@contains, where)
    .checkRequiredGenerics(Class, classDef, where)
    if (sealed) {
      classDef@sealed <- TRUE
    }
  }
  if (S3methods) 
    classDef <- .setS3MethodsOn(classDef)
  assignClassDef(Class, classDef, where)
  invisible(classGeneratorFunction(classDef, where))
}, function (Class, representation = list(), prototype = NULL, contains = character(), validity = NULL, access = list(), where = topenv(parent.frame()), version = .newExternalptr(), sealed = FALSE, package = getPackageName(where), S3methods = FALSE, slots) 
{
  oldDef <- getClassDef(Class, where)
  if (is(oldDef, "classRepresentation") && oldDef@sealed) 
    stop(gettextf("%s has a sealed class definition and cannot be redefined", dQuote(Class)), domain = NA)
  if (!missing(slots)) {
    if (!missing(representation)) 
      stop("Argument \"representation\" cannot be used if argument \"slots\" is supplied")
    properties <- inferProperties(slots, "slot")
    classDef <- makeClassRepresentation(Class, properties, contains, prototype, package, validity, access, version, sealed, where = where)
  }
  else if (is(representation, "classRepresentation")) {
    classDef <- representation
    if (!(missing(prototype) && missing(contains) && missing(validity) && missing(access) && missing(version) && missing(package))) 
      stop("only arguments 'Class' and 'where' can be supplied when argument 'representation' is a 'classRepresentation' object")
    if (length(classDef@package) == 0) 
      classDef@package <- package
  }
  else {
    if (is.character(representation) && length(representation) == 1 && is.null(names(representation))) 
      representation <- list(representation)
    slots <- nzchar(allNames(representation))
    superClasses <- c(as.character(representation[!slots]), contains)
    properties <- representation[slots]
    classDef <- makeClassRepresentation(Class, properties, superClasses, prototype, package, validity, access, version, sealed, where = where)
  }
  superClasses <- names(classDef@contains)
  classDef <- completeClassDefinition(Class, classDef, where, doExtends = FALSE)
  .uncacheClass(Class, classDef)
  if (length(superClasses) > 0) {
    sealed <- classDef@sealed
    classDef@sealed <- FALSE
    assignClassDef(Class, classDef, where)
    badContains <- character()
    for (ext in classDef@contains) {
      class2 <- ext@superClass
      if (is(try(setIs(Class, class2, classDef = classDef, where = where)), "try-error")) 
        badContains <- c(badContains, class2)
      else {
        classDef <- getClassDef(Class, where = where)
        if (is.null(classDef)) 
          stop(sprintf("internal error: definition of class %s not properly assigned", dQuote(Class)), domain = NA)
      }
    }
    if (length(badContains)) {
      msg <- paste(.dQ(badContains), collapse = ", ")
      if (is(try(removeClass(Class, where)), "try-error")) 
        stop(gettextf("error in contained classes (%s) for class %s and unable to remove definition from %s", msg, dQuote(Class), sQuote(getPackageName(where))), domain = NA)
      if (is.null(oldDef)) 
        stop(gettextf("error in contained classes (%s) for class %s; class definition removed from %s", msg, dQuote(Class), sQuote(getPackageName(where))), domain = NA)
      else if (is(try(setClass(Class, oldDef, where = where)), "try-error")) 
        stop(gettextf("error in contained classes (%s) for class %s and unable to restore previous definition from %s", msg, dQuote(Class), sQuote(getPackageName(where))), domain = NA)
      else stop(gettextf("error in contained classes (%s) for class %s; previous definition restored to %s", msg, dQuote(Class), sQuote(getPackageName(where))), domain = NA)
    }
    if (length(attr(classDef@contains, "conflicts")) > 0) 
      .reportSuperclassConflicts(Class, classDef@contains, where)
    .checkRequiredGenerics(Class, classDef, where)
    if (sealed) {
      classDef@sealed <- TRUE
    }
  }
  if (S3methods) 
    classDef <- .setS3MethodsOn(classDef)
  assignClassDef(Class, classDef, where)
  invisible(classGeneratorFunction(classDef, where))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setClassUnion
list(`package:methods` = function (name, members = character(), where = topenv(parent.frame())) 
{
  if (length(members) > 0) {
    membersDefined <- sapply(members, isClass, where = as.environment(where))
    if (!all(membersDefined)) 
      stop(gettextf("the member classes must be defined: not true of %s", paste(.dQ(as(members[!membersDefined], "character")), collapse = ", ")), domain = NA)
  }
  def <- new("ClassUnionRepresentation", makeClassRepresentation(name, package = getPackageName(where), where = where))
  prev <- getClassDef(name, where = where)
  value <- setClass(name, def, where = where)
  failed <- character()
  hasNull <- match("NULL", members, 0)
  if (hasNull) 
    members <- c("NULL", members[-hasNull])
  for (what in members) {
    ext <- def@subclasses[[what]]
    if (is(try(setIs(what, name, where = where, extensionObject = ext)), "try-error")) {
      if (!is.character(what)) 
        what <- getClass(what, TRUE, where)@className
      failed <- c(failed, what)
    }
  }
  if (length(failed) > 0) {
    if (is.null(prev)) 
      try(removeClass(name, where = where))
    else try(setClass(name, prev, where = where))
    stop(gettextf("unable to create union class:  could not set members %s", paste(.dQ(failed), collapse = ", ")), domain = NA)
  }
  invisible(value)
}, function (name, members = character(), where = topenv(parent.frame())) 
{
  if (length(members) > 0) {
    membersDefined <- sapply(members, isClass, where = as.environment(where))
    if (!all(membersDefined)) 
      stop(gettextf("the member classes must be defined: not true of %s", paste(.dQ(as(members[!membersDefined], "character")), collapse = ", ")), domain = NA)
  }
  def <- new("ClassUnionRepresentation", makeClassRepresentation(name, package = getPackageName(where), where = where))
  prev <- getClassDef(name, where = where)
  value <- setClass(name, def, where = where)
  failed <- character()
  hasNull <- match("NULL", members, 0)
  if (hasNull) 
    members <- c("NULL", members[-hasNull])
  for (what in members) {
    ext <- def@subclasses[[what]]
    if (is(try(setIs(what, name, where = where, extensionObject = ext)), "try-error")) {
      if (!is.character(what)) 
        what <- getClass(what, TRUE, where)@className
      failed <- c(failed, what)
    }
  }
  if (length(failed) > 0) {
    if (is.null(prev)) 
      try(removeClass(name, where = where))
    else try(setClass(name, prev, where = where))
    stop(gettextf("unable to create union class:  could not set members %s", paste(.dQ(failed), collapse = ", ")), domain = NA)
  }
  invisible(value)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setDataPart
list(`package:methods` = function (object, value, check = TRUE) 
{
  if (check || typeof(object) == "S4") {
    classDef <- getClass(class(object))
    slots <- getSlots(classDef)
    dataSlot <- .dataSlot(names(slots))
    if (length(dataSlot) == 1) 
      dataClass <- elNamed(slots, dataSlot)
    else if (check) 
      stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
    else return(.mergeAttrs(value, object))
    value <- as(value, dataClass)
    if (typeof(object) == "S4") {
      if (is.null(value)) 
        value <- .pseudoNULL
      attr(object, dataSlot) <- value
      return(object)
    }
  }
  .mergeAttrs(value, object)
}, function (object, value, check = TRUE) 
{
  if (check || typeof(object) == "S4") {
    classDef <- getClass(class(object))
    slots <- getSlots(classDef)
    dataSlot <- .dataSlot(names(slots))
    if (length(dataSlot) == 1) 
      dataClass <- elNamed(slots, dataSlot)
    else if (check) 
      stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
    else return(.mergeAttrs(value, object))
    value <- as(value, dataClass)
    if (typeof(object) == "S4") {
      if (is.null(value)) 
        value <- .pseudoNULL
      attr(object, dataSlot) <- value
      return(object)
    }
  }
  .mergeAttrs(value, object)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setGeneric
list(`package:methods` = function (name, def = NULL, group = list(), valueClass = character(), where = topenv(parent.frame()), package = NULL, signature = NULL, useAsDefault = NULL, genericFunction = NULL, simpleInheritanceOnly = NULL) 
{
  if (is.character(.isSingleName(name))) 
    stop(gettextf("invalid argument 'name': %s", .isSingleName(name)), domain = NA)
  if (exists(name, "package:base") && inBasicFuns(name)) {
    name <- switch(name, as.double = "as.numeric", name)
    fdef <- getGeneric(name)
    compatibleSignature <- nargs() == 2 && !missing(signature) && identical(signature, fdef@signature)
    if (nargs() <= 1 || compatibleSignature) {
      .cacheGeneric(name, fdef)
      return(name)
    }
    if (!is.function(useAsDefault) && !isFALSE(useAsDefault)) {
      msg <- gettextf("%s dispatches internally;  methods can be defined, but the generic function is implicit, and cannot be changed.", sQuote(name))
      stop(msg, domain = NA)
    }
  }
  simpleCall <- {
    nargs() < 2 || all(missing(def), missing(group), missing(valueClass), missing(package), missing(signature), missing(useAsDefault), missing(genericFunction), missing(simpleInheritanceOnly))
  }
  stdGenericBody <- substitute(standardGeneric(NAME), list(NAME = name))
  fdef <- if (is.null(package)) 
    getFunction(name, mustFind = FALSE, where = where)
  else {
    ev <- .NamespaceOrPackage(package)
    if (simpleCall) 
      implicitGeneric(name, ev)
    else getFunction(name, mustFind = FALSE, where = ev)
  }
  if (simpleCall) {
    if (is(fdef, "genericFunction")) 
      return(.GenericAssign(name, fdef, where))
  }
  if (is.null(fdef)) {
    if (isNamespace(where)) 
      fdef <- .getFromStandardPackages(name)
    else fdef <- getFunction(name, mustFind = FALSE)
  }
  if (is.null(fdef) && is.function(useAsDefault)) 
    fdef <- useAsDefault
  doUncache <- FALSE
  if (is.object(fdef) && is(fdef, "genericFunction")) {
    doUncache <- TRUE
    oldDef <- fdef
    prevDefault <- finalDefaultMethod(fdef@default)
    if (is.null(package)) 
      package <- fdef@package
  }
  else if (is.function(fdef)) {
    prevDefault <- fdef
    if (is.primitive(fdef)) 
      package <- "base"
    if (is.null(package)) 
      package <- getPackageName(environment(fdef))
  }
  else prevDefault <- NULL
  if (is.primitive(fdef)) 
    fdef <- getGeneric(name, where = where)
  else if (is.function(fdef)) 
    body(fdef, envir = as.environment(where)) <- stdGenericBody
  if (!is.null(def)) {
    if (is.primitive(def) || !is.function(def)) 
      stop(gettextf("if the 'def' argument is supplied, it must be a function that calls standardGeneric(\"%s\") or is the default", name), domain = NA)
    nonstandardCase <- .NonstandardGenericTest(body(def), name, stdGenericBody)
    if (is.na(nonstandardCase)) {
      if (is.null(useAsDefault)) {
        useAsDefault <- def
      }
      body(def, envir = as.environment(where)) <- stdGenericBody
      nonstandardCase <- FALSE
    }
    fdef <- def
    if (is.null(genericFunction) && nonstandardCase) 
      genericFunction <- new("nonstandardGenericFunction")
  }
  thisPackage <- getPackageName(where)
  if (is.null(package) || !nzchar(package)) 
    package <- thisPackage
  if (is.null(fdef)) 
    stop(gettextf("must supply a function skeleton for %s, explicitly or via an existing function", sQuote(name)), domain = NA)
  ensureGeneric.fdef <- function(sig = signature) {
    if (!(is.object(fdef) && is(fdef, "genericFunction"))) {
      fdeflt <- if (is.function(useAsDefault)) 
        useAsDefault
      else if (isFALSE(useAsDefault)) 
        NULL
      else if (is.function(prevDefault) && !identical(formalArgs(prevDefault), formalArgs(fdef)) && !is.primitive(prevDefault)) 
        NULL
      else prevDefault
      if (is.function(fdeflt)) 
        fdeflt <- .derivedDefaultMethod(fdeflt)
      fdef <<- makeGeneric(name, fdef, fdeflt, group = group, valueClass = valueClass, package = package, signature = sig, genericFunction = genericFunction, simpleInheritanceOnly = simpleInheritanceOnly)
    }
  }
  if (identical(package, thisPackage)) {
    ensureGeneric.fdef()
  }
  else {
    implicit <- implicitGeneric(name, .NamespaceOrPackage(package))
    if (is.null(implicit)) {
      ensureGeneric.fdef()
    }
    else {
      ensureGeneric.fdef(if (is.null(signature) && is.null(def)) 
        implicit@signature
        else signature)
      cmp <- .identicalGeneric(fdef, implicit, allow.extra.dots = !nzchar(Sys.getenv("R_SETGENERIC_PICKY_DOTS")))
      if (isTRUE(cmp)) {
        fdef <- implicit
      }
      else if (is.function(implicit)) {
        thisPName <- if (identical(thisPackage, ".GlobalEnv")) 
          "the global environment"
        else paste("package", sQuote(thisPackage))
        if (is.null(def) && is.null(signature)) {
          message(gettextf("Creating a generic function for %s from %s in %s\n    (from the saved implicit definition)", sQuote(name), sQuote(package), thisPName), domain = NA)
          fdef <- implicit
        }
        else {
          message(gettextf("Creating a new generic function for %s in %s", sQuote(name), thisPName), domain = NA)
          fdef@package <- packageSlot(fdef@generic) <- packageSlot(environment(fdef)$.Generic) <- thisPackage
        }
      }
      else {
        warning(gettextf("no generic version of %s on package %s is allowed;\n   a new generic will be assigned for %s", sQuote(name), sQuote(package), thisPName), domain = NA)
        fdef@package <- packageSlot(fdef@generic) <- packageSlot(environment(fdef)$.Generic) <- thisPackage
      }
    }
  }
  if (identical(fdef@signature, "...")) 
    fdef <- .dotsGeneric(fdef)
  if (doUncache) 
    .uncacheGeneric(name, oldDef)
  groups <- fdef@group
  for (group in groups) {
    gdef <- getGeneric(group)
    if (is(gdef, "groupGenericFunction") && is.na(match(fdef@generic, as.character(gdef@groupMembers)))) {
      gwhere <- .genEnv(group, where)
      gdef@groupMembers <- c(gdef@groupMembers, list(fdef@generic))
      assign(group, gdef, gwhere)
    }
  }
  .GenericAssign(name, fdef, where)
}, function (name, def = NULL, group = list(), valueClass = character(), where = topenv(parent.frame()), package = NULL, signature = NULL, useAsDefault = NULL, genericFunction = NULL, simpleInheritanceOnly = NULL) 
{
  if (is.character(.isSingleName(name))) 
    stop(gettextf("invalid argument 'name': %s", .isSingleName(name)), domain = NA)
  if (exists(name, "package:base") && inBasicFuns(name)) {
    name <- switch(name, as.double = "as.numeric", name)
    fdef <- getGeneric(name)
    compatibleSignature <- nargs() == 2 && !missing(signature) && identical(signature, fdef@signature)
    if (nargs() <= 1 || compatibleSignature) {
      .cacheGeneric(name, fdef)
      return(name)
    }
    if (!is.function(useAsDefault) && !isFALSE(useAsDefault)) {
      msg <- gettextf("%s dispatches internally;  methods can be defined, but the generic function is implicit, and cannot be changed.", sQuote(name))
      stop(msg, domain = NA)
    }
  }
  simpleCall <- {
    nargs() < 2 || all(missing(def), missing(group), missing(valueClass), missing(package), missing(signature), missing(useAsDefault), missing(genericFunction), missing(simpleInheritanceOnly))
  }
  stdGenericBody <- substitute(standardGeneric(NAME), list(NAME = name))
  fdef <- if (is.null(package)) 
    getFunction(name, mustFind = FALSE, where = where)
  else {
    ev <- .NamespaceOrPackage(package)
    if (simpleCall) 
      implicitGeneric(name, ev)
    else getFunction(name, mustFind = FALSE, where = ev)
  }
  if (simpleCall) {
    if (is(fdef, "genericFunction")) 
      return(.GenericAssign(name, fdef, where))
  }
  if (is.null(fdef)) {
    if (isNamespace(where)) 
      fdef <- .getFromStandardPackages(name)
    else fdef <- getFunction(name, mustFind = FALSE)
  }
  if (is.null(fdef) && is.function(useAsDefault)) 
    fdef <- useAsDefault
  doUncache <- FALSE
  if (is.object(fdef) && is(fdef, "genericFunction")) {
    doUncache <- TRUE
    oldDef <- fdef
    prevDefault <- finalDefaultMethod(fdef@default)
    if (is.null(package)) 
      package <- fdef@package
  }
  else if (is.function(fdef)) {
    prevDefault <- fdef
    if (is.primitive(fdef)) 
      package <- "base"
    if (is.null(package)) 
      package <- getPackageName(environment(fdef))
  }
  else prevDefault <- NULL
  if (is.primitive(fdef)) 
    fdef <- getGeneric(name, where = where)
  else if (is.function(fdef)) 
    body(fdef, envir = as.environment(where)) <- stdGenericBody
  if (!is.null(def)) {
    if (is.primitive(def) || !is.function(def)) 
      stop(gettextf("if the 'def' argument is supplied, it must be a function that calls standardGeneric(\"%s\") or is the default", name), domain = NA)
    nonstandardCase <- .NonstandardGenericTest(body(def), name, stdGenericBody)
    if (is.na(nonstandardCase)) {
      if (is.null(useAsDefault)) {
        useAsDefault <- def
      }
      body(def, envir = as.environment(where)) <- stdGenericBody
      nonstandardCase <- FALSE
    }
    fdef <- def
    if (is.null(genericFunction) && nonstandardCase) 
      genericFunction <- new("nonstandardGenericFunction")
  }
  thisPackage <- getPackageName(where)
  if (is.null(package) || !nzchar(package)) 
    package <- thisPackage
  if (is.null(fdef)) 
    stop(gettextf("must supply a function skeleton for %s, explicitly or via an existing function", sQuote(name)), domain = NA)
  ensureGeneric.fdef <- function(sig = signature) {
    if (!(is.object(fdef) && is(fdef, "genericFunction"))) {
      fdeflt <- if (is.function(useAsDefault)) 
        useAsDefault
      else if (isFALSE(useAsDefault)) 
        NULL
      else if (is.function(prevDefault) && !identical(formalArgs(prevDefault), formalArgs(fdef)) && !is.primitive(prevDefault)) 
        NULL
      else prevDefault
      if (is.function(fdeflt)) 
        fdeflt <- .derivedDefaultMethod(fdeflt)
      fdef <<- makeGeneric(name, fdef, fdeflt, group = group, valueClass = valueClass, package = package, signature = sig, genericFunction = genericFunction, simpleInheritanceOnly = simpleInheritanceOnly)
    }
  }
  if (identical(package, thisPackage)) {
    ensureGeneric.fdef()
  }
  else {
    implicit <- implicitGeneric(name, .NamespaceOrPackage(package))
    if (is.null(implicit)) {
      ensureGeneric.fdef()
    }
    else {
      ensureGeneric.fdef(if (is.null(signature) && is.null(def)) 
        implicit@signature
        else signature)
      cmp <- .identicalGeneric(fdef, implicit, allow.extra.dots = !nzchar(Sys.getenv("R_SETGENERIC_PICKY_DOTS")))
      if (isTRUE(cmp)) {
        fdef <- implicit
      }
      else if (is.function(implicit)) {
        thisPName <- if (identical(thisPackage, ".GlobalEnv")) 
          "the global environment"
        else paste("package", sQuote(thisPackage))
        if (is.null(def) && is.null(signature)) {
          message(gettextf("Creating a generic function for %s from %s in %s\n    (from the saved implicit definition)", sQuote(name), sQuote(package), thisPName), domain = NA)
          fdef <- implicit
        }
        else {
          message(gettextf("Creating a new generic function for %s in %s", sQuote(name), thisPName), domain = NA)
          fdef@package <- packageSlot(fdef@generic) <- packageSlot(environment(fdef)$.Generic) <- thisPackage
        }
      }
      else {
        warning(gettextf("no generic version of %s on package %s is allowed;\n   a new generic will be assigned for %s", sQuote(name), sQuote(package), thisPName), domain = NA)
        fdef@package <- packageSlot(fdef@generic) <- packageSlot(environment(fdef)$.Generic) <- thisPackage
      }
    }
  }
  if (identical(fdef@signature, "...")) 
    fdef <- .dotsGeneric(fdef)
  if (doUncache) 
    .uncacheGeneric(name, oldDef)
  groups <- fdef@group
  for (group in groups) {
    gdef <- getGeneric(group)
    if (is(gdef, "groupGenericFunction") && is.na(match(fdef@generic, as.character(gdef@groupMembers)))) {
      gwhere <- .genEnv(group, where)
      gdef@groupMembers <- c(gdef@groupMembers, list(fdef@generic))
      assign(group, gdef, gwhere)
    }
  }
  .GenericAssign(name, fdef, where)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setGenericImplicit
list(`package:methods` = function (name, where = topenv(parent.frame()), restore = TRUE) 
{
  if (!isGeneric(name, where)) {
    warning(gettextf("%s is not currently a generic:  define it first to create a non-default implicit form", sQuote(name)), domain = NA)
    return(FALSE)
  }
  generic <- getGeneric(name, where = where)
  if (restore) 
    removeMethods(name, where, TRUE)
  else removeGeneric(name, where)
  .saveToImplicitGenerics(name, generic, where)
}, function (name, where = topenv(parent.frame()), restore = TRUE) 
{
  if (!isGeneric(name, where)) {
    warning(gettextf("%s is not currently a generic:  define it first to create a non-default implicit form", sQuote(name)), domain = NA)
    return(FALSE)
  }
  generic <- getGeneric(name, where = where)
  if (restore) 
    removeMethods(name, where, TRUE)
  else removeGeneric(name, where)
  .saveToImplicitGenerics(name, generic, where)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setGroupGeneric
list(`package:methods` = function (name, def = NULL, group = list(), valueClass = character(), knownMembers = list(), package = getPackageName(where), where = topenv(parent.frame())) 
{
  if (is.null(def)) {
    def <- getFunction(name, where = where)
    if (isGroup(name, fdef = def)) {
      if (nargs() == 1) {
        message(gettextf("Function %s is already a group generic; no change", sQuote(name)), domain = NA)
        return(name)
      }
    }
  }
  body(def, envir = environment(def)) <- substitute(stop(MSG, domain = NA), list(MSG = gettextf("Function %s is a group generic; do not call it directly", sQuote(name))))
  if (is.character(knownMembers)) 
    knownMembers <- as.list(knownMembers)
  setGeneric(name, def, group = group, valueClass = valueClass, package = package, useAsDefault = FALSE, genericFunction = new("groupGenericFunction", def, groupMembers = knownMembers), where = where)
  .MakeImplicitGroupMembers(name, knownMembers, where)
  name
}, function (name, def = NULL, group = list(), valueClass = character(), knownMembers = list(), package = getPackageName(where), where = topenv(parent.frame())) 
{
  if (is.null(def)) {
    def <- getFunction(name, where = where)
    if (isGroup(name, fdef = def)) {
      if (nargs() == 1) {
        message(gettextf("Function %s is already a group generic; no change", sQuote(name)), domain = NA)
        return(name)
      }
    }
  }
  body(def, envir = environment(def)) <- substitute(stop(MSG, domain = NA), list(MSG = gettextf("Function %s is a group generic; do not call it directly", sQuote(name))))
  if (is.character(knownMembers)) 
    knownMembers <- as.list(knownMembers)
  setGeneric(name, def, group = group, valueClass = valueClass, package = package, useAsDefault = FALSE, genericFunction = new("groupGenericFunction", def, groupMembers = knownMembers), where = where)
  .MakeImplicitGroupMembers(name, knownMembers, where)
  name
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setIs
list(`package:methods` = function (class1, class2, test = NULL, coerce = NULL, replace = NULL, by = character(), where = topenv(parent.frame()), classDef = getClass(class1, TRUE, where = where), extensionObject = NULL, doComplete = TRUE) 
{
  where <- as.environment(where)
  classDef2 <- getClassDef(class2, where)
  if (is.null(classDef2)) 
    stop(gettextf("class %s has no visible definition from package or environment %s", dQuote(class2), sQuote(getPackageName(where))), domain = NA)
  m1 <- classMetaName(class1)
  local1 <- exists(m1, where, inherits = FALSE) && !(classDef@sealed || bindingIsLocked(m1, where))
  if (!local1) {
    m2 <- classMetaName(class2)
    local2 <- exists(m2, where, inherits = FALSE) && !(classDef2@sealed || bindingIsLocked(m2, where))
    if (!local2) 
      stop(gettextf("cannot create a 'setIs' relation when neither of the classes (%s and %s) is local and modifiable in this package", dQuote(class1), dQuote(class2)), domain = NA)
  }
  if (classDef@sealed && !isClassUnion(classDef2)) 
    stop(gettextf("class %s is sealed; new superclasses can not be defined, except by 'setClassUnion'", dQuote(class1)), domain = NA)
  prevIs <- !identical(possibleExtends(class1, class2, classDef, classDef2), FALSE)
  obj <- if (is.null(extensionObject)) 
    makeExtends(class1, coerce, test, replace, by, classDef1 = classDef, classDef2 = classDef2, package = getPackageName(where))
  else extensionObject
  ok <- .validExtends(class1, class2, classDef, classDef2, obj@simple)
  if (!isTRUE(ok)) 
    stop(ok)
  where2 <- .findOrCopyClass(class2, classDef2, where, "subclass")
  classDef2@subclasses[[class1]] <- obj
  if (doComplete) 
    classDef2@subclasses <- completeSubclasses(classDef2, class1, obj, where)
  if (classDef2@virtual && is.na(match(class2, .specialVirtual))) {
    if (extends(classDef, "NULL")) 
      classDef2@prototype <- NULL
    else if (is.null(classDef2@prototype) && is.na(match("NULL", names(classDef2@subclasses)))) {
      classDef2@prototype <- if (classDef@virtual) 
        classDef@prototype
      else .Call(C_new_object, classDef)
    }
  }
  assignClassDef(class2, classDef2, where2, TRUE)
  .removePreviousCoerce(class1, class2, where, prevIs)
  where1 <- .findOrCopyClass(class1, classDef, where, "superClass")
  .newDirectSuperclass(classDef@contains, class2, names(classDef2@contains)) <- obj
  onlyRecacheSubclasses <- (is(classDef, "ClassUnionRepresentation") || is(classDef2, "ClassUnionRepresentation")) && !identical(packageSlot(classDef), packageSlot(classDef2))
  if (doComplete) {
    classDef@contains <- completeExtends(classDef, class2, obj, where = where)
    if (!onlyRecacheSubclasses) 
      .checkSubclasses(class1, classDef, class2, classDef2, where)
  }
  assignClassDef(class1, classDef, where1, TRUE, doSubclasses = onlyRecacheSubclasses)
  invisible(classDef)
}, function (class1, class2, test = NULL, coerce = NULL, replace = NULL, by = character(), where = topenv(parent.frame()), classDef = getClass(class1, TRUE, where = where), extensionObject = NULL, doComplete = TRUE) 
{
  where <- as.environment(where)
  classDef2 <- getClassDef(class2, where)
  if (is.null(classDef2)) 
    stop(gettextf("class %s has no visible definition from package or environment %s", dQuote(class2), sQuote(getPackageName(where))), domain = NA)
  m1 <- classMetaName(class1)
  local1 <- exists(m1, where, inherits = FALSE) && !(classDef@sealed || bindingIsLocked(m1, where))
  if (!local1) {
    m2 <- classMetaName(class2)
    local2 <- exists(m2, where, inherits = FALSE) && !(classDef2@sealed || bindingIsLocked(m2, where))
    if (!local2) 
      stop(gettextf("cannot create a 'setIs' relation when neither of the classes (%s and %s) is local and modifiable in this package", dQuote(class1), dQuote(class2)), domain = NA)
  }
  if (classDef@sealed && !isClassUnion(classDef2)) 
    stop(gettextf("class %s is sealed; new superclasses can not be defined, except by 'setClassUnion'", dQuote(class1)), domain = NA)
  prevIs <- !identical(possibleExtends(class1, class2, classDef, classDef2), FALSE)
  obj <- if (is.null(extensionObject)) 
    makeExtends(class1, coerce, test, replace, by, classDef1 = classDef, classDef2 = classDef2, package = getPackageName(where))
  else extensionObject
  ok <- .validExtends(class1, class2, classDef, classDef2, obj@simple)
  if (!isTRUE(ok)) 
    stop(ok)
  where2 <- .findOrCopyClass(class2, classDef2, where, "subclass")
  classDef2@subclasses[[class1]] <- obj
  if (doComplete) 
    classDef2@subclasses <- completeSubclasses(classDef2, class1, obj, where)
  if (classDef2@virtual && is.na(match(class2, .specialVirtual))) {
    if (extends(classDef, "NULL")) 
      classDef2@prototype <- NULL
    else if (is.null(classDef2@prototype) && is.na(match("NULL", names(classDef2@subclasses)))) {
      classDef2@prototype <- if (classDef@virtual) 
        classDef@prototype
      else .Call(C_new_object, classDef)
    }
  }
  assignClassDef(class2, classDef2, where2, TRUE)
  .removePreviousCoerce(class1, class2, where, prevIs)
  where1 <- .findOrCopyClass(class1, classDef, where, "superClass")
  .newDirectSuperclass(classDef@contains, class2, names(classDef2@contains)) <- obj
  onlyRecacheSubclasses <- (is(classDef, "ClassUnionRepresentation") || is(classDef2, "ClassUnionRepresentation")) && !identical(packageSlot(classDef), packageSlot(classDef2))
  if (doComplete) {
    classDef@contains <- completeExtends(classDef, class2, obj, where = where)
    if (!onlyRecacheSubclasses) 
      .checkSubclasses(class1, classDef, class2, classDef2, where)
  }
  assignClassDef(class1, classDef, where1, TRUE, doSubclasses = onlyRecacheSubclasses)
  invisible(classDef)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setLoadAction
list(`package:methods` = function (action, aname = "", where = topenv(parent.frame())) 
{
  currentAnames <- .assignActionListNames(where)
  if (!nzchar(aname)) 
    aname <- paste0(".", length(currentAnames) + 1)
  .assignActions(list(action), aname, where)
  if (is.na(match(aname, currentAnames))) {
    actionListName <- .actionMetaName("")
    assign(actionListName, c(currentAnames, aname), envir = where)
  }
}, function (action, aname = "", where = topenv(parent.frame())) 
{
  currentAnames <- .assignActionListNames(where)
  if (!nzchar(aname)) 
    aname <- paste0(".", length(currentAnames) + 1)
  .assignActions(list(action), aname, where)
  if (is.na(match(aname, currentAnames))) {
    actionListName <- .actionMetaName("")
    assign(actionListName, c(currentAnames, aname), envir = where)
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setLoadActions
list(`package:methods` = function (..., .where = topenv(parent.frame())) 
{
  actionListName <- .actionMetaName("")
  currentAnames <- .assignActionListNames(.where)
  actions <- list(...)
  anames <- allNames(actions)
  previous <- anames %in% currentAnames
  if (any(previous)) {
    .assignActions(actions[previous], anames[previous], .where)
    if (all(previous)) 
      return(list())
    anames <- anames[!previous]
    actions <- actions[!previous]
  }
  anon <- !nzchar(anames)
  if (any(anon)) {
    n <- length(currentAnames)
    deflts <- paste0(".", seq(from = n + 1, length.out = length(actions)))
    anames[anon] <- deflts[anon]
  }
  .assignActions(actions, anames, .where)
  assign(actionListName, c(currentAnames, anames), envir = .where)
}, function (..., .where = topenv(parent.frame())) 
{
  actionListName <- .actionMetaName("")
  currentAnames <- .assignActionListNames(.where)
  actions <- list(...)
  anames <- allNames(actions)
  previous <- anames %in% currentAnames
  if (any(previous)) {
    .assignActions(actions[previous], anames[previous], .where)
    if (all(previous)) 
      return(list())
    anames <- anames[!previous]
    actions <- actions[!previous]
  }
  anon <- !nzchar(anames)
  if (any(anon)) {
    n <- length(currentAnames)
    deflts <- paste0(".", seq(from = n + 1, length.out = length(actions)))
    anames[anon] <- deflts[anon]
  }
  .assignActions(actions, anames, .where)
  assign(actionListName, c(currentAnames, anames), envir = .where)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setMethod
list(`package:methods` = function (f, signature = character(), definition, where = topenv(parent.frame()), valueClass = NULL, sealed = FALSE) 
{
  if (is.function(f) && is(f, "genericFunction")) {
    fdef <- f
    f <- fdef@generic
    gwhere <- .genEnv(f)
  }
  else if (is.function(f)) {
    if (is.primitive(f)) {
      f <- .primname(f)
      fdef <- genericForBasic(f)
      gwhere <- .genEnv(f)
    }
    else stop("a function for argument 'f' must be a generic function")
  }
  else {
    where <- as.environment(where)
    gwhere <- .genEnv(f, where)
    f <- switch(f, as.double = "as.numeric", f)
    fdef <- getGeneric(f, where = if (identical(gwhere, baseenv())) 
      where
      else gwhere)
  }
  if (.lockedForMethods(fdef, where)) 
    stop(gettextf("the environment %s is locked; cannot assign methods for function %s", sQuote(getPackageName(where)), sQuote(f)), domain = NA)
  hasMethods <- !is.null(fdef)
  deflt <- getFunction(f, generic = FALSE, mustFind = FALSE, where = where)
  if (identical(gwhere, baseenv())) {
    allWhere <- findFunction(f, where = where)
    generics <- logical(length(allWhere))
    if (length(allWhere)) {
      for (i in seq_along(allWhere)) {
        fi <- get(f, allWhere[[i]])
        geni <- is(fi, "genericFunction")
        generics[[i]] <- geni
        if (!geni && is.null(deflt)) 
          deflt <- fi
      }
    }
    if (any(generics)) {
      gwhere <- as.environment(allWhere[generics][[1]])
      if (.lockedForMethods(fdef, gwhere)) {
        if (identical(as.environment(where), gwhere)) 
          stop(gettextf("the 'where' environment (%s) is a locked namespace; cannot assign methods there", getPackageName(where)), domain = NA)
        msg <- gettextf("Copying the generic function %s to environment %s, because the previous version was in a sealed namespace (%s)", sQuote(f), sQuote(getPackageName(where)), sQuote(getPackageName(gwhere)))
        message(strwrap(msg), domain = NA)
        assign(f, fdef, where)
        gwhere <- where
      }
    }
  }
  if (!hasMethods) 
    fdef <- deflt
  if (is.null(fdef)) 
    stop(gettextf("no existing definition for function %s", sQuote(f)), domain = NA)
  if (!hasMethods) {
    setGeneric(f, where = where)
    doMessage <- !isS3Generic(fdef)
    fdef <- getGeneric(f, where = where)
    if (doMessage) {
      thisPackage <- getPackageName(where)
      thisPName <- if (identical(thisPackage, ".GlobalEnv")) 
        "the global environment"
      else paste("package", sQuote(thisPackage))
      if (identical(as.character(fdef@package), thisPackage)) 
        message(gettextf("Creating a generic function from function %s in %s", sQuote(f), thisPName), domain = NA)
      else message(gettextf("Creating a generic function for %s from package %s in %s", sQuote(f), sQuote(fdef@package), thisPName), domain = NA)
    }
  }
  else if (identical(gwhere, NA)) {
    if (is.null(.BasicFunsList[[f]])) 
      stop(sprintf("apparent internal error: a generic function was found for \"%s\", but no corresponding object was found searching from \"%s\"", f, getPackageName(where)), domain = NA)
    if (!isGeneric(f)) 
      setGeneric(f)
  }
  if (isSealedMethod(f, signature, fdef, where = where)) 
    stop(gettextf("the method for function %s and signature %s is sealed and cannot be re-defined", sQuote(f), .signatureString(fdef, signature)), domain = NA)
  signature <- matchSignature(signature, fdef, where)
  createMethod <- FALSE
  switch(typeof(definition), closure = {
    fnames <- formalArgs(fdef)
    mnames <- formalArgs(definition)
    if (!identical(mnames, fnames)) {
      if (length(fnames) == length(mnames) && length(mnames) == 1) {
        warning(gettextf("For function %s, signature %s: argument in method definition changed from (%s) to (%s)", sQuote(f), sQuote(signature), mnames, fnames), domain = NA, call. = FALSE)
        formals(definition) <- formals(fdef)
        ll <- list(as.name(formalArgs(fdef)))
        names(ll) <- mnames
        body(definition) <- substituteDirect(body(definition), ll)
        mnames <- fnames
      } else {
        fullSig <- conformMethod(signature, mnames, fnames, f, fdef, definition)
        if (!identical(fullSig, signature)) {
          formals(definition, envir = environment(definition)) <- formals(fdef)
          signature <- fullSig
        }
        definition <- rematchDefinition(definition, fdef, mnames, fnames, signature)
      }
    }
    definition <- matchDefaults(definition, fdef)
    createMethod <- TRUE
  }, builtin = , special = {
    if (!identical(definition, deflt)) stop("primitive functions cannot be methods; they must be enclosed in a regular function")
  }, `NULL` = {
  }, stop(gettextf("invalid method definition: expected a function, got an object of class %s", dQuote(class(definition))), domain = NA))
  fenv <- environment(fdef)
  nSig <- .getGenericSigLength(fdef, fenv, TRUE)
  signature <- .matchSigLength(signature, fdef, fenv, TRUE)
  margs <- (fdef@signature)[seq_along(signature)]
  if (createMethod) {
    definition <- asMethodDefinition(definition, signature, sealed, fdef)
    definition@generic <- fdef@generic
  }
  is.not.base <- !identical(where, baseenv())
  whereMethods <- if (is.not.base && !.noMlists()) 
    insertMethod(getMethodsMetaData(f, where), signature, margs, definition)
  mtable <- getMethodsForDispatch(fdef)
  if (cacheOnAssign(where)) {
    .cacheMethodInTable(fdef, signature, definition, mtable)
    .cacheMethodInTable(fdef, signature, definition)
    if (is.not.base) 
      .addToMetaTable(fdef, signature, definition, where, nSig)
    resetGeneric(f, fdef, mtable, gwhere, deflt)
  }
  assignMethodsMetaData(f, whereMethods, fdef, where)
  invisible(f)
}, function (f, signature = character(), definition, where = topenv(parent.frame()), valueClass = NULL, sealed = FALSE) 
{
  if (is.function(f) && is(f, "genericFunction")) {
    fdef <- f
    f <- fdef@generic
    gwhere <- .genEnv(f)
  }
  else if (is.function(f)) {
    if (is.primitive(f)) {
      f <- .primname(f)
      fdef <- genericForBasic(f)
      gwhere <- .genEnv(f)
    }
    else stop("a function for argument 'f' must be a generic function")
  }
  else {
    where <- as.environment(where)
    gwhere <- .genEnv(f, where)
    f <- switch(f, as.double = "as.numeric", f)
    fdef <- getGeneric(f, where = if (identical(gwhere, baseenv())) 
      where
      else gwhere)
  }
  if (.lockedForMethods(fdef, where)) 
    stop(gettextf("the environment %s is locked; cannot assign methods for function %s", sQuote(getPackageName(where)), sQuote(f)), domain = NA)
  hasMethods <- !is.null(fdef)
  deflt <- getFunction(f, generic = FALSE, mustFind = FALSE, where = where)
  if (identical(gwhere, baseenv())) {
    allWhere <- findFunction(f, where = where)
    generics <- logical(length(allWhere))
    if (length(allWhere)) {
      for (i in seq_along(allWhere)) {
        fi <- get(f, allWhere[[i]])
        geni <- is(fi, "genericFunction")
        generics[[i]] <- geni
        if (!geni && is.null(deflt)) 
          deflt <- fi
      }
    }
    if (any(generics)) {
      gwhere <- as.environment(allWhere[generics][[1]])
      if (.lockedForMethods(fdef, gwhere)) {
        if (identical(as.environment(where), gwhere)) 
          stop(gettextf("the 'where' environment (%s) is a locked namespace; cannot assign methods there", getPackageName(where)), domain = NA)
        msg <- gettextf("Copying the generic function %s to environment %s, because the previous version was in a sealed namespace (%s)", sQuote(f), sQuote(getPackageName(where)), sQuote(getPackageName(gwhere)))
        message(strwrap(msg), domain = NA)
        assign(f, fdef, where)
        gwhere <- where
      }
    }
  }
  if (!hasMethods) 
    fdef <- deflt
  if (is.null(fdef)) 
    stop(gettextf("no existing definition for function %s", sQuote(f)), domain = NA)
  if (!hasMethods) {
    setGeneric(f, where = where)
    doMessage <- !isS3Generic(fdef)
    fdef <- getGeneric(f, where = where)
    if (doMessage) {
      thisPackage <- getPackageName(where)
      thisPName <- if (identical(thisPackage, ".GlobalEnv")) 
        "the global environment"
      else paste("package", sQuote(thisPackage))
      if (identical(as.character(fdef@package), thisPackage)) 
        message(gettextf("Creating a generic function from function %s in %s", sQuote(f), thisPName), domain = NA)
      else message(gettextf("Creating a generic function for %s from package %s in %s", sQuote(f), sQuote(fdef@package), thisPName), domain = NA)
    }
  }
  else if (identical(gwhere, NA)) {
    if (is.null(.BasicFunsList[[f]])) 
      stop(sprintf("apparent internal error: a generic function was found for \"%s\", but no corresponding object was found searching from \"%s\"", f, getPackageName(where)), domain = NA)
    if (!isGeneric(f)) 
      setGeneric(f)
  }
  if (isSealedMethod(f, signature, fdef, where = where)) 
    stop(gettextf("the method for function %s and signature %s is sealed and cannot be re-defined", sQuote(f), .signatureString(fdef, signature)), domain = NA)
  signature <- matchSignature(signature, fdef, where)
  createMethod <- FALSE
  switch(typeof(definition), closure = {
    fnames <- formalArgs(fdef)
    mnames <- formalArgs(definition)
    if (!identical(mnames, fnames)) {
      if (length(fnames) == length(mnames) && length(mnames) == 1) {
        warning(gettextf("For function %s, signature %s: argument in method definition changed from (%s) to (%s)", sQuote(f), sQuote(signature), mnames, fnames), domain = NA, call. = FALSE)
        formals(definition) <- formals(fdef)
        ll <- list(as.name(formalArgs(fdef)))
        names(ll) <- mnames
        body(definition) <- substituteDirect(body(definition), ll)
        mnames <- fnames
      } else {
        fullSig <- conformMethod(signature, mnames, fnames, f, fdef, definition)
        if (!identical(fullSig, signature)) {
          formals(definition, envir = environment(definition)) <- formals(fdef)
          signature <- fullSig
        }
        definition <- rematchDefinition(definition, fdef, mnames, fnames, signature)
      }
    }
    definition <- matchDefaults(definition, fdef)
    createMethod <- TRUE
  }, builtin = , special = {
    if (!identical(definition, deflt)) stop("primitive functions cannot be methods; they must be enclosed in a regular function")
  }, `NULL` = {
  }, stop(gettextf("invalid method definition: expected a function, got an object of class %s", dQuote(class(definition))), domain = NA))
  fenv <- environment(fdef)
  nSig <- .getGenericSigLength(fdef, fenv, TRUE)
  signature <- .matchSigLength(signature, fdef, fenv, TRUE)
  margs <- (fdef@signature)[seq_along(signature)]
  if (createMethod) {
    definition <- asMethodDefinition(definition, signature, sealed, fdef)
    definition@generic <- fdef@generic
  }
  is.not.base <- !identical(where, baseenv())
  whereMethods <- if (is.not.base && !.noMlists()) 
    insertMethod(getMethodsMetaData(f, where), signature, margs, definition)
  mtable <- getMethodsForDispatch(fdef)
  if (cacheOnAssign(where)) {
    .cacheMethodInTable(fdef, signature, definition, mtable)
    .cacheMethodInTable(fdef, signature, definition)
    if (is.not.base) 
      .addToMetaTable(fdef, signature, definition, where, nSig)
    resetGeneric(f, fdef, mtable, gwhere, deflt)
  }
  assignMethodsMetaData(f, whereMethods, fdef, where)
  invisible(f)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setOldClass
list(`package:methods` = function (Classes, prototype = NULL, where = topenv(parent.frame()), test = FALSE, S4Class) 
{
  simpleCase <- is.null(prototype)
  mainClass <- Classes[[1]]
  prevDef <- getClassDef(mainClass, where, inherits = FALSE)
  if (!missing(S4Class)) {
    if (test) 
      stop("not allowed to have test==TRUE and an S4Class definition")
    if (!is(S4Class, "classRepresentation")) {
      if (is.character(S4Class)) {
        clName <- S4Class
        S4Class <- getClass(S4Class)
        if (.identC(clName, Classes[[1]])) 
          removeClass(clName, where = where)
      }
      else stop(gettextf("argument 'S4Class' must be a class definition: got an object of class %s", dQuote(class(S4Class))), domain = NA)
    }
    if (!is.null(prototype)) {
      S4prototype <- S4Class@prototype
      S4Class@prototype <- .mergeAttrs(prototype, S4prototype)
    }
    Recall(Classes, where = where)
    return(.S4OldClass(Classes[[1]], if (length(Classes) > 1) Classes[[2]] else "oldClass", S4Class, where, prevDef))
  }
  if (test) 
    return(.setOldIs(Classes, where))
  if (!is.null(prevDef)) {
    on.exit(.restoreClass(prevDef, where))
    removeClass(mainClass, where = where)
  }
  prevClass <- "oldClass"
  S3Class <- character()
  if (is.null(S3table <- where$.S3MethodsClasses)) {
    S3table <- new.env()
    assign(".S3MethodsClasses", S3table, envir = where)
  }
  dataPartClass <- NULL
  for (cl in rev(Classes)) {
    S3Class <- c(cl, S3Class)
    if (isClass(cl, where)) {
      def <- getClass(cl, where)
      if (!extends(def, prevClass)) {
        cl1 <- .validDataPartClass(cl, where, dataPartClass)
        if (is.null(cl1)) 
          stop(gettextf("inconsistent old-style class information for %s; the class is defined but does not extend %s and is not valid as the data part", dQuote(cl), dQuote(prevClass)), domain = NA)
        else dataPartClass <- cl1
      }
      else {
        prevP <- def@prototype
        if (missing(prototype)) 
          prototype <- prevP
        prevS3Class <- attr(prevP, ".S3Class")
        if (length(prevS3Class) > length(S3Class)) 
          S3Class <- prevS3Class
      }
    }
    else {
      useP <- TRUE
      if (cl != mainClass || simpleCase) {
        setClass(cl, contains = c(prevClass, "VIRTUAL"), where = where)
      }
      else if (isClass(class(prototype))) 
        setClass(cl, contains = prevClass, prototype = prototype, where = where)
      else {
        if (.class1(prototype) != mainClass) 
          stop(gettextf("the S3 class of the prototype, \"%s\", is undefined; only allowed when this is the S3 class being registered (\"%s\")", .class1(prototype), mainClass), domain = NA)
        setClass(cl, contains = prevClass, where = where)
        useP <- FALSE
      }
      def <- getClassDef(cl, where)
      if (useP) 
        clp <- def@prototype
      else clp <- prototype
      attr(clp, ".S3Class") <- S3Class
      def@prototype <- .notS4(clp)
      assignClassDef(cl, def, where = where)
      assign(cl, def, envir = S3table)
    }
    prevClass <- cl
  }
  if (!is.null(prevDef)) 
    on.exit()
}, function (Classes, prototype = NULL, where = topenv(parent.frame()), test = FALSE, S4Class) 
{
  simpleCase <- is.null(prototype)
  mainClass <- Classes[[1]]
  prevDef <- getClassDef(mainClass, where, inherits = FALSE)
  if (!missing(S4Class)) {
    if (test) 
      stop("not allowed to have test==TRUE and an S4Class definition")
    if (!is(S4Class, "classRepresentation")) {
      if (is.character(S4Class)) {
        clName <- S4Class
        S4Class <- getClass(S4Class)
        if (.identC(clName, Classes[[1]])) 
          removeClass(clName, where = where)
      }
      else stop(gettextf("argument 'S4Class' must be a class definition: got an object of class %s", dQuote(class(S4Class))), domain = NA)
    }
    if (!is.null(prototype)) {
      S4prototype <- S4Class@prototype
      S4Class@prototype <- .mergeAttrs(prototype, S4prototype)
    }
    Recall(Classes, where = where)
    return(.S4OldClass(Classes[[1]], if (length(Classes) > 1) Classes[[2]] else "oldClass", S4Class, where, prevDef))
  }
  if (test) 
    return(.setOldIs(Classes, where))
  if (!is.null(prevDef)) {
    on.exit(.restoreClass(prevDef, where))
    removeClass(mainClass, where = where)
  }
  prevClass <- "oldClass"
  S3Class <- character()
  if (is.null(S3table <- where$.S3MethodsClasses)) {
    S3table <- new.env()
    assign(".S3MethodsClasses", S3table, envir = where)
  }
  dataPartClass <- NULL
  for (cl in rev(Classes)) {
    S3Class <- c(cl, S3Class)
    if (isClass(cl, where)) {
      def <- getClass(cl, where)
      if (!extends(def, prevClass)) {
        cl1 <- .validDataPartClass(cl, where, dataPartClass)
        if (is.null(cl1)) 
          stop(gettextf("inconsistent old-style class information for %s; the class is defined but does not extend %s and is not valid as the data part", dQuote(cl), dQuote(prevClass)), domain = NA)
        else dataPartClass <- cl1
      }
      else {
        prevP <- def@prototype
        if (missing(prototype)) 
          prototype <- prevP
        prevS3Class <- attr(prevP, ".S3Class")
        if (length(prevS3Class) > length(S3Class)) 
          S3Class <- prevS3Class
      }
    }
    else {
      useP <- TRUE
      if (cl != mainClass || simpleCase) {
        setClass(cl, contains = c(prevClass, "VIRTUAL"), where = where)
      }
      else if (isClass(class(prototype))) 
        setClass(cl, contains = prevClass, prototype = prototype, where = where)
      else {
        if (.class1(prototype) != mainClass) 
          stop(gettextf("the S3 class of the prototype, \"%s\", is undefined; only allowed when this is the S3 class being registered (\"%s\")", .class1(prototype), mainClass), domain = NA)
        setClass(cl, contains = prevClass, where = where)
        useP <- FALSE
      }
      def <- getClassDef(cl, where)
      if (useP) 
        clp <- def@prototype
      else clp <- prototype
      attr(clp, ".S3Class") <- S3Class
      def@prototype <- .notS4(clp)
      assignClassDef(cl, def, where = where)
      assign(cl, def, envir = S3table)
    }
    prevClass <- cl
  }
  if (!is.null(prevDef)) 
    on.exit()
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setPackageName
list(`package:methods` = function (pkg, env) 
  assign(".packageName", pkg, envir = env), function (pkg, env) 
    assign(".packageName", pkg, envir = env))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setPrimitiveMethods
list(`package:methods` = function (f, fdef, code, generic, mlist = get(".Methods", envir = environment(generic))) 
  .Call(C_R_M_setPrimitiveMethods, f, fdef, code, generic, mlist), function (f, fdef, code, generic, mlist = get(".Methods", envir = environment(generic))) 
    .Call(C_R_M_setPrimitiveMethods, f, fdef, code, generic, mlist))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setRefClass
list(`package:methods` = function (Class, fields = character(), contains = character(), methods = list(), where = topenv(parent.frame()), inheritPackage = FALSE, ...) 
{
  fields <- inferProperties(fields, "field")
  info <- refClassInformation(Class, contains, fields, methods, where)
  superClasses <- refSuperClasses <- fieldClasses <- fieldPrototypes <- refMethods <- NULL
  for (what in c("superClasses", "refSuperClasses", "fieldClasses", "fieldPrototypes", "refMethods")) assign(what, info[[what]])
  classFun <- setClass(Class, contains = superClasses, where = where, ...)
  classDef <- new("refClassRepresentation", getClassDef(Class, where = where), fieldClasses = fieldClasses, refMethods = as.environment(refMethods), fieldPrototypes = as.environment(fieldPrototypes), refSuperClasses = refSuperClasses)
  .setObjectParent(classDef@refMethods, if (inheritPackage) 
    refSuperClasses
    else NULL, where)
  assignClassDef(Class, classDef, where)
  generator <- new("refGeneratorSlot")
  env <- as.environment(generator)
  env$def <- classDef
  env$className <- Class
  .declareVariables(classDef, where)
  value <- new("refObjectGenerator", classFun, generator = generator)
  invisible(value)
}, function (Class, fields = character(), contains = character(), methods = list(), where = topenv(parent.frame()), inheritPackage = FALSE, ...) 
{
  fields <- inferProperties(fields, "field")
  info <- refClassInformation(Class, contains, fields, methods, where)
  superClasses <- refSuperClasses <- fieldClasses <- fieldPrototypes <- refMethods <- NULL
  for (what in c("superClasses", "refSuperClasses", "fieldClasses", "fieldPrototypes", "refMethods")) assign(what, info[[what]])
  classFun <- setClass(Class, contains = superClasses, where = where, ...)
  classDef <- new("refClassRepresentation", getClassDef(Class, where = where), fieldClasses = fieldClasses, refMethods = as.environment(refMethods), fieldPrototypes = as.environment(fieldPrototypes), refSuperClasses = refSuperClasses)
  .setObjectParent(classDef@refMethods, if (inheritPackage) 
    refSuperClasses
    else NULL, where)
  assignClassDef(Class, classDef, where)
  generator <- new("refGeneratorSlot")
  env <- as.environment(generator)
  env$def <- classDef
  env$className <- Class
  .declareVariables(classDef, where)
  value <- new("refObjectGenerator", classFun, generator = generator)
  invisible(value)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setReplaceMethod
list(`package:methods` = function (f, ..., where = topenv(parent.frame())) 
  setMethod(paste0(f, "<-"), ..., where = where), function (f, ..., where = topenv(parent.frame())) 
    setMethod(paste0(f, "<-"), ..., where = where))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
setValidity
list(`package:methods` = function (Class, method, where = topenv(parent.frame())) 
{
  if (isClassDef(Class)) {
    ClassDef <- Class
    Class <- ClassDef@className
  }
  else {
    ClassDef <- getClassDef(Class, where)
  }
  method <- .makeValidityMethod(Class, method)
  if (is.null(method) || (is.function(method) && length(formalArgs(method)) == 1)) 
    ClassDef@validity <- method
  else stop("validity method must be NULL or a function of one argument")
  assignClassDef(Class, ClassDef, where = where)
  resetClass(Class, ClassDef, where = where)
}, function (Class, method, where = topenv(parent.frame())) 
{
  if (isClassDef(Class)) {
    ClassDef <- Class
    Class <- ClassDef@className
  }
  else {
    ClassDef <- getClassDef(Class, where)
  }
  method <- .makeValidityMethod(Class, method)
  if (is.null(method) || (is.function(method) && length(formalArgs(method)) == 1)) 
    ClassDef@validity <- method
  else stop("validity method must be NULL or a function of one argument")
  assignClassDef(Class, ClassDef, where = where)
  resetClass(Class, ClassDef, where = where)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
show
list(`package:lubridate` = new("standardGeneric", .Data = function (object) 
  standardGeneric("show"), generic = "show", package = "methods", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object) 
    showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"), skeleton = (new("derivedDefaultMethod", .Data = function (object) 
      showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"))(object)), `package:methods` = new("standardGeneric", .Data = function (object) 
        standardGeneric("show"), generic = "show", package = "methods", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object) 
          showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"), skeleton = (new("derivedDefaultMethod", .Data = function (object) 
            showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"))(object)), new("standardGeneric", .Data = function (object) 
              standardGeneric("show"), generic = "show", package = "methods", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object) 
                showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"), skeleton = (new("derivedDefaultMethod", .Data = function (object) 
                  showDefault(object), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "show"))(object)))
c("package:lubridate", "package:methods", "namespace:methods")
c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, TRUE)
showClass
list(`package:methods` = function (Class, complete = TRUE, propertiesAreCalled = "Slots") 
{
  if (isClassDef(Class)) {
    ClassDef <- Class
    Class <- ClassDef@className
  }
  else if (complete) 
    ClassDef <- getClass(Class)
  else ClassDef <- getClassDef(Class)
  cat(if (isTRUE(ClassDef@virtual)) 
    "Virtual ", "Class ", .dQ(Class), if (nzchar(pkg <- ClassDef@package)) 
      c(" [", if (pkg != ".GlobalEnv") "package" else "in", " \"", pkg, "\"]"), "\n", sep = "")
  x <- ClassDef@slots
  if (length(x)) {
    printPropertiesList(x, propertiesAreCalled)
  }
  else cat("\nNo ", propertiesAreCalled, ", prototype of class \"", .class1(ClassDef@prototype), "\"\n", sep = "")
  ext <- ClassDef@contains
  if (length(ext)) {
    cat("\nExtends: ")
    showExtends(ext)
  }
  ext <- ClassDef@subclasses
  if (length(ext)) {
    cat("\nKnown Subclasses: ")
    showExtends(ext)
  }
}, function (Class, complete = TRUE, propertiesAreCalled = "Slots") 
{
  if (isClassDef(Class)) {
    ClassDef <- Class
    Class <- ClassDef@className
  }
  else if (complete) 
    ClassDef <- getClass(Class)
  else ClassDef <- getClassDef(Class)
  cat(if (isTRUE(ClassDef@virtual)) 
    "Virtual ", "Class ", .dQ(Class), if (nzchar(pkg <- ClassDef@package)) 
      c(" [", if (pkg != ".GlobalEnv") "package" else "in", " \"", pkg, "\"]"), "\n", sep = "")
  x <- ClassDef@slots
  if (length(x)) {
    printPropertiesList(x, propertiesAreCalled)
  }
  else cat("\nNo ", propertiesAreCalled, ", prototype of class \"", .class1(ClassDef@prototype), "\"\n", sep = "")
  ext <- ClassDef@contains
  if (length(ext)) {
    cat("\nExtends: ")
    showExtends(ext)
  }
  ext <- ClassDef@subclasses
  if (length(ext)) {
    cat("\nKnown Subclasses: ")
    showExtends(ext)
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
showDefault
list(`package:methods` = function (object, oldMethods = TRUE) 
{
  clDef <- getClass(cl <- class(object), .Force = TRUE)
  if (!missing(oldMethods)) 
    .Deprecated(msg = "the 'oldMethods' argument is deprecated, as it has been unused since R 1.7.0")
  if (!is.null(clDef) && isS4(object) && is.na(match(clDef@className, .BasicClasses))) {
    cat("An object of class ", classLabel(cl), "\n", sep = "")
    slots <- slotNames(clDef)
    dataSlot <- .dataSlot(slots)
    if (length(dataSlot) > 0) {
      show(slot(object, dataSlot))
      slots <- slots[is.na(match(slots, dataSlot))]
    }
    else if (length(slots) == 0) 
      show(unclass(object))
    for (what in slots) {
      if (what == ".Data") 
        next
      cat("Slot ", deparse(what), ":\n", sep = "")
      print(slot(object, what))
      cat("\n")
    }
  }
  else print(object, useS4 = FALSE)
  invisible()
}, function (object, oldMethods = TRUE) 
{
  clDef <- getClass(cl <- class(object), .Force = TRUE)
  if (!missing(oldMethods)) 
    .Deprecated(msg = "the 'oldMethods' argument is deprecated, as it has been unused since R 1.7.0")
  if (!is.null(clDef) && isS4(object) && is.na(match(clDef@className, .BasicClasses))) {
    cat("An object of class ", classLabel(cl), "\n", sep = "")
    slots <- slotNames(clDef)
    dataSlot <- .dataSlot(slots)
    if (length(dataSlot) > 0) {
      show(slot(object, dataSlot))
      slots <- slots[is.na(match(slots, dataSlot))]
    }
    else if (length(slots) == 0) 
      show(unclass(object))
    for (what in slots) {
      if (what == ".Data") 
        next
      cat("Slot ", deparse(what), ":\n", sep = "")
      print(slot(object, what))
      cat("\n")
    }
  }
  else print(object, useS4 = FALSE)
  invisible()
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
showExtends
list(`package:methods` = function (ext, printTo = stdout()) 
{
  what <- names(ext)
  how <- character(length(ext))
  for (i in seq_along(ext)) {
    eli <- el(ext, i)
    if (is(eli, "SClassExtension")) {
      how[i] <- if (length(eli@by)) 
        paste("by class", paste0("\"", eli@by, "\", distance ", eli@distance, collapse = ", "))
      else if (isTRUE(eli@dataPart)) 
        "from data part"
      else "directly"
      if (!eli@simple) {
        if (is.function(eli@test) && !isTRUE(body(eli@test))) {
          how[i] <- paste0(how[i], if (is.function(eli@coerce)) 
            ", with explicit test and coerce"
            else ", with explicit test")
        }
        else if (is.function(eli@coerce)) 
          how[i] <- paste0(how[i], ", with explicit coerce")
      }
    }
  }
  if (isFALSE(printTo)) 
    list(what = what, how = how)
  else if (all(!nzchar(how)) || all(how == "directly")) {
    what <- paste0("\"", what, "\"")
    if (length(what) > 1) 
      what <- c(paste0(what[-length(what)], ","), what[[length(what)]])
    cat(file = printTo, what, fill = TRUE)
  }
  else cat(file = printTo, "\n", paste0("Class \"", what, "\", ", how, "\n"), sep = "")
}, function (ext, printTo = stdout()) 
{
  what <- names(ext)
  how <- character(length(ext))
  for (i in seq_along(ext)) {
    eli <- el(ext, i)
    if (is(eli, "SClassExtension")) {
      how[i] <- if (length(eli@by)) 
        paste("by class", paste0("\"", eli@by, "\", distance ", eli@distance, collapse = ", "))
      else if (isTRUE(eli@dataPart)) 
        "from data part"
      else "directly"
      if (!eli@simple) {
        if (is.function(eli@test) && !isTRUE(body(eli@test))) {
          how[i] <- paste0(how[i], if (is.function(eli@coerce)) 
            ", with explicit test and coerce"
            else ", with explicit test")
        }
        else if (is.function(eli@coerce)) 
          how[i] <- paste0(how[i], ", with explicit coerce")
      }
    }
  }
  if (isFALSE(printTo)) 
    list(what = what, how = how)
  else if (all(!nzchar(how)) || all(how == "directly")) {
    what <- paste0("\"", what, "\"")
    if (length(what) > 1) 
      what <- c(paste0(what[-length(what)], ","), what[[length(what)]])
    cat(file = printTo, what, fill = TRUE)
  }
  else cat(file = printTo, "\n", paste0("Class \"", what, "\", ", how, "\n"), sep = "")
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
showMethods
list(`package:methods` = function (f = character(), where = topenv(parent.frame()), classes = NULL, includeDefs = FALSE, inherited = !includeDefs, showEmpty, printTo = stdout(), fdef = getGeneric(f, where = where)) 
{
  if (missing(showEmpty)) 
    showEmpty <- !missing(f)
  con <- if (isFALSE(printTo)) 
    textConnection(NULL, "w")
  else printTo
  if (is.function(f)) {
    fdef <- f
    if (missing(where)) 
      where <- environment(f)
    f <- deparse1(substitute(f))
  }
  if (!is(f, "character")) 
    stop(gettextf("first argument should be the names of one of more generic functions (got object of class %s)", dQuote(class(f))), domain = NA)
  if (length(f) == 0) {
    f <- if (missing(where)) 
      getGenerics()
    else getGenerics(where)
  }
  if (length(f) == 0) 
    cat(file = con, "no applicable functions\n")
  else if (length(f) > 1) {
    for (ff in f) {
      ffdef <- getGeneric(ff, where = where)
      if (missing(where)) {
        if (isGeneric(ff)) 
          Recall(ff, classes = classes, includeDefs = includeDefs, inherited = inherited, showEmpty = showEmpty, printTo = con, fdef = ffdef)
      }
      else if (isGeneric(ff, where)) {
        Recall(ff, where = where, classes = classes, includeDefs = includeDefs, inherited = inherited, showEmpty = showEmpty, printTo = con, fdef = ffdef)
      }
    }
  }
  else {
    out <- paste0("\nFunction \"", f, "\":\n")
    if (!is(fdef, "genericFunction")) 
      cat(file = con, out, "<not an S4 generic function>\n")
    else .showMethodsTable(fdef, includeDefs, inherited, classes = classes, showEmpty = showEmpty, printTo = con)
  }
  if (isFALSE(printTo)) {
    txtOut <- textConnectionValue(con)
    close(con)
    txtOut
  }
  else invisible(printTo)
}, function (f = character(), where = topenv(parent.frame()), classes = NULL, includeDefs = FALSE, inherited = !includeDefs, showEmpty, printTo = stdout(), fdef = getGeneric(f, where = where)) 
{
  if (missing(showEmpty)) 
    showEmpty <- !missing(f)
  con <- if (isFALSE(printTo)) 
    textConnection(NULL, "w")
  else printTo
  if (is.function(f)) {
    fdef <- f
    if (missing(where)) 
      where <- environment(f)
    f <- deparse1(substitute(f))
  }
  if (!is(f, "character")) 
    stop(gettextf("first argument should be the names of one of more generic functions (got object of class %s)", dQuote(class(f))), domain = NA)
  if (length(f) == 0) {
    f <- if (missing(where)) 
      getGenerics()
    else getGenerics(where)
  }
  if (length(f) == 0) 
    cat(file = con, "no applicable functions\n")
  else if (length(f) > 1) {
    for (ff in f) {
      ffdef <- getGeneric(ff, where = where)
      if (missing(where)) {
        if (isGeneric(ff)) 
          Recall(ff, classes = classes, includeDefs = includeDefs, inherited = inherited, showEmpty = showEmpty, printTo = con, fdef = ffdef)
      }
      else if (isGeneric(ff, where)) {
        Recall(ff, where = where, classes = classes, includeDefs = includeDefs, inherited = inherited, showEmpty = showEmpty, printTo = con, fdef = ffdef)
      }
    }
  }
  else {
    out <- paste0("\nFunction \"", f, "\":\n")
    if (!is(fdef, "genericFunction")) 
      cat(file = con, out, "<not an S4 generic function>\n")
    else .showMethodsTable(fdef, includeDefs, inherited, classes = classes, showEmpty = showEmpty, printTo = con)
  }
  if (isFALSE(printTo)) {
    txtOut <- textConnectionValue(con)
    close(con)
    txtOut
  }
  else invisible(printTo)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
showMlist
list(`package:methods` = function (mlist, includeDefs = TRUE, inherited = TRUE, classes = NULL, useArgNames = TRUE, printTo = stdout()) 
{
  .MlistDeprecated("showMlist()")
  if (isFALSE(printTo)) {
    tmp <- tempfile()
    con <- file(tmp, "w")
  }
  else con <- printTo
  object <- linearizeMlist(mlist, inherited)
  methods <- object@methods
  signatures <- object@classes
  args <- object@arguments
  if (!is.null(classes) && length(signatures) > 0) {
    keep <- !vapply(signatures, function(x, y) all(is.na(match(x, y))), NA, classes)
    methods <- methods[keep]
    signatures <- signatures[keep]
    args <- args[keep]
  }
  if (length(methods) == 0) 
    cat(file = con, "<Empty Methods List>\n")
  else {
    n <- length(methods)
    labels <- character(n)
    if (useArgNames) {
      for (i in 1:n) {
        sigi <- signatures[[i]]
        labels[[i]] <- paste0(args[[i]], " = \"", sigi, "\"", collapse = ", ")
      }
    }
    else {
      for (i in 1:n) labels[[i]] <- paste(signatures[[i]], collapse = ", ")
    }
    for (i in seq_along(methods)) {
      cat(file = con, (if (includeDefs) 
        "## Signature:"
        else ""), labels[[i]])
      method <- methods[[i]]
      if (includeDefs) {
        cat(file = con, ":\n")
        if (is(method, "MethodDefinition")) 
          cat(file = con, deparse(method@.Data), sep = "\n")
        else cat(file = con, deparse(method), sep = "\n")
      }
      if (is(method, "MethodDefinition") && !identical(method@target, method@defined)) {
        defFrom <- method@defined
        cat(file = con, if (includeDefs) 
          "##:"
          else "\n", "    (inherited from ", paste0(names(defFrom), " = \"", as.character(defFrom), "\"", collapse = ", "), ")", if (includeDefs) 
            "\n", sep = "")
      }
      cat(file = con, "\n")
    }
  }
  if (isFALSE(printTo)) {
    close(con)
    value <- readLines(tmp)
    unlink(tmp)
    value
  }
}, function (mlist, includeDefs = TRUE, inherited = TRUE, classes = NULL, useArgNames = TRUE, printTo = stdout()) 
{
  .MlistDeprecated("showMlist()")
  if (isFALSE(printTo)) {
    tmp <- tempfile()
    con <- file(tmp, "w")
  }
  else con <- printTo
  object <- linearizeMlist(mlist, inherited)
  methods <- object@methods
  signatures <- object@classes
  args <- object@arguments
  if (!is.null(classes) && length(signatures) > 0) {
    keep <- !vapply(signatures, function(x, y) all(is.na(match(x, y))), NA, classes)
    methods <- methods[keep]
    signatures <- signatures[keep]
    args <- args[keep]
  }
  if (length(methods) == 0) 
    cat(file = con, "<Empty Methods List>\n")
  else {
    n <- length(methods)
    labels <- character(n)
    if (useArgNames) {
      for (i in 1:n) {
        sigi <- signatures[[i]]
        labels[[i]] <- paste0(args[[i]], " = \"", sigi, "\"", collapse = ", ")
      }
    }
    else {
      for (i in 1:n) labels[[i]] <- paste(signatures[[i]], collapse = ", ")
    }
    for (i in seq_along(methods)) {
      cat(file = con, (if (includeDefs) 
        "## Signature:"
        else ""), labels[[i]])
      method <- methods[[i]]
      if (includeDefs) {
        cat(file = con, ":\n")
        if (is(method, "MethodDefinition")) 
          cat(file = con, deparse(method@.Data), sep = "\n")
        else cat(file = con, deparse(method), sep = "\n")
      }
      if (is(method, "MethodDefinition") && !identical(method@target, method@defined)) {
        defFrom <- method@defined
        cat(file = con, if (includeDefs) 
          "##:"
          else "\n", "    (inherited from ", paste0(names(defFrom), " = \"", as.character(defFrom), "\"", collapse = ", "), ")", if (includeDefs) 
            "\n", sep = "")
      }
      cat(file = con, "\n")
    }
  }
  if (isFALSE(printTo)) {
    close(con)
    value <- readLines(tmp)
    unlink(tmp)
    value
  }
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
signature
list(`package:methods` = function (...) 
{
  value <- list(...)
  names <- names(value)
  for (i in seq_along(value)) {
    sigi <- value[[i]]
    if (!is.character(sigi) || length(sigi) != 1) 
      stop(gettextf("bad class specified for element %d (should be a single character string)", i), domain = NA)
  }
  setNames(as.character(value), names)
}, function (...) 
{
  value <- list(...)
  names <- names(value)
  for (i in seq_along(value)) {
    sigi <- value[[i]]
    if (!is.character(sigi) || length(sigi) != 1) 
      stop(gettextf("bad class specified for element %d (should be a single character string)", i), domain = NA)
  }
  setNames(as.character(value), names)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
SignatureMethod
list(`package:methods` = function (names, signature, definition) 
{
  .MlistDeprecated("SignatureMethod()")
  n <- length(signature)
  if (n > length(names)) 
    stop("arguments 'names' and 'signature' must have the same length")
  if (n == 0) 
    return(definition)
  Class <- signature[[n]]
  name <- names[[n]]
  m <- MethodsList(name)
  slot(m, "methods")[[Class]] <- definition
  slot(m, "argument") <- as.name(name)
  SignatureMethod(names[-n], signature[-n], m)
}, function (names, signature, definition) 
{
  .MlistDeprecated("SignatureMethod()")
  n <- length(signature)
  if (n > length(names)) 
    stop("arguments 'names' and 'signature' must have the same length")
  if (n == 0) 
    return(definition)
  Class <- signature[[n]]
  name <- names[[n]]
  m <- MethodsList(name)
  slot(m, "methods")[[Class]] <- definition
  slot(m, "argument") <- as.name(name)
  SignatureMethod(names[-n], signature[-n], m)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
sigToEnv
list(`package:methods` = function (signature, generic) 
{
  genericSig <- generic@signature
  package <- packageSlot(signature)
  if (is.null(package)) 
    parent <- environment(generic)
  else parent <- .requirePackage(package)
  value <- new.env(parent = parent)
  classes <- as.character(signature)
  args <- names(signature)
  for (i in seq_along(args)) assign(args[[i]], classes[[i]], envir = value)
  if (length(args) < length(genericSig)) 
    for (other in genericSig[is.na(match(genericSig, args))]) assign(other, "ANY", envir = value)
  value
}, function (signature, generic) 
{
  genericSig <- generic@signature
  package <- packageSlot(signature)
  if (is.null(package)) 
    parent <- environment(generic)
  else parent <- .requirePackage(package)
  value <- new.env(parent = parent)
  classes <- as.character(signature)
  args <- names(signature)
  for (i in seq_along(args)) assign(args[[i]], classes[[i]], envir = value)
  if (length(args) < length(genericSig)) 
    for (other in genericSig[is.na(match(genericSig, args))]) assign(other, "ANY", envir = value)
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
slot
list(`package:methods` = function (object, name) 
  .Call(C_R_get_slot, object, name), function (object, name) 
    .Call(C_R_get_slot, object, name))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
slot<-
  list(`package:methods` = function (object, name, check = TRUE, value) 
  {
    if (check) 
      value <- checkSlotAssignment(object, name, value)
    .Call(C_R_set_slot, object, name, value)
  }, function (object, name, check = TRUE, value) 
  {
    if (check) 
      value <- checkSlotAssignment(object, name, value)
    .Call(C_R_set_slot, object, name, value)
  })
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
slotNames
list(`package:methods` = function (x) 
  if (is(x, "classRepresentation")) names(x@slots) else .slotNames(x), function (x) 
    if (is(x, "classRepresentation")) names(x@slots) else .slotNames(x))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
slotsFromS3
list(`package:methods` = new("standardGeneric", .Data = function (object) 
  standardGeneric("slotsFromS3"), generic = "slotsFromS3", package = "methods", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object) 
  {
    list()
  }, target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "slotsFromS3"), skeleton = (new("derivedDefaultMethod", .Data = function (object) 
  {
    list()
  }, target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "slotsFromS3"))(object)), new("standardGeneric", .Data = function (object) 
    standardGeneric("slotsFromS3"), generic = "slotsFromS3", package = "methods", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object) 
    {
      list()
    }, target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "slotsFromS3"), skeleton = (new("derivedDefaultMethod", .Data = function (object) 
    {
      list()
    }, target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "slotsFromS3"))(object)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
substituteDirect
list(`package:methods` = function (object, frame = parent.frame(), cleanFunction = TRUE) 
{
  value <- .Call(C_do_substitute_direct, object, frame)
  if (cleanFunction && is.function(value)) {
    environment(value) <- .GlobalEnv
  }
  value
}, function (object, frame = parent.frame(), cleanFunction = TRUE) 
{
  value <- .Call(C_do_substitute_direct, object, frame)
  if (cleanFunction && is.function(value)) {
    environment(value) <- .GlobalEnv
  }
  value
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
substituteFunctionArgs
list(`package:methods` = function (def, newArgs, args = formalArgs(def), silent = FALSE, functionName = "a function") 
{
  if (!identical(args, newArgs)) {
    if (!missing(functionName)) 
      functionName <- paste("for", functionName)
    n <- length(args)
    if (n != length(newArgs)) 
      stop(sprintf("trying to change the argument list of %s with %d arguments to have arguments (%s)", functionName, n, paste(newArgs, collapse = ", ")), domain = NA)
    bdy <- body(def)
    checkFor <- newArgs[is.na(match(newArgs, args))]
    locals <- all.vars(bdy)
    if (length(checkFor) && any(!is.na(match(checkFor, locals)))) 
      stop(sprintf("get rid of variables in definition %s (%s); they conflict with the needed change to argument names (%s)", functionName, paste(checkFor[!is.na(match(checkFor, locals))], collapse = ", "), paste(newArgs, collapse = ", ")), domain = NA)
    ll <- vector("list", 2 * n)
    for (i in seq_len(n)) {
      ll[[i]] <- as.name(args[[i]])
      ll[[n + i]] <- as.name(newArgs[[i]])
    }
    names(ll) <- c(args, newArgs)
    body(def, envir = environment(def)) <- substituteDirect(bdy, ll)
    if (!silent) {
      msg <- sprintf("NOTE: arguments in definition %s changed from (%s) to (%s)", functionName, paste(args, collapse = ", "), paste(newArgs, collapse = ", "))
      message(msg, domain = NA)
    }
  }
  def
}, function (def, newArgs, args = formalArgs(def), silent = FALSE, functionName = "a function") 
{
  if (!identical(args, newArgs)) {
    if (!missing(functionName)) 
      functionName <- paste("for", functionName)
    n <- length(args)
    if (n != length(newArgs)) 
      stop(sprintf("trying to change the argument list of %s with %d arguments to have arguments (%s)", functionName, n, paste(newArgs, collapse = ", ")), domain = NA)
    bdy <- body(def)
    checkFor <- newArgs[is.na(match(newArgs, args))]
    locals <- all.vars(bdy)
    if (length(checkFor) && any(!is.na(match(checkFor, locals)))) 
      stop(sprintf("get rid of variables in definition %s (%s); they conflict with the needed change to argument names (%s)", functionName, paste(checkFor[!is.na(match(checkFor, locals))], collapse = ", "), paste(newArgs, collapse = ", ")), domain = NA)
    ll <- vector("list", 2 * n)
    for (i in seq_len(n)) {
      ll[[i]] <- as.name(args[[i]])
      ll[[n + i]] <- as.name(newArgs[[i]])
    }
    names(ll) <- c(args, newArgs)
    body(def, envir = environment(def)) <- substituteDirect(bdy, ll)
    if (!silent) {
      msg <- sprintf("NOTE: arguments in definition %s changed from (%s) to (%s)", functionName, paste(args, collapse = ", "), paste(newArgs, collapse = ", "))
      message(msg, domain = NA)
    }
  }
  def
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
Summary
list(`package:methods` = new("groupGenericFunction", .Data = function (x, ..., na.rm = FALSE) 
  standardGeneric("Summary"), groupMembers = list("max", "min", "range", "prod", "sum", "any", "all"), generic = "Summary", package = "base", group = list(), valueClass = character(0), signature = c("x", "na.rm"), default = NULL, skeleton = (function (x, ..., na.rm = FALSE) 
    stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Summary"), domain = NA))(x, ..., na.rm = na.rm)), new("groupGenericFunction", .Data = function (x, ..., na.rm = FALSE) 
      standardGeneric("Summary"), groupMembers = list("max", "min", "range", "prod", "sum", "any", "all"), generic = "Summary", package = "base", group = list(), valueClass = character(0), signature = c("x", "na.rm"), default = NULL, skeleton = (function (x, ..., na.rm = FALSE) 
        stop(gettextf("invalid call in method dispatch to '%s' (no default method)", "Summary"), domain = NA))(x, ..., na.rm = na.rm)))
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
superClassDepth
list(`package:methods` = function (ClassDef, soFar = ClassDef@className, simpleOnly = TRUE) 
{
  ext <- ClassDef@contains
  ok <- rep.int(TRUE, length(ext))
  for (i in seq_along(ext)) {
    exti <- ext[[i]]
    if (.isIndirectExtension(exti) || (simpleOnly && !exti@simple)) 
      ok[i] <- FALSE
  }
  ext <- ext[ok]
  immediate <- names(ext)
  notSoFar <- is.na(match(immediate, soFar))
  immediate <- immediate[notSoFar]
  super <- list(label = immediate, depth = rep.int(1, length(immediate)), ext = ext)
  for (i in seq_along(immediate)) {
    what <- immediate[[i]]
    if (!is.na(match(what, soFar))) 
      next
    exti <- ext[[i]]
    soFar <- c(soFar, what)
    if (!is(exti, "SClassExtension")) 
      stop(gettextf("in definition of class %s, information for superclass %s is of class %s (expected \"SClassExtension\")", dQuote(ClassDef@className), dQuote(what), dQuote(class(exti))), domain = NA)
    superClass <- getClassDef(exti@superClass, package = exti@package)
    if (is.null(superClass)) {
      warning(gettextf("class %s extends an undefined class, %s", dQuote(ClassDef@className), dQuote(what)), domain = NA)
      next
    }
    more <- Recall(superClass, soFar)
    whatMore <- more$label
    if (!all(is.na(match(whatMore, soFar)))) {
      ok <- is.na(match(whatMore, soFar))
      more$depth <- more$depth[ok]
      more$label <- more$label[ok]
      more$ext <- more$ext[ok]
      whatMore <- whatMore[ok]
    }
    if (length(whatMore)) {
      soFar <- c(soFar, whatMore)
      super$depth <- c(super$depth, 1 + more$depth)
      super$label <- c(super$label, more$label)
      super$ext <- c(super$ext, more$ext)
    }
  }
  super
}, function (ClassDef, soFar = ClassDef@className, simpleOnly = TRUE) 
{
  ext <- ClassDef@contains
  ok <- rep.int(TRUE, length(ext))
  for (i in seq_along(ext)) {
    exti <- ext[[i]]
    if (.isIndirectExtension(exti) || (simpleOnly && !exti@simple)) 
      ok[i] <- FALSE
  }
  ext <- ext[ok]
  immediate <- names(ext)
  notSoFar <- is.na(match(immediate, soFar))
  immediate <- immediate[notSoFar]
  super <- list(label = immediate, depth = rep.int(1, length(immediate)), ext = ext)
  for (i in seq_along(immediate)) {
    what <- immediate[[i]]
    if (!is.na(match(what, soFar))) 
      next
    exti <- ext[[i]]
    soFar <- c(soFar, what)
    if (!is(exti, "SClassExtension")) 
      stop(gettextf("in definition of class %s, information for superclass %s is of class %s (expected \"SClassExtension\")", dQuote(ClassDef@className), dQuote(what), dQuote(class(exti))), domain = NA)
    superClass <- getClassDef(exti@superClass, package = exti@package)
    if (is.null(superClass)) {
      warning(gettextf("class %s extends an undefined class, %s", dQuote(ClassDef@className), dQuote(what)), domain = NA)
      next
    }
    more <- Recall(superClass, soFar)
    whatMore <- more$label
    if (!all(is.na(match(whatMore, soFar)))) {
      ok <- is.na(match(whatMore, soFar))
      more$depth <- more$depth[ok]
      more$label <- more$label[ok]
      more$ext <- more$ext[ok]
      whatMore <- whatMore[ok]
    }
    if (length(whatMore)) {
      soFar <- c(soFar, whatMore)
      super$depth <- c(super$depth, 1 + more$depth)
      super$label <- c(super$label, more$label)
      super$ext <- c(super$ext, more$ext)
    }
  }
  super
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
testInheritedMethods
list(`package:methods` = function (f, signatures, test = TRUE, virtual = FALSE, groupMethods = TRUE, where = .GlobalEnv) 
{
  .relevantClasses <- function(classes, excludeVirtual, where, doinheritance) {
    classDefs <- lapply(classes, getClassDef, where)
    undefs <- vapply(classDefs, is.null, NA)
    if (any(undefs)) {
      .undefClasses <<- unique(c(.undefClasses, classes[undefs]))
      classes <- classes[!undefs]
      classDefs <- classDefs[!undefs]
    }
    if (doinheritance) {
      allSubs <- lapply(classDefs, function(what) names(what@subclasses))
      allSubs <- unique(unlist(allSubs))
      pattern <- sapply(allSubs, .matchSubsPattern, classes, excludeVirtual)
      if (excludeVirtual) {
        excl <- nzchar(pattern)
        pattern <- pattern[excl]
        allSubs <- allSubs[excl]
      }
      if (length(allSubs) > 0) 
        allSubs <- sapply(split(allSubs, pattern), `[[`, 1)
      else allSubs <- character()
    }
    else allSubs <- character()
    iAny <- match("ANY", classes, 0)
    if (iAny > 0) {
      classes[[iAny]] <- ".Other"
      classDefs[[iAny]] <- getClassDef(".Other")
    }
    if (excludeVirtual) 
      classes <- classes[vapply(classDefs, function(def) isFALSE(def@virtual), NA)]
    unique(c(classes, allSubs))
  }
  if (!is(f, "genericFunction")) 
    f <- getGeneric(f)
  fname <- f@generic
  if (missing(signatures)) {
    mdefs <- findMethods(f)
    mnames <- names(mdefs)
    sigs <- findMethodSignatures(methods = mdefs)
    if (groupMethods) {
      groups <- getGroup(f, recursive = TRUE)
      for (group in groups) {
        fg <- getGeneric(group)
        mg <- findMethods(fg)
        sigsg <- findMethodSignatures(methods = mg)
        newSigs <- is.na(match(names(mg), mnames))
        sigs <- rbind(sigs, sigsg[newSigs, ])
        mnames <- c(mnames, names(mg)[newSigs])
      }
    }
    if (length(sigs) == 0) 
      return(new("MethodSelectionReport", generic = fname))
    ok <- if (fname %in% c("coerce", "coerce<-")) 
      match(colnames(sigs), "from", 0) > 0
    else rep.int(TRUE, ncol(sigs))
    for (j in seq_len(ncol(sigs))) {
      classesj <- unique(sigs[, j])
      .undefClasses <- character()
      subclasses <- .relevantClasses(classesj, !virtual, where, ok[[j]])
      nj <- length(subclasses)
      if (j > 1) {
        subclasses <- rep(subclasses, rep.int(ncomb, nj))
        ncomb <- ncomb * nj
        sigLabels <- paste(rep(sigLabels, times = nj), subclasses, sep = "#")
      }
      else {
        sigLabels <- subclasses
        ncomb <- nj
      }
      if (length(.undefClasses)) {
        warning(gettextf("undefined classes (%s) will be ignored for argument '%s'", paste0("\"", unique(.undefClasses), "\"", collapse = ", "), colnames(sigs)[[j]]), domain = NA)
        .undefClasses <- character()
      }
    }
    signatures <- strsplit(sigLabels, "#", fixed = TRUE)
  }
  else if (is(signatures, "matrix") && typeof(signatures) == "character" && ncol(signatures) <= length(f@signature)) {
    siglist <- vector("list", nrow(signatures))
    for (i in seq_len(nrow(signatures))) siglist[[i]] <- signatures[i, ]
    signatures <- siglist
  }
  else stop("argument 'signatures' must be a character matrix whose rows are method signatures")
  ambig_target <- character()
  ambig_candidates <- list()
  ambig_selected <- character()
  ambig_note <- character()
  if (test) {
    warninghandler <- function(cond) {
      ambig_target <<- c(ambig_target, attr(cond, "target"))
      ambig_candidates <<- c(ambig_candidates, list(attr(cond, "candidates")))
      ambig_selected <<- c(ambig_selected, attr(cond, "selected"))
      ambig_note <<- c(ambig_note, attr(cond, "notes"))
    }
    ambigOpt <- options(ambiguousMethodSelection = warninghandler)
    on.exit(options(ambigOpt))
    doSelect <- function(sig) {
      x <- selectMethod(f = f, sig, optional = TRUE)
      if (is(x, "MethodDefinition")) {
        nsig <- x@defined
        if (length(nsig) < length(sig)) 
          c(nsig, rep("ANY", length(sig) - length(nsig)))
        else nsig
      }
      else if (is.null(x)) 
        rep_len("<NONE>", length(sig))
      else rep_len("ANY", length(sig))
    }
    signatures <- lapply(signatures, doSelect)
  }
  signatures <- sapply(signatures, paste0, collapse = "#")
  names(signatures) <- sigLabels
  new("MethodSelectionReport", generic = fname, allSelections = signatures, target = ambig_target, selected = ambig_selected, candidates = ambig_candidates, note = ambig_note)
}, function (f, signatures, test = TRUE, virtual = FALSE, groupMethods = TRUE, where = .GlobalEnv) 
{
  .relevantClasses <- function(classes, excludeVirtual, where, doinheritance) {
    classDefs <- lapply(classes, getClassDef, where)
    undefs <- vapply(classDefs, is.null, NA)
    if (any(undefs)) {
      .undefClasses <<- unique(c(.undefClasses, classes[undefs]))
      classes <- classes[!undefs]
      classDefs <- classDefs[!undefs]
    }
    if (doinheritance) {
      allSubs <- lapply(classDefs, function(what) names(what@subclasses))
      allSubs <- unique(unlist(allSubs))
      pattern <- sapply(allSubs, .matchSubsPattern, classes, excludeVirtual)
      if (excludeVirtual) {
        excl <- nzchar(pattern)
        pattern <- pattern[excl]
        allSubs <- allSubs[excl]
      }
      if (length(allSubs) > 0) 
        allSubs <- sapply(split(allSubs, pattern), `[[`, 1)
      else allSubs <- character()
    }
    else allSubs <- character()
    iAny <- match("ANY", classes, 0)
    if (iAny > 0) {
      classes[[iAny]] <- ".Other"
      classDefs[[iAny]] <- getClassDef(".Other")
    }
    if (excludeVirtual) 
      classes <- classes[vapply(classDefs, function(def) isFALSE(def@virtual), NA)]
    unique(c(classes, allSubs))
  }
  if (!is(f, "genericFunction")) 
    f <- getGeneric(f)
  fname <- f@generic
  if (missing(signatures)) {
    mdefs <- findMethods(f)
    mnames <- names(mdefs)
    sigs <- findMethodSignatures(methods = mdefs)
    if (groupMethods) {
      groups <- getGroup(f, recursive = TRUE)
      for (group in groups) {
        fg <- getGeneric(group)
        mg <- findMethods(fg)
        sigsg <- findMethodSignatures(methods = mg)
        newSigs <- is.na(match(names(mg), mnames))
        sigs <- rbind(sigs, sigsg[newSigs, ])
        mnames <- c(mnames, names(mg)[newSigs])
      }
    }
    if (length(sigs) == 0) 
      return(new("MethodSelectionReport", generic = fname))
    ok <- if (fname %in% c("coerce", "coerce<-")) 
      match(colnames(sigs), "from", 0) > 0
    else rep.int(TRUE, ncol(sigs))
    for (j in seq_len(ncol(sigs))) {
      classesj <- unique(sigs[, j])
      .undefClasses <- character()
      subclasses <- .relevantClasses(classesj, !virtual, where, ok[[j]])
      nj <- length(subclasses)
      if (j > 1) {
        subclasses <- rep(subclasses, rep.int(ncomb, nj))
        ncomb <- ncomb * nj
        sigLabels <- paste(rep(sigLabels, times = nj), subclasses, sep = "#")
      }
      else {
        sigLabels <- subclasses
        ncomb <- nj
      }
      if (length(.undefClasses)) {
        warning(gettextf("undefined classes (%s) will be ignored for argument '%s'", paste0("\"", unique(.undefClasses), "\"", collapse = ", "), colnames(sigs)[[j]]), domain = NA)
        .undefClasses <- character()
      }
    }
    signatures <- strsplit(sigLabels, "#", fixed = TRUE)
  }
  else if (is(signatures, "matrix") && typeof(signatures) == "character" && ncol(signatures) <= length(f@signature)) {
    siglist <- vector("list", nrow(signatures))
    for (i in seq_len(nrow(signatures))) siglist[[i]] <- signatures[i, ]
    signatures <- siglist
  }
  else stop("argument 'signatures' must be a character matrix whose rows are method signatures")
  ambig_target <- character()
  ambig_candidates <- list()
  ambig_selected <- character()
  ambig_note <- character()
  if (test) {
    warninghandler <- function(cond) {
      ambig_target <<- c(ambig_target, attr(cond, "target"))
      ambig_candidates <<- c(ambig_candidates, list(attr(cond, "candidates")))
      ambig_selected <<- c(ambig_selected, attr(cond, "selected"))
      ambig_note <<- c(ambig_note, attr(cond, "notes"))
    }
    ambigOpt <- options(ambiguousMethodSelection = warninghandler)
    on.exit(options(ambigOpt))
    doSelect <- function(sig) {
      x <- selectMethod(f = f, sig, optional = TRUE)
      if (is(x, "MethodDefinition")) {
        nsig <- x@defined
        if (length(nsig) < length(sig)) 
          c(nsig, rep("ANY", length(sig) - length(nsig)))
        else nsig
      }
      else if (is.null(x)) 
        rep_len("<NONE>", length(sig))
      else rep_len("ANY", length(sig))
    }
    signatures <- lapply(signatures, doSelect)
  }
  signatures <- sapply(signatures, paste0, collapse = "#")
  names(signatures) <- sigLabels
  new("MethodSelectionReport", generic = fname, allSelections = signatures, target = ambig_target, selected = ambig_selected, candidates = ambig_candidates, note = ambig_note)
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
testVirtual
list(`package:methods` = function (properties, extends, prototype, where) 
{
  if (length(extends)) {
    en <- names(extends)
    if (!is.na(match("VIRTUAL", en))) 
      return(TRUE)
    for (what in en) {
      enDef <- getClassDef(what, package = packageSlot(extends[[what]]))
      if (!is.null(enDef) && isFALSE(enDef@virtual)) 
        return(FALSE)
    }
  }
  (length(properties) == 0 && is.null(prototype))
}, function (properties, extends, prototype, where) 
{
  if (length(extends)) {
    en <- names(extends)
    if (!is.na(match("VIRTUAL", en))) 
      return(TRUE)
    for (what in en) {
      enDef <- getClassDef(what, package = packageSlot(extends[[what]]))
      if (!is.null(enDef) && isFALSE(enDef@virtual)) 
        return(FALSE)
    }
  }
  (length(properties) == 0 && is.null(prototype))
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
tryNew
list(`package:methods` = function (Class, where) 
{
  ClassDef <- getClassDef(Class, where)
  if (is.null(ClassDef)) 
    return(NULL)
  else if (isTRUE(ClassDef@virtual)) 
    ClassDef@prototype
  else tryCatch(new(ClassDef), error = function(e) {
    value <- ClassDef@prototype
    class(value) <- ClassDef@className
    value
  })
}, function (Class, where) 
{
  ClassDef <- getClassDef(Class, where)
  if (is.null(ClassDef)) 
    return(NULL)
  else if (isTRUE(ClassDef@virtual)) 
    ClassDef@prototype
  else tryCatch(new(ClassDef), error = function(e) {
    value <- ClassDef@prototype
    class(value) <- ClassDef@className
    value
  })
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
unRematchDefinition
list(`package:methods` = function (definition) 
{
  if (isRematched(definition)) 
    definition <- body(definition)[[2]][[3]]
  definition
}, function (definition) 
{
  if (isRematched(definition)) 
    definition <- body(definition)[[2]][[3]]
  definition
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
validObject
list(`package:methods` = function (object, test = FALSE, complete = FALSE) 
{
  Class <- class(object)
  classDef <- getClassDef(Class)
  where <- .classEnv(classDef)
  anyStrings <- function(x) if (isTRUE(x)) 
    character()
  else x
  errors <- character()
  slotTypes <- classDef@slots
  slotNames <- names(slotTypes)
  attrNames <- c(".Data", ".S3Class", names(attributes(object)))
  if (anyNA(idx <- match(slotNames, attrNames))) {
    badSlots <- is.na(idx)
    errors <- c(errors, paste("slots in class definition but not in object:", paste0("\"", slotNames[badSlots], "\"", collapse = ", ")))
    slotTypes <- slotTypes[!badSlots]
    slotNames <- slotNames[!badSlots]
  }
  for (i in seq_along(slotTypes)) {
    classi <- slotTypes[[i]]
    classDefi <- getClassDef(classi, where = where)
    if (is.null(classDefi)) {
      errors <- c(errors, paste0("undefined class for slot \"", slotNames[[i]], "\" (\"", classi, "\")"))
      next
    }
    namei <- slotNames[[i]]
    sloti <- try(switch(namei, .S3Class = S3Class(object), slot(object, namei)), silent = TRUE)
    if (inherits(sloti, "try-error")) {
      errors <- c(errors, sloti)
      next
    }
    ok <- possibleExtends(class(sloti), classi, ClassDef2 = classDefi)
    if (isFALSE(ok)) {
      errors <- c(errors, paste0("invalid object for slot \"", slotNames[[i]], "\" in class \"", Class, "\": got class \"", class(sloti)[[1]], "\", should be or extend class \"", classi, "\""))
      next
    }
    if (!complete) 
      next
    errori <- anyStrings(Recall(sloti, TRUE, TRUE))
    if (length(errori)) {
      errori <- paste0("In slot \"", slotNames[[i]], "\" of class \"", class(sloti), "\": ", errori)
      errors <- c(errors, errori)
    }
  }
  extends <- rev(classDef@contains)
  for (i in seq_along(extends)) {
    exti <- extends[[i]]
    superClass <- exti@superClass
    if (!exti@simple && !is(object, superClass)) 
      next
    superDef <- getClassDef(superClass)
    if (is.null(superDef)) {
      errors <- c(errors, paste0("superclass \"", superClass, "\" not defined in the environment of the object's class"))
      break
    }
    validityMethod <- superDef@validity
    if (is.function(validityMethod)) {
      errors <- c(errors, anyStrings(validityMethod(as(object, superClass))))
      if (length(errors)) 
        break
    }
  }
  validityMethod <- classDef@validity
  if (length(errors) == 0 && is.function(validityMethod)) {
    errors <- c(errors, anyStrings(validityMethod(object)))
  }
  if (length(errors)) {
    if (test) 
      errors
    else {
      msg <- gettextf("invalid class %s object", dQuote(Class))
      if (length(errors) > 1) 
        stop(paste(paste0(msg, ":"), paste(seq_along(errors), errors, sep = ": "), collapse = "\n"), domain = NA)
      else stop(msg, ": ", errors, domain = NA)
    }
  }
  else TRUE
}, function (object, test = FALSE, complete = FALSE) 
{
  Class <- class(object)
  classDef <- getClassDef(Class)
  where <- .classEnv(classDef)
  anyStrings <- function(x) if (isTRUE(x)) 
    character()
  else x
  errors <- character()
  slotTypes <- classDef@slots
  slotNames <- names(slotTypes)
  attrNames <- c(".Data", ".S3Class", names(attributes(object)))
  if (anyNA(idx <- match(slotNames, attrNames))) {
    badSlots <- is.na(idx)
    errors <- c(errors, paste("slots in class definition but not in object:", paste0("\"", slotNames[badSlots], "\"", collapse = ", ")))
    slotTypes <- slotTypes[!badSlots]
    slotNames <- slotNames[!badSlots]
  }
  for (i in seq_along(slotTypes)) {
    classi <- slotTypes[[i]]
    classDefi <- getClassDef(classi, where = where)
    if (is.null(classDefi)) {
      errors <- c(errors, paste0("undefined class for slot \"", slotNames[[i]], "\" (\"", classi, "\")"))
      next
    }
    namei <- slotNames[[i]]
    sloti <- try(switch(namei, .S3Class = S3Class(object), slot(object, namei)), silent = TRUE)
    if (inherits(sloti, "try-error")) {
      errors <- c(errors, sloti)
      next
    }
    ok <- possibleExtends(class(sloti), classi, ClassDef2 = classDefi)
    if (isFALSE(ok)) {
      errors <- c(errors, paste0("invalid object for slot \"", slotNames[[i]], "\" in class \"", Class, "\": got class \"", class(sloti)[[1]], "\", should be or extend class \"", classi, "\""))
      next
    }
    if (!complete) 
      next
    errori <- anyStrings(Recall(sloti, TRUE, TRUE))
    if (length(errori)) {
      errori <- paste0("In slot \"", slotNames[[i]], "\" of class \"", class(sloti), "\": ", errori)
      errors <- c(errors, errori)
    }
  }
  extends <- rev(classDef@contains)
  for (i in seq_along(extends)) {
    exti <- extends[[i]]
    superClass <- exti@superClass
    if (!exti@simple && !is(object, superClass)) 
      next
    superDef <- getClassDef(superClass)
    if (is.null(superDef)) {
      errors <- c(errors, paste0("superclass \"", superClass, "\" not defined in the environment of the object's class"))
      break
    }
    validityMethod <- superDef@validity
    if (is.function(validityMethod)) {
      errors <- c(errors, anyStrings(validityMethod(as(object, superClass))))
      if (length(errors)) 
        break
    }
  }
  validityMethod <- classDef@validity
  if (length(errors) == 0 && is.function(validityMethod)) {
    errors <- c(errors, anyStrings(validityMethod(object)))
  }
  if (length(errors)) {
    if (test) 
      errors
    else {
      msg <- gettextf("invalid class %s object", dQuote(Class))
      if (length(errors) > 1) 
        stop(paste(paste0(msg, ":"), paste(seq_along(errors), errors, sep = ": "), collapse = "\n"), domain = NA)
      else stop(msg, ": ", errors, domain = NA)
    }
  }
  else TRUE
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)
validSlotNames
list(`package:methods` = function (names) 
{
  if (is.na(match("class", names))) 
    names
  else stop("\"class\" is a reserved slot name and cannot be redefined")
}, function (names) 
{
  if (is.na(match("class", names))) 
    names
  else stop("\"class\" is a reserved slot name and cannot be redefined")
})
c("package:methods", "namespace:methods")
c(TRUE, FALSE)
c(FALSE, TRUE)


################################################################################################
library(microbenchmark)
get_nanotime
list(`package:microbenchmark` = function () 
{
  .Call(do_get_nanotime, PACKAGE = "microbenchmark")
}, function () 
{
  .Call(do_get_nanotime, PACKAGE = "microbenchmark")
})
c("package:microbenchmark", "namespace:microbenchmark")
c(TRUE, FALSE)
c(FALSE, TRUE)
microbenchmark
list(`package:microbenchmark` = function (..., list = NULL, times = 100, unit = NULL, check = NULL, control = list(), setup = NULL) 
{
  stopifnot(times == as.integer(times))
  if (!missing(unit) && !is.null(unit)) 
    stopifnot(is.character(unit), length(unit) == 1)
  unit <- normalize_unit(unit)
  control[["warmup"]] <- coalesce(control[["warmup"]], 2^18)
  control[["order"]] <- coalesce(control[["order"]], "random")
  stopifnot(as.integer(control$warmup) == control$warmup)
  exprs <- c(as.list(match.call(expand.dots = FALSE)$...), list)
  nm <- names(exprs)
  exprnm <- sapply(exprs, function(e) paste(deparse(e), collapse = " "))
  if (is.null(nm)) 
    nm <- exprnm
  else nm[nm == ""] <- exprnm[nm == ""]
  names(exprs) <- nm
  env <- parent.frame()
  setup <- substitute(setup)
  if (!is.null(check)) {
    setupexpr <- as.expression(setup)
    checkexprs <- lapply(exprs, function(e) c(setupexpr, e))
    values <- lapply(checkexprs, eval, env)
    if (is.character(check) && isTRUE(check == "equal")) {
      check <- function(values) {
        all(sapply(values[-1], function(x) isTRUE(all.equal(values[[1]], x))))
      }
    }
    else if (is.character(check) && isTRUE(check == "equivalent")) {
      check <- function(values) {
        all(sapply(values[-1], function(x) isTRUE(all.equal(values[[1]], x, check.attributes = F))))
      }
    }
    else if (is.character(check) && isTRUE(check == "identical")) {
      check <- function(values) {
        all(sapply(values[-1], function(x) identical(values[[1]], x)))
      }
    }
    ok <- check(values)
    if (!isTRUE(ok)) {
      stop("Input expressions are not equivalent.", call. = FALSE)
    }
  }
  gc(FALSE)
  o <- if (control$order == "random") 
    sample(rep(seq_along(exprs), times = times))
  else if (control$order == "inorder") 
    rep(seq_along(exprs), times = times)
  else if (control$order == "block") 
    rep(seq_along(exprs), each = times)
  else stop("Unknown ordering. Must be one of 'random', 'inorder' or 'block'.")
  exprs <- exprs[o]
  if (anyDuplicated(nm) > 0) {
    duplicates <- nm[duplicated(nm)]
    stop("Expression names must be unique. Duplicate expression names: ", paste(duplicates, collapse = ", "))
  }
  expr <- factor(nm[o], levels = nm)
  res <- .Call(do_microtiming, exprs, env, as.integer(control$warmup), setup, PACKAGE = "microbenchmark")
  if (all(is.na(res))) 
    .all_na_stop()
  res <- data.frame(expr = expr, time = res)
  class(res) <- c("microbenchmark", class(res))
  if (!is.null(unit)) 
    attr(res, "unit") <- unit
  res
}, function (..., list = NULL, times = 100, unit = NULL, check = NULL, control = list(), setup = NULL) 
{
  stopifnot(times == as.integer(times))
  if (!missing(unit) && !is.null(unit)) 
    stopifnot(is.character(unit), length(unit) == 1)
  unit <- normalize_unit(unit)
  control[["warmup"]] <- coalesce(control[["warmup"]], 2^18)
  control[["order"]] <- coalesce(control[["order"]], "random")
  stopifnot(as.integer(control$warmup) == control$warmup)
  exprs <- c(as.list(match.call(expand.dots = FALSE)$...), list)
  nm <- names(exprs)
  exprnm <- sapply(exprs, function(e) paste(deparse(e), collapse = " "))
  if (is.null(nm)) 
    nm <- exprnm
  else nm[nm == ""] <- exprnm[nm == ""]
  names(exprs) <- nm
  env <- parent.frame()
  setup <- substitute(setup)
  if (!is.null(check)) {
    setupexpr <- as.expression(setup)
    checkexprs <- lapply(exprs, function(e) c(setupexpr, e))
    values <- lapply(checkexprs, eval, env)
    if (is.character(check) && isTRUE(check == "equal")) {
      check <- function(values) {
        all(sapply(values[-1], function(x) isTRUE(all.equal(values[[1]], x))))
      }
    }
    else if (is.character(check) && isTRUE(check == "equivalent")) {
      check <- function(values) {
        all(sapply(values[-1], function(x) isTRUE(all.equal(values[[1]], x, check.attributes = F))))
      }
    }
    else if (is.character(check) && isTRUE(check == "identical")) {
      check <- function(values) {
        all(sapply(values[-1], function(x) identical(values[[1]], x)))
      }
    }
    ok <- check(values)
    if (!isTRUE(ok)) {
      stop("Input expressions are not equivalent.", call. = FALSE)
    }
  }
  gc(FALSE)
  o <- if (control$order == "random") 
    sample(rep(seq_along(exprs), times = times))
  else if (control$order == "inorder") 
    rep(seq_along(exprs), times = times)
  else if (control$order == "block") 
    rep(seq_along(exprs), each = times)
  else stop("Unknown ordering. Must be one of 'random', 'inorder' or 'block'.")
  exprs <- exprs[o]
  if (anyDuplicated(nm) > 0) {
    duplicates <- nm[duplicated(nm)]
    stop("Expression names must be unique. Duplicate expression names: ", paste(duplicates, collapse = ", "))
  }
  expr <- factor(nm[o], levels = nm)
  res <- .Call(do_microtiming, exprs, env, as.integer(control$warmup), setup, PACKAGE = "microbenchmark")
  if (all(is.na(res))) 
    .all_na_stop()
  res <- data.frame(expr = expr, time = res)
  class(res) <- c("microbenchmark", class(res))
  if (!is.null(unit)) 
    attr(res, "unit") <- unit
  res
})
c("package:microbenchmark", "namespace:microbenchmark")
c(TRUE, FALSE)
c(FALSE, TRUE)
microtiming_precision
list(`package:microbenchmark` = function (rounds = 100, warmup = 2^18) 
{
  .Call(do_microtiming_precision, parent.frame(), as.integer(rounds), as.integer(warmup), PACKAGE = "microbenchmark")
}, function (rounds = 100, warmup = 2^18) 
{
  .Call(do_microtiming_precision, parent.frame(), as.integer(rounds), as.integer(warmup), PACKAGE = "microbenchmark")
})
c("package:microbenchmark", "namespace:microbenchmark")
c(TRUE, FALSE)
c(FALSE, TRUE)
