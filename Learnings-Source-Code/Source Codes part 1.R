library(base)       # (1380 out of 1380)   8
library(beepr)      # (2 out of 2)         40902
library(caret)      # (180 out of 180)     41009
library(checkmate)  # (363 out of 363)     50135
library(chron)      # (26 out of 26)       56451
library(cowsay)     # (3 out of 3)         57339

library(base) 
1) - : function (e1, e2)
-  
list(`package:base` = .Primitive("-"), .Primitive("-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
2)-.Date
list(`package:base` = function (e1, e2) 
{
  coerceTimeUnit <- function(x) as.vector(round(switch(attr(x, "units"), secs = x/86400, mins = x/1440, hours = x/24, days = x, weeks = 7 * x)))
  if (!inherits(e1, "Date")) 
    stop("can only subtract from \"Date\" objects")
  if (nargs() == 1) 
    stop("unary - is not defined for \"Date\" objects")
  if (inherits(e2, "Date")) 
    return(difftime(e1, e2, units = "days"))
  if (inherits(e2, "difftime")) 
    e2 <- coerceTimeUnit(e2)
  if (!is.null(attr(e2, "class"))) 
    stop("can only subtract numbers from \"Date\" objects")
  .Date(unclass(as.Date(e1)) - e2)
}, function (e1, e2) 
{
  coerceTimeUnit <- function(x) as.vector(round(switch(attr(x, "units"), secs = x/86400, mins = x/1440, hours = x/24, days = x, weeks = 7 * x)))
  if (!inherits(e1, "Date")) 
    stop("can only subtract from \"Date\" objects")
  if (nargs() == 1) 
    stop("unary - is not defined for \"Date\" objects")
  if (inherits(e2, "Date")) 
    return(difftime(e1, e2, units = "days"))
  if (inherits(e2, "difftime")) 
    e2 <- coerceTimeUnit(e2)
  if (!is.null(attr(e2, "class"))) 
    stop("can only subtract numbers from \"Date\" objects")
  .Date(unclass(as.Date(e1)) - e2)
}, function (e1, e2) 
{
  coerceTimeUnit <- function(x) as.vector(round(switch(attr(x, "units"), secs = x/86400, mins = x/1440, hours = x/24, days = x, weeks = 7 * x)))
  if (!inherits(e1, "Date")) 
    stop("can only subtract from \"Date\" objects")
  if (nargs() == 1) 
    stop("unary - is not defined for \"Date\" objects")
  if (inherits(e2, "Date")) 
    return(difftime(e1, e2, units = "days"))
  if (inherits(e2, "difftime")) 
    e2 <- coerceTimeUnit(e2)
  if (!is.null(attr(e2, "class"))) 
    stop("can only subtract numbers from \"Date\" objects")
  .Date(unclass(as.Date(e1)) - e2)
})
c("package:base", "registered S3 method for - from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
3)-.POSIXt
list(`package:base` = function (e1, e2) 
{
  coerceTimeUnit <- function(x) as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
  if (!inherits(e1, "POSIXt")) 
    stop("can only subtract from \"POSIXt\" objects")
  if (nargs() == 1) 
    stop("unary '-' is not defined for \"POSIXt\" objects")
  if (inherits(e2, "POSIXt")) 
    return(difftime(e1, e2))
  if (inherits(e2, "difftime")) 
    e2 <- coerceTimeUnit(e2)
  if (!is.null(attr(e2, "class"))) 
    stop("can only subtract numbers from \"POSIXt\" objects")
  e1 <- as.POSIXct(e1)
  .POSIXct(unclass(e1) - e2, attr(e1, "tzone"))
}, function (e1, e2) 
{
  coerceTimeUnit <- function(x) as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
  if (!inherits(e1, "POSIXt")) 
    stop("can only subtract from \"POSIXt\" objects")
  if (nargs() == 1) 
    stop("unary '-' is not defined for \"POSIXt\" objects")
  if (inherits(e2, "POSIXt")) 
    return(difftime(e1, e2))
  if (inherits(e2, "difftime")) 
    e2 <- coerceTimeUnit(e2)
  if (!is.null(attr(e2, "class"))) 
    stop("can only subtract numbers from \"POSIXt\" objects")
  e1 <- as.POSIXct(e1)
  .POSIXct(unclass(e1) - e2, attr(e1, "tzone"))
}, function (e1, e2) 
{
  coerceTimeUnit <- function(x) as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
  if (!inherits(e1, "POSIXt")) 
    stop("can only subtract from \"POSIXt\" objects")
  if (nargs() == 1) 
    stop("unary '-' is not defined for \"POSIXt\" objects")
  if (inherits(e2, "POSIXt")) 
    return(difftime(e1, e2))
  if (inherits(e2, "difftime")) 
    e2 <- coerceTimeUnit(e2)
  if (!is.null(attr(e2, "class"))) 
    stop("can only subtract numbers from \"POSIXt\" objects")
  e1 <- as.POSIXct(e1)
  .POSIXct(unclass(e1) - e2, attr(e1, "tzone"))
})
c("package:base", "registered S3 method for - from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
4)!
  list(`package:base` = .Primitive("!"), .Primitive("!"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
5)!.hexmode
list(`package:base` = function (a) 
  as.hexmode(bitwNot(as.hexmode(a))), function (a) 
    as.hexmode(bitwNot(as.hexmode(a))), function (a) 
      as.hexmode(bitwNot(as.hexmode(a))))
c("package:base", "registered S3 method for ! from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
6)!.octmode
list(`package:base` = function (a) 
  as.octmode(bitwNot(as.octmode(a))), function (a) 
    as.octmode(bitwNot(as.octmode(a))), function (a) 
      as.octmode(bitwNot(as.octmode(a))))
c("package:base", "registered S3 method for ! from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
7)!=
  list(`package:base` = .Primitive("!="), .Primitive("!="))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
8)$
  list(`package:base` = .Primitive("$"), .Primitive("$"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
9)$.DLLInfo
list(`package:base` = function (x, name) 
  getNativeSymbolInfo(as.character(name), PACKAGE = x), function (x, name) 
    getNativeSymbolInfo(as.character(name), PACKAGE = x), function (x, name) 
      getNativeSymbolInfo(as.character(name), PACKAGE = x))
c("package:base", "registered S3 method for $ from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
10)$.package_version
list(`package:base` = function (x, name) 
{
  name <- pmatch(name, c("major", "minor", "patchlevel"))
  x <- unclass(x)
  switch(name, major = vapply(x, `[`, 0, 1), minor = vapply(x, `[`, 0, 2), patchlevel = vapply(x, `[`, 0, 3))
}, function (x, name) 
{
  name <- pmatch(name, c("major", "minor", "patchlevel"))
  x <- unclass(x)
  switch(name, major = vapply(x, `[`, 0, 1), minor = vapply(x, `[`, 0, 2), patchlevel = vapply(x, `[`, 0, 3))
}, function (x, name) 
{
  name <- pmatch(name, c("major", "minor", "patchlevel"))
  x <- unclass(x)
  switch(name, major = vapply(x, `[`, 0, 1), minor = vapply(x, `[`, 0, 2), patchlevel = vapply(x, `[`, 0, 3))
})
c("package:base", "registered S3 method for $ from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
11)$<-
  list(`package:base` = .Primitive("$<-"), .Primitive("$<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
12)$<-.data.frame
list(`package:base` = function (x, name, value) 
{
  cl <- oldClass(x)
  class(x) <- NULL
  nrows <- .row_names_info(x, 2)
  if (!is.null(value)) {
    N <- NROW(value)
    if (N > nrows) 
      stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
    if (N < nrows) 
      if (N > 0 && (nrows%%N == 0) && length(dim(value)) <= 1) 
        value <- rep(value, length.out = nrows)
    else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
    if (is.atomic(value) && !is.null(names(value))) 
      names(value) <- NULL
  }
  x[[name]] <- value
  class(x) <- cl
  return(x)
}, function (x, name, value) 
{
  cl <- oldClass(x)
  class(x) <- NULL
  nrows <- .row_names_info(x, 2)
  if (!is.null(value)) {
    N <- NROW(value)
    if (N > nrows) 
      stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
    if (N < nrows) 
      if (N > 0 && (nrows%%N == 0) && length(dim(value)) <= 1) 
        value <- rep(value, length.out = nrows)
    else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
    if (is.atomic(value) && !is.null(names(value))) 
      names(value) <- NULL
  }
  x[[name]] <- value
  class(x) <- cl
  return(x)
}, function (x, name, value) 
{
  cl <- oldClass(x)
  class(x) <- NULL
  nrows <- .row_names_info(x, 2)
  if (!is.null(value)) {
    N <- NROW(value)
    if (N > nrows) 
      stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
    if (N < nrows) 
      if (N > 0 && (nrows%%N == 0) && length(dim(value)) <= 1) 
        value <- rep(value, length.out = nrows)
    else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
    if (is.atomic(value) && !is.null(names(value))) 
      names(value) <- NULL
  }
  x[[name]] <- value
  class(x) <- cl
  return(x)
})
c("package:base", "registered S3 method for $<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
13)%%
  list(`package:base` = .Primitive("%%"), .Primitive("%%"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
14)%*%
  list(`package:base` = .Primitive("%*%"), .Primitive("%*%"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
15)%/%
  list(`package:base` = .Primitive("%/%"), .Primitive("%/%"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
16)%in%
  list(`package:base` = function (x, table) 
    match(x, table, nomatch = 0) > 0, function (x, table) 
      match(x, table, nomatch = 0) > 0)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
17)%o%
  list(`package:base` = function (X, Y) 
    outer(X, Y), function (X, Y) 
      outer(X, Y))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
18)%x%
  list(`package:base` = function (X, Y) 
    kronecker(X, Y), function (X, Y) 
      kronecker(X, Y))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
19)&
  list(`package:base` = .Primitive("&"), .Primitive("&"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
20)&&
  list(`package:base` = .Primitive("&&"), .Primitive("&&"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
21)&.hexmode
list(`package:base` = function (a, b) 
  as.hexmode(bitwAnd(as.hexmode(a), as.hexmode(b))), function (a, b) 
    as.hexmode(bitwAnd(as.hexmode(a), as.hexmode(b))), function (a, b) 
      as.hexmode(bitwAnd(as.hexmode(a), as.hexmode(b))))
c("package:base", "registered S3 method for & from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
22)&.octmode
list(`package:base` = function (a, b) 
  as.octmode(bitwAnd(as.octmode(a), as.octmode(b))), function (a, b) 
    as.octmode(bitwAnd(as.octmode(a), as.octmode(b))), function (a, b) 
      as.octmode(bitwAnd(as.octmode(a), as.octmode(b))))
c("package:base", "registered S3 method for & from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
23)(
list(`package:base` = .Primitive("("), .Primitive("("))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
24)*
  list(`package:base` = .Primitive("*"), .Primitive("*"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
25)*.difftime
list(`package:base` = function (e1, e2) 
{
 if (inherits(e1, "difftime") && inherits(e2, "difftime")) 
   stop("both arguments of * cannot be \"difftime\" objects")
 if (inherits(e2, "difftime")) {
     tmp <- e1
     e1 <- e2
     e2 <- tmp
   }
   .difftime(e2 * unclass(e1), attr(e1, "units"))
 }, function (e1, e2) 
 {
   if (inherits(e1, "difftime") && inherits(e2, "difftime")) 
     stop("both arguments of * cannot be \"difftime\" objects")
   if (inherits(e2, "difftime")) {
     tmp <- e1
     e1 <- e2
      e2 <- tmp
    }
    .difftime(e2 * unclass(e1), attr(e1, "units"))
  }, function (e1, e2) 
  {
    if (inherits(e1, "difftime") && inherits(e2, "difftime")) 
      stop("both arguments of * cannot be \"difftime\" objects")
    if (inherits(e2, "difftime")) {
      tmp <- e1
      e1 <- e2
      e2 <- tmp
    }
    .difftime(e2 * unclass(e1), attr(e1, "units"))
  })
  c("package:base", "registered S3 method for * from namespace base", "namespace:base")
  c(TRUE, FALSE, FALSE)
  c(FALSE, TRUE, TRUE)
26)...elt
  list(`package:base` = .Primitive("...elt"), function (n) 
  {
    .Call(dotsElt, parent.frame(), as.integer(n))
  }, .Primitive("...elt"))
  c("package:base", "namespace:backports", "namespace:base")
  c(TRUE, FALSE, FALSE)
  c(FALSE, FALSE, TRUE)
27)...length
  list(`package:base` = .Primitive("...length"), function () 
  {
    .Call(dotsLength, parent.frame())
  }, .Primitive("...length"))
  c("package:base", "namespace:backports", "namespace:base")
  c(TRUE, FALSE, FALSE)
  c(FALSE, FALSE, TRUE)
28)...names
  list(`package:base` = .Primitive("...names"), function () 
  {
    .Call(dotsNames, parent.frame())
  }, .Primitive("...names"))
  c("package:base", "namespace:backports", "namespace:base")
  c(TRUE, FALSE, FALSE)
  c(FALSE, FALSE, TRUE)
29)..deparseOpts
  list(`package:base` = c("all", "keepInteger", "quoteExpressions", "showAttributes", "useSource", "warnIncomplete", "delayPromises", "keepNA", "S_compatible", "hexNumeric", "digits17", "niceNames", "exact"), c("all", "keepInteger", "quoteExpressions", "showAttributes", "useSource", "warnIncomplete", "delayPromises", "keepNA", "S_compatible", "hexNumeric", "digits17", "niceNames", "exact"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
30)..getNamespace
  list(`package:base` = function (name, where) 
  {
    ns <- .Internal(getRegisteredNamespace(name))
    if (!is.null(ns)) 
      ns
    else tryCatch(loadNamespace(name), error = function(e) {
      tr <- Sys.getenv("_R_NO_REPORT_MISSING_NAMESPACES_")
      if (tr == "false" || (where != "<unknown>" && !nzchar(tr))) {
        warning(gettextf("namespace %s is not available and has been replaced\nby .GlobalEnv when processing object %s", sQuote(name)[1], sQuote(where)), domain = NA, call. = FALSE, immediate. = TRUE)
        if (nzchar(Sys.getenv("_R_CALLS_MISSING_NAMESPACES_"))) 
          print(sys.calls())
      }
      .GlobalEnv
    })
  }, function (name, where) 
  {
    ns <- .Internal(getRegisteredNamespace(name))
    if (!is.null(ns)) 
      ns
    else tryCatch(loadNamespace(name), error = function(e) {
      tr <- Sys.getenv("_R_NO_REPORT_MISSING_NAMESPACES_")
      if (tr == "false" || (where != "<unknown>" && !nzchar(tr))) {
        warning(gettextf("namespace %s is not available and has been replaced\nby .GlobalEnv when processing object %s", sQuote(name)[1], sQuote(where)), domain = NA, call. = FALSE, immediate. = TRUE)
        if (nzchar(Sys.getenv("_R_CALLS_MISSING_NAMESPACES_"))) 
          print(sys.calls())
      }
      .GlobalEnv
    })
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
31).__H__.cbind
  list(`package:base` = function (..., deparse.level = 1) 
  {
    .Deprecated("base::cbind")
    .Internal(cbind(deparse.level, ...))
  }, function (..., deparse.level = 1) 
  {
    .Deprecated("base::cbind")
    .Internal(cbind(deparse.level, ...))
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
32).__H__.rbind
  list(`package:base` = function (..., deparse.level = 1) 
  {
    .Deprecated("base::rbind")
    .Internal(rbind(deparse.level, ...))
  }, function (..., deparse.level = 1) 
  {
    .Deprecated("base::rbind")
    .Internal(rbind(deparse.level, ...))
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
33).__S3MethodsTable__.
  list(`package:base` = <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, 
       <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, 
       <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>, <environment>)
  c("package:base", "namespace:tidyselect", "namespace:reshape2", "namespace:listenv", "namespace:purrr", "namespace:splines", "namespace:lattice", "namespace:colorspace", "namespace:multicolor", "namespace:vctrs", "namespace:generics", "namespace:stats4", "namespace:grDevices", "namespace:chron", "namespace:utf8", "namespace:survival", "namespace:prodlim", "namespace:rlang", "namespace:e1071", "namespace:ModelMetrics", "namespace:pillar", "namespace:glue", "namespace:withr", "namespace:fortunes", 
    "namespace:foreach", "namespace:lifecycle", "namespace:plyr", "namespace:stringr", "namespace:lava", "namespace:timeDate", "namespace:munsell", "namespace:gtable", "namespace:future", "namespace:recipes", "namespace:codetools", "namespace:caret", "namespace:parallel", "namespace:class", "namespace:fansi", "namespace:methods", "namespace:Rcpp", "namespace:backports", "namespace:scales", "namespace:checkmate", "namespace:ipred", "namespace:jsonlite", "namespace:parallelly", "namespace:rmsfact", "namespace:ggplot2", 
    "namespace:stats", "namespace:datasets", "namespace:graphics", "namespace:digest", "namespace:stringi", "namespace:dplyr", "namespace:grid", "namespace:hardhat", "namespace:cli", "namespace:tools", "namespace:magrittr", "namespace:proxy", "namespace:cowsay", "namespace:tibble", "namespace:crayon", "namespace:future.apply", "namespace:pkgconfig", "namespace:ellipsis", "namespace:MASS", "namespace:Matrix", "namespace:data.table", "namespace:utils", "namespace:pROC", "namespace:lubridate", "namespace:gower", 
    "namespace:base", "namespace:iterators", "namespace:R6", "namespace:globals", "namespace:rpart", "namespace:nnet", "namespace:nlme", "namespace:compiler")
  c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)
  c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
    FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)
34).amatch_bounds
  list(`package:base` = function (x = 0.1) 
  {
    if (!is.list(x)) {
      if (!is.numeric(x) || (x < 0)) 
        stop("match distance components must be non-negative")
      bounds <- c(as.double(x), rep.int(NA, 4))
    }
    else {
      table <- c("cost", "insertions", "deletions", "substitutions", "all")
      pos <- pmatch(names(x), table)
      if (anyNA(pos)) {
        warning("unknown match distance components ignored")
        x <- x[!is.na(pos)]
      }
      names(x) <- table[pos]
      x <- unlist(x)
      if (!all(is.numeric(x)) || any(x < 0)) 
        stop("match distance components must be non-negative")
      if (!is.na(x["cost"])) {
        bounds <- rep.int(NA, 5)
      }
      else {
        if (is.na(x["all"])) 
          x["all"] <- 0.1
        bounds <- c(NA, rep.int(x["all"], 4))
      }
      names(bounds) <- table
      bounds[names(x)] <- x
    }
    bounds
  }, function (x = 0.1) 
  {
    if (!is.list(x)) {
      if (!is.numeric(x) || (x < 0)) 
        stop("match distance components must be non-negative")
      bounds <- c(as.double(x), rep.int(NA, 4))
    }
    else {
      table <- c("cost", "insertions", "deletions", "substitutions", "all")
      pos <- pmatch(names(x), table)
      if (anyNA(pos)) {
        warning("unknown match distance components ignored")
        x <- x[!is.na(pos)]
      }
      names(x) <- table[pos]
      x <- unlist(x)
      if (!all(is.numeric(x)) || any(x < 0)) 
        stop("match distance components must be non-negative")
      if (!is.na(x["cost"])) {
        bounds <- rep.int(NA, 5)
      }
      else {
        if (is.na(x["all"])) 
          x["all"] <- 0.1
        bounds <- c(NA, rep.int(x["all"], 4))
      }
      names(bounds) <- table
      bounds[names(x)] <- x
    }
    bounds
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
35).amatch_costs
  list(`package:base` = function (x = NULL) 
  {
    costs <- c(insertions = 1, deletions = 1, substitutions = 1)
    if (!is.null(x)) {
      x <- as.list(x)
      pos <- pmatch(names(x), names(costs))
      if (anyNA(pos)) {
        warning("unknown cost components ignored")
        x <- x[!is.na(pos)]
      }
      x <- unlist(x)
      if (!all(is.numeric(x)) || any(x < 0)) 
        stop("cost components must be non-negative")
      costs[pos] <- x
    }
    costs
  }, function (x = NULL) 
  {
    costs <- c(insertions = 1, deletions = 1, substitutions = 1)
    if (!is.null(x)) {
      x <- as.list(x)
      pos <- pmatch(names(x), names(costs))
      if (anyNA(pos)) {
        warning("unknown cost components ignored")
        x <- x[!is.na(pos)]
      }
      x <- unlist(x)
      if (!all(is.numeric(x)) || any(x < 0)) 
        stop("cost components must be non-negative")
      costs[pos] <- x
    }
    costs
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
36).ArgsEnv
  list(`package:base` = <environment>, <environment>)
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
37).AutoloadEnv
  list(`package:base` = <environment>, <environment>)
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
38).BaseNamespaceEnv
  list(`package:base` = <environment>, <environment>)
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
39).bincode
  list(`package:base` = function (x, breaks, right = TRUE, include.lowest = FALSE) 
    .Internal(bincode(x, breaks, right, include.lowest)), function (x, breaks, right = TRUE, include.lowest = FALSE) 
      .Internal(bincode(x, breaks, right, include.lowest)))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
40).C
  list(`package:base` = .Primitive(".C"), .Primitive(".C"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
41).C_R_addTaskCallback
  list(`package:base` = list(name = "R_addTaskCallback", address = <pointer: 0x00000278d31165c0>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 4), list(name = "R_addTaskCallback", address = <pointer: 0x00000278d31165c0>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 4))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
42).C_R_getTaskCallbackNames
  list(`package:base` = list(name = "R_getTaskCallbackNames", address = <pointer: 0x00000278d3116600>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 0), list(name = "R_getTaskCallbackNames", address = <pointer: 0x00000278d3116600>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 0))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
43).C_R_removeTaskCallback
  list(`package:base` = list(name = "R_removeTaskCallback", address = <pointer: 0x00000278d31166a0>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 1), list(name = "R_removeTaskCallback", address = <pointer: 0x00000278d31166a0>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 1))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
44).cache_class
  list(`package:base` = .Primitive(".cache_class"), .Primitive(".cache_class"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
45).Call
  list(`package:base` = .Primitive(".Call"), .Primitive(".Call"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
  .Call.graphics
  list(`package:base` = .Primitive(".Call.graphics"), .Primitive(".Call.graphics"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
46).class2
  list(`package:base` = .Primitive(".class2"), .Primitive(".class2"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
47).col
  list(`package:base` = function (dim) 
    .Internal(col(dim)), function (dim) 
      .Internal(col(dim)))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
48).colMeans
  list(`package:base` = function (x, m, n, na.rm = FALSE) 
    .Internal(colMeans(x, m, n, na.rm)), function (x, m, n, na.rm = FALSE) 
      .Internal(colMeans(x, m, n, na.rm)))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
49).colSums
  list(`package:base` = function (x, m, n, na.rm = FALSE) 
    .Internal(colSums(x, m, n, na.rm)), function (x, m, n, na.rm = FALSE) 
      .Internal(colSums(x, m, n, na.rm)))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
50).Date
  list(`package:base` = function (xx, cl = "Date") 
    `class<-`(xx, cl), function (xx, cl = "Date") 
      `class<-`(xx, cl))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
51).decode_numeric_version
  list(`package:base` = function (x) 
  {
    width <- attr(x, "width")
    y <- Map(function(elt, len) {
      if (is.na(elt)) 
        return(integer())
      first <- seq(from = 1, length.out = len, by = width)
      last <- seq(from = width, length.out = len, by = width)
      strtoi(substring(elt, first, last), 8)
    }, x, attr(x, "lens"))
    names(y) <- names(x)
    class(y) <- unique(c(attr(x, ".classes"), "numeric_version"))
    y
  }, function (x) 
  {
    width <- attr(x, "width")
    y <- Map(function(elt, len) {
      if (is.na(elt)) 
        return(integer())
      first <- seq(from = 1, length.out = len, by = width)
      last <- seq(from = width, length.out = len, by = width)
      strtoi(substring(elt, first, last), 8)
    }, x, attr(x, "lens"))
    names(y) <- names(x)
    class(y) <- unique(c(attr(x, ".classes"), "numeric_version"))
    y
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
52).Defunct
  list(`package:base` = function (new, package = NULL, msg) 
  {
    fname <- as.character(sys.call(sys.parent())[[1]])
    if (missing(msg)) {
      msg <- gettextf("'%s' is defunct.\n", fname[length(fname)])
      if (!missing(new)) 
        msg <- c(msg, gettextf("Use '%s' instead.\n", new))
      msg <- c(msg, if (!is.null(package)) gettextf("See help(\"Defunct\") and help(\"%s-defunct\").", package) else gettext("See help(\"Defunct\")"))
    }
    else msg <- as.character(msg)
    msg <- paste(msg, collapse = "")
    if (missing(new)) 
      new <- NULL
    stop(errorCondition(msg, old = fname, new = new, package = package, class = "defunctError"))
  }, function (new, package = NULL, msg) 
  {
    fname <- as.character(sys.call(sys.parent())[[1]])
    if (missing(msg)) {
      msg <- gettextf("'%s' is defunct.\n", fname[length(fname)])
      if (!missing(new)) 
        msg <- c(msg, gettextf("Use '%s' instead.\n", new))
      msg <- c(msg, if (!is.null(package)) gettextf("See help(\"Defunct\") and help(\"%s-defunct\").", package) else gettext("See help(\"Defunct\")"))
    }
    else msg <- as.character(msg)
    msg <- paste(msg, collapse = "")
    if (missing(new)) 
      new <- NULL
    stop(errorCondition(msg, old = fname, new = new, package = package, class = "defunctError"))
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
53).deparseOpts
  list(`package:base` = function (control) 
  {
    if (!length(control)) 
      return(0)
    opts <- pmatch(as.character(control), ..deparseOpts)
    if (anyNA(opts)) 
      stop(sprintf(ngettext(as.integer(sum(is.na(opts))), "deparse option %s is not recognized", "deparse options %s are not recognized"), paste(sQuote(control[is.na(opts)]), collapse = ", ")), call. = FALSE, domain = NA)
    if (any(opts == 1)) {
      if (any(opts == 13)) 
        stop("\"all\" and \"exact\" are mutually exclusive")
      opts <- unique(c(opts[opts != 1], 2:6, 8, if (!any(opts == 10)) 11, 12))
    }
    else if (any(opts == 13)) {
      opts <- unique(c(opts[opts != 13], 2:6, 8, 10, 12))
    }
    if (10 %in% opts && 11 %in% opts) 
      stop("\"hexNumeric\" and \"digits17\" are mutually exclusive")
    sum(2^(opts - 2))
  }, function (control) 
  {
    if (!length(control)) 
      return(0)
    opts <- pmatch(as.character(control), ..deparseOpts)
    if (anyNA(opts)) 
      stop(sprintf(ngettext(as.integer(sum(is.na(opts))), "deparse option %s is not recognized", "deparse options %s are not recognized"), paste(sQuote(control[is.na(opts)]), collapse = ", ")), call. = FALSE, domain = NA)
    if (any(opts == 1)) {
      if (any(opts == 13)) 
        stop("\"all\" and \"exact\" are mutually exclusive")
      opts <- unique(c(opts[opts != 1], 2:6, 8, if (!any(opts == 10)) 11, 12))
    }
    else if (any(opts == 13)) {
      opts <- unique(c(opts[opts != 13], 2:6, 8, 10, 12))
    }
    if (10 %in% opts && 11 %in% opts) 
      stop("\"hexNumeric\" and \"digits17\" are mutually exclusive")
    sum(2^(opts - 2))
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
54).Deprecated
  list(`package:base` = function (new, package = NULL, msg, old = as.character(sys.call(sys.parent()))[1]) 
  {
    msg <- if (missing(msg)) {
      msg <- gettextf("'%s' is deprecated.\n", old)
      if (!missing(new)) 
        msg <- c(msg, gettextf("Use '%s' instead.\n", new))
      c(msg, if (!is.null(package)) gettextf("See help(\"Deprecated\") and help(\"%s-deprecated\").", package) else gettext("See help(\"Deprecated\")"))
    }
    else as.character(msg)
    msg <- paste(msg, collapse = "")
    if (missing(new)) 
      new <- NULL
    warning(warningCondition(msg, old = old, new = new, package = package, class = "deprecatedWarning"))
  }, function (new, package = NULL, msg, old = as.character(sys.call(sys.parent()))[1]) 
  {
    msg <- if (missing(msg)) {
      msg <- gettextf("'%s' is deprecated.\n", old)
      if (!missing(new)) 
        msg <- c(msg, gettextf("Use '%s' instead.\n", new))
      c(msg, if (!is.null(package)) gettextf("See help(\"Deprecated\") and help(\"%s-deprecated\").", package) else gettext("See help(\"Deprecated\")"))
    }
    else as.character(msg)
    msg <- paste(msg, collapse = "")
    if (missing(new)) 
      new <- NULL
    warning(warningCondition(msg, old = old, new = new, package = package, class = "deprecatedWarning"))
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
55).detach
  list(`package:base` = function (pos) 
    .Internal(detach(pos)), function (pos) 
      .Internal(detach(pos)))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
56).Device
  list(`package:base` = "null device", "null device")
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
57).Devices
  list(`package:base` = pairlist("null device"), pairlist("null device"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
58).difftime
  list(`package:base` = function (xx, units, cl = "difftime") 
  {
    class(xx) <- cl
    attr(xx, "units") <- units
    xx
  }, function (xx, units, cl = "difftime") 
  {
    class(xx) <- cl
    attr(xx, "units") <- units
    xx
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
59).doSortWrap
  list(`package:base` = function (vec, decr, nalast, noNA = NA) 
  {
    if (length(vec) > 0 && is.numeric(vec)) {
      sorted <- .makeSortEnum(decr, nalast)
      if (is.na(noNA)) {
        if (is.na(nalast)) 
          noNA <- TRUE
        else if (nalast) 
          noNA <- !is.na(vec[length(vec)])
        else noNA <- !is.na(vec[1])
      }
      .Internal(wrap_meta(vec, sorted, noNA))
    }
    else vec
  }, function (vec, decr, nalast, noNA = NA) 
  {
    if (length(vec) > 0 && is.numeric(vec)) {
      sorted <- .makeSortEnum(decr, nalast)
      if (is.na(noNA)) {
        if (is.na(nalast)) 
          noNA <- TRUE
        else if (nalast) 
          noNA <- !is.na(vec[length(vec)])
        else noNA <- !is.na(vec[1])
      }
      .Internal(wrap_meta(vec, sorted, noNA))
    }
    else vec
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
60).doTrace
  list(`package:base` = function (expr, msg) 
  {
    on <- tracingState(FALSE)
    if (on) {
      on.exit(tracingState(TRUE))
      if (!missing(msg)) {
        call <- deparse(sys.call(sys.parent(1)))
        if (length(call) > 1) 
          call <- paste(call[[1]], "....")
        cat("Tracing", call, msg, "\n")
      }
      exprObj <- substitute(expr)
      eval.parent(exprObj)
    }
    NULL
  }, function (expr, msg) 
  {
    on <- tracingState(FALSE)
    if (on) {
      on.exit(tracingState(TRUE))
      if (!missing(msg)) {
        call <- deparse(sys.call(sys.parent(1)))
        if (length(call) > 1) 
          call <- paste(call[[1]], "....")
        cat("Tracing", call, msg, "\n")
      }
      exprObj <- substitute(expr)
      eval.parent(exprObj)
    }
    NULL
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
61).doWrap
  list(`package:base` = function (vec, decr, nalast, noNA = NA) 
  {
    if (length(vec) > 0 && is.numeric(vec)) {
      sorted <- .makeSortEnum(decr, nalast)
      if (is.na(noNA)) {
        if (is.na(nalast)) 
          noNA <- TRUE
        else if (nalast) 
          noNA <- !is.na(vec[length(vec)])
        else noNA <- !is.na(vec[1])
      }
      .Internal(wrap_meta(vec, sorted, noNA))
    }
    else vec
  }, function (vec, decr, nalast, noNA = NA) 
  {
    if (length(vec) > 0 && is.numeric(vec)) {
      sorted <- .makeSortEnum(decr, nalast)
      if (is.na(noNA)) {
        if (is.na(nalast)) 
          noNA <- TRUE
        else if (nalast) 
          noNA <- !is.na(vec[length(vec)])
        else noNA <- !is.na(vec[1])
      }
      .Internal(wrap_meta(vec, sorted, noNA))
    }
    else vec
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
62).dynLibs
  list(`package:base` = function (new) 
  {
    if (!missing(new)) {
      class(new) <- "DLLInfoList"
      .Dyn.libs <<- new
    }
    else .Dyn.libs
  }, function (new) 
  {
    if (!missing(new)) {
      class(new) <- "DLLInfoList"
      .Dyn.libs <<- new
    }
    else .Dyn.libs
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
63).encode_numeric_version
  list(`package:base` = function (x) 
  {
    strlpad <- function(x, char, width) paste0(strrep(char, width - nchar(x)), x)
    strrpad <- function(x, char, width) paste0(x, strrep(char, width - nchar(x)))
    if (!is.numeric_version(x)) 
      stop("wrong class")
    classes <- class(x)
    nms <- names(x)
    x <- unclass(x)
    lens <- vapply(x, length, 0)
    y <- lapply(x, function(e) sprintf("%o", e))
    width <- max(nchar(unlist(y)), 0)
    y <- vapply(y, function(e) paste(strlpad(e, "0", width), collapse = ""), "")
    y <- strrpad(y, "0", max(nchar(y), 0))
    structure(ifelse(lens > 0, y, NA), width = width, lens = lens, .classes = classes, names = nms)
  }, function (x) 
  {
    strlpad <- function(x, char, width) paste0(strrep(char, width - nchar(x)), x)
    strrpad <- function(x, char, width) paste0(x, strrep(char, width - nchar(x)))
    if (!is.numeric_version(x)) 
      stop("wrong class")
    classes <- class(x)
    nms <- names(x)
    x <- unclass(x)
    lens <- vapply(x, length, 0)
    y <- lapply(x, function(e) sprintf("%o", e))
    width <- max(nchar(unlist(y)), 0)
    y <- vapply(y, function(e) paste(strlpad(e, "0", width), collapse = ""), "")
    y <- strrpad(y, "0", max(nchar(y), 0))
    structure(ifelse(lens > 0, y, NA), width = width, lens = lens, .classes = classes, names = nms)
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
64).expand_R_libs_env_var
  list(`package:base` = function (x) 
  {
    v <- paste(R.version[c("major", "minor")], collapse = ".")
    s <- Sys.info()
    R_LIBS_USER_default <- function() {
      home <- normalizePath("~")
      x.y <- paste0(R.version$major, ".", sub("[.].*", "", R.version$minor))
      if (.Platform$OS.type == "windows") 
        file.path(Sys.getenv("LOCALAPPDATA"), "R", "win-library", x.y)
      else if (s["sysname"] == "Darwin") 
        file.path(home, "Library", "R", s["machine"], x.y, "library")
      else file.path(home, "R", paste0(R.version$platform, "-library"), x.y)
    }
    R_LIBS_SITE_default <- file.path(R.home(), "site-library")
    expand <- function(x, spec, expansion) {
      replace <- sprintf("\\1\\2%s", gsub("([\\])", "\\\\\\1", expansion))
      gsub(paste0("(^|[^%])(%%)*%", spec), replace, x)
    }
    x <- expand(x, "V", v)
    x <- expand(x, "v", sub("\\.[^.]*$", "", v))
    x <- expand(x, "p", R.version$platform)
    x <- expand(x, "a", R.version$arch)
    x <- expand(x, "o", R.version$os)
    x <- expand(x, "U", R_LIBS_USER_default())
    x <- expand(x, "S", R_LIBS_SITE_default)
    gsub("%%", "%", x, fixed = TRUE)
  }, function (x) 
  {
    v <- paste(R.version[c("major", "minor")], collapse = ".")
    s <- Sys.info()
    R_LIBS_USER_default <- function() {
      home <- normalizePath("~")
      x.y <- paste0(R.version$major, ".", sub("[.].*", "", R.version$minor))
      if (.Platform$OS.type == "windows") 
        file.path(Sys.getenv("LOCALAPPDATA"), "R", "win-library", x.y)
      else if (s["sysname"] == "Darwin") 
        file.path(home, "Library", "R", s["machine"], x.y, "library")
      else file.path(home, "R", paste0(R.version$platform, "-library"), x.y)
    }
    R_LIBS_SITE_default <- file.path(R.home(), "site-library")
    expand <- function(x, spec, expansion) {
      replace <- sprintf("\\1\\2%s", gsub("([\\])", "\\\\\\1", expansion))
      gsub(paste0("(^|[^%])(%%)*%", spec), replace, x)
    }
    x <- expand(x, "V", v)
    x <- expand(x, "v", sub("\\.[^.]*$", "", v))
    x <- expand(x, "p", R.version$platform)
    x <- expand(x, "a", R.version$arch)
    x <- expand(x, "o", R.version$os)
    x <- expand(x, "U", R_LIBS_USER_default())
    x <- expand(x, "S", R_LIBS_SITE_default)
    gsub("%%", "%", x, fixed = TRUE)
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
65).External
  list(`package:base` = .Primitive(".External"), .Primitive(".External"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
66).External.graphics
  list(`package:base` = .Primitive(".External.graphics"), .Primitive(".External.graphics"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
67).External2
  list(`package:base` = .Primitive(".External2"), .Primitive(".External2"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
68).F_dchdc
  list(`package:base` = NULL, NULL)
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
69).F_dqrcf
  list(`package:base` = list(name = "dqrcf", address = <pointer: 0x00000278d31166c0>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 8), list(name = "dqrcf", address = <pointer: 0x00000278d31166c0>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 8))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
70).F_dqrdc2
  list(`package:base` = list(name = "dqrdc2", address = <pointer: 0x00000278d3168580>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 9), list(name = "dqrdc2", address = <pointer: 0x00000278d3168580>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 9))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
71).F_dqrqty
  list(`package:base` = list(name = "dqrqty", address = <pointer: 0x00000278d3168400>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 7), list(name = "dqrqty", address = <pointer: 0x00000278d3168400>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 7))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
72).F_dqrqy
  list(`package:base` = list(name = "dqrqy", address = <pointer: 0x00000278d3168300>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 7), list(name = "dqrqy", address = <pointer: 0x00000278d3168300>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 7))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
73).F_dqrrsd
  list(`package:base` = list(name = "dqrrsd", address = <pointer: 0x00000278d3168680>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 7), list(name = "dqrrsd", address = <pointer: 0x00000278d3168680>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 7))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
74).F_dqrxb
  list(`package:base` = list(name = "dqrxb", address = <pointer: 0x00000278d3168360>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 7), list(name = "dqrxb", address = <pointer: 0x00000278d3168360>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 7))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
75).F_dtrco
  list(`package:base` = list(name = "dtrco", address = <pointer: 0x00000278d3168380>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 6), list(name = "dtrco", address = <pointer: 0x00000278d3168380>, dll = list(name = "base", path = "base", dynamicLookup = FALSE, handle = <pointer: (nil)>, info = <pointer: 0x00000278d3136100>), numParameters = 6))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
76).First.sys
  list(`package:base` = function () 
  {
    for (pkg in getOption("defaultPackages")) {
      res <- require(pkg, quietly = TRUE, warn.conflicts = FALSE, character.only = TRUE)
      if (!res) 
        warning(gettextf("package %s in options(\"defaultPackages\") was not found", sQuote(pkg)), call. = FALSE, domain = NA)
    }
  }, function () 
  {
    for (pkg in getOption("defaultPackages")) {
      res <- require(pkg, quietly = TRUE, warn.conflicts = FALSE, character.only = TRUE)
      if (!res) 
        warning(gettextf("package %s in options(\"defaultPackages\") was not found", sQuote(pkg)), call. = FALSE, domain = NA)
    }
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
77).fixupGFortranStderr
  list(`package:base` = function () 
  {
    old <- Sys.getenv("GFORTRAN_STDERR_UNIT")
    if (nzchar(old) && old == "-1") {
      Sys.unsetenv("GFORTRAN_STDERR_UNIT")
      TRUE
    }
    else FALSE
  }, function () 
  {
    old <- Sys.getenv("GFORTRAN_STDERR_UNIT")
    if (nzchar(old) && old == "-1") {
      Sys.unsetenv("GFORTRAN_STDERR_UNIT")
      TRUE
    }
    else FALSE
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
78).fixupGFortranStdout
  list(`package:base` = function () 
  {
    old <- Sys.getenv("GFORTRAN_STDOUT_UNIT")
    if (nzchar(old) && old == "-1") {
      Sys.unsetenv("GFORTRAN_STDOUT_UNIT")
      TRUE
    }
    else FALSE
  }, function () 
  {
    old <- Sys.getenv("GFORTRAN_STDOUT_UNIT")
    if (nzchar(old) && old == "-1") {
      Sys.unsetenv("GFORTRAN_STDOUT_UNIT")
      TRUE
    }
    else FALSE
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
79).format.zeros
  list(`package:base` = function (x, zero.print, nx = suppressWarnings(as.numeric(x)), replace = FALSE, warn.non.fitting = TRUE) 
  {
    if (!is.null(zero.print) && any(i0 <- nx == 0 & !is.na(nx))) {
      if (length(zero.print) > 1) 
        stop("'zero.print' has length > 1")
      if (is.logical(zero.print)) 
        zero.print <- if (zero.print) 
          "0"
      else " "
      if (!is.character(zero.print)) 
        stop("'zero.print' must be character, logical or NULL")
      nz <- nchar(zero.print, "c")
      nc <- nchar(x[i0], "c")
      ind0 <- as.vector(regexpr("0", x[i0], fixed = TRUE))
      if (replace) {
        x[i0] <- zero.print
      }
      else {
        if (any(nc < nz) && warn.non.fitting) 
          warning("'zero.print' is truncated to fit into formatted zeros; consider 'replace=TRUE'")
        i2 <- pmin(nc, nz - 1 + ind0)
        i1 <- pmax(1, i2 - nz + 1)
        substr(x[i0], i1, i2) <- zero.print
        if (any(P <- nc > i2)) 
          substr(x[i0][P], i2[P] + 1, nc[P]) <- strrep(" ", (nc - i2)[P])
      }
    }
    x
  }, function (x, zero.print, nx = suppressWarnings(as.numeric(x)), replace = FALSE, warn.non.fitting = TRUE) 
  {
    if (!is.null(zero.print) && any(i0 <- nx == 0 & !is.na(nx))) {
      if (length(zero.print) > 1) 
        stop("'zero.print' has length > 1")
      if (is.logical(zero.print)) 
        zero.print <- if (zero.print) 
          "0"
      else " "
      if (!is.character(zero.print)) 
        stop("'zero.print' must be character, logical or NULL")
      nz <- nchar(zero.print, "c")
      nc <- nchar(x[i0], "c")
      ind0 <- as.vector(regexpr("0", x[i0], fixed = TRUE))
      if (replace) {
        x[i0] <- zero.print
      }
      else {
        if (any(nc < nz) && warn.non.fitting) 
          warning("'zero.print' is truncated to fit into formatted zeros; consider 'replace=TRUE'")
        i2 <- pmin(nc, nz - 1 + ind0)
        i1 <- pmax(1, i2 - nz + 1)
        substr(x[i0], i1, i2) <- zero.print
        if (any(P <- nc > i2)) 
          substr(x[i0][P], i2[P] + 1, nc[P]) <- strrep(" ", (nc - i2)[P])
      }
    }
    x
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
80).Fortran
  list(`package:base` = .Primitive(".Fortran"), .Primitive(".Fortran"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
81).GenericArgsEnv
  list(`package:base` = <environment>, <environment>)
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
82).getNamespace
  list(`package:base` = function (name) 
    .Internal(getRegisteredNamespace(name)), function (name) 
      .Internal(getRegisteredNamespace(name)))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
83).getNamespaceInfo
  list(`package:base` = function (ns, which) 
  {
    ns[[".__NAMESPACE__."]][[which]]
  }, function (ns, which) 
  {
    ns[[".__NAMESPACE__."]][[which]]
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
84).getRequiredPackages
  list(`package:base` = function (file = "DESCRIPTION", lib.loc = NULL, quietly = FALSE, useImports = FALSE) 
  {
    pkgInfo <- tools:::.split_description(tools:::.read_description(file))
    .getRequiredPackages2(pkgInfo, quietly, lib.loc, useImports)
    invisible()
  }, function (file = "DESCRIPTION", lib.loc = NULL, quietly = FALSE, useImports = FALSE) 
  {
    pkgInfo <- tools:::.split_description(tools:::.read_description(file))
    .getRequiredPackages2(pkgInfo, quietly, lib.loc, useImports)
    invisible()
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
85).getRequiredPackages2
  list(`package:base` = function (pkgInfo, quietly = FALSE, lib.loc = NULL, useImports = FALSE) 
  {
    .findVersion <- function(pkg, lib.loc) {
      pfile <- system.file("Meta", "package.rds", package = pkg, lib.loc = lib.loc)
      if (nzchar(pfile)) 
        as.numeric_version(readRDS(pfile)$DESCRIPTION["Version"])
    }
    pkgs <- unique(names(pkgInfo$Depends))
    pkgname <- pkgInfo$DESCRIPTION["Package"]
    for (pkg in setdiff(pkgs, "base")) {
      depends <- pkgInfo$Depends[names(pkgInfo$Depends) == pkg]
      attached <- paste0("package:", pkg) %in% search()
      current <- .findVersion(pkg, lib.loc)
      if (is.null(current)) 
        stop(gettextf("package %s required by %s could not be found", sQuote(pkg), sQuote(pkgname)), call. = FALSE, domain = NA)
      have_vers <- lengths(depends) > 1
      for (dep in depends[have_vers]) {
        target <- as.numeric_version(dep$version)
        sufficient <- do.call(dep$op, list(current, target))
        if (!sufficient) {
          if (is.null(lib.loc)) 
            lib.loc <- .libPaths()
          allV <- lapply(lib.loc, .findVersion, pkg = pkg)
          versions <- do.call(c, allV[iV <- which(!vapply(allV, is.null, NA))])
          sufficient <- vapply(versions, dep$op, logical(1), target)
          if (any(sufficient)) {
            warning(gettextf("version %s of %s masked by %s in %s", versions[which(sufficient)[1]], sQuote(pkg), current, lib.loc[iV[!sufficient][1]]), call. = FALSE, domain = NA)
          }
          msg <- if (attached) 
            "package %s %s is loaded, but %s %s is required by %s"
          else "package %s %s was found, but %s %s is required by %s"
          stop(gettextf(msg, sQuote(pkg), current, dep$op, target, sQuote(pkgname)), call. = FALSE, domain = NA)
        }
      }
      if (!attached) {
        if (!quietly) 
          packageStartupMessage(gettextf("Loading required package: %s", pkg), domain = NA)
        library(pkg, character.only = TRUE, logical.return = TRUE, lib.loc = lib.loc, quietly = quietly) || stop(gettextf("package %s could not be loaded", sQuote(pkg)), call. = FALSE, domain = NA)
      }
    }
    if (useImports) {
      nss <- names(pkgInfo$Imports)
      for (ns in nss) loadNamespace(ns, lib.loc)
    }
  }, function (pkgInfo, quietly = FALSE, lib.loc = NULL, useImports = FALSE) 
  {
    .findVersion <- function(pkg, lib.loc) {
      pfile <- system.file("Meta", "package.rds", package = pkg, lib.loc = lib.loc)
      if (nzchar(pfile)) 
        as.numeric_version(readRDS(pfile)$DESCRIPTION["Version"])
    }
    pkgs <- unique(names(pkgInfo$Depends))
    pkgname <- pkgInfo$DESCRIPTION["Package"]
    for (pkg in setdiff(pkgs, "base")) {
      depends <- pkgInfo$Depends[names(pkgInfo$Depends) == pkg]
      attached <- paste0("package:", pkg) %in% search()
      current <- .findVersion(pkg, lib.loc)
      if (is.null(current)) 
        stop(gettextf("package %s required by %s could not be found", sQuote(pkg), sQuote(pkgname)), call. = FALSE, domain = NA)
      have_vers <- lengths(depends) > 1
      for (dep in depends[have_vers]) {
        target <- as.numeric_version(dep$version)
        sufficient <- do.call(dep$op, list(current, target))
        if (!sufficient) {
          if (is.null(lib.loc)) 
            lib.loc <- .libPaths()
          allV <- lapply(lib.loc, .findVersion, pkg = pkg)
          versions <- do.call(c, allV[iV <- which(!vapply(allV, is.null, NA))])
          sufficient <- vapply(versions, dep$op, logical(1), target)
          if (any(sufficient)) {
            warning(gettextf("version %s of %s masked by %s in %s", versions[which(sufficient)[1]], sQuote(pkg), current, lib.loc[iV[!sufficient][1]]), call. = FALSE, domain = NA)
          }
          msg <- if (attached) 
            "package %s %s is loaded, but %s %s is required by %s"
          else "package %s %s was found, but %s %s is required by %s"
          stop(gettextf(msg, sQuote(pkg), current, dep$op, target, sQuote(pkgname)), call. = FALSE, domain = NA)
        }
      }
      if (!attached) {
        if (!quietly) 
          packageStartupMessage(gettextf("Loading required package: %s", pkg), domain = NA)
        library(pkg, character.only = TRUE, logical.return = TRUE, lib.loc = lib.loc, quietly = quietly) || stop(gettextf("package %s could not be loaded", sQuote(pkg)), call. = FALSE, domain = NA)
      }
    }
    if (useImports) {
      nss <- names(pkgInfo$Imports)
      for (ns in nss) loadNamespace(ns, lib.loc)
    }
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
86)).GlobalEnv
  list(`package:base` = <environment>, <environment>)
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
87).gt
  list(`package:base` = function (x, i, j) 
  {
    xi <- x[i]
    xj <- x[j]
    if (xi == xj) 
      0
    else if (xi > xj) 
      1
    else -1
  }, function (x, i, j) 
  {
    xi <- x[i]
    xj <- x[j]
    if (xi == xj) 
      0
    else if (xi > xj) 
      1
    else -1
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
88).gtn
  list(`package:base` = function (x, strictly) 
  {
    n <- length(x)
    if (strictly) 
      !all(x[-1] > x[-n])
    else !all(x[-1] >= x[-n])
  }, function (x, strictly) 
  {
    n <- length(x)
    if (strictly) 
      !all(x[-1] > x[-n])
    else !all(x[-1] >= x[-n])
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
89).handleSimpleError
  list(`package:base` = function (h, msg, call) 
    h(simpleError(msg, call)), function (h, msg, call) 
      h(simpleError(msg, call)))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
90).Internal
  list(`package:base` = .Primitive(".Internal"), .Primitive(".Internal"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
91).isMethodsDispatchOn
  list(`package:base` = .Primitive(".isMethodsDispatchOn"), .Primitive(".isMethodsDispatchOn"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
92).isOpen
  list(`package:base` = function (srcfile) 
  {
    conn <- srcfile$conn
    return(!is.null(conn) && isOpen(conn))
  }, function (srcfile) 
  {
    conn <- srcfile$conn
    return(!is.null(conn) && isOpen(conn))
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
93).kappa_tri
  list(`package:base` = function (z, exact = FALSE, LINPACK = TRUE, norm = NULL, ...) 
  {
    if (exact) {
      stopifnot(is.null(norm) || identical("2", norm))
      kappa.default(z, exact = TRUE)
    }
    else {
      p <- as.integer(nrow(z))
      if (is.na(p)) 
        stop("invalid nrow(x)")
      if (p != ncol(z)) 
        stop("triangular matrix should be square")
      if (is.null(norm)) 
        norm <- "1"
      if (is.complex(z)) 
        1/.Internal(La_ztrcon(z, norm))
      else if (LINPACK) {
        if (norm == "I") 
          z <- t(z)
        storage.mode(z) <- "double"
        1/.Fortran(.F_dtrco, z, p, p, k = double(1), double(p), 1)$k
      }
      else 1/.Internal(La_dtrcon(z, norm))
    }
  }, function (z, exact = FALSE, LINPACK = TRUE, norm = NULL, ...) 
  {
    if (exact) {
      stopifnot(is.null(norm) || identical("2", norm))
      kappa.default(z, exact = TRUE)
    }
    else {
      p <- as.integer(nrow(z))
      if (is.na(p)) 
        stop("invalid nrow(x)")
      if (p != ncol(z)) 
        stop("triangular matrix should be square")
      if (is.null(norm)) 
        norm <- "1"
      if (is.complex(z)) 
        1/.Internal(La_ztrcon(z, norm))
      else if (LINPACK) {
        if (norm == "I") 
          z <- t(z)
        storage.mode(z) <- "double"
        1/.Fortran(.F_dtrco, z, p, p, k = double(1), double(p), 1)$k
      }
      else 1/.Internal(La_dtrcon(z, norm))
    }
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
94).knownS3Generics
  list(`package:base` = c(Math = "base", Ops = "base", Summary = "base", Complex = "base", as.character = "base", as.data.frame = "base", as.environment = "base", as.matrix = "base", as.vector = "base", cbind = "base", labels = "base", print = "base", rbind = "base", rep = "base", seq = "base", seq.int = "base", plot = "base", sequence = "base", solve = "base", summary = "base", t = "base", edit = "utils", str = "utils", contour = "graphics", hist = "graphics", identify = "graphics", image = "graphics", 
                          lines = "graphics", pairs = "graphics", points = "graphics", text = "graphics", add1 = "stats", AIC = "stats", anova = "stats", biplot = "stats", coef = "stats", confint = "stats", deviance = "stats", df.residual = "stats", drop1 = "stats", extractAIC = "stats", fitted = "stats", formula = "stats", logLik = "stats", model.frame = "stats", model.matrix = "stats", predict = "stats", profile = "stats", qqnorm = "stats", residuals = "stats", se.contrast = "stats", terms = "stats", update = "stats", vcov = "stats"
  ), c(Math = "base", Ops = "base", Summary = "base", Complex = "base", as.character = "base", as.data.frame = "base", as.environment = "base", as.matrix = "base", as.vector = "base", cbind = "base", labels = "base", print = "base", rbind = "base", rep = "base", seq = "base", seq.int = "base", plot = "base", sequence = "base", solve = "base", summary = "base", t = "base", edit = "utils", str = "utils", contour = "graphics", hist = "graphics", identify = "graphics", image = "graphics", lines = "graphics", 
       pairs = "graphics", points = "graphics", text = "graphics", add1 = "stats", AIC = "stats", anova = "stats", biplot = "stats", coef = "stats", confint = "stats", deviance = "stats", df.residual = "stats", drop1 = "stats", extractAIC = "stats", fitted = "stats", formula = "stats", logLik = "stats", model.frame = "stats", model.matrix = "stats", predict = "stats", profile = "stats", qqnorm = "stats", residuals = "stats", se.contrast = "stats", terms = "stats", update = "stats", vcov = "stats"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
95).kronecker
  list(`package:base` = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    X <- as.array(X)
    Y <- as.array(Y)
    if (make.dimnames) {
      dnx <- dimnames(X)
      dny <- dimnames(Y)
    }
    dX <- dim(X)
    dY <- dim(Y)
    ld <- length(dX) - length(dY)
    if (ld < 0) 
      dX <- dim(X) <- c(dX, rep.int(1, -ld))
    else if (ld > 0) 
      dY <- dim(Y) <- c(dY, rep.int(1, ld))
    opobj <- outer(X, Y, FUN, ...)
    dp <- as.vector(t(matrix(1:(2 * length(dX)), ncol = 2)[, 2:1]))
    opobj <- aperm(opobj, dp)
    dim(opobj) <- dX * dY
    if (make.dimnames && !(is.null(dnx) && is.null(dny))) {
      if (is.null(dnx)) 
        dnx <- vector("list", length(dX))
      else if (ld < 0) 
        dnx <- c(dnx, vector("list", -ld))
      tmp <- which(sapply(dnx, is.null))
      dnx[tmp] <- lapply(tmp, function(i) rep.int("", dX[i]))
      if (is.null(dny)) 
        dny <- vector("list", length(dY))
      else if (ld > 0) 
        dny <- c(dny, vector("list", ld))
      tmp <- which(sapply(dny, is.null))
      dny[tmp] <- lapply(tmp, function(i) rep.int("", dY[i]))
      k <- length(dim(opobj))
      dno <- vector("list", k)
      for (i in 1:k) {
        tmp <- outer(dnx[[i]], dny[[i]], FUN = paste, sep = ":")
        dno[[i]] <- as.vector(t(tmp))
      }
      dimnames(opobj) <- dno
    }
    opobj
  }, function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    X <- as.array(X)
    Y <- as.array(Y)
    if (make.dimnames) {
      dnx <- dimnames(X)
      dny <- dimnames(Y)
    }
    dX <- dim(X)
    dY <- dim(Y)
    ld <- length(dX) - length(dY)
    if (ld < 0) 
      dX <- dim(X) <- c(dX, rep.int(1, -ld))
    else if (ld > 0) 
      dY <- dim(Y) <- c(dY, rep.int(1, ld))
    opobj <- outer(X, Y, FUN, ...)
    dp <- as.vector(t(matrix(1:(2 * length(dX)), ncol = 2)[, 2:1]))
    opobj <- aperm(opobj, dp)
    dim(opobj) <- dX * dY
    if (make.dimnames && !(is.null(dnx) && is.null(dny))) {
      if (is.null(dnx)) 
        dnx <- vector("list", length(dX))
      else if (ld < 0) 
        dnx <- c(dnx, vector("list", -ld))
      tmp <- which(sapply(dnx, is.null))
      dnx[tmp] <- lapply(tmp, function(i) rep.int("", dX[i]))
      if (is.null(dny)) 
        dny <- vector("list", length(dY))
      else if (ld > 0) 
        dny <- c(dny, vector("list", ld))
      tmp <- which(sapply(dny, is.null))
      dny[tmp] <- lapply(tmp, function(i) rep.int("", dY[i]))
      k <- length(dim(opobj))
      dno <- vector("list", k)
      for (i in 1:k) {
        tmp <- outer(dnx[[i]], dny[[i]], FUN = paste, sep = ":")
        dno[[i]] <- as.vector(t(tmp))
      }
      dimnames(opobj) <- dno
    }
    opobj
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
96).Last.value
  list(`package:base` = NULL, NULL)
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
97).LC.categories
  list(`package:base` = c("LC_ALL", "LC_COLLATE", "LC_CTYPE", "LC_MONETARY", "LC_NUMERIC", "LC_TIME", "LC_MESSAGES", "LC_PAPER", "LC_MEASUREMENT"), c("LC_ALL", "LC_COLLATE", "LC_CTYPE", "LC_MONETARY", "LC_NUMERIC", "LC_TIME", "LC_MESSAGES", "LC_PAPER", "LC_MEASUREMENT"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
  .leap.seconds
  list(`package:base` = c(78796800, 94694400, 126230400, 157766400, 189302400, 220924800, 252460800, 283996800, 315532800, 362793600, 394329600, 425865600, 489024000, 567993600, 631152000, 662688000, 709948800, 741484800, 773020800, 820454400, 867715200, 915148800, 1136073600, 1230768000, 1341100800, 1435708800, 1483228800), c(78796800, 94694400, 126230400, 157766400, 189302400, 220924800, 252460800, 283996800, 315532800, 362793600, 394329600, 425865600, 489024000, 567993600, 631152000, 662688000, 
                                                                                                                                                                                                                                                                                                                                         709948800, 741484800, 773020800, 820454400, 867715200, 915148800, 1136073600, 1230768000, 1341100800, 1435708800, 1483228800))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
98).libPaths
  list(`package:base` = function (new, include.site = TRUE) 
  {
    if (!missing(new)) {
      new <- Sys.glob(path.expand(new))
      paths <- c(new, if (include.site) .Library.site, .Library)
      paths <- paths[dir.exists(paths)]
      .lib.loc <<- unique(normalizePath(paths, "/"))
    }
    else .lib.loc
  }, function (new, include.site = TRUE) 
  {
    if (!missing(new)) {
      new <- Sys.glob(path.expand(new))
      paths <- c(new, if (include.site) .Library.site, .Library)
      paths <- paths[dir.exists(paths)]
      .lib.loc <<- unique(normalizePath(paths, "/"))
    }
    else .lib.loc
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
99).Library
  list(`package:base` = "C:/PROGRA~1/R/R-42~1.1/library", "C:/PROGRA~1/R/R-42~1.1/library")
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
100).Library.site
  list(`package:base` = character(0), character(0))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
101).Machine
  list(`package:base` = list(double.eps = 2.22044604925031e-16, double.neg.eps = 1.11022302462516e-16, double.xmin = 2.2250738585072e-308, double.xmax = 1.79769313486232e+308, double.base = 2, double.digits = 53, double.rounding = 5, double.guard = 0, double.ulp.digits = -52, double.neg.ulp.digits = -53, double.exponent = 11, double.min.exp = -1022, double.max.exp = 1024, integer.max = 2147483647, sizeof.long = 4, sizeof.longlong = 8, sizeof.longdouble = 16, sizeof.pointer = 8, longdouble.eps = 1.0842021724855e-19, 
                             longdouble.neg.eps = 5.42101086242752e-20, longdouble.digits = 64, longdouble.rounding = 5, longdouble.guard = 0, longdouble.ulp.digits = -63, longdouble.neg.ulp.digits = -64, longdouble.exponent = 15, longdouble.min.exp = -16382, longdouble.max.exp = 16384), list(double.eps = 2.22044604925031e-16, double.neg.eps = 1.11022302462516e-16, double.xmin = 2.2250738585072e-308, double.xmax = 1.79769313486232e+308, double.base = 2, double.digits = 53, double.rounding = 5, double.guard = 0, double.ulp.digits = -52, 
                                                                                                                                                                                                                                                                                                      double.neg.ulp.digits = -53, double.exponent = 11, double.min.exp = -1022, double.max.exp = 1024, integer.max = 2147483647, sizeof.long = 4, sizeof.longlong = 8, sizeof.longdouble = 16, sizeof.pointer = 8, longdouble.eps = 1.0842021724855e-19, longdouble.neg.eps = 5.42101086242752e-20, longdouble.digits = 64, longdouble.rounding = 5, longdouble.guard = 0, longdouble.ulp.digits = -63, longdouble.neg.ulp.digits = -64, longdouble.exponent = 15, longdouble.min.exp = -16382, longdouble.max.exp = 16384))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
102).make_numeric_version
  list(`package:base` = function (x, strict = TRUE, regexp, classes = NULL) 
  {
    nms <- names(x)
    x <- as.character(x)
    y <- rep.int(list(integer()), length(x))
    valid_numeric_version_regexp <- sprintf("^%s$", regexp)
    if (length(x)) {
      ok <- grepl(valid_numeric_version_regexp, x)
      if (!all(ok) && strict) 
        stop(gettextf("invalid version specification %s", paste(sQuote(unique(x[!ok])), collapse = ", ")), call. = FALSE, domain = NA)
      y[ok] <- lapply(strsplit(x[ok], "[.-]"), as.integer)
    }
    names(y) <- nms
    class(y) <- unique(c(classes, "numeric_version"))
    y
  }, function (x, strict = TRUE, regexp, classes = NULL) 
  {
    nms <- names(x)
    x <- as.character(x)
    y <- rep.int(list(integer()), length(x))
    valid_numeric_version_regexp <- sprintf("^%s$", regexp)
    if (length(x)) {
      ok <- grepl(valid_numeric_version_regexp, x)
      if (!all(ok) && strict) 
        stop(gettextf("invalid version specification %s", paste(sQuote(unique(x[!ok])), collapse = ", ")), call. = FALSE, domain = NA)
      y[ok] <- lapply(strsplit(x[ok], "[.-]"), as.integer)
    }
    names(y) <- nms
    class(y) <- unique(c(classes, "numeric_version"))
    y
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
104).makeMessage
  list(`package:base` = function (..., domain = NULL, appendLF = FALSE) 
  {
    msg <- if (...length()) {
      args <- lapply(list(...), as.character)
      if (is.null(domain) || !is.na(domain)) 
        args <- .Internal(gettext(domain, unlist(args), TRUE))
      paste(args, collapse = "")
    }
    else ""
    if (appendLF) 
      paste0(msg, "\n")
    else msg
  }, function (..., domain = NULL, appendLF = FALSE) 
  {
    msg <- if (...length()) {
      args <- lapply(list(...), as.character)
      if (is.null(domain) || !is.na(domain)) 
        args <- .Internal(gettext(domain, unlist(args), TRUE))
      paste(args, collapse = "")
    }
    else ""
    if (appendLF) 
      paste0(msg, "\n")
    else msg
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
105).mapply
  list(`package:base` = function (FUN, dots, MoreArgs) 
    .Internal(mapply(match.fun(FUN), dots, MoreArgs)), function (FUN, dots, MoreArgs) 
      .Internal(mapply(match.fun(FUN), dots, MoreArgs)))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
106).maskedMsg
  list(`package:base` = function (same, pkg, by) 
  {
    objs <- strwrap(paste(same, collapse = ", "), indent = 4, exdent = 4)
    txt <- if (by) {
      ngettext(length(same), "The following object is masked _by_ %s:", "The following objects are masked _by_ %s:")
    }
    else {
      ngettext(length(same), "The following object is masked from %s:", "The following objects are masked from %s:")
    }
    sprintf(paste0(txt, "\n\n%s\n"), pkg, paste(objs, collapse = "\n"))
  }, function (same, pkg, by) 
  {
    objs <- strwrap(paste(same, collapse = ", "), indent = 4, exdent = 4)
    txt <- if (by) {
      ngettext(length(same), "The following object is masked _by_ %s:", "The following objects are masked _by_ %s:")
    }
    else {
      ngettext(length(same), "The following object is masked from %s:", "The following objects are masked from %s:")
    }
    sprintf(paste0(txt, "\n\n%s\n"), pkg, paste(objs, collapse = "\n"))
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
107).mergeExportMethods
  list(`package:base` = function (new, ns) 
  {
    newMethods <- new[startsWith(new, ".__M__")]
    nsimports <- parent.env(ns)
    for (what in newMethods) {
      if (!is.null(m1 <- nsimports[[what]])) {
        m2 <- get(what, envir = ns)
        ns[[what]] <- methods::mergeMethods(m1, m2)
      }
    }
  }, function (new, ns) 
  {
    newMethods <- new[startsWith(new, ".__M__")]
    nsimports <- parent.env(ns)
    for (what in newMethods) {
      if (!is.null(m1 <- nsimports[[what]])) {
        m2 <- get(what, envir = ns)
        ns[[what]] <- methods::mergeMethods(m1, m2)
      }
    }
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
108).mergeImportMethods
  list(`package:base` = function (impenv, expenv, metaname) 
  {
    impMethods <- impenv[[metaname]]
    if (!is.null(impMethods)) 
      impenv[[metaname]] <- methods:::.mergeMethodsTable2(impMethods, newtable = expenv[[metaname]], expenv, metaname)
    impMethods
  }, function (impenv, expenv, metaname) 
  {
    impMethods <- impenv[[metaname]]
    if (!is.null(impMethods)) 
      impenv[[metaname]] <- methods:::.mergeMethodsTable2(impMethods, newtable = expenv[[metaname]], expenv, metaname)
    impMethods
  })
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
109).noGenerics
list(`package:base` = TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE)
c("package:base", "namespace:splines", "namespace:lattice", "namespace:grDevices", "namespace:parallel", "namespace:class", "namespace:stats", "namespace:graphics", "namespace:grid", "namespace:tools", "namespace:MASS", "namespace:utils", "namespace:base", "namespace:rpart", "namespace:nnet")
c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE)
110).NotYetImplemented
list(`package:base` = function () 
  stop(gettextf("'%s' is not implemented yet", as.character(sys.call(sys.parent())[[1]])), call. = FALSE), function () 
    stop(gettextf("'%s' is not implemented yet", as.character(sys.call(sys.parent())[[1]])), call. = FALSE))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
111).NotYetUsed
list(`package:base` = function (arg, error = TRUE) 
{
  msg <- gettextf("argument '%s' is not used (yet)", arg)
  if (error) 
    stop(msg, domain = NA, call. = FALSE)
  else warning(msg, domain = NA, call. = FALSE)
}, function (arg, error = TRUE) 
{
  msg <- gettextf("argument '%s' is not used (yet)", arg)
  if (error) 
    stop(msg, domain = NA, call. = FALSE)
  else warning(msg, domain = NA, call. = FALSE)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
112).Options
list(`package:base` = pairlist(prompt = "> ", continue = "+ ", expressions = 5000, width = 91, deparse.cutoff = 60, digits = 7, echo = TRUE, verbose = FALSE, check.bounds = FALSE, keep.source = TRUE, keep.source.pkgs = FALSE, keep.parse.data = TRUE, keep.parse.data.pkgs = FALSE, warning.length = 1000, nwarnings = 50, OutDec = ".", browserNLdisabled = FALSE, CBoundsCheck = FALSE, matprod = "default", PCRE_study = FALSE, PCRE_use_JIT = TRUE, PCRE_limit_recursion = NA, warn = 0, timeout = 60, encoding = "native.enc", show.error.messages = TRUE, scipen = 0, max.print = 1000, add.smooth = TRUE, stringsAsFactors = FALSE, defaultPackages = c("datasets", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "utils", "grDevices", "graphics", "stats", "methods"), papersize = "a4", pager = function (files, header, title, delete.file) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     .rs.pager(files, header, title, delete.file)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }, useFancyQuotes = TRUE, pdfviewer = "C:/PROGRA~1/R/R-42~1.1/bin/x64/open.exe", help_type = "html", help.try.all.packages = FALSE, help.search.types = c("vignette", "demo", "help"), citation.bibtex.max = 1, internet.info = 2, pkgType = "both", str = list(strict.width = "no", digits.d = 3, vec.len = 4, list.len = 99, deparse.lines = NULL, drop.deparse.attr = TRUE, formatNum = function (x, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     format(x, trim = TRUE, drop0trailing = TRUE, ...)), demo.ask = "default", example.ask = "default", HTTPUserAgent = "RStudio Desktop (2022.2.3.492); R (4.2.1 x86_64-w64-mingw32 x86_64 mingw32)", menu.graphics = FALSE, mailer = "mailto", install.packages.compile.from.source = "interactive", unzip = "internal", editor = function (name, file = "", title = file, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (missing(name) || is.null(name)) return(.Call("rs_editFile", file, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(file) || !nzchar(file)) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         file <- tempfile("rstudio-scratch-", fileext = ".R")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         on.exit(unlink(file), add = TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       deparsed <- if (is.function(name)) .rs.deparseFunction(name, useSource = TRUE, asString = FALSE) else deparse(name)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       writeLines(deparsed, con = file)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_editFile", file, PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       eval(parse(file), envir = globalenv())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, repos = c(CRAN = "https://cran.rstudio.com/"), askYesNo = function (msg, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       flush.console()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ans <- winDialog("yesnocancel", msg)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       switch(ans, YES = TRUE, NO = FALSE, NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, locatorBell = TRUE, device.ask.default = FALSE, windowsTimeouts = c(100, 500), device = "RStudioGD", contrasts = c(unordered = "contr.treatment", ordered = "contr.poly"), na.action = "na.omit", show.coef.Pvalues = TRUE, show.signif.stars = TRUE, str.dendrogram.last = "`", ts.eps = 1e-05, ts.S.compat = FALSE, terminal.manager = list(terminalActivate = function (id = NULL, show = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.null(id) && (!is.character(id) || (length(id) != 1))) stop("'id' must be NULL or a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.logical(show)) stop("'show' must be TRUE or FALSE")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalActivate", id, show)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalCreate = function (caption = NULL, show = TRUE, shellType = NULL) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.null(caption) && (!is.character(caption) || (length(caption) != 1))) stop("'caption' must be NULL or a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(show) || !is.logical(show)) stop("'show' must be a logical vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.null(shellType) && (!is.character(shellType) || (length(shellType) != 1))) stop("'shellType' must be NULL or a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       validShellType = TRUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.null(shellType)) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         validShellType <- tolower(shellType) %in% c("default", "win-cmd", "win-ps", "win-git-bash", "win-wsl-bash", "ps-core", "custom")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!validShellType) stop("'shellType' must be NULL, or one of 'default', 'win-cmd', 'win-ps', 'win-git-bash', 'win-wsl-bash', 'ps-core', 'bash', 'zsh', or 'custom'.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalCreate", caption, show, shellType)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalClear = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(id) || !is.character(id) || length(id) != 1) stop("'id' must be a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalClear", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalList = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalList")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalContext = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(id) || !is.character(id) || (length(id) != 1)) stop("'id' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalContext", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalBuffer = function (id, stripAnsi = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(id) || !is.character(id) || (length(id) != 1)) stop("'id' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(stripAnsi) || !is.logical(stripAnsi)) stop("'stripAnsi' must be a logical vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalBuffer", id, stripAnsi)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalVisible = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalVisible")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalBusy = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(id) || !is.character(id)) stop("'id' must be a character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalBusy", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalRunning = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(id) || !is.character(id)) stop("'id' must be a character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalRunning", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalKill = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(id) || !is.character(id)) stop("'id' must be a character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalKill", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalSend = function (id, text) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.character(text)) stop("'text' should be a character vector", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(id) || !is.character(id) || length(id) != 1) stop("'id' must be a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalSend", id, text)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalExecute = function (command, workingDir = NULL, env = character(), show = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(command) || !is.character(command) || (length(command) != 1)) stop("'command' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.null(workingDir) && (!is.character(workingDir) || (length(workingDir) != 1))) stop("'workingDir' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.null(env) && !is.character(env)) stop("'env' must be a character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(show) || !is.logical(show)) stop("'show' must be a logical vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalExecute", command, workingDir, env, show, PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, terminalExitCode = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(id) || !is.character(id) || (length(id) != 1)) stop("'id' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_terminalExitCode", id, PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }), connectionObserver = list(connectionOpened = function (type, host, displayName, icon = NULL, connectCode, disconnect, listObjectTypes, listObjects, listColumns, previewObject, connectionObject, actions = NULL) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       tryCatch(.rs.connectionObserver.connectionOpenedImpl(type, host, displayName, icon, connectCode, disconnect, listObjectTypes, listObjects, listColumns, previewObject, connectionObject, actions), error = .rs.connectionObserver.connectionError)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, connectionClosed = function (type, host, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       tryCatch(.rs.connectionObserver.connectionClosedImpl(type, host, ...), error = .rs.connectionObserver.connectionError)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, connectionUpdated = function (type, host, hint, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       tryCatch(.rs.connectionObserver.connectionUpdatedImpl(type, host, hint, ...), error = .rs.connectionObserver.connectionError)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }), profvis.prof_output = "C:/Users/50045208/AppData/Local/RStudio/profiles-cache", profvis.print = function (x) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.profilePrint(x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, profvis.prof_extension = ".Rprof", ggvis.renderer = "svg", buildtools.check = function (action) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.checkBuildTools(action)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, buildtools.with = function (code) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.withBuildTools(code)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, shiny.launch.browser = function (url) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(.Call("rs_shinyviewer", url, getwd(), "window", NULL, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, plumber.docs.callback = function (url) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(.Call("rs_plumberviewer", url, getwd(), "window", PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, plumber.swagger.url = function (url) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(.Call("rs_plumberviewer", url, getwd(), "window", PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, reticulate.initialized = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       options(reticulate.initialized = NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.reticulate.onPythonInitialized()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.reticulate.enqueueClientEvent(.rs.reticulateEvents$PYTHON_INITIALIZED, list())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_reticulateInitialized", PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, reticulate.repl.initialize = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.reticulate.replInitialize()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, reticulate.repl.hook = function (buffer, contents, trimmed) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.reticulate.replHook(buffer, contents, trimmed)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, reticulate.repl.busy = function (busy) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.reticulate.replBusy(busy)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, reticulate.repl.teardown = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.reticulate.replTeardown()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, RStudioGD.backend = "default", RStudioGD.antialias = "default", browser = function (url) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .Call("rs_browseURL", url, PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, viewer = function (url, height = NULL) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.character(url) || (length(url) != 1)) stop("url must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (identical(height, "maximize")) height <- -1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.null(height) && (!is.numeric(height) || (length(height) != 1))) stop("height must be a single element numeric vector or 'maximize'.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(.Call("rs_viewer", url, height, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, page_viewer = function (url, title = "RStudio Viewer", self_contained = FALSE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.character(url) || (length(url) != 1)) stop("url must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.character(title) || (length(title) != 1)) stop("title must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.logical(self_contained) || (length(self_contained) != 1)) stop("self_contained must be a single element logical vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(.Call("rs_showPageViewer", url, title, self_contained, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, shinygadgets.showdialog = function (caption, url, width = NULL, height = NULL) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.character(caption) || (length(caption) != 1)) stop("caption must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.character(url) || (length(url) != 1)) stop("url must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(width)) width <- 600
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.null(height)) height <- 600
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.numeric(width) || (length(width) != 1)) stop("width must be a single element numeric vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (!is.numeric(height) || (length(height) != 1)) stop("height must be a single element numeric vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       invisible(.Call("rs_showShinyGadgetDialog", caption, url, width, height, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, askpass = function (prompt) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.askForPassword(prompt)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, asksecret = function (name, title = name, prompt = paste(name, ":", sep = "")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.askForSecret(name, title, prompt)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, restart = function (afterRestartCommand = "") 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .rs.restartR(afterRestartCommand)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, profvis.keep_output = TRUE, rstudio.notebook.executing = FALSE, deparse.max.lines = 20, download.file.method = "libcurl", rsconnect.check.certificate = TRUE, datatable.verbose = FALSE, datatable.optimize = Inf, datatable.print.nrows = 100, datatable.print.topn = 5, datatable.print.class = FALSE, datatable.print.rownames = TRUE, datatable.print.colnames = "auto", datatable.print.keys = FALSE, datatable.print.trunc.cols = FALSE, datatable.allow.cartesian = FALSE, datatable.dfdispatchwarn = TRUE, datatable.warnredundantby = TRUE, datatable.alloccol = 1024, datatable.auto.index = TRUE, datatable.use.index = TRUE, foreachDoparLocal = TRUE, callr.condition_handler_cli_message = function (msg) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       custom_handler <- getOption("cli.default_handler")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if (is.function(custom_handler)) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         custom_handler(msg)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       } else {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         cli_server_default(msg)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }, dplyr.show_progress = TRUE, ambiguousMethodSelection = function (cond) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       NULL, gd_num_thread = 7, future.deprecated.defunct = "transparent", pROCProgress = list(name = "win", width = 300), error = (function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         .rs.recordTraceback(TRUE, 5, .rs.enqueueError)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       })()), pairlist(prompt = "> ", continue = "+ ", expressions = 5000, width = 91, deparse.cutoff = 60, digits = 7, echo = TRUE, verbose = FALSE, check.bounds = FALSE, keep.source = TRUE, keep.source.pkgs = FALSE, keep.parse.data = TRUE, keep.parse.data.pkgs = FALSE, warning.length = 1000, nwarnings = 50, OutDec = ".", browserNLdisabled = FALSE, CBoundsCheck = FALSE, matprod = "default", PCRE_study = FALSE, PCRE_use_JIT = TRUE, PCRE_limit_recursion = NA, warn = 0, timeout = 60, encoding = "native.enc", show.error.messages = TRUE, scipen = 0, max.print = 1000, add.smooth = TRUE, stringsAsFactors = FALSE, defaultPackages = c("datasets", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           "utils", "grDevices", "graphics", "stats", "methods"), papersize = "a4", pager = function (files, header, title, delete.file) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             .rs.pager(files, header, title, delete.file)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }, useFancyQuotes = TRUE, pdfviewer = "C:/PROGRA~1/R/R-42~1.1/bin/x64/open.exe", help_type = "html", help.try.all.packages = FALSE, help.search.types = c("vignette", "demo", "help"), citation.bibtex.max = 1, internet.info = 2, pkgType = "both", str = list(strict.width = "no", digits.d = 3, vec.len = 4, list.len = 99, deparse.lines = NULL, drop.deparse.attr = TRUE, formatNum = function (x, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             format(x, trim = TRUE, drop0trailing = TRUE, ...)), demo.ask = "default", example.ask = "default", HTTPUserAgent = "RStudio Desktop (2022.2.3.492); R (4.2.1 x86_64-w64-mingw32 x86_64 mingw32)", menu.graphics = FALSE, mailer = "mailto", install.packages.compile.from.source = "interactive", unzip = "internal", editor = function (name, file = "", title = file, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (missing(name) || is.null(name)) return(.Call("rs_editFile", file, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(file) || !nzchar(file)) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 file <- tempfile("rstudio-scratch-", fileext = ".R")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 on.exit(unlink(file), add = TRUE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               deparsed <- if (is.function(name)) .rs.deparseFunction(name, useSource = TRUE, asString = FALSE) else deparse(name)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               writeLines(deparsed, con = file)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_editFile", file, PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               eval(parse(file), envir = globalenv())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, repos = c(CRAN = "https://cran.rstudio.com/"), askYesNo = function (msg, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               flush.console()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ans <- winDialog("yesnocancel", msg)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               switch(ans, YES = TRUE, NO = FALSE, NA)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, locatorBell = TRUE, device.ask.default = FALSE, windowsTimeouts = c(100, 500), device = "RStudioGD", contrasts = c(unordered = "contr.treatment", ordered = "contr.poly"), na.action = "na.omit", show.coef.Pvalues = TRUE, show.signif.stars = TRUE, str.dendrogram.last = "`", ts.eps = 1e-05, ts.S.compat = FALSE, terminal.manager = list(terminalActivate = function (id = NULL, show = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.null(id) && (!is.character(id) || (length(id) != 1))) stop("'id' must be NULL or a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.logical(show)) stop("'show' must be TRUE or FALSE")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalActivate", id, show)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalCreate = function (caption = NULL, show = TRUE, shellType = NULL) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.null(caption) && (!is.character(caption) || (length(caption) != 1))) stop("'caption' must be NULL or a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(show) || !is.logical(show)) stop("'show' must be a logical vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.null(shellType) && (!is.character(shellType) || (length(shellType) != 1))) stop("'shellType' must be NULL or a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               validShellType = TRUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.null(shellType)) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 validShellType <- tolower(shellType) %in% c("default", "win-cmd", "win-ps", "win-git-bash", "win-wsl-bash", "ps-core", "custom")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!validShellType) stop("'shellType' must be NULL, or one of 'default', 'win-cmd', 'win-ps', 'win-git-bash', 'win-wsl-bash', 'ps-core', 'bash', 'zsh', or 'custom'.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalCreate", caption, show, shellType)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalClear = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(id) || !is.character(id) || length(id) != 1) stop("'id' must be a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalClear", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalList = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalList")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalContext = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(id) || !is.character(id) || (length(id) != 1)) stop("'id' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalContext", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalBuffer = function (id, stripAnsi = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(id) || !is.character(id) || (length(id) != 1)) stop("'id' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(stripAnsi) || !is.logical(stripAnsi)) stop("'stripAnsi' must be a logical vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalBuffer", id, stripAnsi)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalVisible = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalVisible")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalBusy = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(id) || !is.character(id)) stop("'id' must be a character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalBusy", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalRunning = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(id) || !is.character(id)) stop("'id' must be a character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalRunning", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalKill = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(id) || !is.character(id)) stop("'id' must be a character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalKill", id)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalSend = function (id, text) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.character(text)) stop("'text' should be a character vector", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(id) || !is.character(id) || length(id) != 1) stop("'id' must be a character vector of length one")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalSend", id, text)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalExecute = function (command, workingDir = NULL, env = character(), show = TRUE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(command) || !is.character(command) || (length(command) != 1)) stop("'command' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.null(workingDir) && (!is.character(workingDir) || (length(workingDir) != 1))) stop("'workingDir' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.null(env) && !is.character(env)) stop("'env' must be a character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(show) || !is.logical(show)) stop("'show' must be a logical vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalExecute", command, workingDir, env, show, PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, terminalExitCode = function (id) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(id) || !is.character(id) || (length(id) != 1)) stop("'id' must be a single element character vector")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_terminalExitCode", id, PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }), connectionObserver = list(connectionOpened = function (type, host, displayName, icon = NULL, connectCode, disconnect, listObjectTypes, listObjects, listColumns, previewObject, connectionObject, actions = NULL) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               tryCatch(.rs.connectionObserver.connectionOpenedImpl(type, host, displayName, icon, connectCode, disconnect, listObjectTypes, listObjects, listColumns, previewObject, connectionObject, actions), error = .rs.connectionObserver.connectionError)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, connectionClosed = function (type, host, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               tryCatch(.rs.connectionObserver.connectionClosedImpl(type, host, ...), error = .rs.connectionObserver.connectionError)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, connectionUpdated = function (type, host, hint, ...) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               tryCatch(.rs.connectionObserver.connectionUpdatedImpl(type, host, hint, ...), error = .rs.connectionObserver.connectionError)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }), profvis.prof_output = "C:/Users/50045208/AppData/Local/RStudio/profiles-cache", profvis.print = function (x) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.profilePrint(x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, profvis.prof_extension = ".Rprof", ggvis.renderer = "svg", buildtools.check = function (action) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.checkBuildTools(action)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, buildtools.with = function (code) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.withBuildTools(code)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, shiny.launch.browser = function (url) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(.Call("rs_shinyviewer", url, getwd(), "window", NULL, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, plumber.docs.callback = function (url) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(.Call("rs_plumberviewer", url, getwd(), "window", PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, plumber.swagger.url = function (url) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(.Call("rs_plumberviewer", url, getwd(), "window", PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, reticulate.initialized = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               options(reticulate.initialized = NULL)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.reticulate.onPythonInitialized()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.reticulate.enqueueClientEvent(.rs.reticulateEvents$PYTHON_INITIALIZED, list())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_reticulateInitialized", PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, reticulate.repl.initialize = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.reticulate.replInitialize()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, reticulate.repl.hook = function (buffer, contents, trimmed) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.reticulate.replHook(buffer, contents, trimmed)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, reticulate.repl.busy = function (busy) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.reticulate.replBusy(busy)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, reticulate.repl.teardown = function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.reticulate.replTeardown()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, RStudioGD.backend = "default", RStudioGD.antialias = "default", browser = function (url) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .Call("rs_browseURL", url, PACKAGE = "(embedding)")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, viewer = function (url, height = NULL) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.character(url) || (length(url) != 1)) stop("url must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (identical(height, "maximize")) height <- -1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.null(height) && (!is.numeric(height) || (length(height) != 1))) stop("height must be a single element numeric vector or 'maximize'.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(.Call("rs_viewer", url, height, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, page_viewer = function (url, title = "RStudio Viewer", self_contained = FALSE) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.character(url) || (length(url) != 1)) stop("url must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.character(title) || (length(title) != 1)) stop("title must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.logical(self_contained) || (length(self_contained) != 1)) stop("self_contained must be a single element logical vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(.Call("rs_showPageViewer", url, title, self_contained, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, shinygadgets.showdialog = function (caption, url, width = NULL, height = NULL) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.character(caption) || (length(caption) != 1)) stop("caption must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.character(url) || (length(url) != 1)) stop("url must be a single element character vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(width)) width <- 600
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.null(height)) height <- 600
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.numeric(width) || (length(width) != 1)) stop("width must be a single element numeric vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (!is.numeric(height) || (length(height) != 1)) stop("height must be a single element numeric vector.", call. = FALSE)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               invisible(.Call("rs_showShinyGadgetDialog", caption, url, width, height, PACKAGE = "(embedding)"))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, askpass = function (prompt) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.askForPassword(prompt)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, asksecret = function (name, title = name, prompt = paste(name, ":", sep = "")) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.askForSecret(name, title, prompt)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, restart = function (afterRestartCommand = "") 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .rs.restartR(afterRestartCommand)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, profvis.keep_output = TRUE, rstudio.notebook.executing = FALSE, deparse.max.lines = 20, download.file.method = "libcurl", rsconnect.check.certificate = TRUE, datatable.verbose = FALSE, datatable.optimize = Inf, datatable.print.nrows = 100, datatable.print.topn = 5, datatable.print.class = FALSE, datatable.print.rownames = TRUE, datatable.print.colnames = "auto", datatable.print.keys = FALSE, datatable.print.trunc.cols = FALSE, datatable.allow.cartesian = FALSE, datatable.dfdispatchwarn = TRUE, datatable.warnredundantby = TRUE, datatable.alloccol = 1024, datatable.auto.index = TRUE, datatable.use.index = TRUE, foreachDoparLocal = TRUE, callr.condition_handler_cli_message = function (msg) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               custom_handler <- getOption("cli.default_handler")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if (is.function(custom_handler)) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 custom_handler(msg)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               } else {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 cli_server_default(msg)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }, dplyr.show_progress = TRUE, ambiguousMethodSelection = function (cond) 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               NULL, gd_num_thread = 7, future.deprecated.defunct = "transparent", pROCProgress = list(name = "win", width = 300), error = (function () 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 .rs.recordTraceback(TRUE, 5, .rs.enqueueError)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               })()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
113).OptRequireMethods
list(`package:base` = function () 
{
  pkg <- "methods"
  if (pkg %in% getOption("defaultPackages")) 
    if (!require(pkg, quietly = TRUE, warn.conflicts = FALSE, character.only = TRUE)) 
      warning("package \"methods\" in options(\"defaultPackages\") was not found", call. = FALSE)
}, function () 
{
  pkg <- "methods"
  if (pkg %in% getOption("defaultPackages")) 
    if (!require(pkg, quietly = TRUE, warn.conflicts = FALSE, character.only = TRUE)) 
      warning("package \"methods\" in options(\"defaultPackages\") was not found", call. = FALSE)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
114).packages
list(`package:base` = function (all.available = FALSE, lib.loc = NULL) 
{
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (all.available) {
    ans <- character()
    for (lib in lib.loc[file.exists(lib.loc)]) {
      a <- list.files(lib, all.files = FALSE, full.names = FALSE)
      pfile <- file.path(lib, a, "Meta", "package.rds")
      ans <- c(ans, a[file.exists(pfile)])
    }
    return(unique(ans))
  }
  s <- search()
  invisible(.rmpkg(s[startsWith(s, "package:")]))
}, function (all.available = FALSE, lib.loc = NULL) 
{
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (all.available) {
    ans <- character()
    for (lib in lib.loc[file.exists(lib.loc)]) {
      a <- list.files(lib, all.files = FALSE, full.names = FALSE)
      pfile <- file.path(lib, a, "Meta", "package.rds")
      ans <- c(ans, a[file.exists(pfile)])
    }
    return(unique(ans))
  }
  s <- search()
  invisible(.rmpkg(s[startsWith(s, "package:")]))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
115).packageStartupMessage
list(`package:base` = function (message, call = NULL) 
  structure(list(message = message, call = call), class = c("packageStartupMessage", "simpleMessage", "message", "condition")), function (message, call = NULL) 
    structure(list(message = message, call = call), class = c("packageStartupMessage", "simpleMessage", "message", "condition")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
116).Platform
list(`package:base` = list(OS.type = "windows", file.sep = "/", dynlib.ext = ".dll", GUI = "RStudio", endian = "little", pkgType = "win.binary", path.sep = ";", r_arch = "x64"), list(OS.type = "windows", file.sep = "/", dynlib.ext = ".dll", GUI = "RStudio", endian = "little", pkgType = "win.binary", path.sep = ";", r_arch = "x64"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
117).popath
list(`package:base` = "C:/Program Files/R/R-4.2.1/library/translations", "C:/Program Files/R/R-4.2.1/library/translations")
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
118).POSIXct
list(`package:base` = function (xx, tz = NULL, cl = c("POSIXct", "POSIXt")) 
{
  class(xx) <- cl
  attr(xx, "tzone") <- tz
  xx
}, function (xx, tz = NULL, cl = c("POSIXct", "POSIXt")) 
{
  class(xx) <- cl
  attr(xx, "tzone") <- tz
  xx
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
119).POSIXlt
list(`package:base` = function (xx, tz = NULL, cl = c("POSIXlt", "POSIXt")) 
{
  class(xx) <- cl
  attr(xx, "tzone") <- tz
  xx
}, function (xx, tz = NULL, cl = c("POSIXlt", "POSIXt")) 
{
  class(xx) <- cl
  attr(xx, "tzone") <- tz
  xx
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
120).pretty
list(`package:base` = function (x, n = 5, min.n = n%/%3, shrink.sml = 0.75, high.u.bias = 1.5, u5.bias = 0.5 + 1.5 * high.u.bias, eps.correct = 0, f.min = 2^-20, bounds = TRUE) 
{
  x <- x[is.finite(x <- as.numeric(x))]
  if (length(x)) 
    .Internal(pretty(min(x), max(x), n, min.n, shrink.sml, c(high.u.bias, u5.bias, f.min), eps.correct, bounds))
}, function (x, n = 5, min.n = n%/%3, shrink.sml = 0.75, high.u.bias = 1.5, u5.bias = 0.5 + 1.5 * high.u.bias, eps.correct = 0, f.min = 2^-20, bounds = TRUE) 
{
  x <- x[is.finite(x <- as.numeric(x))]
  if (length(x)) 
    .Internal(pretty(min(x), max(x), n, min.n, shrink.sml, c(high.u.bias, u5.bias, f.min), eps.correct, bounds))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
121).Primitive
list(`package:base` = .Primitive(".Primitive"), .Primitive(".Primitive"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
122).primTrace
list(`package:base` = .Primitive(".primTrace"), .Primitive(".primTrace"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
123).primUntrace
list(`package:base` = .Primitive(".primUntrace"), .Primitive(".primUntrace"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
124).rmpkg
list(`package:base` = function (pkg) 
  sub("package:", "", pkg, fixed = TRUE), function (pkg) 
    sub("package:", "", pkg, fixed = TRUE))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
125).row
list(`package:base` = function (dim) 
  .Internal(row(dim)), function (dim) 
    .Internal(row(dim)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
126).row_names_info
list(`package:base` = function (x, type = 1) 
  .Internal(shortRowNames(x, type)), function (x, type = 1) 
    .Internal(shortRowNames(x, type)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
127).rowMeans
list(`package:base` = function (x, m, n, na.rm = FALSE) 
  .Internal(rowMeans(x, m, n, na.rm)), function (x, m, n, na.rm = FALSE) 
    .Internal(rowMeans(x, m, n, na.rm)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
128).rowNamesDF<-
  list(`package:base` = function (x, make.names = FALSE, value) 
  {
    if (!is.data.frame(x)) 
      x <- as.data.frame(x)
    n <- .row_names_info(x, 2)
    if (is.null(value)) {
      attr(x, "row.names") <- .set_row_names(n)
      return(x)
    }
    if (is.object(value) || !is.integer(value)) 
      value <- as.character(value)
    if (n == 0) {
      if (!is.null(attr(x, "row.names")) && length(value) > 0) 
        stop("invalid 'row.names' length")
    }
    else if (length(value) != n) {
      if (isFALSE(make.names)) 
        stop("invalid 'row.names' length")
      else if (is.na(make.names)) {
        attr(x, "row.names") <- .set_row_names(n)
        return(x)
      }
      else if (!isTRUE(make.names)) 
        stop("invalid 'make.names'")
      else if ((nv <- length(value)) < n) 
        value <- c(value, rep_len(value[nv], n - nv))
      else value <- value[seq_len(n)]
    }
    if (anyDuplicated(value)) {
      if (isFALSE(make.names)) {
        nonuniq <- sort(unique(value[duplicated(value)]))
        warning(ngettext(length(nonuniq), sprintf("non-unique value when setting 'row.names': %s", sQuote(nonuniq[1])), sprintf("non-unique values when setting 'row.names': %s", paste(sQuote(nonuniq), collapse = ", "))), domain = NA, call. = FALSE)
        stop("duplicate 'row.names' are not allowed")
      }
      else if (is.na(make.names)) {
        value <- .set_row_names(if (n == 0 && is.null(.row_names_info(x, 0)) && length(x) > 0) 
          length(x[[1]])
          else n)
      }
      else if (!isTRUE(make.names)) 
        stop("invalid 'make.names'")
      else value <- make.names(value, unique = TRUE)
    }
    else if (anyNA(value)) {
      if (isFALSE(make.names)) 
        stop("missing values in 'row.names' are not allowed")
      if (is.na(make.names)) 
        value <- .set_row_names(n)
      else if (!isTRUE(make.names)) 
        stop("invalid 'make.names'")
      else value <- make.names(value, unique = TRUE)
    }
    attr(x, "row.names") <- value
    x
  }, function (x, make.names = FALSE, value) 
  {
    if (!is.data.frame(x)) 
      x <- as.data.frame(x)
    n <- .row_names_info(x, 2)
    if (is.null(value)) {
      attr(x, "row.names") <- .set_row_names(n)
      return(x)
    }
    if (is.object(value) || !is.integer(value)) 
      value <- as.character(value)
    if (n == 0) {
      if (!is.null(attr(x, "row.names")) && length(value) > 0) 
        stop("invalid 'row.names' length")
    }
    else if (length(value) != n) {
      if (isFALSE(make.names)) 
        stop("invalid 'row.names' length")
      else if (is.na(make.names)) {
        attr(x, "row.names") <- .set_row_names(n)
        return(x)
      }
      else if (!isTRUE(make.names)) 
        stop("invalid 'make.names'")
      else if ((nv <- length(value)) < n) 
        value <- c(value, rep_len(value[nv], n - nv))
      else value <- value[seq_len(n)]
    }
    if (anyDuplicated(value)) {
      if (isFALSE(make.names)) {
        nonuniq <- sort(unique(value[duplicated(value)]))
        warning(ngettext(length(nonuniq), sprintf("non-unique value when setting 'row.names': %s", sQuote(nonuniq[1])), sprintf("non-unique values when setting 'row.names': %s", paste(sQuote(nonuniq), collapse = ", "))), domain = NA, call. = FALSE)
        stop("duplicate 'row.names' are not allowed")
      }
      else if (is.na(make.names)) {
        value <- .set_row_names(if (n == 0 && is.null(.row_names_info(x, 0)) && length(x) > 0) 
          length(x[[1]])
          else n)
      }
      else if (!isTRUE(make.names)) 
        stop("invalid 'make.names'")
      else value <- make.names(value, unique = TRUE)
    }
    else if (anyNA(value)) {
      if (isFALSE(make.names)) 
        stop("missing values in 'row.names' are not allowed")
      if (is.na(make.names)) 
        value <- .set_row_names(n)
      else if (!isTRUE(make.names)) 
        stop("invalid 'make.names'")
      else value <- make.names(value, unique = TRUE)
    }
    attr(x, "row.names") <- value
    x
  })
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
129).rowSums
list(`package:base` = function (x, m, n, na.rm = FALSE) 
  .Internal(rowSums(x, m, n, na.rm)), function (x, m, n, na.rm = FALSE) 
    .Internal(rowSums(x, m, n, na.rm)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
130).S3_methods_table
list(`package:base` = c("!", "!", "$", "$", "$<-", "&", "&", "*", "+", "+", "-", "-", "/", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[<-", "[<-", "[<-", "[<-", "[<-", "[<-", "[<-", "[[", "[[", "[[", "[[", "[[", "[[", "[[<-", "[[<-", "[[<-", "[[<-", "|", "|", "Math", "Math", "Math", "Math", "Math", "Ops", "Ops", "Ops", "Ops", "Ops", "Ops", "Ops", "Summary", "Summary", "Summary", "Summary", "Summary", "Summary", "Summary", "Summary", "all.equal", "all.equal", 
                        "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "anyDuplicated", "anyDuplicated", "anyDuplicated", "anyDuplicated", "anyNA", "anyNA", "anyNA", "aperm", "aperm", "as.Date", "as.Date", "as.Date", "as.Date", "as.Date", "as.Date", "as.POSIXct", "as.POSIXct", "as.POSIXct", "as.POSIXct", "as.POSIXlt", "as.POSIXlt", "as.POSIXlt", "as.POSIXlt", "as.POSIXlt", "as.POSIXlt", "as.array", "as.character", "as.character", "as.character", 
                        "as.character", "as.character", "as.character", "as.character", "as.character", "as.character", "as.character", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", 
                        "as.data.frame", "as.double", "as.double", "as.expression", "as.function", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.logical", "as.matrix", "as.matrix", "as.matrix", "as.matrix", "as.null", "as.single", "as.table", "as.vector", "as.vector", "as.vector", "by", "by", "c", "c", "c", "c", "c", "c", "c", "c", "cbind", "chol", "close", "close", "close", "conditionCall", "conditionMessage", "cut", "cut", "cut", "determinant", "diff", 
                        "diff", "diff", "diff", "dim", "dimnames", "dimnames<-", "droplevels", "droplevels", "duplicated", "duplicated", "duplicated", "duplicated", "duplicated", "duplicated", "duplicated", "flush", "format", "format", "format", "format", "format", "format", "format", "format", "format", "format", "format", "format", "format", "format", "getDLLRegisteredRoutines", "getDLLRegisteredRoutines", "is.na", "is.na", "is.na", "is.na<-", "is.na<-", "is.na<-", "is.numeric", "is.numeric", "is.numeric", "isSymmetric", 
                        "julian", "julian", "kappa", "kappa", "kappa", "labels", "length", "length<-", "length<-", "length<-", "length<-", "length<-", "levels", "levels<-", "mean", "mean", "mean", "mean", "mean", "merge", "merge", "months", "months", "mtfrm", "names", "names<-", "open", "open", "open", "open", "pretty", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", 
                        "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "qr", "quarters", "quarters", "range", "rbind", "rep", "rep", "rep", "rep", "rep", "rep", "rev", "round", "round", "row.names", "row.names", "row.names<-", "row.names<-", "rowsum", "rowsum", "scale", "seek", "seq", "seq", "seq", "sequence", "solve", "solve", "sort", "sort", "split", "split", "split", "split", "split<-", "split<-", "subset", "subset", "subset", "summary", "summary", 
                        "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "t", "t", "toString", "transform", "transform", "trunc", "trunc", "truncate", "unique", "unique", "unique", "unique", "unique", "unique", "unique", "units", "units<-", "weekdays", "weekdays", "with", "within", "within", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "hexmode", "octmode", "DLLInfo", "package_version", "data.frame", "hexmode", "octmode", 
                        "difftime", "Date", "POSIXt", "Date", "POSIXt", "difftime", "AsIs", "DLLInfoList", "Date", "Dlist", "POSIXct", "POSIXlt", "data.frame", "difftime", "factor", "hexmode", "listof", "noquote", "numeric_version", "octmode", "simple.list", "table", "warnings", "Date", "POSIXct", "POSIXlt", "data.frame", "difftime", "factor", "numeric_version", "Date", "POSIXct", "POSIXlt", "data.frame", "factor", "numeric_version", "POSIXlt", "data.frame", "factor", "numeric_version", "hexmode", "octmode", "Date", "POSIXt", 
                        "data.frame", "difftime", "factor", "Date", "POSIXt", "data.frame", "difftime", "factor", "numeric_version", "ordered", "Date", "POSIXct", "POSIXlt", "data.frame", "difftime", "factor", "numeric_version", "ordered", "POSIXt", "character", "default", "envRefClass", "environment", "factor", "formula", "function", "language", "list", "numeric", "raw", "array", "data.frame", "default", "matrix", "POSIXlt", "data.frame", "numeric_version", "default", "table", "POSIXct", "POSIXlt", "character", "default", 
                        "factor", "numeric", "Date", "POSIXlt", "default", "numeric", "Date", "POSIXct", "character", "default", "factor", "numeric", "default", "Date", "POSIXt", "condition", "default", "error", "factor", "hexmode", "numeric_version", "octmode", "srcref", "AsIs", "Date", "POSIXct", "POSIXlt", "array", "character", "complex", "data.frame", "default", "difftime", "factor", "integer", "list", "logical", "matrix", "model.matrix", "noquote", "numeric", "numeric_version", "ordered", "raw", "table", "ts", "vector", 
                        "POSIXlt", "difftime", "default", "default", "Date", "POSIXct", "POSIXlt", "data.frame", "default", "difftime", "environment", "factor", "function", "numeric_version", "factor", "POSIXlt", "data.frame", "default", "noquote", "default", "default", "default", "POSIXlt", "data.frame", "factor", "data.frame", "default", "Date", "POSIXct", "POSIXlt", "difftime", "factor", "noquote", "numeric_version", "warnings", "data.frame", "default", "connection", "srcfile", "srcfilealias", "condition", "condition", 
                        "Date", "POSIXt", "default", "matrix", "Date", "POSIXt", "default", "difftime", "data.frame", "data.frame", "data.frame", "data.frame", "factor", "POSIXlt", "array", "data.frame", "default", "matrix", "numeric_version", "warnings", "connection", "AsIs", "Date", "POSIXct", "POSIXlt", "data.frame", "default", "difftime", "factor", "hexmode", "libraryIQR", "numeric_version", "octmode", "packageInfo", "summaryDefault", "DLLInfo", "character", "POSIXlt", "data.frame", "numeric_version", "default", "factor", 
                        "numeric_version", "Date", "POSIXt", "difftime", "matrix", "Date", "POSIXt", "default", "lm", "qr", "default", "POSIXlt", "Date", "POSIXct", "POSIXlt", "difftime", "factor", "default", "factor", "Date", "POSIXct", "POSIXlt", "default", "difftime", "data.frame", "default", "Date", "POSIXt", "default", "POSIXlt", "POSIXlt", "connection", "srcfile", "srcfilealias", "srcfilecopy", "default", "AsIs", "DLLInfo", "DLLInfoList", "DLLRegisteredRoutines", "Date", "Dlist", "NativeRoutineList", "POSIXct", "POSIXlt", 
                        "by", "condition", "connection", "data.frame", "default", "difftime", "eigen", "factor", "function", "hexmode", "libraryIQR", "listof", "noquote", "numeric_version", "octmode", "packageInfo", "proc_time", "restart", "rle", "simple.list", "srcfile", "srcref", "summary.table", "summary.warnings", "summaryDefault", "table", "warnings", "default", "Date", "POSIXt", "default", "data.frame", "Date", "POSIXct", "POSIXlt", "difftime", "factor", "numeric_version", "default", "Date", "POSIXt", "data.frame", 
                        "default", "data.frame", "default", "data.frame", "default", "default", "connection", "Date", "POSIXt", "default", "default", "default", "qr", "POSIXlt", "default", "Date", "POSIXct", "data.frame", "default", "data.frame", "default", "data.frame", "default", "matrix", "Date", "POSIXct", "POSIXlt", "connection", "data.frame", "default", "factor", "matrix", "proc_time", "srcfile", "srcref", "table", "warnings", "data.frame", "default", "default", "data.frame", "default", "Date", "POSIXt", "connection", 
                        "POSIXlt", "array", "data.frame", "default", "matrix", "numeric_version", "warnings", "difftime", "difftime", "Date", "POSIXt", "default", "data.frame", "list", "AsIs", "Date", "POSIXct", "POSIXlt", "data.frame", "default", "difftime", "factor", "numeric_version"), c("!", "!", "$", "$", "$<-", "&", "&", "*", "+", "+", "-", "-", "/", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[", "[<-", "[<-", "[<-", "[<-", "[<-", "[<-", "[<-", "[[", "[[", "[[", "[[", "[[", "[[", 
                                                                                                                                                                                                                                                                                                    "[[<-", "[[<-", "[[<-", "[[<-", "|", "|", "Math", "Math", "Math", "Math", "Math", "Ops", "Ops", "Ops", "Ops", "Ops", "Ops", "Ops", "Summary", "Summary", "Summary", "Summary", "Summary", "Summary", "Summary", "Summary", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "all.equal", "anyDuplicated", "anyDuplicated", "anyDuplicated", "anyDuplicated", "anyNA", "anyNA", "anyNA", "aperm", "aperm", "as.Date", "as.Date", 
                                                                                                                                                                                                                                                                                                    "as.Date", "as.Date", "as.Date", "as.Date", "as.POSIXct", "as.POSIXct", "as.POSIXct", "as.POSIXct", "as.POSIXlt", "as.POSIXlt", "as.POSIXlt", "as.POSIXlt", "as.POSIXlt", "as.POSIXlt", "as.array", "as.character", "as.character", "as.character", "as.character", "as.character", "as.character", "as.character", "as.character", "as.character", "as.character", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", 
                                                                                                                                                                                                                                                                                                    "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.data.frame", "as.double", "as.double", "as.expression", "as.function", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.list", "as.logical", "as.matrix", "as.matrix", "as.matrix", "as.matrix", "as.null", "as.single", 
                                                                                                                                                                                                                                                                                                    "as.table", "as.vector", "as.vector", "as.vector", "by", "by", "c", "c", "c", "c", "c", "c", "c", "c", "cbind", "chol", "close", "close", "close", "conditionCall", "conditionMessage", "cut", "cut", "cut", "determinant", "diff", "diff", "diff", "diff", "dim", "dimnames", "dimnames<-", "droplevels", "droplevels", "duplicated", "duplicated", "duplicated", "duplicated", "duplicated", "duplicated", "duplicated", "flush", "format", "format", "format", "format", "format", "format", "format", "format", "format", 
                                                                                                                                                                                                                                                                                                    "format", "format", "format", "format", "format", "getDLLRegisteredRoutines", "getDLLRegisteredRoutines", "is.na", "is.na", "is.na", "is.na<-", "is.na<-", "is.na<-", "is.numeric", "is.numeric", "is.numeric", "isSymmetric", "julian", "julian", "kappa", "kappa", "kappa", "labels", "length", "length<-", "length<-", "length<-", "length<-", "length<-", "levels", "levels<-", "mean", "mean", "mean", "mean", "mean", "merge", "merge", "months", "months", "mtfrm", "names", "names<-", "open", "open", "open", 
                                                                                                                                                                                                                                                                                                    "open", "pretty", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "qr", "quarters", "quarters", "range", "rbind", "rep", "rep", "rep", "rep", "rep", "rep", "rev", "round", "round", "row.names", "row.names", "row.names<-", "row.names<-", 
                                                                                                                                                                                                                                                                                                    "rowsum", "rowsum", "scale", "seek", "seq", "seq", "seq", "sequence", "solve", "solve", "sort", "sort", "split", "split", "split", "split", "split<-", "split<-", "subset", "subset", "subset", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "summary", "t", "t", "toString", "transform", "transform", "trunc", "trunc", "truncate", "unique", "unique", "unique", "unique", "unique", "unique", "unique", "units", "units<-", 
                                                                                                                                                                                                                                                                                                    "weekdays", "weekdays", "with", "within", "within", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "xtfrm", "hexmode", "octmode", "DLLInfo", "package_version", "data.frame", "hexmode", "octmode", "difftime", "Date", "POSIXt", "Date", "POSIXt", "difftime", "AsIs", "DLLInfoList", "Date", "Dlist", "POSIXct", "POSIXlt", "data.frame", "difftime", "factor", "hexmode", "listof", "noquote", "numeric_version", "octmode", "simple.list", "table", "warnings", "Date", "POSIXct", "POSIXlt", 
                                                                                                                                                                                                                                                                                                    "data.frame", "difftime", "factor", "numeric_version", "Date", "POSIXct", "POSIXlt", "data.frame", "factor", "numeric_version", "POSIXlt", "data.frame", "factor", "numeric_version", "hexmode", "octmode", "Date", "POSIXt", "data.frame", "difftime", "factor", "Date", "POSIXt", "data.frame", "difftime", "factor", "numeric_version", "ordered", "Date", "POSIXct", "POSIXlt", "data.frame", "difftime", "factor", "numeric_version", "ordered", "POSIXt", "character", "default", "envRefClass", "environment", 
                                                                                                                                                                                                                                                                                                    "factor", "formula", "function", "language", "list", "numeric", "raw", "array", "data.frame", "default", "matrix", "POSIXlt", "data.frame", "numeric_version", "default", "table", "POSIXct", "POSIXlt", "character", "default", "factor", "numeric", "Date", "POSIXlt", "default", "numeric", "Date", "POSIXct", "character", "default", "factor", "numeric", "default", "Date", "POSIXt", "condition", "default", "error", "factor", "hexmode", "numeric_version", "octmode", "srcref", "AsIs", "Date", "POSIXct", 
                                                                                                                                                                                                                                                                                                    "POSIXlt", "array", "character", "complex", "data.frame", "default", "difftime", "factor", "integer", "list", "logical", "matrix", "model.matrix", "noquote", "numeric", "numeric_version", "ordered", "raw", "table", "ts", "vector", "POSIXlt", "difftime", "default", "default", "Date", "POSIXct", "POSIXlt", "data.frame", "default", "difftime", "environment", "factor", "function", "numeric_version", "factor", "POSIXlt", "data.frame", "default", "noquote", "default", "default", "default", "POSIXlt", "data.frame", 
                                                                                                                                                                                                                                                                                                    "factor", "data.frame", "default", "Date", "POSIXct", "POSIXlt", "difftime", "factor", "noquote", "numeric_version", "warnings", "data.frame", "default", "connection", "srcfile", "srcfilealias", "condition", "condition", "Date", "POSIXt", "default", "matrix", "Date", "POSIXt", "default", "difftime", "data.frame", "data.frame", "data.frame", "data.frame", "factor", "POSIXlt", "array", "data.frame", "default", "matrix", "numeric_version", "warnings", "connection", "AsIs", "Date", "POSIXct", "POSIXlt", 
                                                                                                                                                                                                                                                                                                    "data.frame", "default", "difftime", "factor", "hexmode", "libraryIQR", "numeric_version", "octmode", "packageInfo", "summaryDefault", "DLLInfo", "character", "POSIXlt", "data.frame", "numeric_version", "default", "factor", "numeric_version", "Date", "POSIXt", "difftime", "matrix", "Date", "POSIXt", "default", "lm", "qr", "default", "POSIXlt", "Date", "POSIXct", "POSIXlt", "difftime", "factor", "default", "factor", "Date", "POSIXct", "POSIXlt", "default", "difftime", "data.frame", "default", "Date", 
                                                                                                                                                                                                                                                                                                    "POSIXt", "default", "POSIXlt", "POSIXlt", "connection", "srcfile", "srcfilealias", "srcfilecopy", "default", "AsIs", "DLLInfo", "DLLInfoList", "DLLRegisteredRoutines", "Date", "Dlist", "NativeRoutineList", "POSIXct", "POSIXlt", "by", "condition", "connection", "data.frame", "default", "difftime", "eigen", "factor", "function", "hexmode", "libraryIQR", "listof", "noquote", "numeric_version", "octmode", "packageInfo", "proc_time", "restart", "rle", "simple.list", "srcfile", "srcref", "summary.table", 
                                                                                                                                                                                                                                                                                                    "summary.warnings", "summaryDefault", "table", "warnings", "default", "Date", "POSIXt", "default", "data.frame", "Date", "POSIXct", "POSIXlt", "difftime", "factor", "numeric_version", "default", "Date", "POSIXt", "data.frame", "default", "data.frame", "default", "data.frame", "default", "default", "connection", "Date", "POSIXt", "default", "default", "default", "qr", "POSIXlt", "default", "Date", "POSIXct", "data.frame", "default", "data.frame", "default", "data.frame", "default", "matrix", "Date", 
                                                                                                                                                                                                                                                                                                    "POSIXct", "POSIXlt", "connection", "data.frame", "default", "factor", "matrix", "proc_time", "srcfile", "srcref", "table", "warnings", "data.frame", "default", "default", "data.frame", "default", "Date", "POSIXt", "connection", "POSIXlt", "array", "data.frame", "default", "matrix", "numeric_version", "warnings", "difftime", "difftime", "Date", "POSIXt", "default", "data.frame", "list", "AsIs", "Date", "POSIXct", "POSIXlt", "data.frame", "default", "difftime", "factor", "numeric_version"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
131).S3method
list(`package:base` = function (generic, class, method) 
{
  if (missing(method)) 
    method <- paste(generic, class, sep = ".")
  method <- match.fun(method)
  registerS3method(generic, class, method, envir = parent.frame())
  invisible(NULL)
}, function (generic, class, method) 
{
  if (missing(method)) 
    method <- paste(generic, class, sep = ".")
  method <- match.fun(method)
  registerS3method(generic, class, method, envir = parent.frame())
  invisible(NULL)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
132).S3PrimitiveGenerics
list(`package:base` = c("anyNA", "as.character", "as.complex", "as.double", "as.environment", "as.integer", "as.logical", "as.call", "as.numeric", "as.raw", "c", "dim", "dim<-", "dimnames", "dimnames<-", "is.array", "is.finite", "is.infinite", "is.matrix", "is.na", "is.nan", "is.numeric", "length", "length<-", "levels<-", "names", "names<-", "rep", "seq.int", "xtfrm"), c("anyNA", "as.character", "as.complex", "as.double", "as.environment", "as.integer", "as.logical", "as.call", "as.numeric", "as.raw", 
                                                                                                                                                                                                                                                                                                                                                                                      "c", "dim", "dim<-", "dimnames", "dimnames<-", "is.array", "is.finite", "is.infinite", "is.matrix", "is.na", "is.nan", "is.numeric", "length", "length<-", "levels<-", "names", "names<-", "rep", "seq.int", "xtfrm"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
133).Script
list(`package:base` = function (interpreter, script, args, ...) 
{
  if (.Platform$OS.type == "windows") {
    cmd <- paste(shQuote(file.path(R.home("bin"), "Rcmd")), file.path("..", "share", interpreter, script), args)
    system(cmd, invisible = TRUE)
  }
  else system(paste(shQuote(file.path(R.home("bin"), "Rcmd")), interpreter, shQuote(file.path(R.home("share"), interpreter, script)), args), ...)
}, function (interpreter, script, args, ...) 
{
  if (.Platform$OS.type == "windows") {
    cmd <- paste(shQuote(file.path(R.home("bin"), "Rcmd")), file.path("..", "share", interpreter, script), args)
    system(cmd, invisible = TRUE)
  }
  else system(paste(shQuote(file.path(R.home("bin"), "Rcmd")), interpreter, shQuote(file.path(R.home("share"), interpreter, script)), args), ...)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
134).set_row_names
list(`package:base` = function (n) 
  if (n > 0) c(NA, -n) else integer(), function (n) 
    if (n > 0) c(NA, -n) else integer())
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
135).signalSimpleWarning
list(`package:base` = function (msg, call) 
  withRestarts({
    .Internal(.signalCondition(simpleWarning(msg, call), msg, call))
    .Internal(.dfltWarn(msg, call))
  }, muffleWarning = function() NULL), function (msg, call) 
    withRestarts({
      .Internal(.signalCondition(simpleWarning(msg, call), msg, call))
      .Internal(.dfltWarn(msg, call))
    }, muffleWarning = function() NULL))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
136).standard_regexps
list(`package:base` = function () 
{
  list(valid_package_name = "[[:alpha:]][[:alnum:].]*[[:alnum:]]", valid_package_version = "([[:digit:]]+[.-]){1,}[[:digit:]]+", valid_R_system_version = "[[:digit:]]+\\.[[:digit:]]+\\.[[:digit:]]+", valid_numeric_version = "([[:digit:]]+[.-])*[[:digit:]]+")
}, function () 
{
  list(valid_package_name = "[[:alpha:]][[:alnum:].]*[[:alnum:]]", valid_package_version = "([[:digit:]]+[.-]){1,}[[:digit:]]+", valid_R_system_version = "[[:digit:]]+\\.[[:digit:]]+\\.[[:digit:]]+", valid_numeric_version = "([[:digit:]]+[.-])*[[:digit:]]+")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
137).subset
list(`package:base` = .Primitive(".subset"), .Primitive(".subset"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
138).subset2
list(`package:base` = .Primitive(".subset2"), .Primitive(".subset2"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
139).sys.timezone
list(`package:base` = NA, NA)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
140).TAOCP1997init
list(`package:base` = function (seed) 
{
  KK <- 100
  LL <- 37
  MM <- as.integer(2^30)
  KKK <- KK + KK - 1
  KKL <- KK - LL
  ss <- seed - (seed%%2) + 2
  X <- integer(KKK)
  for (j in 1:KK) {
    X[j] <- ss
    ss <- ss + ss
    if (ss >= MM) 
      ss <- ss - MM + 2
  }
  X[2] <- X[2] + 1
  ss <- seed
  T <- 69
  while (T > 0) {
    for (j in KK:2) X[j + j - 1] <- X[j]
    for (j in seq(KKK, KKL + 1, -2)) X[KKK - j + 2] <- X[j] - (X[j]%%2)
    for (j in KKK:(KK + 1)) if (X[j]%%2 == 1) {
      X[j - KKL] <- (X[j - KKL] - X[j])%%MM
      X[j - KK] <- (X[j - KK] - X[j])%%MM
    }
    if (ss%%2 == 1) {
      for (j in KK:1) X[j + 1] <- X[j]
      X[1] <- X[KK + 1]
      if (X[KK + 1]%%2 == 1) 
        X[LL + 1] <- (X[LL + 1] - X[KK + 1])%%MM
    }
    if (ss) 
      ss <- ss%/%2
    else T <- T - 1
  }
  rs <- c(X[(LL + 1):KK], X[1:LL])
  invisible(rs)
}, function (seed) 
{
  KK <- 100
  LL <- 37
  MM <- as.integer(2^30)
  KKK <- KK + KK - 1
  KKL <- KK - LL
  ss <- seed - (seed%%2) + 2
  X <- integer(KKK)
  for (j in 1:KK) {
    X[j] <- ss
    ss <- ss + ss
    if (ss >= MM) 
      ss <- ss - MM + 2
  }
  X[2] <- X[2] + 1
  ss <- seed
  T <- 69
  while (T > 0) {
    for (j in KK:2) X[j + j - 1] <- X[j]
    for (j in seq(KKK, KKL + 1, -2)) X[KKK - j + 2] <- X[j] - (X[j]%%2)
    for (j in KKK:(KK + 1)) if (X[j]%%2 == 1) {
      X[j - KKL] <- (X[j - KKL] - X[j])%%MM
      X[j - KK] <- (X[j - KK] - X[j])%%MM
    }
    if (ss%%2 == 1) {
      for (j in KK:1) X[j + 1] <- X[j]
      X[1] <- X[KK + 1]
      if (X[KK + 1]%%2 == 1) 
        X[LL + 1] <- (X[LL + 1] - X[KK + 1])%%MM
    }
    if (ss) 
      ss <- ss%/%2
    else T <- T - 1
  }
  rs <- c(X[(LL + 1):KK], X[1:LL])
  invisible(rs)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
141).traceback
list(`package:base` = function (x = NULL, max.lines = getOption("traceback.max.lines", getOption("deparse.max.lines", -1))) 
{
  stopifnot(length(max.lines) <= 1)
  .is.positive.intlike <- function(x) is.numeric(x) && length(x) == 1 && !is.na(x) && as.integer(x) >= 0
  if (int.x <- .is.positive.intlike(x)) 
    x <- .Internal(traceback(x))
  if (int.x || (is.null(x) && !is.null(x <- get0(".Traceback", envir = baseenv()))) || is.pairlist(x) || is.list(x)) {
    valid.max.lines <- .is.positive.intlike(max.lines)
    nlines <- if (valid.max.lines) 
      max.lines + 1
    else max.lines
    for (i in seq_along(x)) {
      srcref <- attr(x[[i]], "srcref")
      if (typeof(x[[i]]) == "language") 
        x[[i]] <- deparse(x[[i]], nlines = nlines)
      if (valid.max.lines && length(x[[i]]) > max.lines) {
        x[[i]] <- x[[i]][seq_len(max.lines)]
        attr(x[[i]], "truncated") <- TRUE
      }
      attr(x[[i]], "srcref") <- srcref
    }
  }
  x
}, function (x = NULL, max.lines = getOption("traceback.max.lines", getOption("deparse.max.lines", -1))) 
{
  stopifnot(length(max.lines) <= 1)
  .is.positive.intlike <- function(x) is.numeric(x) && length(x) == 1 && !is.na(x) && as.integer(x) >= 0
  if (int.x <- .is.positive.intlike(x)) 
    x <- .Internal(traceback(x))
  if (int.x || (is.null(x) && !is.null(x <- get0(".Traceback", envir = baseenv()))) || is.pairlist(x) || is.list(x)) {
    valid.max.lines <- .is.positive.intlike(max.lines)
    nlines <- if (valid.max.lines) 
      max.lines + 1
    else max.lines
    for (i in seq_along(x)) {
      srcref <- attr(x[[i]], "srcref")
      if (typeof(x[[i]]) == "language") 
        x[[i]] <- deparse(x[[i]], nlines = nlines)
      if (valid.max.lines && length(x[[i]]) > max.lines) {
        x[[i]] <- x[[i]][seq_len(max.lines)]
        attr(x[[i]], "truncated") <- TRUE
      }
      attr(x[[i]], "srcref") <- srcref
    }
  }
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
142).tryResumeInterrupt
list(`package:base` = function () 
{
  r <- findRestart("resume")
  if (!is.null(r)) 
    invokeRestart(r)
}, function () 
{
  r <- findRestart("resume")
  if (!is.null(r)) 
    invokeRestart(r)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
143).userHooksEnv
list(`package:base` = <environment>, <environment>)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
144).valid.factor
list(`package:base` = function (object) 
{
  levs <- levels(object)
  if (!is.character(levs)) 
    return("factor levels must be \"character\"")
  if (d <- anyDuplicated(levs)) 
    return(sprintf("duplicated level [%d] in factor", d))
  TRUE
}, function (object) 
{
  levs <- levels(object)
  if (!is.character(levs)) 
    return("factor levels must be \"character\"")
  if (d <- anyDuplicated(levs)) 
    return(sprintf("duplicated level [%d] in factor", d))
  TRUE
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
145)/
  list(`package:base` = .Primitive("/"), .Primitive("/"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
146)/.difftime
list(`package:base` = function (e1, e2) 
{
  if (inherits(e2, "difftime")) 
    stop("second argument of / cannot be a \"difftime\" object")
  .difftime(unclass(e1)/e2, attr(e1, "units"))
}, function (e1, e2) 
{
  if (inherits(e2, "difftime")) 
    stop("second argument of / cannot be a \"difftime\" object")
  .difftime(unclass(e1)/e2, attr(e1, "units"))
}, function (e1, e2) 
{
  if (inherits(e2, "difftime")) 
    stop("second argument of / cannot be a \"difftime\" object")
  .difftime(unclass(e1)/e2, attr(e1, "units"))
})
c("package:base", "registered S3 method for / from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
147):
  list(`package:base` = .Primitive(":"), .Primitive(":"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
148)::
  list(`package:base` = .Primitive("::"), .Primitive("::"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
149):::
  list(`package:base` = .Primitive(":::"), .Primitive(":::"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
150)@
  list(`package:base` = .Primitive("@"), .Primitive("@"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
151)@<-
  list(`package:base` = .Primitive("@<-"), .Primitive("@<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
152)[
  list(`package:base` = .Primitive("["), .Primitive("["))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
153)[.AsIs
    list(`package:base` = function (x, i, ...) 
      I(NextMethod("[")), function (x, i, ...) 
        I(NextMethod("[")), function (x, i, ...) 
          I(NextMethod("[")))
    c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
    c(TRUE, FALSE, FALSE)
    c(FALSE, TRUE, TRUE)
154)[.data.frame
      list(`package:base` = function (x, i, j, drop = if (missing(i)) TRUE else length(cols) == 1) 
      {
        mdrop <- missing(drop)
        Narg <- nargs() - !mdrop
        has.j <- !missing(j)
        if (!all(names(sys.call()) %in% c("", "drop")) && !isS4(x)) 
          warning("named arguments other than 'drop' are discouraged")
        if (Narg < 3) {
          if (!mdrop) 
            warning("'drop' argument will be ignored")
          if (missing(i)) 
            return(x)
          if (is.matrix(i)) 
            return(as.matrix(x)[i])
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (!is.character(i) && anyNA(nm)) {
            names(nm) <- names(x) <- seq_along(x)
            y <- NextMethod("[")
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
            cols <- names(y) <- nm[cols]
          }
          else {
            y <- NextMethod("[")
            cols <- names(y)
            if (!is.null(cols) && anyNA(cols)) 
              stop("undefined columns selected")
          }
          if (anyDuplicated(cols)) 
            names(y) <- make.unique(cols)
          attr(y, "row.names") <- .row_names_info(x, 0)
          attr(y, "class") <- oldClass(x)
          return(y)
        }
        if (missing(i)) {
          if (drop && !has.j && length(x) == 1) 
            return(.subset2(x, 1))
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (has.j && !is.character(j) && anyNA(nm)) {
            names(nm) <- names(x) <- seq_along(x)
            y <- .subset(x, j)
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
            cols <- names(y) <- nm[cols]
          }
          else {
            y <- if (has.j) 
              .subset(x, j)
            else x
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
          }
          if (drop && length(y) == 1) 
            return(.subset2(y, 1))
          if (anyDuplicated(cols)) 
            names(y) <- make.unique(cols)
          nrow <- .row_names_info(x, 2)
          if (drop && !mdrop && nrow == 1) 
            return(structure(y, class = NULL, row.names = NULL))
          else {
            attr(y, "class") <- oldClass(x)
            attr(y, "row.names") <- .row_names_info(x, 0)
            return(y)
          }
        }
        xx <- x
        cols <- names(xx)
        x <- vector("list", length(x))
        x <- .Internal(copyDFattr(xx, x))
        oldClass(x) <- attr(x, "row.names") <- NULL
        if (has.j) {
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (!is.character(j) && anyNA(nm)) 
            names(nm) <- names(x) <- seq_along(x)
          x <- x[j]
          cols <- names(x)
          if (drop && length(x) == 1) {
            if (is.character(i)) {
              rows <- attr(xx, "row.names")
              i <- pmatch(i, rows, duplicates.ok = TRUE)
            }
            xj <- .subset2(.subset(xx, j), 1)
            return(if (length(dim(xj)) != 2) xj[i] else xj[i, , drop = FALSE])
          }
          if (anyNA(cols)) 
            stop("undefined columns selected")
          if (!is.null(names(nm))) 
            cols <- names(x) <- nm[cols]
          nxx <- structure(seq_along(xx), names = names(xx))
          sxx <- match(nxx[j], seq_along(xx))
        }
        else sxx <- seq_along(x)
        rows <- NULL
        if (is.character(i)) {
          rows <- attr(xx, "row.names")
          i <- pmatch(i, rows, duplicates.ok = TRUE)
        }
        for (j in seq_along(x)) {
          xj <- xx[[sxx[j]]]
          x[[j]] <- if (length(dim(xj)) != 2) 
            xj[i]
          else xj[i, , drop = FALSE]
        }
        if (drop) {
          n <- length(x)
          if (n == 1) 
            return(x[[1]])
          if (n > 1) {
            xj <- x[[1]]
            nrow <- if (length(dim(xj)) == 2) 
              dim(xj)[1]
            else length(xj)
            drop <- !mdrop && nrow == 1
          }
          else drop <- FALSE
        }
        if (!drop) {
          if (is.null(rows)) 
            rows <- attr(xx, "row.names")
          rows <- rows[i]
          if ((ina <- anyNA(rows)) | (dup <- anyDuplicated(rows))) {
            if (!dup && is.character(rows)) 
              dup <- "NA" %in% rows
            if (ina) 
              rows[is.na(rows)] <- "NA"
            if (dup) 
              rows <- make.unique(as.character(rows))
          }
          if (has.j && anyDuplicated(nm <- names(x))) 
            names(x) <- make.unique(nm)
          if (is.null(rows)) 
            rows <- attr(xx, "row.names")[i]
          attr(x, "row.names") <- rows
          oldClass(x) <- oldClass(xx)
        }
        x
      }, function (x, i, j, drop = if (missing(i)) TRUE else length(cols) == 1) 
      {
        mdrop <- missing(drop)
        Narg <- nargs() - !mdrop
        has.j <- !missing(j)
        if (!all(names(sys.call()) %in% c("", "drop")) && !isS4(x)) 
          warning("named arguments other than 'drop' are discouraged")
        if (Narg < 3) {
          if (!mdrop) 
            warning("'drop' argument will be ignored")
          if (missing(i)) 
            return(x)
          if (is.matrix(i)) 
            return(as.matrix(x)[i])
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (!is.character(i) && anyNA(nm)) {
            names(nm) <- names(x) <- seq_along(x)
            y <- NextMethod("[")
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
            cols <- names(y) <- nm[cols]
          }
          else {
            y <- NextMethod("[")
            cols <- names(y)
            if (!is.null(cols) && anyNA(cols)) 
              stop("undefined columns selected")
          }
          if (anyDuplicated(cols)) 
            names(y) <- make.unique(cols)
          attr(y, "row.names") <- .row_names_info(x, 0)
          attr(y, "class") <- oldClass(x)
          return(y)
        }
        if (missing(i)) {
          if (drop && !has.j && length(x) == 1) 
            return(.subset2(x, 1))
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (has.j && !is.character(j) && anyNA(nm)) {
            names(nm) <- names(x) <- seq_along(x)
            y <- .subset(x, j)
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
            cols <- names(y) <- nm[cols]
          }
          else {
            y <- if (has.j) 
              .subset(x, j)
            else x
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
          }
          if (drop && length(y) == 1) 
            return(.subset2(y, 1))
          if (anyDuplicated(cols)) 
            names(y) <- make.unique(cols)
          nrow <- .row_names_info(x, 2)
          if (drop && !mdrop && nrow == 1) 
            return(structure(y, class = NULL, row.names = NULL))
          else {
            attr(y, "class") <- oldClass(x)
            attr(y, "row.names") <- .row_names_info(x, 0)
            return(y)
          }
        }
        xx <- x
        cols <- names(xx)
        x <- vector("list", length(x))
        x <- .Internal(copyDFattr(xx, x))
        oldClass(x) <- attr(x, "row.names") <- NULL
        if (has.j) {
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (!is.character(j) && anyNA(nm)) 
            names(nm) <- names(x) <- seq_along(x)
          x <- x[j]
          cols <- names(x)
          if (drop && length(x) == 1) {
            if (is.character(i)) {
              rows <- attr(xx, "row.names")
              i <- pmatch(i, rows, duplicates.ok = TRUE)
            }
            xj <- .subset2(.subset(xx, j), 1)
            return(if (length(dim(xj)) != 2) xj[i] else xj[i, , drop = FALSE])
          }
          if (anyNA(cols)) 
            stop("undefined columns selected")
          if (!is.null(names(nm))) 
            cols <- names(x) <- nm[cols]
          nxx <- structure(seq_along(xx), names = names(xx))
          sxx <- match(nxx[j], seq_along(xx))
        }
        else sxx <- seq_along(x)
        rows <- NULL
        if (is.character(i)) {
          rows <- attr(xx, "row.names")
          i <- pmatch(i, rows, duplicates.ok = TRUE)
        }
        for (j in seq_along(x)) {
          xj <- xx[[sxx[j]]]
          x[[j]] <- if (length(dim(xj)) != 2) 
            xj[i]
          else xj[i, , drop = FALSE]
        }
        if (drop) {
          n <- length(x)
          if (n == 1) 
            return(x[[1]])
          if (n > 1) {
            xj <- x[[1]]
            nrow <- if (length(dim(xj)) == 2) 
              dim(xj)[1]
            else length(xj)
            drop <- !mdrop && nrow == 1
          }
          else drop <- FALSE
        }
        if (!drop) {
          if (is.null(rows)) 
            rows <- attr(xx, "row.names")
          rows <- rows[i]
          if ((ina <- anyNA(rows)) | (dup <- anyDuplicated(rows))) {
            if (!dup && is.character(rows)) 
              dup <- "NA" %in% rows
            if (ina) 
              rows[is.na(rows)] <- "NA"
            if (dup) 
              rows <- make.unique(as.character(rows))
          }
          if (has.j && anyDuplicated(nm <- names(x))) 
            names(x) <- make.unique(nm)
          if (is.null(rows)) 
            rows <- attr(xx, "row.names")[i]
          attr(x, "row.names") <- rows
          oldClass(x) <- oldClass(xx)
        }
        x
      }, function (x, i, j, drop = if (missing(i)) TRUE else length(cols) == 1) 
      {
        mdrop <- missing(drop)
        Narg <- nargs() - !mdrop
        has.j <- !missing(j)
        if (!all(names(sys.call()) %in% c("", "drop")) && !isS4(x)) 
          warning("named arguments other than 'drop' are discouraged")
        if (Narg < 3) {
          if (!mdrop) 
            warning("'drop' argument will be ignored")
          if (missing(i)) 
            return(x)
          if (is.matrix(i)) 
            return(as.matrix(x)[i])
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (!is.character(i) && anyNA(nm)) {
            names(nm) <- names(x) <- seq_along(x)
            y <- NextMethod("[")
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
            cols <- names(y) <- nm[cols]
          }
          else {
            y <- NextMethod("[")
            cols <- names(y)
            if (!is.null(cols) && anyNA(cols)) 
              stop("undefined columns selected")
          }
          if (anyDuplicated(cols)) 
            names(y) <- make.unique(cols)
          attr(y, "row.names") <- .row_names_info(x, 0)
          attr(y, "class") <- oldClass(x)
          return(y)
        }
        if (missing(i)) {
          if (drop && !has.j && length(x) == 1) 
            return(.subset2(x, 1))
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (has.j && !is.character(j) && anyNA(nm)) {
            names(nm) <- names(x) <- seq_along(x)
            y <- .subset(x, j)
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
            cols <- names(y) <- nm[cols]
          }
          else {
            y <- if (has.j) 
              .subset(x, j)
            else x
            cols <- names(y)
            if (anyNA(cols)) 
              stop("undefined columns selected")
          }
          if (drop && length(y) == 1) 
            return(.subset2(y, 1))
          if (anyDuplicated(cols)) 
            names(y) <- make.unique(cols)
          nrow <- .row_names_info(x, 2)
          if (drop && !mdrop && nrow == 1) 
            return(structure(y, class = NULL, row.names = NULL))
          else {
            attr(y, "class") <- oldClass(x)
            attr(y, "row.names") <- .row_names_info(x, 0)
            return(y)
          }
        }
        xx <- x
        cols <- names(xx)
        x <- vector("list", length(x))
        x <- .Internal(copyDFattr(xx, x))
        oldClass(x) <- attr(x, "row.names") <- NULL
        if (has.j) {
          nm <- names(x)
          if (is.null(nm)) 
            nm <- character()
          if (!is.character(j) && anyNA(nm)) 
            names(nm) <- names(x) <- seq_along(x)
          x <- x[j]
          cols <- names(x)
          if (drop && length(x) == 1) {
            if (is.character(i)) {
              rows <- attr(xx, "row.names")
              i <- pmatch(i, rows, duplicates.ok = TRUE)
            }
            xj <- .subset2(.subset(xx, j), 1)
            return(if (length(dim(xj)) != 2) xj[i] else xj[i, , drop = FALSE])
          }
          if (anyNA(cols)) 
            stop("undefined columns selected")
          if (!is.null(names(nm))) 
            cols <- names(x) <- nm[cols]
          nxx <- structure(seq_along(xx), names = names(xx))
          sxx <- match(nxx[j], seq_along(xx))
        }
        else sxx <- seq_along(x)
        rows <- NULL
        if (is.character(i)) {
          rows <- attr(xx, "row.names")
          i <- pmatch(i, rows, duplicates.ok = TRUE)
        }
        for (j in seq_along(x)) {
          xj <- xx[[sxx[j]]]
          x[[j]] <- if (length(dim(xj)) != 2) 
            xj[i]
          else xj[i, , drop = FALSE]
        }
        if (drop) {
          n <- length(x)
          if (n == 1) 
            return(x[[1]])
          if (n > 1) {
            xj <- x[[1]]
            nrow <- if (length(dim(xj)) == 2) 
              dim(xj)[1]
            else length(xj)
            drop <- !mdrop && nrow == 1
          }
          else drop <- FALSE
        }
        if (!drop) {
          if (is.null(rows)) 
            rows <- attr(xx, "row.names")
          rows <- rows[i]
          if ((ina <- anyNA(rows)) | (dup <- anyDuplicated(rows))) {
            if (!dup && is.character(rows)) 
              dup <- "NA" %in% rows
            if (ina) 
              rows[is.na(rows)] <- "NA"
            if (dup) 
              rows <- make.unique(as.character(rows))
          }
          if (has.j && anyDuplicated(nm <- names(x))) 
            names(x) <- make.unique(nm)
          if (is.null(rows)) 
            rows <- attr(xx, "row.names")[i]
          attr(x, "row.names") <- rows
          oldClass(x) <- oldClass(xx)
        }
        x
      })
      c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
      c(TRUE, FALSE, FALSE)
      c(FALSE, TRUE, TRUE)
155)[.Date
        list(`package:base` = function (x, ..., drop = TRUE) 
        {
          .Date(NextMethod("["), oldClass(x))
        }, function (x, ..., drop = TRUE) 
        {
          .Date(NextMethod("["), oldClass(x))
        }, function (x, ..., drop = TRUE) 
        {
          .Date(NextMethod("["), oldClass(x))
        })
        c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
        c(TRUE, FALSE, FALSE)
        c(FALSE, TRUE, TRUE)
156)[.difftime
          list(`package:base` = function (x, ..., drop = TRUE) 
            .difftime(NextMethod("["), attr(x, "units"), oldClass(x)), function (x, ..., drop = TRUE) 
              .difftime(NextMethod("["), attr(x, "units"), oldClass(x)), function (x, ..., drop = TRUE) 
                .difftime(NextMethod("["), attr(x, "units"), oldClass(x)))
          c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
          c(TRUE, FALSE, FALSE)
          c(FALSE, TRUE, TRUE)
157)[.Dlist
            list(`package:base` = function (x, i, ...) 
              structure(NextMethod("["), class = class(x)), function (x, i, ...) 
                structure(NextMethod("["), class = class(x)), function (x, i, ...) 
                  structure(NextMethod("["), class = class(x)))
            c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
            c(TRUE, FALSE, FALSE)
            c(FALSE, TRUE, TRUE)
            [.DLLInfoList
              list(`package:base` = function (x, ...) 
                structure(NextMethod("["), class = class(x)), function (x, ...) 
                  structure(NextMethod("["), class = class(x)), function (x, ...) 
                    structure(NextMethod("["), class = class(x)))
              c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
              c(TRUE, FALSE, FALSE)
              c(FALSE, TRUE, TRUE)
158)[.factor
                list(`package:base` = function (x, ..., drop = FALSE) 
                {
                  y <- NextMethod("[")
                  attr(y, "contrasts") <- attr(x, "contrasts")
                  attr(y, "levels") <- attr(x, "levels")
                  class(y) <- oldClass(x)
                  if (drop) 
                    factor(y, exclude = if (anyNA(levels(x))) 
                      NULL
                      else NA)
                  else y
                }, function (x, ..., drop = FALSE) 
                {
                  y <- NextMethod("[")
                  attr(y, "contrasts") <- attr(x, "contrasts")
                  attr(y, "levels") <- attr(x, "levels")
                  class(y) <- oldClass(x)
                  if (drop) 
                    factor(y, exclude = if (anyNA(levels(x))) 
                      NULL
                      else NA)
                  else y
                }, function (x, ..., drop = FALSE) 
                {
                  y <- NextMethod("[")
                  attr(y, "contrasts") <- attr(x, "contrasts")
                  attr(y, "levels") <- attr(x, "levels")
                  class(y) <- oldClass(x)
                  if (drop) 
                    factor(y, exclude = if (anyNA(levels(x))) 
                      NULL
                      else NA)
                  else y
                })
                c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                c(TRUE, FALSE, FALSE)
                c(FALSE, TRUE, TRUE)
159)[.hexmode
                  list(`package:base` = function (x, i) 
                  {
                    cl <- oldClass(x)
                    y <- NextMethod("[")
                    oldClass(y) <- cl
                    y
                  }, function (x, i) 
                  {
                    cl <- oldClass(x)
                    y <- NextMethod("[")
                    oldClass(y) <- cl
                    y
                  }, function (x, i) 
                  {
                    cl <- oldClass(x)
                    y <- NextMethod("[")
                    oldClass(y) <- cl
                    y
                  })
                  c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                  c(TRUE, FALSE, FALSE)
                  c(FALSE, TRUE, TRUE)
160)[.listof
                    list(`package:base` = function (x, i, ...) 
                      structure(NextMethod("["), class = class(x)), function (x, i, ...) 
                        structure(NextMethod("["), class = class(x)), function (x, i, ...) 
                          structure(NextMethod("["), class = class(x)))
                    c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                    c(TRUE, FALSE, FALSE)
                    c(FALSE, TRUE, TRUE)
161)[.noquote
                      list(`package:base` = function (x, ...) 
                      {
                        attr <- attributes(x)
                        r <- unclass(x)[...]
                        attributes(r) <- c(attributes(r), attr[is.na(match(names(attr), c("dim", "dimnames", "names")))])
                        r
                      }, function (x, ...) 
                      {
                        attr <- attributes(x)
                        r <- unclass(x)[...]
                        attributes(r) <- c(attributes(r), attr[is.na(match(names(attr), c("dim", "dimnames", "names")))])
                        r
                      }, function (x, ...) 
                      {
                        attr <- attributes(x)
                        r <- unclass(x)[...]
                        attributes(r) <- c(attributes(r), attr[is.na(match(names(attr), c("dim", "dimnames", "names")))])
                        r
                      })
                      c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                      c(TRUE, FALSE, FALSE)
                      c(FALSE, TRUE, TRUE)
162)[.numeric_version
                        list(`package:base` = function (x, i, j) 
                        {
                          y <- if (missing(j)) 
                            unclass(x)[i]
                          else lapply(unclass(x)[i], `[`, j)
                          bad <- vapply(y, function(t) is.null(t) || anyNA(t), NA)
                          if (any(bad)) 
                            y[bad] <- rep.int(list(integer()), length(bad))
                          class(y) <- class(x)
                          y
                        }, function (x, i, j) 
                        {
                          y <- if (missing(j)) 
                            unclass(x)[i]
                          else lapply(unclass(x)[i], `[`, j)
                          bad <- vapply(y, function(t) is.null(t) || anyNA(t), NA)
                          if (any(bad)) 
                            y[bad] <- rep.int(list(integer()), length(bad))
                          class(y) <- class(x)
                          y
                        }, function (x, i, j) 
                        {
                          y <- if (missing(j)) 
                            unclass(x)[i]
                          else lapply(unclass(x)[i], `[`, j)
                          bad <- vapply(y, function(t) is.null(t) || anyNA(t), NA)
                          if (any(bad)) 
                            y[bad] <- rep.int(list(integer()), length(bad))
                          class(y) <- class(x)
                          y
                        })
                        c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                        c(TRUE, FALSE, FALSE)
                        c(FALSE, TRUE, TRUE)
163)[.octmode
                          list(`package:base` = function (x, i) 
                          {
                            cl <- oldClass(x)
                            y <- NextMethod("[")
                            oldClass(y) <- cl
                            y
                          }, function (x, i) 
                          {
                            cl <- oldClass(x)
                            y <- NextMethod("[")
                            oldClass(y) <- cl
                            y
                          }, function (x, i) 
                          {
                            cl <- oldClass(x)
                            y <- NextMethod("[")
                            oldClass(y) <- cl
                            y
                          })
                          c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                          c(TRUE, FALSE, FALSE)
                          c(FALSE, TRUE, TRUE)
164)[.POSIXct
                            list(`package:base` = function (x, ..., drop = TRUE) 
                              .POSIXct(NextMethod("["), attr(x, "tzone"), oldClass(x)), function (x, ..., drop = TRUE) 
                                .POSIXct(NextMethod("["), attr(x, "tzone"), oldClass(x)), function (x, ..., drop = TRUE) 
                                  .POSIXct(NextMethod("["), attr(x, "tzone"), oldClass(x)))
                            c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                            c(TRUE, FALSE, FALSE)
                            c(FALSE, TRUE, TRUE)
165)[.POSIXlt
                              list(`package:base` = function (x, i, j, drop = TRUE) 
                              {
                                if (!(mj <- missing(j))) 
                                  if (!is.character(j) || (length(j) != 1)) 
                                    stop("component subscript must be a character string")
                                if (missing(i)) {
                                  if (mj) 
                                    x
                                  else unclass(x)[[j]]
                                }
                                else {
                                  if (is.character(i)) 
                                    i <- match(i, names(x), incomparables = c("", NA))
                                  if (mj) 
                                    .POSIXlt(lapply(X = unclass(x), FUN = `[`, i, drop = drop), attr(x, "tzone"), oldClass(x))
                                  else unclass(x)[[j]][i]
                                }
                              }, function (x, i, j, drop = TRUE) 
                              {
                                if (!(mj <- missing(j))) 
                                  if (!is.character(j) || (length(j) != 1)) 
                                    stop("component subscript must be a character string")
                                if (missing(i)) {
                                  if (mj) 
                                    x
                                  else unclass(x)[[j]]
                                }
                                else {
                                  if (is.character(i)) 
                                    i <- match(i, names(x), incomparables = c("", NA))
                                  if (mj) 
                                    .POSIXlt(lapply(X = unclass(x), FUN = `[`, i, drop = drop), attr(x, "tzone"), oldClass(x))
                                  else unclass(x)[[j]][i]
                                }
                              }, function (x, i, j, drop = TRUE) 
                              {
                                if (!(mj <- missing(j))) 
                                  if (!is.character(j) || (length(j) != 1)) 
                                    stop("component subscript must be a character string")
                                if (missing(i)) {
                                  if (mj) 
                                    x
                                  else unclass(x)[[j]]
                                }
                                else {
                                  if (is.character(i)) 
                                    i <- match(i, names(x), incomparables = c("", NA))
                                  if (mj) 
                                    .POSIXlt(lapply(X = unclass(x), FUN = `[`, i, drop = drop), attr(x, "tzone"), oldClass(x))
                                  else unclass(x)[[j]][i]
                                }
                              })
                              c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                              c(TRUE, FALSE, FALSE)
                              c(FALSE, TRUE, TRUE)
166)[.simple.list
                                list(`package:base` = function (x, i, ...) 
                                  structure(NextMethod("["), class = class(x)), function (x, i, ...) 
                                    structure(NextMethod("["), class = class(x)), function (x, i, ...) 
                                      structure(NextMethod("["), class = class(x)))
                                c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                                c(TRUE, FALSE, FALSE)
                                c(FALSE, TRUE, TRUE)
167)[.table
                                  list(`package:base` = function (x, i, j, ..., drop = TRUE) 
                                  {
                                    ret <- NextMethod()
                                    ldr <- length(dim(ret))
                                    if ((ldr > 1) || (ldr == length(dim(x)))) 
                                      class(ret) <- "table"
                                    ret
                                  }, function (x, i, j, ..., drop = TRUE) 
                                  {
                                    ret <- NextMethod()
                                    ldr <- length(dim(ret))
                                    if ((ldr > 1) || (ldr == length(dim(x)))) 
                                      class(ret) <- "table"
                                    ret
                                  }, function (x, i, j, ..., drop = TRUE) 
                                  {
                                    ret <- NextMethod()
                                    ldr <- length(dim(ret))
                                    if ((ldr > 1) || (ldr == length(dim(x)))) 
                                      class(ret) <- "table"
                                    ret
                                  })
                                  c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
                                  c(TRUE, FALSE, FALSE)
                                  c(FALSE, TRUE, TRUE)
                                  168)[.warnings
                                    list(`package:base` = function (x, ...) 
  structure(NextMethod("["), class = "warnings"), function (x, ...) 
    structure(NextMethod("["), class = "warnings"), function (x, ...) 
      structure(NextMethod("["), class = "warnings"))
c("package:base", "registered S3 method for [ from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
168)[[
  list(`package:base` = .Primitive("[["), .Primitive("[["))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
169)[[.data.frame
    list(`package:base` = function (x, ..., exact = TRUE) 
    {
      na <- nargs() - !missing(exact)
      if (!all(names(sys.call()) %in% c("", "exact"))) 
        warning("named arguments other than 'exact' are discouraged")
      if (na < 3) 
        (function(x, i, exact) if (is.matrix(i)) 
          as.matrix(x)[[i]]
         else .subset2(x, i, exact = exact))(x, ..., exact = exact)
      else {
        col <- .subset2(x, ..2, exact = exact)
        i <- if (is.character(..1)) 
          pmatch(..1, row.names(x), duplicates.ok = TRUE)
        else ..1
        col[[i, exact = exact]]
      }
    }, function (x, ..., exact = TRUE) 
    {
      na <- nargs() - !missing(exact)
      if (!all(names(sys.call()) %in% c("", "exact"))) 
        warning("named arguments other than 'exact' are discouraged")
      if (na < 3) 
        (function(x, i, exact) if (is.matrix(i)) 
          as.matrix(x)[[i]]
         else .subset2(x, i, exact = exact))(x, ..., exact = exact)
      else {
        col <- .subset2(x, ..2, exact = exact)
        i <- if (is.character(..1)) 
          pmatch(..1, row.names(x), duplicates.ok = TRUE)
        else ..1
        col[[i, exact = exact]]
      }
    }, function (x, ..., exact = TRUE) 
    {
      na <- nargs() - !missing(exact)
      if (!all(names(sys.call()) %in% c("", "exact"))) 
        warning("named arguments other than 'exact' are discouraged")
      if (na < 3) 
        (function(x, i, exact) if (is.matrix(i)) 
          as.matrix(x)[[i]]
         else .subset2(x, i, exact = exact))(x, ..., exact = exact)
      else {
        col <- .subset2(x, ..2, exact = exact)
        i <- if (is.character(..1)) 
          pmatch(..1, row.names(x), duplicates.ok = TRUE)
        else ..1
        col[[i, exact = exact]]
      }
    })
    c("package:base", "registered S3 method for [[ from namespace base", "namespace:base")
    c(TRUE, FALSE, FALSE)
    c(FALSE, TRUE, TRUE)
170)[[.Date
      list(`package:base` = function (x, ..., drop = TRUE) 
      {
        .Date(NextMethod("[["), oldClass(x))
      }, function (x, ..., drop = TRUE) 
      {
        .Date(NextMethod("[["), oldClass(x))
      }, function (x, ..., drop = TRUE) 
      {
        .Date(NextMethod("[["), oldClass(x))
      })
      c("package:base", "registered S3 method for [[ from namespace base", "namespace:base")
      c(TRUE, FALSE, FALSE)
      c(FALSE, TRUE, TRUE)
171)[[.factor
        list(`package:base` = function (x, ...) 
        {
          y <- NextMethod("[[")
          attr(y, "contrasts") <- attr(x, "contrasts")
          attr(y, "levels") <- attr(x, "levels")
          class(y) <- oldClass(x)
          y
        }, function (x, ...) 
        {
          y <- NextMethod("[[")
          attr(y, "contrasts") <- attr(x, "contrasts")
          attr(y, "levels") <- attr(x, "levels")
          class(y) <- oldClass(x)
          y
        }, function (x, ...) 
        {
          y <- NextMethod("[[")
          attr(y, "contrasts") <- attr(x, "contrasts")
          attr(y, "levels") <- attr(x, "levels")
          class(y) <- oldClass(x)
          y
        })
        c("package:base", "registered S3 method for [[ from namespace base", "namespace:base")
        c(TRUE, FALSE, FALSE)
        c(FALSE, TRUE, TRUE)
172)[[.numeric_version
          list(`package:base` = function (x, ..., exact = NA) 
          {
            if (...length() < 2) 
              structure(list(unclass(x)[[..., exact = exact]]), class = oldClass(x))
            else unclass(x)[[..1, exact = exact]][..2]
          }, function (x, ..., exact = NA) 
          {
            if (...length() < 2) 
              structure(list(unclass(x)[[..., exact = exact]]), class = oldClass(x))
            else unclass(x)[[..1, exact = exact]][..2]
          }, function (x, ..., exact = NA) 
          {
            if (...length() < 2) 
              structure(list(unclass(x)[[..., exact = exact]]), class = oldClass(x))
            else unclass(x)[[..1, exact = exact]][..2]
          })
          c("package:base", "registered S3 method for [[ from namespace base", "namespace:base")
          c(TRUE, FALSE, FALSE)
          c(FALSE, TRUE, TRUE)
173)[[.POSIXct
            list(`package:base` = function (x, ..., drop = TRUE) 
              .POSIXct(NextMethod("[["), attr(x, "tzone"), oldClass(x)), function (x, ..., drop = TRUE) 
                .POSIXct(NextMethod("[["), attr(x, "tzone"), oldClass(x)), function (x, ..., drop = TRUE) 
                  .POSIXct(NextMethod("[["), attr(x, "tzone"), oldClass(x)))
            c("package:base", "registered S3 method for [[ from namespace base", "namespace:base")
            c(TRUE, FALSE, FALSE)
            c(FALSE, TRUE, TRUE)
174)[[.POSIXlt
              list(`package:base` = function (x, i, drop = TRUE) 
              {
                if (!missing(i) && is.character(i)) {
                  i <- match(i, names(x), incomparables = c("", NA))
                }
                .POSIXlt(lapply(X = unclass(x), FUN = `[[`, i, drop = drop), attr(x, "tzone"), oldClass(x))
              }, function (x, i, drop = TRUE) 
              {
                if (!missing(i) && is.character(i)) {
                  i <- match(i, names(x), incomparables = c("", NA))
                }
                .POSIXlt(lapply(X = unclass(x), FUN = `[[`, i, drop = drop), attr(x, "tzone"), oldClass(x))
              }, function (x, i, drop = TRUE) 
              {
                if (!missing(i) && is.character(i)) {
                  i <- match(i, names(x), incomparables = c("", NA))
                }
                .POSIXlt(lapply(X = unclass(x), FUN = `[[`, i, drop = drop), attr(x, "tzone"), oldClass(x))
              })
              c("package:base", "registered S3 method for [[ from namespace base", "namespace:base")
              c(TRUE, FALSE, FALSE)
              c(FALSE, TRUE, TRUE)
175)[[<-
                  list(`package:base` = .Primitive("[[<-"), .Primitive("[[<-"))
                c("package:base", "namespace:base")
                c(TRUE, FALSE)
                c(FALSE, TRUE)
176)[[<-.data.frame
                  list(`package:base` = function (x, i, j, value) 
                  {
                    if (!all(names(sys.call()) %in% c("", "value"))) 
                      warning("named arguments are discouraged")
                    cl <- oldClass(x)
                    class(x) <- NULL
                    nrows <- .row_names_info(x, 2)
                    if (is.atomic(value) && !is.null(names(value))) 
                      names(value) <- NULL
                    if (nargs() < 4) {
                      nc <- length(x)
                      if (!is.null(value)) {
                        N <- NROW(value)
                        if (N > nrows) 
                          stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
                        if (N < nrows) 
                          if (N > 0 && (nrows%%N == 0) && length(dim(value)) <= 1) 
                            value <- rep(value, length.out = nrows)
                        else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
                      }
                      x[[i]] <- value
                      if (length(x) > nc) {
                        nc <- length(x)
                        if (names(x)[nc] == "") 
                          names(x)[nc] <- paste0("V", nc)
                        names(x) <- make.unique(names(x))
                      }
                      class(x) <- cl
                      return(x)
                    }
                    if (missing(i) || missing(j)) 
                      stop("only valid calls are x[[j]] <- value or x[[i,j]] <- value")
                    rows <- attr(x, "row.names")
                    nvars <- length(x)
                    if (n <- is.character(i)) {
                      ii <- match(i, rows)
                      n <- sum(new.rows <- is.na(ii))
                      if (n > 0) {
                        ii[new.rows] <- seq.int(from = nrows + 1, length.out = n)
                        new.rows <- i[new.rows]
                      }
                      i <- ii
                    }
                    if (all(i >= 0) && (nn <- max(i)) > nrows) {
                      if (n == 0) {
                        nrr <- (nrows + 1):nn
                        if (inherits(value, "data.frame") && (dim(value)[1]) >= length(nrr)) {
                          new.rows <- attr(value, "row.names")[seq_len(nrr)]
                          repl <- duplicated(new.rows) | match(new.rows, rows, 0)
                          if (any(repl)) 
                            new.rows[repl] <- nrr[repl]
                        }
                        else new.rows <- nrr
                      }
                      x <- xpdrows.data.frame(x, rows, new.rows)
                      rows <- attr(x, "row.names")
                      nrows <- length(rows)
                    }
                    iseq <- seq_len(nrows)[i]
                    if (anyNA(iseq)) 
                      stop("non-existent rows not allowed")
                    if (is.character(j)) {
                      if ("" %in% j) 
                        stop("column name \"\" cannot match any column")
                      jseq <- match(j, names(x))
                      if (anyNA(jseq)) 
                        stop(gettextf("replacing element in non-existent column: %s", j[is.na(jseq)]), domain = NA)
                    }
                    else if (is.logical(j) || min(j) < 0) 
                      jseq <- seq_along(x)[j]
                    else {
                      jseq <- j
                      if (max(jseq) > nvars) 
                        stop(gettextf("replacing element in non-existent column: %s", jseq[jseq > nvars]), domain = NA)
                    }
                    if (length(iseq) > 1 || length(jseq) > 1) 
                      stop("only a single element should be replaced")
                    x[[jseq]][[iseq]] <- value
                    class(x) <- cl
                    x
                  }, function (x, i, j, value) 
                  {
                    if (!all(names(sys.call()) %in% c("", "value"))) 
                      warning("named arguments are discouraged")
                    cl <- oldClass(x)
                    class(x) <- NULL
                    nrows <- .row_names_info(x, 2)
                    if (is.atomic(value) && !is.null(names(value))) 
                      names(value) <- NULL
                    if (nargs() < 4) {
                      nc <- length(x)
                      if (!is.null(value)) {
                        N <- NROW(value)
                        if (N > nrows) 
                          stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
                        if (N < nrows) 
                          if (N > 0 && (nrows%%N == 0) && length(dim(value)) <= 1) 
                            value <- rep(value, length.out = nrows)
                        else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
                      }
                      x[[i]] <- value
                      if (length(x) > nc) {
                        nc <- length(x)
                        if (names(x)[nc] == "") 
                          names(x)[nc] <- paste0("V", nc)
                        names(x) <- make.unique(names(x))
                      }
                      class(x) <- cl
                      return(x)
                    }
                    if (missing(i) || missing(j)) 
                      stop("only valid calls are x[[j]] <- value or x[[i,j]] <- value")
                    rows <- attr(x, "row.names")
                    nvars <- length(x)
                    if (n <- is.character(i)) {
                      ii <- match(i, rows)
                      n <- sum(new.rows <- is.na(ii))
                      if (n > 0) {
                        ii[new.rows] <- seq.int(from = nrows + 1, length.out = n)
                        new.rows <- i[new.rows]
                      }
                      i <- ii
                    }
                    if (all(i >= 0) && (nn <- max(i)) > nrows) {
                      if (n == 0) {
                        nrr <- (nrows + 1):nn
                        if (inherits(value, "data.frame") && (dim(value)[1]) >= length(nrr)) {
                          new.rows <- attr(value, "row.names")[seq_len(nrr)]
                          repl <- duplicated(new.rows) | match(new.rows, rows, 0)
                          if (any(repl)) 
                            new.rows[repl] <- nrr[repl]
                        }
                        else new.rows <- nrr
                      }
                      x <- xpdrows.data.frame(x, rows, new.rows)
                      rows <- attr(x, "row.names")
                      nrows <- length(rows)
                    }
                    iseq <- seq_len(nrows)[i]
                    if (anyNA(iseq)) 
                      stop("non-existent rows not allowed")
                    if (is.character(j)) {
                      if ("" %in% j) 
                        stop("column name \"\" cannot match any column")
                      jseq <- match(j, names(x))
                      if (anyNA(jseq)) 
                        stop(gettextf("replacing element in non-existent column: %s", j[is.na(jseq)]), domain = NA)
                    }
                    else if (is.logical(j) || min(j) < 0) 
                      jseq <- seq_along(x)[j]
                    else {
                      jseq <- j
                      if (max(jseq) > nvars) 
                        stop(gettextf("replacing element in non-existent column: %s", jseq[jseq > nvars]), domain = NA)
                    }
                    if (length(iseq) > 1 || length(jseq) > 1) 
                      stop("only a single element should be replaced")
                    x[[jseq]][[iseq]] <- value
                    class(x) <- cl
                    x
                  }, function (x, i, j, value) 
                  {
                    if (!all(names(sys.call()) %in% c("", "value"))) 
                      warning("named arguments are discouraged")
                    cl <- oldClass(x)
                    class(x) <- NULL
                    nrows <- .row_names_info(x, 2)
                    if (is.atomic(value) && !is.null(names(value))) 
                      names(value) <- NULL
                    if (nargs() < 4) {
                      nc <- length(x)
                      if (!is.null(value)) {
                        N <- NROW(value)
                        if (N > nrows) 
                          stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
                        if (N < nrows) 
                          if (N > 0 && (nrows%%N == 0) && length(dim(value)) <= 1) 
                            value <- rep(value, length.out = nrows)
                        else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
                      }
                      x[[i]] <- value
                      if (length(x) > nc) {
                        nc <- length(x)
                        if (names(x)[nc] == "") 
                          names(x)[nc] <- paste0("V", nc)
                        names(x) <- make.unique(names(x))
                      }
                      class(x) <- cl
                      return(x)
                    }
                    if (missing(i) || missing(j)) 
                      stop("only valid calls are x[[j]] <- value or x[[i,j]] <- value")
                    rows <- attr(x, "row.names")
                    nvars <- length(x)
                    if (n <- is.character(i)) {
                      ii <- match(i, rows)
                      n <- sum(new.rows <- is.na(ii))
                      if (n > 0) {
                        ii[new.rows] <- seq.int(from = nrows + 1, length.out = n)
                        new.rows <- i[new.rows]
                      }
                      i <- ii
                    }
                    if (all(i >= 0) && (nn <- max(i)) > nrows) {
                      if (n == 0) {
                        nrr <- (nrows + 1):nn
                        if (inherits(value, "data.frame") && (dim(value)[1]) >= length(nrr)) {
                          new.rows <- attr(value, "row.names")[seq_len(nrr)]
                          repl <- duplicated(new.rows) | match(new.rows, rows, 0)
                          if (any(repl)) 
                            new.rows[repl] <- nrr[repl]
                        }
                        else new.rows <- nrr
                      }
                      x <- xpdrows.data.frame(x, rows, new.rows)
                      rows <- attr(x, "row.names")
                      nrows <- length(rows)
                    }
                    iseq <- seq_len(nrows)[i]
                    if (anyNA(iseq)) 
                      stop("non-existent rows not allowed")
                    if (is.character(j)) {
                      if ("" %in% j) 
                        stop("column name \"\" cannot match any column")
                      jseq <- match(j, names(x))
                      if (anyNA(jseq)) 
                        stop(gettextf("replacing element in non-existent column: %s", j[is.na(jseq)]), domain = NA)
                    }
                    else if (is.logical(j) || min(j) < 0) 
                      jseq <- seq_along(x)[j]
                    else {
                      jseq <- j
                      if (max(jseq) > nvars) 
                        stop(gettextf("replacing element in non-existent column: %s", jseq[jseq > nvars]), domain = NA)
                    }
                    if (length(iseq) > 1 || length(jseq) > 1) 
                      stop("only a single element should be replaced")
                    x[[jseq]][[iseq]] <- value
                    class(x) <- cl
                    x
                  })
                  c("package:base", "registered S3 method for [[<- from namespace base", "namespace:base")
                  c(TRUE, FALSE, FALSE)
                  c(FALSE, TRUE, TRUE)
178)[[<-.factor
                    list(`package:base` = function (x, ..., value) 
                    {
                      lx <- levels(x)
                      cx <- oldClass(x)
                      if (is.factor(value)) 
                        value <- levels(value)[value]
                      m <- match(value, lx)
                      if (any(is.na(m) & !is.na(value))) 
                        warning("invalid factor level, NA generated")
                      class(x) <- NULL
                      x[[...]] <- m
                      attr(x, "levels") <- lx
                      class(x) <- cx
                      x
                    }, function (x, ..., value) 
                    {
                      lx <- levels(x)
                      cx <- oldClass(x)
                      if (is.factor(value)) 
                        value <- levels(value)[value]
                      m <- match(value, lx)
                      if (any(is.na(m) & !is.na(value))) 
                        warning("invalid factor level, NA generated")
                      class(x) <- NULL
                      x[[...]] <- m
                      attr(x, "levels") <- lx
                      class(x) <- cx
                      x
                    }, function (x, ..., value) 
                    {
                      lx <- levels(x)
                      cx <- oldClass(x)
                      if (is.factor(value)) 
                        value <- levels(value)[value]
                      m <- match(value, lx)
                      if (any(is.na(m) & !is.na(value))) 
                        warning("invalid factor level, NA generated")
                      class(x) <- NULL
                      x[[...]] <- m
                      attr(x, "levels") <- lx
                      class(x) <- cx
                      x
                    })
c("package:base", "registered S3 method for [[<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
179)[[<-.numeric_version
  list(`package:base` = function (x, ..., value) 
  {
    z <- unclass(x)
    if (nargs() < 4) {
      if (length(..1) < 2) {
        if (is.character(value) && length(value) == 1) 
          value <- unclass(as.numeric_version(value))[[1]]
        else if (!is.integer(value)) 
          stop("invalid 'value'")
      }
      else {
        value <- as.integer(value)
        if (length(value) != 1) 
          stop("invalid 'value'")
      }
      z[[..1]] <- value
    }
    else {
      value <- as.integer(value)
      if (length(value) != 1) 
        stop("invalid 'value'")
      z[[..1]][..2] <- value
    }
    structure(z, class = oldClass(x))
  }, function (x, ..., value) 
  {
    z <- unclass(x)
    if (nargs() < 4) {
      if (length(..1) < 2) {
        if (is.character(value) && length(value) == 1) 
          value <- unclass(as.numeric_version(value))[[1]]
        else if (!is.integer(value)) 
          stop("invalid 'value'")
      }
      else {
        value <- as.integer(value)
        if (length(value) != 1) 
          stop("invalid 'value'")
      }
      z[[..1]] <- value
    }
    else {
      value <- as.integer(value)
      if (length(value) != 1) 
        stop("invalid 'value'")
      z[[..1]][..2] <- value
    }
    structure(z, class = oldClass(x))
  }, function (x, ..., value) 
  {
    z <- unclass(x)
    if (nargs() < 4) {
      if (length(..1) < 2) {
        if (is.character(value) && length(value) == 1) 
          value <- unclass(as.numeric_version(value))[[1]]
        else if (!is.integer(value)) 
          stop("invalid 'value'")
      }
      else {
        value <- as.integer(value)
        if (length(value) != 1) 
          stop("invalid 'value'")
      }
      z[[..1]] <- value
    }
    else {
      value <- as.integer(value)
      if (length(value) != 1) 
        stop("invalid 'value'")
      z[[..1]][..2] <- value
    }
    structure(z, class = oldClass(x))
  })
c("package:base", "registered S3 method for [[<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
180)[[<-.POSIXlt
  list(`package:base` = function (x, i, value) 
  {
    cl <- oldClass(x)
    class(x) <- NULL
    if (!missing(i) && is.character(i)) {
      nms <- names(x$year)
      for (n in names(x)) names(x[[n]]) <- nms
    }
    value <- unclass(as.POSIXlt(value))
    for (n in names(x)) x[[n]][[i]] <- value[[n]]
    class(x) <- cl
    x
  }, function (x, i, value) 
  {
    cl <- oldClass(x)
    class(x) <- NULL
    if (!missing(i) && is.character(i)) {
      nms <- names(x$year)
      for (n in names(x)) names(x[[n]]) <- nms
    }
    value <- unclass(as.POSIXlt(value))
    for (n in names(x)) x[[n]][[i]] <- value[[n]]
    class(x) <- cl
    x
  }, function (x, i, value) 
  {
    cl <- oldClass(x)
    class(x) <- NULL
    if (!missing(i) && is.character(i)) {
      nms <- names(x$year)
      for (n in names(x)) names(x[[n]]) <- nms
    }
    value <- unclass(as.POSIXlt(value))
    for (n in names(x)) x[[n]][[i]] <- value[[n]]
    class(x) <- cl
    x
  })
c("package:base", "registered S3 method for [[<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
181)[<-
  list(`package:base` = .Primitive("[<-"), .Primitive("[<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
182)[<-.data.frame
  list(`package:base` = function (x, i, j, value) 
  {
    if (!all(names(sys.call()) %in% c("", "value"))) 
      warning("named arguments are discouraged")
    nA <- nargs()
    if (nA == 4) {
      has.i <- !missing(i)
      has.j <- !missing(j)
    }
    else if (nA == 3) {
      if (is.atomic(value) && !is.null(names(value))) 
        names(value) <- NULL
      if (missing(i) && missing(j)) {
        i <- j <- NULL
        has.i <- has.j <- FALSE
        if (is.null(value)) 
          return(x[logical()])
      }
      else {
        if (is.numeric(i) && is.matrix(i) && ncol(i) == 2) {
          index <- rep.int(FALSE, prod(dim(x)))
          dim(index) <- dim(x)
          tryCatch(index[i] <- TRUE, error = function(e) stop(conditionMessage(e), call. = FALSE))
          o <- order(i[, 2], i[, 1])
          N <- length(value)
          if (length(o)%%N != 0) 
            warning("number of items to replace is not a multiple of replacement length")
          if (N < length(o)) 
            value <- rep(value, length.out = length(o))
          value <- value[o]
          i <- index
        }
        if (is.logical(i) && is.matrix(i) && all(dim(i) == dim(x))) {
          nreplace <- sum(i, na.rm = TRUE)
          if (!nreplace) 
            return(x)
          N <- length(value)
          if (N > 1 && N < nreplace && (nreplace%%N) == 0) 
            value <- rep(value, length.out = nreplace)
          if (N > 1 && (length(value) != nreplace)) 
            stop("'value' is the wrong length")
          n <- 0
          nv <- nrow(x)
          for (v in seq_len(dim(i)[2])) {
            thisvar <- i[, v, drop = TRUE]
            nv <- sum(thisvar, na.rm = TRUE)
            if (nv) {
              if (is.matrix(x[[v]])) 
                x[[v]][thisvar, ] <- if (N > 1) 
                  value[n + seq_len(nv)]
              else value
              else x[[v]][thisvar] <- if (N > 1) 
                value[n + seq_len(nv)]
              else value
            }
            n <- n + nv
          }
          return(x)
        }
        if (is.matrix(i)) 
          stop("unsupported matrix index in replacement")
        j <- i
        i <- NULL
        has.i <- FALSE
        has.j <- TRUE
      }
    }
    else stop("need 0, 1, or 2 subscripts")
    if ((has.j && !length(j)) || (has.i && !length(i) && !has.j)) 
      return(x)
    cl <- oldClass(x)
    class(x) <- NULL
    new.cols <- NULL
    nvars <- length(x)
    nrows <- .row_names_info(x, 2)
    if (has.i && length(i)) {
      rows <- NULL
      if (anyNA(i)) 
        stop("missing values are not allowed in subscripted assignments of data frames")
      if (char.i <- is.character(i)) {
        rows <- attr(x, "row.names")
        ii <- match(i, rows)
        nextra <- sum(new.rows <- is.na(ii))
        if (nextra > 0) {
          ii[new.rows] <- seq.int(from = nrows + 1, length.out = nextra)
          new.rows <- i[new.rows]
        }
        i <- ii
      }
      if (!is.logical(i) && (char.i && nextra || all(i >= 0) && (nn <- max(i)) > nrows)) {
        if (is.null(rows)) 
          rows <- attr(x, "row.names")
        if (!char.i) {
          nrr <- (nrows + 1):nn
          if (inherits(value, "data.frame") && (dim(value)[1]) >= length(nrr)) {
            new.rows <- attr(value, "row.names")[seq_along(nrr)]
            repl <- duplicated(new.rows) | match(new.rows, rows, 0)
            if (any(repl)) 
              new.rows[repl] <- nrr[repl]
          }
          else new.rows <- nrr
        }
        x <- xpdrows.data.frame(x, rows, new.rows)
        rows <- attr(x, "row.names")
        nrows <- length(rows)
      }
      iseq <- seq_len(nrows)[i]
      if (anyNA(iseq)) 
        stop("non-existent rows not allowed")
    }
    else iseq <- NULL
    if (has.j) {
      if (anyNA(j)) 
        stop("missing values are not allowed in subscripted assignments of data frames")
      if (is.character(j)) {
        if ("" %in% j) 
          stop("column name \"\" cannot match any column")
        jseq <- match(j, names(x))
        if (anyNA(jseq)) {
          n <- is.na(jseq)
          jseq[n] <- nvars + seq_len(sum(n))
          new.cols <- j[n]
        }
      }
      else if (is.logical(j) || min(j) < 0) 
        jseq <- seq_along(x)[j]
      else {
        jseq <- j
        if (max(jseq) > nvars) {
          new.cols <- paste0("V", seq.int(from = nvars + 1, to = max(jseq)))
          if (length(new.cols) != sum(jseq > nvars)) 
            stop("new columns would leave holes after existing columns")
          if (is.list(value) && !is.null(vnm <- names(value))) {
            p <- length(jseq)
            if (length(vnm) < p) 
              vnm <- rep_len(vnm, p)
            new.cols <- vnm[jseq > nvars]
          }
        }
      }
    }
    else jseq <- seq_along(x)
    if (has.i && !length(iseq) && all(1 <= jseq & jseq <= nvars)) 
      return(`class<-`(x, cl))
    if (anyDuplicated(jseq)) 
      stop("duplicate subscripts for columns")
    n <- length(iseq)
    if (n == 0) 
      n <- nrows
    p <- length(jseq)
    if (is.null(value)) {
      value <- list(NULL)
    }
    m <- length(value)
    if (!is.list(value)) {
      if (p == 1) {
        N <- NROW(value)
        if (N > n) 
          stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, n), domain = NA)
        if (N < n && N > 0) 
          if (n%%N == 0 && length(dim(value)) <= 1) 
            value <- rep(value, length.out = n)
        else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
        if (!is.null(names(value))) 
          names(value) <- NULL
        value <- list(value)
      }
      else {
        if (m < n * p && (m == 0 || (n * p)%%m)) 
          stop(sprintf(ngettext(m, "replacement has %d item, need %d", "replacement has %d items, need %d"), m, n * p), domain = NA)
        value <- matrix(value, n, p)
        value <- split(c(value), col(value))
      }
      dimv <- c(n, p)
    }
    else {
      value <- unclass(value)
      lens <- vapply(value, NROW, 1)
      for (k in seq_along(lens)) {
        N <- lens[k]
        if (n != N && length(dim(value[[k]])) == 2) 
          stop(sprintf(ngettext(N, "replacement element %d is a matrix/data frame of %d row, need %d", "replacement element %d is a matrix/data frame of %d rows, need %d"), k, N, n), domain = NA)
        if (N > 0 && N < n && n%%N) 
          stop(sprintf(ngettext(N, "replacement element %d has %d row, need %d", "replacement element %d has %d rows, need %d"), k, N, n), domain = NA)
        if (N > 0 && N < n) 
          value[[k]] <- rep(value[[k]], length.out = n)
        if (N > n) {
          warning(sprintf(ngettext(N, "replacement element %d has %d row to replace %d rows", "replacement element %d has %d rows to replace %d rows"), k, N, n), domain = NA)
          value[[k]] <- value[[k]][seq_len(n)]
        }
      }
      dimv <- c(n, length(value))
    }
    nrowv <- dimv[1]
    if (nrowv < n && nrowv > 0) {
      if (n%%nrowv == 0) 
        value <- value[rep_len(seq_len(nrowv), n), , drop = FALSE]
      else stop(sprintf(ngettext(nrowv, "%d row in value to replace %d rows", "%d rows in value to replace %d rows"), nrowv, n), domain = NA)
    }
    else if (nrowv > n) 
      warning(sprintf(ngettext(nrowv, "replacement data has %d row to replace %d rows", "replacement data has %d rows to replace %d rows"), nrowv, n), domain = NA)
    ncolv <- dimv[2]
    jvseq <- seq_len(p)
    if (ncolv < p) 
      jvseq <- rep_len(seq_len(ncolv), p)
    else if (p != 0 && ncolv > p) {
      warning(sprintf(ngettext(ncolv, "provided %d variable to replace %d variables", "provided %d variables to replace %d variables"), ncolv, p), domain = NA)
      new.cols <- new.cols[seq_len(p)]
    }
    if (length(new.cols)) {
      nm <- names(x)
      rows <- .row_names_info(x, 0)
      a <- attributes(x)
      a["names"] <- NULL
      x <- c(x, vector("list", length(new.cols)))
      attributes(x) <- a
      names(x) <- c(nm, new.cols)
      attr(x, "row.names") <- rows
    }
    if (has.i) 
      for (jjj in seq_len(p)) {
        jj <- jseq[jjj]
        vjj <- value[[jvseq[[jjj]]]]
        if (jj <= nvars) {
          if (length(dim(x[[jj]])) != 2) 
            x[[jj]][iseq] <- vjj
          else x[[jj]][iseq, ] <- vjj
        }
        else {
          x[[jj]] <- vjj[FALSE]
          if (length(dim(vjj)) == 2) {
            length(x[[jj]]) <- nrows * ncol(vjj)
            dim(x[[jj]]) <- c(nrows, ncol(vjj))
            x[[jj]][iseq, ] <- vjj
          }
          else {
            length(x[[jj]]) <- nrows
            x[[jj]][iseq] <- vjj
          }
        }
      }
    else if (p > 0) 
      for (jjj in p:1) {
        o <- order(jseq)
        jseq <- jseq[o]
        jvseq <- jvseq[o]
        jj <- jseq[jjj]
        v <- value[[jvseq[[jjj]]]]
        if (!is.null(v) && nrows > 0 && !length(v)) 
          length(v) <- nrows
        x[[jj]] <- v
        if (!is.null(v) && is.atomic(x[[jj]]) && !is.null(names(x[[jj]]))) 
          names(x[[jj]]) <- NULL
      }
    if (length(new.cols) > 0) {
      new.cols <- names(x)
      if (anyDuplicated(new.cols)) 
        names(x) <- make.unique(new.cols)
    }
    class(x) <- cl
    x
  }, function (x, i, j, value) 
  {
    if (!all(names(sys.call()) %in% c("", "value"))) 
      warning("named arguments are discouraged")
    nA <- nargs()
    if (nA == 4) {
      has.i <- !missing(i)
      has.j <- !missing(j)
    }
    else if (nA == 3) {
      if (is.atomic(value) && !is.null(names(value))) 
        names(value) <- NULL
      if (missing(i) && missing(j)) {
        i <- j <- NULL
        has.i <- has.j <- FALSE
        if (is.null(value)) 
          return(x[logical()])
      }
      else {
        if (is.numeric(i) && is.matrix(i) && ncol(i) == 2) {
          index <- rep.int(FALSE, prod(dim(x)))
          dim(index) <- dim(x)
          tryCatch(index[i] <- TRUE, error = function(e) stop(conditionMessage(e), call. = FALSE))
          o <- order(i[, 2], i[, 1])
          N <- length(value)
          if (length(o)%%N != 0) 
            warning("number of items to replace is not a multiple of replacement length")
          if (N < length(o)) 
            value <- rep(value, length.out = length(o))
          value <- value[o]
          i <- index
        }
        if (is.logical(i) && is.matrix(i) && all(dim(i) == dim(x))) {
          nreplace <- sum(i, na.rm = TRUE)
          if (!nreplace) 
            return(x)
          N <- length(value)
          if (N > 1 && N < nreplace && (nreplace%%N) == 0) 
            value <- rep(value, length.out = nreplace)
          if (N > 1 && (length(value) != nreplace)) 
            stop("'value' is the wrong length")
          n <- 0
          nv <- nrow(x)
          for (v in seq_len(dim(i)[2])) {
            thisvar <- i[, v, drop = TRUE]
            nv <- sum(thisvar, na.rm = TRUE)
            if (nv) {
              if (is.matrix(x[[v]])) 
                x[[v]][thisvar, ] <- if (N > 1) 
                  value[n + seq_len(nv)]
              else value
              else x[[v]][thisvar] <- if (N > 1) 
                value[n + seq_len(nv)]
              else value
            }
            n <- n + nv
          }
          return(x)
        }
        if (is.matrix(i)) 
          stop("unsupported matrix index in replacement")
        j <- i
        i <- NULL
        has.i <- FALSE
        has.j <- TRUE
      }
    }
    else stop("need 0, 1, or 2 subscripts")
    if ((has.j && !length(j)) || (has.i && !length(i) && !has.j)) 
      return(x)
    cl <- oldClass(x)
    class(x) <- NULL
    new.cols <- NULL
    nvars <- length(x)
    nrows <- .row_names_info(x, 2)
    if (has.i && length(i)) {
      rows <- NULL
      if (anyNA(i)) 
        stop("missing values are not allowed in subscripted assignments of data frames")
      if (char.i <- is.character(i)) {
        rows <- attr(x, "row.names")
        ii <- match(i, rows)
        nextra <- sum(new.rows <- is.na(ii))
        if (nextra > 0) {
          ii[new.rows] <- seq.int(from = nrows + 1, length.out = nextra)
          new.rows <- i[new.rows]
        }
        i <- ii
      }
      if (!is.logical(i) && (char.i && nextra || all(i >= 0) && (nn <- max(i)) > nrows)) {
        if (is.null(rows)) 
          rows <- attr(x, "row.names")
        if (!char.i) {
          nrr <- (nrows + 1):nn
          if (inherits(value, "data.frame") && (dim(value)[1]) >= length(nrr)) {
            new.rows <- attr(value, "row.names")[seq_along(nrr)]
            repl <- duplicated(new.rows) | match(new.rows, rows, 0)
            if (any(repl)) 
              new.rows[repl] <- nrr[repl]
          }
          else new.rows <- nrr
        }
        x <- xpdrows.data.frame(x, rows, new.rows)
        rows <- attr(x, "row.names")
        nrows <- length(rows)
      }
      iseq <- seq_len(nrows)[i]
      if (anyNA(iseq)) 
        stop("non-existent rows not allowed")
    }
    else iseq <- NULL
    if (has.j) {
      if (anyNA(j)) 
        stop("missing values are not allowed in subscripted assignments of data frames")
      if (is.character(j)) {
        if ("" %in% j) 
          stop("column name \"\" cannot match any column")
        jseq <- match(j, names(x))
        if (anyNA(jseq)) {
          n <- is.na(jseq)
          jseq[n] <- nvars + seq_len(sum(n))
          new.cols <- j[n]
        }
      }
      else if (is.logical(j) || min(j) < 0) 
        jseq <- seq_along(x)[j]
      else {
        jseq <- j
        if (max(jseq) > nvars) {
          new.cols <- paste0("V", seq.int(from = nvars + 1, to = max(jseq)))
          if (length(new.cols) != sum(jseq > nvars)) 
            stop("new columns would leave holes after existing columns")
          if (is.list(value) && !is.null(vnm <- names(value))) {
            p <- length(jseq)
            if (length(vnm) < p) 
              vnm <- rep_len(vnm, p)
            new.cols <- vnm[jseq > nvars]
          }
        }
      }
    }
    else jseq <- seq_along(x)
    if (has.i && !length(iseq) && all(1 <= jseq & jseq <= nvars)) 
      return(`class<-`(x, cl))
    if (anyDuplicated(jseq)) 
      stop("duplicate subscripts for columns")
    n <- length(iseq)
    if (n == 0) 
      n <- nrows
    p <- length(jseq)
    if (is.null(value)) {
      value <- list(NULL)
    }
    m <- length(value)
    if (!is.list(value)) {
      if (p == 1) {
        N <- NROW(value)
        if (N > n) 
          stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, n), domain = NA)
        if (N < n && N > 0) 
          if (n%%N == 0 && length(dim(value)) <= 1) 
            value <- rep(value, length.out = n)
        else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
        if (!is.null(names(value))) 
          names(value) <- NULL
        value <- list(value)
      }
      else {
        if (m < n * p && (m == 0 || (n * p)%%m)) 
          stop(sprintf(ngettext(m, "replacement has %d item, need %d", "replacement has %d items, need %d"), m, n * p), domain = NA)
        value <- matrix(value, n, p)
        value <- split(c(value), col(value))
      }
      dimv <- c(n, p)
    }
    else {
      value <- unclass(value)
      lens <- vapply(value, NROW, 1)
      for (k in seq_along(lens)) {
        N <- lens[k]
        if (n != N && length(dim(value[[k]])) == 2) 
          stop(sprintf(ngettext(N, "replacement element %d is a matrix/data frame of %d row, need %d", "replacement element %d is a matrix/data frame of %d rows, need %d"), k, N, n), domain = NA)
        if (N > 0 && N < n && n%%N) 
          stop(sprintf(ngettext(N, "replacement element %d has %d row, need %d", "replacement element %d has %d rows, need %d"), k, N, n), domain = NA)
        if (N > 0 && N < n) 
          value[[k]] <- rep(value[[k]], length.out = n)
        if (N > n) {
          warning(sprintf(ngettext(N, "replacement element %d has %d row to replace %d rows", "replacement element %d has %d rows to replace %d rows"), k, N, n), domain = NA)
          value[[k]] <- value[[k]][seq_len(n)]
        }
      }
      dimv <- c(n, length(value))
    }
    nrowv <- dimv[1]
    if (nrowv < n && nrowv > 0) {
      if (n%%nrowv == 0) 
        value <- value[rep_len(seq_len(nrowv), n), , drop = FALSE]
      else stop(sprintf(ngettext(nrowv, "%d row in value to replace %d rows", "%d rows in value to replace %d rows"), nrowv, n), domain = NA)
    }
    else if (nrowv > n) 
      warning(sprintf(ngettext(nrowv, "replacement data has %d row to replace %d rows", "replacement data has %d rows to replace %d rows"), nrowv, n), domain = NA)
    ncolv <- dimv[2]
    jvseq <- seq_len(p)
    if (ncolv < p) 
      jvseq <- rep_len(seq_len(ncolv), p)
    else if (p != 0 && ncolv > p) {
      warning(sprintf(ngettext(ncolv, "provided %d variable to replace %d variables", "provided %d variables to replace %d variables"), ncolv, p), domain = NA)
      new.cols <- new.cols[seq_len(p)]
    }
    if (length(new.cols)) {
      nm <- names(x)
      rows <- .row_names_info(x, 0)
      a <- attributes(x)
      a["names"] <- NULL
      x <- c(x, vector("list", length(new.cols)))
      attributes(x) <- a
      names(x) <- c(nm, new.cols)
      attr(x, "row.names") <- rows
    }
    if (has.i) 
      for (jjj in seq_len(p)) {
        jj <- jseq[jjj]
        vjj <- value[[jvseq[[jjj]]]]
        if (jj <= nvars) {
          if (length(dim(x[[jj]])) != 2) 
            x[[jj]][iseq] <- vjj
          else x[[jj]][iseq, ] <- vjj
        }
        else {
          x[[jj]] <- vjj[FALSE]
          if (length(dim(vjj)) == 2) {
            length(x[[jj]]) <- nrows * ncol(vjj)
            dim(x[[jj]]) <- c(nrows, ncol(vjj))
            x[[jj]][iseq, ] <- vjj
          }
          else {
            length(x[[jj]]) <- nrows
            x[[jj]][iseq] <- vjj
          }
        }
      }
    else if (p > 0) 
      for (jjj in p:1) {
        o <- order(jseq)
        jseq <- jseq[o]
        jvseq <- jvseq[o]
        jj <- jseq[jjj]
        v <- value[[jvseq[[jjj]]]]
        if (!is.null(v) && nrows > 0 && !length(v)) 
          length(v) <- nrows
        x[[jj]] <- v
        if (!is.null(v) && is.atomic(x[[jj]]) && !is.null(names(x[[jj]]))) 
          names(x[[jj]]) <- NULL
      }
    if (length(new.cols) > 0) {
      new.cols <- names(x)
      if (anyDuplicated(new.cols)) 
        names(x) <- make.unique(new.cols)
    }
    class(x) <- cl
    x
  }, function (x, i, j, value) 
  {
    if (!all(names(sys.call()) %in% c("", "value"))) 
      warning("named arguments are discouraged")
    nA <- nargs()
    if (nA == 4) {
      has.i <- !missing(i)
      has.j <- !missing(j)
    }
    else if (nA == 3) {
      if (is.atomic(value) && !is.null(names(value))) 
        names(value) <- NULL
      if (missing(i) && missing(j)) {
        i <- j <- NULL
        has.i <- has.j <- FALSE
        if (is.null(value)) 
          return(x[logical()])
      }
      else {
        if (is.numeric(i) && is.matrix(i) && ncol(i) == 2) {
          index <- rep.int(FALSE, prod(dim(x)))
          dim(index) <- dim(x)
          tryCatch(index[i] <- TRUE, error = function(e) stop(conditionMessage(e), call. = FALSE))
          o <- order(i[, 2], i[, 1])
          N <- length(value)
          if (length(o)%%N != 0) 
            warning("number of items to replace is not a multiple of replacement length")
          if (N < length(o)) 
            value <- rep(value, length.out = length(o))
          value <- value[o]
          i <- index
        }
        if (is.logical(i) && is.matrix(i) && all(dim(i) == dim(x))) {
          nreplace <- sum(i, na.rm = TRUE)
          if (!nreplace) 
            return(x)
          N <- length(value)
          if (N > 1 && N < nreplace && (nreplace%%N) == 0) 
            value <- rep(value, length.out = nreplace)
          if (N > 1 && (length(value) != nreplace)) 
            stop("'value' is the wrong length")
          n <- 0
          nv <- nrow(x)
          for (v in seq_len(dim(i)[2])) {
            thisvar <- i[, v, drop = TRUE]
            nv <- sum(thisvar, na.rm = TRUE)
            if (nv) {
              if (is.matrix(x[[v]])) 
                x[[v]][thisvar, ] <- if (N > 1) 
                  value[n + seq_len(nv)]
              else value
              else x[[v]][thisvar] <- if (N > 1) 
                value[n + seq_len(nv)]
              else value
            }
            n <- n + nv
          }
          return(x)
        }
        if (is.matrix(i)) 
          stop("unsupported matrix index in replacement")
        j <- i
        i <- NULL
        has.i <- FALSE
        has.j <- TRUE
      }
    }
    else stop("need 0, 1, or 2 subscripts")
    if ((has.j && !length(j)) || (has.i && !length(i) && !has.j)) 
      return(x)
    cl <- oldClass(x)
    class(x) <- NULL
    new.cols <- NULL
    nvars <- length(x)
    nrows <- .row_names_info(x, 2)
    if (has.i && length(i)) {
      rows <- NULL
      if (anyNA(i)) 
        stop("missing values are not allowed in subscripted assignments of data frames")
      if (char.i <- is.character(i)) {
        rows <- attr(x, "row.names")
        ii <- match(i, rows)
        nextra <- sum(new.rows <- is.na(ii))
        if (nextra > 0) {
          ii[new.rows] <- seq.int(from = nrows + 1, length.out = nextra)
          new.rows <- i[new.rows]
        }
        i <- ii
      }
      if (!is.logical(i) && (char.i && nextra || all(i >= 0) && (nn <- max(i)) > nrows)) {
        if (is.null(rows)) 
          rows <- attr(x, "row.names")
        if (!char.i) {
          nrr <- (nrows + 1):nn
          if (inherits(value, "data.frame") && (dim(value)[1]) >= length(nrr)) {
            new.rows <- attr(value, "row.names")[seq_along(nrr)]
            repl <- duplicated(new.rows) | match(new.rows, rows, 0)
            if (any(repl)) 
              new.rows[repl] <- nrr[repl]
          }
          else new.rows <- nrr
        }
        x <- xpdrows.data.frame(x, rows, new.rows)
        rows <- attr(x, "row.names")
        nrows <- length(rows)
      }
      iseq <- seq_len(nrows)[i]
      if (anyNA(iseq)) 
        stop("non-existent rows not allowed")
    }
    else iseq <- NULL
    if (has.j) {
      if (anyNA(j)) 
        stop("missing values are not allowed in subscripted assignments of data frames")
      if (is.character(j)) {
        if ("" %in% j) 
          stop("column name \"\" cannot match any column")
        jseq <- match(j, names(x))
        if (anyNA(jseq)) {
          n <- is.na(jseq)
          jseq[n] <- nvars + seq_len(sum(n))
          new.cols <- j[n]
        }
      }
      else if (is.logical(j) || min(j) < 0) 
        jseq <- seq_along(x)[j]
      else {
        jseq <- j
        if (max(jseq) > nvars) {
          new.cols <- paste0("V", seq.int(from = nvars + 1, to = max(jseq)))
          if (length(new.cols) != sum(jseq > nvars)) 
            stop("new columns would leave holes after existing columns")
          if (is.list(value) && !is.null(vnm <- names(value))) {
            p <- length(jseq)
            if (length(vnm) < p) 
              vnm <- rep_len(vnm, p)
            new.cols <- vnm[jseq > nvars]
          }
        }
      }
    }
    else jseq <- seq_along(x)
    if (has.i && !length(iseq) && all(1 <= jseq & jseq <= nvars)) 
      return(`class<-`(x, cl))
    if (anyDuplicated(jseq)) 
      stop("duplicate subscripts for columns")
    n <- length(iseq)
    if (n == 0) 
      n <- nrows
    p <- length(jseq)
    if (is.null(value)) {
      value <- list(NULL)
    }
    m <- length(value)
    if (!is.list(value)) {
      if (p == 1) {
        N <- NROW(value)
        if (N > n) 
          stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, n), domain = NA)
        if (N < n && N > 0) 
          if (n%%N == 0 && length(dim(value)) <= 1) 
            value <- rep(value, length.out = n)
        else stop(sprintf(ngettext(N, "replacement has %d row, data has %d", "replacement has %d rows, data has %d"), N, nrows), domain = NA)
        if (!is.null(names(value))) 
          names(value) <- NULL
        value <- list(value)
      }
      else {
        if (m < n * p && (m == 0 || (n * p)%%m)) 
          stop(sprintf(ngettext(m, "replacement has %d item, need %d", "replacement has %d items, need %d"), m, n * p), domain = NA)
        value <- matrix(value, n, p)
        value <- split(c(value), col(value))
      }
      dimv <- c(n, p)
    }
    else {
      value <- unclass(value)
      lens <- vapply(value, NROW, 1)
      for (k in seq_along(lens)) {
        N <- lens[k]
        if (n != N && length(dim(value[[k]])) == 2) 
          stop(sprintf(ngettext(N, "replacement element %d is a matrix/data frame of %d row, need %d", "replacement element %d is a matrix/data frame of %d rows, need %d"), k, N, n), domain = NA)
        if (N > 0 && N < n && n%%N) 
          stop(sprintf(ngettext(N, "replacement element %d has %d row, need %d", "replacement element %d has %d rows, need %d"), k, N, n), domain = NA)
        if (N > 0 && N < n) 
          value[[k]] <- rep(value[[k]], length.out = n)
        if (N > n) {
          warning(sprintf(ngettext(N, "replacement element %d has %d row to replace %d rows", "replacement element %d has %d rows to replace %d rows"), k, N, n), domain = NA)
          value[[k]] <- value[[k]][seq_len(n)]
        }
      }
      dimv <- c(n, length(value))
    }
    nrowv <- dimv[1]
    if (nrowv < n && nrowv > 0) {
      if (n%%nrowv == 0) 
        value <- value[rep_len(seq_len(nrowv), n), , drop = FALSE]
      else stop(sprintf(ngettext(nrowv, "%d row in value to replace %d rows", "%d rows in value to replace %d rows"), nrowv, n), domain = NA)
    }
    else if (nrowv > n) 
      warning(sprintf(ngettext(nrowv, "replacement data has %d row to replace %d rows", "replacement data has %d rows to replace %d rows"), nrowv, n), domain = NA)
    ncolv <- dimv[2]
    jvseq <- seq_len(p)
    if (ncolv < p) 
      jvseq <- rep_len(seq_len(ncolv), p)
    else if (p != 0 && ncolv > p) {
      warning(sprintf(ngettext(ncolv, "provided %d variable to replace %d variables", "provided %d variables to replace %d variables"), ncolv, p), domain = NA)
      new.cols <- new.cols[seq_len(p)]
    }
    if (length(new.cols)) {
      nm <- names(x)
      rows <- .row_names_info(x, 0)
      a <- attributes(x)
      a["names"] <- NULL
      x <- c(x, vector("list", length(new.cols)))
      attributes(x) <- a
      names(x) <- c(nm, new.cols)
      attr(x, "row.names") <- rows
    }
    if (has.i) 
      for (jjj in seq_len(p)) {
        jj <- jseq[jjj]
        vjj <- value[[jvseq[[jjj]]]]
        if (jj <= nvars) {
          if (length(dim(x[[jj]])) != 2) 
            x[[jj]][iseq] <- vjj
          else x[[jj]][iseq, ] <- vjj
        }
        else {
          x[[jj]] <- vjj[FALSE]
          if (length(dim(vjj)) == 2) {
            length(x[[jj]]) <- nrows * ncol(vjj)
            dim(x[[jj]]) <- c(nrows, ncol(vjj))
            x[[jj]][iseq, ] <- vjj
          }
          else {
            length(x[[jj]]) <- nrows
            x[[jj]][iseq] <- vjj
          }
        }
      }
    else if (p > 0) 
      for (jjj in p:1) {
        o <- order(jseq)
        jseq <- jseq[o]
        jvseq <- jvseq[o]
        jj <- jseq[jjj]
        v <- value[[jvseq[[jjj]]]]
        if (!is.null(v) && nrows > 0 && !length(v)) 
          length(v) <- nrows
        x[[jj]] <- v
        if (!is.null(v) && is.atomic(x[[jj]]) && !is.null(names(x[[jj]]))) 
          names(x[[jj]]) <- NULL
      }
    if (length(new.cols) > 0) {
      new.cols <- names(x)
      if (anyDuplicated(new.cols)) 
        names(x) <- make.unique(new.cols)
    }
    class(x) <- cl
    x
  })
c("package:base", "registered S3 method for [<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
183)[<-.Date
  list(`package:base` = function (x, ..., value) 
  {
    if (!length(value)) 
      return(x)
    value <- unclass(as.Date(value))
    .Date(NextMethod(.Generic), oldClass(x))
  }, function (x, ..., value) 
  {
    if (!length(value)) 
      return(x)
    value <- unclass(as.Date(value))
    .Date(NextMethod(.Generic), oldClass(x))
  }, function (x, ..., value) 
  {
    if (!length(value)) 
      return(x)
    value <- unclass(as.Date(value))
    .Date(NextMethod(.Generic), oldClass(x))
  })
c("package:base", "registered S3 method for [<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
184)[<-.difftime
  list(`package:base` = function (x, i, value) 
  {
    if (inherits(value, "difftime") && !identical(units(x), units(value))) 
      units(value) <- units(x)
    NextMethod("[<-")
  }, function (x, i, value) 
  {
    if (inherits(value, "difftime") && !identical(units(x), units(value))) 
      units(value) <- units(x)
    NextMethod("[<-")
  }, function (x, i, value) 
  {
    if (inherits(value, "difftime") && !identical(units(x), units(value))) 
      units(value) <- units(x)
    NextMethod("[<-")
  })
  c("package:base", "registered S3 method for [<- from namespace base", "namespace:base")
  c(TRUE, FALSE, FALSE)
  c(FALSE, TRUE, TRUE)
  185)[<-.factor
    list(`package:base` = function (x, ..., value) 
    {
      lx <- levels(x)
      cx <- oldClass(x)
      if (is.factor(value)) 
        value <- levels(value)[value]
      m <- match(value, lx)
      if (any(is.na(m) & !is.na(value))) 
        warning("invalid factor level, NA generated")
      class(x) <- NULL
      x[...] <- m
      attr(x, "levels") <- lx
      class(x) <- cx
      x
    }, function (x, ..., value) 
    {
      lx <- levels(x)
      cx <- oldClass(x)
      if (is.factor(value)) 
        value <- levels(value)[value]
      m <- match(value, lx)
      if (any(is.na(m) & !is.na(value))) 
        warning("invalid factor level, NA generated")
      class(x) <- NULL
      x[...] <- m
      attr(x, "levels") <- lx
      class(x) <- cx
      x
    }, function (x, ..., value) 
    {
      lx <- levels(x)
      cx <- oldClass(x)
      if (is.factor(value)) 
        value <- levels(value)[value]
      m <- match(value, lx)
      if (any(is.na(m) & !is.na(value))) 
        warning("invalid factor level, NA generated")
      class(x) <- NULL
      x[...] <- m
      attr(x, "levels") <- lx
      class(x) <- cx
      x
    })
    c("package:base", "registered S3 method for [<- from namespace base", "namespace:base")
    c(TRUE, FALSE, FALSE)
    c(FALSE, TRUE, TRUE)
186)[<-.numeric_version
      list(`package:base` = function (x, i, j, value) 
      {
        y <- unclass(x)
        if (missing(j)) 
          y[i] <- unclass(as.numeric_version(value))
        else {
          if (!is.list(value)) 
            value <- list(value)
          value <- lapply(value, as.integer)
          if (any(vapply(value, function(e) anyNA(e) || any(e < 0), NA))) 
            stop("invalid 'value'")
          if (!is.list(j)) 
            j <- list(j)
          y[i] <- Map(`[<-`, y[i], j, value)
        }
        class(y) <- class(x)
        y
      }, function (x, i, j, value) 
      {
        y <- unclass(x)
        if (missing(j)) 
          y[i] <- unclass(as.numeric_version(value))
        else {
          if (!is.list(value)) 
            value <- list(value)
          value <- lapply(value, as.integer)
          if (any(vapply(value, function(e) anyNA(e) || any(e < 0), NA))) 
            stop("invalid 'value'")
          if (!is.list(j)) 
            j <- list(j)
          y[i] <- Map(`[<-`, y[i], j, value)
        }
        class(y) <- class(x)
        y
      }, function (x, i, j, value) 
      {
        y <- unclass(x)
        if (missing(j)) 
          y[i] <- unclass(as.numeric_version(value))
        else {
          if (!is.list(value)) 
            value <- list(value)
          value <- lapply(value, as.integer)
          if (any(vapply(value, function(e) anyNA(e) || any(e < 0), NA))) 
            stop("invalid 'value'")
          if (!is.list(j)) 
            j <- list(j)
          y[i] <- Map(`[<-`, y[i], j, value)
        }
        class(y) <- class(x)
        y
      })
      c("package:base", "registered S3 method for [<- from namespace base", "namespace:base")
      c(TRUE, FALSE, FALSE)
      c(FALSE, TRUE, TRUE)
188)[<-.POSIXct
        list(`package:base` = function (x, ..., value) 
        {
          if (!length(value)) 
            return(x)
          value <- unclass(as.POSIXct(value))
          .POSIXct(NextMethod(.Generic), attr(x, "tzone"), oldClass(x))
        }, function (x, ..., value) 
        {
          if (!length(value)) 
            return(x)
          value <- unclass(as.POSIXct(value))
          .POSIXct(NextMethod(.Generic), attr(x, "tzone"), oldClass(x))
        }, function (x, ..., value) 
        {
          if (!length(value)) 
            return(x)
          value <- unclass(as.POSIXct(value))
          .POSIXct(NextMethod(.Generic), attr(x, "tzone"), oldClass(x))
        })
        c("package:base", "registered S3 method for [<- from namespace base", "namespace:base")
        c(TRUE, FALSE, FALSE)
        c(FALSE, TRUE, TRUE)
189)[<-.POSIXlt
          list(`package:base` = function (x, i, j, value) 
          {
            if (!(mj <- missing(j))) 
              if (!is.character(j) || (length(j) != 1)) 
                stop("component subscript must be a character string")
            if (!length(value)) 
              return(x)
            cl <- oldClass(x)
            class(x) <- NULL
            if (missing(i)) {
              if (mj) 
                x <- as.POSIXlt(value)
              else x[[j]] <- value
            }
            else {
              ici <- is.character(i)
              nms <- names(x$year)
              if (mj) {
                value <- unclass(as.POSIXlt(value))
                if (ici) {
                  for (n in names(x)) names(x[[n]]) <- nms
                }
                for (n in names(x)) x[[n]][i] <- value[[n]]
              }
              else {
                if (ici) {
                  names(x[[j]]) <- nms
                }
                x[[j]][i] <- value
              }
            }
            class(x) <- cl
            x
          }, function (x, i, j, value) 
          {
            if (!(mj <- missing(j))) 
              if (!is.character(j) || (length(j) != 1)) 
                stop("component subscript must be a character string")
            if (!length(value)) 
              return(x)
            cl <- oldClass(x)
            class(x) <- NULL
            if (missing(i)) {
              if (mj) 
                x <- as.POSIXlt(value)
              else x[[j]] <- value
            }
            else {
              ici <- is.character(i)
              nms <- names(x$year)
              if (mj) {
                value <- unclass(as.POSIXlt(value))
                if (ici) {
                  for (n in names(x)) names(x[[n]]) <- nms
                }
                for (n in names(x)) x[[n]][i] <- value[[n]]
              }
              else {
                if (ici) {
                  names(x[[j]]) <- nms
                }
                x[[j]][i] <- value
              }
            }
            class(x) <- cl
            x
          }, function (x, i, j, value) 
          {
            if (!(mj <- missing(j))) 
              if (!is.character(j) || (length(j) != 1)) 
                stop("component subscript must be a character string")
            if (!length(value)) 
              return(x)
            cl <- oldClass(x)
            class(x) <- NULL
            if (missing(i)) {
              if (mj) 
                x <- as.POSIXlt(value)
              else x[[j]] <- value
            }
            else {
              ici <- is.character(i)
              nms <- names(x$year)
              if (mj) {
                value <- unclass(as.POSIXlt(value))
                if (ici) {
                  for (n in names(x)) names(x[[n]]) <- nms
                }
                for (n in names(x)) x[[n]][i] <- value[[n]]
              }
              else {
                if (ici) {
                  names(x[[j]]) <- nms
                }
                x[[j]][i] <- value
              }
            }
            class(x) <- cl
            x
          })
c("package:base", "registered S3 method for [<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
190)^
  list(`package:base` = .Primitive("^"), .Primitive("^"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
191){
  list(`package:base` = .Primitive("{"), .Primitive("{"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
192)|
    list(`package:base` = .Primitive("|"), .Primitive("|"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
193)|.hexmode
  list(`package:base` = function (a, b) 
    as.hexmode(bitwOr(as.hexmode(a), as.hexmode(b))), function (a, b) 
      as.hexmode(bitwOr(as.hexmode(a), as.hexmode(b))), function (a, b) 
        as.hexmode(bitwOr(as.hexmode(a), as.hexmode(b))))
  c("package:base", "registered S3 method for | from namespace base", "namespace:base")
  c(TRUE, FALSE, FALSE)
  c(FALSE, TRUE, TRUE)
194)|.octmode
  list(`package:base` = function (a, b) 
    as.octmode(bitwOr(as.octmode(a), as.octmode(b))), function (a, b) 
      as.octmode(bitwOr(as.octmode(a), as.octmode(b))), function (a, b) 
        as.octmode(bitwOr(as.octmode(a), as.octmode(b))))
  c("package:base", "registered S3 method for | from namespace base", "namespace:base")
  c(TRUE, FALSE, FALSE)
  c(FALSE, TRUE, TRUE)
195)||
    list(`package:base` = .Primitive("||"), .Primitive("||"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
196)~
    list(`package:base` = .Primitive("~"), .Primitive("~"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
197)+
    list(`package:base` = .Primitive("+"), .Primitive("+"))
  c("package:base", "namespace:base")
  c(TRUE, FALSE)
  c(FALSE, TRUE)
198)+.Date
  list(`package:base` = function (e1, e2) 
  {
    coerceTimeUnit <- function(x) as.vector(round(switch(attr(x, "units"), secs = x/86400, mins = x/1440, hours = x/24, days = x, weeks = 7 * x)))
    if (nargs() == 1) 
      return(e1)
    if (inherits(e1, "Date") && inherits(e2, "Date")) 
      stop("binary + is not defined for \"Date\" objects")
    if (inherits(e1, "difftime")) 
      e1 <- coerceTimeUnit(e1)
    if (inherits(e2, "difftime")) 
      e2 <- coerceTimeUnit(e2)
    .Date(unclass(e1) + unclass(e2))
  }, function (e1, e2) 
  {
    coerceTimeUnit <- function(x) as.vector(round(switch(attr(x, "units"), secs = x/86400, mins = x/1440, hours = x/24, days = x, weeks = 7 * x)))
    if (nargs() == 1) 
      return(e1)
    if (inherits(e1, "Date") && inherits(e2, "Date")) 
      stop("binary + is not defined for \"Date\" objects")
    if (inherits(e1, "difftime")) 
      e1 <- coerceTimeUnit(e1)
    if (inherits(e2, "difftime")) 
      e2 <- coerceTimeUnit(e2)
    .Date(unclass(e1) + unclass(e2))
  }, function (e1, e2) 
  {
    coerceTimeUnit <- function(x) as.vector(round(switch(attr(x, "units"), secs = x/86400, mins = x/1440, hours = x/24, days = x, weeks = 7 * x)))
    if (nargs() == 1) 
      return(e1)
    if (inherits(e1, "Date") && inherits(e2, "Date")) 
      stop("binary + is not defined for \"Date\" objects")
    if (inherits(e1, "difftime")) 
      e1 <- coerceTimeUnit(e1)
    if (inherits(e2, "difftime")) 
      e2 <- coerceTimeUnit(e2)
    .Date(unclass(e1) + unclass(e2))
  })
  c("package:base", "registered S3 method for + from namespace base", "namespace:base")
  c(TRUE, FALSE, FALSE)
  c(FALSE, TRUE, TRUE)
199)+.POSIXt
  list(`package:base` = function (e1, e2) 
  {
    coerceTimeUnit <- function(x) as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
    if (nargs() == 1) 
      return(e1)
    if (inherits(e1, "POSIXt") && inherits(e2, "POSIXt")) 
      stop("binary '+' is not defined for \"POSIXt\" objects")
    if (inherits(e1, "POSIXlt")) 
      e1 <- as.POSIXct(e1)
    if (inherits(e2, "POSIXlt")) 
      e2 <- as.POSIXct(e2)
    if (inherits(e1, "difftime")) 
      e1 <- coerceTimeUnit(e1)
    if (inherits(e2, "difftime")) 
      e2 <- coerceTimeUnit(e2)
    .POSIXct(unclass(e1) + unclass(e2), check_tzones(e1, e2))
  }, function (e1, e2) 
  {
    coerceTimeUnit <- function(x) as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
    if (nargs() == 1) 
      return(e1)
    if (inherits(e1, "POSIXt") && inherits(e2, "POSIXt")) 
      stop("binary '+' is not defined for \"POSIXt\" objects")
    if (inherits(e1, "POSIXlt")) 
      e1 <- as.POSIXct(e1)
    if (inherits(e2, "POSIXlt")) 
      e2 <- as.POSIXct(e2)
    if (inherits(e1, "difftime")) 
      e1 <- coerceTimeUnit(e1)
    if (inherits(e2, "difftime")) 
      e2 <- coerceTimeUnit(e2)
    .POSIXct(unclass(e1) + unclass(e2), check_tzones(e1, e2))
  }, function (e1, e2) 
  {
    coerceTimeUnit <- function(x) as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
    if (nargs() == 1) 
      return(e1)
    if (inherits(e1, "POSIXt") && inherits(e2, "POSIXt")) 
      stop("binary '+' is not defined for \"POSIXt\" objects")
    if (inherits(e1, "POSIXlt")) 
      e1 <- as.POSIXct(e1)
    if (inherits(e2, "POSIXlt")) 
      e2 <- as.POSIXct(e2)
    if (inherits(e1, "difftime")) 
      e1 <- coerceTimeUnit(e1)
    if (inherits(e2, "difftime")) 
      e2 <- coerceTimeUnit(e2)
    .POSIXct(unclass(e1) + unclass(e2), check_tzones(e1, e2))
})
c("package:base", "registered S3 method for + from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
200)<
  list(`package:base` = .Primitive("<"), .Primitive("<"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
201)<-
  list(`package:base` = .Primitive("<-"), .Primitive("<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
202)<<-
  list(`package:base` = .Primitive("<<-"), .Primitive("<<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
203)<=
  list(`package:base` = .Primitive("<="), .Primitive("<="))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
204)=
  list(`package:base` = .Primitive("="), .Primitive("="))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
205)==
  list(`package:base` = .Primitive("=="), .Primitive("=="))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
206)>
  list(`package:base` = .Primitive(">"), .Primitive(">"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
207)>=
  list(`package:base` = .Primitive(">="), .Primitive(">="))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
208)abbreviate
list(`package:base` = function (names.arg, minlength = 4, use.classes = TRUE, dot = FALSE, strict = FALSE, method = c("left.kept", "both.sides"), named = TRUE) 
{
  if (minlength <= 0) {
    x <- rep.int("", length(names.arg))
    if (named) 
      names(x) <- names.arg
    return(x)
  }
  names.arg <- sub("^ +", "", sub(" +$", "", as.character(names.arg)))
  dups <- duplicated(names.arg)
  old <- names.arg
  if (any(dups)) 
    names.arg <- names.arg[!dups]
  x <- names.arg
  if (strict) {
    x[] <- .Internal(abbreviate(x, minlength, use.classes))
  }
  else {
    method <- match.arg(method)
    if (method == "both.sides") 
      chRev <- function(x) sapply(lapply(strsplit(x, NULL), rev), paste, collapse = "")
    dup2 <- rep.int(TRUE, length(names.arg))
    these <- names.arg
    repeat {
      ans <- .Internal(abbreviate(these, minlength, use.classes))
      x[dup2] <- ans
      if (!any(dup2 <- duplicated(x))) 
        break
      if (method == "both.sides") {
        x[dup2] <- chRev(.Internal(abbreviate(chRev(names.arg[dup2]), minlength, use.classes)))
        if (!any(dup2 <- duplicated(x))) 
          break
      }
      minlength <- minlength + 1
      dup2 <- dup2 | match(x, x[dup2], 0)
      these <- names.arg[dup2]
    }
  }
  if (any(dups)) 
    x <- x[match(old, names.arg)]
  if (dot) {
    chgd <- x != old
    x[chgd] <- paste0(x[chgd], ".")
  }
  if (named) 
    names(x) <- old
  x
}, function (names.arg, minlength = 4, use.classes = TRUE, dot = FALSE, strict = FALSE, method = c("left.kept", "both.sides"), named = TRUE) 
{
  if (minlength <= 0) {
    x <- rep.int("", length(names.arg))
    if (named) 
      names(x) <- names.arg
    return(x)
  }
  names.arg <- sub("^ +", "", sub(" +$", "", as.character(names.arg)))
  dups <- duplicated(names.arg)
  old <- names.arg
  if (any(dups)) 
    names.arg <- names.arg[!dups]
  x <- names.arg
  if (strict) {
    x[] <- .Internal(abbreviate(x, minlength, use.classes))
  }
  else {
    method <- match.arg(method)
    if (method == "both.sides") 
      chRev <- function(x) sapply(lapply(strsplit(x, NULL), rev), paste, collapse = "")
    dup2 <- rep.int(TRUE, length(names.arg))
    these <- names.arg
    repeat {
      ans <- .Internal(abbreviate(these, minlength, use.classes))
      x[dup2] <- ans
      if (!any(dup2 <- duplicated(x))) 
        break
      if (method == "both.sides") {
        x[dup2] <- chRev(.Internal(abbreviate(chRev(names.arg[dup2]), minlength, use.classes)))
        if (!any(dup2 <- duplicated(x))) 
          break
      }
      minlength <- minlength + 1
      dup2 <- dup2 | match(x, x[dup2], 0)
      these <- names.arg[dup2]
    }
  }
  if (any(dups)) 
    x <- x[match(old, names.arg)]
  if (dot) {
    chgd <- x != old
    x[chgd] <- paste0(x[chgd], ".")
  }
  if (named) 
    names(x) <- old
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
209)abs
list(`package:base` = .Primitive("abs"), .Primitive("abs"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
210)acos
list(`package:base` = .Primitive("acos"), .Primitive("acos"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
211)acosh
list(`package:base` = .Primitive("acosh"), .Primitive("acosh"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
212)activeBindingFunction
list(`package:base` = function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(activeBindingFunction(sym, env))
}, function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(activeBindingFunction(sym, env))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
213)addNA
list(`package:base` = function (x, ifany = FALSE) 
{
  if (!is.factor(x)) 
    x <- factor(x)
  if (ifany && !anyNA(x)) 
    return(x)
  ll <- levels(x)
  if (!anyNA(ll)) 
    ll <- c(ll, NA)
  else if (!ifany && !anyNA(x)) 
    return(x)
  factor(x, levels = ll, exclude = NULL)
}, function (x, ifany = FALSE) 
{
  if (!is.factor(x)) 
    x <- factor(x)
  if (ifany && !anyNA(x)) 
    return(x)
  ll <- levels(x)
  if (!anyNA(ll)) 
    ll <- c(ll, NA)
  else if (!ifany && !anyNA(x)) 
    return(x)
  factor(x, levels = ll, exclude = NULL)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
214)addTaskCallback
list(`package:base` = function (f, data = NULL, name = character()) 
{
  if (!is.function(f)) 
    stop("handler must be a function")
  val <- .Call(.C_R_addTaskCallback, f, data, !missing(data), as.character(name))
  val + 1
}, function (f, data = NULL, name = character()) 
{
  if (!is.function(f)) 
    stop("handler must be a function")
  val <- .Call(.C_R_addTaskCallback, f, data, !missing(data), as.character(name))
  val + 1
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
215)agrep
list(`package:base` = function (pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, value = FALSE, fixed = TRUE, useBytes = FALSE) 
{
  pattern <- as.character(pattern)
  if (!is.character(x)) 
    x <- as.character(x)
  costs <- as.integer(.amatch_costs(costs))
  bounds <- .amatch_bounds(max.distance)
  .Internal(agrep(pattern, x, ignore.case, value, costs, bounds, useBytes, fixed))
}, function (pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, value = FALSE, fixed = TRUE, useBytes = FALSE) 
{
  pattern <- as.character(pattern)
  if (!is.character(x)) 
    x <- as.character(x)
  costs <- as.integer(.amatch_costs(costs))
  bounds <- .amatch_bounds(max.distance)
  .Internal(agrep(pattern, x, ignore.case, value, costs, bounds, useBytes, fixed))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
216)agrepl
list(`package:base` = function (pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = TRUE, useBytes = FALSE) 
{
  pattern <- as.character(pattern)
  if (!is.character(x)) 
    x <- as.character(x)
  costs <- as.integer(.amatch_costs(costs))
  bounds <- .amatch_bounds(max.distance)
  .Internal(agrepl(pattern, x, ignore.case, FALSE, costs, bounds, useBytes, fixed))
}, function (pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = TRUE, useBytes = FALSE) 
{
  pattern <- as.character(pattern)
  if (!is.character(x)) 
    x <- as.character(x)
  costs <- as.integer(.amatch_costs(costs))
  bounds <- .amatch_bounds(max.distance)
  .Internal(agrepl(pattern, x, ignore.case, FALSE, costs, bounds, useBytes, fixed))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
217)alist
list(`package:base` = function (...) 
  as.list(sys.call())[-1], function (...) 
    as.list(sys.call())[-1])
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
218)all
list(`package:base` = .Primitive("all"), .Primitive("all"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
219)all.equal
list(`package:base` = function (target, current, ...) 
  UseMethod("all.equal"), function (target, current, ...) 
    UseMethod("all.equal"), new("standardGeneric", .Data = function (target, current, ...) 
      standardGeneric("all.equal"), generic = "all.equal", package = "base", group = list(), valueClass = character(0), signature = c("target", "current"), default = new("derivedDefaultMethod", .Data = function (target, current, ...) 
        UseMethod("all.equal"), target = new("signature", .Data = "ANY", names = "target", package = "methods"), defined = new("signature", .Data = "ANY", names = "target", package = "methods"), generic = "all.equal"), skeleton = (new("derivedDefaultMethod", .Data = function (target, current, ...) 
          UseMethod("all.equal"), target = new("signature", .Data = "ANY", names = "target", package = "methods"), defined = new("signature", .Data = "ANY", names = "target", package = "methods"), generic = "all.equal"))(target, current, ...)), function (target, current, ...) 
            UseMethod("all.equal"))
c("package:base", "registered S3 method for all from namespace base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
220)all.equal.character
list(`package:base` = function (target, current, ..., check.attributes = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0("Lengths (", lt, ", ", lc, ") differ (string compare on first ", ll <- min(lt, lc), ")"))
    ll <- seq_len(ll)
    target <- target[ll]
    current <- current[ll]
  }
  nas <- is.na(target)
  nasc <- is.na(current)
  if (any(nas != nasc)) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(nasc), "in current", sum(nas), "in target"))
    return(msg)
  }
  ne <- !nas & (target != current)
  if (!any(ne) && is.null(msg)) 
    TRUE
  else if (sum(ne) == 1) 
    c(msg, paste("1 string mismatch"))
  else if (sum(ne) > 1) 
    c(msg, paste(sum(ne), "string mismatches"))
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0("Lengths (", lt, ", ", lc, ") differ (string compare on first ", ll <- min(lt, lc), ")"))
    ll <- seq_len(ll)
    target <- target[ll]
    current <- current[ll]
  }
  nas <- is.na(target)
  nasc <- is.na(current)
  if (any(nas != nasc)) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(nasc), "in current", sum(nas), "in target"))
    return(msg)
  }
  ne <- !nas & (target != current)
  if (!any(ne) && is.null(msg)) 
    TRUE
  else if (sum(ne) == 1) 
    c(msg, paste("1 string mismatch"))
  else if (sum(ne) > 1) 
    c(msg, paste(sum(ne), "string mismatches"))
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0("Lengths (", lt, ", ", lc, ") differ (string compare on first ", ll <- min(lt, lc), ")"))
    ll <- seq_len(ll)
    target <- target[ll]
    current <- current[ll]
  }
  nas <- is.na(target)
  nasc <- is.na(current)
  if (any(nas != nasc)) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(nasc), "in current", sum(nas), "in target"))
    return(msg)
  }
  ne <- !nas & (target != current)
  if (!any(ne) && is.null(msg)) 
    TRUE
  else if (sum(ne) == 1) 
    c(msg, paste("1 string mismatch"))
  else if (sum(ne) > 1) 
    c(msg, paste(sum(ne), "string mismatches"))
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0("Lengths (", lt, ", ", lc, ") differ (string compare on first ", ll <- min(lt, lc), ")"))
    ll <- seq_len(ll)
    target <- target[ll]
    current <- current[ll]
  }
  nas <- is.na(target)
  nasc <- is.na(current)
  if (any(nas != nasc)) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(nasc), "in current", sum(nas), "in target"))
    return(msg)
  }
  ne <- !nas & (target != current)
  if (!any(ne) && is.null(msg)) 
    TRUE
  else if (sum(ne) == 1) 
    c(msg, paste("1 string mismatch"))
  else if (sum(ne) > 1) 
    c(msg, paste(sum(ne), "string mismatches"))
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
221)all.equal.default
list(`package:base` = function (target, current, ...) 
{
  if (is.language(target)) 
    return(all.equal.language(target, current, ...))
  if (is.function(target)) {
    if ("function" %in% .class2(target)) 
      .Deprecated("all.equal(*)", old = "all.equal.default(<function>)")
    return(all.equal.function(target, current, ...))
  }
  if (is.environment(target) || is.environment(current)) 
    return(all.equal.environment(target, current, ...))
  if (is.recursive(target)) {
    return(if (typeof(target) == "..." && typeof(current) == "...") {
      if (identical(target, current)) TRUE else if ((lt <- length(target)) != (lc <- length(current))) paste0("\"...\"-typed\": lengths (", lt, ", ", lc, ") differ") else if (xor(is.null(nt <- names(target)), is.null(nc <- names(current)))) {
        paste0("\"...\"-typed: names in ", if (length(nt)) "target but not in current" else "current but not in target")
      } else if (!is.null(nt)) {
        nt <- sort(nt)
        nc <- sort(nc)
        if (identical(nt, nc)) TRUE else c("\"...\"-typed\": sorted names differ", all.equal.character(nt, nc, ...))
      } else "\"...\"-types of the same length, no names, but not identical"
    } else all.equal.list(target, current, ...))
  }
  msg <- switch(mode(target), integer = , complex = , numeric = all.equal.numeric(target, current, ...), character = all.equal.character(target, current, ...), logical = , raw = all.equal.raw(target, current, ...), S4 = attr.all.equal(target, current, ...), if (data.class(target) != data.class(current)) {
    gettextf("target is %s, current is %s", data.class(target), data.class(current))
  } else NULL)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  if (is.language(target)) 
    return(all.equal.language(target, current, ...))
  if (is.function(target)) {
    if ("function" %in% .class2(target)) 
      .Deprecated("all.equal(*)", old = "all.equal.default(<function>)")
    return(all.equal.function(target, current, ...))
  }
  if (is.environment(target) || is.environment(current)) 
    return(all.equal.environment(target, current, ...))
  if (is.recursive(target)) {
    return(if (typeof(target) == "..." && typeof(current) == "...") {
      if (identical(target, current)) TRUE else if ((lt <- length(target)) != (lc <- length(current))) paste0("\"...\"-typed\": lengths (", lt, ", ", lc, ") differ") else if (xor(is.null(nt <- names(target)), is.null(nc <- names(current)))) {
        paste0("\"...\"-typed: names in ", if (length(nt)) "target but not in current" else "current but not in target")
      } else if (!is.null(nt)) {
        nt <- sort(nt)
        nc <- sort(nc)
        if (identical(nt, nc)) TRUE else c("\"...\"-typed\": sorted names differ", all.equal.character(nt, nc, ...))
      } else "\"...\"-types of the same length, no names, but not identical"
    } else all.equal.list(target, current, ...))
  }
  msg <- switch(mode(target), integer = , complex = , numeric = all.equal.numeric(target, current, ...), character = all.equal.character(target, current, ...), logical = , raw = all.equal.raw(target, current, ...), S4 = attr.all.equal(target, current, ...), if (data.class(target) != data.class(current)) {
    gettextf("target is %s, current is %s", data.class(target), data.class(current))
  } else NULL)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  if (is.language(target)) 
    return(all.equal.language(target, current, ...))
  if (is.function(target)) {
    if ("function" %in% .class2(target)) 
      .Deprecated("all.equal(*)", old = "all.equal.default(<function>)")
    return(all.equal.function(target, current, ...))
  }
  if (is.environment(target) || is.environment(current)) 
    return(all.equal.environment(target, current, ...))
  if (is.recursive(target)) {
    return(if (typeof(target) == "..." && typeof(current) == "...") {
      if (identical(target, current)) TRUE else if ((lt <- length(target)) != (lc <- length(current))) paste0("\"...\"-typed\": lengths (", lt, ", ", lc, ") differ") else if (xor(is.null(nt <- names(target)), is.null(nc <- names(current)))) {
        paste0("\"...\"-typed: names in ", if (length(nt)) "target but not in current" else "current but not in target")
      } else if (!is.null(nt)) {
        nt <- sort(nt)
        nc <- sort(nc)
        if (identical(nt, nc)) TRUE else c("\"...\"-typed\": sorted names differ", all.equal.character(nt, nc, ...))
      } else "\"...\"-types of the same length, no names, but not identical"
    } else all.equal.list(target, current, ...))
  }
  msg <- switch(mode(target), integer = , complex = , numeric = all.equal.numeric(target, current, ...), character = all.equal.character(target, current, ...), logical = , raw = all.equal.raw(target, current, ...), S4 = attr.all.equal(target, current, ...), if (data.class(target) != data.class(current)) {
    gettextf("target is %s, current is %s", data.class(target), data.class(current))
  } else NULL)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  if (is.language(target)) 
    return(all.equal.language(target, current, ...))
  if (is.function(target)) {
    if ("function" %in% .class2(target)) 
      .Deprecated("all.equal(*)", old = "all.equal.default(<function>)")
    return(all.equal.function(target, current, ...))
  }
  if (is.environment(target) || is.environment(current)) 
    return(all.equal.environment(target, current, ...))
  if (is.recursive(target)) {
    return(if (typeof(target) == "..." && typeof(current) == "...") {
      if (identical(target, current)) TRUE else if ((lt <- length(target)) != (lc <- length(current))) paste0("\"...\"-typed\": lengths (", lt, ", ", lc, ") differ") else if (xor(is.null(nt <- names(target)), is.null(nc <- names(current)))) {
        paste0("\"...\"-typed: names in ", if (length(nt)) "target but not in current" else "current but not in target")
      } else if (!is.null(nt)) {
        nt <- sort(nt)
        nc <- sort(nc)
        if (identical(nt, nc)) TRUE else c("\"...\"-typed\": sorted names differ", all.equal.character(nt, nc, ...))
      } else "\"...\"-types of the same length, no names, but not identical"
    } else all.equal.list(target, current, ...))
  }
  msg <- switch(mode(target), integer = , complex = , numeric = all.equal.numeric(target, current, ...), character = all.equal.character(target, current, ...), logical = , raw = all.equal.raw(target, current, ...), S4 = attr.all.equal(target, current, ...), if (data.class(target) != data.class(current)) {
    gettextf("target is %s, current is %s", data.class(target), data.class(current))
  } else NULL)
  if (is.null(msg)) 
    TRUE
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
222)all.equal.environment
list(`package:base` = function (target, current, all.names = TRUE, evaluate = TRUE, ...) 
{
  if (!is.environment(target)) 
    return("'target' is not an environment")
  if (!is.environment(current)) 
    return("'current' is not an environment")
  if (identical(target, current)) 
    return(TRUE)
  ae.run <- dynGet("__all.eq.E__", NULL)
  if (is.null(ae.run)) 
    "__all.eq.E__" <- environment()
  else {
    do1 <- function(em) {
      if (identical(target, em$target) && identical(current, em$current)) 
        TRUE
      else if (!is.null(em$mm)) 
        do1(em$mm)
      else {
        e <- new.env(parent = emptyenv())
        e$target <- target
        e$current <- current
        em$mm <- e
        FALSE
      }
    }
    if (do1(ae.run)) 
      return(TRUE)
  }
  if (evaluate) {
    Lt <- as.list.environment(target, all.names = all.names, sorted = TRUE)
    Lc <- as.list.environment(current, all.names = all.names, sorted = TRUE)
    if (identical(Lt, Lc)) 
      TRUE
    else all.equal.list(Lt, Lc, ...)
  }
  else {
    if (!identical(nt <- sort(names(target)), nc <- sort(names(current)))) 
      paste("names of environments differ:", all.equal(nt, nc, ...), collapse = " ")
    else "environments contain objects of the same names, but are not identical"
  }
}, function (target, current, all.names = TRUE, evaluate = TRUE, ...) 
{
  if (!is.environment(target)) 
    return("'target' is not an environment")
  if (!is.environment(current)) 
    return("'current' is not an environment")
  if (identical(target, current)) 
    return(TRUE)
  ae.run <- dynGet("__all.eq.E__", NULL)
  if (is.null(ae.run)) 
    "__all.eq.E__" <- environment()
  else {
    do1 <- function(em) {
      if (identical(target, em$target) && identical(current, em$current)) 
        TRUE
      else if (!is.null(em$mm)) 
        do1(em$mm)
      else {
        e <- new.env(parent = emptyenv())
        e$target <- target
        e$current <- current
        em$mm <- e
        FALSE
      }
    }
    if (do1(ae.run)) 
      return(TRUE)
  }
  if (evaluate) {
    Lt <- as.list.environment(target, all.names = all.names, sorted = TRUE)
    Lc <- as.list.environment(current, all.names = all.names, sorted = TRUE)
    if (identical(Lt, Lc)) 
      TRUE
    else all.equal.list(Lt, Lc, ...)
  }
  else {
    if (!identical(nt <- sort(names(target)), nc <- sort(names(current)))) 
      paste("names of environments differ:", all.equal(nt, nc, ...), collapse = " ")
    else "environments contain objects of the same names, but are not identical"
  }
}, function (target, current, all.names = TRUE, evaluate = TRUE, ...) 
{
  if (!is.environment(target)) 
    return("'target' is not an environment")
  if (!is.environment(current)) 
    return("'current' is not an environment")
  if (identical(target, current)) 
    return(TRUE)
  ae.run <- dynGet("__all.eq.E__", NULL)
  if (is.null(ae.run)) 
    "__all.eq.E__" <- environment()
  else {
    do1 <- function(em) {
      if (identical(target, em$target) && identical(current, em$current)) 
        TRUE
      else if (!is.null(em$mm)) 
        do1(em$mm)
      else {
        e <- new.env(parent = emptyenv())
        e$target <- target
        e$current <- current
        em$mm <- e
        FALSE
      }
    }
    if (do1(ae.run)) 
      return(TRUE)
  }
  if (evaluate) {
    Lt <- as.list.environment(target, all.names = all.names, sorted = TRUE)
    Lc <- as.list.environment(current, all.names = all.names, sorted = TRUE)
    if (identical(Lt, Lc)) 
      TRUE
    else all.equal.list(Lt, Lc, ...)
  }
  else {
    if (!identical(nt <- sort(names(target)), nc <- sort(names(current)))) 
      paste("names of environments differ:", all.equal(nt, nc, ...), collapse = " ")
    else "environments contain objects of the same names, but are not identical"
  }
}, function (target, current, all.names = TRUE, evaluate = TRUE, ...) 
{
  if (!is.environment(target)) 
    return("'target' is not an environment")
  if (!is.environment(current)) 
    return("'current' is not an environment")
  if (identical(target, current)) 
    return(TRUE)
  ae.run <- dynGet("__all.eq.E__", NULL)
  if (is.null(ae.run)) 
    "__all.eq.E__" <- environment()
  else {
    do1 <- function(em) {
      if (identical(target, em$target) && identical(current, em$current)) 
        TRUE
      else if (!is.null(em$mm)) 
        do1(em$mm)
      else {
        e <- new.env(parent = emptyenv())
        e$target <- target
        e$current <- current
        em$mm <- e
        FALSE
      }
    }
    if (do1(ae.run)) 
      return(TRUE)
  }
  if (evaluate) {
    Lt <- as.list.environment(target, all.names = all.names, sorted = TRUE)
    Lc <- as.list.environment(current, all.names = all.names, sorted = TRUE)
    if (identical(Lt, Lc)) 
      TRUE
    else all.equal.list(Lt, Lc, ...)
  }
  else {
    if (!identical(nt <- sort(names(target)), nc <- sort(names(current)))) 
      paste("names of environments differ:", all.equal(nt, nc, ...), collapse = " ")
    else "environments contain objects of the same names, but are not identical"
  }
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
223)all.equal.envRefClass
list(`package:base` = function (target, current, ...) 
{
  if (!methods::is(target, "envRefClass")) 
    return("'target' is not an envRefClass")
  if (!methods::is(current, "envRefClass")) 
    return("'current' is not an envRefClass")
  if (!isTRUE(ae <- all.equal(class(target), class(current), ...))) 
    return(sprintf("Classes differ: %s", paste(ae, collapse = " ")))
  getCl <- function(x) {
    cl <- tryCatch(x$getClass(), error = function(e) NULL)
    if (is.null(cl)) 
      class(x)
    else cl
  }
  if (!identical(cld <- getCl(target), c2 <- getCl(current))) {
    hasCA <- "check.attributes" %in% ...names()
    ae <- if (hasCA) 
      all.equal(cld, c2, ...)
    else all.equal(cld, c2, check.attributes = FALSE, ...)
    if (isTRUE(ae) && !hasCA) 
      ae <- all.equal(cld, c2, ...)
    return(sprintf("Class definitions are not identical%s", if (isTRUE(ae)) "" else paste(":", ae, collapse = " ")))
  }
  if (!isS4(cld)) 
    return(if (identical(target, current)) TRUE else "different prototypical 'envRefClass' objects")
  flds <- names(cld@fieldClasses)
  asL <- function(O) sapply(flds, function(ch) O[[ch]], simplify = FALSE)
  n <- all.equal.list(asL(target), asL(current), ...)
  sns <- names(cld@slots)
  sns <- sns[sns != ".xData"]
  msg <- if (length(sns)) {
    L <- lapply(sns, function(sn) all.equal(methods::slot(target, sn), methods::slot(current, sn), ...))
    unlist(L[vapply(L, is.character, NA)])
  }
  if (is.character(n)) 
    msg <- c(msg, n)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  if (!methods::is(target, "envRefClass")) 
    return("'target' is not an envRefClass")
  if (!methods::is(current, "envRefClass")) 
    return("'current' is not an envRefClass")
  if (!isTRUE(ae <- all.equal(class(target), class(current), ...))) 
    return(sprintf("Classes differ: %s", paste(ae, collapse = " ")))
  getCl <- function(x) {
    cl <- tryCatch(x$getClass(), error = function(e) NULL)
    if (is.null(cl)) 
      class(x)
    else cl
  }
  if (!identical(cld <- getCl(target), c2 <- getCl(current))) {
    hasCA <- "check.attributes" %in% ...names()
    ae <- if (hasCA) 
      all.equal(cld, c2, ...)
    else all.equal(cld, c2, check.attributes = FALSE, ...)
    if (isTRUE(ae) && !hasCA) 
      ae <- all.equal(cld, c2, ...)
    return(sprintf("Class definitions are not identical%s", if (isTRUE(ae)) "" else paste(":", ae, collapse = " ")))
  }
  if (!isS4(cld)) 
    return(if (identical(target, current)) TRUE else "different prototypical 'envRefClass' objects")
  flds <- names(cld@fieldClasses)
  asL <- function(O) sapply(flds, function(ch) O[[ch]], simplify = FALSE)
  n <- all.equal.list(asL(target), asL(current), ...)
  sns <- names(cld@slots)
  sns <- sns[sns != ".xData"]
  msg <- if (length(sns)) {
    L <- lapply(sns, function(sn) all.equal(methods::slot(target, sn), methods::slot(current, sn), ...))
    unlist(L[vapply(L, is.character, NA)])
  }
  if (is.character(n)) 
    msg <- c(msg, n)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  if (!methods::is(target, "envRefClass")) 
    return("'target' is not an envRefClass")
  if (!methods::is(current, "envRefClass")) 
    return("'current' is not an envRefClass")
  if (!isTRUE(ae <- all.equal(class(target), class(current), ...))) 
    return(sprintf("Classes differ: %s", paste(ae, collapse = " ")))
  getCl <- function(x) {
    cl <- tryCatch(x$getClass(), error = function(e) NULL)
    if (is.null(cl)) 
      class(x)
    else cl
  }
  if (!identical(cld <- getCl(target), c2 <- getCl(current))) {
    hasCA <- "check.attributes" %in% ...names()
    ae <- if (hasCA) 
      all.equal(cld, c2, ...)
    else all.equal(cld, c2, check.attributes = FALSE, ...)
    if (isTRUE(ae) && !hasCA) 
      ae <- all.equal(cld, c2, ...)
    return(sprintf("Class definitions are not identical%s", if (isTRUE(ae)) "" else paste(":", ae, collapse = " ")))
  }
  if (!isS4(cld)) 
    return(if (identical(target, current)) TRUE else "different prototypical 'envRefClass' objects")
  flds <- names(cld@fieldClasses)
  asL <- function(O) sapply(flds, function(ch) O[[ch]], simplify = FALSE)
  n <- all.equal.list(asL(target), asL(current), ...)
  sns <- names(cld@slots)
  sns <- sns[sns != ".xData"]
  msg <- if (length(sns)) {
    L <- lapply(sns, function(sn) all.equal(methods::slot(target, sn), methods::slot(current, sn), ...))
    unlist(L[vapply(L, is.character, NA)])
  }
  if (is.character(n)) 
    msg <- c(msg, n)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  if (!methods::is(target, "envRefClass")) 
    return("'target' is not an envRefClass")
  if (!methods::is(current, "envRefClass")) 
    return("'current' is not an envRefClass")
  if (!isTRUE(ae <- all.equal(class(target), class(current), ...))) 
    return(sprintf("Classes differ: %s", paste(ae, collapse = " ")))
  getCl <- function(x) {
    cl <- tryCatch(x$getClass(), error = function(e) NULL)
    if (is.null(cl)) 
      class(x)
    else cl
  }
  if (!identical(cld <- getCl(target), c2 <- getCl(current))) {
    hasCA <- "check.attributes" %in% ...names()
    ae <- if (hasCA) 
      all.equal(cld, c2, ...)
    else all.equal(cld, c2, check.attributes = FALSE, ...)
    if (isTRUE(ae) && !hasCA) 
      ae <- all.equal(cld, c2, ...)
    return(sprintf("Class definitions are not identical%s", if (isTRUE(ae)) "" else paste(":", ae, collapse = " ")))
  }
  if (!isS4(cld)) 
    return(if (identical(target, current)) TRUE else "different prototypical 'envRefClass' objects")
  flds <- names(cld@fieldClasses)
  asL <- function(O) sapply(flds, function(ch) O[[ch]], simplify = FALSE)
  n <- all.equal.list(asL(target), asL(current), ...)
  sns <- names(cld@slots)
  sns <- sns[sns != ".xData"]
  msg <- if (length(sns)) {
    L <- lapply(sns, function(sn) all.equal(methods::slot(target, sn), methods::slot(current, sn), ...))
    unlist(L[vapply(L, is.character, NA)])
  }
  if (is.character(n)) 
    msg <- c(msg, n)
  if (is.null(msg)) 
    TRUE
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
224)all.equal.factor
list(`package:base` = function (target, current, ..., check.attributes = TRUE) 
{
  if (!inherits(current, "factor")) 
    return("'current' is not a factor")
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  class(target) <- class(current) <- NULL
  nax <- is.na(target)
  nay <- is.na(current)
  n <- sum(nax != nay)
  if (n > 1) 
    msg <- c(msg, paste(n, "NA mismatches"))
  else if (n == 1) 
    msg <- c(msg, paste("1, NA mismatch"))
  else {
    target <- levels(target)[target[!nax]]
    current <- levels(current)[current[!nay]]
    n <- all.equal(target, current, check.attributes = check.attributes, ...)
    if (is.character(n)) 
      msg <- c(msg, n)
  }
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!inherits(current, "factor")) 
    return("'current' is not a factor")
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  class(target) <- class(current) <- NULL
  nax <- is.na(target)
  nay <- is.na(current)
  n <- sum(nax != nay)
  if (n > 1) 
    msg <- c(msg, paste(n, "NA mismatches"))
  else if (n == 1) 
    msg <- c(msg, paste("1, NA mismatch"))
  else {
    target <- levels(target)[target[!nax]]
    current <- levels(current)[current[!nay]]
    n <- all.equal(target, current, check.attributes = check.attributes, ...)
    if (is.character(n)) 
      msg <- c(msg, n)
  }
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!inherits(current, "factor")) 
    return("'current' is not a factor")
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  class(target) <- class(current) <- NULL
  nax <- is.na(target)
  nay <- is.na(current)
  n <- sum(nax != nay)
  if (n > 1) 
    msg <- c(msg, paste(n, "NA mismatches"))
  else if (n == 1) 
    msg <- c(msg, paste("1, NA mismatch"))
  else {
    target <- levels(target)[target[!nax]]
    current <- levels(current)[current[!nay]]
    n <- all.equal(target, current, check.attributes = check.attributes, ...)
    if (is.character(n)) 
      msg <- c(msg, n)
  }
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!inherits(current, "factor")) 
    return("'current' is not a factor")
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  class(target) <- class(current) <- NULL
  nax <- is.na(target)
  nay <- is.na(current)
  n <- sum(nax != nay)
  if (n > 1) 
    msg <- c(msg, paste(n, "NA mismatches"))
  else if (n == 1) 
    msg <- c(msg, paste("1, NA mismatch"))
  else {
    target <- levels(target)[target[!nax]]
    current <- levels(current)[current[!nay]]
    n <- all.equal(target, current, check.attributes = check.attributes, ...)
    if (is.character(n)) 
      msg <- c(msg, n)
  }
  if (is.null(msg)) 
    TRUE
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
225)all.equal.formula
list(`package:base` = function (target, current, ...) 
{
  if (length(target) != length(current)) 
    return(paste0("target, current differ in having response: ", length(target) == 3, ", ", length(current) == 3))
  if (!identical(deparse(target), deparse(current))) 
    "formulas differ in contents"
  else TRUE
}, function (target, current, ...) 
{
  if (length(target) != length(current)) 
    return(paste0("target, current differ in having response: ", length(target) == 3, ", ", length(current) == 3))
  if (!identical(deparse(target), deparse(current))) 
    "formulas differ in contents"
  else TRUE
}, function (target, current, ...) 
{
  if (length(target) != length(current)) 
    return(paste0("target, current differ in having response: ", length(target) == 3, ", ", length(current) == 3))
  if (!identical(deparse(target), deparse(current))) 
    "formulas differ in contents"
  else TRUE
}, function (target, current, ...) 
{
  if (length(target) != length(current)) 
    return(paste0("target, current differ in having response: ", length(target) == 3, ", ", length(current) == 3))
  if (!identical(deparse(target), deparse(current))) 
    "formulas differ in contents"
  else TRUE
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
226)all.equal.function
list(`package:base` = function (target, current, check.environment = TRUE, ...) 
{
  msg <- all.equal.language(target, current, ...)
  if (check.environment) {
    ee <- identical(environment(target), environment(current), ignore.environment = FALSE)
    if (!ee) 
      ee <- all.equal.environment(environment(target), environment(current), ...)
    if (isTRUE(msg)) 
      ee
    else c(msg, if (!isTRUE(ee)) ee)
  }
  else msg
}, function (target, current, check.environment = TRUE, ...) 
{
  msg <- all.equal.language(target, current, ...)
  if (check.environment) {
    ee <- identical(environment(target), environment(current), ignore.environment = FALSE)
    if (!ee) 
      ee <- all.equal.environment(environment(target), environment(current), ...)
    if (isTRUE(msg)) 
      ee
    else c(msg, if (!isTRUE(ee)) ee)
  }
  else msg
}, function (target, current, check.environment = TRUE, ...) 
{
  msg <- all.equal.language(target, current, ...)
  if (check.environment) {
    ee <- identical(environment(target), environment(current), ignore.environment = FALSE)
    if (!ee) 
      ee <- all.equal.environment(environment(target), environment(current), ...)
    if (isTRUE(msg)) 
      ee
    else c(msg, if (!isTRUE(ee)) ee)
  }
  else msg
}, function (target, current, check.environment = TRUE, ...) 
{
  msg <- all.equal.language(target, current, ...)
  if (check.environment) {
    ee <- identical(environment(target), environment(current), ignore.environment = FALSE)
    if (!ee) 
      ee <- all.equal.environment(environment(target), environment(current), ...)
    if (isTRUE(msg)) 
      ee
    else c(msg, if (!isTRUE(ee)) ee)
  }
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
227)all.equal.language
list(`package:base` = function (target, current, ...) 
{
  mt <- mode(target)
  mc <- mode(current)
  if (mt == "expression" && mc == "expression") 
    return(all.equal.list(target, current, ...))
  ttxt <- paste(deparse(target), collapse = "\n")
  ctxt <- tryCatch(paste(deparse(current), collapse = "\n"), error = function(e) NULL)
  msg <- c(if (mt != mc) paste0("Modes of target, current: ", mt, ", ", mc), if (is.null(ctxt)) "current is not deparse()able" else if (ttxt != ctxt) {
    if (pmatch(ttxt, ctxt, 0)) "target is a subset of current" else if (pmatch(ctxt, ttxt, 0)) "current is a subset of target" else "target, current do not match when deparsed"
  })
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  mt <- mode(target)
  mc <- mode(current)
  if (mt == "expression" && mc == "expression") 
    return(all.equal.list(target, current, ...))
  ttxt <- paste(deparse(target), collapse = "\n")
  ctxt <- tryCatch(paste(deparse(current), collapse = "\n"), error = function(e) NULL)
  msg <- c(if (mt != mc) paste0("Modes of target, current: ", mt, ", ", mc), if (is.null(ctxt)) "current is not deparse()able" else if (ttxt != ctxt) {
    if (pmatch(ttxt, ctxt, 0)) "target is a subset of current" else if (pmatch(ctxt, ttxt, 0)) "current is a subset of target" else "target, current do not match when deparsed"
  })
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  mt <- mode(target)
  mc <- mode(current)
  if (mt == "expression" && mc == "expression") 
    return(all.equal.list(target, current, ...))
  ttxt <- paste(deparse(target), collapse = "\n")
  ctxt <- tryCatch(paste(deparse(current), collapse = "\n"), error = function(e) NULL)
  msg <- c(if (mt != mc) paste0("Modes of target, current: ", mt, ", ", mc), if (is.null(ctxt)) "current is not deparse()able" else if (ttxt != ctxt) {
    if (pmatch(ttxt, ctxt, 0)) "target is a subset of current" else if (pmatch(ctxt, ttxt, 0)) "current is a subset of target" else "target, current do not match when deparsed"
  })
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ...) 
{
  mt <- mode(target)
  mc <- mode(current)
  if (mt == "expression" && mc == "expression") 
    return(all.equal.list(target, current, ...))
  ttxt <- paste(deparse(target), collapse = "\n")
  ctxt <- tryCatch(paste(deparse(current), collapse = "\n"), error = function(e) NULL)
  msg <- c(if (mt != mc) paste0("Modes of target, current: ", mt, ", ", mc), if (is.null(ctxt)) "current is not deparse()able" else if (ttxt != ctxt) {
    if (pmatch(ttxt, ctxt, 0)) "target is a subset of current" else if (pmatch(ctxt, ttxt, 0)) "current is a subset of target" else "target, current do not match when deparsed"
  })
  if (is.null(msg)) 
    TRUE
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
228)all.equal.list
list(`package:base` = function (target, current, ..., check.attributes = TRUE, use.names = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  if (!is.logical(use.names)) 
    stop(gettextf("'%s' must be logical", "use.names"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  target <- unclass(target)
  current <- unclass(current)
  if (!is.list(target) && !is.vector(target)) 
    return(c(msg, "target is not list-like"))
  if (!is.list(current) && !is.vector(current)) 
    return(c(msg, "current is not list-like"))
  if ((n <- length(target)) != length(current)) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    n <- min(n, length(current))
    msg <- c(msg, paste("Length mismatch: comparison on first", n, "components"))
  }
  iseq <- seq_len(n)
  if (use.names) 
    use.names <- (length(nt <- names(target)[iseq]) == n && length(nc <- names(current)[iseq]) == n)
  for (i in iseq) {
    mi <- all.equal(target[[i]], current[[i]], check.attributes = check.attributes, use.names = use.names, ...)
    if (is.character(mi)) 
      msg <- c(msg, paste0("Component ", if (use.names && nt[i] == nc[i]) dQuote(nt[i]) else i, ": ", mi))
  }
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., check.attributes = TRUE, use.names = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  if (!is.logical(use.names)) 
    stop(gettextf("'%s' must be logical", "use.names"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  target <- unclass(target)
  current <- unclass(current)
  if (!is.list(target) && !is.vector(target)) 
    return(c(msg, "target is not list-like"))
  if (!is.list(current) && !is.vector(current)) 
    return(c(msg, "current is not list-like"))
  if ((n <- length(target)) != length(current)) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    n <- min(n, length(current))
    msg <- c(msg, paste("Length mismatch: comparison on first", n, "components"))
  }
  iseq <- seq_len(n)
  if (use.names) 
    use.names <- (length(nt <- names(target)[iseq]) == n && length(nc <- names(current)[iseq]) == n)
  for (i in iseq) {
    mi <- all.equal(target[[i]], current[[i]], check.attributes = check.attributes, use.names = use.names, ...)
    if (is.character(mi)) 
      msg <- c(msg, paste0("Component ", if (use.names && nt[i] == nc[i]) dQuote(nt[i]) else i, ": ", mi))
  }
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., check.attributes = TRUE, use.names = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  if (!is.logical(use.names)) 
    stop(gettextf("'%s' must be logical", "use.names"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  target <- unclass(target)
  current <- unclass(current)
  if (!is.list(target) && !is.vector(target)) 
    return(c(msg, "target is not list-like"))
  if (!is.list(current) && !is.vector(current)) 
    return(c(msg, "current is not list-like"))
  if ((n <- length(target)) != length(current)) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    n <- min(n, length(current))
    msg <- c(msg, paste("Length mismatch: comparison on first", n, "components"))
  }
  iseq <- seq_len(n)
  if (use.names) 
    use.names <- (length(nt <- names(target)[iseq]) == n && length(nc <- names(current)[iseq]) == n)
  for (i in iseq) {
    mi <- all.equal(target[[i]], current[[i]], check.attributes = check.attributes, use.names = use.names, ...)
    if (is.character(mi)) 
      msg <- c(msg, paste0("Component ", if (use.names && nt[i] == nc[i]) dQuote(nt[i]) else i, ": ", mi))
  }
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., check.attributes = TRUE, use.names = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  if (!is.logical(use.names)) 
    stop(gettextf("'%s' must be logical", "use.names"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  target <- unclass(target)
  current <- unclass(current)
  if (!is.list(target) && !is.vector(target)) 
    return(c(msg, "target is not list-like"))
  if (!is.list(current) && !is.vector(current)) 
    return(c(msg, "current is not list-like"))
  if ((n <- length(target)) != length(current)) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    n <- min(n, length(current))
    msg <- c(msg, paste("Length mismatch: comparison on first", n, "components"))
  }
  iseq <- seq_len(n)
  if (use.names) 
    use.names <- (length(nt <- names(target)[iseq]) == n && length(nc <- names(current)[iseq]) == n)
  for (i in iseq) {
    mi <- all.equal(target[[i]], current[[i]], check.attributes = check.attributes, use.names = use.names, ...)
    if (is.character(mi)) 
      msg <- c(msg, paste0("Component ", if (use.names && nt[i] == nc[i]) dQuote(nt[i]) else i, ": ", mi))
  }
  if (is.null(msg)) 
    TRUE
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
229)all.equal.numeric
list(`package:base` = function (target, current, tolerance = sqrt(.Machine$double.eps), scale = NULL, countEQ = FALSE, formatFUN = function(err, what) format(err), ..., check.attributes = TRUE) 
{
  if (!is.numeric(tolerance)) 
    stop("'tolerance' should be numeric")
  stopifnot(length(tolerance) == 1)
  if (!is.numeric(scale) && !is.null(scale)) 
    stop("'scale' should be numeric or NULL")
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, tolerance = tolerance, scale = scale, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  cplx <- is.complex(target)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0(if (cplx) "Complex" else "Numeric", ": lengths (", lt, ", ", lc, ") differ"))
    return(msg)
  }
  target <- as.vector(target)
  current <- as.vector(current)
  out <- is.na(target)
  if (any(out != is.na(current))) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(is.na(current)), "in current", sum(out), "in target"))
    return(msg)
  }
  out <- out | target == current
  if (all(out)) 
    return(if (is.null(msg)) TRUE else msg)
  anyO <- any(out)
  sabst0 <- if (countEQ && anyO) 
    mean(abs(target[out]))
  else 0
  if (anyO) {
    keep <- which(!out)
    target <- target[keep]
    current <- current[keep]
    if (!is.null(scale) && length(scale) > 1) 
      scale <- rep_len(scale, length(out))[keep]
  }
  N <- length(target)
  if (is.integer(target) && is.integer(current)) 
    target <- as.double(target)
  what <- if (is.null(scale)) {
    scale <- (sabst0 + sum(abs(target)/N))
    if (is.finite(scale) && scale > tolerance) {
      "relative"
    }
    else {
      scale <- 1
      "absolute"
    }
  }
  else {
    stopifnot(all(scale > 0))
    if (all(abs(scale - 1) < 1e-07)) 
      "absolute"
    else "scaled"
  }
  xy <- sum(abs(target - current)/(N * scale))
  if (cplx) 
    what <- paste(what, "Mod")
  if (is.na(xy) || xy > tolerance) 
    msg <- c(msg, paste("Mean", what, "difference:", formatFUN(xy, what)))
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, tolerance = sqrt(.Machine$double.eps), scale = NULL, countEQ = FALSE, formatFUN = function(err, what) format(err), ..., check.attributes = TRUE) 
{
  if (!is.numeric(tolerance)) 
    stop("'tolerance' should be numeric")
  stopifnot(length(tolerance) == 1)
  if (!is.numeric(scale) && !is.null(scale)) 
    stop("'scale' should be numeric or NULL")
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, tolerance = tolerance, scale = scale, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  cplx <- is.complex(target)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0(if (cplx) "Complex" else "Numeric", ": lengths (", lt, ", ", lc, ") differ"))
    return(msg)
  }
  target <- as.vector(target)
  current <- as.vector(current)
  out <- is.na(target)
  if (any(out != is.na(current))) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(is.na(current)), "in current", sum(out), "in target"))
    return(msg)
  }
  out <- out | target == current
  if (all(out)) 
    return(if (is.null(msg)) TRUE else msg)
  anyO <- any(out)
  sabst0 <- if (countEQ && anyO) 
    mean(abs(target[out]))
  else 0
  if (anyO) {
    keep <- which(!out)
    target <- target[keep]
    current <- current[keep]
    if (!is.null(scale) && length(scale) > 1) 
      scale <- rep_len(scale, length(out))[keep]
  }
  N <- length(target)
  if (is.integer(target) && is.integer(current)) 
    target <- as.double(target)
  what <- if (is.null(scale)) {
    scale <- (sabst0 + sum(abs(target)/N))
    if (is.finite(scale) && scale > tolerance) {
      "relative"
    }
    else {
      scale <- 1
      "absolute"
    }
  }
  else {
    stopifnot(all(scale > 0))
    if (all(abs(scale - 1) < 1e-07)) 
      "absolute"
    else "scaled"
  }
  xy <- sum(abs(target - current)/(N * scale))
  if (cplx) 
    what <- paste(what, "Mod")
  if (is.na(xy) || xy > tolerance) 
    msg <- c(msg, paste("Mean", what, "difference:", formatFUN(xy, what)))
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, tolerance = sqrt(.Machine$double.eps), scale = NULL, countEQ = FALSE, formatFUN = function(err, what) format(err), ..., check.attributes = TRUE) 
{
  if (!is.numeric(tolerance)) 
    stop("'tolerance' should be numeric")
  stopifnot(length(tolerance) == 1)
  if (!is.numeric(scale) && !is.null(scale)) 
    stop("'scale' should be numeric or NULL")
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, tolerance = tolerance, scale = scale, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  cplx <- is.complex(target)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0(if (cplx) "Complex" else "Numeric", ": lengths (", lt, ", ", lc, ") differ"))
    return(msg)
  }
  target <- as.vector(target)
  current <- as.vector(current)
  out <- is.na(target)
  if (any(out != is.na(current))) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(is.na(current)), "in current", sum(out), "in target"))
    return(msg)
  }
  out <- out | target == current
  if (all(out)) 
    return(if (is.null(msg)) TRUE else msg)
  anyO <- any(out)
  sabst0 <- if (countEQ && anyO) 
    mean(abs(target[out]))
  else 0
  if (anyO) {
    keep <- which(!out)
    target <- target[keep]
    current <- current[keep]
    if (!is.null(scale) && length(scale) > 1) 
      scale <- rep_len(scale, length(out))[keep]
  }
  N <- length(target)
  if (is.integer(target) && is.integer(current)) 
    target <- as.double(target)
  what <- if (is.null(scale)) {
    scale <- (sabst0 + sum(abs(target)/N))
    if (is.finite(scale) && scale > tolerance) {
      "relative"
    }
    else {
      scale <- 1
      "absolute"
    }
  }
  else {
    stopifnot(all(scale > 0))
    if (all(abs(scale - 1) < 1e-07)) 
      "absolute"
    else "scaled"
  }
  xy <- sum(abs(target - current)/(N * scale))
  if (cplx) 
    what <- paste(what, "Mod")
  if (is.na(xy) || xy > tolerance) 
    msg <- c(msg, paste("Mean", what, "difference:", formatFUN(xy, what)))
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, tolerance = sqrt(.Machine$double.eps), scale = NULL, countEQ = FALSE, formatFUN = function(err, what) format(err), ..., check.attributes = TRUE) 
{
  if (!is.numeric(tolerance)) 
    stop("'tolerance' should be numeric")
  stopifnot(length(tolerance) == 1)
  if (!is.numeric(scale) && !is.null(scale)) 
    stop("'scale' should be numeric or NULL")
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, tolerance = tolerance, scale = scale, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  cplx <- is.complex(target)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0(if (cplx) "Complex" else "Numeric", ": lengths (", lt, ", ", lc, ") differ"))
    return(msg)
  }
  target <- as.vector(target)
  current <- as.vector(current)
  out <- is.na(target)
  if (any(out != is.na(current))) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(is.na(current)), "in current", sum(out), "in target"))
    return(msg)
  }
  out <- out | target == current
  if (all(out)) 
    return(if (is.null(msg)) TRUE else msg)
  anyO <- any(out)
  sabst0 <- if (countEQ && anyO) 
    mean(abs(target[out]))
  else 0
  if (anyO) {
    keep <- which(!out)
    target <- target[keep]
    current <- current[keep]
    if (!is.null(scale) && length(scale) > 1) 
      scale <- rep_len(scale, length(out))[keep]
  }
  N <- length(target)
  if (is.integer(target) && is.integer(current)) 
    target <- as.double(target)
  what <- if (is.null(scale)) {
    scale <- (sabst0 + sum(abs(target)/N))
    if (is.finite(scale) && scale > tolerance) {
      "relative"
    }
    else {
      scale <- 1
      "absolute"
    }
  }
  else {
    stopifnot(all(scale > 0))
    if (all(abs(scale - 1) < 1e-07)) 
      "absolute"
    else "scaled"
  }
  xy <- sum(abs(target - current)/(N * scale))
  if (cplx) 
    what <- paste(what, "Mod")
  if (is.na(xy) || xy > tolerance) 
    msg <- c(msg, paste("Mean", what, "difference:", formatFUN(xy, what)))
  if (is.null(msg)) 
    TRUE
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
230)all.equal.POSIXt
list(`package:base` = function (target, current, ..., tolerance = 0.001, scale, check.tzone = TRUE) 
{
  if (!inherits(target, "POSIXt")) 
    return("'target' is not a POSIXt")
  if (!inherits(current, "POSIXt")) 
    return("'current' is not a POSIXt")
  target <- as.POSIXct(target)
  current <- as.POSIXct(current)
  msg <- NULL
  if (check.tzone) {
    tz <- function(dt) {
      if (is.null(tz <- attr(dt, "tzone"))) 
        ""
      else tz[1]
    }
    tzt <- tz(target)
    tzc <- tz(current)
    if (!isTRUE(tzt == tzc)) 
      msg <- sprintf("'tzone' attributes are inconsistent ('%s' and '%s')", tzt, tzc)
  }
  attr(target, "tzone") <- attr(current, "tzone") <- NULL
  val <- all.equal.numeric(target, current, ..., tolerance = tolerance, scale = 1)
  if (!isTRUE(val)) 
    msg <- c(msg, val)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., tolerance = 0.001, scale, check.tzone = TRUE) 
{
  if (!inherits(target, "POSIXt")) 
    return("'target' is not a POSIXt")
  if (!inherits(current, "POSIXt")) 
    return("'current' is not a POSIXt")
  target <- as.POSIXct(target)
  current <- as.POSIXct(current)
  msg <- NULL
  if (check.tzone) {
    tz <- function(dt) {
      if (is.null(tz <- attr(dt, "tzone"))) 
        ""
      else tz[1]
    }
    tzt <- tz(target)
    tzc <- tz(current)
    if (!isTRUE(tzt == tzc)) 
      msg <- sprintf("'tzone' attributes are inconsistent ('%s' and '%s')", tzt, tzc)
  }
  attr(target, "tzone") <- attr(current, "tzone") <- NULL
  val <- all.equal.numeric(target, current, ..., tolerance = tolerance, scale = 1)
  if (!isTRUE(val)) 
    msg <- c(msg, val)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., tolerance = 0.001, scale, check.tzone = TRUE) 
{
  if (!inherits(target, "POSIXt")) 
    return("'target' is not a POSIXt")
  if (!inherits(current, "POSIXt")) 
    return("'current' is not a POSIXt")
  target <- as.POSIXct(target)
  current <- as.POSIXct(current)
  msg <- NULL
  if (check.tzone) {
    tz <- function(dt) {
      if (is.null(tz <- attr(dt, "tzone"))) 
        ""
      else tz[1]
    }
    tzt <- tz(target)
    tzc <- tz(current)
    if (!isTRUE(tzt == tzc)) 
      msg <- sprintf("'tzone' attributes are inconsistent ('%s' and '%s')", tzt, tzc)
  }
  attr(target, "tzone") <- attr(current, "tzone") <- NULL
  val <- all.equal.numeric(target, current, ..., tolerance = tolerance, scale = 1)
  if (!isTRUE(val)) 
    msg <- c(msg, val)
  if (is.null(msg)) 
    TRUE
  else msg
}, function (target, current, ..., tolerance = 0.001, scale, check.tzone = TRUE) 
{
  if (!inherits(target, "POSIXt")) 
    return("'target' is not a POSIXt")
  if (!inherits(current, "POSIXt")) 
    return("'current' is not a POSIXt")
  target <- as.POSIXct(target)
  current <- as.POSIXct(current)
  msg <- NULL
  if (check.tzone) {
    tz <- function(dt) {
      if (is.null(tz <- attr(dt, "tzone"))) 
        ""
      else tz[1]
    }
    tzt <- tz(target)
    tzc <- tz(current)
    if (!isTRUE(tzt == tzc)) 
      msg <- sprintf("'tzone' attributes are inconsistent ('%s' and '%s')", tzt, tzc)
  }
  attr(target, "tzone") <- attr(current, "tzone") <- NULL
  val <- all.equal.numeric(target, current, ..., tolerance = tolerance, scale = 1)
  if (!isTRUE(val)) 
    msg <- c(msg, val)
  if (is.null(msg)) 
    TRUE
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
231)all.equal.raw
list(`package:base` = function (target, current, ..., check.attributes = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0("Lengths (", lt, ", ", lc, ") differ (comparison on first ", ll <- min(lt, lc), " components)"))
    ll <- seq_len(ll)
    target <- target[ll]
    current <- current[ll]
  }
  nas <- is.na(target)
  nasc <- is.na(current)
  if (any(nas != nasc)) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(nasc), "in current", sum(nas), "in target"))
    return(msg)
  }
  ne <- !nas & (target != current)
  if (!any(ne) && is.null(msg)) 
    TRUE
  else if (sum(ne) == 1) 
    c(msg, paste("1 element mismatch"))
  else if (sum(ne) > 1) 
    c(msg, paste(sum(ne), "element mismatches"))
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0("Lengths (", lt, ", ", lc, ") differ (comparison on first ", ll <- min(lt, lc), " components)"))
    ll <- seq_len(ll)
    target <- target[ll]
    current <- current[ll]
  }
  nas <- is.na(target)
  nasc <- is.na(current)
  if (any(nas != nasc)) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(nasc), "in current", sum(nas), "in target"))
    return(msg)
  }
  ne <- !nas & (target != current)
  if (!any(ne) && is.null(msg)) 
    TRUE
  else if (sum(ne) == 1) 
    c(msg, paste("1 element mismatch"))
  else if (sum(ne) > 1) 
    c(msg, paste(sum(ne), "element mismatches"))
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0("Lengths (", lt, ", ", lc, ") differ (comparison on first ", ll <- min(lt, lc), " components)"))
    ll <- seq_len(ll)
    target <- target[ll]
    current <- current[ll]
  }
  nas <- is.na(target)
  nasc <- is.na(current)
  if (any(nas != nasc)) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(nasc), "in current", sum(nas), "in target"))
    return(msg)
  }
  ne <- !nas & (target != current)
  if (!any(ne) && is.null(msg)) 
    TRUE
  else if (sum(ne) == 1) 
    c(msg, paste("1 element mismatch"))
  else if (sum(ne) > 1) 
    c(msg, paste(sum(ne), "element mismatches"))
  else msg
}, function (target, current, ..., check.attributes = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  msg <- if (check.attributes) 
    attr.all.equal(target, current, ...)
  if (data.class(target) != data.class(current)) {
    msg <- c(msg, paste0("target is ", data.class(target), ", current is ", data.class(current)))
    return(msg)
  }
  lt <- length(target)
  lc <- length(current)
  if (lt != lc) {
    if (!is.null(msg)) 
      msg <- msg[-grep("\\bLengths\\b", msg)]
    msg <- c(msg, paste0("Lengths (", lt, ", ", lc, ") differ (comparison on first ", ll <- min(lt, lc), " components)"))
    ll <- seq_len(ll)
    target <- target[ll]
    current <- current[ll]
  }
  nas <- is.na(target)
  nasc <- is.na(current)
  if (any(nas != nasc)) {
    msg <- c(msg, paste("'is.NA' value mismatch:", sum(nasc), "in current", sum(nas), "in target"))
    return(msg)
  }
  ne <- !nas & (target != current)
  if (!any(ne) && is.null(msg)) 
    TRUE
  else if (sum(ne) == 1) 
    c(msg, paste("1 element mismatch"))
  else if (sum(ne) > 1) 
    c(msg, paste(sum(ne), "element mismatches"))
  else msg
})
c("package:base", "registered S3 method for all from namespace base", "registered S3 method for all.equal from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
232)all.names
list(`package:base` = function (expr, functions = TRUE, max.names = -1, unique = FALSE) 
  .Internal(all.names(expr, functions, max.names, unique)), function (expr, functions = TRUE, max.names = -1, unique = FALSE) 
    .Internal(all.names(expr, functions, max.names, unique)), function (expr, functions = TRUE, max.names = -1, unique = FALSE) 
      .Internal(all.names(expr, functions, max.names, unique)))
c("package:base", "registered S3 method for all from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
233)all.vars
list(`package:base` = function (expr, functions = FALSE, max.names = -1, unique = TRUE) 
  .Internal(all.names(expr, functions, max.names, unique)), function (expr, functions = FALSE, max.names = -1, unique = TRUE) 
    .Internal(all.names(expr, functions, max.names, unique)), function (expr, functions = FALSE, max.names = -1, unique = TRUE) 
      .Internal(all.names(expr, functions, max.names, unique)))
c("package:base", "registered S3 method for all from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
234)allowInterrupts
list(`package:base` = function (expr) 
{
  suspended <- .Internal(interruptsSuspended())
  if (suspended) {
    on.exit(.Internal(interruptsSuspended(suspended)))
    .Internal(interruptsSuspended(FALSE))
    expr
  }
  else expr
}, function (expr) 
{
  suspended <- .Internal(interruptsSuspended())
  if (suspended) {
    on.exit(.Internal(interruptsSuspended(suspended)))
    .Internal(interruptsSuspended(FALSE))
    expr
  }
  else expr
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
235)any
list(`package:base` = .Primitive("any"), .Primitive("any"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
236)anyDuplicated
list(`package:base` = function (x, incomparables = FALSE, ...) 
  UseMethod("anyDuplicated"), function (x, incomparables = FALSE, ...) 
    UseMethod("anyDuplicated"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
237)anyDuplicated.array
list(`package:base` = function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  anyDuplicated.default(temp, fromLast = fromLast)
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  anyDuplicated.default(temp, fromLast = fromLast)
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  anyDuplicated.default(temp, fromLast = fromLast)
})
c("package:base", "registered S3 method for anyDuplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
238)anyDuplicated.data.frame
list(`package:base` = function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  if (any(i <- (lengths(lapply(x, dim)) == 2))) 
    x[i] <- lapply(x[i], split.data.frame, seq_len(nrow(x)))
  anyDuplicated(do.call(Map, `names<-`(c(list, x), NULL)), fromLast = fromLast)
}, function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  if (any(i <- (lengths(lapply(x, dim)) == 2))) 
    x[i] <- lapply(x[i], split.data.frame, seq_len(nrow(x)))
  anyDuplicated(do.call(Map, `names<-`(c(list, x), NULL)), fromLast = fromLast)
}, function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  if (any(i <- (lengths(lapply(x, dim)) == 2))) 
    x[i] <- lapply(x[i], split.data.frame, seq_len(nrow(x)))
  anyDuplicated(do.call(Map, `names<-`(c(list, x), NULL)), fromLast = fromLast)
})
c("package:base", "registered S3 method for anyDuplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
239)anyDuplicated.default
list(`package:base` = function (x, incomparables = FALSE, fromLast = FALSE, ...) 
  .Internal(anyDuplicated(x, incomparables, fromLast)), function (x, incomparables = FALSE, fromLast = FALSE, ...) 
    .Internal(anyDuplicated(x, incomparables, fromLast)), function (x, incomparables = FALSE, fromLast = FALSE, ...) 
      .Internal(anyDuplicated(x, incomparables, fromLast)))
c("package:base", "registered S3 method for anyDuplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
240)anyDuplicated.matrix
list(`package:base` = function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  anyDuplicated.default(temp, fromLast = fromLast)
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  anyDuplicated.default(temp, fromLast = fromLast)
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  anyDuplicated.default(temp, fromLast = fromLast)
})
c("package:base", "registered S3 method for anyDuplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
241)anyNA
list(`package:base` = .Primitive("anyNA"), .Primitive("anyNA"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
242)anyNA.data.frame
list(`package:base` = function (x, recursive = FALSE) 
  any(vapply(x, anyNA, NA, USE.NAMES = FALSE)), function (x, recursive = FALSE) 
    any(vapply(x, anyNA, NA, USE.NAMES = FALSE)), function (x, recursive = FALSE) 
      any(vapply(x, anyNA, NA, USE.NAMES = FALSE)))
c("package:base", "registered S3 method for anyNA from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
243)anyNA.numeric_version
list(`package:base` = function (x, recursive = FALSE) 
{
  anyNA(.encode_numeric_version(x))
}, function (x, recursive = FALSE) 
{
  anyNA(.encode_numeric_version(x))
}, function (x, recursive = FALSE) 
{
  anyNA(.encode_numeric_version(x))
})
c("package:base", "registered S3 method for anyNA from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
244)anyNA.POSIXlt
list(`package:base` = function (x, recursive = FALSE) 
  anyNA(as.POSIXct(x)), function (x, recursive = FALSE) 
    anyNA(as.POSIXct(x)), function (x, recursive = FALSE) 
      anyNA(as.POSIXct(x)))
c("package:base", "registered S3 method for anyNA from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
245)aperm
list(`package:base` = function (a, perm, ...) 
  UseMethod("aperm"), function (a, perm, ...) 
    UseMethod("aperm"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
246)aperm.default
list(`package:base` = function (a, perm = NULL, resize = TRUE, ...) 
  .Internal(aperm(a, perm, resize)), function (a, perm = NULL, resize = TRUE, ...) 
    .Internal(aperm(a, perm, resize)), function (a, perm = NULL, resize = TRUE, ...) 
      .Internal(aperm(a, perm, resize)))
c("package:base", "registered S3 method for aperm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
247)aperm.table
list(`package:base` = function (a, perm = NULL, resize = TRUE, keep.class = TRUE, ...) 
{
  r <- aperm.default(a, perm, resize = resize)
  if (keep.class) 
    class(r) <- class(a)
  r
}, function (a, perm = NULL, resize = TRUE, keep.class = TRUE, ...) 
{
  r <- aperm.default(a, perm, resize = resize)
  if (keep.class) 
    class(r) <- class(a)
  r
}, function (a, perm = NULL, resize = TRUE, keep.class = TRUE, ...) 
{
  r <- aperm.default(a, perm, resize = resize)
  if (keep.class) 
    class(r) <- class(a)
  r
})
c("package:base", "registered S3 method for aperm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
248)append
list(`package:base` = function (x, values, after = length(x)) 
{
  lengx <- length(x)
  if (!after) 
    c(values, x)
  else if (after >= lengx) 
    c(x, values)
  else c(x[1:after], values, x[(after + 1):lengx])
}, function (x, values, after = length(x)) 
{
  lengx <- length(x)
  if (!after) 
    c(values, x)
  else if (after >= lengx) 
    c(x, values)
  else c(x[1:after], values, x[(after + 1):lengx])
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
249)apply
list(`package:base` = function (X, MARGIN, FUN, ..., simplify = TRUE) 
{
  FUN <- match.fun(FUN)
  simplify <- isTRUE(simplify)
  dl <- length(dim(X))
  if (!dl) 
    stop("dim(X) must have a positive length")
  if (is.object(X)) 
    X <- if (dl == 2) 
      as.matrix(X)
  else as.array(X)
  d <- dim(X)
  dn <- dimnames(X)
  ds <- seq_len(dl)
  if (is.character(MARGIN)) {
    if (is.null(dnn <- names(dn))) 
      stop("'X' must have named dimnames")
    MARGIN <- match(MARGIN, dnn)
    if (anyNA(MARGIN)) 
      stop("not all elements of 'MARGIN' are names of dimensions")
  }
  d.call <- d[-MARGIN]
  d.ans <- d[MARGIN]
  if (anyNA(d.call) || anyNA(d.ans)) 
    stop("'MARGIN' does not match dim(X)")
  s.call <- ds[-MARGIN]
  s.ans <- ds[MARGIN]
  dn.call <- dn[-MARGIN]
  dn.ans <- dn[MARGIN]
  d2 <- prod(d.ans)
  if (d2 == 0) {
    newX <- array(vector(typeof(X), 1), dim = c(prod(d.call), 1))
    ans <- forceAndCall(1, FUN, if (length(d.call) < 2) newX[, 1] else array(newX[, 1], d.call, dn.call), ...)
    return(if (is.null(ans)) ans else if (length(d.ans) < 2) ans[1][-1] else array(ans, d.ans, dn.ans))
  }
  newX <- aperm(X, c(s.call, s.ans))
  dim(newX) <- c(prod(d.call), d2)
  ans <- vector("list", d2)
  if (length(d.call) < 2) {
    if (length(dn.call)) 
      dimnames(newX) <- c(dn.call, list(NULL))
    for (i in 1:d2) {
      tmp <- forceAndCall(1, FUN, newX[, i], ...)
      if (!is.null(tmp)) 
        ans[[i]] <- tmp
    }
  }
  else for (i in 1:d2) {
    tmp <- forceAndCall(1, FUN, array(newX[, i], d.call, dn.call), ...)
    if (!is.null(tmp)) 
      ans[[i]] <- tmp
  }
  ans.list <- !simplify || is.recursive(ans[[1]])
  l.ans <- length(ans[[1]])
  ans.names <- names(ans[[1]])
  if (!ans.list) 
    ans.list <- any(lengths(ans) != l.ans)
  if (!ans.list && length(ans.names)) {
    all.same <- vapply(ans, function(x) identical(names(x), ans.names), NA)
    if (!all(all.same)) 
      ans.names <- NULL
  }
  len.a <- if (ans.list) 
    d2
  else length(ans <- unlist(ans, recursive = FALSE))
  if (length(MARGIN) == 1 && len.a == d2) {
    names(ans) <- if (length(dn.ans[[1]])) 
      dn.ans[[1]]
    ans
  }
  else if (len.a == d2) 
    array(ans, d.ans, dn.ans)
  else if (len.a && len.a%%d2 == 0) {
    if (is.null(dn.ans)) 
      dn.ans <- vector(mode = "list", length(d.ans))
    dn1 <- list(ans.names)
    if (length(dn.call) && !is.null(n1 <- names(dn <- dn.call[1])) && nzchar(n1) && length(ans.names) == length(dn[[1]])) 
      names(dn1) <- n1
    dn.ans <- c(dn1, dn.ans)
    array(ans, c(len.a%/%d2, d.ans), if (!is.null(names(dn.ans)) || !all(vapply(dn.ans, is.null, NA))) 
      dn.ans)
  }
  else ans
}, function (X, MARGIN, FUN, ..., simplify = TRUE) 
{
  FUN <- match.fun(FUN)
  simplify <- isTRUE(simplify)
  dl <- length(dim(X))
  if (!dl) 
    stop("dim(X) must have a positive length")
  if (is.object(X)) 
    X <- if (dl == 2) 
      as.matrix(X)
  else as.array(X)
  d <- dim(X)
  dn <- dimnames(X)
  ds <- seq_len(dl)
  if (is.character(MARGIN)) {
    if (is.null(dnn <- names(dn))) 
      stop("'X' must have named dimnames")
    MARGIN <- match(MARGIN, dnn)
    if (anyNA(MARGIN)) 
      stop("not all elements of 'MARGIN' are names of dimensions")
  }
  d.call <- d[-MARGIN]
  d.ans <- d[MARGIN]
  if (anyNA(d.call) || anyNA(d.ans)) 
    stop("'MARGIN' does not match dim(X)")
  s.call <- ds[-MARGIN]
  s.ans <- ds[MARGIN]
  dn.call <- dn[-MARGIN]
  dn.ans <- dn[MARGIN]
  d2 <- prod(d.ans)
  if (d2 == 0) {
    newX <- array(vector(typeof(X), 1), dim = c(prod(d.call), 1))
    ans <- forceAndCall(1, FUN, if (length(d.call) < 2) newX[, 1] else array(newX[, 1], d.call, dn.call), ...)
    return(if (is.null(ans)) ans else if (length(d.ans) < 2) ans[1][-1] else array(ans, d.ans, dn.ans))
  }
  newX <- aperm(X, c(s.call, s.ans))
  dim(newX) <- c(prod(d.call), d2)
  ans <- vector("list", d2)
  if (length(d.call) < 2) {
    if (length(dn.call)) 
      dimnames(newX) <- c(dn.call, list(NULL))
    for (i in 1:d2) {
      tmp <- forceAndCall(1, FUN, newX[, i], ...)
      if (!is.null(tmp)) 
        ans[[i]] <- tmp
    }
  }
  else for (i in 1:d2) {
    tmp <- forceAndCall(1, FUN, array(newX[, i], d.call, dn.call), ...)
    if (!is.null(tmp)) 
      ans[[i]] <- tmp
  }
  ans.list <- !simplify || is.recursive(ans[[1]])
  l.ans <- length(ans[[1]])
  ans.names <- names(ans[[1]])
  if (!ans.list) 
    ans.list <- any(lengths(ans) != l.ans)
  if (!ans.list && length(ans.names)) {
    all.same <- vapply(ans, function(x) identical(names(x), ans.names), NA)
    if (!all(all.same)) 
      ans.names <- NULL
  }
  len.a <- if (ans.list) 
    d2
  else length(ans <- unlist(ans, recursive = FALSE))
  if (length(MARGIN) == 1 && len.a == d2) {
    names(ans) <- if (length(dn.ans[[1]])) 
      dn.ans[[1]]
    ans
  }
  else if (len.a == d2) 
    array(ans, d.ans, dn.ans)
  else if (len.a && len.a%%d2 == 0) {
    if (is.null(dn.ans)) 
      dn.ans <- vector(mode = "list", length(d.ans))
    dn1 <- list(ans.names)
    if (length(dn.call) && !is.null(n1 <- names(dn <- dn.call[1])) && nzchar(n1) && length(ans.names) == length(dn[[1]])) 
      names(dn1) <- n1
    dn.ans <- c(dn1, dn.ans)
    array(ans, c(len.a%/%d2, d.ans), if (!is.null(names(dn.ans)) || !all(vapply(dn.ans, is.null, NA))) 
      dn.ans)
  }
  else ans
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
250)Arg
list(`package:base` = .Primitive("Arg"), .Primitive("Arg"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
251)args
list(`package:base` = function (name) 
  .Internal(args(name)), function (name) 
    .Internal(args(name)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
252)array
list(`package:base` = function (data = NA, dim = length(data), dimnames = NULL) 
{
  if (is.atomic(data) && !is.object(data)) 
    return(.Internal(array(data, dim, dimnames)))
  data <- as.vector(data)
  if (is.object(data)) {
    dim <- as.integer(dim)
    if (!length(dim)) 
      stop("'dim' cannot be of length 0")
    vl <- prod(dim)
    if (length(data) != vl) {
      if (vl > .Machine$integer.max) 
        stop("'dim' specifies too large an array")
      data <- rep_len(data, vl)
    }
    if (length(dim)) 
      dim(data) <- dim
    if (is.list(dimnames) && length(dimnames)) 
      dimnames(data) <- dimnames
    data
  }
  else .Internal(array(data, dim, dimnames))
}, function (data = NA, dim = length(data), dimnames = NULL) 
{
  if (is.atomic(data) && !is.object(data)) 
    return(.Internal(array(data, dim, dimnames)))
  data <- as.vector(data)
  if (is.object(data)) {
    dim <- as.integer(dim)
    if (!length(dim)) 
      stop("'dim' cannot be of length 0")
    vl <- prod(dim)
    if (length(data) != vl) {
      if (vl > .Machine$integer.max) 
        stop("'dim' specifies too large an array")
      data <- rep_len(data, vl)
    }
    if (length(dim)) 
      dim(data) <- dim
    if (is.list(dimnames) && length(dimnames)) 
      dimnames(data) <- dimnames
    data
  }
  else .Internal(array(data, dim, dimnames))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
253)arrayInd
list(`package:base` = function (ind, .dim, .dimnames = NULL, useNames = FALSE) 
{
  m <- length(ind)
  rank <- length(.dim)
  wh1 <- ind - 1
  ind <- 1 + wh1%%.dim[1]
  dnms <- if (useNames) {
    list(.dimnames[[1]][ind], if (any(nzchar(nd <- names(.dimnames)))) nd else if (rank == 2) c("row", "col") else paste0("dim", seq_len(rank)))
  }
  ind <- matrix(ind, nrow = m, ncol = rank, dimnames = dnms)
  if (rank >= 2) {
    denom <- 1
    for (i in 2:rank) {
      denom <- denom * .dim[i - 1]
      nextd1 <- wh1%/%denom
      ind[, i] <- 1 + nextd1%%.dim[i]
    }
  }
  storage.mode(ind) <- "integer"
  ind
}, function (ind, .dim, .dimnames = NULL, useNames = FALSE) 
{
  m <- length(ind)
  rank <- length(.dim)
  wh1 <- ind - 1
  ind <- 1 + wh1%%.dim[1]
  dnms <- if (useNames) {
    list(.dimnames[[1]][ind], if (any(nzchar(nd <- names(.dimnames)))) nd else if (rank == 2) c("row", "col") else paste0("dim", seq_len(rank)))
  }
  ind <- matrix(ind, nrow = m, ncol = rank, dimnames = dnms)
  if (rank >= 2) {
    denom <- 1
    for (i in 2:rank) {
      denom <- denom * .dim[i - 1]
      nextd1 <- wh1%/%denom
      ind[, i] <- 1 + nextd1%%.dim[i]
    }
  }
  storage.mode(ind) <- "integer"
  ind
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
254)as.array
list(`package:base` = function (x, ...) 
  UseMethod("as.array"), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("as.array"), generic = "as.array", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
      UseMethod("as.array"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.array"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("as.array"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.array"))(x, ...)), function (x, ...) 
          UseMethod("as.array"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
255)as.array.default
list(`package:base` = function (x, ...) 
{
  if (is.array(x)) 
    return(x)
  n <- names(x)
  dim(x) <- length(x)
  if (length(n)) 
    dimnames(x) <- list(n)
  return(x)
}, function (x, ...) 
{
  if (is.array(x)) 
    return(x)
  n <- names(x)
  dim(x) <- length(x)
  if (length(n)) 
    dimnames(x) <- list(n)
  return(x)
}, function (x, ...) 
{
  if (is.array(x)) 
    return(x)
  n <- names(x)
  dim(x) <- length(x)
  if (length(n)) 
    dimnames(x) <- list(n)
  return(x)
})
c("package:base", "registered S3 method for as.array from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
256)as.call
list(`package:base` = .Primitive("as.call"), .Primitive("as.call"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
257)as.character
list(`package:base` = .Primitive("as.character"), .Primitive("as.character"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
258)as.character.condition
list(`package:base` = function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  cl <- class(x)[1]
  if (!is.null(call)) 
    paste0(cl, " in ", deparse(call, nlines = 1), ": ", msg, "\n")
  else paste0(cl, ": ", msg, "\n")
}, function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  cl <- class(x)[1]
  if (!is.null(call)) 
    paste0(cl, " in ", deparse(call, nlines = 1), ": ", msg, "\n")
  else paste0(cl, ": ", msg, "\n")
}, function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  cl <- class(x)[1]
  if (!is.null(call)) 
    paste0(cl, " in ", deparse(call, nlines = 1), ": ", msg, "\n")
  else paste0(cl, ": ", msg, "\n")
})
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
259)as.character.Date
list(`package:base` = function (x, ...) 
  format(x, ...), function (x, ...) 
    format(x, ...), function (x, ...) 
      format(x, ...))
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
260)as.character.default
list(`package:base` = function (x, ...) 
  .Internal(as.vector(x, "character")), function (x, ...) 
    .Internal(as.vector(x, "character")), function (x, ...) 
      .Internal(as.vector(x, "character")))
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
261)as.character.error
list(`package:base` = function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  if (!is.null(call)) 
    paste0("Error in ", deparse(call, nlines = 1), ": ", msg, "\n")
  else paste0("Error: ", msg, "\n")
}, function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  if (!is.null(call)) 
    paste0("Error in ", deparse(call, nlines = 1), ": ", msg, "\n")
  else paste0("Error: ", msg, "\n")
}, function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  if (!is.null(call)) 
    paste0("Error in ", deparse(call, nlines = 1), ": ", msg, "\n")
  else paste0("Error: ", msg, "\n")
})
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
262)as.character.factor
list(`package:base` = function (x, ...) 
  .Internal(asCharacterFactor(x)), function (x, ...) 
    .Internal(asCharacterFactor(x)), function (x, ...) 
      .Internal(asCharacterFactor(x)))
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
263)as.character.hexmode
list(`package:base` = function (x, ...) 
{
  ans <- rep_len(NA, length(x))
  notNA <- !is.na(x)
  ans[notNA] <- sprintf("%x", as.integer(x[notNA]))
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
}, function (x, ...) 
{
  ans <- rep_len(NA, length(x))
  notNA <- !is.na(x)
  ans[notNA] <- sprintf("%x", as.integer(x[notNA]))
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
}, function (x, ...) 
{
  ans <- rep_len(NA, length(x))
  notNA <- !is.na(x)
  ans[notNA] <- sprintf("%x", as.integer(x[notNA]))
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
})
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
264)as.character.numeric_version
list(`package:base` = function (x, ...) 
  as.character(format(x)), function (x, ...) 
    as.character(format(x)), function (x, ...) 
      as.character(format(x)))
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
265)as.character.octmode
list(`package:base` = function (x, ...) 
{
  ans <- rep_len(NA, length(x))
  notNA <- !is.na(x)
  ans[notNA] <- sprintf("%o", as.integer(x[notNA]))
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
}, function (x, ...) 
{
  ans <- rep_len(NA, length(x))
  notNA <- !is.na(x)
  ans[notNA] <- sprintf("%o", as.integer(x[notNA]))
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
}, function (x, ...) 
{
  ans <- rep_len(NA, length(x))
  notNA <- !is.na(x)
  ans[notNA] <- sprintf("%o", as.integer(x[notNA]))
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
})
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
266)as.character.POSIXt
list(`package:base` = function (x, ...) 
  format(x, ...), function (x, ...) 
    format(x, ...), function (x, ...) 
      format(x, ...))
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
267)as.character.srcref
list(`package:base` = function (x, useSource = TRUE, to = x, ...) 
{
  srcfile <- attr(x, "srcfile")
  if (!missing(to)) {
    if (!identical(srcfile, attr(to, "srcfile"))) 
      stop("'x' and 'to' must refer to same file")
    x[c(3, 4, 6, 8)] <- to[c(3, 4, 6, 8)]
  }
  if (!is.null(srcfile) && !inherits(srcfile, "srcfile")) {
    cat("forcing class on")
    print(utils::str(srcfile))
    class(srcfile) <- c("srcfilealias", "srcfile")
  }
  if (useSource) {
    if (inherits(srcfile, "srcfilecopy") || inherits(srcfile, "srcfilealias")) 
      lines <- try(getSrcLines(srcfile, x[7], x[8]), TRUE)
    else lines <- try(getSrcLines(srcfile, x[1], x[3]), TRUE)
  }
  if (!useSource || inherits(lines, "try-error")) 
    lines <- paste0("<srcref: file \"", srcfile$filename, "\" chars ", x[1], ":", x[5], " to ", x[3], ":", x[6], ">")
  else if (length(lines)) {
    enc <- Encoding(lines)
    Encoding(lines) <- "latin1"
    if (length(lines) < x[3] - x[1] + 1) 
      x[4] <- .Machine$integer.max
    lines[length(lines)] <- substring(lines[length(lines)], 1, x[4])
    lines[1] <- substring(lines[1], x[2])
    Encoding(lines) <- enc
  }
  lines
}, function (x, useSource = TRUE, to = x, ...) 
{
  srcfile <- attr(x, "srcfile")
  if (!missing(to)) {
    if (!identical(srcfile, attr(to, "srcfile"))) 
      stop("'x' and 'to' must refer to same file")
    x[c(3, 4, 6, 8)] <- to[c(3, 4, 6, 8)]
  }
  if (!is.null(srcfile) && !inherits(srcfile, "srcfile")) {
    cat("forcing class on")
    print(utils::str(srcfile))
    class(srcfile) <- c("srcfilealias", "srcfile")
  }
  if (useSource) {
    if (inherits(srcfile, "srcfilecopy") || inherits(srcfile, "srcfilealias")) 
      lines <- try(getSrcLines(srcfile, x[7], x[8]), TRUE)
    else lines <- try(getSrcLines(srcfile, x[1], x[3]), TRUE)
  }
  if (!useSource || inherits(lines, "try-error")) 
    lines <- paste0("<srcref: file \"", srcfile$filename, "\" chars ", x[1], ":", x[5], " to ", x[3], ":", x[6], ">")
  else if (length(lines)) {
    enc <- Encoding(lines)
    Encoding(lines) <- "latin1"
    if (length(lines) < x[3] - x[1] + 1) 
      x[4] <- .Machine$integer.max
    lines[length(lines)] <- substring(lines[length(lines)], 1, x[4])
    lines[1] <- substring(lines[1], x[2])
    Encoding(lines) <- enc
  }
  lines
}, function (x, useSource = TRUE, to = x, ...) 
{
  srcfile <- attr(x, "srcfile")
  if (!missing(to)) {
    if (!identical(srcfile, attr(to, "srcfile"))) 
      stop("'x' and 'to' must refer to same file")
    x[c(3, 4, 6, 8)] <- to[c(3, 4, 6, 8)]
  }
  if (!is.null(srcfile) && !inherits(srcfile, "srcfile")) {
    cat("forcing class on")
    print(utils::str(srcfile))
    class(srcfile) <- c("srcfilealias", "srcfile")
  }
  if (useSource) {
    if (inherits(srcfile, "srcfilecopy") || inherits(srcfile, "srcfilealias")) 
      lines <- try(getSrcLines(srcfile, x[7], x[8]), TRUE)
    else lines <- try(getSrcLines(srcfile, x[1], x[3]), TRUE)
  }
  if (!useSource || inherits(lines, "try-error")) 
    lines <- paste0("<srcref: file \"", srcfile$filename, "\" chars ", x[1], ":", x[5], " to ", x[3], ":", x[6], ">")
  else if (length(lines)) {
    enc <- Encoding(lines)
    Encoding(lines) <- "latin1"
    if (length(lines) < x[3] - x[1] + 1) 
      x[4] <- .Machine$integer.max
    lines[length(lines)] <- substring(lines[length(lines)], 1, x[4])
    lines[1] <- substring(lines[1], x[2])
    Encoding(lines) <- enc
  }
  lines
})
c("package:base", "registered S3 method for as.character from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
268)as.complex
list(`package:base` = .Primitive("as.complex"), .Primitive("as.complex"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
269)as.data.frame
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ...) 
{
  if (is.null(x)) 
    return(as.data.frame(list()))
  UseMethod("as.data.frame")
}, function (x, row.names = NULL, optional = FALSE, ...) 
{
  if (is.null(x)) 
    return(as.data.frame(list()))
  UseMethod("as.data.frame")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
270)as.data.frame.array
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ...) 
{
  d <- dim(x)
  if (length(d) == 1) {
    value <- as.data.frame.vector(c(x), row.names, optional, ...)
    if (!optional) 
      names(value) <- deparse(substitute(x))[[1]]
    value
  }
  else if (length(d) == 2) {
    as.data.frame.matrix(x, row.names, optional, ...)
  }
  else {
    dn <- dimnames(x)
    dim(x) <- c(d[1], prod(d[-1]))
    if (!is.null(dn)) {
      if (length(dn[[1]])) 
        rownames(x) <- dn[[1]]
      for (i in 2:length(d)) if (is.null(dn[[i]])) 
        dn[[i]] <- seq_len(d[i])
      colnames(x) <- interaction(expand.grid(dn[-1]))
    }
    as.data.frame.matrix(x, row.names, optional, ...)
  }
}, function (x, row.names = NULL, optional = FALSE, ...) 
{
  d <- dim(x)
  if (length(d) == 1) {
    value <- as.data.frame.vector(c(x), row.names, optional, ...)
    if (!optional) 
      names(value) <- deparse(substitute(x))[[1]]
    value
  }
  else if (length(d) == 2) {
    as.data.frame.matrix(x, row.names, optional, ...)
  }
  else {
    dn <- dimnames(x)
    dim(x) <- c(d[1], prod(d[-1]))
    if (!is.null(dn)) {
      if (length(dn[[1]])) 
        rownames(x) <- dn[[1]]
      for (i in 2:length(d)) if (is.null(dn[[i]])) 
        dn[[i]] <- seq_len(d[i])
      colnames(x) <- interaction(expand.grid(dn[-1]))
    }
    as.data.frame.matrix(x, row.names, optional, ...)
  }
}, function (x, row.names = NULL, optional = FALSE, ...) 
{
  d <- dim(x)
  if (length(d) == 1) {
    value <- as.data.frame.vector(c(x), row.names, optional, ...)
    if (!optional) 
      names(value) <- deparse(substitute(x))[[1]]
    value
  }
  else if (length(d) == 2) {
    as.data.frame.matrix(x, row.names, optional, ...)
  }
  else {
    dn <- dimnames(x)
    dim(x) <- c(d[1], prod(d[-1]))
    if (!is.null(dn)) {
      if (length(dn[[1]])) 
        rownames(x) <- dn[[1]]
      for (i in 2:length(d)) if (is.null(dn[[i]])) 
        dn[[i]] <- seq_len(d[i])
      colnames(x) <- interaction(expand.grid(dn[-1]))
    }
    as.data.frame.matrix(x, row.names, optional, ...)
  }
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
271)as.data.frame.AsIs
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ...) 
{
  if (length(dim(x)) == 2) 
    as.data.frame.model.matrix(x, row.names, optional)
  else {
    nrows <- length(x)
    nm <- deparse1(substitute(x))
    if (is.null(row.names)) {
      autoRN <- FALSE
      if (nrows == 0) 
        row.names <- character()
      else if (length(row.names <- names(x)) == nrows && !anyDuplicated(row.names)) {
      }
      else {
        autoRN <- TRUE
        row.names <- .set_row_names(nrows)
      }
    }
    else autoRN <- is.integer(row.names) && length(row.names) == 2 && is.na(rn1 <- row.names[[1]]) && rn1 < 0
    value <- list(x)
    if (!optional) 
      names(value) <- nm
    class(value) <- "data.frame"
    attr(value, "row.names") <- row.names
    value
  }
}, function (x, row.names = NULL, optional = FALSE, ...) 
{
  if (length(dim(x)) == 2) 
    as.data.frame.model.matrix(x, row.names, optional)
  else {
    nrows <- length(x)
    nm <- deparse1(substitute(x))
    if (is.null(row.names)) {
      autoRN <- FALSE
      if (nrows == 0) 
        row.names <- character()
      else if (length(row.names <- names(x)) == nrows && !anyDuplicated(row.names)) {
      }
      else {
        autoRN <- TRUE
        row.names <- .set_row_names(nrows)
      }
    }
    else autoRN <- is.integer(row.names) && length(row.names) == 2 && is.na(rn1 <- row.names[[1]]) && rn1 < 0
    value <- list(x)
    if (!optional) 
      names(value) <- nm
    class(value) <- "data.frame"
    attr(value, "row.names") <- row.names
    value
  }
}, function (x, row.names = NULL, optional = FALSE, ...) 
{
  if (length(dim(x)) == 2) 
    as.data.frame.model.matrix(x, row.names, optional)
  else {
    nrows <- length(x)
    nm <- deparse1(substitute(x))
    if (is.null(row.names)) {
      autoRN <- FALSE
      if (nrows == 0) 
        row.names <- character()
      else if (length(row.names <- names(x)) == nrows && !anyDuplicated(row.names)) {
      }
      else {
        autoRN <- TRUE
        row.names <- .set_row_names(nrows)
      }
    }
    else autoRN <- is.integer(row.names) && length(row.names) == 2 && is.na(rn1 <- row.names[[1]]) && rn1 < 0
    value <- list(x)
    if (!optional) 
      names(value) <- nm
    class(value) <- "data.frame"
    attr(value, "row.names") <- row.names
    value
  }
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
272)as.data.frame.character
list(`package:base` = function (x, ..., stringsAsFactors = FALSE) 
{
  nm <- deparse1(substitute(x))
  if (stringsAsFactors) 
    x <- factor(x)
  if (!"nm" %in% ...names()) 
    as.data.frame.vector(x, ..., nm = nm)
  else as.data.frame.vector(x, ...)
}, function (x, ..., stringsAsFactors = FALSE) 
{
  nm <- deparse1(substitute(x))
  if (stringsAsFactors) 
    x <- factor(x)
  if (!"nm" %in% ...names()) 
    as.data.frame.vector(x, ..., nm = nm)
  else as.data.frame.vector(x, ...)
}, function (x, ..., stringsAsFactors = FALSE) 
{
  nm <- deparse1(substitute(x))
  if (stringsAsFactors) 
    x <- factor(x)
  if (!"nm" %in% ...names()) 
    as.data.frame.vector(x, ..., nm = nm)
  else as.data.frame.vector(x, ...)
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
273)as.data.frame.complex
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
274)as.data.frame.data.frame
list(`package:base` = function (x, row.names = NULL, ...) 
{
  cl <- oldClass(x)
  i <- match("data.frame", cl)
  if (i > 1) 
    class(x) <- cl[-(1:(i - 1))]
  if (!is.null(row.names)) {
    nr <- .row_names_info(x, 2)
    if (length(row.names) == nr) 
      attr(x, "row.names") <- row.names
    else stop(sprintf(ngettext(nr, "invalid 'row.names', length %d for a data frame with %d row", "invalid 'row.names', length %d for a data frame with %d rows"), length(row.names), nr), domain = NA)
  }
  x
}, function (x, row.names = NULL, ...) 
{
  cl <- oldClass(x)
  i <- match("data.frame", cl)
  if (i > 1) 
    class(x) <- cl[-(1:(i - 1))]
  if (!is.null(row.names)) {
    nr <- .row_names_info(x, 2)
    if (length(row.names) == nr) 
      attr(x, "row.names") <- row.names
    else stop(sprintf(ngettext(nr, "invalid 'row.names', length %d for a data frame with %d row", "invalid 'row.names', length %d for a data frame with %d rows"), length(row.names), nr), domain = NA)
  }
  x
}, function (x, row.names = NULL, ...) 
{
  cl <- oldClass(x)
  i <- match("data.frame", cl)
  if (i > 1) 
    class(x) <- cl[-(1:(i - 1))]
  if (!is.null(row.names)) {
    nr <- .row_names_info(x, 2)
    if (length(row.names) == nr) 
      attr(x, "row.names") <- row.names
    else stop(sprintf(ngettext(nr, "invalid 'row.names', length %d for a data frame with %d row", "invalid 'row.names', length %d for a data frame with %d rows"), length(row.names), nr), domain = NA)
  }
  x
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
275)as.data.frame.Date
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
276)as.data.frame.default
list(`package:base` = function (x, ...) 
  stop(gettextf("cannot coerce class %s to a data.frame", sQuote(deparse(class(x))[1])), domain = NA), function (x, ...) 
    stop(gettextf("cannot coerce class %s to a data.frame", sQuote(deparse(class(x))[1])), domain = NA), function (x, ...) 
      stop(gettextf("cannot coerce class %s to a data.frame", sQuote(deparse(class(x))[1])), domain = NA))
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
277)as.data.frame.difftime
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
278)as.data.frame.factor
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
279)as.data.frame.integer
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
280)as.data.frame.list
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., cut.names = FALSE, col.names = names(x), fix.empty.names = TRUE, check.names = !optional, stringsAsFactors = FALSE) 
{
  new.nms <- !missing(col.names)
  if (cut.names) {
    maxL <- if (is.logical(cut.names)) 
      256
    else as.integer(cut.names)
    if (any(long <- nchar(col.names, "bytes", keepNA = FALSE) > maxL)) 
      col.names[long] <- paste(substr(col.names[long], 1, maxL - 6), "...")
    else cut.names <- FALSE
  }
  m <- match(names(formals(data.frame))[-1], col.names, 0)
  if (any.m <- any(m)) 
    col.names[m] <- paste0("..adfl.", col.names[m])
  if (new.nms || any.m || cut.names) 
    names(x) <- col.names
  alis <- c(list(check.names = check.names, fix.empty.names = fix.empty.names, stringsAsFactors = stringsAsFactors), if (!missing(row.names)) list(row.names = row.names))
  x <- do.call(data.frame, c(x, alis))
  if (any.m) 
    names(x) <- sub("^\\.\\.adfl\\.", "", names(x))
  x
}, function (x, row.names = NULL, optional = FALSE, ..., cut.names = FALSE, col.names = names(x), fix.empty.names = TRUE, check.names = !optional, stringsAsFactors = FALSE) 
{
  new.nms <- !missing(col.names)
  if (cut.names) {
    maxL <- if (is.logical(cut.names)) 
      256
    else as.integer(cut.names)
    if (any(long <- nchar(col.names, "bytes", keepNA = FALSE) > maxL)) 
      col.names[long] <- paste(substr(col.names[long], 1, maxL - 6), "...")
    else cut.names <- FALSE
  }
  m <- match(names(formals(data.frame))[-1], col.names, 0)
  if (any.m <- any(m)) 
    col.names[m] <- paste0("..adfl.", col.names[m])
  if (new.nms || any.m || cut.names) 
    names(x) <- col.names
  alis <- c(list(check.names = check.names, fix.empty.names = fix.empty.names, stringsAsFactors = stringsAsFactors), if (!missing(row.names)) list(row.names = row.names))
  x <- do.call(data.frame, c(x, alis))
  if (any.m) 
    names(x) <- sub("^\\.\\.adfl\\.", "", names(x))
  x
}, function (x, row.names = NULL, optional = FALSE, ..., cut.names = FALSE, col.names = names(x), fix.empty.names = TRUE, check.names = !optional, stringsAsFactors = FALSE) 
{
  new.nms <- !missing(col.names)
  if (cut.names) {
    maxL <- if (is.logical(cut.names)) 
      256
    else as.integer(cut.names)
    if (any(long <- nchar(col.names, "bytes", keepNA = FALSE) > maxL)) 
      col.names[long] <- paste(substr(col.names[long], 1, maxL - 6), "...")
    else cut.names <- FALSE
  }
  m <- match(names(formals(data.frame))[-1], col.names, 0)
  if (any.m <- any(m)) 
    col.names[m] <- paste0("..adfl.", col.names[m])
  if (new.nms || any.m || cut.names) 
    names(x) <- col.names
  alis <- c(list(check.names = check.names, fix.empty.names = fix.empty.names, stringsAsFactors = stringsAsFactors), if (!missing(row.names)) list(row.names = row.names))
  x <- do.call(data.frame, c(x, alis))
  if (any.m) 
    names(x) <- sub("^\\.\\.adfl\\.", "", names(x))
  x
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
281)as.data.frame.logical
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
282)as.data.frame.matrix
list(`package:base` = function (x, row.names = NULL, optional = FALSE, make.names = TRUE, ..., stringsAsFactors = FALSE) 
{
  d <- dim(x)
  nrows <- d[[1]]
  ncols <- d[[2]]
  ic <- seq_len(ncols)
  dn <- dimnames(x)
  if (is.null(row.names)) 
    row.names <- dn[[1]]
  collabs <- dn[[2]]
  if (any(empty <- !nzchar(collabs))) 
    collabs[empty] <- paste0("V", ic)[empty]
  value <- vector("list", ncols)
  if (mode(x) == "character" && stringsAsFactors) {
    for (i in ic) value[[i]] <- as.factor(x[, i])
  }
  else {
    for (i in ic) value[[i]] <- as.vector(x[, i])
  }
  autoRN <- (is.null(row.names) || length(row.names) != nrows)
  if (length(collabs) == ncols) 
    names(value) <- collabs
  else if (!optional) 
    names(value) <- paste0("V", ic)
  class(value) <- "data.frame"
  if (autoRN) 
    attr(value, "row.names") <- .set_row_names(nrows)
  else .rowNamesDF(value, make.names = make.names) <- row.names
  value
}, function (x, row.names = NULL, optional = FALSE, make.names = TRUE, ..., stringsAsFactors = FALSE) 
{
  d <- dim(x)
  nrows <- d[[1]]
  ncols <- d[[2]]
  ic <- seq_len(ncols)
  dn <- dimnames(x)
  if (is.null(row.names)) 
    row.names <- dn[[1]]
  collabs <- dn[[2]]
  if (any(empty <- !nzchar(collabs))) 
    collabs[empty] <- paste0("V", ic)[empty]
  value <- vector("list", ncols)
  if (mode(x) == "character" && stringsAsFactors) {
    for (i in ic) value[[i]] <- as.factor(x[, i])
  }
  else {
    for (i in ic) value[[i]] <- as.vector(x[, i])
  }
  autoRN <- (is.null(row.names) || length(row.names) != nrows)
  if (length(collabs) == ncols) 
    names(value) <- collabs
  else if (!optional) 
    names(value) <- paste0("V", ic)
  class(value) <- "data.frame"
  if (autoRN) 
    attr(value, "row.names") <- .set_row_names(nrows)
  else .rowNamesDF(value, make.names = make.names) <- row.names
  value
}, function (x, row.names = NULL, optional = FALSE, make.names = TRUE, ..., stringsAsFactors = FALSE) 
{
  d <- dim(x)
  nrows <- d[[1]]
  ncols <- d[[2]]
  ic <- seq_len(ncols)
  dn <- dimnames(x)
  if (is.null(row.names)) 
    row.names <- dn[[1]]
  collabs <- dn[[2]]
  if (any(empty <- !nzchar(collabs))) 
    collabs[empty] <- paste0("V", ic)[empty]
  value <- vector("list", ncols)
  if (mode(x) == "character" && stringsAsFactors) {
    for (i in ic) value[[i]] <- as.factor(x[, i])
  }
  else {
    for (i in ic) value[[i]] <- as.vector(x[, i])
  }
  autoRN <- (is.null(row.names) || length(row.names) != nrows)
  if (length(collabs) == ncols) 
    names(value) <- collabs
  else if (!optional) 
    names(value) <- paste0("V", ic)
  class(value) <- "data.frame"
  if (autoRN) 
    attr(value, "row.names") <- .set_row_names(nrows)
  else .rowNamesDF(value, make.names = make.names) <- row.names
  value
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
283)as.data.frame.model.matrix
list(`package:base` = function (x, row.names = NULL, optional = FALSE, make.names = TRUE, ...) 
{
  d <- dim(x)
  nrows <- d[[1]]
  dn <- dimnames(x)
  row.names <- dn[[1]]
  value <- list(x)
  if (!optional) 
    names(value) <- deparse(substitute(x))[[1]]
  class(value) <- "data.frame"
  if (!is.null(row.names)) {
    row.names <- as.character(row.names)
    if (length(row.names) != nrows) 
      stop(sprintf(ngettext(length(row.names), "supplied %d row name for %d rows", "supplied %d row names for %d rows"), length(row.names), nrows), domain = NA)
    .rowNamesDF(value, make.names = make.names) <- row.names
  }
  else attr(value, "row.names") <- .set_row_names(nrows)
  value
}, function (x, row.names = NULL, optional = FALSE, make.names = TRUE, ...) 
{
  d <- dim(x)
  nrows <- d[[1]]
  dn <- dimnames(x)
  row.names <- dn[[1]]
  value <- list(x)
  if (!optional) 
    names(value) <- deparse(substitute(x))[[1]]
  class(value) <- "data.frame"
  if (!is.null(row.names)) {
    row.names <- as.character(row.names)
    if (length(row.names) != nrows) 
      stop(sprintf(ngettext(length(row.names), "supplied %d row name for %d rows", "supplied %d row names for %d rows"), length(row.names), nrows), domain = NA)
    .rowNamesDF(value, make.names = make.names) <- row.names
  }
  else attr(value, "row.names") <- .set_row_names(nrows)
  value
}, function (x, row.names = NULL, optional = FALSE, make.names = TRUE, ...) 
{
  d <- dim(x)
  nrows <- d[[1]]
  dn <- dimnames(x)
  row.names <- dn[[1]]
  value <- list(x)
  if (!optional) 
    names(value) <- deparse(substitute(x))[[1]]
  class(value) <- "data.frame"
  if (!is.null(row.names)) {
    row.names <- as.character(row.names)
    if (length(row.names) != nrows) 
      stop(sprintf(ngettext(length(row.names), "supplied %d row name for %d rows", "supplied %d row names for %d rows"), length(row.names), nrows), domain = NA)
    .rowNamesDF(value, make.names = make.names) <- row.names
  }
  else attr(value, "row.names") <- .set_row_names(nrows)
  value
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
284)as.data.frame.noquote
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
285)as.data.frame.numeric
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
286)as.data.frame.numeric_version
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
287)as.data.frame.ordered
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
288)as.data.frame.POSIXct
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
289)as.data.frame.POSIXlt
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ...) 
{
  value <- as.data.frame.POSIXct(as.POSIXct(x), row.names, optional, ...)
  if (!optional) 
    names(value) <- deparse1(substitute(x))
  value
}, function (x, row.names = NULL, optional = FALSE, ...) 
{
  value <- as.data.frame.POSIXct(as.POSIXct(x), row.names, optional, ...)
  if (!optional) 
    names(value) <- deparse1(substitute(x))
  value
}, function (x, row.names = NULL, optional = FALSE, ...) 
{
  value <- as.data.frame.POSIXct(as.POSIXct(x), row.names, optional, ...)
  if (!optional) 
    names(value) <- deparse1(substitute(x))
  value
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
as.data.frame.raw
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
290)as.data.frame.table
list(`package:base` = function (x, row.names = NULL, ..., responseName = "Freq", stringsAsFactors = TRUE, sep = "", base = list(LETTERS)) 
{
  ex <- quote(data.frame(do.call("expand.grid", c(dimnames(provideDimnames(x, sep = sep, base = base)), KEEP.OUT.ATTRS = FALSE, stringsAsFactors = stringsAsFactors)), Freq = c(x), row.names = row.names))
  names(ex)[3] <- responseName
  eval(ex)
}, function (x, row.names = NULL, ..., responseName = "Freq", stringsAsFactors = TRUE, sep = "", base = list(LETTERS)) 
{
  ex <- quote(data.frame(do.call("expand.grid", c(dimnames(provideDimnames(x, sep = sep, base = base)), KEEP.OUT.ATTRS = FALSE, stringsAsFactors = stringsAsFactors)), Freq = c(x), row.names = row.names))
  names(ex)[3] <- responseName
  eval(ex)
}, function (x, row.names = NULL, ..., responseName = "Freq", stringsAsFactors = TRUE, sep = "", base = list(LETTERS)) 
{
  ex <- quote(data.frame(do.call("expand.grid", c(dimnames(provideDimnames(x, sep = sep, base = base)), KEEP.OUT.ATTRS = FALSE, stringsAsFactors = stringsAsFactors)), Freq = c(x), row.names = row.names))
  names(ex)[3] <- responseName
  eval(ex)
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
291)as.data.frame.ts
list(`package:base` = function (x, ...) 
{
  if (is.matrix(x)) 
    as.data.frame.matrix(x, ...)
  else as.data.frame.vector(x, ...)
}, function (x, ...) 
{
  if (is.matrix(x)) 
    as.data.frame.matrix(x, ...)
  else as.data.frame.vector(x, ...)
}, function (x, ...) 
{
  if (is.matrix(x)) 
    as.data.frame.matrix(x, ...)
  else as.data.frame.vector(x, ...)
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
292)as.data.frame.vector
list(`package:base` = function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
}, function (x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x))) 
{
  force(nm)
  nrows <- length(x)
  if (!(is.null(row.names) || (is.character(row.names) && length(row.names) == nrows))) {
    warning(gettextf("'row.names' is not a character vector of length %d -- omitting it. Will be an error!", nrows), domain = NA)
    row.names <- NULL
  }
  if (is.null(row.names)) {
    if (nrows == 0) 
      row.names <- character()
    else if (length(row.names <- names(x)) != nrows || anyDuplicated(row.names)) 
      row.names <- .set_row_names(nrows)
  }
  if (!is.null(names(x))) 
    names(x) <- NULL
  value <- list(x)
  if (!optional) 
    names(value) <- nm
  structure(value, row.names = row.names, class = "data.frame")
})
c("package:base", "registered S3 method for as.data.frame from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
293)as.Date
list(`package:base` = function (x, ...) 
  UseMethod("as.Date"), function (x, ...) 
    UseMethod("as.Date"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
294)as.Date.character
list(`package:base` = function (x, format, tryFormats = c("%Y-%m-%d", "%Y/%m/%d"), optional = FALSE, ...) 
{
  charToDate <- function(x) {
    is.na(x) <- !nzchar(x)
    xx <- x[1]
    if (is.na(xx)) {
      j <- 1
      while (is.na(xx) && (j <- j + 1) <= length(x)) xx <- x[j]
      if (is.na(xx)) 
        f <- "%Y-%m-%d"
    }
    if (is.na(xx)) 
      strptime(x, f)
    else {
      for (ff in tryFormats) if (!is.na(strptime(xx, ff, tz = "GMT"))) 
        return(strptime(x, ff))
      if (optional) 
        as.Date.character(rep.int(NA, length(x)), "%Y-%m-%d")
      else stop("character string is not in a standard unambiguous format")
    }
  }
  res <- if (missing(format)) 
    charToDate(x)
  else strptime(x, format, tz = "GMT")
  as.Date(res)
}, function (x, format, tryFormats = c("%Y-%m-%d", "%Y/%m/%d"), optional = FALSE, ...) 
{
  charToDate <- function(x) {
    is.na(x) <- !nzchar(x)
    xx <- x[1]
    if (is.na(xx)) {
      j <- 1
      while (is.na(xx) && (j <- j + 1) <= length(x)) xx <- x[j]
      if (is.na(xx)) 
        f <- "%Y-%m-%d"
    }
    if (is.na(xx)) 
      strptime(x, f)
    else {
      for (ff in tryFormats) if (!is.na(strptime(xx, ff, tz = "GMT"))) 
        return(strptime(x, ff))
      if (optional) 
        as.Date.character(rep.int(NA, length(x)), "%Y-%m-%d")
      else stop("character string is not in a standard unambiguous format")
    }
  }
  res <- if (missing(format)) 
    charToDate(x)
  else strptime(x, format, tz = "GMT")
  as.Date(res)
}, function (x, format, tryFormats = c("%Y-%m-%d", "%Y/%m/%d"), optional = FALSE, ...) 
{
  charToDate <- function(x) {
    is.na(x) <- !nzchar(x)
    xx <- x[1]
    if (is.na(xx)) {
      j <- 1
      while (is.na(xx) && (j <- j + 1) <= length(x)) xx <- x[j]
      if (is.na(xx)) 
        f <- "%Y-%m-%d"
    }
    if (is.na(xx)) 
      strptime(x, f)
    else {
      for (ff in tryFormats) if (!is.na(strptime(xx, ff, tz = "GMT"))) 
        return(strptime(x, ff))
      if (optional) 
        as.Date.character(rep.int(NA, length(x)), "%Y-%m-%d")
      else stop("character string is not in a standard unambiguous format")
    }
  }
  res <- if (missing(format)) 
    charToDate(x)
  else strptime(x, format, tz = "GMT")
  as.Date(res)
})
c("package:base", "registered S3 method for as.Date from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
295)as.Date.default
list(`package:base` = function (x, ...) 
{
  if (inherits(x, "Date")) 
    x
  else if (is.null(x)) 
    .Date(numeric())
  else if (is.logical(x) && all(is.na(x))) 
    .Date(as.numeric(x))
  else stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("Date")), domain = NA)
}, function (x, ...) 
{
  if (inherits(x, "Date")) 
    x
  else if (is.null(x)) 
    .Date(numeric())
  else if (is.logical(x) && all(is.na(x))) 
    .Date(as.numeric(x))
  else stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("Date")), domain = NA)
}, function (x, ...) 
{
  if (inherits(x, "Date")) 
    x
  else if (is.null(x)) 
    .Date(numeric())
  else if (is.logical(x) && all(is.na(x))) 
    .Date(as.numeric(x))
  else stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("Date")), domain = NA)
})
c("package:base", "registered S3 method for as.Date from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
296)as.Date.factor
list(`package:base` = function (x, ...) 
  as.Date(as.character(x), ...), function (x, ...) 
    as.Date(as.character(x), ...), function (x, ...) 
      as.Date(as.character(x), ...))
c("package:base", "registered S3 method for as.Date from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
297)as.Date.numeric
list(`package:base` = function (x, origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(.Date(numeric()))
    if (!any(is.finite(x))) 
      return(.Date(x))
    stop("'origin' must be supplied")
  }
  as.Date(origin, ...) + x
}, function (x, origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(.Date(numeric()))
    if (!any(is.finite(x))) 
      return(.Date(x))
    stop("'origin' must be supplied")
  }
  as.Date(origin, ...) + x
}, function (x, origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(.Date(numeric()))
    if (!any(is.finite(x))) 
      return(.Date(x))
    stop("'origin' must be supplied")
  }
  as.Date(origin, ...) + x
})
c("package:base", "registered S3 method for as.Date from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
298)as.Date.POSIXct
list(`package:base` = function (x, tz = "UTC", ...) 
{
  if (tz == "UTC") {
    z <- floor(unclass(x)/86400)
    attr(z, "tzone") <- NULL
    .Date(z)
  }
  else as.Date(as.POSIXlt(x, tz = tz))
}, function (x, tz = "UTC", ...) 
{
  if (tz == "UTC") {
    z <- floor(unclass(x)/86400)
    attr(z, "tzone") <- NULL
    .Date(z)
  }
  else as.Date(as.POSIXlt(x, tz = tz))
}, function (x, tz = "UTC", ...) 
{
  if (tz == "UTC") {
    z <- floor(unclass(x)/86400)
    attr(z, "tzone") <- NULL
    .Date(z)
  }
  else as.Date(as.POSIXlt(x, tz = tz))
})
c("package:base", "registered S3 method for as.Date from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
299)as.Date.POSIXlt
list(`package:base` = function (x, ...) 
  .Internal(POSIXlt2Date(x)), function (x, ...) 
    .Internal(POSIXlt2Date(x)), function (x, ...) 
      .Internal(POSIXlt2Date(x)))
c("package:base", "registered S3 method for as.Date from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
300)as.difftime
list(`package:base` = function (tim, format = "%X", units = "auto", tz = "UTC") 
{
  if (inherits(tim, "difftime")) 
    return(tim)
  if (is.character(tim)) {
    difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
  }
  else {
    if (!is.numeric(tim)) 
      stop("'tim' is not character or numeric")
    if (units == "auto") 
      stop("need explicit units for numeric conversion")
    if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
      stop("invalid units specified")
    .difftime(tim, units = units)
  }
}, function (tim, ...) 
  UseMethod("as.difftime"), new("standardGeneric", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
    standardGeneric("as.difftime"), generic = "as.difftime", package = "base", group = list(), valueClass = character(0), signature = c("tim", "format", "units", "tz"), default = new("derivedDefaultMethod", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
    {
      if (inherits(tim, "difftime")) 
        return(tim)
      if (is.character(tim)) {
        difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
      }
      else {
        if (!is.numeric(tim)) 
          stop("'tim' is not character or numeric")
        if (units == "auto") 
          stop("need explicit units for numeric conversion")
        if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
          stop("invalid units specified")
        .difftime(tim, units = units)
      }
    }, target = new("signature", .Data = "ANY", names = "tim", package = "methods"), defined = new("signature", .Data = "ANY", names = "tim", package = "methods"), generic = "as.difftime"), skeleton = (new("derivedDefaultMethod", .Data = function (tim, format = "%X", units = "auto", tz = "UTC") 
    {
      if (inherits(tim, "difftime")) 
        return(tim)
      if (is.character(tim)) {
        difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
      }
      else {
        if (!is.numeric(tim)) 
          stop("'tim' is not character or numeric")
        if (units == "auto") 
          stop("need explicit units for numeric conversion")
        if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
          stop("invalid units specified")
        .difftime(tim, units = units)
      }
    }, target = new("signature", .Data = "ANY", names = "tim", package = "methods"), defined = new("signature", .Data = "ANY", names = "tim", package = "methods"), generic = "as.difftime"))(tim, format, units, tz)), function (tim, format = "%X", units = "auto", tz = "UTC") 
    {
      if (inherits(tim, "difftime")) 
        return(tim)
      if (is.character(tim)) {
        difftime(strptime(tim, format = format), strptime("0:0:0", format = "%X"), units = units, tz = tz)
      }
      else {
        if (!is.numeric(tim)) 
          stop("'tim' is not character or numeric")
        if (units == "auto") 
          stop("need explicit units for numeric conversion")
        if (!(units %in% c("secs", "mins", "hours", "days", "weeks"))) 
          stop("invalid units specified")
        .difftime(tim, units = units)
      }
    })
c("package:base", "namespace:generics", "namespace:lubridate", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE)
301)as.double
list(`package:base` = .Primitive("as.double"), .Primitive("as.double"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
302)as.double.difftime
list(`package:base` = function (x, units = "auto", ...) 
{
  if (units != "auto") 
    units(x) <- units
  as.vector(x, "double")
}, function (x, units = "auto", ...) 
{
  if (units != "auto") 
    units(x) <- units
  as.vector(x, "double")
}, function (x, units = "auto", ...) 
{
  if (units != "auto") 
    units(x) <- units
  as.vector(x, "double")
})
c("package:base", "registered S3 method for as.double from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
303)as.double.POSIXlt
list(`package:base` = function (x, ...) 
  as.double(as.POSIXct(x)), function (x, ...) 
    as.double(as.POSIXct(x)), function (x, ...) 
      as.double(as.POSIXct(x)))
c("package:base", "registered S3 method for as.double from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
304)as.environment
list(`package:base` = .Primitive("as.environment"), .Primitive("as.environment"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
305)as.expression
list(`package:base` = function (x, ...) 
  UseMethod("as.expression"), function (x, ...) 
    UseMethod("as.expression"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
306)as.expression.default
list(`package:base` = function (x, ...) 
  .Internal(as.vector(x, "expression")), function (x, ...) 
    .Internal(as.vector(x, "expression")), function (x, ...) 
      .Internal(as.vector(x, "expression")))
c("package:base", "registered S3 method for as.expression from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
307)as.factor
list(`package:base` = function (x) 
{
  if (is.factor(x)) 
    x
  else if (!is.object(x) && is.integer(x)) {
    levels <- sort.int(unique.default(x))
    f <- match(x, levels)
    levels(f) <- as.character(levels)
    if (!is.null(nx <- names(x))) 
      names(f) <- nx
    class(f) <- "factor"
    f
  }
  else factor(x)
}, function (x, ...) 
  UseMethod("as.factor"), function (x) 
  {
    if (is.factor(x)) 
      x
    else if (!is.object(x) && is.integer(x)) {
      levels <- sort.int(unique.default(x))
      f <- match(x, levels)
      levels(f) <- as.character(levels)
      if (!is.null(nx <- names(x))) 
        names(f) <- nx
      class(f) <- "factor"
      f
    }
    else factor(x)
  })
c("package:base", "namespace:generics", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
308)as.function
list(`package:base` = function (x, ...) 
  UseMethod("as.function"), function (x, ...) 
    UseMethod("as.function"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
309)as.function.default
list(`package:base` = function (x, envir = parent.frame(), ...) 
  if (is.function(x)) x else .Internal(as.function.default(x, envir)), function (x, envir = parent.frame(), ...) 
    if (is.function(x)) x else .Internal(as.function.default(x, envir)), function (x, envir = parent.frame(), ...) 
      if (is.function(x)) x else .Internal(as.function.default(x, envir)))
c("package:base", "registered S3 method for as.function from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
310)as.hexmode
list(`package:base` = function (x) 
{
  if (inherits(x, "hexmode")) 
    return(x)
  if (is.double(x) && all(is.na(x) | x == as.integer(x))) 
    x <- as.integer(x)
  if (is.integer(x)) 
    return(structure(x, class = "hexmode"))
  if (is.character(x)) {
    z <- strtoi(x, 16)
    if (!any(is.na(z) | z < 0)) 
      return(structure(z, class = "hexmode"))
  }
  stop("'x' cannot be coerced to class \"hexmode\"")
}, function (x) 
{
  if (inherits(x, "hexmode")) 
    return(x)
  if (is.double(x) && all(is.na(x) | x == as.integer(x))) 
    x <- as.integer(x)
  if (is.integer(x)) 
    return(structure(x, class = "hexmode"))
  if (is.character(x)) {
    z <- strtoi(x, 16)
    if (!any(is.na(z) | z < 0)) 
      return(structure(z, class = "hexmode"))
  }
  stop("'x' cannot be coerced to class \"hexmode\"")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
311)as.integer
list(`package:base` = .Primitive("as.integer"), .Primitive("as.integer"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
312)as.list
list(`package:base` = function (x, ...) 
  UseMethod("as.list"), function (x, ...) 
    UseMethod("as.list"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
313)as.list.data.frame
list(`package:base` = function (x, ...) 
{
  x <- unclass(x)
  attr(x, "row.names") <- NULL
  x
}, function (x, ...) 
{
  x <- unclass(x)
  attr(x, "row.names") <- NULL
  x
}, function (x, ...) 
{
  x <- unclass(x)
  attr(x, "row.names") <- NULL
  x
})
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
314)as.list.Date
list(`package:base` = function (x, ...) 
  lapply(unclass(x), .Date, oldClass(x)), function (x, ...) 
    lapply(unclass(x), .Date, oldClass(x)), function (x, ...) 
      lapply(unclass(x), .Date, oldClass(x)))
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
315)as.list.default
list(`package:base` = function (x, ...) 
  if (typeof(x) == "list") x else .Internal(as.vector(x, "list")), function (x, ...) 
    if (typeof(x) == "list") x else .Internal(as.vector(x, "list")), function (x, ...) 
      if (typeof(x) == "list") x else .Internal(as.vector(x, "list")))
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
316)as.list.difftime
list(`package:base` = function (x, ...) 
  lapply(unclass(x), .difftime, attr(x, "units"), oldClass(x)), function (x, ...) 
    lapply(unclass(x), .difftime, attr(x, "units"), oldClass(x)), function (x, ...) 
      lapply(unclass(x), .difftime, attr(x, "units"), oldClass(x)))
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
317)as.list.environment
list(`package:base` = function (x, all.names = FALSE, sorted = FALSE, ...) 
  .Internal(env2list(x, all.names, sorted)), function (x, all.names = FALSE, sorted = FALSE, ...) 
    .Internal(env2list(x, all.names, sorted)), function (x, all.names = FALSE, sorted = FALSE, ...) 
      .Internal(env2list(x, all.names, sorted)))
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
318)as.list.factor
list(`package:base` = function (x, ...) 
{
  res <- vector("list", length(x))
  for (i in seq_along(x)) res[[i]] <- x[[i]]
  if (is.null(names(x))) 
    res
  else `names<-`(res, names(x))
}, function (x, ...) 
{
  res <- vector("list", length(x))
  for (i in seq_along(x)) res[[i]] <- x[[i]]
  if (is.null(names(x))) 
    res
  else `names<-`(res, names(x))
}, function (x, ...) 
{
  res <- vector("list", length(x))
  for (i in seq_along(x)) res[[i]] <- x[[i]]
  if (is.null(names(x))) 
    res
  else `names<-`(res, names(x))
})
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
319)as.list.function
list(`package:base` = function (x, ...) 
  c(formals(x), list(body(x))), function (x, ...) 
    c(formals(x), list(body(x))), function (x, ...) 
      c(formals(x), list(body(x))))
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
320)as.list.numeric_version
list(`package:base` = function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(seq_along(x), function(i) x[i])
  names(y) <- nms
  y
}, function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(seq_along(x), function(i) x[i])
  names(y) <- nms
  y
}, function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(seq_along(x), function(i) x[i])
  names(y) <- nms
  y
})
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
321)as.list.POSIXct
list(`package:base` = function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(unclass(x), .POSIXct, attr(x, "tzone"), oldClass(x))
  names(y) <- nms
  y
}, function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(unclass(x), .POSIXct, attr(x, "tzone"), oldClass(x))
  names(y) <- nms
  y
}, function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(unclass(x), .POSIXct, attr(x, "tzone"), oldClass(x))
  names(y) <- nms
  y
})
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
322)as.list.POSIXlt
list(`package:base` = function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(X = do.call(Map, c(list, unclass(x))), FUN = .POSIXlt, attr(x, "tzone"), oldClass(x))
  names(y) <- nms
  y
}, function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(X = do.call(Map, c(list, unclass(x))), FUN = .POSIXlt, attr(x, "tzone"), oldClass(x))
  names(y) <- nms
  y
}, function (x, ...) 
{
  nms <- names(x)
  names(x) <- NULL
  y <- lapply(X = do.call(Map, c(list, unclass(x))), FUN = .POSIXlt, attr(x, "tzone"), oldClass(x))
  names(y) <- nms
  y
})
c("package:base", "registered S3 method for as.list from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
323)as.logical
list(`package:base` = .Primitive("as.logical"), .Primitive("as.logical"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
324)as.logical.factor
list(`package:base` = function (x, ...) 
  as.logical(levels(x))[x], function (x, ...) 
    as.logical(levels(x))[x], function (x, ...) 
      as.logical(levels(x))[x])
c("package:base", "registered S3 method for as.logical from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
325)as.matrix
list(`package:base` = function (x, ...) 
  UseMethod("as.matrix"), function (x, ...) 
    base::as.matrix(x, ...), new("standardGeneric", .Data = function (x, ...) 
      standardGeneric("as.matrix"), generic = "as.matrix", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("as.matrix"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.matrix"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
          UseMethod("as.matrix"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "as.matrix"))(x, ...)), function (x, ...) 
            UseMethod("as.matrix"))
c("package:base", "namespace:proxy", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE)
326)as.matrix.data.frame
list(`package:base` = function (x, rownames.force = NA, ...) 
{
  dm <- dim(x)
  rn <- if (rownames.force %in% FALSE) 
    NULL
  else if (rownames.force %in% TRUE || .row_names_info(x) > 0) 
    row.names(x)
  dn <- list(rn, names(x))
  if (any(dm == 0)) 
    return(array(NA, dim = dm, dimnames = dn))
  p <- dm[2]
  pseq <- seq_len(p)
  n <- dm[1]
  X <- unclass(x)
  non.numeric <- non.atomic <- FALSE
  all.logical <- TRUE
  for (j in pseq) {
    xj <- X[[j]]
    if (inherits(xj, "data.frame")) 
      X[[j]] <- xj <- as.matrix(xj)
    j.logic <- is.logical(xj)
    if (all.logical && !j.logic) 
      all.logical <- FALSE
    if (length(levels(xj)) > 0 || !(j.logic || is.numeric(xj) || is.complex(xj)) || (!is.null(cl <- attr(xj, "class")) && any(cl %in% c("Date", "POSIXct", "POSIXlt")))) 
      non.numeric <- TRUE
    if (!is.atomic(xj) && !inherits(xj, "POSIXlt")) 
      non.atomic <- TRUE
  }
  if (non.atomic) {
    for (j in pseq) {
      xj <- X[[j]]
      if (!is.recursive(xj)) 
        X[[j]] <- as.list(as.vector(xj))
    }
  }
  else if (all.logical) {
  }
  else if (non.numeric) {
    for (j in pseq) {
      if (is.character(X[[j]])) 
        next
      else if (is.logical(xj <- X[[j]])) 
        xj <- as.character(xj)
      else {
        miss <- is.na(xj)
        xj <- if (length(levels(xj))) 
          as.vector(xj)
        else format(xj)
        is.na(xj) <- miss
      }
      X[[j]] <- xj
    }
  }
  collabs <- as.list(dn[[2]])
  for (j in pseq) {
    xj <- X[[j]]
    dj <- dim(xj)
    if (length(dj) == 2 && dj[2] > 0) {
      if (!length(dnj <- colnames(xj))) 
        dnj <- seq_len(dj[2])
      collabs[[j]] <- if (length(collabs)) {
        if (dj[2] > 1) 
          paste(collabs[[j]], dnj, sep = ".")
        else if (is.character(collabs[[j]])) 
          collabs[[j]]
        else dnj
      }
      else dnj
    }
  }
  nc <- vapply(X, NCOL, numeric(1), USE.NAMES = FALSE)
  X <- unlist(X, recursive = FALSE, use.names = FALSE)
  dim(X) <- c(n, length(X)/n)
  dimnames(X) <- list(dn[[1]], unlist(collabs[nc > 0], use.names = FALSE))
  X
}, function (x, rownames.force = NA, ...) 
{
  dm <- dim(x)
  rn <- if (rownames.force %in% FALSE) 
    NULL
  else if (rownames.force %in% TRUE || .row_names_info(x) > 0) 
    row.names(x)
  dn <- list(rn, names(x))
  if (any(dm == 0)) 
    return(array(NA, dim = dm, dimnames = dn))
  p <- dm[2]
  pseq <- seq_len(p)
  n <- dm[1]
  X <- unclass(x)
  non.numeric <- non.atomic <- FALSE
  all.logical <- TRUE
  for (j in pseq) {
    xj <- X[[j]]
    if (inherits(xj, "data.frame")) 
      X[[j]] <- xj <- as.matrix(xj)
    j.logic <- is.logical(xj)
    if (all.logical && !j.logic) 
      all.logical <- FALSE
    if (length(levels(xj)) > 0 || !(j.logic || is.numeric(xj) || is.complex(xj)) || (!is.null(cl <- attr(xj, "class")) && any(cl %in% c("Date", "POSIXct", "POSIXlt")))) 
      non.numeric <- TRUE
    if (!is.atomic(xj) && !inherits(xj, "POSIXlt")) 
      non.atomic <- TRUE
  }
  if (non.atomic) {
    for (j in pseq) {
      xj <- X[[j]]
      if (!is.recursive(xj)) 
        X[[j]] <- as.list(as.vector(xj))
    }
  }
  else if (all.logical) {
  }
  else if (non.numeric) {
    for (j in pseq) {
      if (is.character(X[[j]])) 
        next
      else if (is.logical(xj <- X[[j]])) 
        xj <- as.character(xj)
      else {
        miss <- is.na(xj)
        xj <- if (length(levels(xj))) 
          as.vector(xj)
        else format(xj)
        is.na(xj) <- miss
      }
      X[[j]] <- xj
    }
  }
  collabs <- as.list(dn[[2]])
  for (j in pseq) {
    xj <- X[[j]]
    dj <- dim(xj)
    if (length(dj) == 2 && dj[2] > 0) {
      if (!length(dnj <- colnames(xj))) 
        dnj <- seq_len(dj[2])
      collabs[[j]] <- if (length(collabs)) {
        if (dj[2] > 1) 
          paste(collabs[[j]], dnj, sep = ".")
        else if (is.character(collabs[[j]])) 
          collabs[[j]]
        else dnj
      }
      else dnj
    }
  }
  nc <- vapply(X, NCOL, numeric(1), USE.NAMES = FALSE)
  X <- unlist(X, recursive = FALSE, use.names = FALSE)
  dim(X) <- c(n, length(X)/n)
  dimnames(X) <- list(dn[[1]], unlist(collabs[nc > 0], use.names = FALSE))
  X
}, function (x, rownames.force = NA, ...) 
{
  dm <- dim(x)
  rn <- if (rownames.force %in% FALSE) 
    NULL
  else if (rownames.force %in% TRUE || .row_names_info(x) > 0) 
    row.names(x)
  dn <- list(rn, names(x))
  if (any(dm == 0)) 
    return(array(NA, dim = dm, dimnames = dn))
  p <- dm[2]
  pseq <- seq_len(p)
  n <- dm[1]
  X <- unclass(x)
  non.numeric <- non.atomic <- FALSE
  all.logical <- TRUE
  for (j in pseq) {
    xj <- X[[j]]
    if (inherits(xj, "data.frame")) 
      X[[j]] <- xj <- as.matrix(xj)
    j.logic <- is.logical(xj)
    if (all.logical && !j.logic) 
      all.logical <- FALSE
    if (length(levels(xj)) > 0 || !(j.logic || is.numeric(xj) || is.complex(xj)) || (!is.null(cl <- attr(xj, "class")) && any(cl %in% c("Date", "POSIXct", "POSIXlt")))) 
      non.numeric <- TRUE
    if (!is.atomic(xj) && !inherits(xj, "POSIXlt")) 
      non.atomic <- TRUE
  }
  if (non.atomic) {
    for (j in pseq) {
      xj <- X[[j]]
      if (!is.recursive(xj)) 
        X[[j]] <- as.list(as.vector(xj))
    }
  }
  else if (all.logical) {
  }
  else if (non.numeric) {
    for (j in pseq) {
      if (is.character(X[[j]])) 
        next
      else if (is.logical(xj <- X[[j]])) 
        xj <- as.character(xj)
      else {
        miss <- is.na(xj)
        xj <- if (length(levels(xj))) 
          as.vector(xj)
        else format(xj)
        is.na(xj) <- miss
      }
      X[[j]] <- xj
    }
  }
  collabs <- as.list(dn[[2]])
  for (j in pseq) {
    xj <- X[[j]]
    dj <- dim(xj)
    if (length(dj) == 2 && dj[2] > 0) {
      if (!length(dnj <- colnames(xj))) 
        dnj <- seq_len(dj[2])
      collabs[[j]] <- if (length(collabs)) {
        if (dj[2] > 1) 
          paste(collabs[[j]], dnj, sep = ".")
        else if (is.character(collabs[[j]])) 
          collabs[[j]]
        else dnj
      }
      else dnj
    }
  }
  nc <- vapply(X, NCOL, numeric(1), USE.NAMES = FALSE)
  X <- unlist(X, recursive = FALSE, use.names = FALSE)
  dim(X) <- c(n, length(X)/n)
  dimnames(X) <- list(dn[[1]], unlist(collabs[nc > 0], use.names = FALSE))
  X
})
c("package:base", "registered S3 method for as.matrix from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
327)as.matrix.default
list(`package:base` = function (x, ...) 
{
  if (is.matrix(x)) 
    x
  else array(x, c(length(x), 1), if (!is.null(names(x))) 
    list(names(x), NULL)
    else NULL)
}, function (x, ...) 
{
  if (is.matrix(x)) 
    x
  else array(x, c(length(x), 1), if (!is.null(names(x))) 
    list(names(x), NULL)
    else NULL)
}, function (x, ...) 
{
  if (is.matrix(x)) 
    x
  else array(x, c(length(x), 1), if (!is.null(names(x))) 
    list(names(x), NULL)
    else NULL)
})
c("package:base", "registered S3 method for as.matrix from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
328)as.matrix.noquote
list(`package:base` = function (x, ...) 
  noquote(NextMethod("as.matrix", x)), function (x, ...) 
    noquote(NextMethod("as.matrix", x)), function (x, ...) 
      noquote(NextMethod("as.matrix", x)))
c("package:base", "registered S3 method for as.matrix from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
329)as.matrix.POSIXlt
list(`package:base` = function (x, ...) 
{
  as.matrix(as.data.frame(unclass(x)), ...)
}, function (x, ...) 
{
  as.matrix(as.data.frame(unclass(x)), ...)
}, function (x, ...) 
{
  as.matrix(as.data.frame(unclass(x)), ...)
})
c("package:base", "registered S3 method for as.matrix from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
330)as.name
list(`package:base` = function (x) 
  .Internal(as.vector(x, "symbol")), function (x) 
    .Internal(as.vector(x, "symbol")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
331)as.null
list(`package:base` = function (x, ...) 
  UseMethod("as.null"), function (x, ...) 
    UseMethod("as.null"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
332)as.null.default
list(`package:base` = function (x, ...) 
  NULL, function (x, ...) 
    NULL, function (x, ...) 
      NULL)
c("package:base", "registered S3 method for as.null from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
333)as.numeric
list(`package:base` = .Primitive("as.double"), .Primitive("as.double"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
334)as.numeric_version
list(`package:base` = function (x) 
{
  if (is.numeric_version(x)) 
    x
  else if (is.package_version(x)) {
    structure(x, class = c(class(x), "numeric_version"))
  }
  else if (is.list(x) && all(vapply(x, is.integer, NA))) {
    bad <- vapply(x, function(e) anyNA(e) || any(e < 0), NA)
    if (any(bad)) {
      x[bad] <- rep.int(list(integer()), sum(bad))
    }
    class(x) <- "numeric_version"
    x
  }
  else numeric_version(x)
}, function (x) 
{
  if (is.numeric_version(x)) 
    x
  else if (is.package_version(x)) {
    structure(x, class = c(class(x), "numeric_version"))
  }
  else if (is.list(x) && all(vapply(x, is.integer, NA))) {
    bad <- vapply(x, function(e) anyNA(e) || any(e < 0), NA)
    if (any(bad)) {
      x[bad] <- rep.int(list(integer()), sum(bad))
    }
    class(x) <- "numeric_version"
    x
  }
  else numeric_version(x)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
335)as.octmode
list(`package:base` = function (x) 
{
  if (inherits(x, "octmode")) 
    return(x)
  if (is.double(x) && all(is.na(x) | x == as.integer(x))) 
    x <- as.integer(x)
  if (is.integer(x)) 
    return(structure(x, class = "octmode"))
  if (is.character(x)) {
    z <- strtoi(x, 8)
    if (!any(is.na(z) | z < 0)) 
      return(structure(z, class = "octmode"))
  }
  stop("'x' cannot be coerced to class \"octmode\"")
}, function (x) 
{
  if (inherits(x, "octmode")) 
    return(x)
  if (is.double(x) && all(is.na(x) | x == as.integer(x))) 
    x <- as.integer(x)
  if (is.integer(x)) 
    return(structure(x, class = "octmode"))
  if (is.character(x)) {
    z <- strtoi(x, 8)
    if (!any(is.na(z) | z < 0)) 
      return(structure(z, class = "octmode"))
  }
  stop("'x' cannot be coerced to class \"octmode\"")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
336)as.ordered
list(`package:base` = function (x) 
  if (is.ordered(x)) x else ordered(x), function (x, ...) 
    UseMethod("as.ordered"), function (x) 
      if (is.ordered(x)) x else ordered(x))
c("package:base", "namespace:generics", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
337)as.package_version
list(`package:base` = function (x) 
  if (is.package_version(x)) x else package_version(x), function (x) 
    if (is.package_version(x)) x else package_version(x))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
338)as.pairlist
list(`package:base` = function (x) 
  .Internal(as.vector(x, "pairlist")), function (x) 
    .Internal(as.vector(x, "pairlist")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
339)as.POSIXct
list(`package:base` = function (x, tz = "", ...) 
  UseMethod("as.POSIXct"), function (x, tz = "", ...) 
    UseMethod("as.POSIXct"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
340)as.POSIXct.Date
list(`package:base` = function (x, ...) 
  .POSIXct(unclass(x) * 86400), function (x, ...) 
    .POSIXct(unclass(x) * 86400), function (x, ...) 
      .POSIXct(unclass(x) * 86400))
c("package:base", "registered S3 method for as.POSIXct from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
341)as.POSIXct.default
list(`package:base` = function (x, tz = "", ...) 
{
  if (inherits(x, "POSIXct")) 
    return(x)
  if (is.null(x)) 
    return(.POSIXct(numeric(), tz))
  if (is.character(x) || is.factor(x)) 
    return(as.POSIXct(as.POSIXlt(x, tz, ...), tz, ...))
  if (is.logical(x) && all(is.na(x))) 
    return(.POSIXct(as.numeric(x), tz))
  stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("POSIXct")), domain = NA)
}, function (x, tz = "", ...) 
{
  if (inherits(x, "POSIXct")) 
    return(x)
  if (is.null(x)) 
    return(.POSIXct(numeric(), tz))
  if (is.character(x) || is.factor(x)) 
    return(as.POSIXct(as.POSIXlt(x, tz, ...), tz, ...))
  if (is.logical(x) && all(is.na(x))) 
    return(.POSIXct(as.numeric(x), tz))
  stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("POSIXct")), domain = NA)
}, function (x, tz = "", ...) 
{
  if (inherits(x, "POSIXct")) 
    return(x)
  if (is.null(x)) 
    return(.POSIXct(numeric(), tz))
  if (is.character(x) || is.factor(x)) 
    return(as.POSIXct(as.POSIXlt(x, tz, ...), tz, ...))
  if (is.logical(x) && all(is.na(x))) 
    return(.POSIXct(as.numeric(x), tz))
  stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("POSIXct")), domain = NA)
})
c("package:base", "registered S3 method for as.POSIXct from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
342)as.POSIXct.numeric
list(`package:base` = function (x, tz = "", origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(.POSIXct(numeric(), tz))
    if (!any(is.finite(x))) 
      return(.POSIXct(x, tz))
    stop("'origin' must be supplied")
  }
  .POSIXct(as.POSIXct(origin, tz = "GMT", ...) + x, tz)
}, function (x, tz = "", origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(.POSIXct(numeric(), tz))
    if (!any(is.finite(x))) 
      return(.POSIXct(x, tz))
    stop("'origin' must be supplied")
  }
  .POSIXct(as.POSIXct(origin, tz = "GMT", ...) + x, tz)
}, function (x, tz = "", origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(.POSIXct(numeric(), tz))
    if (!any(is.finite(x))) 
      return(.POSIXct(x, tz))
    stop("'origin' must be supplied")
  }
  .POSIXct(as.POSIXct(origin, tz = "GMT", ...) + x, tz)
})
c("package:base", "registered S3 method for as.POSIXct from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
343)as.POSIXct.POSIXlt
list(`package:base` = function (x, tz = "", ...) 
{
  tzone <- attr(x, "tzone")
  if (missing(tz) && !is.null(tzone)) 
    tz <- tzone[1]
  y <- .Internal(as.POSIXct(x, tz))
  names(y) <- names(x$year)
  .POSIXct(y, tz)
}, function (x, tz = "", ...) 
{
  tzone <- attr(x, "tzone")
  if (missing(tz) && !is.null(tzone)) 
    tz <- tzone[1]
  y <- .Internal(as.POSIXct(x, tz))
  names(y) <- names(x$year)
  .POSIXct(y, tz)
}, function (x, tz = "", ...) 
{
  tzone <- attr(x, "tzone")
  if (missing(tz) && !is.null(tzone)) 
    tz <- tzone[1]
  y <- .Internal(as.POSIXct(x, tz))
  names(y) <- names(x$year)
  .POSIXct(y, tz)
})
c("package:base", "registered S3 method for as.POSIXct from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
344)as.POSIXlt
list(`package:base` = function (x, tz = "", ...) 
  UseMethod("as.POSIXlt"), function (x, tz = "", ...) 
    UseMethod("as.POSIXlt"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
345)as.POSIXlt.character
list(`package:base` = function (x, tz = "", format, tryFormats = c("%Y-%m-%d %H:%M:%OS", "%Y/%m/%d %H:%M:%OS", "%Y-%m-%d %H:%M", "%Y/%m/%d %H:%M", "%Y-%m-%d", "%Y/%m/%d"), optional = FALSE, ...) 
{
  x <- unclass(x)
  if (!missing(format)) {
    res <- strptime(x, format, tz = tz)
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  xx <- x[!is.na(x)]
  if (!length(xx)) {
    res <- strptime(x, "%Y/%m/%d")
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  else for (f in tryFormats) if (all(!is.na(strptime(xx, f, tz = tz)))) {
    res <- strptime(x, f, tz = tz)
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  if (optional) 
    as.POSIXlt.character(rep.int(NA, length(x)), tz = tz)
  else stop("character string is not in a standard unambiguous format")
}, function (x, tz = "", format, tryFormats = c("%Y-%m-%d %H:%M:%OS", "%Y/%m/%d %H:%M:%OS", "%Y-%m-%d %H:%M", "%Y/%m/%d %H:%M", "%Y-%m-%d", "%Y/%m/%d"), optional = FALSE, ...) 
{
  x <- unclass(x)
  if (!missing(format)) {
    res <- strptime(x, format, tz = tz)
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  xx <- x[!is.na(x)]
  if (!length(xx)) {
    res <- strptime(x, "%Y/%m/%d")
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  else for (f in tryFormats) if (all(!is.na(strptime(xx, f, tz = tz)))) {
    res <- strptime(x, f, tz = tz)
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  if (optional) 
    as.POSIXlt.character(rep.int(NA, length(x)), tz = tz)
  else stop("character string is not in a standard unambiguous format")
}, function (x, tz = "", format, tryFormats = c("%Y-%m-%d %H:%M:%OS", "%Y/%m/%d %H:%M:%OS", "%Y-%m-%d %H:%M", "%Y/%m/%d %H:%M", "%Y-%m-%d", "%Y/%m/%d"), optional = FALSE, ...) 
{
  x <- unclass(x)
  if (!missing(format)) {
    res <- strptime(x, format, tz = tz)
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  xx <- x[!is.na(x)]
  if (!length(xx)) {
    res <- strptime(x, "%Y/%m/%d")
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  else for (f in tryFormats) if (all(!is.na(strptime(xx, f, tz = tz)))) {
    res <- strptime(x, f, tz = tz)
    if (nzchar(tz)) 
      attr(res, "tzone") <- tz
    return(res)
  }
  if (optional) 
    as.POSIXlt.character(rep.int(NA, length(x)), tz = tz)
  else stop("character string is not in a standard unambiguous format")
})
c("package:base", "registered S3 method for as.POSIXlt from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
346)as.POSIXlt.Date
list(`package:base` = function (x, ...) 
  .Internal(Date2POSIXlt(x)), function (x, ...) 
    .Internal(Date2POSIXlt(x)), function (x, ...) 
      .Internal(Date2POSIXlt(x)))
c("package:base", "registered S3 method for as.POSIXlt from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
347)as.POSIXlt.default
list(`package:base` = function (x, tz = "", optional = FALSE, ...) 
{
  if (inherits(x, "POSIXlt")) 
    return(x)
  if (is.null(x)) 
    return(as.POSIXlt.character(character(), tz))
  if (is.logical(x) && all(is.na(x))) 
    return(as.POSIXlt(as.POSIXct.default(x), tz = tz))
  if (optional) 
    as.POSIXlt.character(rep.int(NA, length(x)), tz = tz)
  else stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("POSIXlt")), domain = NA)
}, function (x, tz = "", optional = FALSE, ...) 
{
  if (inherits(x, "POSIXlt")) 
    return(x)
  if (is.null(x)) 
    return(as.POSIXlt.character(character(), tz))
  if (is.logical(x) && all(is.na(x))) 
    return(as.POSIXlt(as.POSIXct.default(x), tz = tz))
  if (optional) 
    as.POSIXlt.character(rep.int(NA, length(x)), tz = tz)
  else stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("POSIXlt")), domain = NA)
}, function (x, tz = "", optional = FALSE, ...) 
{
  if (inherits(x, "POSIXlt")) 
    return(x)
  if (is.null(x)) 
    return(as.POSIXlt.character(character(), tz))
  if (is.logical(x) && all(is.na(x))) 
    return(as.POSIXlt(as.POSIXct.default(x), tz = tz))
  if (optional) 
    as.POSIXlt.character(rep.int(NA, length(x)), tz = tz)
  else stop(gettextf("do not know how to convert '%s' to class %s", deparse1(substitute(x)), dQuote("POSIXlt")), domain = NA)
})
c("package:base", "registered S3 method for as.POSIXlt from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
348)as.POSIXlt.factor
list(`package:base` = function (x, ...) 
{
  y <- as.POSIXlt(as.character(x), ...)
  names(y$year) <- names(x)
  y
}, function (x, ...) 
{
  y <- as.POSIXlt(as.character(x), ...)
  names(y$year) <- names(x)
  y
}, function (x, ...) 
{
  y <- as.POSIXlt(as.character(x), ...)
  names(y$year) <- names(x)
  y
})
c("package:base", "registered S3 method for as.POSIXlt from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
349)as.POSIXlt.numeric
list(`package:base` = function (x, tz = "", origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(as.POSIXlt.character(character(), tz))
    if (!any(is.finite(x))) 
      return(as.POSIXlt.character(rep_len(NA, length(x)), tz))
    stop("'origin' must be supplied")
  }
  as.POSIXlt(as.POSIXct(origin, tz = "UTC", ...) + x, tz = tz)
}, function (x, tz = "", origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(as.POSIXlt.character(character(), tz))
    if (!any(is.finite(x))) 
      return(as.POSIXlt.character(rep_len(NA, length(x)), tz))
    stop("'origin' must be supplied")
  }
  as.POSIXlt(as.POSIXct(origin, tz = "UTC", ...) + x, tz = tz)
}, function (x, tz = "", origin, ...) 
{
  if (missing(origin)) {
    if (!length(x)) 
      return(as.POSIXlt.character(character(), tz))
    if (!any(is.finite(x))) 
      return(as.POSIXlt.character(rep_len(NA, length(x)), tz))
    stop("'origin' must be supplied")
  }
  as.POSIXlt(as.POSIXct(origin, tz = "UTC", ...) + x, tz = tz)
})
c("package:base", "registered S3 method for as.POSIXlt from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
350)as.POSIXlt.POSIXct
list(`package:base` = function (x, tz = "", ...) 
{
  if ((missing(tz) || is.null(tz)) && !is.null(tzone <- attr(x, "tzone"))) 
    tz <- tzone[1]
  .Internal(as.POSIXlt(x, tz))
}, function (x, tz = "", ...) 
{
  if ((missing(tz) || is.null(tz)) && !is.null(tzone <- attr(x, "tzone"))) 
    tz <- tzone[1]
  .Internal(as.POSIXlt(x, tz))
}, function (x, tz = "", ...) 
{
  if ((missing(tz) || is.null(tz)) && !is.null(tzone <- attr(x, "tzone"))) 
    tz <- tzone[1]
  .Internal(as.POSIXlt(x, tz))
})
c("package:base", "registered S3 method for as.POSIXlt from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
351)as.qr
list(`package:base` = function (x) 
  stop("you cannot be serious", domain = NA), function (x) 
    stop("you cannot be serious", domain = NA))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
352)as.raw
list(`package:base` = .Primitive("as.raw"), .Primitive("as.raw"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
353)as.single
list(`package:base` = function (x, ...) 
  UseMethod("as.single"), function (x, ...) 
    UseMethod("as.single"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
354)as.single.default
list(`package:base` = function (x, ...) 
  structure(.Internal(as.vector(x, "double")), Csingle = TRUE), function (x, ...) 
    structure(.Internal(as.vector(x, "double")), Csingle = TRUE), function (x, ...) 
      structure(.Internal(as.vector(x, "double")), Csingle = TRUE))
c("package:base", "registered S3 method for as.single from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
354)as.symbol
list(`package:base` = function (x) 
  .Internal(as.vector(x, "symbol")), function (x) 
    .Internal(as.vector(x, "symbol")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
355)as.table
list(`package:base` = function (x, ...) 
  UseMethod("as.table"), function (x, ...) 
    UseMethod("as.table"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
356)as.table.default
list(`package:base` = function (x, ...) 
{
  if (is.table(x)) 
    return(x)
  else if (is.array(x) || is.numeric(x)) {
    x <- as.array(x)
    structure(class = c("table", oldClass(x)), provideDimnames(x))
  }
  else stop("cannot coerce to a table")
}, function (x, ...) 
{
  if (is.table(x)) 
    return(x)
  else if (is.array(x) || is.numeric(x)) {
    x <- as.array(x)
    structure(class = c("table", oldClass(x)), provideDimnames(x))
  }
  else stop("cannot coerce to a table")
}, function (x, ...) 
{
  if (is.table(x)) 
    return(x)
  else if (is.array(x) || is.numeric(x)) {
    x <- as.array(x)
    structure(class = c("table", oldClass(x)), provideDimnames(x))
  }
  else stop("cannot coerce to a table")
})
c("package:base", "registered S3 method for as.table from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
357)as.vector
list(`package:base` = function (x, mode = "any") 
  .Internal(as.vector(x, mode)), function (x, mode = "any") 
    .Internal(as.vector(x, mode)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
358)as.vector.data.frame
list(`package:base` = function (x, mode = "any") 
{
  x <- as.list.data.frame(x)
  if (mode %in% c("any", "list")) 
    x
  else as.vector(x, mode = mode)
}, function (x, mode = "any") 
{
  x <- as.list.data.frame(x)
  if (mode %in% c("any", "list")) 
    x
  else as.vector(x, mode = mode)
}, function (x, mode = "any") 
{
  x <- as.list.data.frame(x)
  if (mode %in% c("any", "list")) 
    x
  else as.vector(x, mode = mode)
})
c("package:base", "registered S3 method for as.vector from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
359)as.vector.factor
list(`package:base` = function (x, mode = "any") 
{
  if (mode == "list") 
    as.list(x)
  else if (mode == "any" || mode == "character" || mode == "logical") 
    as.vector(levels(x)[x], mode)
  else as.vector(unclass(x), mode)
}, function (x, mode = "any") 
{
  if (mode == "list") 
    as.list(x)
  else if (mode == "any" || mode == "character" || mode == "logical") 
    as.vector(levels(x)[x], mode)
  else as.vector(unclass(x), mode)
}, function (x, mode = "any") 
{
  if (mode == "list") 
    as.list(x)
  else if (mode == "any" || mode == "character" || mode == "logical") 
    as.vector(levels(x)[x], mode)
  else as.vector(unclass(x), mode)
})
c("package:base", "registered S3 method for as.vector from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
360)as.vector.POSIXlt
list(`package:base` = function (x, mode = "any") 
  as.vector(as.list(x), mode), function (x, mode = "any") 
    as.vector(as.list(x), mode), function (x, mode = "any") 
      as.vector(as.list(x), mode))
c("package:base", "registered S3 method for as.vector from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
361)asin
list(`package:base` = .Primitive("asin"), .Primitive("asin"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
362)asinh
list(`package:base` = .Primitive("asinh"), .Primitive("asinh"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
363)asNamespace
list(`package:base` = function (ns, base.OK = TRUE) 
{
  if (is.character(ns) || is.name(ns)) 
    ns <- getNamespace(ns)
  if (!isNamespace(ns)) 
    stop("not a namespace")
  else if (!base.OK && isBaseNamespace(ns)) 
    stop("operation not allowed on base namespace")
  else ns
}, function (ns, base.OK = TRUE) 
{
  if (is.character(ns) || is.name(ns)) 
    ns <- getNamespace(ns)
  if (!isNamespace(ns)) 
    stop("not a namespace")
  else if (!base.OK && isBaseNamespace(ns)) 
    stop("operation not allowed on base namespace")
  else ns
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
364)asplit
list(`package:base` = function (x, MARGIN) 
{
  dl <- length(dim(x))
  if (!dl) 
    stop("dim(x) must have a positive length")
  if (is.object(x)) 
    x <- if (dl == 2) 
      as.matrix(x)
  else as.array(x)
  d <- dim(x)
  dn <- dimnames(x)
  ds <- seq_len(dl)
  if (is.character(MARGIN)) {
    if (is.null(dnn <- names(dn))) 
      stop("'x' must have named dimnames")
    MARGIN <- match(MARGIN, dnn)
    if (anyNA(MARGIN)) 
      stop("not all elements of 'MARGIN' are names of dimensions")
  }
  s.call <- ds[-MARGIN]
  s.ans <- ds[MARGIN]
  d.call <- d[-MARGIN]
  d.ans <- d[MARGIN]
  dn.call <- dn[-MARGIN]
  dn.ans <- dn[MARGIN]
  d2 <- prod(d.ans)
  newx <- aperm(x, c(s.call, s.ans))
  dim(newx) <- c(prod(d.call), d2)
  ans <- vector("list", d2)
  for (i in seq_len(d2)) {
    ans[[i]] <- array(newx[, i], d.call, dn.call)
  }
  array(ans, d.ans, dn.ans)
}, function (x, MARGIN) 
{
  dl <- length(dim(x))
  if (!dl) 
    stop("dim(x) must have a positive length")
  if (is.object(x)) 
    x <- if (dl == 2) 
      as.matrix(x)
  else as.array(x)
  d <- dim(x)
  dn <- dimnames(x)
  ds <- seq_len(dl)
  if (is.character(MARGIN)) {
    if (is.null(dnn <- names(dn))) 
      stop("'x' must have named dimnames")
    MARGIN <- match(MARGIN, dnn)
    if (anyNA(MARGIN)) 
      stop("not all elements of 'MARGIN' are names of dimensions")
  }
  s.call <- ds[-MARGIN]
  s.ans <- ds[MARGIN]
  d.call <- d[-MARGIN]
  d.ans <- d[MARGIN]
  dn.call <- dn[-MARGIN]
  dn.ans <- dn[MARGIN]
  d2 <- prod(d.ans)
  newx <- aperm(x, c(s.call, s.ans))
  dim(newx) <- c(prod(d.call), d2)
  ans <- vector("list", d2)
  for (i in seq_len(d2)) {
    ans[[i]] <- array(newx[, i], d.call, dn.call)
  }
  array(ans, d.ans, dn.ans)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
365)asS3
list(`package:base` = function (object, flag = TRUE, complete = TRUE) 
  .Internal(setS4Object(object, !as.logical(flag), complete)), function (object, flag = TRUE, complete = TRUE) 
    .Internal(setS4Object(object, !as.logical(flag), complete)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
366)asS4
list(`package:base` = function (object, flag = TRUE, complete = TRUE) 
  .Internal(setS4Object(object, flag, complete)), function (object, flag = TRUE, complete = TRUE) 
    .Internal(setS4Object(object, flag, complete)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
367)assign
list(`package:base` = function (x, value, pos = -1, envir = as.environment(pos), inherits = FALSE, immediate = TRUE) 
  .Internal(assign(x, value, envir, inherits)), function (x, value, pos = -1, envir = as.environment(pos), inherits = FALSE, immediate = TRUE) 
    .Internal(assign(x, value, envir, inherits)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
368)atan
list(`package:base` = .Primitive("atan"), .Primitive("atan"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
369)atan2
list(`package:base` = function (y, x) 
  .Internal(atan2(y, x)), function (y, x) 
    .Internal(atan2(y, x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
370)atanh
list(`package:base` = .Primitive("atanh"), .Primitive("atanh"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
371)attach
list(`package:base` = function (what, pos = 2, name = deparse1(substitute(what), backtick = FALSE), warn.conflicts = TRUE) 
{
  checkConflicts <- function(env) {
    dont.mind <- c("last.dump", "last.warning", ".Last.value", ".Random.seed", ".Last.lib", ".onDetach", ".packageName", ".noGenerics", ".required", ".no_S3_generics", ".Depends", ".requireCachedGenerics")
    sp <- search()
    for (i in seq_along(sp)) {
      if (identical(env, as.environment(i))) {
        lib.pos <- i
        break
      }
    }
    ob <- names(as.environment(lib.pos))
    if (.isMethodsDispatchOn()) {
      these <- ob[startsWith(ob, ".__T__")]
      gen <- gsub(".__T__(.*):([^:]+)", "\\1", these)
      from <- gsub(".__T__(.*):([^:]+)", "\\2", these)
      gen <- gen[from != ".GlobalEnv"]
      ob <- ob[!(ob %in% gen)]
    }
    ipos <- seq_along(sp)[-c(lib.pos, match(c("Autoloads", "CheckExEnv"), sp, 0))]
    for (i in ipos) {
      obj.same <- match(names(as.environment(i)), ob, nomatch = 0)
      if (any(obj.same > 0)) {
        same <- ob[obj.same]
        same <- same[!(same %in% dont.mind)]
        Classobjs <- which(startsWith(same, ".__"))
        if (length(Classobjs)) 
          same <- same[-Classobjs]
        same.isFn <- function(where) vapply(same, exists, NA, where = where, mode = "function", inherits = FALSE)
        same <- same[same.isFn(i) == same.isFn(lib.pos)]
        if (length(same)) {
          pkg <- if (sum(sp == sp[i]) > 1) 
            sprintf("%s (pos = %d)", sp[i], i)
          else sp[i]
          message(.maskedMsg(sort(same), pkg, by = i < lib.pos), domain = NA)
        }
      }
    }
  }
  if (pos == 1) 
    stop("'pos=1' is not possible and has been warned about for years")
  if (is.character(what) && (length(what) == 1)) {
    if (!file.exists(what)) 
      stop(gettextf("file '%s' not found", what), domain = NA)
    if (missing(name)) 
      name <- paste0("file:", what)
    value <- .Internal(attach(NULL, pos, name))
    load(what, envir = as.environment(pos))
  }
  else value <- .Internal(attach(what, pos, name))
  if (warn.conflicts && !exists(".conflicts.OK", envir = value, inherits = FALSE)) {
    checkConflicts(value)
  }
  if (length(names(value)) && .isMethodsDispatchOn()) 
    methods::cacheMetaData(value, TRUE)
  invisible(value)
}, function (what, pos = 2, name = deparse1(substitute(what), backtick = FALSE), warn.conflicts = TRUE) 
{
  checkConflicts <- function(env) {
    dont.mind <- c("last.dump", "last.warning", ".Last.value", ".Random.seed", ".Last.lib", ".onDetach", ".packageName", ".noGenerics", ".required", ".no_S3_generics", ".Depends", ".requireCachedGenerics")
    sp <- search()
    for (i in seq_along(sp)) {
      if (identical(env, as.environment(i))) {
        lib.pos <- i
        break
      }
    }
    ob <- names(as.environment(lib.pos))
    if (.isMethodsDispatchOn()) {
      these <- ob[startsWith(ob, ".__T__")]
      gen <- gsub(".__T__(.*):([^:]+)", "\\1", these)
      from <- gsub(".__T__(.*):([^:]+)", "\\2", these)
      gen <- gen[from != ".GlobalEnv"]
      ob <- ob[!(ob %in% gen)]
    }
    ipos <- seq_along(sp)[-c(lib.pos, match(c("Autoloads", "CheckExEnv"), sp, 0))]
    for (i in ipos) {
      obj.same <- match(names(as.environment(i)), ob, nomatch = 0)
      if (any(obj.same > 0)) {
        same <- ob[obj.same]
        same <- same[!(same %in% dont.mind)]
        Classobjs <- which(startsWith(same, ".__"))
        if (length(Classobjs)) 
          same <- same[-Classobjs]
        same.isFn <- function(where) vapply(same, exists, NA, where = where, mode = "function", inherits = FALSE)
        same <- same[same.isFn(i) == same.isFn(lib.pos)]
        if (length(same)) {
          pkg <- if (sum(sp == sp[i]) > 1) 
            sprintf("%s (pos = %d)", sp[i], i)
          else sp[i]
          message(.maskedMsg(sort(same), pkg, by = i < lib.pos), domain = NA)
        }
      }
    }
  }
  if (pos == 1) 
    stop("'pos=1' is not possible and has been warned about for years")
  if (is.character(what) && (length(what) == 1)) {
    if (!file.exists(what)) 
      stop(gettextf("file '%s' not found", what), domain = NA)
    if (missing(name)) 
      name <- paste0("file:", what)
    value <- .Internal(attach(NULL, pos, name))
    load(what, envir = as.environment(pos))
  }
  else value <- .Internal(attach(what, pos, name))
  if (warn.conflicts && !exists(".conflicts.OK", envir = value, inherits = FALSE)) {
    checkConflicts(value)
  }
  if (length(names(value)) && .isMethodsDispatchOn()) 
    methods::cacheMetaData(value, TRUE)
  invisible(value)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
372)attachNamespace
list(`package:base` = function (ns, pos = 2, depends = NULL, exclude, include.only) 
{
  runHook <- function(hookname, env, libname, pkgname) {
    if (!is.null(fun <- env[[hookname]])) {
      res <- tryCatch(fun(libname, pkgname), error = identity)
      if (inherits(res, "error")) {
        stop(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", hookname, "attachNamespace", nsname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
      }
    }
  }
  runUserHook <- function(pkgname, pkgpath) {
    hook <- getHook(packageEvent(pkgname, "attach"))
    for (fun in hook) try(fun(pkgname, pkgpath))
  }
  ns <- asNamespace(ns, base.OK = FALSE)
  nsname <- getNamespaceName(ns)
  nspath <- .getNamespaceInfo(ns, "path")
  attname <- paste0("package:", nsname)
  if (attname %in% search()) 
    stop("namespace is already attached")
  env <- attach(NULL, pos = pos, name = attname)
  on.exit(.Internal(detach(pos)))
  attr(env, "path") <- nspath
  exports <- getNamespaceExports(ns)
  importIntoEnv(env, exports, ns, exports)
  dimpenv <- .getNamespaceInfo(ns, "lazydata")
  dnames <- names(dimpenv)
  .Internal(importIntoEnv(env, dnames, dimpenv, dnames))
  if (length(depends) > 0) 
    env$.Depends <- depends
  Sys.setenv(`_R_NS_LOAD_` = nsname)
  on.exit(Sys.unsetenv("_R_NS_LOAD_"), add = TRUE)
  runHook(".onAttach", ns, dirname(nspath), nsname)
  if (!missing(exclude) && length(exclude) > 0) 
    rm(list = exclude, envir = env)
  if (!missing(include.only)) {
    vars <- ls(env, all.names = TRUE)
    nf <- setdiff(include.only, vars)
    if (length(nf) > 0) {
      nf <- strwrap(paste(nf, collapse = ", "), indent = 4, exdent = 4)
      stop(gettextf("not found in namespace %s: \n\n%s\n", sQuote(nsname), nf), call. = FALSE, domain = NA)
    }
    rm(list = setdiff(vars, include.only), envir = env)
  }
  lockEnvironment(env, TRUE)
  runUserHook(nsname, nspath)
  on.exit()
  Sys.unsetenv("_R_NS_LOAD_")
  invisible(env)
}, function (ns, pos = 2, depends = NULL, exclude, include.only) 
{
  runHook <- function(hookname, env, libname, pkgname) {
    if (!is.null(fun <- env[[hookname]])) {
      res <- tryCatch(fun(libname, pkgname), error = identity)
      if (inherits(res, "error")) {
        stop(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", hookname, "attachNamespace", nsname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
      }
    }
  }
  runUserHook <- function(pkgname, pkgpath) {
    hook <- getHook(packageEvent(pkgname, "attach"))
    for (fun in hook) try(fun(pkgname, pkgpath))
  }
  ns <- asNamespace(ns, base.OK = FALSE)
  nsname <- getNamespaceName(ns)
  nspath <- .getNamespaceInfo(ns, "path")
  attname <- paste0("package:", nsname)
  if (attname %in% search()) 
    stop("namespace is already attached")
  env <- attach(NULL, pos = pos, name = attname)
  on.exit(.Internal(detach(pos)))
  attr(env, "path") <- nspath
  exports <- getNamespaceExports(ns)
  importIntoEnv(env, exports, ns, exports)
  dimpenv <- .getNamespaceInfo(ns, "lazydata")
  dnames <- names(dimpenv)
  .Internal(importIntoEnv(env, dnames, dimpenv, dnames))
  if (length(depends) > 0) 
    env$.Depends <- depends
  Sys.setenv(`_R_NS_LOAD_` = nsname)
  on.exit(Sys.unsetenv("_R_NS_LOAD_"), add = TRUE)
  runHook(".onAttach", ns, dirname(nspath), nsname)
  if (!missing(exclude) && length(exclude) > 0) 
    rm(list = exclude, envir = env)
  if (!missing(include.only)) {
    vars <- ls(env, all.names = TRUE)
    nf <- setdiff(include.only, vars)
    if (length(nf) > 0) {
      nf <- strwrap(paste(nf, collapse = ", "), indent = 4, exdent = 4)
      stop(gettextf("not found in namespace %s: \n\n%s\n", sQuote(nsname), nf), call. = FALSE, domain = NA)
    }
    rm(list = setdiff(vars, include.only), envir = env)
  }
  lockEnvironment(env, TRUE)
  runUserHook(nsname, nspath)
  on.exit()
  Sys.unsetenv("_R_NS_LOAD_")
  invisible(env)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
373)attr
list(`package:base` = .Primitive("attr"), .Primitive("attr"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
374)attr.all.equal
list(`package:base` = function (target, current, ..., check.attributes = TRUE, check.names = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  if (!is.logical(check.names)) 
    stop(gettextf("'%s' must be logical", "check.names"), domain = NA)
  msg <- NULL
  if (mode(target) != mode(current)) 
    msg <- paste0("Modes: ", mode(target), ", ", mode(current))
  if (length(target) != length(current)) 
    msg <- c(msg, paste0("Lengths: ", length(target), ", ", length(current)))
  ax <- attributes(target)
  ay <- attributes(current)
  if (check.names) {
    nx <- names(target)
    ny <- names(current)
    if ((lx <- length(nx)) | (ly <- length(ny))) {
      ax$names <- ay$names <- NULL
      if (lx && ly) {
        if (is.character(m <- all.equal.character(nx, ny, check.attributes = check.attributes))) 
          msg <- c(msg, paste("Names:", m))
      }
      else if (lx) 
        msg <- c(msg, "names for target but not for current")
      else msg <- c(msg, "names for current but not for target")
    }
  }
  else {
    ax[["names"]] <- NULL
    ay[["names"]] <- NULL
  }
  if (check.attributes && (length(ax) || length(ay))) {
    nx <- names(ax)
    ny <- names(ay)
    if (length(nx)) 
      ax <- ax[order(nx)]
    if (length(ny)) 
      ay <- ay[order(ny)]
    tt <- all.equal(ax, ay, ..., check.attributes = check.attributes)
    if (is.character(tt)) 
      msg <- c(msg, paste("Attributes: <", tt, ">"))
  }
  msg
}, function (target, current, ..., check.attributes = TRUE, check.names = TRUE) 
{
  if (!is.logical(check.attributes)) 
    stop(gettextf("'%s' must be logical", "check.attributes"), domain = NA)
  if (!is.logical(check.names)) 
    stop(gettextf("'%s' must be logical", "check.names"), domain = NA)
  msg <- NULL
  if (mode(target) != mode(current)) 
    msg <- paste0("Modes: ", mode(target), ", ", mode(current))
  if (length(target) != length(current)) 
    msg <- c(msg, paste0("Lengths: ", length(target), ", ", length(current)))
  ax <- attributes(target)
  ay <- attributes(current)
  if (check.names) {
    nx <- names(target)
    ny <- names(current)
    if ((lx <- length(nx)) | (ly <- length(ny))) {
      ax$names <- ay$names <- NULL
      if (lx && ly) {
        if (is.character(m <- all.equal.character(nx, ny, check.attributes = check.attributes))) 
          msg <- c(msg, paste("Names:", m))
      }
      else if (lx) 
        msg <- c(msg, "names for target but not for current")
      else msg <- c(msg, "names for current but not for target")
    }
  }
  else {
    ax[["names"]] <- NULL
    ay[["names"]] <- NULL
  }
  if (check.attributes && (length(ax) || length(ay))) {
    nx <- names(ax)
    ny <- names(ay)
    if (length(nx)) 
      ax <- ax[order(nx)]
    if (length(ny)) 
      ay <- ay[order(ny)]
    tt <- all.equal(ax, ay, ..., check.attributes = check.attributes)
    if (is.character(tt)) 
      msg <- c(msg, paste("Attributes: <", tt, ">"))
  }
  msg
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
375)attr<-
  list(`package:base` = .Primitive("attr<-"), .Primitive("attr<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
376)attributes
list(`package:base` = .Primitive("attributes"), .Primitive("attributes"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
377)attributes<-
  list(`package:base` = .Primitive("attributes<-"), .Primitive("attributes<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
378)autoload
list(`package:base` = function (name, package, reset = FALSE, ...) 
{
  if (!reset && exists(name, envir = .GlobalEnv, inherits = FALSE)) 
    stop("an object with that name already exists")
  m <- match.call()
  m[[1]] <- as.name("list")
  newcall <- eval(m, parent.frame())
  newcall <- as.call(c(as.name("autoloader"), newcall))
  newcall$reset <- NULL
  if (is.na(match(package, .Autoloaded))) 
    assign(".Autoloaded", c(package, .Autoloaded), envir = .AutoloadEnv)
  do.call(delayedAssign, list(name, newcall, .GlobalEnv, .AutoloadEnv))
  invisible()
}, function (name, package, reset = FALSE, ...) 
{
  if (!reset && exists(name, envir = .GlobalEnv, inherits = FALSE)) 
    stop("an object with that name already exists")
  m <- match.call()
  m[[1]] <- as.name("list")
  newcall <- eval(m, parent.frame())
  newcall <- as.call(c(as.name("autoloader"), newcall))
  newcall$reset <- NULL
  if (is.na(match(package, .Autoloaded))) 
    assign(".Autoloaded", c(package, .Autoloaded), envir = .AutoloadEnv)
  do.call(delayedAssign, list(name, newcall, .GlobalEnv, .AutoloadEnv))
  invisible()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
379)autoloader
list(`package:base` = function (name, package, ...) 
{
  name <- paste0(name, "")
  rm(list = name, envir = .AutoloadEnv, inherits = FALSE)
  m <- match.call()
  m$name <- NULL
  m[[1]] <- as.name("library")
  eval(m, .GlobalEnv)
  autoload(name, package, reset = TRUE, ...)
  where <- match(paste0("package:", package), search())
  if (exists(name, where = where, inherits = FALSE)) 
    eval(as.name(name), as.environment(where))
  else stop(gettextf("autoloader did not find '%s' in '%s'", name, package), domain = NA)
}, function (name, package, ...) 
{
  name <- paste0(name, "")
  rm(list = name, envir = .AutoloadEnv, inherits = FALSE)
  m <- match.call()
  m$name <- NULL
  m[[1]] <- as.name("library")
  eval(m, .GlobalEnv)
  autoload(name, package, reset = TRUE, ...)
  where <- match(paste0("package:", package), search())
  if (exists(name, where = where, inherits = FALSE)) 
    eval(as.name(name), as.environment(where))
  else stop(gettextf("autoloader did not find '%s' in '%s'", name, package), domain = NA)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
380)backsolve
list(`package:base` = function (r, x, k = ncol(r), upper.tri = TRUE, transpose = FALSE) 
{
  r <- as.matrix(r)
  x.mat <- is.matrix(x)
  if (!x.mat) 
    x <- as.matrix(x)
  z <- .Internal(backsolve(r, x, k, upper.tri, transpose))
  if (x.mat) 
    z
  else drop(z)
}, function (r, x, k = ncol(r), upper.tri = TRUE, transpose = FALSE) 
{
  r <- as.matrix(r)
  x.mat <- is.matrix(x)
  if (!x.mat) 
    x <- as.matrix(x)
  z <- .Internal(backsolve(r, x, k, upper.tri, transpose))
  if (x.mat) 
    z
  else drop(z)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
381)baseenv
list(`package:base` = .Primitive("baseenv"), .Primitive("baseenv"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
382)basename
list(`package:base` = function (path) 
  .Internal(basename(path)), function (path) 
    .Internal(basename(path)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
383)besselI
list(`package:base` = function (x, nu, expon.scaled = FALSE) 
{
  .Internal(besselI(x, nu, 1 + as.logical(expon.scaled)))
}, function (x, nu, expon.scaled = FALSE) 
{
  .Internal(besselI(x, nu, 1 + as.logical(expon.scaled)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
384)besselJ
list(`package:base` = function (x, nu) 
  .Internal(besselJ(x, nu)), function (x, nu) 
    .Internal(besselJ(x, nu)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
385)besselK
list(`package:base` = function (x, nu, expon.scaled = FALSE) 
{
  .Internal(besselK(x, nu, 1 + as.logical(expon.scaled)))
}, function (x, nu, expon.scaled = FALSE) 
{
  .Internal(besselK(x, nu, 1 + as.logical(expon.scaled)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
386)besselY
list(`package:base` = function (x, nu) 
  .Internal(besselY(x, nu)), function (x, nu) 
    .Internal(besselY(x, nu)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
387)beta
list(`package:base` = function (a, b) 
  .Internal(beta(a, b)), function (a, b) 
    .Internal(beta(a, b)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
388)bindingIsActive
list(`package:base` = function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(bindingIsActive(sym, env))
}, function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(bindingIsActive(sym, env))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
389)bindingIsLocked
list(`package:base` = function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(bindingIsLocked(sym, env))
}, function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(bindingIsLocked(sym, env))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
390)bindtextdomain
list(`package:base` = function (domain, dirname = NULL) 
  .Internal(bindtextdomain(domain, dirname)), function (domain, dirname = NULL) 
    .Internal(bindtextdomain(domain, dirname)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
391)bitwAnd
list(`package:base` = function (a, b) 
  .Internal(bitwiseAnd(a, b)), function (a, b) 
    .Internal(bitwiseAnd(a, b)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
392)bitwNot
list(`package:base` = function (a) 
  .Internal(bitwiseNot(a)), function (a) 
    .Internal(bitwiseNot(a)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
393)bitwOr
list(`package:base` = function (a, b) 
  .Internal(bitwiseOr(a, b)), function (a, b) 
    .Internal(bitwiseOr(a, b)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
394)bitwShiftL
list(`package:base` = function (a, n) 
  .Internal(bitwiseShiftL(a, n)), function (a, n) 
    .Internal(bitwiseShiftL(a, n)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
395)bitwShiftR
list(`package:base` = function (a, n) 
  .Internal(bitwiseShiftR(a, n)), function (a, n) 
    .Internal(bitwiseShiftR(a, n)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
396)bitwXor
list(`package:base` = function (a, b) 
  .Internal(bitwiseXor(a, b)), function (a, b) 
    .Internal(bitwiseXor(a, b)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
397)body
list(`package:base` = function (fun = sys.function(sys.parent())) 
{
  if (is.character(fun)) 
    fun <- get(fun, mode = "function", envir = parent.frame())
  .Internal(body(fun))
}, function (fun = sys.function(sys.parent())) 
{
  if (is.character(fun)) 
    fun <- get(fun, mode = "function", envir = parent.frame())
  .Internal(body(fun))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
398)body<-
  list(`package:methods` = new("standardGeneric", .Data = function (fun, envir = environment(fun), value) 
    standardGeneric("body<-"), generic = "body<-", package = "base", group = list(), valueClass = character(0), signature = c("fun", "envir", "value"), default = new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      if (is.expression(value)) {
        if (length(value) > 1) 
          warning("using the first element of 'value' of type \"expression\"")
        value <- value[[1]]
      }
      as.function(c(as.list(formals(fun)), list(value)), envir)
    }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "body<-"), skeleton = (new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      if (is.expression(value)) {
        if (length(value) > 1) 
          warning("using the first element of 'value' of type \"expression\"")
        value <- value[[1]]
      }
      as.function(c(as.list(formals(fun)), list(value)), envir)
    }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "body<-"))(fun, envir, value)), `package:base` = function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      if (is.expression(value)) {
        if (length(value) > 1) 
          warning("using the first element of 'value' of type \"expression\"")
        value <- value[[1]]
      }
      as.function(c(as.list(formals(fun)), list(value)), envir)
    }, new("standardGeneric", .Data = function (fun, envir = environment(fun), value) 
      standardGeneric("body<-"), generic = "body<-", package = "base", group = list(), valueClass = character(0), signature = c("fun", "envir", "value"), default = new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
      {
        if (!is.function(fun)) 
          warning("'fun' is not a function")
        if (is.expression(value)) {
          if (length(value) > 1) 
            warning("using the first element of 'value' of type \"expression\"")
          value <- value[[1]]
        }
        as.function(c(as.list(formals(fun)), list(value)), envir)
      }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "body<-"), skeleton = (new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
      {
        if (!is.function(fun)) 
          warning("'fun' is not a function")
        if (is.expression(value)) {
          if (length(value) > 1) 
            warning("using the first element of 'value' of type \"expression\"")
          value <- value[[1]]
        }
        as.function(c(as.list(formals(fun)), list(value)), envir)
      }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "body<-"))(fun, envir, value)), function (fun, envir = environment(fun), value) 
      {
        if (!is.function(fun)) 
          warning("'fun' is not a function")
        if (is.expression(value)) {
          if (length(value) > 1) 
            warning("using the first element of 'value' of type \"expression\"")
          value <- value[[1]]
        }
        as.function(c(as.list(formals(fun)), list(value)), envir)
      })
c("package:methods", "package:base", "namespace:methods", "namespace:base")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
399)bquote
list(`package:base` = function (expr, where = parent.frame(), splice = FALSE) 
{
  if (!is.environment(where)) 
    where <- as.environment(where)
  unquote <- function(e) {
    if (is.pairlist(e)) 
      as.pairlist(lapply(e, unquote))
    else if (is.call(e)) {
      if (is.name(e[[1]]) && as.character(e[[1]]) == ".") 
        eval(e[[2]], where)
      else if (splice) {
        if (is.name(e[[1]]) && as.character(e[[1]]) == "..") 
          stop("can only splice inside a call", call. = FALSE)
        else as.call(unquote.list(e))
      }
      else as.call(lapply(e, unquote))
    }
    else e
  }
  is.splice.macro <- function(e) is.call(e) && is.name(e[[1]]) && as.character(e[[1]]) == ".."
  unquote.list <- function(e) {
    p <- Position(is.splice.macro, e, nomatch = NULL)
    if (is.null(p)) 
      lapply(e, unquote)
    else {
      n <- length(e)
      head <- if (p == 1) 
        NULL
      else e[1:(p - 1)]
      tail <- if (p == n) 
        NULL
      else e[(p + 1):n]
      macro <- e[[p]]
      mexp <- eval(macro[[2]], where)
      if (!is.vector(mexp) && !is.expression(mexp)) 
        stop("can only splice vectors")
      c(lapply(head, unquote), mexp, as.list(unquote.list(tail)))
    }
  }
  unquote(substitute(expr))
}, function (expr, where = parent.frame(), splice = FALSE) 
{
  if (!is.environment(where)) 
    where <- as.environment(where)
  unquote <- function(e) {
    if (is.pairlist(e)) 
      as.pairlist(lapply(e, unquote))
    else if (is.call(e)) {
      if (is.name(e[[1]]) && as.character(e[[1]]) == ".") 
        eval(e[[2]], where)
      else if (splice) {
        if (is.name(e[[1]]) && as.character(e[[1]]) == "..") 
          stop("can only splice inside a call", call. = FALSE)
        else as.call(unquote.list(e))
      }
      else as.call(lapply(e, unquote))
    }
    else e
  }
  is.splice.macro <- function(e) is.call(e) && is.name(e[[1]]) && as.character(e[[1]]) == ".."
  unquote.list <- function(e) {
    p <- Position(is.splice.macro, e, nomatch = NULL)
    if (is.null(p)) 
      lapply(e, unquote)
    else {
      n <- length(e)
      head <- if (p == 1) 
        NULL
      else e[1:(p - 1)]
      tail <- if (p == n) 
        NULL
      else e[(p + 1):n]
      macro <- e[[p]]
      mexp <- eval(macro[[2]], where)
      if (!is.vector(mexp) && !is.expression(mexp)) 
        stop("can only splice vectors")
      c(lapply(head, unquote), mexp, as.list(unquote.list(tail)))
    }
  }
  unquote(substitute(expr))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
400)break
list(`package:base` = .Primitive("break"), .Primitive("break"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
401)browser
list(`package:base` = .Primitive("browser"), function (..., skipCalls = 0, frame = parent.frame()) 
{
  if (!identical(stdout(), getConnection(1))) {
    sink(getConnection(1))
    withr::defer(sink(), envir = frame)
  }
  on.exit(base::browser(..., skipCalls = skipCalls + 1))
}, function (..., skipCalls = 0, frame = parent.frame()) 
{
  if (!identical(stdout(), getConnection(1))) {
    sink(getConnection(1))
    withr::defer(sink(), envir = frame)
  }
  on.exit(base::browser(..., skipCalls = skipCalls + 1))
}, .Primitive("browser"))
c("package:base", "namespace:vctrs", "namespace:rlang", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
402)browserCondition
list(`package:base` = function (n = 1) 
  .Internal(browserCondition(n)), function (n = 1) 
    .Internal(browserCondition(n)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
403)browserSetDebug
list(`package:base` = function (n = 1) 
  .Internal(browserSetDebug(n)), function (n = 1) 
    .Internal(browserSetDebug(n)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
404)browserText
list(`package:base` = function (n = 1) 
  .Internal(browserText(n)), function (n = 1) 
    .Internal(browserText(n)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
405)builtins
list(`package:base` = function (internal = FALSE) 
  .Internal(builtins(internal)), function (internal = FALSE) 
    .Internal(builtins(internal)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
406)by
list(`package:base` = function (data, INDICES, FUN, ..., simplify = TRUE) 
  UseMethod("by"), function (data, INDICES, FUN, ..., simplify = TRUE) 
    UseMethod("by"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
407)by.data.frame
list(`package:base` = function (data, INDICES, FUN, ..., simplify = TRUE) 
{
  if (!is.list(INDICES)) {
    IND <- list(INDICES)
    names(IND) <- deparse(substitute(INDICES))[1]
  }
  else IND <- INDICES
  FUNx <- function(x) FUN(data[x, , drop = FALSE], ...)
  nd <- nrow(data)
  structure(eval(substitute(tapply(seq_len(nd), IND, FUNx, simplify = simplify)), data), call = match.call(), class = "by")
}, function (data, INDICES, FUN, ..., simplify = TRUE) 
{
  if (!is.list(INDICES)) {
    IND <- list(INDICES)
    names(IND) <- deparse(substitute(INDICES))[1]
  }
  else IND <- INDICES
  FUNx <- function(x) FUN(data[x, , drop = FALSE], ...)
  nd <- nrow(data)
  structure(eval(substitute(tapply(seq_len(nd), IND, FUNx, simplify = simplify)), data), call = match.call(), class = "by")
}, function (data, INDICES, FUN, ..., simplify = TRUE) 
{
  if (!is.list(INDICES)) {
    IND <- list(INDICES)
    names(IND) <- deparse(substitute(INDICES))[1]
  }
  else IND <- INDICES
  FUNx <- function(x) FUN(data[x, , drop = FALSE], ...)
  nd <- nrow(data)
  structure(eval(substitute(tapply(seq_len(nd), IND, FUNx, simplify = simplify)), data), call = match.call(), class = "by")
})
c("package:base", "registered S3 method for by from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
by.default
list(`package:base` = function (data, INDICES, FUN, ..., simplify = TRUE) 
{
  dd <- as.data.frame(data)
  if (length(dim(data))) 
    by(dd, INDICES, FUN, ..., simplify = simplify)
  else {
    if (!is.list(INDICES)) {
      IND <- list(INDICES)
      names(IND) <- deparse(substitute(INDICES))[1]
    }
    else IND <- INDICES
    FUNx <- function(x) FUN(dd[x, ], ...)
    nd <- nrow(dd)
    structure(eval(substitute(tapply(seq_len(nd), IND, FUNx, simplify = simplify)), dd), call = match.call(), class = "by")
  }
}, function (data, INDICES, FUN, ..., simplify = TRUE) 
{
  dd <- as.data.frame(data)
  if (length(dim(data))) 
    by(dd, INDICES, FUN, ..., simplify = simplify)
  else {
    if (!is.list(INDICES)) {
      IND <- list(INDICES)
      names(IND) <- deparse(substitute(INDICES))[1]
    }
    else IND <- INDICES
    FUNx <- function(x) FUN(dd[x, ], ...)
    nd <- nrow(dd)
    structure(eval(substitute(tapply(seq_len(nd), IND, FUNx, simplify = simplify)), dd), call = match.call(), class = "by")
  }
}, function (data, INDICES, FUN, ..., simplify = TRUE) 
{
  dd <- as.data.frame(data)
  if (length(dim(data))) 
    by(dd, INDICES, FUN, ..., simplify = simplify)
  else {
    if (!is.list(INDICES)) {
      IND <- list(INDICES)
      names(IND) <- deparse(substitute(INDICES))[1]
    }
    else IND <- INDICES
    FUNx <- function(x) FUN(dd[x, ], ...)
    nd <- nrow(dd)
    structure(eval(substitute(tapply(seq_len(nd), IND, FUNx, simplify = simplify)), dd), call = match.call(), class = "by")
  }
})
c("package:base", "registered S3 method for by from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
bzfile
list(`package:base` = function (description, open = "", encoding = getOption("encoding"), compression = 9) 
  .Internal(bzfile(description, open, encoding, compression)), function (description, open = "", encoding = getOption("encoding"), compression = 9) 
    .Internal(bzfile(description, open, encoding, compression)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
c
list(`package:base` = .Primitive("c"), .Primitive("c"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
c.Date
list(`package:base` = function (..., recursive = FALSE) 
  .Date(c(unlist(lapply(list(...), function(e) unclass(as.Date(e)))))), function (..., recursive = FALSE) 
    .Date(c(unlist(lapply(list(...), function(e) unclass(as.Date(e)))))), function (..., recursive = FALSE) 
    {
      structure(c(unlist(lapply(list(...), .recursive_date_unclass))), class = "Date")
    }, function (..., recursive = FALSE) 
      .Date(c(unlist(lapply(list(...), function(e) unclass(as.Date(e)))))))
c("package:base", "registered S3 method for c from namespace base", "namespace:lubridate", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
c.difftime
list(`package:base` = function (..., recursive = FALSE) 
{
  coerceTimeUnit <- function(x) {
    switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x)
  }
  args <- list(...)
  if (!length(args)) 
    return(.difftime(double(), "secs"))
  ind <- sapply(args, inherits, "difftime")
  pos <- which(!ind)
  units <- sapply(args[ind], attr, "units")
  if (all(units == (un1 <- units[1]))) {
    if (length(pos)) 
      args[pos] <- lapply(args[pos], as.difftime, units = un1)
    .difftime(unlist(args), un1)
  }
  else {
    if (length(pos)) 
      args[pos] <- lapply(args[pos], as.difftime, units = "secs")
    args[ind] <- lapply(args[ind], coerceTimeUnit)
    .difftime(unlist(args), "secs")
  }
}, function (..., recursive = FALSE) 
{
  coerceTimeUnit <- function(x) {
    switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x)
  }
  args <- list(...)
  if (!length(args)) 
    return(.difftime(double(), "secs"))
  ind <- sapply(args, inherits, "difftime")
  pos <- which(!ind)
  units <- sapply(args[ind], attr, "units")
  if (all(units == (un1 <- units[1]))) {
    if (length(pos)) 
      args[pos] <- lapply(args[pos], as.difftime, units = un1)
    .difftime(unlist(args), un1)
  }
  else {
    if (length(pos)) 
      args[pos] <- lapply(args[pos], as.difftime, units = "secs")
    args[ind] <- lapply(args[ind], coerceTimeUnit)
    .difftime(unlist(args), "secs")
  }
}, function (..., recursive = FALSE) 
{
  coerceTimeUnit <- function(x) {
    switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x)
  }
  args <- list(...)
  if (!length(args)) 
    return(.difftime(double(), "secs"))
  ind <- sapply(args, inherits, "difftime")
  pos <- which(!ind)
  units <- sapply(args[ind], attr, "units")
  if (all(units == (un1 <- units[1]))) {
    if (length(pos)) 
      args[pos] <- lapply(args[pos], as.difftime, units = un1)
    .difftime(unlist(args), un1)
  }
  else {
    if (length(pos)) 
      args[pos] <- lapply(args[pos], as.difftime, units = "secs")
    args[ind] <- lapply(args[ind], coerceTimeUnit)
    .difftime(unlist(args), "secs")
  }
})
c("package:base", "registered S3 method for c from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
c.factor
list(`package:base` = function (..., recursive = TRUE) 
{
  x <- list(...)
  y <- unlist(x, recursive = recursive)
  if (inherits(y, "factor") && all(vapply(x, inherits, NA, "ordered")) && (length(unique(lapply(x, levels))) == 1)) 
    class(y) <- c("ordered", "factor")
  y
}, function (..., recursive = TRUE) 
{
  x <- list(...)
  y <- unlist(x, recursive = recursive)
  if (inherits(y, "factor") && all(vapply(x, inherits, NA, "ordered")) && (length(unique(lapply(x, levels))) == 1)) 
    class(y) <- c("ordered", "factor")
  y
}, function (..., recursive = TRUE) 
{
  x <- list(...)
  y <- unlist(x, recursive = recursive)
  if (inherits(y, "factor") && all(vapply(x, inherits, NA, "ordered")) && (length(unique(lapply(x, levels))) == 1)) 
    class(y) <- c("ordered", "factor")
  y
})
c("package:base", "registered S3 method for c from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
c.noquote
list(`package:base` = function (..., recursive = FALSE) 
  structure(NextMethod("c"), class = "noquote"), function (..., recursive = FALSE) 
    structure(NextMethod("c"), class = "noquote"), function (..., recursive = FALSE) 
      structure(NextMethod("c"), class = "noquote"))
c("package:base", "registered S3 method for c from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
c.numeric_version
list(`package:base` = function (..., recursive = FALSE) 
{
  x <- lapply(list(...), as.numeric_version)
  classes <- if (length(unique(lapply(x, class))) == 1) 
    class(x[[1]])
  else "numeric_version"
  structure(unlist(x, recursive = FALSE), class = classes)
}, function (..., recursive = FALSE) 
{
  x <- lapply(list(...), as.numeric_version)
  classes <- if (length(unique(lapply(x, class))) == 1) 
    class(x[[1]])
  else "numeric_version"
  structure(unlist(x, recursive = FALSE), class = classes)
}, function (..., recursive = FALSE) 
{
  x <- lapply(list(...), as.numeric_version)
  classes <- if (length(unique(lapply(x, class))) == 1) 
    class(x[[1]])
  else "numeric_version"
  structure(unlist(x, recursive = FALSE), class = classes)
})
c("package:base", "registered S3 method for c from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
c.POSIXct
list(`package:base` = function (..., recursive = FALSE) 
{
  x <- lapply(list(...), function(e) unclass(as.POSIXct(e)))
  tzones <- lapply(x, attr, "tzone")
  tz <- if (length(unique(tzones)) == 1) 
    tzones[[1]]
  else NULL
  .POSIXct(c(unlist(x)), tz)
}, function (..., recursive = FALSE) 
{
  x <- lapply(list(...), function(e) unclass(as.POSIXct(e)))
  tzones <- lapply(x, attr, "tzone")
  tz <- if (length(unique(tzones)) == 1) 
    tzones[[1]]
  else NULL
  .POSIXct(c(unlist(x)), tz)
}, function (..., recursive = FALSE) 
{
  dots <- list(...)
  tz <- tz(dots[[1]])
  .POSIXct(c(unlist(lapply(dots, .recursive_posixct_unclass, tz = tz))), tz = tz)
}, function (..., recursive = FALSE) 
{
  x <- lapply(list(...), function(e) unclass(as.POSIXct(e)))
  tzones <- lapply(x, attr, "tzone")
  tz <- if (length(unique(tzones)) == 1) 
    tzones[[1]]
  else NULL
  .POSIXct(c(unlist(x)), tz)
})
c("package:base", "registered S3 method for c from namespace base", "namespace:lubridate", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
c.POSIXlt
list(`package:base` = function (..., recursive = FALSE) 
{
  as.POSIXlt(do.call(c, lapply(list(...), as.POSIXct)))
}, function (..., recursive = FALSE) 
{
  as.POSIXlt(do.call(c, lapply(list(...), as.POSIXct)))
}, function (..., recursive = FALSE) 
{
  as.POSIXlt(do.call("c.POSIXct", lapply(list(...), as.POSIXct)))
}, function (..., recursive = FALSE) 
{
  as.POSIXlt(do.call(c, lapply(list(...), as.POSIXct)))
})
c("package:base", "registered S3 method for c from namespace base", "namespace:lubridate", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
c.warnings
list(`package:base` = function (..., recursive = FALSE) 
  structure(NextMethod("c"), class = "warnings"), function (..., recursive = FALSE) 
    structure(NextMethod("c"), class = "warnings"), function (..., recursive = FALSE) 
      structure(NextMethod("c"), class = "warnings"))
c("package:base", "registered S3 method for c from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
call
list(`package:base` = .Primitive("call"), .Primitive("call"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
callCC
list(`package:base` = function (fun) 
{
  value <- NULL
  delayedAssign("throw", return(value))
  fun(function(v) {
    value <<- v
    throw
  })
}, function (fun) 
{
  value <- NULL
  delayedAssign("throw", return(value))
  fun(function(v) {
    value <<- v
    throw
  })
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
capabilities
list(`package:base` = function (what = NULL, Xchk = any(nas %in% c("X11", "jpeg", "png", "tiff"))) 
{
  z <- .Internal(capabilities())
  if (!is.null(what)) 
    z <- z[match(what, names(z), 0)]
  if (.Platform$OS.type == "windows" || (!missing(Xchk) && isFALSE(Xchk))) 
    return(z)
  nas <- names(z[is.na(z)])
  if (Xchk) {
    z[nas] <- tryCatch(.Internal(capabilitiesX11()), error = function(e) FALSE)
  }
  z
}, function () 
  .Call(rcpp_capabilities), function (what = NULL, Xchk = any(nas %in% c("X11", "jpeg", "png", "tiff"))) 
  {
    z <- .Internal(capabilities())
    if (!is.null(what)) 
      z <- z[match(what, names(z), 0)]
    if (.Platform$OS.type == "windows" || (!missing(Xchk) && isFALSE(Xchk))) 
      return(z)
    nas <- names(z[is.na(z)])
    if (Xchk) {
      z[nas] <- tryCatch(.Internal(capabilitiesX11()), error = function(e) FALSE)
    }
    z
  })
c("package:base", "namespace:Rcpp", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
casefold
list(`package:base` = function (x, upper = FALSE) 
  if (upper) toupper(x) else tolower(x), function (x, upper = FALSE) 
    if (upper) toupper(x) else tolower(x))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cat
list(`package:base` = function (..., file = "", sep = " ", fill = FALSE, labels = NULL, append = FALSE) 
{
  if (is.character(file)) 
    if (file == "") 
      file <- stdout()
  else if (startsWith(file, "|")) {
    file <- pipe(substring(file, 2), "w")
    on.exit(close(file))
  }
  else {
    file <- file(file, ifelse(append, "a", "w"))
    on.exit(close(file))
  }
  .Internal(cat(list(...), file, sep, fill, labels, append))
}, function (..., file = "", sep = " ", fill = FALSE, labels = NULL, append = FALSE) 
{
  if (is.character(file)) 
    if (file == "") 
      file <- stdout()
  else if (startsWith(file, "|")) {
    file <- pipe(substring(file, 2), "w")
    on.exit(close(file))
  }
  else {
    file <- file(file, ifelse(append, "a", "w"))
    on.exit(close(file))
  }
  .Internal(cat(list(...), file, sep, fill, labels, append))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cbind
list(`package:base` = function (..., deparse.level = 1) 
  .Internal(cbind(deparse.level, ...)), function (..., deparse.level = 1) 
  {
    has.dl <- !missing(deparse.level)
    deparse.level <- as.integer(deparse.level)
    if (identical(deparse.level, -1)) 
      deparse.level <- 0
    stopifnot(0 <= deparse.level, deparse.level <= 2)
    argl <- list(...)
    na <- nargs() - has.dl
    while (na > 0 && is.null(argl[[na]])) {
      argl <- argl[-na]
      na <- na - 1
    }
    if (na == 0) 
      return(NULL)
    symarg <- as.list(substitute(list(...)))[-1]
    nmsym <- names(symarg)
    nm <- c(function(i) NULL, function(i) if (is.symbol(s <- symarg[[i]])) deparse(s) else NULL, function(i) deparse(symarg[[i]])[[1]])[[1 + deparse.level]]
    Nms <- function(i) {
      if (!is.null(s <- nmsym[i]) && nzchar(s)) 
        s
      else nm(i)
    }
    if (na == 1) {
      if (isS4(..1)) {
        r <- cbind2(..1)
        if (length(dim(..1)) < 2 && length(dim(r)) == 2) 
          colnames(r) <- Nms(1)
        return(r)
      }
      else return(base::cbind(..., deparse.level = deparse.level))
    }
    if (na == 2) {
      fix.na <- FALSE
    }
    else {
      nrs <- unname(lapply(argl, nrow))
      iV <- vapply(nrs, is.null, NA)
      fix.na <- identical(nrs[(na - 1):na], list(NULL, NULL))
      if (fix.na) {
        nr <- max(if (all(iV)) lengths(argl) else unlist(nrs[!iV]))
        argl[[na]] <- cbind(rep(argl[[na]], length.out = nr), deparse.level = 0)
      }
      if (fix.na) 
        fix.na <- !is.null(Nna <- Nms(na))
    }
    Ncol <- function(x) {
      d <- dim(x)
      if (length(d) == 2) 
        d[2]
      else as.integer(length(x) > 0)
    }
    setN <- function(i, nams) colnames(r)[i] <<- if (is.null(nams)) 
      ""
    else nams
    r <- argl[[na]]
    for (i in (na - 1):1) {
      d2 <- dim(r)
      r <- cbind2(argl[[i]], r)
      ism1 <- !is.null(d1 <- dim(argl[[i]])) && length(d1) == 2
      ism2 <- !is.null(d2) && length(d2) == 2
      if (ism1 && ism2) 
        next
      nn1 <- !is.null(N1 <- if ((l1 <- Ncol(argl[[i]])) && !ism1) Nms(i))
      nn2 <- !is.null(N2 <- if (i == na - 1 && Ncol(argl[[na]]) && !ism2) Nms(na))
      if (nn1 || nn2) {
        if (is.null(colnames(r))) 
          colnames(r) <- rep.int("", ncol(r))
        if (nn1) 
          setN(1, N1)
        if (nn2) 
          setN(1 + l1, N2)
      }
    }
    if (fix.na) {
      if (is.null(colnames(r))) 
        colnames(r) <- rep.int("", ncol(r))
      setN(ncol(r), Nna)
    }
    r
  }, function (..., deparse.level = 1) 
    .Internal(cbind(deparse.level, ...)))
c("package:base", "namespace:methods", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
cbind.data.frame
list(`package:base` = function (..., deparse.level = 1) 
  data.frame(..., check.names = FALSE), function (..., deparse.level = 1) 
    data.frame(..., check.names = FALSE), function (..., deparse.level = 1) 
      data.frame(..., check.names = FALSE))
c("package:base", "registered S3 method for cbind from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
ceiling
list(`package:base` = .Primitive("ceiling"), .Primitive("ceiling"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
char.expand
list(`package:base` = function (input, target, nomatch = stop("no match")) 
{
  if (length(input) != 1) 
    stop("'input' must have length 1")
  if (!(is.character(input) && is.character(target))) 
    stop("'input' and 'target' must be character vectors")
  y <- .Internal(charmatch(input, target, NA))
  if (anyNA(y)) 
    eval(nomatch)
  target[y]
}, function (input, target, nomatch = stop("no match")) 
{
  if (length(input) != 1) 
    stop("'input' must have length 1")
  if (!(is.character(input) && is.character(target))) 
    stop("'input' and 'target' must be character vectors")
  y <- .Internal(charmatch(input, target, NA))
  if (anyNA(y)) 
    eval(nomatch)
  target[y]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
character
list(`package:base` = function (length = 0) 
  .Internal(vector("character", length)), function (length = 0) 
    .Internal(vector("character", length)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
charmatch
list(`package:base` = function (x, table, nomatch = NA) 
  .Internal(charmatch(as.character(x), as.character(table), nomatch)), function (x, table, nomatch = NA) 
    .Internal(charmatch(as.character(x), as.character(table), nomatch)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
charToRaw
list(`package:base` = function (x) 
  .Internal(charToRaw(x)), function (x) 
    .Internal(charToRaw(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
chartr
list(`package:base` = function (old, new, x) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(chartr(old, new, x))
}, function (old, new, x) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(chartr(old, new, x))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_tzones
list(`package:base` = function (...) 
{
  tzs <- unique(sapply(list(...), function(x) {
    y <- attr(x, "tzone")
    if (is.null(y)) 
      ""
    else y[1]
  }))
  tzs <- tzs[nzchar(tzs)]
  if (length(tzs) > 1) 
    warning("'tzone' attributes are inconsistent")
  if (length(tzs)) 
    tzs[1]
  else NULL
}, function (...) 
{
  tzs <- unique(sapply(list(...), function(x) {
    y <- attr(x, "tzone")
    if (is.null(y)) 
      ""
    else y[1]
  }))
  tzs <- tzs[nzchar(tzs)]
  if (length(tzs) > 1) 
    warning("'tzone' attributes are inconsistent")
  if (length(tzs)) 
    tzs[1]
  else NULL
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
chkDots
list(`package:base` = function (..., which.call = -1, allowed = character(0)) 
{
  if (nx <- ...length()) 
    warning(sprintf(ngettext(nx, "In %s :\n extra argument %s will be disregarded", "In %s :\n extra arguments %s will be disregarded"), paste(deparse(sys.call(which.call), control = c()), collapse = "\n"), paste(sQuote(...names()), collapse = ", ")), call. = FALSE, domain = NA)
}, function (..., which.call = -1, allowed = character(0)) 
{
  if (nx <- ...length()) 
    warning(sprintf(ngettext(nx, "In %s :\n extra argument %s will be disregarded", "In %s :\n extra arguments %s will be disregarded"), paste(deparse(sys.call(which.call), control = c()), collapse = "\n"), paste(sQuote(...names()), collapse = ", ")), call. = FALSE, domain = NA)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
chol
list(`package:base` = function (x, ...) 
  UseMethod("chol"), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("chol"), generic = "chol", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
      UseMethod("chol"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "chol"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("chol"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "chol"))(x, ...)), function (x, ...) 
          UseMethod("chol"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
chol.default
list(`package:base` = function (x, pivot = FALSE, LINPACK = FALSE, tol = -1, ...) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  if (is.complex(x)) 
    stop("complex matrices not permitted at present")
  .Internal(La_chol(as.matrix(x), pivot, tol))
}, function (x, pivot = FALSE, LINPACK = FALSE, tol = -1, ...) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  if (is.complex(x)) 
    stop("complex matrices not permitted at present")
  .Internal(La_chol(as.matrix(x), pivot, tol))
}, function (x, pivot = FALSE, LINPACK = FALSE, tol = -1, ...) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  if (is.complex(x)) 
    stop("complex matrices not permitted at present")
  .Internal(La_chol(as.matrix(x), pivot, tol))
})
c("package:base", "registered S3 method for chol from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
chol2inv
list(`package:base` = function (x, size = NCOL(x), LINPACK = FALSE) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  .Internal(La_chol2inv(x, size))
}, new("standardGeneric", .Data = function (x, ...) 
  standardGeneric("chol2inv"), generic = "chol2inv", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
    base::chol2inv(x, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "chol2inv"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
      base::chol2inv(x, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "chol2inv"))(x, ...)), function (x, size = NCOL(x), LINPACK = FALSE) 
      {
        if (!missing(LINPACK)) 
          stop("the LINPACK argument has been defunct since R 3.1.0")
        .Internal(La_chol2inv(x, size))
      })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
choose
list(`package:base` = function (n, k) 
  .Internal(choose(n, k)), function (n, k) 
    .Internal(choose(n, k)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
class
list(`package:base` = .Primitive("class"), .Primitive("class"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
class<-
  list(`package:base` = .Primitive("class<-"), .Primitive("class<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
clearPushBack
list(`package:base` = function (connection) 
  .Internal(clearPushBack(connection)), function (connection) 
    .Internal(clearPushBack(connection)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
close
list(`package:base` = function (con, ...) 
  UseMethod("close"), function (con, ...) 
    UseMethod("close"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
close.connection
list(`package:base` = function (con, type = "rw", ...) 
  .Internal(close(con, type)), function (con, type = "rw", ...) 
    .Internal(close(con, type)), function (con, type = "rw", ...) 
      .Internal(close(con, type)))
c("package:base", "registered S3 method for close from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
close.srcfile
list(`package:base` = function (con, ...) 
{
  srcfile <- con
  conn <- srcfile$conn
  if (is.null(conn)) 
    return()
  else {
    close(conn)
    rm(list = c("conn", "line"), envir = srcfile)
  }
}, function (con, ...) 
{
  srcfile <- con
  conn <- srcfile$conn
  if (is.null(conn)) 
    return()
  else {
    close(conn)
    rm(list = c("conn", "line"), envir = srcfile)
  }
}, function (con, ...) 
{
  srcfile <- con
  conn <- srcfile$conn
  if (is.null(conn)) 
    return()
  else {
    close(conn)
    rm(list = c("conn", "line"), envir = srcfile)
  }
})
c("package:base", "registered S3 method for close from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
close.srcfilealias
list(`package:base` = function (con, ...) 
  close(con$original, ...), function (con, ...) 
    close(con$original, ...), function (con, ...) 
      close(con$original, ...))
c("package:base", "registered S3 method for close from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
closeAllConnections
list(`package:base` = function () 
{
  i <- sink.number(type = "message")
  if (i > 0) 
    sink(stderr(), type = "message")
  n <- sink.number()
  if (n > 0) 
    for (i in seq_len(n)) sink()
  gc()
  set <- getAllConnections()
  set <- set[set > 2]
  for (i in seq_along(set)) close(getConnection(set[i]))
  invisible()
}, function () 
{
  i <- sink.number(type = "message")
  if (i > 0) 
    sink(stderr(), type = "message")
  n <- sink.number()
  if (n > 0) 
    for (i in seq_len(n)) sink()
  gc()
  set <- getAllConnections()
  set <- set[set > 2]
  for (i in seq_along(set)) close(getConnection(set[i]))
  invisible()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
col
list(`package:base` = function (x, as.factor = FALSE) 
{
  if (as.factor) {
    labs <- colnames(x, do.NULL = FALSE, prefix = "")
    res <- factor(.Internal(col(dim(x))), labels = labs)
    dim(res) <- dim(x)
    res
  }
  else .Internal(col(dim(x)))
}, function (x, as.factor = FALSE) 
{
  if (as.factor) {
    labs <- colnames(x, do.NULL = FALSE, prefix = "")
    res <- factor(.Internal(col(dim(x))), labels = labs)
    dim(res) <- dim(x)
    res
  }
  else .Internal(col(dim(x)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
colMeans
list(`package:base` = function (x, na.rm = FALSE, dims = 1) 
{
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (!is.array(x) || length(dn <- dim(x)) < 2) 
    stop("'x' must be an array of at least two dimensions")
  if (dims < 1 || dims > length(dn) - 1) 
    stop("invalid 'dims'")
  n <- prod(dn[id <- seq_len(dims)])
  dn <- dn[-id]
  z <- if (is.complex(x)) 
    .Internal(colMeans(Re(x), n, prod(dn), na.rm)) + (0+1i) * .Internal(colMeans(Im(x), n, prod(dn), na.rm))
  else .Internal(colMeans(x, n, prod(dn), na.rm))
  if (length(dn) > 1) {
    dim(z) <- dn
    dimnames(z) <- dimnames(x)[-id]
  }
  else names(z) <- dimnames(x)[[dims + 1]]
  z
}, new("standardGeneric", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
  standardGeneric("colMeans"), generic = "colMeans", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
    base::colMeans(x, na.rm = na.rm, dims = dims, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "colMeans"), skeleton = (new("derivedDefaultMethod", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
      base::colMeans(x, na.rm = na.rm, dims = dims, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "colMeans"))(x, na.rm, dims, ...)), function (x, na.rm = FALSE, dims = 1) 
      {
        if (is.data.frame(x)) 
          x <- as.matrix(x)
        if (!is.array(x) || length(dn <- dim(x)) < 2) 
          stop("'x' must be an array of at least two dimensions")
        if (dims < 1 || dims > length(dn) - 1) 
          stop("invalid 'dims'")
        n <- prod(dn[id <- seq_len(dims)])
        dn <- dn[-id]
        z <- if (is.complex(x)) 
          .Internal(colMeans(Re(x), n, prod(dn), na.rm)) + (0+1i) * .Internal(colMeans(Im(x), n, prod(dn), na.rm))
        else .Internal(colMeans(x, n, prod(dn), na.rm))
        if (length(dn) > 1) {
          dim(z) <- dn
          dimnames(z) <- dimnames(x)[-id]
        }
        else names(z) <- dimnames(x)[[dims + 1]]
        z
      })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
colnames
list(`package:base` = function (x, do.NULL = TRUE, prefix = "col") 
{
  if (is.data.frame(x) && do.NULL) 
    return(names(x))
  dn <- dimnames(x)
  if (!is.null(dn[[2]])) 
    dn[[2]]
  else {
    nc <- NCOL(x)
    if (do.NULL) 
      NULL
    else if (nc > 0) 
      paste0(prefix, seq_len(nc))
    else character()
  }
}, function (x, do.NULL = TRUE, prefix = "col") 
{
  if (is.data.frame(x) && do.NULL) 
    return(names(x))
  dn <- dimnames(x)
  if (!is.null(dn[[2]])) 
    dn[[2]]
  else {
    nc <- NCOL(x)
    if (do.NULL) 
      NULL
    else if (nc > 0) 
      paste0(prefix, seq_len(nc))
    else character()
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
colnames<-
  list(`package:base` = function (x, value) 
  {
    if (is.data.frame(x)) {
      names(x) <- value
    }
    else {
      dn <- dimnames(x)
      if (is.null(dn)) {
        if (is.null(value)) 
          return(x)
        if ((nd <- length(dim(x))) < 2) 
          stop("attempt to set 'colnames' on an object with less than two dimensions")
        dn <- vector("list", nd)
      }
      if (length(dn) < 2) 
        stop("attempt to set 'colnames' on an object with less than two dimensions")
      if (is.null(value)) 
        dn[2] <- list(NULL)
      else dn[[2]] <- value
      dimnames(x) <- dn
    }
    x
  }, function (x, value) 
  {
    if (is.data.frame(x)) {
      names(x) <- value
    }
    else {
      dn <- dimnames(x)
      if (is.null(dn)) {
        if (is.null(value)) 
          return(x)
        if ((nd <- length(dim(x))) < 2) 
          stop("attempt to set 'colnames' on an object with less than two dimensions")
        dn <- vector("list", nd)
      }
      if (length(dn) < 2) 
        stop("attempt to set 'colnames' on an object with less than two dimensions")
      if (is.null(value)) 
        dn[2] <- list(NULL)
      else dn[[2]] <- value
      dimnames(x) <- dn
    }
    x
  })
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
colSums
list(`package:base` = function (x, na.rm = FALSE, dims = 1) 
{
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (!is.array(x) || length(dn <- dim(x)) < 2) 
    stop("'x' must be an array of at least two dimensions")
  if (dims < 1 || dims > length(dn) - 1) 
    stop("invalid 'dims'")
  n <- prod(dn[id <- seq_len(dims)])
  dn <- dn[-id]
  z <- if (is.complex(x)) 
    .Internal(colSums(Re(x), n, prod(dn), na.rm)) + (0+1i) * .Internal(colSums(Im(x), n, prod(dn), na.rm))
  else .Internal(colSums(x, n, prod(dn), na.rm))
  if (length(dn) > 1) {
    dim(z) <- dn
    dimnames(z) <- dimnames(x)[-id]
  }
  else names(z) <- dimnames(x)[[dims + 1]]
  z
}, new("standardGeneric", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
  standardGeneric("colSums"), generic = "colSums", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
    base::colSums(x, na.rm = na.rm, dims = dims, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "colSums"), skeleton = (new("derivedDefaultMethod", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
      base::colSums(x, na.rm = na.rm, dims = dims, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "colSums"))(x, na.rm, dims, ...)), function (x, na.rm = FALSE, dims = 1) 
      {
        if (is.data.frame(x)) 
          x <- as.matrix(x)
        if (!is.array(x) || length(dn <- dim(x)) < 2) 
          stop("'x' must be an array of at least two dimensions")
        if (dims < 1 || dims > length(dn) - 1) 
          stop("invalid 'dims'")
        n <- prod(dn[id <- seq_len(dims)])
        dn <- dn[-id]
        z <- if (is.complex(x)) 
          .Internal(colSums(Re(x), n, prod(dn), na.rm)) + (0+1i) * .Internal(colSums(Im(x), n, prod(dn), na.rm))
        else .Internal(colSums(x, n, prod(dn), na.rm))
        if (length(dn) > 1) {
          dim(z) <- dn
          dimnames(z) <- dimnames(x)[-id]
        }
        else names(z) <- dimnames(x)[[dims + 1]]
        z
      })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
commandArgs
list(`package:base` = function (trailingOnly = FALSE) 
{
  args <- .Internal(commandArgs())
  if (trailingOnly) {
    m <- match("--args", args, 0)
    if (m) 
      args[-seq_len(m)]
    else character()
  }
  else args
}, function (trailingOnly = FALSE) 
{
  args <- .Internal(commandArgs())
  if (trailingOnly) {
    m <- match("--args", args, 0)
    if (m) 
      args[-seq_len(m)]
    else character()
  }
  else args
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
comment
list(`package:base` = function (x) 
  .Internal(comment(x)), function (x) 
    .Internal(comment(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
comment<-
  list(`package:base` = function (x, value) 
    .Internal(`comment<-`(x, value)), function (x, value) 
      .Internal(`comment<-`(x, value)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
complex
list(`package:base` = function (length.out = 0, real = numeric(), imaginary = numeric(), modulus = 1, argument = 0) 
{
  if (missing(modulus) && missing(argument)) {
    .Internal(complex(length.out, real, imaginary))
  }
  else {
    n <- max(length.out, length(argument), length(modulus))
    rep_len(modulus, n) * exp((0+1i) * rep_len(argument, n))
  }
}, function (length.out = 0, real = numeric(), imaginary = numeric(), modulus = 1, argument = 0) 
{
  if (missing(modulus) && missing(argument)) {
    .Internal(complex(length.out, real, imaginary))
  }
  else {
    n <- max(length.out, length(argument), length(modulus))
    rep_len(modulus, n) * exp((0+1i) * rep_len(argument, n))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
computeRestarts
list(`package:base` = function (cond = NULL) 
{
  val <- NULL
  i <- 1
  repeat {
    r <- .Internal(.getRestart(i))
    if (is.null(r)) 
      return(val)
    else if (is.null(cond) || is.null(r$test) || r$test(cond)) 
      val <- c(val, list(r))
    i <- i + 1
  }
}, function (cond = NULL) 
{
  val <- NULL
  i <- 1
  repeat {
    r <- .Internal(.getRestart(i))
    if (is.null(r)) 
      return(val)
    else if (is.null(cond) || is.null(r$test) || r$test(cond)) 
      val <- c(val, list(r))
    i <- i + 1
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
conditionCall
list(`package:base` = function (c) 
  UseMethod("conditionCall"), function (c) 
    UseMethod("conditionCall"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
conditionCall.condition
list(`package:base` = function (c) 
  c$call, function (c) 
    c$call, function (c) 
      c$call)
c("package:base", "registered S3 method for conditionCall from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
conditionMessage
list(`package:base` = function (c) 
  UseMethod("conditionMessage"), function (c) 
    UseMethod("conditionMessage"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
conditionMessage.condition
list(`package:base` = function (c) 
  c$message, function (c) 
    c$message, function (c) 
      c$message)
c("package:base", "registered S3 method for conditionMessage from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
conflictRules
list(`package:base` = function (pkg, mask.ok = NULL, exclude = NULL) 
{
  if ((!missing(mask.ok)) || (!missing(exclude))) 
    assign(pkg, list(mask.ok = mask.ok, exclude = exclude), envir = data)
  else get0(pkg, envir = data, inherits = FALSE)
}, function (pkg, mask.ok = NULL, exclude = NULL) 
{
  if ((!missing(mask.ok)) || (!missing(exclude))) 
    assign(pkg, list(mask.ok = mask.ok, exclude = exclude), envir = data)
  else get0(pkg, envir = data, inherits = FALSE)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
conflicts
list(`package:base` = function (where = search(), detail = FALSE) 
{
  if (length(where) < 1) 
    stop("argument 'where' of length 0")
  z <- vector(length(where), mode = "list")
  names(z) <- where
  for (i in seq_along(where)) z[[i]] <- objects(pos = where[i])
  all <- unlist(z, use.names = FALSE)
  dups <- duplicated(all)
  dups <- all[dups]
  if (detail) {
    for (i in where) z[[i]] <- z[[i]][match(dups, z[[i]], 0)]
    z[vapply(z, function(x) length(x) == 0, NA)] <- NULL
    z
  }
  else dups
}, function (where = search(), detail = FALSE) 
{
  if (length(where) < 1) 
    stop("argument 'where' of length 0")
  z <- vector(length(where), mode = "list")
  names(z) <- where
  for (i in seq_along(where)) z[[i]] <- objects(pos = where[i])
  all <- unlist(z, use.names = FALSE)
  dups <- duplicated(all)
  dups <- all[dups]
  if (detail) {
    for (i in where) z[[i]] <- z[[i]][match(dups, z[[i]], 0)]
    z[vapply(z, function(x) length(x) == 0, NA)] <- NULL
    z
  }
  else dups
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Conj
list(`package:base` = .Primitive("Conj"), .Primitive("Conj"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
contributors
list(`package:base` = function () 
{
  outFile <- tempfile()
  outConn <- file(outFile, open = "w")
  writeLines(paste0("R is a project which is attempting to provide a ", "modern piece of\nstatistical software for the ", "GNU suite of software.\n\n", "The current R is the result of a collaborative ", "effort with\ncontributions from all over the ", "world.\n\n"), outConn)
  writeLines(readLines(file.path(R.home("doc"), "AUTHORS")), outConn)
  writeLines("", outConn)
  writeLines(readLines(file.path(R.home("doc"), "THANKS")), outConn)
  close(outConn)
  file.show(outFile, delete.file = TRUE)
}, function () 
{
  outFile <- tempfile()
  outConn <- file(outFile, open = "w")
  writeLines(paste0("R is a project which is attempting to provide a ", "modern piece of\nstatistical software for the ", "GNU suite of software.\n\n", "The current R is the result of a collaborative ", "effort with\ncontributions from all over the ", "world.\n\n"), outConn)
  writeLines(readLines(file.path(R.home("doc"), "AUTHORS")), outConn)
  writeLines("", outConn)
  writeLines(readLines(file.path(R.home("doc"), "THANKS")), outConn)
  close(outConn)
  file.show(outFile, delete.file = TRUE)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cos
list(`package:base` = .Primitive("cos"), .Primitive("cos"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cosh
list(`package:base` = .Primitive("cosh"), .Primitive("cosh"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cospi
list(`package:base` = .Primitive("cospi"), .Primitive("cospi"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
crossprod
list(`package:base` = function (x, y = NULL) 
  .Internal(crossprod(x, y)), new("standardGeneric", .Data = function (x, y = NULL, ...) 
    standardGeneric("crossprod"), generic = "crossprod", package = "base", group = list(), valueClass = character(0), signature = c("x", "y"), default = new("derivedDefaultMethod", .Data = function (x, y = NULL, ...) 
      base::crossprod(x, y), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "crossprod"), skeleton = (new("derivedDefaultMethod", .Data = function (x, y = NULL, ...) 
        base::crossprod(x, y), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "crossprod"))(x, y, ...)), function (x, y = NULL) 
          .Internal(crossprod(x, y)))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
Cstack_info
list(`package:base` = function () 
  .Internal(Cstack_info()), function () 
    .Internal(Cstack_info()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cummax
list(`package:base` = .Primitive("cummax"), .Primitive("cummax"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cummin
list(`package:base` = .Primitive("cummin"), .Primitive("cummin"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cumprod
list(`package:base` = .Primitive("cumprod"), .Primitive("cumprod"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cumsum
list(`package:base` = .Primitive("cumsum"), .Primitive("cumsum"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
curlGetHeaders
list(`package:base` = function (url, redirect = TRUE, verify = TRUE, timeout = 0, TLS = "") 
  .Internal(curlGetHeaders(url, redirect, verify, timeout, as.character(TLS))), function (url, redirect = TRUE, verify = TRUE, timeout = 0, TLS = "") 
    .Internal(curlGetHeaders(url, redirect, verify, timeout, as.character(TLS))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cut
list(`package:base` = function (x, ...) 
  UseMethod("cut"), function (x, ...) 
    UseMethod("cut"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
cut.Date
list(`package:base` = function (x, breaks, labels = NULL, start.on.monday = TRUE, right = FALSE, ...) 
{
  if (!inherits(x, "Date")) 
    stop("'x' must be a date-time object")
  x <- as.Date(x)
  if (inherits(breaks, "Date")) {
    breaks <- sort(as.Date(breaks))
  }
  else if (is.numeric(breaks) && length(breaks) == 1) {
  }
  else if (is.character(breaks) && length(breaks) == 1) {
    by2 <- strsplit(breaks, " ", fixed = TRUE)[[1]]
    if (length(by2) > 2 || length(by2) < 1) 
      stop("invalid specification of 'breaks'")
    valid <- pmatch(by2[length(by2)], c("days", "weeks", "months", "years", "quarters"))
    if (is.na(valid)) 
      stop("invalid specification of 'breaks'")
    start <- as.POSIXlt(min(x, na.rm = TRUE))
    if (valid == 1) 
      incr <- 1
    if (valid == 2) {
      start$mday <- start$mday - start$wday
      if (start.on.monday) 
        start$mday <- start$mday + ifelse(start$wday > 0, 1, -6)
      start$isdst <- -1
      incr <- 7
    }
    if (valid == 3) {
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (31 * step * 86400))
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, breaks))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 4) {
      start$mon <- 0
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (366 * step * 86400))
      end$mon <- 0
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, breaks))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 5) {
      qtr <- rep(c(0, 3, 6, 9), each = 3)
      start$mon <- qtr[start$mon + 1]
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (93 * step * 86400))
      end$mon <- qtr[end$mon + 1]
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, paste(step * 3, "months")))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else {
      start <- as.Date(start)
      if (length(by2) == 2) 
        incr <- incr * as.integer(by2[1])
      maxx <- max(x, na.rm = TRUE)
      breaks <- seq(start, maxx + incr, breaks)
      breaks <- breaks[seq_len(1 + max(which(breaks <= maxx)))]
    }
  }
  else stop("invalid specification of 'breaks'")
  res <- cut(unclass(x), unclass(breaks), labels = labels, right = right, ...)
  if (is.null(labels)) {
    levels(res) <- as.character(if (is.numeric(breaks)) x[!duplicated(res)] else breaks[-length(breaks)])
  }
  res
}, function (x, breaks, labels = NULL, start.on.monday = TRUE, right = FALSE, ...) 
{
  if (!inherits(x, "Date")) 
    stop("'x' must be a date-time object")
  x <- as.Date(x)
  if (inherits(breaks, "Date")) {
    breaks <- sort(as.Date(breaks))
  }
  else if (is.numeric(breaks) && length(breaks) == 1) {
  }
  else if (is.character(breaks) && length(breaks) == 1) {
    by2 <- strsplit(breaks, " ", fixed = TRUE)[[1]]
    if (length(by2) > 2 || length(by2) < 1) 
      stop("invalid specification of 'breaks'")
    valid <- pmatch(by2[length(by2)], c("days", "weeks", "months", "years", "quarters"))
    if (is.na(valid)) 
      stop("invalid specification of 'breaks'")
    start <- as.POSIXlt(min(x, na.rm = TRUE))
    if (valid == 1) 
      incr <- 1
    if (valid == 2) {
      start$mday <- start$mday - start$wday
      if (start.on.monday) 
        start$mday <- start$mday + ifelse(start$wday > 0, 1, -6)
      start$isdst <- -1
      incr <- 7
    }
    if (valid == 3) {
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (31 * step * 86400))
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, breaks))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 4) {
      start$mon <- 0
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (366 * step * 86400))
      end$mon <- 0
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, breaks))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 5) {
      qtr <- rep(c(0, 3, 6, 9), each = 3)
      start$mon <- qtr[start$mon + 1]
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (93 * step * 86400))
      end$mon <- qtr[end$mon + 1]
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, paste(step * 3, "months")))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else {
      start <- as.Date(start)
      if (length(by2) == 2) 
        incr <- incr * as.integer(by2[1])
      maxx <- max(x, na.rm = TRUE)
      breaks <- seq(start, maxx + incr, breaks)
      breaks <- breaks[seq_len(1 + max(which(breaks <= maxx)))]
    }
  }
  else stop("invalid specification of 'breaks'")
  res <- cut(unclass(x), unclass(breaks), labels = labels, right = right, ...)
  if (is.null(labels)) {
    levels(res) <- as.character(if (is.numeric(breaks)) x[!duplicated(res)] else breaks[-length(breaks)])
  }
  res
}, function (x, breaks, labels = NULL, start.on.monday = TRUE, right = FALSE, ...) 
{
  if (!inherits(x, "Date")) 
    stop("'x' must be a date-time object")
  x <- as.Date(x)
  if (inherits(breaks, "Date")) {
    breaks <- sort(as.Date(breaks))
  }
  else if (is.numeric(breaks) && length(breaks) == 1) {
  }
  else if (is.character(breaks) && length(breaks) == 1) {
    by2 <- strsplit(breaks, " ", fixed = TRUE)[[1]]
    if (length(by2) > 2 || length(by2) < 1) 
      stop("invalid specification of 'breaks'")
    valid <- pmatch(by2[length(by2)], c("days", "weeks", "months", "years", "quarters"))
    if (is.na(valid)) 
      stop("invalid specification of 'breaks'")
    start <- as.POSIXlt(min(x, na.rm = TRUE))
    if (valid == 1) 
      incr <- 1
    if (valid == 2) {
      start$mday <- start$mday - start$wday
      if (start.on.monday) 
        start$mday <- start$mday + ifelse(start$wday > 0, 1, -6)
      start$isdst <- -1
      incr <- 7
    }
    if (valid == 3) {
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (31 * step * 86400))
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, breaks))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 4) {
      start$mon <- 0
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (366 * step * 86400))
      end$mon <- 0
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, breaks))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 5) {
      qtr <- rep(c(0, 3, 6, 9), each = 3)
      start$mon <- qtr[start$mon + 1]
      start$mday <- 1
      start$isdst <- -1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (93 * step * 86400))
      end$mon <- qtr[end$mon + 1]
      end$mday <- 1
      end$isdst <- -1
      breaks <- as.Date(seq(start, end, paste(step * 3, "months")))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else {
      start <- as.Date(start)
      if (length(by2) == 2) 
        incr <- incr * as.integer(by2[1])
      maxx <- max(x, na.rm = TRUE)
      breaks <- seq(start, maxx + incr, breaks)
      breaks <- breaks[seq_len(1 + max(which(breaks <= maxx)))]
    }
  }
  else stop("invalid specification of 'breaks'")
  res <- cut(unclass(x), unclass(breaks), labels = labels, right = right, ...)
  if (is.null(labels)) {
    levels(res) <- as.character(if (is.numeric(breaks)) x[!duplicated(res)] else breaks[-length(breaks)])
  }
  res
})
c("package:base", "registered S3 method for cut from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
cut.default
list(`package:base` = function (x, breaks, labels = NULL, include.lowest = FALSE, right = TRUE, dig.lab = 3, ordered_result = FALSE, ...) 
{
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (length(breaks) == 1) {
    if (is.na(breaks) || breaks < 2) 
      stop("invalid number of intervals")
    nb <- as.integer(breaks + 1)
    dx <- diff(rx <- range(x, na.rm = TRUE))
    if (dx == 0) {
      dx <- if (rx[1] != 0) 
        abs(rx[1])
      else 1
      breaks <- seq.int(rx[1] - dx/1000, rx[2] + dx/1000, length.out = nb)
    }
    else {
      breaks <- seq.int(rx[1], rx[2], length.out = nb)
      breaks[c(1, nb)] <- c(rx[1] - dx/1000, rx[2] + dx/1000)
    }
  }
  else nb <- length(breaks <- sort.int(as.double(breaks)))
  if (anyDuplicated(breaks)) 
    stop("'breaks' are not unique")
  codes.only <- FALSE
  if (is.null(labels)) {
    for (dig in dig.lab:max(12, dig.lab)) {
      ch.br <- formatC(0 + breaks, digits = dig, width = 1)
      if (ok <- all(ch.br[-1] != ch.br[-nb])) 
        break
    }
    labels <- if (ok) 
      paste0(if (right) 
        "("
        else "[", ch.br[-nb], ",", ch.br[-1], if (right) 
          "]"
        else ")")
    else paste0("Range_", seq_len(nb - 1))
    if (ok && include.lowest) {
      if (right) 
        substr(labels[1], 1, 1) <- "["
      else substring(labels[nb - 1], nchar(labels[nb - 1], "c")) <- "]"
    }
  }
  else if (is.logical(labels) && !labels) 
    codes.only <- TRUE
  else if (length(labels) != nb - 1) 
    stop("lengths of 'breaks' and 'labels' differ")
  code <- .bincode(x, breaks, right, include.lowest)
  if (codes.only) 
    code
  else factor(code, seq_along(labels), labels, ordered = ordered_result)
}, function (x, breaks, labels = NULL, include.lowest = FALSE, right = TRUE, dig.lab = 3, ordered_result = FALSE, ...) 
{
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (length(breaks) == 1) {
    if (is.na(breaks) || breaks < 2) 
      stop("invalid number of intervals")
    nb <- as.integer(breaks + 1)
    dx <- diff(rx <- range(x, na.rm = TRUE))
    if (dx == 0) {
      dx <- if (rx[1] != 0) 
        abs(rx[1])
      else 1
      breaks <- seq.int(rx[1] - dx/1000, rx[2] + dx/1000, length.out = nb)
    }
    else {
      breaks <- seq.int(rx[1], rx[2], length.out = nb)
      breaks[c(1, nb)] <- c(rx[1] - dx/1000, rx[2] + dx/1000)
    }
  }
  else nb <- length(breaks <- sort.int(as.double(breaks)))
  if (anyDuplicated(breaks)) 
    stop("'breaks' are not unique")
  codes.only <- FALSE
  if (is.null(labels)) {
    for (dig in dig.lab:max(12, dig.lab)) {
      ch.br <- formatC(0 + breaks, digits = dig, width = 1)
      if (ok <- all(ch.br[-1] != ch.br[-nb])) 
        break
    }
    labels <- if (ok) 
      paste0(if (right) 
        "("
        else "[", ch.br[-nb], ",", ch.br[-1], if (right) 
          "]"
        else ")")
    else paste0("Range_", seq_len(nb - 1))
    if (ok && include.lowest) {
      if (right) 
        substr(labels[1], 1, 1) <- "["
      else substring(labels[nb - 1], nchar(labels[nb - 1], "c")) <- "]"
    }
  }
  else if (is.logical(labels) && !labels) 
    codes.only <- TRUE
  else if (length(labels) != nb - 1) 
    stop("lengths of 'breaks' and 'labels' differ")
  code <- .bincode(x, breaks, right, include.lowest)
  if (codes.only) 
    code
  else factor(code, seq_along(labels), labels, ordered = ordered_result)
}, function (x, breaks, labels = NULL, include.lowest = FALSE, right = TRUE, dig.lab = 3, ordered_result = FALSE, ...) 
{
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (length(breaks) == 1) {
    if (is.na(breaks) || breaks < 2) 
      stop("invalid number of intervals")
    nb <- as.integer(breaks + 1)
    dx <- diff(rx <- range(x, na.rm = TRUE))
    if (dx == 0) {
      dx <- if (rx[1] != 0) 
        abs(rx[1])
      else 1
      breaks <- seq.int(rx[1] - dx/1000, rx[2] + dx/1000, length.out = nb)
    }
    else {
      breaks <- seq.int(rx[1], rx[2], length.out = nb)
      breaks[c(1, nb)] <- c(rx[1] - dx/1000, rx[2] + dx/1000)
    }
  }
  else nb <- length(breaks <- sort.int(as.double(breaks)))
  if (anyDuplicated(breaks)) 
    stop("'breaks' are not unique")
  codes.only <- FALSE
  if (is.null(labels)) {
    for (dig in dig.lab:max(12, dig.lab)) {
      ch.br <- formatC(0 + breaks, digits = dig, width = 1)
      if (ok <- all(ch.br[-1] != ch.br[-nb])) 
        break
    }
    labels <- if (ok) 
      paste0(if (right) 
        "("
        else "[", ch.br[-nb], ",", ch.br[-1], if (right) 
          "]"
        else ")")
    else paste0("Range_", seq_len(nb - 1))
    if (ok && include.lowest) {
      if (right) 
        substr(labels[1], 1, 1) <- "["
      else substring(labels[nb - 1], nchar(labels[nb - 1], "c")) <- "]"
    }
  }
  else if (is.logical(labels) && !labels) 
    codes.only <- TRUE
  else if (length(labels) != nb - 1) 
    stop("lengths of 'breaks' and 'labels' differ")
  code <- .bincode(x, breaks, right, include.lowest)
  if (codes.only) 
    code
  else factor(code, seq_along(labels), labels, ordered = ordered_result)
})
c("package:base", "registered S3 method for cut from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
cut.POSIXt
list(`package:base` = function (x, breaks, labels = NULL, start.on.monday = TRUE, right = FALSE, ...) 
{
  if (!inherits(x, "POSIXt")) 
    stop("'x' must be a date-time object")
  x <- as.POSIXct(x)
  if (inherits(breaks, "POSIXt")) {
    breaks <- sort(as.POSIXct(breaks))
  }
  else if (is.numeric(breaks) && length(breaks) == 1) {
  }
  else if (is.character(breaks) && length(breaks) == 1) {
    by2 <- strsplit(breaks, " ", fixed = TRUE)[[1]]
    if (length(by2) > 2 || length(by2) < 1) 
      stop("invalid specification of 'breaks'")
    valid <- pmatch(by2[length(by2)], c("secs", "mins", "hours", "days", "weeks", "months", "years", "DSTdays", "quarters"))
    if (is.na(valid)) 
      stop("invalid specification of 'breaks'")
    start <- as.POSIXlt(min(x, na.rm = TRUE))
    incr <- 1
    if (valid > 1) {
      start$sec <- 0
      incr <- 60
    }
    if (valid > 2) {
      start$min <- 0
      incr <- 3600
    }
    if (valid > 3) {
      start$hour <- 0
      start$isdst <- -1
      incr <- 86400
    }
    if (valid == 5) {
      start$mday <- start$mday - start$wday
      if (start.on.monday) 
        start$mday <- start$mday + ifelse(start$wday > 0, 1, -6)
      incr <- 7 * 86400
    }
    if (valid == 8) 
      incr <- 25 * 3600
    if (valid == 6) {
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (31 * step * 86400))
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, breaks)
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 7) {
      start$mon <- 0
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (366 * step * 86400))
      end$mon <- 0
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, breaks)
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 9) {
      qtr <- rep(c(0, 3, 6, 9), each = 3)
      start$mon <- qtr[start$mon + 1]
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (93 * step * 86400))
      end$mon <- qtr[end$mon + 1]
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, paste(step * 3, "months"))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else {
      if (length(by2) == 2) 
        incr <- incr * as.integer(by2[1])
      maxx <- max(x, na.rm = TRUE)
      breaks <- seq(start, maxx + incr, breaks)
      breaks <- breaks[seq_len(1 + max(which(breaks <= maxx)))]
    }
  }
  else stop("invalid specification of 'breaks'")
  res <- cut(unclass(x), unclass(breaks), labels = labels, right = right, ...)
  if (is.null(labels)) {
    levels(res) <- as.character(if (is.numeric(breaks)) x[!duplicated(res)] else breaks[-length(breaks)])
  }
  res
}, function (x, breaks, labels = NULL, start.on.monday = TRUE, right = FALSE, ...) 
{
  if (!inherits(x, "POSIXt")) 
    stop("'x' must be a date-time object")
  x <- as.POSIXct(x)
  if (inherits(breaks, "POSIXt")) {
    breaks <- sort(as.POSIXct(breaks))
  }
  else if (is.numeric(breaks) && length(breaks) == 1) {
  }
  else if (is.character(breaks) && length(breaks) == 1) {
    by2 <- strsplit(breaks, " ", fixed = TRUE)[[1]]
    if (length(by2) > 2 || length(by2) < 1) 
      stop("invalid specification of 'breaks'")
    valid <- pmatch(by2[length(by2)], c("secs", "mins", "hours", "days", "weeks", "months", "years", "DSTdays", "quarters"))
    if (is.na(valid)) 
      stop("invalid specification of 'breaks'")
    start <- as.POSIXlt(min(x, na.rm = TRUE))
    incr <- 1
    if (valid > 1) {
      start$sec <- 0
      incr <- 60
    }
    if (valid > 2) {
      start$min <- 0
      incr <- 3600
    }
    if (valid > 3) {
      start$hour <- 0
      start$isdst <- -1
      incr <- 86400
    }
    if (valid == 5) {
      start$mday <- start$mday - start$wday
      if (start.on.monday) 
        start$mday <- start$mday + ifelse(start$wday > 0, 1, -6)
      incr <- 7 * 86400
    }
    if (valid == 8) 
      incr <- 25 * 3600
    if (valid == 6) {
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (31 * step * 86400))
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, breaks)
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 7) {
      start$mon <- 0
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (366 * step * 86400))
      end$mon <- 0
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, breaks)
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 9) {
      qtr <- rep(c(0, 3, 6, 9), each = 3)
      start$mon <- qtr[start$mon + 1]
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (93 * step * 86400))
      end$mon <- qtr[end$mon + 1]
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, paste(step * 3, "months"))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else {
      if (length(by2) == 2) 
        incr <- incr * as.integer(by2[1])
      maxx <- max(x, na.rm = TRUE)
      breaks <- seq(start, maxx + incr, breaks)
      breaks <- breaks[seq_len(1 + max(which(breaks <= maxx)))]
    }
  }
  else stop("invalid specification of 'breaks'")
  res <- cut(unclass(x), unclass(breaks), labels = labels, right = right, ...)
  if (is.null(labels)) {
    levels(res) <- as.character(if (is.numeric(breaks)) x[!duplicated(res)] else breaks[-length(breaks)])
  }
  res
}, function (x, breaks, labels = NULL, start.on.monday = TRUE, right = FALSE, ...) 
{
  if (!inherits(x, "POSIXt")) 
    stop("'x' must be a date-time object")
  x <- as.POSIXct(x)
  if (inherits(breaks, "POSIXt")) {
    breaks <- sort(as.POSIXct(breaks))
  }
  else if (is.numeric(breaks) && length(breaks) == 1) {
  }
  else if (is.character(breaks) && length(breaks) == 1) {
    by2 <- strsplit(breaks, " ", fixed = TRUE)[[1]]
    if (length(by2) > 2 || length(by2) < 1) 
      stop("invalid specification of 'breaks'")
    valid <- pmatch(by2[length(by2)], c("secs", "mins", "hours", "days", "weeks", "months", "years", "DSTdays", "quarters"))
    if (is.na(valid)) 
      stop("invalid specification of 'breaks'")
    start <- as.POSIXlt(min(x, na.rm = TRUE))
    incr <- 1
    if (valid > 1) {
      start$sec <- 0
      incr <- 60
    }
    if (valid > 2) {
      start$min <- 0
      incr <- 3600
    }
    if (valid > 3) {
      start$hour <- 0
      start$isdst <- -1
      incr <- 86400
    }
    if (valid == 5) {
      start$mday <- start$mday - start$wday
      if (start.on.monday) 
        start$mday <- start$mday + ifelse(start$wday > 0, 1, -6)
      incr <- 7 * 86400
    }
    if (valid == 8) 
      incr <- 25 * 3600
    if (valid == 6) {
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (31 * step * 86400))
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, breaks)
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 7) {
      start$mon <- 0
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (366 * step * 86400))
      end$mon <- 0
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, breaks)
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else if (valid == 9) {
      qtr <- rep(c(0, 3, 6, 9), each = 3)
      start$mon <- qtr[start$mon + 1]
      start$mday <- 1
      maxx <- max(x, na.rm = TRUE)
      end <- as.POSIXlt(maxx)
      step <- if (length(by2) == 2) 
        as.integer(by2[1])
      else 1
      end <- as.POSIXlt(end + (93 * step * 86400))
      end$mon <- qtr[end$mon + 1]
      end$mday <- 1
      end$isdst <- -1
      breaks <- seq(start, end, paste(step * 3, "months"))
      lb <- length(breaks)
      if (maxx < breaks[lb - 1]) 
        breaks <- breaks[-lb]
    }
    else {
      if (length(by2) == 2) 
        incr <- incr * as.integer(by2[1])
      maxx <- max(x, na.rm = TRUE)
      breaks <- seq(start, maxx + incr, breaks)
      breaks <- breaks[seq_len(1 + max(which(breaks <= maxx)))]
    }
  }
  else stop("invalid specification of 'breaks'")
  res <- cut(unclass(x), unclass(breaks), labels = labels, right = right, ...)
  if (is.null(labels)) {
    levels(res) <- as.character(if (is.numeric(breaks)) x[!duplicated(res)] else breaks[-length(breaks)])
  }
  res
})
c("package:base", "registered S3 method for cut from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
data.class
list(`package:base` = function (x) 
{
  if (length(cl <- oldClass(x))) 
    cl[1]
  else {
    l <- length(dim(x))
    if (l == 2) 
      "matrix"
    else if (l) 
      "array"
    else mode(x)
  }
}, function (x) 
{
  if (length(cl <- oldClass(x))) 
    cl[1]
  else {
    l <- length(dim(x))
    if (l == 2) 
      "matrix"
    else if (l) 
      "array"
    else mode(x)
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
data.frame
list(`package:base` = function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, fix.empty.names = TRUE, stringsAsFactors = FALSE) 
{
  data.row.names <- if (check.rows && is.null(row.names)) 
    function(current, new, i) {
      if (is.character(current)) 
        new <- as.character(new)
      if (is.character(new)) 
        current <- as.character(current)
      if (anyDuplicated(new)) 
        return(current)
      if (is.null(current)) 
        return(new)
      if (all(current == new) || all(current == "")) 
        return(new)
      stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
    }
  else function(current, new, i) {
    if (is.null(current)) {
      if (anyDuplicated(new)) {
        warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
        current
      }
      else new
    }
    else current
  }
  object <- as.list(substitute(list(...)))[-1]
  mirn <- missing(row.names)
  mrn <- is.null(row.names)
  x <- list(...)
  n <- length(x)
  if (n < 1) {
    if (!mrn) {
      if (is.object(row.names) || !is.integer(row.names)) 
        row.names <- as.character(row.names)
      if (anyNA(row.names)) 
        stop("row names contain missing values")
      if (anyDuplicated(row.names)) 
        stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
    }
    else row.names <- integer()
    return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
  }
  vnames <- names(x)
  if (length(vnames) != n) 
    vnames <- character(n)
  no.vn <- !nzchar(vnames)
  vlist <- vnames <- as.list(vnames)
  nrows <- ncols <- integer(n)
  for (i in seq_len(n)) {
    xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
      as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
    else as.data.frame(x[[i]], optional = TRUE)
    nrows[i] <- .row_names_info(xi)
    ncols[i] <- length(xi)
    namesi <- names(xi)
    if (ncols[i] > 1) {
      if (length(namesi) == 0) 
        namesi <- seq_len(ncols[i])
      vnames[[i]] <- if (no.vn[i]) 
        namesi
      else paste(vnames[[i]], namesi, sep = ".")
    }
    else if (length(namesi)) {
      vnames[[i]] <- namesi
    }
    else if (fix.empty.names && no.vn[[i]]) {
      tmpname <- deparse(object[[i]], nlines = 1)[1]
      if (startsWith(tmpname, "I(") && endsWith(tmpname, ")")) {
        ntmpn <- nchar(tmpname, "c")
        tmpname <- substr(tmpname, 3, ntmpn - 1)
      }
      vnames[[i]] <- tmpname
    }
    if (mirn && nrows[i] > 0) {
      rowsi <- attr(xi, "row.names")
      if (any(nzchar(rowsi))) 
        row.names <- data.row.names(row.names, rowsi, i)
    }
    nrows[i] <- abs(nrows[i])
    vlist[[i]] <- xi
  }
  nr <- max(nrows)
  for (i in seq_len(n)[nrows < nr]) {
    xi <- vlist[[i]]
    if (nrows[i] > 0 && (nr%%nrows[i] == 0)) {
      xi <- unclass(xi)
      fixed <- TRUE
      for (j in seq_along(xi)) {
        xi1 <- xi[[j]]
        if (is.vector(xi1) || is.factor(xi1)) 
          xi[[j]] <- rep(xi1, length.out = nr)
        else if (is.character(xi1) && inherits(xi1, "AsIs")) 
          xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
        else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
          xi[[j]] <- rep(xi1, length.out = nr)
        else {
          fixed <- FALSE
          break
        }
      }
      if (fixed) {
        vlist[[i]] <- xi
        next
      }
    }
    stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
  }
  value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
  vnames <- as.character(unlist(vnames[ncols > 0]))
  if (fix.empty.names && any(noname <- !nzchar(vnames))) 
    vnames[noname] <- paste0("Var.", seq_along(vnames))[noname]
  if (check.names) {
    if (fix.empty.names) 
      vnames <- make.names(vnames, unique = TRUE)
    else {
      nz <- nzchar(vnames)
      vnames[nz] <- make.names(vnames[nz], unique = TRUE)
    }
  }
  names(value) <- vnames
  if (!mrn) {
    if (length(row.names) == 1 && nr != 1) {
      if (is.character(row.names)) 
        row.names <- match(row.names, vnames, 0)
      if (length(row.names) != 1 || row.names < 1 || row.names > length(vnames)) 
        stop("'row.names' should specify one of the variables")
      i <- row.names
      row.names <- value[[i]]
      value <- value[-i]
    }
    else if (!is.null(row.names) && length(row.names) != nr) 
      stop("row names supplied are of the wrong length")
  }
  else if (!is.null(row.names) && length(row.names) != nr) {
    warning("row names were found from a short variable and have been discarded")
    row.names <- NULL
  }
  class(value) <- "data.frame"
  if (is.null(row.names)) 
    attr(value, "row.names") <- .set_row_names(nr)
  else {
    if (is.object(row.names) || !is.integer(row.names)) 
      row.names <- as.character(row.names)
    if (anyNA(row.names)) 
      stop("row names contain missing values")
    if (anyDuplicated(row.names)) 
      stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
    row.names(value) <- row.names
  }
  value
}, function (..., stringsAsFactors = NULL) 
{
  stringsAsFactors <- stringsAsFactors %||% FALSE
  base::data.frame(..., stringsAsFactors = stringsAsFactors)
}, function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, fix.empty.names = TRUE, stringsAsFactors = FALSE) 
{
  data.row.names <- if (check.rows && is.null(row.names)) 
    function(current, new, i) {
      if (is.character(current)) 
        new <- as.character(new)
      if (is.character(new)) 
        current <- as.character(current)
      if (anyDuplicated(new)) 
        return(current)
      if (is.null(current)) 
        return(new)
      if (all(current == new) || all(current == "")) 
        return(new)
      stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
    }
  else function(current, new, i) {
    if (is.null(current)) {
      if (anyDuplicated(new)) {
        warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
        current
      }
      else new
    }
    else current
  }
  object <- as.list(substitute(list(...)))[-1]
  mirn <- missing(row.names)
  mrn <- is.null(row.names)
  x <- list(...)
  n <- length(x)
  if (n < 1) {
    if (!mrn) {
      if (is.object(row.names) || !is.integer(row.names)) 
        row.names <- as.character(row.names)
      if (anyNA(row.names)) 
        stop("row names contain missing values")
      if (anyDuplicated(row.names)) 
        stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
    }
    else row.names <- integer()
    return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
  }
  vnames <- names(x)
  if (length(vnames) != n) 
    vnames <- character(n)
  no.vn <- !nzchar(vnames)
  vlist <- vnames <- as.list(vnames)
  nrows <- ncols <- integer(n)
  for (i in seq_len(n)) {
    xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
      as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
    else as.data.frame(x[[i]], optional = TRUE)
    nrows[i] <- .row_names_info(xi)
    ncols[i] <- length(xi)
    namesi <- names(xi)
    if (ncols[i] > 1) {
      if (length(namesi) == 0) 
        namesi <- seq_len(ncols[i])
      vnames[[i]] <- if (no.vn[i]) 
        namesi
      else paste(vnames[[i]], namesi, sep = ".")
    }
    else if (length(namesi)) {
      vnames[[i]] <- namesi
    }
    else if (fix.empty.names && no.vn[[i]]) {
      tmpname <- deparse(object[[i]], nlines = 1)[1]
      if (startsWith(tmpname, "I(") && endsWith(tmpname, ")")) {
        ntmpn <- nchar(tmpname, "c")
        tmpname <- substr(tmpname, 3, ntmpn - 1)
      }
      vnames[[i]] <- tmpname
    }
    if (mirn && nrows[i] > 0) {
      rowsi <- attr(xi, "row.names")
      if (any(nzchar(rowsi))) 
        row.names <- data.row.names(row.names, rowsi, i)
    }
    nrows[i] <- abs(nrows[i])
    vlist[[i]] <- xi
  }
  nr <- max(nrows)
  for (i in seq_len(n)[nrows < nr]) {
    xi <- vlist[[i]]
    if (nrows[i] > 0 && (nr%%nrows[i] == 0)) {
      xi <- unclass(xi)
      fixed <- TRUE
      for (j in seq_along(xi)) {
        xi1 <- xi[[j]]
        if (is.vector(xi1) || is.factor(xi1)) 
          xi[[j]] <- rep(xi1, length.out = nr)
        else if (is.character(xi1) && inherits(xi1, "AsIs")) 
          xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
        else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
          xi[[j]] <- rep(xi1, length.out = nr)
        else {
          fixed <- FALSE
          break
        }
      }
      if (fixed) {
        vlist[[i]] <- xi
        next
      }
    }
    stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
  }
  value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
  vnames <- as.character(unlist(vnames[ncols > 0]))
  if (fix.empty.names && any(noname <- !nzchar(vnames))) 
    vnames[noname] <- paste0("Var.", seq_along(vnames))[noname]
  if (check.names) {
    if (fix.empty.names) 
      vnames <- make.names(vnames, unique = TRUE)
    else {
      nz <- nzchar(vnames)
      vnames[nz] <- make.names(vnames[nz], unique = TRUE)
    }
  }
  names(value) <- vnames
  if (!mrn) {
    if (length(row.names) == 1 && nr != 1) {
      if (is.character(row.names)) 
        row.names <- match(row.names, vnames, 0)
      if (length(row.names) != 1 || row.names < 1 || row.names > length(vnames)) 
        stop("'row.names' should specify one of the variables")
      i <- row.names
      row.names <- value[[i]]
      value <- value[-i]
    }
    else if (!is.null(row.names) && length(row.names) != nr) 
      stop("row names supplied are of the wrong length")
  }
  else if (!is.null(row.names) && length(row.names) != nr) {
    warning("row names were found from a short variable and have been discarded")
    row.names <- NULL
  }
  class(value) <- "data.frame"
  if (is.null(row.names)) 
    attr(value, "row.names") <- .set_row_names(nr)
  else {
    if (is.object(row.names) || !is.integer(row.names)) 
      row.names <- as.character(row.names)
    if (anyNA(row.names)) 
      stop("row names contain missing values")
    if (anyDuplicated(row.names)) 
      stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
    row.names(value) <- row.names
  }
  value
})
c("package:base", "namespace:vctrs", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
data.matrix
list(`package:base` = function (frame, rownames.force = NA) 
{
  if (!is.data.frame(frame)) 
    return(as.matrix(frame))
  d <- dim(frame)
  rn <- if (isFALSE(rownames.force)) 
    NULL
  else if (isTRUE(rownames.force)) 
    row.names(frame)
  else if (.row_names_info(frame) <= 0) 
    NULL
  else row.names(frame)
  for (i in seq_len(d[2])) {
    xi <- frame[[i]]
    if (is.integer(xi) || is.numeric(xi)) 
      next
    if (is.logical(xi) || is.factor(xi)) {
      frame[[i]] <- as.integer(xi)
      next
    }
    if (is.character(xi)) {
      frame[[i]] <- as.integer(factor(xi))
      next
    }
    frame[[i]] <- if (isS4(xi)) 
      methods::as(xi, "numeric")
    else as.numeric(xi)
  }
  intOK <- all(unlist(lapply(frame, is.integer)))
  x <- matrix(if (intOK) 
    NA
    else NA, nrow = d[1], ncol = d[2], dimnames = list(rn, names(frame)))
  for (i in seq_len(d[2])) x[, i] <- frame[[i]]
  x
}, function (frame, rownames.force = NA) 
{
  if (!is.data.frame(frame)) 
    return(as.matrix(frame))
  d <- dim(frame)
  rn <- if (isFALSE(rownames.force)) 
    NULL
  else if (isTRUE(rownames.force)) 
    row.names(frame)
  else if (.row_names_info(frame) <= 0) 
    NULL
  else row.names(frame)
  for (i in seq_len(d[2])) {
    xi <- frame[[i]]
    if (is.integer(xi) || is.numeric(xi)) 
      next
    if (is.logical(xi) || is.factor(xi)) {
      frame[[i]] <- as.integer(xi)
      next
    }
    if (is.character(xi)) {
      frame[[i]] <- as.integer(factor(xi))
      next
    }
    frame[[i]] <- if (isS4(xi)) 
      methods::as(xi, "numeric")
    else as.numeric(xi)
  }
  intOK <- all(unlist(lapply(frame, is.integer)))
  x <- matrix(if (intOK) 
    NA
    else NA, nrow = d[1], ncol = d[2], dimnames = list(rn, names(frame)))
  for (i in seq_len(d[2])) x[, i] <- frame[[i]]
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
date
list(`package:base` = function () 
  .Internal(date()), function (x) 
    UseMethod("date"), function () 
      .Internal(date()))
c("package:base", "namespace:lubridate", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
debug
list(`package:base` = function (fun, text = "", condition = NULL, signature = NULL) 
{
  if (is.null(signature)) 
    .Internal(debug(fun, text, condition))
  else if (requireNamespace("methods")) 
    methods::.debugMethod(fun, text, condition, signature, once = FALSE)
  else stop("failed to load the methods package for debugging by signature")
}, function (fun, text = "", condition = NULL, signature = NULL) 
{
  if (is.null(signature)) 
    .Internal(debug(fun, text, condition))
  else if (requireNamespace("methods")) 
    methods::.debugMethod(fun, text, condition, signature, once = FALSE)
  else stop("failed to load the methods package for debugging by signature")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
debuggingState
list(`package:base` = function (on = NULL) 
  .Internal(debugOnOff(on)), function (on = NULL) 
    .Internal(debugOnOff(on)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
debugonce
list(`package:base` = function (fun, text = "", condition = NULL, signature = NULL) 
{
  if (is.null(signature)) 
    .Internal(debugonce(fun, text, condition))
  else if (requireNamespace("methods")) 
    methods::.debugMethod(fun, text, condition, signature, once = TRUE)
  else stop("failed to load the methods package for debugging by signature")
}, function (fun, text = "", condition = NULL, signature = NULL) 
{
  if (is.null(signature)) 
    .Internal(debugonce(fun, text, condition))
  else if (requireNamespace("methods")) 
    methods::.debugMethod(fun, text, condition, signature, once = TRUE)
  else stop("failed to load the methods package for debugging by signature")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
default.stringsAsFactors
list(`package:base` = function () 
{
  .Deprecated("`stringsAsFactors = FALSE`")
  val <- getOption("stringsAsFactors")
  if (is.null(val)) 
    val <- FALSE
  if (length(val) != 1 || !is.logical(val) || is.na(val)) 
    stop("options(\"stringsAsFactors\") not set to TRUE or FALSE")
  val
}, function () 
{
  .Deprecated("`stringsAsFactors = FALSE`")
  val <- getOption("stringsAsFactors")
  if (is.null(val)) 
    val <- FALSE
  if (length(val) != 1 || !is.logical(val) || is.na(val)) 
    stop("options(\"stringsAsFactors\") not set to TRUE or FALSE")
  val
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
delayedAssign
list(`package:base` = function (x, value, eval.env = parent.frame(1), assign.env = parent.frame(1)) 
  .Internal(delayedAssign(x, substitute(value), eval.env, assign.env)), function (x, value, eval.env = parent.frame(1), assign.env = parent.frame(1)) 
    .Internal(delayedAssign(x, substitute(value), eval.env, assign.env)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
deparse
list(`package:base` = function (expr, width.cutoff = 60, backtick = mode(expr) %in% c("call", "expression", "(", "function"), control = c("keepNA", "keepInteger", "niceNames", "showAttributes"), nlines = -1) 
  .Internal(deparse(expr, width.cutoff, backtick, .deparseOpts(control), nlines)), function (expr, width.cutoff = 60, backtick = mode(expr) %in% c("call", "expression", "(", "function"), control = c("keepNA", "keepInteger", "niceNames", "showAttributes"), nlines = -1) 
    .Internal(deparse(expr, width.cutoff, backtick, .deparseOpts(control), nlines)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
deparse1
list(`package:base` = function (expr, collapse = " ", width.cutoff = 500, ...) 
  paste(deparse(expr, width.cutoff, ...), collapse = collapse), function (expr, collapse = " ", width.cutoff = 500, ...) 
    paste(deparse(expr, width.cutoff, ...), collapse = collapse))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
det
list(`package:base` = function (x, ...) 
{
  z <- determinant(x, logarithm = TRUE, ...)
  c(z$sign * exp(z$modulus))
}, function (x, ...) 
{
  z <- determinant(x, logarithm = TRUE, ...)
  c(z$sign * exp(z$modulus))
}, function (x, ...) 
{
  z <- determinant(x, logarithm = TRUE, ...)
  c(z$sign * exp(z$modulus))
})
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
detach
list(`package:base` = function (name, pos = 2, unload = FALSE, character.only = FALSE, force = FALSE) 
{
  if (!missing(name)) {
    if (!character.only) 
      name <- substitute(name)
    pos <- if (is.numeric(name)) 
      name
    else {
      if (!is.character(name)) 
        name <- deparse1(name)
      match(name, search())
    }
    if (is.na(pos)) 
      stop("invalid 'name' argument")
  }
  packageName <- search()[[pos]]
  if (!startsWith(packageName, "package:")) 
    return(invisible(.Internal(detach(pos))))
  pkgname <- .rmpkg(packageName)
  for (pkg in search()[-1]) {
    if (startsWith(pkg, "package:") && exists(".Depends", pkg, inherits = FALSE) && pkgname %in% get(".Depends", pkg, inherits = FALSE)) 
      if (force) 
        warning(gettextf("package %s is required by %s, which may no longer work correctly", sQuote(pkgname), sQuote(.rmpkg(pkg))), call. = FALSE, domain = NA)
    else stop(gettextf("package %s is required by %s so will not be detached", sQuote(pkgname), sQuote(.rmpkg(pkg))), call. = FALSE, domain = NA)
  }
  env <- as.environment(pos)
  libpath <- attr(env, "path")
  hook <- getHook(packageEvent(pkgname, "detach"))
  for (fun in rev(hook)) try(fun(pkgname, libpath))
  ns <- .getNamespace(pkgname)
  if (!is.null(ns) && exists(".onDetach", mode = "function", where = ns, inherits = FALSE)) {
    .onDetach <- get(".onDetach", mode = "function", pos = ns, inherits = FALSE)
    if (!is.null(libpath)) {
      res <- tryCatch(.onDetach(libpath), error = identity)
      if (inherits(res, "error")) {
        warning(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", ".onDetach", "detach", pkgname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
      }
    }
  }
  else if (exists(".Last.lib", mode = "function", where = pos, inherits = FALSE)) {
    .Last.lib <- get(".Last.lib", mode = "function", pos = pos, inherits = FALSE)
    if (!is.null(libpath)) {
      res <- tryCatch(.Last.lib(libpath), error = identity)
      if (inherits(res, "error")) {
        warning(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", ".Last.lib", "detach", pkgname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
      }
    }
  }
  .Internal(detach(pos))
  if (isNamespaceLoaded(pkgname)) {
    if (unload) {
      tryCatch(unloadNamespace(pkgname), error = function(e) warning(gettextf("%s namespace cannot be unloaded:\n  ", sQuote(pkgname)), conditionMessage(e), call. = FALSE, domain = NA))
    }
  }
  else {
    if (.isMethodsDispatchOn() && methods:::.hasS4MetaData(env)) 
      methods::cacheMetaData(env, FALSE)
    .Internal(lazyLoadDBflush(paste0(libpath, "/R/", pkgname, ".rdb")))
  }
  invisible()
}, function (name, pos = 2, unload = FALSE, character.only = FALSE, force = FALSE) 
{
  if (!missing(name)) {
    if (!character.only) 
      name <- substitute(name)
    pos <- if (is.numeric(name)) 
      name
    else {
      if (!is.character(name)) 
        name <- deparse1(name)
      match(name, search())
    }
    if (is.na(pos)) 
      stop("invalid 'name' argument")
  }
  packageName <- search()[[pos]]
  if (!startsWith(packageName, "package:")) 
    return(invisible(.Internal(detach(pos))))
  pkgname <- .rmpkg(packageName)
  for (pkg in search()[-1]) {
    if (startsWith(pkg, "package:") && exists(".Depends", pkg, inherits = FALSE) && pkgname %in% get(".Depends", pkg, inherits = FALSE)) 
      if (force) 
        warning(gettextf("package %s is required by %s, which may no longer work correctly", sQuote(pkgname), sQuote(.rmpkg(pkg))), call. = FALSE, domain = NA)
    else stop(gettextf("package %s is required by %s so will not be detached", sQuote(pkgname), sQuote(.rmpkg(pkg))), call. = FALSE, domain = NA)
  }
  env <- as.environment(pos)
  libpath <- attr(env, "path")
  hook <- getHook(packageEvent(pkgname, "detach"))
  for (fun in rev(hook)) try(fun(pkgname, libpath))
  ns <- .getNamespace(pkgname)
  if (!is.null(ns) && exists(".onDetach", mode = "function", where = ns, inherits = FALSE)) {
    .onDetach <- get(".onDetach", mode = "function", pos = ns, inherits = FALSE)
    if (!is.null(libpath)) {
      res <- tryCatch(.onDetach(libpath), error = identity)
      if (inherits(res, "error")) {
        warning(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", ".onDetach", "detach", pkgname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
      }
    }
  }
  else if (exists(".Last.lib", mode = "function", where = pos, inherits = FALSE)) {
    .Last.lib <- get(".Last.lib", mode = "function", pos = pos, inherits = FALSE)
    if (!is.null(libpath)) {
      res <- tryCatch(.Last.lib(libpath), error = identity)
      if (inherits(res, "error")) {
        warning(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", ".Last.lib", "detach", pkgname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
      }
    }
  }
  .Internal(detach(pos))
  if (isNamespaceLoaded(pkgname)) {
    if (unload) {
      tryCatch(unloadNamespace(pkgname), error = function(e) warning(gettextf("%s namespace cannot be unloaded:\n  ", sQuote(pkgname)), conditionMessage(e), call. = FALSE, domain = NA))
    }
  }
  else {
    if (.isMethodsDispatchOn() && methods:::.hasS4MetaData(env)) 
      methods::cacheMetaData(env, FALSE)
    .Internal(lazyLoadDBflush(paste0(libpath, "/R/", pkgname, ".rdb")))
  }
  invisible()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
determinant
list(`package:base` = function (x, logarithm = TRUE, ...) 
  UseMethod("determinant"), new("standardGeneric", .Data = function (x, logarithm = TRUE, ...) 
    standardGeneric("determinant"), generic = "determinant", package = "base", group = list(), valueClass = character(0), signature = c("x", "logarithm"), default = new("derivedDefaultMethod", .Data = function (x, logarithm = TRUE, ...) 
      base::determinant(x, logarithm, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "determinant"), skeleton = (new("derivedDefaultMethod", .Data = function (x, logarithm = TRUE, ...) 
        base::determinant(x, logarithm, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "determinant"))(x, logarithm, ...)), function (x, logarithm = TRUE, ...) 
          UseMethod("determinant"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
determinant.matrix
list(`package:base` = function (x, logarithm = TRUE, ...) 
{
  if ((n <- ncol(x)) != nrow(x)) 
    stop("'x' must be a square matrix")
  if (n < 1) 
    return(structure(list(modulus = structure(if (logarithm) 0 else 1, logarithm = logarithm), sign = 1), class = "det"))
  if (is.complex(x)) 
    stop("'determinant' not currently defined for complex matrices")
  .Internal(det_ge_real(x, logarithm))
}, function (x, logarithm = TRUE, ...) 
{
  if ((n <- ncol(x)) != nrow(x)) 
    stop("'x' must be a square matrix")
  if (n < 1) 
    return(structure(list(modulus = structure(if (logarithm) 0 else 1, logarithm = logarithm), sign = 1), class = "det"))
  if (is.complex(x)) 
    stop("'determinant' not currently defined for complex matrices")
  .Internal(det_ge_real(x, logarithm))
}, function (x, logarithm = TRUE, ...) 
{
  if ((n <- ncol(x)) != nrow(x)) 
    stop("'x' must be a square matrix")
  if (n < 1) 
    return(structure(list(modulus = structure(if (logarithm) 0 else 1, logarithm = logarithm), sign = 1), class = "det"))
  if (is.complex(x)) 
    stop("'determinant' not currently defined for complex matrices")
  .Internal(det_ge_real(x, logarithm))
})
c("package:base", "registered S3 method for determinant from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
dget
list(`package:base` = function (file, keep.source = FALSE) 
  eval(parse(file = file, keep.source = keep.source)), function (file, keep.source = FALSE) 
    eval(parse(file = file, keep.source = keep.source)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
diag
list(`package:base` = function (x = 1, nrow, ncol, names = TRUE) 
{
  if (is.matrix(x)) {
    if (nargs() > 1 && (nargs() > 2 || any(names(match.call()) %in% c("nrow", "ncol")))) 
      stop("'nrow' or 'ncol' cannot be specified when 'x' is a matrix")
    if ((m <- min(dim(x))) == 0) 
      return(vector(typeof(x), 0))
    y <- x[1 + 0:(m - 1) * (dim(x)[1] + 1)]
    if (names) {
      nms <- dimnames(x)
      if (is.list(nms) && !any(vapply(nms, is.null, NA)) && identical((nm <- nms[[1]][seq_len(m)]), nms[[2]][seq_len(m)])) 
        names(y) <- nm
    }
    return(y)
  }
  if (is.array(x) && length(dim(x)) != 1) 
    stop("'x' is an array, but not one-dimensional.")
  if (missing(x)) 
    n <- nrow
  else if (length(x) == 1 && nargs() == 1) {
    n <- as.integer(x)
    x <- 1
  }
  else n <- length(x)
  if (!missing(nrow)) 
    n <- nrow
  if (missing(ncol)) 
    ncol <- n
  .Internal(diag(x, n, ncol))
}, new("standardGeneric", .Data = function (x = 1, nrow, ncol, names = TRUE) 
  standardGeneric("diag"), generic = "diag", package = "base", group = list(), valueClass = character(0), signature = c("x", "nrow", "ncol", "names"), default = new("derivedDefaultMethod", .Data = function (x = 1, nrow, ncol, names = TRUE) 
  {
    if (is.matrix(x)) {
      if (nargs() > 1 && (nargs() > 2 || any(names(match.call()) %in% c("nrow", "ncol")))) 
        stop("'nrow' or 'ncol' cannot be specified when 'x' is a matrix")
      if ((m <- min(dim(x))) == 0) 
        return(vector(typeof(x), 0))
      y <- x[1 + 0:(m - 1) * (dim(x)[1] + 1)]
      if (names) {
        nms <- dimnames(x)
        if (is.list(nms) && !any(vapply(nms, is.null, NA)) && identical((nm <- nms[[1]][seq_len(m)]), nms[[2]][seq_len(m)])) 
          names(y) <- nm
      }
      return(y)
    }
    if (is.array(x) && length(dim(x)) != 1) 
      stop("'x' is an array, but not one-dimensional.")
    if (missing(x)) 
      n <- nrow
    else if (length(x) == 1 && nargs() == 1) {
      n <- as.integer(x)
      x <- 1
    }
    else n <- length(x)
    if (!missing(nrow)) 
      n <- nrow
    if (missing(ncol)) 
      ncol <- n
    .Internal(diag(x, n, ncol))
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "diag"), skeleton = (new("derivedDefaultMethod", .Data = function (x = 1, nrow, ncol, names = TRUE) 
  {
    if (is.matrix(x)) {
      if (nargs() > 1 && (nargs() > 2 || any(names(match.call()) %in% c("nrow", "ncol")))) 
        stop("'nrow' or 'ncol' cannot be specified when 'x' is a matrix")
      if ((m <- min(dim(x))) == 0) 
        return(vector(typeof(x), 0))
      y <- x[1 + 0:(m - 1) * (dim(x)[1] + 1)]
      if (names) {
        nms <- dimnames(x)
        if (is.list(nms) && !any(vapply(nms, is.null, NA)) && identical((nm <- nms[[1]][seq_len(m)]), nms[[2]][seq_len(m)])) 
          names(y) <- nm
      }
      return(y)
    }
    if (is.array(x) && length(dim(x)) != 1) 
      stop("'x' is an array, but not one-dimensional.")
    if (missing(x)) 
      n <- nrow
    else if (length(x) == 1 && nargs() == 1) {
      n <- as.integer(x)
      x <- 1
    }
    else n <- length(x)
    if (!missing(nrow)) 
      n <- nrow
    if (missing(ncol)) 
      ncol <- n
    .Internal(diag(x, n, ncol))
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "diag"))(x, nrow, ncol, names)), function (x = 1, nrow, ncol, names = TRUE) 
  {
    if (is.matrix(x)) {
      if (nargs() > 1 && (nargs() > 2 || any(names(match.call()) %in% c("nrow", "ncol")))) 
        stop("'nrow' or 'ncol' cannot be specified when 'x' is a matrix")
      if ((m <- min(dim(x))) == 0) 
        return(vector(typeof(x), 0))
      y <- x[1 + 0:(m - 1) * (dim(x)[1] + 1)]
      if (names) {
        nms <- dimnames(x)
        if (is.list(nms) && !any(vapply(nms, is.null, NA)) && identical((nm <- nms[[1]][seq_len(m)]), nms[[2]][seq_len(m)])) 
          names(y) <- nm
      }
      return(y)
    }
    if (is.array(x) && length(dim(x)) != 1) 
      stop("'x' is an array, but not one-dimensional.")
    if (missing(x)) 
      n <- nrow
    else if (length(x) == 1 && nargs() == 1) {
      n <- as.integer(x)
      x <- 1
    }
    else n <- length(x)
    if (!missing(nrow)) 
      n <- nrow
    if (missing(ncol)) 
      ncol <- n
    .Internal(diag(x, n, ncol))
  })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
diag<-
  list(`package:base` = function (x, value) 
  {
    dx <- dim(x)
    if (length(dx) != 2) 
      stop("only matrix diagonals can be replaced")
    len.i <- min(dx)
    len.v <- length(value)
    if (len.v != 1 && len.v != len.i) 
      stop("replacement diagonal has wrong length")
    if (len.i) {
      i <- seq_len(len.i)
      x[cbind(i, i)] <- value
    }
    x
  }, new("standardGeneric", .Data = function (x, value) 
    standardGeneric("diag<-"), generic = "diag<-", package = "base", group = list(), valueClass = character(0), signature = c("x", "value"), default = new("derivedDefaultMethod", .Data = function (x, value) 
    {
      dx <- dim(x)
      if (length(dx) != 2) 
        stop("only matrix diagonals can be replaced")
      len.i <- min(dx)
      len.v <- length(value)
      if (len.v != 1 && len.v != len.i) 
        stop("replacement diagonal has wrong length")
      if (len.i) {
        i <- seq_len(len.i)
        x[cbind(i, i)] <- value
      }
      x
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "diag<-"), skeleton = (new("derivedDefaultMethod", .Data = function (x, value) 
    {
      dx <- dim(x)
      if (length(dx) != 2) 
        stop("only matrix diagonals can be replaced")
      len.i <- min(dx)
      len.v <- length(value)
      if (len.v != 1 && len.v != len.i) 
        stop("replacement diagonal has wrong length")
      if (len.i) {
        i <- seq_len(len.i)
        x[cbind(i, i)] <- value
      }
      x
    }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "diag<-"))(x, value)), function (x, value) 
    {
      dx <- dim(x)
      if (length(dx) != 2) 
        stop("only matrix diagonals can be replaced")
      len.i <- min(dx)
      len.v <- length(value)
      if (len.v != 1 && len.v != len.i) 
        stop("replacement diagonal has wrong length")
      if (len.i) {
        i <- seq_len(len.i)
        x[cbind(i, i)] <- value
      }
      x
    })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
diff
list(`package:base` = function (x, ...) 
  UseMethod("diff"), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("diff"), generic = "diff", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
      UseMethod("diff"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "diff"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("diff"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "diff"))(x, ...)), function (x, ...) 
          UseMethod("diff"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
diff.Date
list(`package:base` = function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  xlen <- if (ismat) 
    dim(x)[1]
  else length(x)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(.difftime(numeric(), units = "days"))
  r <- x
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  r
}, function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  xlen <- if (ismat) 
    dim(x)[1]
  else length(x)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(.difftime(numeric(), units = "days"))
  r <- x
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  r
}, function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  xlen <- if (ismat) 
    dim(x)[1]
  else length(x)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(.difftime(numeric(), units = "days"))
  r <- x
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  r
})
c("package:base", "registered S3 method for diff from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
diff.default
list(`package:base` = function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  xlen <- if (ismat) 
    dim(x)[1]
  else length(x)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(x[0])
  r <- unclass(x)
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  class(r) <- oldClass(x)
  r
}, function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  xlen <- if (ismat) 
    dim(x)[1]
  else length(x)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(x[0])
  r <- unclass(x)
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  class(r) <- oldClass(x)
  r
}, function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  xlen <- if (ismat) 
    dim(x)[1]
  else length(x)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(x[0])
  r <- unclass(x)
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  class(r) <- oldClass(x)
  r
})
c("package:base", "registered S3 method for diff from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
diff.difftime
list(`package:base` = function (x, ...) 
  .difftime(NextMethod("diff"), attr(x, "units"), oldClass(x)), function (x, ...) 
    .difftime(NextMethod("diff"), attr(x, "units"), oldClass(x)), function (x, ...) 
      .difftime(NextMethod("diff"), attr(x, "units"), oldClass(x)))
c("package:base", "registered S3 method for diff from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
diff.POSIXt
list(`package:base` = function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  r <- if (inherits(x, "POSIXlt")) 
    as.POSIXct(x)
  else x
  xlen <- if (ismat) 
    dim(x)[1]
  else length(r)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(.difftime(numeric(), "secs"))
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  r
}, function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  r <- if (inherits(x, "POSIXlt")) 
    as.POSIXct(x)
  else x
  xlen <- if (ismat) 
    dim(x)[1]
  else length(r)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(.difftime(numeric(), "secs"))
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  r
}, function (x, lag = 1, differences = 1, ...) 
{
  ismat <- is.matrix(x)
  r <- if (inherits(x, "POSIXlt")) 
    as.POSIXct(x)
  else x
  xlen <- if (ismat) 
    dim(x)[1]
  else length(r)
  if (length(lag) != 1 || length(differences) > 1 || lag < 1 || differences < 1) 
    stop("'lag' and 'differences' must be integers >= 1")
  if (lag * differences >= xlen) 
    return(.difftime(numeric(), "secs"))
  i1 <- -seq_len(lag)
  if (ismat) 
    for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - r[-nrow(r):-(nrow(r) - lag + 1), , drop = FALSE]
  else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - lag + 1)]
  r
})
c("package:base", "registered S3 method for diff from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
difftime
list(`package:base` = function (time1, time2, tz, units = c("auto", "secs", "mins", "hours", "days", "weeks")) 
{
  if (missing(tz)) {
    time1 <- as.POSIXct(time1)
    time2 <- as.POSIXct(time2)
  }
  else {
    time1 <- as.POSIXct(time1, tz = tz)
    time2 <- as.POSIXct(time2, tz = tz)
  }
  z <- unclass(time1) - unclass(time2)
  attr(z, "tzone") <- NULL
  units <- match.arg(units)
  if (units == "auto") 
    units <- if (all(is.na(z))) 
      "secs"
  else {
    zz <- min(abs(z), na.rm = TRUE)
    if (!is.finite(zz) || zz < 60) 
      "secs"
    else if (zz < 3600) 
      "mins"
    else if (zz < 86400) 
      "hours"
    else "days"
  }
  switch(units, secs = .difftime(z, units = "secs"), mins = .difftime(z/60, units = "mins"), hours = .difftime(z/3600, units = "hours"), days = .difftime(z/86400, units = "days"), weeks = .difftime(z/(7 * 86400), units = "weeks"))
}, function (time1, time2, tz, units = c("auto", "secs", "mins", "hours", "days", "weeks")) 
{
  if (missing(tz)) {
    time1 <- as.POSIXct(time1)
    time2 <- as.POSIXct(time2)
  }
  else {
    time1 <- as.POSIXct(time1, tz = tz)
    time2 <- as.POSIXct(time2, tz = tz)
  }
  z <- unclass(time1) - unclass(time2)
  attr(z, "tzone") <- NULL
  units <- match.arg(units)
  if (units == "auto") 
    units <- if (all(is.na(z))) 
      "secs"
  else {
    zz <- min(abs(z), na.rm = TRUE)
    if (!is.finite(zz) || zz < 60) 
      "secs"
    else if (zz < 3600) 
      "mins"
    else if (zz < 86400) 
      "hours"
    else "days"
  }
  switch(units, secs = .difftime(z, units = "secs"), mins = .difftime(z/60, units = "mins"), hours = .difftime(z/3600, units = "hours"), days = .difftime(z/86400, units = "days"), weeks = .difftime(z/(7 * 86400), units = "weeks"))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
digamma
list(`package:base` = .Primitive("digamma"), .Primitive("digamma"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dim
list(`package:base` = .Primitive("dim"), .Primitive("dim"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dim.data.frame
list(`package:base` = function (x) 
  c(.row_names_info(x, 2), length(x)), function (x) 
    c(.row_names_info(x, 2), length(x)), function (x) 
      c(.row_names_info(x, 2), length(x)))
c("package:base", "registered S3 method for dim from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
dim<-
  list(`package:base` = .Primitive("dim<-"), .Primitive("dim<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dimnames
list(`package:base` = .Primitive("dimnames"), .Primitive("dimnames"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dimnames.data.frame
list(`package:base` = function (x) 
  list(row.names(x), names(x)), function (x) 
    list(row.names(x), names(x)), function (x) 
      list(row.names(x), names(x)))
c("package:base", "registered S3 method for dimnames from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
dimnames<-
  list(`package:base` = .Primitive("dimnames<-"), .Primitive("dimnames<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dimnames<-.data.frame
list(`package:base` = function (x, value) 
{
  d <- dim(x)
  if (!is.list(value) || length(value) != 2) 
    stop("invalid 'dimnames' given for data frame")
  value[[1]] <- as.character(value[[1]])
  value[[2]] <- as.character(value[[2]])
  if (d[[1]] != length(value[[1]]) || d[[2]] != length(value[[2]])) 
    stop("invalid 'dimnames' given for data frame")
  row.names(x) <- value[[1]]
  names(x) <- value[[2]]
  x
}, function (x, value) 
{
  d <- dim(x)
  if (!is.list(value) || length(value) != 2) 
    stop("invalid 'dimnames' given for data frame")
  value[[1]] <- as.character(value[[1]])
  value[[2]] <- as.character(value[[2]])
  if (d[[1]] != length(value[[1]]) || d[[2]] != length(value[[2]])) 
    stop("invalid 'dimnames' given for data frame")
  row.names(x) <- value[[1]]
  names(x) <- value[[2]]
  x
}, function (x, value) 
{
  d <- dim(x)
  if (!is.list(value) || length(value) != 2) 
    stop("invalid 'dimnames' given for data frame")
  value[[1]] <- as.character(value[[1]])
  value[[2]] <- as.character(value[[2]])
  if (d[[1]] != length(value[[1]]) || d[[2]] != length(value[[2]])) 
    stop("invalid 'dimnames' given for data frame")
  row.names(x) <- value[[1]]
  names(x) <- value[[2]]
  x
})
c("package:base", "registered S3 method for dimnames<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
dir
list(`package:base` = function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) 
  .Internal(list.files(path, pattern, all.files, full.names, recursive, ignore.case, include.dirs, no..)), function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) 
    .Internal(list.files(path, pattern, all.files, full.names, recursive, ignore.case, include.dirs, no..)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dir.create
list(`package:base` = function (path, showWarnings = TRUE, recursive = FALSE, mode = "0777") 
  .Internal(dir.create(path, showWarnings, recursive, as.octmode(mode))), function (path, showWarnings = TRUE, recursive = FALSE, mode = "0777") 
    .Internal(dir.create(path, showWarnings, recursive, as.octmode(mode))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dir.exists
list(`package:base` = function (paths) 
  .Internal(dir.exists(paths)), function (paths) 
    .Internal(dir.exists(paths)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dirname
list(`package:base` = function (path) 
  .Internal(dirname(path)), function (path) 
    .Internal(dirname(path)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
do.call
list(`package:base` = function (what, args, quote = FALSE, envir = parent.frame()) 
{
  if (!is.list(args)) 
    stop("second argument must be a list")
  if (quote) 
    args <- lapply(args, enquote)
  .Internal(do.call(what, args, envir))
}, function (what, args, quote = FALSE, envir = parent.frame()) 
{
  if (!is.list(args)) 
    stop("second argument must be a list")
  if (quote) 
    args <- lapply(args, enquote)
  .Internal(do.call(what, args, envir))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dontCheck
list(`package:base` = function (x) 
  x, function (x) 
    x)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
double
list(`package:base` = function (length = 0) 
  .Internal(vector("double", length)), function (length = 0) 
    .Internal(vector("double", length)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dput
list(`package:base` = function (x, file = "", control = c("keepNA", "keepInteger", "niceNames", "showAttributes")) 
{
  if (is.character(file)) 
    if (nzchar(file)) {
      file <- file(file, "wt")
      on.exit(close(file))
    }
  else file <- stdout()
  .Internal(dput(x, file, .deparseOpts(control)))
}, function (x, file = "", control = c("keepNA", "keepInteger", "niceNames", "showAttributes")) 
{
  if (is.character(file)) 
    if (nzchar(file)) {
      file <- file(file, "wt")
      on.exit(close(file))
    }
  else file <- stdout()
  .Internal(dput(x, file, .deparseOpts(control)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dQuote
list(`package:base` = function (x, q = getOption("useFancyQuotes")) 
{
  if (!length(x)) 
    return(character())
  before <- after <- "\""
  if (!is.null(q)) {
    if (isTRUE(q)) {
      li <- l10n_info()
      if (li$"UTF-8") 
        q <- "UTF-8"
      if (!is.null(li$codepage) && li$codepage > 0) {
        if (li$codepage >= 1250 && li$codepage <= 1258 || li$codepage == 874) {
          before <- rawToChar(as.raw(147))
          after <- rawToChar(as.raw(148))
        }
        else {
          z <- iconv(c(intToUtf8(8220), intToUtf8(8221)), "UTF-8", "")
          before <- z[1]
          after <- z[2]
        }
      }
    }
    if (identical(q, "TeX")) {
      before <- "``"
      after <- "''"
    }
    if (identical(q, "UTF-8")) {
      before <- intToUtf8(8220)
      after <- intToUtf8(8221)
    }
    if (is.character(q) && length(q) >= 4) {
      before <- q[3]
      after <- q[4]
    }
  }
  paste0(before, x, after)
}, function (x, q = getOption("useFancyQuotes")) 
{
  if (!length(x)) 
    return(character())
  before <- after <- "\""
  if (!is.null(q)) {
    if (isTRUE(q)) {
      li <- l10n_info()
      if (li$"UTF-8") 
        q <- "UTF-8"
      if (!is.null(li$codepage) && li$codepage > 0) {
        if (li$codepage >= 1250 && li$codepage <= 1258 || li$codepage == 874) {
          before <- rawToChar(as.raw(147))
          after <- rawToChar(as.raw(148))
        }
        else {
          z <- iconv(c(intToUtf8(8220), intToUtf8(8221)), "UTF-8", "")
          before <- z[1]
          after <- z[2]
        }
      }
    }
    if (identical(q, "TeX")) {
      before <- "``"
      after <- "''"
    }
    if (identical(q, "UTF-8")) {
      before <- intToUtf8(8220)
      after <- intToUtf8(8221)
    }
    if (is.character(q) && length(q) >= 4) {
      before <- q[3]
      after <- q[4]
    }
  }
  paste0(before, x, after)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
drop
list(`package:base` = function (x) 
  .Internal(drop(x)), new("standardGeneric", .Data = function (x) 
    standardGeneric("drop"), generic = "drop", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x) 
      .Internal(drop(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "drop"), skeleton = (new("derivedDefaultMethod", .Data = function (x) 
        .Internal(drop(x)), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "drop"))(x)), function (x) 
          .Internal(drop(x)))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
droplevels
list(`package:base` = function (x, ...) 
  UseMethod("droplevels"), function (x, ...) 
    UseMethod("droplevels"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
droplevels.data.frame
list(`package:base` = function (x, except = NULL, exclude, ...) 
{
  ix <- vapply(x, is.factor, NA)
  if (!is.null(except)) 
    ix[except] <- FALSE
  x[ix] <- if (missing(exclude)) 
    lapply(x[ix], droplevels)
  else lapply(x[ix], droplevels, exclude = exclude)
  x
}, function (x, except = NULL, exclude, ...) 
{
  ix <- vapply(x, is.factor, NA)
  if (!is.null(except)) 
    ix[except] <- FALSE
  x[ix] <- if (missing(exclude)) 
    lapply(x[ix], droplevels)
  else lapply(x[ix], droplevels, exclude = exclude)
  x
}, function (x, except = NULL, exclude, ...) 
{
  ix <- vapply(x, is.factor, NA)
  if (!is.null(except)) 
    ix[except] <- FALSE
  x[ix] <- if (missing(exclude)) 
    lapply(x[ix], droplevels)
  else lapply(x[ix], droplevels, exclude = exclude)
  x
})
c("package:base", "registered S3 method for droplevels from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
droplevels.factor
list(`package:base` = function (x, exclude = if (anyNA(levels(x))) NULL else NA, ...) 
  factor(x, exclude = exclude), function (x, exclude = if (anyNA(levels(x))) NULL else NA, ...) 
    factor(x, exclude = exclude), function (x, exclude = if (anyNA(levels(x))) NULL else NA, ...) 
      factor(x, exclude = exclude))
c("package:base", "registered S3 method for droplevels from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
dump
list(`package:base` = function (list, file = "dumpdata.R", append = FALSE, control = "all", envir = parent.frame(), evaluate = TRUE) 
{
  if (is.character(file)) {
    ex <- sapply(list, exists, envir = envir)
    if (!any(ex)) 
      return(invisible(character()))
    if (nzchar(file)) {
      file <- file(file, if (append) 
        "a"
        else "w")
      on.exit(close(file), add = TRUE)
    }
    else file <- stdout()
  }
  opts <- .deparseOpts(control)
  .Internal(dump(list, file, envir, opts, evaluate))
}, function (list, file = "dumpdata.R", append = FALSE, control = "all", envir = parent.frame(), evaluate = TRUE) 
{
  if (is.character(file)) {
    ex <- sapply(list, exists, envir = envir)
    if (!any(ex)) 
      return(invisible(character()))
    if (nzchar(file)) {
      file <- file(file, if (append) 
        "a"
        else "w")
      on.exit(close(file), add = TRUE)
    }
    else file <- stdout()
  }
  opts <- .deparseOpts(control)
  .Internal(dump(list, file, envir, opts, evaluate))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
duplicated
list(`package:base` = function (x, incomparables = FALSE, ...) 
  UseMethod("duplicated"), function (x, incomparables = FALSE, ...) 
    UseMethod("duplicated"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
duplicated.array
list(`package:base` = function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  res <- duplicated.default(temp, fromLast = fromLast, ...)
  dim(res) <- dim(temp)
  dimnames(res) <- dimnames(temp)
  res
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  res <- duplicated.default(temp, fromLast = fromLast, ...)
  dim(res) <- dim(temp)
  dimnames(res) <- dimnames(temp)
  res
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  res <- duplicated.default(temp, fromLast = fromLast, ...)
  dim(res) <- dim(temp)
  dimnames(res) <- dimnames(temp)
  res
})
c("package:base", "registered S3 method for duplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
duplicated.data.frame
list(`package:base` = function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  if (length(x) != 1) {
    if (any(i <- vapply(x, is.factor, NA))) 
      x[i] <- lapply(x[i], as.numeric)
    if (any(i <- (lengths(lapply(x, dim)) == 2))) 
      x[i] <- lapply(x[i], split.data.frame, seq_len(nrow(x)))
    duplicated(do.call(Map, `names<-`(c(list, x), NULL)), fromLast = fromLast)
  }
  else duplicated(x[[1]], fromLast = fromLast, ...)
}, function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  if (length(x) != 1) {
    if (any(i <- vapply(x, is.factor, NA))) 
      x[i] <- lapply(x[i], as.numeric)
    if (any(i <- (lengths(lapply(x, dim)) == 2))) 
      x[i] <- lapply(x[i], split.data.frame, seq_len(nrow(x)))
    duplicated(do.call(Map, `names<-`(c(list, x), NULL)), fromLast = fromLast)
  }
  else duplicated(x[[1]], fromLast = fromLast, ...)
}, function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  if (length(x) != 1) {
    if (any(i <- vapply(x, is.factor, NA))) 
      x[i] <- lapply(x[i], as.numeric)
    if (any(i <- (lengths(lapply(x, dim)) == 2))) 
      x[i] <- lapply(x[i], split.data.frame, seq_len(nrow(x)))
    duplicated(do.call(Map, `names<-`(c(list, x), NULL)), fromLast = fromLast)
  }
  else duplicated(x[[1]], fromLast = fromLast, ...)
})
c("package:base", "registered S3 method for duplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
duplicated.default
list(`package:base` = function (x, incomparables = FALSE, fromLast = FALSE, nmax = NA, ...) 
  .Internal(duplicated(x, incomparables, fromLast, if (is.factor(x)) min(length(x), nlevels(x) + 1) else nmax)), function (x, incomparables = FALSE, fromLast = FALSE, nmax = NA, ...) 
    .Internal(duplicated(x, incomparables, fromLast, if (is.factor(x)) min(length(x), nlevels(x) + 1) else nmax)), function (x, incomparables = FALSE, fromLast = FALSE, nmax = NA, ...) 
      .Internal(duplicated(x, incomparables, fromLast, if (is.factor(x)) min(length(x), nlevels(x) + 1) else nmax)))
c("package:base", "registered S3 method for duplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
duplicated.matrix
list(`package:base` = function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  res <- duplicated.default(temp, fromLast = fromLast, ...)
  dim(res) <- dim(temp)
  dimnames(res) <- dimnames(temp)
  res
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  res <- duplicated.default(temp, fromLast = fromLast, ...)
  dim(res) <- dim(temp)
  dimnames(res) <- dimnames(temp)
  res
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (any(MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  res <- duplicated.default(temp, fromLast = fromLast, ...)
  dim(res) <- dim(temp)
  dimnames(res) <- dimnames(temp)
  res
})
c("package:base", "registered S3 method for duplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
duplicated.numeric_version
list(`package:base` = function (x, incomparables = FALSE, ...) 
{
  x <- .encode_numeric_version(x)
  NextMethod("duplicated")
}, function (x, incomparables = FALSE, ...) 
{
  x <- .encode_numeric_version(x)
  NextMethod("duplicated")
}, function (x, incomparables = FALSE, ...) 
{
  x <- .encode_numeric_version(x)
  NextMethod("duplicated")
})
c("package:base", "registered S3 method for duplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
duplicated.POSIXlt
list(`package:base` = function (x, incomparables = FALSE, ...) 
{
  x <- as.POSIXct(x)
  NextMethod("duplicated", x)
}, function (x, incomparables = FALSE, ...) 
{
  x <- as.POSIXct(x)
  NextMethod("duplicated", x)
}, function (x, incomparables = FALSE, ...) 
{
  x <- as.POSIXct(x)
  NextMethod("duplicated", x)
})
c("package:base", "registered S3 method for duplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
duplicated.warnings
list(`package:base` = function (x, incomparables = FALSE, ...) 
  duplicated(paste(names(x), as.character(x)), incomparables, ...), function (x, incomparables = FALSE, ...) 
    duplicated(paste(names(x), as.character(x)), incomparables, ...), function (x, incomparables = FALSE, ...) 
      duplicated(paste(names(x), as.character(x)), incomparables, ...))
c("package:base", "registered S3 method for duplicated from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
dyn.load
list(`package:base` = function (x, local = TRUE, now = TRUE, ...) 
{
  inDL <- function(x, local, now, ..., DLLpath = "") .Internal(dyn.load(x, local, now, DLLpath))
  inDL(x, as.logical(local), as.logical(now), ...)
}, function (x, local = TRUE, now = TRUE, ...) 
{
  inDL <- function(x, local, now, ..., DLLpath = "") .Internal(dyn.load(x, local, now, DLLpath))
  inDL(x, as.logical(local), as.logical(now), ...)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dyn.unload
list(`package:base` = function (x) 
  .Internal(dyn.unload(x)), function (x) 
    .Internal(dyn.unload(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
dynGet
list(`package:base` = function (x, ifnotfound = stop(gettextf("%s not found", sQuote(x)), domain = NA), minframe = 1, inherits = FALSE) 
{
  n <- sys.nframe()
  myObj <- structure(list(.b = as.raw(7)), foo = 47)
  while (n > minframe) {
    n <- n - 1
    env <- sys.frame(n)
    r <- get0(x, envir = env, inherits = inherits, ifnotfound = myObj)
    if (!identical(r, myObj)) 
      return(r)
  }
  ifnotfound
}, function (x, ifnotfound = stop(gettextf("%s not found", sQuote(x)), domain = NA), minframe = 1, inherits = FALSE) 
{
  n <- sys.nframe()
  myObj <- structure(list(.b = as.raw(7)), foo = 47)
  while (n > minframe) {
    n <- n - 1
    env <- sys.frame(n)
    r <- get0(x, envir = env, inherits = inherits, ifnotfound = myObj)
    if (!identical(r, myObj)) 
      return(r)
  }
  ifnotfound
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
eapply
list(`package:base` = function (env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE) 
{
  FUN <- match.fun(FUN)
  .Internal(eapply(env, FUN, all.names, USE.NAMES))
}, function (env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE) 
{
  FUN <- match.fun(FUN)
  .Internal(eapply(env, FUN, all.names, USE.NAMES))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
eigen
list(`package:base` = function (x, symmetric, only.values = FALSE, EISPACK = FALSE) 
{
  x <- unname(as.matrix(x))
  n <- nrow(x)
  if (!n) 
    stop("0 x 0 matrix")
  if (n != ncol(x)) 
    stop("non-square matrix in 'eigen'")
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid nrow(x)")
  complex.x <- is.complex(x)
  if (!all(is.finite(x))) 
    stop("infinite or missing values in 'x'")
  if (missing(symmetric)) 
    symmetric <- isSymmetric.matrix(x)
  if (symmetric) {
    z <- if (!complex.x) 
      .Internal(La_rs(x, only.values))
    else .Internal(La_rs_cmplx(x, only.values))
    ord <- rev(seq_along(z$values))
  }
  else {
    z <- if (!complex.x) 
      .Internal(La_rg(x, only.values))
    else .Internal(La_rg_cmplx(x, only.values))
    ord <- sort.list(Mod(z$values), decreasing = TRUE)
  }
  if (only.values) 
    list(values = z$values[ord], vectors = NULL)
  else structure(class = "eigen", list(values = z$values[ord], vectors = z$vectors[, ord, drop = FALSE]))
}, function (x, symmetric, only.values = FALSE, EISPACK = FALSE) 
{
  x <- unname(as.matrix(x))
  n <- nrow(x)
  if (!n) 
    stop("0 x 0 matrix")
  if (n != ncol(x)) 
    stop("non-square matrix in 'eigen'")
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid nrow(x)")
  complex.x <- is.complex(x)
  if (!all(is.finite(x))) 
    stop("infinite or missing values in 'x'")
  if (missing(symmetric)) 
    symmetric <- isSymmetric.matrix(x)
  if (symmetric) {
    z <- if (!complex.x) 
      .Internal(La_rs(x, only.values))
    else .Internal(La_rs_cmplx(x, only.values))
    ord <- rev(seq_along(z$values))
  }
  else {
    z <- if (!complex.x) 
      .Internal(La_rg(x, only.values))
    else .Internal(La_rg_cmplx(x, only.values))
    ord <- sort.list(Mod(z$values), decreasing = TRUE)
  }
  if (only.values) 
    list(values = z$values[ord], vectors = NULL)
  else structure(class = "eigen", list(values = z$values[ord], vectors = z$vectors[, ord, drop = FALSE]))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
emptyenv
list(`package:base` = .Primitive("emptyenv"), .Primitive("emptyenv"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
enc2native
list(`package:base` = .Primitive("enc2native"), .Primitive("enc2native"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
enc2utf8
list(`package:base` = .Primitive("enc2utf8"), .Primitive("enc2utf8"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
encodeString
list(`package:base` = function (x, width = 0, quote = "", na.encode = TRUE, justify = c("left", "right", "centre", "none")) 
{
  at <- attributes(x)
  x <- as.character(x)
  attributes(x) <- at
  oldClass(x) <- NULL
  justify <- match(match.arg(justify), c("left", "right", "centre", "none")) - 1
  .Internal(encodeString(x, width, quote, justify, na.encode))
}, function (x, width = 0, quote = "", na.encode = TRUE, justify = c("left", "right", "centre", "none")) 
{
  at <- attributes(x)
  x <- as.character(x)
  attributes(x) <- at
  oldClass(x) <- NULL
  justify <- match(match.arg(justify), c("left", "right", "centre", "none")) - 1
  .Internal(encodeString(x, width, quote, justify, na.encode))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Encoding
list(`package:base` = function (x) 
  .Internal(Encoding(x)), function (x) 
    .Internal(Encoding(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Encoding<-
  list(`package:base` = function (x, value) 
    .Internal(setEncoding(x, value)), function (x, value) 
      .Internal(setEncoding(x, value)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
endsWith
list(`package:base` = function (x, suffix) 
  .Internal(endsWith(x, suffix)), function (x, suffix) 
    .Internal(endsWith(x, suffix)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
enquote
list(`package:base` = function (cl) 
  as.call(list(quote(base::quote), cl)), function (cl) 
    as.call(list(quote(base::quote), cl)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
env.profile
list(`package:base` = function (env) 
  .Internal(env.profile(env)), function (env) 
    .Internal(env.profile(env)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
environment
list(`package:base` = function (fun = NULL) 
  .Internal(environment(fun)), function (fun = NULL) 
    .Internal(environment(fun)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
environment<-
  list(`package:base` = .Primitive("environment<-"), .Primitive("environment<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
environmentIsLocked
list(`package:base` = function (env) 
  .Internal(environmentIsLocked(env)), function (env) 
    .Internal(environmentIsLocked(env)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
environmentName
list(`package:base` = function (env) 
  .Internal(environmentName(env)), function (env) 
    .Internal(environmentName(env)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
errorCondition
list(`package:base` = function (message, ..., class = NULL, call = NULL) 
  structure(list(message = as.character(message), call = call, ...), class = c(class, "error", "condition")), function (message, ..., class = NULL, call = NULL) 
    structure(list(message = as.character(message), call = call, ...), class = c(class, "error", "condition")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
eval
list(`package:base` = function (expr, envir = parent.frame(), enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv()) 
  .Internal(eval(expr, envir, enclos)), function (expr, envir = parent.frame(), enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv()) 
    .Internal(eval(expr, envir, enclos)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
eval.parent
list(`package:base` = function (expr, n = 1) 
{
  p <- parent.frame(n + 1)
  eval(expr, p)
}, function (expr, n = 1) 
{
  p <- parent.frame(n + 1)
  eval(expr, p)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
evalq
list(`package:base` = function (expr, envir = parent.frame(), enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv()) 
  .Internal(eval(substitute(expr), envir, enclos)), function (expr, envir = parent.frame(), enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv()) 
    .Internal(eval(substitute(expr), envir, enclos)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
exists
list(`package:base` = function (x, where = -1, envir = if (missing(frame)) as.environment(where) else sys.frame(frame), frame, mode = "any", inherits = TRUE) 
  .Internal(exists(x, envir, mode, inherits)), function (x, where = -1, envir = if (missing(frame)) as.environment(where) else sys.frame(frame), frame, mode = "any", inherits = TRUE) 
    .Internal(exists(x, envir, mode, inherits)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
exp
list(`package:base` = .Primitive("exp"), .Primitive("exp"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
expand.grid
list(`package:base` = function (..., KEEP.OUT.ATTRS = TRUE, stringsAsFactors = TRUE) 
{
  nargs <- length(args <- list(...))
  if (!nargs) 
    return(as.data.frame(list()))
  if (nargs == 1 && is.list(a1 <- args[[1]])) 
    nargs <- length(args <- a1)
  if (nargs == 0) 
    return(as.data.frame(list()))
  cargs <- vector("list", nargs)
  iArgs <- seq_len(nargs)
  nmc <- paste0("Var", iArgs)
  nm <- names(args)
  if (is.null(nm)) 
    nm <- nmc
  else if (any(ng0 <- nzchar(nm))) 
    nmc[ng0] <- nm[ng0]
  names(cargs) <- nmc
  rep.fac <- 1
  d <- lengths(args)
  if (KEEP.OUT.ATTRS) {
    dn <- vector("list", nargs)
    names(dn) <- nmc
  }
  orep <- prod(d)
  if (orep == 0) {
    for (i in iArgs) cargs[[i]] <- args[[i]][FALSE]
  }
  else {
    for (i in iArgs) {
      x <- args[[i]]
      if (KEEP.OUT.ATTRS) 
        dn[[i]] <- paste0(nmc[i], "=", if (is.numeric(x)) 
          format(x)
          else x)
      nx <- length(x)
      orep <- orep/nx
      if (stringsAsFactors && is.character(x)) 
        x <- factor(x, levels = unique(x))
      x <- x[rep.int(rep.int(seq_len(nx), rep.int(rep.fac, nx)), orep)]
      cargs[[i]] <- x
      rep.fac <- rep.fac * nx
    }
  }
  if (KEEP.OUT.ATTRS) 
    attr(cargs, "out.attrs") <- list(dim = d, dimnames = dn)
  rn <- .set_row_names(as.integer(prod(d)))
  structure(cargs, class = "data.frame", row.names = rn)
}, function (..., KEEP.OUT.ATTRS = TRUE, stringsAsFactors = TRUE) 
{
  nargs <- length(args <- list(...))
  if (!nargs) 
    return(as.data.frame(list()))
  if (nargs == 1 && is.list(a1 <- args[[1]])) 
    nargs <- length(args <- a1)
  if (nargs == 0) 
    return(as.data.frame(list()))
  cargs <- vector("list", nargs)
  iArgs <- seq_len(nargs)
  nmc <- paste0("Var", iArgs)
  nm <- names(args)
  if (is.null(nm)) 
    nm <- nmc
  else if (any(ng0 <- nzchar(nm))) 
    nmc[ng0] <- nm[ng0]
  names(cargs) <- nmc
  rep.fac <- 1
  d <- lengths(args)
  if (KEEP.OUT.ATTRS) {
    dn <- vector("list", nargs)
    names(dn) <- nmc
  }
  orep <- prod(d)
  if (orep == 0) {
    for (i in iArgs) cargs[[i]] <- args[[i]][FALSE]
  }
  else {
    for (i in iArgs) {
      x <- args[[i]]
      if (KEEP.OUT.ATTRS) 
        dn[[i]] <- paste0(nmc[i], "=", if (is.numeric(x)) 
          format(x)
          else x)
      nx <- length(x)
      orep <- orep/nx
      if (stringsAsFactors && is.character(x)) 
        x <- factor(x, levels = unique(x))
      x <- x[rep.int(rep.int(seq_len(nx), rep.int(rep.fac, nx)), orep)]
      cargs[[i]] <- x
      rep.fac <- rep.fac * nx
    }
  }
  if (KEEP.OUT.ATTRS) 
    attr(cargs, "out.attrs") <- list(dim = d, dimnames = dn)
  rn <- .set_row_names(as.integer(prod(d)))
  structure(cargs, class = "data.frame", row.names = rn)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
expm1
list(`package:base` = .Primitive("expm1"), .Primitive("expm1"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
expression
list(`package:base` = .Primitive("expression"), .Primitive("expression"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
extSoftVersion
list(`package:base` = function () 
  .Internal(eSoftVersion()), function () 
    .Internal(eSoftVersion()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
F
list(`package:base` = FALSE, FALSE)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
factor
list(`package:base` = function (x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), nmax = NA) 
{
  if (is.null(x)) 
    x <- character()
  nx <- names(x)
  if (missing(levels)) {
    y <- unique(x, nmax = nmax)
    ind <- order(y)
    levels <- unique(as.character(y)[ind])
  }
  force(ordered)
  if (!is.character(x)) 
    x <- as.character(x)
  levels <- levels[is.na(match(levels, exclude))]
  f <- match(x, levels)
  if (!is.null(nx)) 
    names(f) <- nx
  if (missing(labels)) {
    levels(f) <- as.character(levels)
  }
  else {
    nlab <- length(labels)
    if (nlab == length(levels)) {
      nlevs <- unique(xlevs <- as.character(labels))
      at <- attributes(f)
      at$levels <- nlevs
      f <- match(xlevs, nlevs)[f]
      attributes(f) <- at
    }
    else if (nlab == 1) 
      levels(f) <- paste0(labels, seq_along(levels))
    else stop(gettextf("invalid 'labels'; length %d should be 1 or %d", nlab, length(levels)), domain = NA)
  }
  class(f) <- c(if (ordered) "ordered", "factor")
  f
}, function (x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), nmax = NA) 
{
  if (is.null(x)) 
    x <- character()
  nx <- names(x)
  if (missing(levels)) {
    y <- unique(x, nmax = nmax)
    ind <- order(y)
    levels <- unique(as.character(y)[ind])
  }
  force(ordered)
  if (!is.character(x)) 
    x <- as.character(x)
  levels <- levels[is.na(match(levels, exclude))]
  f <- match(x, levels)
  if (!is.null(nx)) 
    names(f) <- nx
  if (missing(labels)) {
    levels(f) <- as.character(levels)
  }
  else {
    nlab <- length(labels)
    if (nlab == length(levels)) {
      nlevs <- unique(xlevs <- as.character(labels))
      at <- attributes(f)
      at$levels <- nlevs
      f <- match(xlevs, nlevs)[f]
      attributes(f) <- at
    }
    else if (nlab == 1) 
      levels(f) <- paste0(labels, seq_along(levels))
    else stop(gettextf("invalid 'labels'; length %d should be 1 or %d", nlab, length(levels)), domain = NA)
  }
  class(f) <- c(if (ordered) "ordered", "factor")
  f
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
factorial
list(`package:base` = function (x) 
  gamma(x + 1), function (x) 
    gamma(x + 1))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
fifo
list(`package:base` = function (description, open = "", blocking = FALSE, encoding = getOption("encoding")) 
  .Internal(fifo(description, open, blocking, encoding)), function (description, open = "", blocking = FALSE, encoding = getOption("encoding")) 
    .Internal(fifo(description, open, blocking, encoding)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file
list(`package:base` = function (description = "", open = "", blocking = TRUE, encoding = getOption("encoding"), raw = FALSE, method = getOption("url.method", "default")) 
{
  .Internal(file(description, open, blocking, encoding, method, raw))
}, function (description = "", open = "", blocking = TRUE, encoding = getOption("encoding"), raw = FALSE, method = getOption("url.method", "default")) 
{
  .Internal(file(description, open, blocking, encoding, method, raw))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.access
list(`package:base` = function (names, mode = 0) 
{
  res <- .Internal(file.access(names, mode))
  names(res) <- names
  res
}, function (names, mode = 0) 
{
  res <- .Internal(file.access(names, mode))
  names(res) <- names
  res
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.append
list(`package:base` = function (file1, file2) 
  .Internal(file.append(file1, file2)), function (file1, file2) 
    .Internal(file.append(file1, file2)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.choose
list(`package:base` = function (new = FALSE) 
  .Internal(file.choose(new)), function (new = FALSE) 
    .Internal(file.choose(new)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.copy
list(`package:base` = function (from, to, overwrite = recursive, recursive = FALSE, copy.mode = TRUE, copy.date = FALSE) 
{
  if (!(nf <- length(from))) 
    return(logical())
  if (!(nt <- length(to))) 
    stop("no files to copy to")
  if (nt == 1 && dir.exists(to)) {
    if (recursive && to %in% from) 
      stop("attempt to copy a directory to itself")
    if (.Platform$OS.type == "windows") {
      from <- gsub("/", "\\", from, fixed = TRUE)
      to <- gsub("/", "\\", to, fixed = TRUE)
    }
    return(.Internal(file.copy(from, to, overwrite, recursive, copy.mode, copy.date)))
  }
  else if (nf > nt) 
    stop("more 'from' files than 'to' files")
  else if (recursive) 
    warning("'recursive' will be ignored as 'to' is not a single existing directory")
  if (nt > nf) 
    from <- rep_len(from, length.out = nt)
  okay <- file.exists(from)
  if (!overwrite) 
    okay[file.exists(to)] <- FALSE
  else {
    dirtofile <- dir.exists(from[okay]) & file.exists(to[okay]) & !dir.exists(to[okay])
    if (any(dirtofile)) {
      warning("cannot overwrite a non-directory with a directory")
      okay[okay] <- !dirtofile
    }
  }
  if (any(from[okay] %in% to[okay])) 
    stop("file can not be copied both 'from' and 'to'")
  if (any(okay)) {
    okay[okay] <- file.create(to[okay])
    if (any(okay)) {
      okay[okay] <- file.append(to[okay], from[okay])
      if (copy.mode || copy.date) {
        fi <- file.info(from[okay], extra_cols = FALSE)
        if (copy.mode) 
          Sys.chmod(to[okay], fi$mode, TRUE)
        if (copy.date) 
          Sys.setFileTime(to[okay], fi$mtime)
      }
    }
  }
  okay
}, function (from, to, overwrite = recursive, recursive = FALSE, copy.mode = TRUE, copy.date = FALSE) 
{
  if (!(nf <- length(from))) 
    return(logical())
  if (!(nt <- length(to))) 
    stop("no files to copy to")
  if (nt == 1 && dir.exists(to)) {
    if (recursive && to %in% from) 
      stop("attempt to copy a directory to itself")
    if (.Platform$OS.type == "windows") {
      from <- gsub("/", "\\", from, fixed = TRUE)
      to <- gsub("/", "\\", to, fixed = TRUE)
    }
    return(.Internal(file.copy(from, to, overwrite, recursive, copy.mode, copy.date)))
  }
  else if (nf > nt) 
    stop("more 'from' files than 'to' files")
  else if (recursive) 
    warning("'recursive' will be ignored as 'to' is not a single existing directory")
  if (nt > nf) 
    from <- rep_len(from, length.out = nt)
  okay <- file.exists(from)
  if (!overwrite) 
    okay[file.exists(to)] <- FALSE
  else {
    dirtofile <- dir.exists(from[okay]) & file.exists(to[okay]) & !dir.exists(to[okay])
    if (any(dirtofile)) {
      warning("cannot overwrite a non-directory with a directory")
      okay[okay] <- !dirtofile
    }
  }
  if (any(from[okay] %in% to[okay])) 
    stop("file can not be copied both 'from' and 'to'")
  if (any(okay)) {
    okay[okay] <- file.create(to[okay])
    if (any(okay)) {
      okay[okay] <- file.append(to[okay], from[okay])
      if (copy.mode || copy.date) {
        fi <- file.info(from[okay], extra_cols = FALSE)
        if (copy.mode) 
          Sys.chmod(to[okay], fi$mode, TRUE)
        if (copy.date) 
          Sys.setFileTime(to[okay], fi$mtime)
      }
    }
  }
  okay
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.create
list(`package:base` = function (..., showWarnings = TRUE) 
  .Internal(file.create(c(...), showWarnings)), function (..., showWarnings = TRUE) 
    .Internal(file.create(c(...), showWarnings)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.exists
list(`package:base` = function (...) 
  .Internal(file.exists(c(...))), function (...) 
    .Internal(file.exists(c(...))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.info
list(`package:base` = function (..., extra_cols = TRUE) 
{
  res <- .Internal(file.info(fn <- c(...), extra_cols))
  res$mtime <- .POSIXct(res$mtime)
  res$ctime <- .POSIXct(res$ctime)
  res$atime <- .POSIXct(res$atime)
  class(res) <- "data.frame"
  attr(res, "row.names") <- fn
  res
}, function (..., extra_cols = TRUE) 
{
  res <- .Internal(file.info(fn <- c(...), extra_cols))
  res$mtime <- .POSIXct(res$mtime)
  res$ctime <- .POSIXct(res$ctime)
  res$atime <- .POSIXct(res$atime)
  class(res) <- "data.frame"
  attr(res, "row.names") <- fn
  res
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.link
list(`package:base` = function (from, to) 
{
  if (!(length(from))) 
    stop("no files to link from")
  if (!length(to)) 
    stop("no files to link to")
  .Internal(file.link(from, to))
}, function (from, to) 
{
  if (!(length(from))) 
    stop("no files to link from")
  if (!length(to)) 
    stop("no files to link to")
  .Internal(file.link(from, to))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.mode
list(`package:base` = function (...) 
  file.info(..., extra_cols = FALSE)$mode, function (...) 
    file.info(..., extra_cols = FALSE)$mode)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.mtime
list(`package:base` = function (...) 
  file.info(..., extra_cols = FALSE)$mtime, function (...) 
    file.info(..., extra_cols = FALSE)$mtime)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.path
list(`package:base` = function (..., fsep = .Platform$file.sep) 
  .Internal(file.path(list(...), fsep)), function (..., fsep = .Platform$file.sep) 
    .Internal(file.path(list(...), fsep)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.remove
list(`package:base` = function (...) 
  .Internal(file.remove(c(...))), function (...) 
    .Internal(file.remove(c(...))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.rename
list(`package:base` = function (from, to) 
  .Internal(file.rename(from, to)), function (from, to) 
    .Internal(file.rename(from, to)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.show
list(`package:base` = function (..., header = rep("", nfiles), title = "R Information", delete.file = FALSE, pager = getOption("pager"), encoding = "") 
{
  files <- path.expand(c(...))
  nfiles <- length(files)
  if (nfiles == 0) 
    return(invisible(NULL))
  if (l10n_info()[["UTF-8"]] && encoding == "UTF-8") 
    encoding <- ""
  if (l10n_info()[["Latin-1"]] && encoding == "latin1") 
    encoding <- ""
  if (!is.na(encoding) && nzchar(encoding)) {
    for (i in seq_along(files)) {
      f <- files[i]
      tf <- tempfile()
      tmp <- readLines(f, warn = FALSE)
      tmp2 <- try(iconv(tmp, encoding, "", "byte"))
      if (inherits(tmp2, "try-error")) 
        file.copy(f, tf)
      else writeLines(tmp2, tf)
      files[i] <- tf
      if (delete.file) 
        unlink(f)
    }
    delete.file <- TRUE
  }
  if (is.function(pager)) 
    pager(files, header = header, title = title, delete.file = delete.file)
  else .Internal(file.show(files, header, title, delete.file, pager))
}, function (..., header = rep("", nfiles), title = "R Information", delete.file = FALSE, pager = getOption("pager"), encoding = "") 
{
  files <- path.expand(c(...))
  nfiles <- length(files)
  if (nfiles == 0) 
    return(invisible(NULL))
  if (l10n_info()[["UTF-8"]] && encoding == "UTF-8") 
    encoding <- ""
  if (l10n_info()[["Latin-1"]] && encoding == "latin1") 
    encoding <- ""
  if (!is.na(encoding) && nzchar(encoding)) {
    for (i in seq_along(files)) {
      f <- files[i]
      tf <- tempfile()
      tmp <- readLines(f, warn = FALSE)
      tmp2 <- try(iconv(tmp, encoding, "", "byte"))
      if (inherits(tmp2, "try-error")) 
        file.copy(f, tf)
      else writeLines(tmp2, tf)
      files[i] <- tf
      if (delete.file) 
        unlink(f)
    }
    delete.file <- TRUE
  }
  if (is.function(pager)) 
    pager(files, header = header, title = title, delete.file = delete.file)
  else .Internal(file.show(files, header, title, delete.file, pager))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.size
list(`package:base` = function (...) 
  file.info(..., extra_cols = FALSE)$size, function (...) 
    file.info(..., extra_cols = FALSE)$size)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.symlink
list(`package:base` = function (from, to) 
{
  if (!(length(from))) 
    stop("no files to link from")
  if (!(nt <- length(to))) 
    stop("no files/directory to link to")
  if (nt == 1 && file.exists(to) && file.info(to, extra_cols = FALSE)$isdir) 
    to <- file.path(to, basename(from))
  .Internal(file.symlink(from, to))
}, function (from, to) 
{
  if (!(length(from))) 
    stop("no files to link from")
  if (!(nt <- length(to))) 
    stop("no files/directory to link to")
  if (nt == 1 && file.exists(to) && file.info(to, extra_cols = FALSE)$isdir) 
    to <- file.path(to, basename(from))
  .Internal(file.symlink(from, to))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Filter
list(`package:base` = function (f, x) 
{
  f <- match.fun(f)
  ind <- as.logical(unlist(lapply(x, f)))
  x[which(ind)]
}, function (f, x) 
{
  f <- match.fun(f)
  ind <- as.logical(unlist(lapply(x, f)))
  x[which(ind)]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Find
list(`package:base` = function (f, x, right = FALSE, nomatch = NULL) 
{
  f <- match.fun(f)
  if ((pos <- Position(f, x, right, nomatch = 0)) > 0) 
    x[[pos]]
  else nomatch
}, function (f, x, right = FALSE, nomatch = NULL) 
{
  f <- match.fun(f)
  if ((pos <- Position(f, x, right, nomatch = 0)) > 0) 
    x[[pos]]
  else nomatch
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
find.package
list(`package:base` = function (package = NULL, lib.loc = NULL, quiet = FALSE, verbose = getOption("verbose")) 
{
  if (is.null(package) && is.null(lib.loc) && !verbose) {
    return(path.package())
  }
  if (length(package) == 1 && package %in% c("base", "tools", "utils", "grDevices", "graphics", "stats", "datasets", "methods", "grid", "parallel", "splines", "stats4", "tcltk", "compiler")) 
    return(file.path(.Library, package))
  if (is.null(package)) 
    package <- .packages()
  if (!length(package)) 
    return(character())
  if (use_loaded <- is.null(lib.loc)) 
    lib.loc <- .libPaths()
  bad <- character()
  out <- character()
  for (pkg in package) {
    paths <- file.path(lib.loc, pkg)
    paths <- paths[file.exists(file.path(paths, "DESCRIPTION"))]
    if (use_loaded && isNamespaceLoaded(pkg)) {
      dir <- if (pkg == "base") 
        system.file()
      else .getNamespaceInfo(asNamespace(pkg), "path")
      paths <- c(dir, paths)
    }
    if (length(paths) && file.exists(file.path(paths[1], "dummy_for_check"))) {
      bad <- c(bad, pkg)
      next
    }
    if (length(paths)) {
      paths <- unique(paths)
      valid_package_version_regexp <- .standard_regexps()$valid_package_version
      db <- lapply(paths, function(p) {
        pfile <- file.path(p, "Meta", "package.rds")
        info <- if (file.exists(pfile)) {
          tryCatch(readRDS(pfile)$DESCRIPTION[c("Package", "Version")], error = function(e) c(Package = NA, Version = NA))
        }
        else {
          info <- tryCatch(read.dcf(file.path(p, "DESCRIPTION"), c("Package", "Version"))[1, ], error = identity)
          if (inherits(info, "error") || (length(info) != 2) || anyNA(info)) 
            c(Package = NA, Version = NA)
          else info
        }
      })
      db <- do.call(rbind, db)
      ok <- (apply(!is.na(db), 1, all) & (db[, "Package"] == pkg) & (grepl(valid_package_version_regexp, db[, "Version"])))
      paths <- paths[ok]
    }
    if (length(paths) == 0) {
      bad <- c(bad, pkg)
      next
    }
    if (length(paths) > 1) {
      if (verbose) 
        warning(gettextf("package %s found more than once, using the first from\n  %s", sQuote(pkg), paste(dQuote(paths), collapse = ",\n  ")), domain = NA)
      paths <- paths[1]
    }
    out <- c(out, paths)
  }
  if (!quiet && length(bad)) {
    if (length(out) == 0) 
      stop(packageNotFoundError(bad, lib.loc, sys.call()))
    for (pkg in bad) warning(gettextf("there is no package called %s", sQuote(pkg)), domain = NA)
  }
  out
}, function (package = NULL, lib.loc = NULL, quiet = FALSE, verbose = getOption("verbose")) 
{
  if (is.null(package) && is.null(lib.loc) && !verbose) {
    return(path.package())
  }
  if (length(package) == 1 && package %in% c("base", "tools", "utils", "grDevices", "graphics", "stats", "datasets", "methods", "grid", "parallel", "splines", "stats4", "tcltk", "compiler")) 
    return(file.path(.Library, package))
  if (is.null(package)) 
    package <- .packages()
  if (!length(package)) 
    return(character())
  if (use_loaded <- is.null(lib.loc)) 
    lib.loc <- .libPaths()
  bad <- character()
  out <- character()
  for (pkg in package) {
    paths <- file.path(lib.loc, pkg)
    paths <- paths[file.exists(file.path(paths, "DESCRIPTION"))]
    if (use_loaded && isNamespaceLoaded(pkg)) {
      dir <- if (pkg == "base") 
        system.file()
      else .getNamespaceInfo(asNamespace(pkg), "path")
      paths <- c(dir, paths)
    }
    if (length(paths) && file.exists(file.path(paths[1], "dummy_for_check"))) {
      bad <- c(bad, pkg)
      next
    }
    if (length(paths)) {
      paths <- unique(paths)
      valid_package_version_regexp <- .standard_regexps()$valid_package_version
      db <- lapply(paths, function(p) {
        pfile <- file.path(p, "Meta", "package.rds")
        info <- if (file.exists(pfile)) {
          tryCatch(readRDS(pfile)$DESCRIPTION[c("Package", "Version")], error = function(e) c(Package = NA, Version = NA))
        }
        else {
          info <- tryCatch(read.dcf(file.path(p, "DESCRIPTION"), c("Package", "Version"))[1, ], error = identity)
          if (inherits(info, "error") || (length(info) != 2) || anyNA(info)) 
            c(Package = NA, Version = NA)
          else info
        }
      })
      db <- do.call(rbind, db)
      ok <- (apply(!is.na(db), 1, all) & (db[, "Package"] == pkg) & (grepl(valid_package_version_regexp, db[, "Version"])))
      paths <- paths[ok]
    }
    if (length(paths) == 0) {
      bad <- c(bad, pkg)
      next
    }
    if (length(paths) > 1) {
      if (verbose) 
        warning(gettextf("package %s found more than once, using the first from\n  %s", sQuote(pkg), paste(dQuote(paths), collapse = ",\n  ")), domain = NA)
      paths <- paths[1]
    }
    out <- c(out, paths)
  }
  if (!quiet && length(bad)) {
    if (length(out) == 0) 
      stop(packageNotFoundError(bad, lib.loc, sys.call()))
    for (pkg in bad) warning(gettextf("there is no package called %s", sQuote(pkg)), domain = NA)
  }
  out
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
findInterval
list(`package:base` = function (x, vec, rightmost.closed = FALSE, all.inside = FALSE, left.open = FALSE) 
{
  if (!identical(FALSE, is.unsorted(vec))) 
    stop("'vec' must be sorted non-decreasingly and not contain NAs")
  .Internal(findInterval(as.double(vec), as.double(x), rightmost.closed, all.inside, left.open))
}, function (x, vec, rightmost.closed = FALSE, all.inside = FALSE, left.open = FALSE) 
{
  if (!identical(FALSE, is.unsorted(vec))) 
    stop("'vec' must be sorted non-decreasingly and not contain NAs")
  .Internal(findInterval(as.double(vec), as.double(x), rightmost.closed, all.inside, left.open))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
findPackageEnv
list(`package:base` = function (info) 
{
  if (info %in% search()) 
    return(as.environment(info))
  message(gettextf("Attempting to load the environment %s", sQuote(info)), domain = NA)
  if (require(substr(info, 9, 1000), character.only = TRUE, quietly = TRUE)) 
    return(as.environment(info))
  message("Specified environment not found: using '.GlobalEnv' instead")
  .GlobalEnv
}, function (info) 
{
  if (info %in% search()) 
    return(as.environment(info))
  message(gettextf("Attempting to load the environment %s", sQuote(info)), domain = NA)
  if (require(substr(info, 9, 1000), character.only = TRUE, quietly = TRUE)) 
    return(as.environment(info))
  message("Specified environment not found: using '.GlobalEnv' instead")
  .GlobalEnv
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
findRestart
list(`package:base` = function (name, cond = NULL) 
{
  i <- 1
  repeat {
    r <- .Internal(.getRestart(i))
    if (is.null(r)) 
      return(NULL)
    else if (name == r[[1]] && (is.null(cond) || is.null(r$test) || r$test(cond))) 
      return(r)
    else i <- i + 1
  }
}, function (name, cond = NULL) 
{
  i <- 1
  repeat {
    r <- .Internal(.getRestart(i))
    if (is.null(r)) 
      return(NULL)
    else if (name == r[[1]] && (is.null(cond) || is.null(r$test) || r$test(cond))) 
      return(r)
    else i <- i + 1
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
floor
list(`package:base` = .Primitive("floor"), .Primitive("floor"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
flush
list(`package:base` = function (con) 
  UseMethod("flush"), function (con) 
    UseMethod("flush"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
flush.connection
list(`package:base` = function (con) 
  .Internal(flush(con)), function (con) 
    .Internal(flush(con)), function (con) 
      .Internal(flush(con)))
c("package:base", "registered S3 method for flush from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
for
list(`package:base` = .Primitive("for"), .Primitive("for"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
force
list(`package:base` = function (x) 
  x, function (x) 
    x)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
forceAndCall
list(`package:base` = .Primitive("forceAndCall"), .Primitive("forceAndCall"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
formals
list(`package:base` = function (fun = sys.function(sys.parent()), envir = parent.frame()) 
{
  if (is.character(fun)) 
    fun <- get(fun, mode = "function", envir = envir)
  .Internal(formals(fun))
}, function (fun = sys.function(sys.parent()), envir = parent.frame()) 
{
  if (is.character(fun)) 
    fun <- get(fun, mode = "function", envir = envir)
  .Internal(formals(fun))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
formals<-
  list(`package:base` = function (fun, envir = environment(fun), value) 
  {
    if (!is.function(fun)) 
      warning("'fun' is not a function")
    bd <- body(fun)
    as.function(c(value, if (is.null(bd) || is.list(bd)) list(bd) else bd), envir)
  }, new("standardGeneric", .Data = function (fun, envir = environment(fun), value) 
    standardGeneric("formals<-"), generic = "formals<-", package = "base", group = list(), valueClass = character(0), signature = c("fun", "envir", "value"), default = new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      bd <- body(fun)
      as.function(c(value, if (is.null(bd) || is.list(bd)) list(bd) else bd), envir)
    }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "formals<-"), skeleton = (new("derivedDefaultMethod", .Data = function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      bd <- body(fun)
      as.function(c(value, if (is.null(bd) || is.list(bd)) list(bd) else bd), envir)
    }, target = new("signature", .Data = "ANY", names = "fun", package = "methods"), defined = new("signature", .Data = "ANY", names = "fun", package = "methods"), generic = "formals<-"))(fun, envir, value)), function (fun, envir = environment(fun), value) 
    {
      if (!is.function(fun)) 
        warning("'fun' is not a function")
      bd <- body(fun)
      as.function(c(value, if (is.null(bd) || is.list(bd)) list(bd) else bd), envir)
    })
c("package:base", "namespace:Rcpp", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
format
list(`package:base` = function (x, ...) 
  UseMethod("format"), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("format"), generic = "format", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
      UseMethod("format"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "format"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("format"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "format"))(x, ...)), function (x, ...) 
          UseMethod("format"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
format.AsIs
list(`package:base` = function (x, width = 12, ...) 
{
  if (is.character(x) || (is.atomic(x) && is.matrix(x))) 
    return(format.default(x, ...))
  if (is.null(width)) 
    width <- 12
  rvec <- vapply(x, function(y) {
    cl <- oldClass(y)
    if (m <- match("AsIs", cl, 0)) 
      oldClass(y) <- cl[-m]
    toString(y, width = width, ...)
  }, "")
  dim(rvec) <- dim(x)
  dimnames(rvec) <- dimnames(x)
  format.default(rvec, justify = "right")
}, function (x, width = 12, ...) 
{
  if (is.character(x) || (is.atomic(x) && is.matrix(x))) 
    return(format.default(x, ...))
  if (is.null(width)) 
    width <- 12
  rvec <- vapply(x, function(y) {
    cl <- oldClass(y)
    if (m <- match("AsIs", cl, 0)) 
      oldClass(y) <- cl[-m]
    toString(y, width = width, ...)
  }, "")
  dim(rvec) <- dim(x)
  dimnames(rvec) <- dimnames(x)
  format.default(rvec, justify = "right")
}, function (x, width = 12, ...) 
{
  if (is.character(x) || (is.atomic(x) && is.matrix(x))) 
    return(format.default(x, ...))
  if (is.null(width)) 
    width <- 12
  rvec <- vapply(x, function(y) {
    cl <- oldClass(y)
    if (m <- match("AsIs", cl, 0)) 
      oldClass(y) <- cl[-m]
    toString(y, width = width, ...)
  }, "")
  dim(rvec) <- dim(x)
  dimnames(rvec) <- dimnames(x)
  format.default(rvec, justify = "right")
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.data.frame
list(`package:base` = function (x, ..., justify = "none") 
{
  nc <- length(x)
  if (!nc) 
    return(x)
  nr <- .row_names_info(x, 2)
  rval <- vector("list", nc)
  for (i in seq_len(nc)) rval[[i]] <- format(x[[i]], ..., justify = justify)
  lens <- vapply(rval, NROW, 1)
  if (any(lens != nr)) {
    warning("corrupt data frame: columns will be truncated or padded with NAs")
    for (i in seq_len(nc)) {
      len <- NROW(rval[[i]])
      if (len == nr) 
        next
      if (length(dim(rval[[i]])) == 2) {
        rval[[i]] <- if (len < nr) 
          rbind(rval[[i]], matrix(NA, nr - len, ncol(rval[[i]])))
        else rval[[i]][seq_len(nr), ]
      }
      else {
        rval[[i]] <- if (len < nr) 
          c(rval[[i]], rep.int(NA, nr - len))
        else rval[[i]][seq_len(nr)]
      }
    }
  }
  for (i in seq_len(nc)) {
    if (is.character(rval[[i]]) && inherits(rval[[i]], "character")) 
      oldClass(rval[[i]]) <- "AsIs"
  }
  y <- as.data.frame.list(rval, row.names = seq_len(nr), col.names = names(x), optional = TRUE, fix.empty.names = FALSE, cut.names = TRUE)
  attr(y, "row.names") <- row.names(x)
  y
}, function (x, ..., justify = "none") 
{
  nc <- length(x)
  if (!nc) 
    return(x)
  nr <- .row_names_info(x, 2)
  rval <- vector("list", nc)
  for (i in seq_len(nc)) rval[[i]] <- format(x[[i]], ..., justify = justify)
  lens <- vapply(rval, NROW, 1)
  if (any(lens != nr)) {
    warning("corrupt data frame: columns will be truncated or padded with NAs")
    for (i in seq_len(nc)) {
      len <- NROW(rval[[i]])
      if (len == nr) 
        next
      if (length(dim(rval[[i]])) == 2) {
        rval[[i]] <- if (len < nr) 
          rbind(rval[[i]], matrix(NA, nr - len, ncol(rval[[i]])))
        else rval[[i]][seq_len(nr), ]
      }
      else {
        rval[[i]] <- if (len < nr) 
          c(rval[[i]], rep.int(NA, nr - len))
        else rval[[i]][seq_len(nr)]
      }
    }
  }
  for (i in seq_len(nc)) {
    if (is.character(rval[[i]]) && inherits(rval[[i]], "character")) 
      oldClass(rval[[i]]) <- "AsIs"
  }
  y <- as.data.frame.list(rval, row.names = seq_len(nr), col.names = names(x), optional = TRUE, fix.empty.names = FALSE, cut.names = TRUE)
  attr(y, "row.names") <- row.names(x)
  y
}, function (x, ..., justify = "none") 
{
  nc <- length(x)
  if (!nc) 
    return(x)
  nr <- .row_names_info(x, 2)
  rval <- vector("list", nc)
  for (i in seq_len(nc)) rval[[i]] <- format(x[[i]], ..., justify = justify)
  lens <- vapply(rval, NROW, 1)
  if (any(lens != nr)) {
    warning("corrupt data frame: columns will be truncated or padded with NAs")
    for (i in seq_len(nc)) {
      len <- NROW(rval[[i]])
      if (len == nr) 
        next
      if (length(dim(rval[[i]])) == 2) {
        rval[[i]] <- if (len < nr) 
          rbind(rval[[i]], matrix(NA, nr - len, ncol(rval[[i]])))
        else rval[[i]][seq_len(nr), ]
      }
      else {
        rval[[i]] <- if (len < nr) 
          c(rval[[i]], rep.int(NA, nr - len))
        else rval[[i]][seq_len(nr)]
      }
    }
  }
  for (i in seq_len(nc)) {
    if (is.character(rval[[i]]) && inherits(rval[[i]], "character")) 
      oldClass(rval[[i]]) <- "AsIs"
  }
  y <- as.data.frame.list(rval, row.names = seq_len(nr), col.names = names(x), optional = TRUE, fix.empty.names = FALSE, cut.names = TRUE)
  attr(y, "row.names") <- row.names(x)
  y
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.Date
list(`package:base` = function (x, ...) 
{
  xx <- format(as.POSIXlt(x), ...)
  names(xx) <- names(x)
  xx
}, function (x, ...) 
{
  xx <- format(as.POSIXlt(x), ...)
  names(xx) <- names(x)
  xx
}, function (x, ...) 
{
  xx <- format(as.POSIXlt(x), ...)
  names(xx) <- names(x)
  xx
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.default
list(`package:base` = function (x, trim = FALSE, digits = NULL, nsmall = 0, justify = c("left", "right", "centre", "none"), width = NULL, na.encode = TRUE, scientific = NA, big.mark = "", big.interval = 3, small.mark = "", small.interval = 5, decimal.mark = getOption("OutDec"), zero.print = NULL, drop0trailing = FALSE, ...) 
{
  justify <- match.arg(justify)
  if (is.list(x)) {
    if (missing(trim)) 
      trim <- TRUE
    if (missing(justify)) 
      justify <- "none"
    res <- lapply(X = x, FUN = function(xx, ...) format.default(unlist(xx), ...), trim = trim, digits = digits, nsmall = nsmall, justify = justify, width = width, na.encode = na.encode, scientific = scientific, big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, zero.print = zero.print, drop0trailing = drop0trailing, ...)
    vapply(res, paste, "", collapse = ", ")
  }
  else {
    switch(mode(x), `NULL` = "NULL", character = {
      adj <- match(justify, c("left", "right", "centre", "none")) - 1
      .Internal(format(x, trim, digits, nsmall, width, adj, na.encode, scientific, NA))
    }, call = , expression = , `function` = , `(` = deparse(x, backtick = TRUE), name = deparse(x, backtick = FALSE), raw = as.character(x), S4 = {
      cld <- methods::getClassDef(cl <- class(x))
      pkg <- attr(cl, "package")
      paste0("<S4 class ", sQuote(cl), if (!is.null(pkg)) paste0(" [package ", dQuote(pkg), "]"), if (!is.null(cld) && !is.null(sls <- cld@slots)) paste(" with", length(sls), if (length(sls) == 1) "slot" else "slots"), ">")
    }, numeric = , logical = , complex = , externalptr = , environment = prettyNum(.Internal(format(x, trim, digits, nsmall, width, 3, na.encode, scientific, decimal.mark)), big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, input.d.mark = decimal.mark, zero.print = zero.print, drop0trailing = drop0trailing, is.cmplx = is.complex(x), preserve.width = if (trim) "individual" else "common"), stop(gettextf("Found no format() method for class \"%s\"", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            class(x)), domain = NA))
  }
}, function (x, trim = FALSE, digits = NULL, nsmall = 0, justify = c("left", "right", "centre", "none"), width = NULL, na.encode = TRUE, scientific = NA, big.mark = "", big.interval = 3, small.mark = "", small.interval = 5, decimal.mark = getOption("OutDec"), zero.print = NULL, drop0trailing = FALSE, ...) 
{
  justify <- match.arg(justify)
  if (is.list(x)) {
    if (missing(trim)) 
      trim <- TRUE
    if (missing(justify)) 
      justify <- "none"
    res <- lapply(X = x, FUN = function(xx, ...) format.default(unlist(xx), ...), trim = trim, digits = digits, nsmall = nsmall, justify = justify, width = width, na.encode = na.encode, scientific = scientific, big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, zero.print = zero.print, drop0trailing = drop0trailing, ...)
    vapply(res, paste, "", collapse = ", ")
  }
  else {
    switch(mode(x), `NULL` = "NULL", character = {
      adj <- match(justify, c("left", "right", "centre", "none")) - 1
      .Internal(format(x, trim, digits, nsmall, width, adj, na.encode, scientific, NA))
    }, call = , expression = , `function` = , `(` = deparse(x, backtick = TRUE), name = deparse(x, backtick = FALSE), raw = as.character(x), S4 = {
      cld <- methods::getClassDef(cl <- class(x))
      pkg <- attr(cl, "package")
      paste0("<S4 class ", sQuote(cl), if (!is.null(pkg)) paste0(" [package ", dQuote(pkg), "]"), if (!is.null(cld) && !is.null(sls <- cld@slots)) paste(" with", length(sls), if (length(sls) == 1) "slot" else "slots"), ">")
    }, numeric = , logical = , complex = , externalptr = , environment = prettyNum(.Internal(format(x, trim, digits, nsmall, width, 3, na.encode, scientific, decimal.mark)), big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, input.d.mark = decimal.mark, zero.print = zero.print, drop0trailing = drop0trailing, is.cmplx = is.complex(x), preserve.width = if (trim) "individual" else "common"), stop(gettextf("Found no format() method for class \"%s\"", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            class(x)), domain = NA))
  }
}, function (x, trim = FALSE, digits = NULL, nsmall = 0, justify = c("left", "right", "centre", "none"), width = NULL, na.encode = TRUE, scientific = NA, big.mark = "", big.interval = 3, small.mark = "", small.interval = 5, decimal.mark = getOption("OutDec"), zero.print = NULL, drop0trailing = FALSE, ...) 
{
  justify <- match.arg(justify)
  if (is.list(x)) {
    if (missing(trim)) 
      trim <- TRUE
    if (missing(justify)) 
      justify <- "none"
    res <- lapply(X = x, FUN = function(xx, ...) format.default(unlist(xx), ...), trim = trim, digits = digits, nsmall = nsmall, justify = justify, width = width, na.encode = na.encode, scientific = scientific, big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, zero.print = zero.print, drop0trailing = drop0trailing, ...)
    vapply(res, paste, "", collapse = ", ")
  }
  else {
    switch(mode(x), `NULL` = "NULL", character = {
      adj <- match(justify, c("left", "right", "centre", "none")) - 1
      .Internal(format(x, trim, digits, nsmall, width, adj, na.encode, scientific, NA))
    }, call = , expression = , `function` = , `(` = deparse(x, backtick = TRUE), name = deparse(x, backtick = FALSE), raw = as.character(x), S4 = {
      cld <- methods::getClassDef(cl <- class(x))
      pkg <- attr(cl, "package")
      paste0("<S4 class ", sQuote(cl), if (!is.null(pkg)) paste0(" [package ", dQuote(pkg), "]"), if (!is.null(cld) && !is.null(sls <- cld@slots)) paste(" with", length(sls), if (length(sls) == 1) "slot" else "slots"), ">")
    }, numeric = , logical = , complex = , externalptr = , environment = prettyNum(.Internal(format(x, trim, digits, nsmall, width, 3, na.encode, scientific, decimal.mark)), big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, input.d.mark = decimal.mark, zero.print = zero.print, drop0trailing = drop0trailing, is.cmplx = is.complex(x), preserve.width = if (trim) "individual" else "common"), stop(gettextf("Found no format() method for class \"%s\"", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            class(x)), domain = NA))
  }
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.difftime
list(`package:base` = function (x, ...) 
  paste(format(unclass(x), ...), units(x)), function (x, ...) 
    paste(format(unclass(x), ...), units(x)), function (x, ...) 
      paste(format(unclass(x), ...), units(x)))
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.factor
list(`package:base` = function (x, ...) 
  format(structure(as.character(x), names = names(x), dim = dim(x), dimnames = dimnames(x)), ...), function (x, ...) 
    format(structure(as.character(x), names = names(x), dim = dim(x), dimnames = dimnames(x)), ...), function (x, ...) 
      format(structure(as.character(x), names = names(x), dim = dim(x), dimnames = dimnames(x)), ...))
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.hexmode
list(`package:base` = function (x, width = NULL, upper.case = FALSE, ...) 
{
  isna <- is.na(x)
  y <- as.integer(x[!isna])
  fmt0 <- if (upper.case) 
    "X"
  else "x"
  fmt <- if (!is.null(width)) 
    paste0("%0", width, fmt0)
  else paste0("%", fmt0)
  ans <- rep.int(NA, length(x))
  ans0 <- sprintf(fmt, y)
  if (is.null(width) && length(y) > 1) {
    nc <- max(nchar(ans0))
    ans0 <- sprintf(paste0("%0", nc, fmt0), y)
  }
  ans[!isna] <- ans0
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
}, function (x, width = NULL, upper.case = FALSE, ...) 
{
  isna <- is.na(x)
  y <- as.integer(x[!isna])
  fmt0 <- if (upper.case) 
    "X"
  else "x"
  fmt <- if (!is.null(width)) 
    paste0("%0", width, fmt0)
  else paste0("%", fmt0)
  ans <- rep.int(NA, length(x))
  ans0 <- sprintf(fmt, y)
  if (is.null(width) && length(y) > 1) {
    nc <- max(nchar(ans0))
    ans0 <- sprintf(paste0("%0", nc, fmt0), y)
  }
  ans[!isna] <- ans0
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
}, function (x, width = NULL, upper.case = FALSE, ...) 
{
  isna <- is.na(x)
  y <- as.integer(x[!isna])
  fmt0 <- if (upper.case) 
    "X"
  else "x"
  fmt <- if (!is.null(width)) 
    paste0("%0", width, fmt0)
  else paste0("%", fmt0)
  ans <- rep.int(NA, length(x))
  ans0 <- sprintf(fmt, y)
  if (is.null(width) && length(y) > 1) {
    nc <- max(nchar(ans0))
    ans0 <- sprintf(paste0("%0", nc, fmt0), y)
  }
  ans[!isna] <- ans0
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.info
list(`package:base` = function (x, digits = NULL, nsmall = 0) 
  .Internal(format.info(x, digits, nsmall)), function (x, digits = NULL, nsmall = 0) 
    .Internal(format.info(x, digits, nsmall)), function (x, digits = NULL, nsmall = 0) 
      .Internal(format.info(x, digits, nsmall)))
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.libraryIQR
list(`package:base` = function (x, ...) 
{
  db <- x$results
  if (!nrow(db)) 
    return(character())
  libs <- db[, "LibPath"]
  libs <- factor(libs, levels = unique(libs))
  out <- lapply(split(1:nrow(db), libs), function(ind) db[ind, c("Package", "Title"), drop = FALSE])
  c(unlist(Map(function(lib, sep) {
    c(gettextf("%sPackages in library %s:\n", sep, sQuote(lib)), formatDL(out[[lib]][, "Package"], out[[lib]][, "Title"]))
  }, names(out), c("", rep.int("\n", length(out) - 1)))), x$footer)
}, function (x, ...) 
{
  db <- x$results
  if (!nrow(db)) 
    return(character())
  libs <- db[, "LibPath"]
  libs <- factor(libs, levels = unique(libs))
  out <- lapply(split(1:nrow(db), libs), function(ind) db[ind, c("Package", "Title"), drop = FALSE])
  c(unlist(Map(function(lib, sep) {
    c(gettextf("%sPackages in library %s:\n", sep, sQuote(lib)), formatDL(out[[lib]][, "Package"], out[[lib]][, "Title"]))
  }, names(out), c("", rep.int("\n", length(out) - 1)))), x$footer)
}, function (x, ...) 
{
  db <- x$results
  if (!nrow(db)) 
    return(character())
  libs <- db[, "LibPath"]
  libs <- factor(libs, levels = unique(libs))
  out <- lapply(split(1:nrow(db), libs), function(ind) db[ind, c("Package", "Title"), drop = FALSE])
  c(unlist(Map(function(lib, sep) {
    c(gettextf("%sPackages in library %s:\n", sep, sQuote(lib)), formatDL(out[[lib]][, "Package"], out[[lib]][, "Title"]))
  }, names(out), c("", rep.int("\n", length(out) - 1)))), x$footer)
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.numeric_version
list(`package:base` = function (x, ...) 
{
  x <- unclass(x)
  y <- rep.int(NA, length(x))
  names(y) <- names(x)
  ind <- lengths(x) > 0
  y[ind] <- unlist(lapply(x[ind], paste, collapse = "."))
  y
}, function (x, ...) 
{
  x <- unclass(x)
  y <- rep.int(NA, length(x))
  names(y) <- names(x)
  ind <- lengths(x) > 0
  y[ind] <- unlist(lapply(x[ind], paste, collapse = "."))
  y
}, function (x, ...) 
{
  x <- unclass(x)
  y <- rep.int(NA, length(x))
  names(y) <- names(x)
  ind <- lengths(x) > 0
  y[ind] <- unlist(lapply(x[ind], paste, collapse = "."))
  y
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.octmode
list(`package:base` = function (x, width = NULL, ...) 
{
  isna <- is.na(x)
  y <- as.integer(x[!isna])
  fmt <- if (!is.null(width)) 
    paste0("%0", width, "o")
  else "%o"
  ans <- rep.int(NA, length(x))
  ans0 <- sprintf(fmt, y)
  if (is.null(width) && length(y) > 1) {
    nc <- max(nchar(ans0))
    ans0 <- sprintf(paste0("%0", nc, "o"), y)
  }
  ans[!isna] <- ans0
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
}, function (x, width = NULL, ...) 
{
  isna <- is.na(x)
  y <- as.integer(x[!isna])
  fmt <- if (!is.null(width)) 
    paste0("%0", width, "o")
  else "%o"
  ans <- rep.int(NA, length(x))
  ans0 <- sprintf(fmt, y)
  if (is.null(width) && length(y) > 1) {
    nc <- max(nchar(ans0))
    ans0 <- sprintf(paste0("%0", nc, "o"), y)
  }
  ans[!isna] <- ans0
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
}, function (x, width = NULL, ...) 
{
  isna <- is.na(x)
  y <- as.integer(x[!isna])
  fmt <- if (!is.null(width)) 
    paste0("%0", width, "o")
  else "%o"
  ans <- rep.int(NA, length(x))
  ans0 <- sprintf(fmt, y)
  if (is.null(width) && length(y) > 1) {
    nc <- max(nchar(ans0))
    ans0 <- sprintf(paste0("%0", nc, "o"), y)
  }
  ans[!isna] <- ans0
  dim(ans) <- dim(x)
  dimnames(ans) <- dimnames(x)
  names(ans) <- names(x)
  ans
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.packageInfo
list(`package:base` = function (x, ...) 
{
  if (!inherits(x, "packageInfo")) 
    stop("wrong class")
  vignetteMsg <- gettextf("Further information is available in the following vignettes in directory %s:", sQuote(file.path(x$path, "doc")))
  headers <- sprintf("\n%s\n", c(gettext("Description:"), gettext("Index:"), paste(strwrap(vignetteMsg), collapse = "\n")))
  formatDocEntry <- function(entry) {
    if (is.list(entry) || is.matrix(entry)) 
      formatDL(entry, style = "list")
    else entry
  }
  c(gettextf("\n\t\tInformation on package %s", sQuote(x$name)), unlist(lapply(which(!vapply(x$info, is.null, NA)), function(i) c(headers[i], formatDocEntry(x$info[[i]])))))
}, function (x, ...) 
{
  if (!inherits(x, "packageInfo")) 
    stop("wrong class")
  vignetteMsg <- gettextf("Further information is available in the following vignettes in directory %s:", sQuote(file.path(x$path, "doc")))
  headers <- sprintf("\n%s\n", c(gettext("Description:"), gettext("Index:"), paste(strwrap(vignetteMsg), collapse = "\n")))
  formatDocEntry <- function(entry) {
    if (is.list(entry) || is.matrix(entry)) 
      formatDL(entry, style = "list")
    else entry
  }
  c(gettextf("\n\t\tInformation on package %s", sQuote(x$name)), unlist(lapply(which(!vapply(x$info, is.null, NA)), function(i) c(headers[i], formatDocEntry(x$info[[i]])))))
}, function (x, ...) 
{
  if (!inherits(x, "packageInfo")) 
    stop("wrong class")
  vignetteMsg <- gettextf("Further information is available in the following vignettes in directory %s:", sQuote(file.path(x$path, "doc")))
  headers <- sprintf("\n%s\n", c(gettext("Description:"), gettext("Index:"), paste(strwrap(vignetteMsg), collapse = "\n")))
  formatDocEntry <- function(entry) {
    if (is.list(entry) || is.matrix(entry)) 
      formatDL(entry, style = "list")
    else entry
  }
  c(gettextf("\n\t\tInformation on package %s", sQuote(x$name)), unlist(lapply(which(!vapply(x$info, is.null, NA)), function(i) c(headers[i], formatDocEntry(x$info[[i]])))))
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.POSIXct
list(`package:base` = function (x, format = "", tz = "", usetz = FALSE, ...) 
{
  if (!inherits(x, "POSIXct")) 
    stop("wrong class")
  if (missing(tz) && !is.null(tzone <- attr(x, "tzone"))) 
    tz <- tzone
  structure(format.POSIXlt(as.POSIXlt(x, tz), format, usetz, ...), names = names(x))
}, function (x, format = "", tz = "", usetz = FALSE, ...) 
{
  if (!inherits(x, "POSIXct")) 
    stop("wrong class")
  if (missing(tz) && !is.null(tzone <- attr(x, "tzone"))) 
    tz <- tzone
  structure(format.POSIXlt(as.POSIXlt(x, tz), format, usetz, ...), names = names(x))
}, function (x, format = "", tz = "", usetz = FALSE, ...) 
{
  if (!inherits(x, "POSIXct")) 
    stop("wrong class")
  if (missing(tz) && !is.null(tzone <- attr(x, "tzone"))) 
    tz <- tzone
  structure(format.POSIXlt(as.POSIXlt(x, tz), format, usetz, ...), names = names(x))
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.POSIXlt
list(`package:base` = function (x, format = "", usetz = FALSE, digits = getOption("digits.secs"), ...) 
{
  if (!inherits(x, "POSIXlt")) 
    stop("wrong class")
  if (any(f0 <- format == "")) {
    times <- unlist(unclass(x)[1:3])[f0]
    secs <- x$sec[f0]
    secs <- secs[is.finite(secs)]
    np <- if (is.null(digits)) 
      0
    else min(6, digits)
    if (np >= 1) 
      for (i in seq_len(np) - 1) if (all(abs(secs - round(secs, i)) < 1e-06)) {
        np <- i
        break
      }
    format[f0] <- if (all(times[is.finite(times)] == 0)) 
      "%Y-%m-%d"
    else if (np == 0) 
      "%Y-%m-%d %H:%M:%S"
    else paste0("%Y-%m-%d %H:%M:%OS", np)
  }
  y <- .Internal(format.POSIXlt(x, format, usetz))
  names(y) <- names(x$year)
  y
}, function (x, format = "", usetz = FALSE, digits = getOption("digits.secs"), ...) 
{
  if (!inherits(x, "POSIXlt")) 
    stop("wrong class")
  if (any(f0 <- format == "")) {
    times <- unlist(unclass(x)[1:3])[f0]
    secs <- x$sec[f0]
    secs <- secs[is.finite(secs)]
    np <- if (is.null(digits)) 
      0
    else min(6, digits)
    if (np >= 1) 
      for (i in seq_len(np) - 1) if (all(abs(secs - round(secs, i)) < 1e-06)) {
        np <- i
        break
      }
    format[f0] <- if (all(times[is.finite(times)] == 0)) 
      "%Y-%m-%d"
    else if (np == 0) 
      "%Y-%m-%d %H:%M:%S"
    else paste0("%Y-%m-%d %H:%M:%OS", np)
  }
  y <- .Internal(format.POSIXlt(x, format, usetz))
  names(y) <- names(x$year)
  y
}, function (x, format = "", usetz = FALSE, digits = getOption("digits.secs"), ...) 
{
  if (!inherits(x, "POSIXlt")) 
    stop("wrong class")
  if (any(f0 <- format == "")) {
    times <- unlist(unclass(x)[1:3])[f0]
    secs <- x$sec[f0]
    secs <- secs[is.finite(secs)]
    np <- if (is.null(digits)) 
      0
    else min(6, digits)
    if (np >= 1) 
      for (i in seq_len(np) - 1) if (all(abs(secs - round(secs, i)) < 1e-06)) {
        np <- i
        break
      }
    format[f0] <- if (all(times[is.finite(times)] == 0)) 
      "%Y-%m-%d"
    else if (np == 0) 
      "%Y-%m-%d %H:%M:%S"
    else paste0("%Y-%m-%d %H:%M:%OS", np)
  }
  y <- .Internal(format.POSIXlt(x, format, usetz))
  names(y) <- names(x$year)
  y
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.pval
list(`package:base` = function (pv, digits = max(1, getOption("digits") - 2), eps = .Machine$double.eps, na.form = "NA", ...) 
{
  if ((has.na <- any(ina <- is.na(pv)))) 
    pv <- pv[!ina]
  r <- character(length(is0 <- pv < eps))
  if (any(!is0)) {
    rr <- pv <- pv[!is0]
    expo <- floor(log10(ifelse(pv > 0, pv, 1e-50)))
    fixp <- expo >= -3 | (expo == -4 & digits > 1)
    if (any(fixp)) 
      rr[fixp] <- format(pv[fixp], digits = digits, ...)
    if (any(!fixp)) 
      rr[!fixp] <- format(pv[!fixp], digits = digits, ...)
    r[!is0] <- rr
  }
  if (any(is0)) {
    digits <- max(1, digits - 2)
    if (any(!is0)) {
      nc <- max(nchar(rr, type = "w"))
      if (digits > 1 && digits + 6 > nc) 
        digits <- max(1, nc - 7)
      sep <- if (digits == 1 && nc <= 6) 
        ""
      else " "
    }
    else sep <- if (digits == 1) 
      ""
    else " "
    r[is0] <- paste("<", format(eps, digits = digits, ...), sep = sep)
  }
  if (has.na) {
    rok <- r
    r <- character(length(ina))
    r[!ina] <- rok
    r[ina] <- na.form
  }
  r
}, function (pv, digits = max(1, getOption("digits") - 2), eps = .Machine$double.eps, na.form = "NA", ...) 
{
  if ((has.na <- any(ina <- is.na(pv)))) 
    pv <- pv[!ina]
  r <- character(length(is0 <- pv < eps))
  if (any(!is0)) {
    rr <- pv <- pv[!is0]
    expo <- floor(log10(ifelse(pv > 0, pv, 1e-50)))
    fixp <- expo >= -3 | (expo == -4 & digits > 1)
    if (any(fixp)) 
      rr[fixp] <- format(pv[fixp], digits = digits, ...)
    if (any(!fixp)) 
      rr[!fixp] <- format(pv[!fixp], digits = digits, ...)
    r[!is0] <- rr
  }
  if (any(is0)) {
    digits <- max(1, digits - 2)
    if (any(!is0)) {
      nc <- max(nchar(rr, type = "w"))
      if (digits > 1 && digits + 6 > nc) 
        digits <- max(1, nc - 7)
      sep <- if (digits == 1 && nc <= 6) 
        ""
      else " "
    }
    else sep <- if (digits == 1) 
      ""
    else " "
    r[is0] <- paste("<", format(eps, digits = digits, ...), sep = sep)
  }
  if (has.na) {
    rok <- r
    r <- character(length(ina))
    r[!ina] <- rok
    r[ina] <- na.form
  }
  r
}, function (pv, digits = max(1, getOption("digits") - 2), eps = .Machine$double.eps, na.form = "NA", ...) 
{
  if ((has.na <- any(ina <- is.na(pv)))) 
    pv <- pv[!ina]
  r <- character(length(is0 <- pv < eps))
  if (any(!is0)) {
    rr <- pv <- pv[!is0]
    expo <- floor(log10(ifelse(pv > 0, pv, 1e-50)))
    fixp <- expo >= -3 | (expo == -4 & digits > 1)
    if (any(fixp)) 
      rr[fixp] <- format(pv[fixp], digits = digits, ...)
    if (any(!fixp)) 
      rr[!fixp] <- format(pv[!fixp], digits = digits, ...)
    r[!is0] <- rr
  }
  if (any(is0)) {
    digits <- max(1, digits - 2)
    if (any(!is0)) {
      nc <- max(nchar(rr, type = "w"))
      if (digits > 1 && digits + 6 > nc) 
        digits <- max(1, nc - 7)
      sep <- if (digits == 1 && nc <= 6) 
        ""
      else " "
    }
    else sep <- if (digits == 1) 
      ""
    else " "
    r[is0] <- paste("<", format(eps, digits = digits, ...), sep = sep)
  }
  if (has.na) {
    rok <- r
    r <- character(length(ina))
    r[!ina] <- rok
    r[ina] <- na.form
  }
  r
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
format.summaryDefault
list(`package:base` = function (x, digits = max(3, getOption("digits") - 3), ...) 
{
  xx <- x
  if (is.numeric(x) || is.complex(x)) {
    finite <- is.finite(x)
    xx[finite] <- zapsmall(x[finite])
  }
  class(xx) <- class(x)[-1]
  m <- match("NA's", names(x), 0)
  if (inherits(x, "Date") || inherits(x, "POSIXct")) {
    if (length(a <- attr(x, "NAs"))) 
      c(format(xx, digits = digits, ...), `NA's` = as.character(a))
    else format(xx, digits = digits)
  }
  else if (m && !is.character(x)) 
    xx <- c(format(xx[-m], digits = digits, ...), `NA's` = as.character(xx[m]))
  else format(xx, digits = digits, ...)
}, function (x, digits = max(3, getOption("digits") - 3), ...) 
{
  xx <- x
  if (is.numeric(x) || is.complex(x)) {
    finite <- is.finite(x)
    xx[finite] <- zapsmall(x[finite])
  }
  class(xx) <- class(x)[-1]
  m <- match("NA's", names(x), 0)
  if (inherits(x, "Date") || inherits(x, "POSIXct")) {
    if (length(a <- attr(x, "NAs"))) 
      c(format(xx, digits = digits, ...), `NA's` = as.character(a))
    else format(xx, digits = digits)
  }
  else if (m && !is.character(x)) 
    xx <- c(format(xx[-m], digits = digits, ...), `NA's` = as.character(xx[m]))
  else format(xx, digits = digits, ...)
}, function (x, digits = max(3, getOption("digits") - 3), ...) 
{
  xx <- x
  if (is.numeric(x) || is.complex(x)) {
    finite <- is.finite(x)
    xx[finite] <- zapsmall(x[finite])
  }
  class(xx) <- class(x)[-1]
  m <- match("NA's", names(x), 0)
  if (inherits(x, "Date") || inherits(x, "POSIXct")) {
    if (length(a <- attr(x, "NAs"))) 
      c(format(xx, digits = digits, ...), `NA's` = as.character(a))
    else format(xx, digits = digits)
  }
  else if (m && !is.character(x)) 
    xx <- c(format(xx[-m], digits = digits, ...), `NA's` = as.character(xx[m]))
  else format(xx, digits = digits, ...)
})
c("package:base", "registered S3 method for format from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
formatC
list(`package:base` = function (x, digits = NULL, width = NULL, format = NULL, flag = "", mode = NULL, big.mark = "", big.interval = 3, small.mark = "", small.interval = 5, decimal.mark = getOption("OutDec"), preserve.width = "individual", zero.print = NULL, replace.zero = TRUE, drop0trailing = FALSE) 
{
  if (is.object(x)) {
    if (!(is.atomic(x) || inherits(x, "vector"))) 
      warning("class of 'x' was discarded")
    x <- unclass(x)
  }
  flag <- as.character(flag)
  if (length(flag) != 1) 
    stop("'flag' must be a string, i.e., of length 1")
  nf <- strsplit(flag, "")[[1]]
  if (!all(nf %in% c("0", "+", "-", " ", "#", "'", "I"))) 
    stop("'flag' should contain only characters from [0+- #'I]")
  format.char <- function(x, width, flag) {
    if (is.null(width)) 
      width <- 0
    else if (width < 0) {
      flag <- "-"
      width <- -width
    }
    format.default(x, width = width, justify = if (flag == "-") 
      "left"
      else "right")
  }
  if (!(n <- length(x))) 
    return(character())
  if (is.null(mode)) 
    mode <- storage.mode(x)
  else if (any(mode == c("double", "real", "integer"))) {
    if (mode == "real") 
      mode <- "double"
    storage.mode(x) <- mode
  }
  else if (mode != "character") 
    stop("'mode' must be \"double\" (\"real\"), \"integer\" or \"character\"")
  if (mode == "character" || (!is.null(format) && format == "s")) {
    if (mode != "character") {
      warning("coercing argument to \"character\" for format=\"s\"")
      x <- as.character(x)
    }
    return(format.char(x, width = width, flag = flag))
  }
  if (missing(format) || is.null(format)) 
    format <- if (mode == "integer") 
      "d"
  else "g"
  else {
    if (any(format == c("f", "e", "E", "g", "G", "fg"))) {
      if (mode == "integer") 
        mode <- storage.mode(x) <- "double"
    }
    else if (format == "d") {
      if (mode != "integer") 
        mode <- storage.mode(x) <- "integer"
    }
    else stop("'format' must be one of {\"f\",\"e\",\"E\",\"g\",\"G\", \"fg\", \"s\"}")
  }
  some.special <- !all(Ok <- is.finite(x))
  if (some.special) {
    rQ <- as.character(x[!Ok])
    rQ[is.na(rQ)] <- "NA"
    x[!Ok] <- as.vector(0, mode = mode)
  }
  if (is.null(width) && is.null(digits)) 
    width <- 1
  if (is.null(digits)) 
    digits <- if (mode == "integer") 
      2
  else 4
  else if (digits < 0) 
    digits <- 6
  else {
    maxDigits <- if (format != "f") 
      50
    else ceiling(-(.Machine$double.neg.ulp.digits + .Machine$double.min.exp)/log2(10))
    if (digits > maxDigits) {
      warning(gettextf("'digits' reduced to %d", maxDigits), domain = NA)
      digits <- maxDigits
    }
  }
  if (is.null(width)) 
    width <- digits + 1
  else if (width == 0) 
    width <- digits
  i.strlen <- pmax(abs(as.integer(width)), if (format == "fg" || format == "f") {
    xEx <- as.integer(floor(log10(abs(x + (x == 0)))))
    as.integer(x < 0 | flag != "") + digits + if (format == "f") {
      2 + pmax(xEx, 0)
    }
    else {
      1 + pmax(xEx, digits, digits + (-xEx) + 1) + length(nf)
    }
  }
  else rep.int(digits + 8, n))
  if (digits > 0 && any(nf == "#")) 
    digits <- -digits
  attr(x, "Csingle") <- NULL
  r <- .Internal(formatC(x, as.character(mode), width, digits, as.character(format), flag, i.strlen))
  if (some.special) 
    r[!Ok] <- format.char(rQ, width = width, flag = flag)
  if (nzchar(big.mark) || nzchar(small.mark) || decimal.mark != "." || !is.null(zero.print) || drop0trailing) 
    r <- prettyNum(r, big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, input.d.mark = ".", preserve.width = preserve.width, zero.print = zero.print, replace.zero = replace.zero, drop0trailing = drop0trailing, is.cmplx = FALSE)
  if (!is.null(x.atr <- attributes(x))) 
    attributes(r) <- x.atr
  r
}, function (x, digits = NULL, width = NULL, format = NULL, flag = "", mode = NULL, big.mark = "", big.interval = 3, small.mark = "", small.interval = 5, decimal.mark = getOption("OutDec"), preserve.width = "individual", zero.print = NULL, replace.zero = TRUE, drop0trailing = FALSE) 
{
  if (is.object(x)) {
    if (!(is.atomic(x) || inherits(x, "vector"))) 
      warning("class of 'x' was discarded")
    x <- unclass(x)
  }
  flag <- as.character(flag)
  if (length(flag) != 1) 
    stop("'flag' must be a string, i.e., of length 1")
  nf <- strsplit(flag, "")[[1]]
  if (!all(nf %in% c("0", "+", "-", " ", "#", "'", "I"))) 
    stop("'flag' should contain only characters from [0+- #'I]")
  format.char <- function(x, width, flag) {
    if (is.null(width)) 
      width <- 0
    else if (width < 0) {
      flag <- "-"
      width <- -width
    }
    format.default(x, width = width, justify = if (flag == "-") 
      "left"
      else "right")
  }
  if (!(n <- length(x))) 
    return(character())
  if (is.null(mode)) 
    mode <- storage.mode(x)
  else if (any(mode == c("double", "real", "integer"))) {
    if (mode == "real") 
      mode <- "double"
    storage.mode(x) <- mode
  }
  else if (mode != "character") 
    stop("'mode' must be \"double\" (\"real\"), \"integer\" or \"character\"")
  if (mode == "character" || (!is.null(format) && format == "s")) {
    if (mode != "character") {
      warning("coercing argument to \"character\" for format=\"s\"")
      x <- as.character(x)
    }
    return(format.char(x, width = width, flag = flag))
  }
  if (missing(format) || is.null(format)) 
    format <- if (mode == "integer") 
      "d"
  else "g"
  else {
    if (any(format == c("f", "e", "E", "g", "G", "fg"))) {
      if (mode == "integer") 
        mode <- storage.mode(x) <- "double"
    }
    else if (format == "d") {
      if (mode != "integer") 
        mode <- storage.mode(x) <- "integer"
    }
    else stop("'format' must be one of {\"f\",\"e\",\"E\",\"g\",\"G\", \"fg\", \"s\"}")
  }
  some.special <- !all(Ok <- is.finite(x))
  if (some.special) {
    rQ <- as.character(x[!Ok])
    rQ[is.na(rQ)] <- "NA"
    x[!Ok] <- as.vector(0, mode = mode)
  }
  if (is.null(width) && is.null(digits)) 
    width <- 1
  if (is.null(digits)) 
    digits <- if (mode == "integer") 
      2
  else 4
  else if (digits < 0) 
    digits <- 6
  else {
    maxDigits <- if (format != "f") 
      50
    else ceiling(-(.Machine$double.neg.ulp.digits + .Machine$double.min.exp)/log2(10))
    if (digits > maxDigits) {
      warning(gettextf("'digits' reduced to %d", maxDigits), domain = NA)
      digits <- maxDigits
    }
  }
  if (is.null(width)) 
    width <- digits + 1
  else if (width == 0) 
    width <- digits
  i.strlen <- pmax(abs(as.integer(width)), if (format == "fg" || format == "f") {
    xEx <- as.integer(floor(log10(abs(x + (x == 0)))))
    as.integer(x < 0 | flag != "") + digits + if (format == "f") {
      2 + pmax(xEx, 0)
    }
    else {
      1 + pmax(xEx, digits, digits + (-xEx) + 1) + length(nf)
    }
  }
  else rep.int(digits + 8, n))
  if (digits > 0 && any(nf == "#")) 
    digits <- -digits
  attr(x, "Csingle") <- NULL
  r <- .Internal(formatC(x, as.character(mode), width, digits, as.character(format), flag, i.strlen))
  if (some.special) 
    r[!Ok] <- format.char(rQ, width = width, flag = flag)
  if (nzchar(big.mark) || nzchar(small.mark) || decimal.mark != "." || !is.null(zero.print) || drop0trailing) 
    r <- prettyNum(r, big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, input.d.mark = ".", preserve.width = preserve.width, zero.print = zero.print, replace.zero = replace.zero, drop0trailing = drop0trailing, is.cmplx = FALSE)
  if (!is.null(x.atr <- attributes(x))) 
    attributes(r) <- x.atr
  r
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
formatDL
list(`package:base` = function (x, y, style = c("table", "list"), width = 0.9 * getOption("width"), indent = NULL) 
{
  if (is.list(x)) {
    if (length(x) == 2 && diff(lengths(x)) == 0) {
      y <- x[[2]]
      x <- x[[1]]
    }
    else stop("incorrect value for 'x'")
  }
  else if (is.matrix(x)) {
    if (NCOL(x) == 2) {
      y <- x[, 2]
      x <- x[, 1]
    }
    else stop("incorrect value for 'x'")
  }
  else if (missing(y) && !is.null(nms <- names(x))) {
    y <- x
    x <- nms
  }
  else if (length(x) != length(y)) 
    stop("'x' and 'y' must have the same length")
  x <- as.character(x)
  if (!length(x)) 
    return(x)
  y <- as.character(y)
  style <- match.arg(style)
  if (is.null(indent)) 
    indent <- switch(style, table = width/3, list = width/9)
  indent <- min(indent, 0.5 * width)
  indentString <- strrep(" ", indent)
  if (style == "table") {
    i <- (nchar(x, type = "w") > indent - 3)
    if (any(i)) 
      x[i] <- paste0(x[i], "\n", indentString)
    i <- !i
    if (any(i)) 
      x[i] <- formatC(x[i], width = indent, flag = "-")
    y <- lapply(strwrap(y, width = width - indent, simplify = FALSE), paste, collapse = paste0("\n", indentString))
    r <- paste0(x, unlist(y))
  }
  else if (style == "list") {
    y <- strwrap(paste0(x, ": ", y), exdent = indent, width = width, simplify = FALSE)
    r <- unlist(lapply(y, paste, collapse = "\n"))
  }
  r
}, function (x, y, style = c("table", "list"), width = 0.9 * getOption("width"), indent = NULL) 
{
  if (is.list(x)) {
    if (length(x) == 2 && diff(lengths(x)) == 0) {
      y <- x[[2]]
      x <- x[[1]]
    }
    else stop("incorrect value for 'x'")
  }
  else if (is.matrix(x)) {
    if (NCOL(x) == 2) {
      y <- x[, 2]
      x <- x[, 1]
    }
    else stop("incorrect value for 'x'")
  }
  else if (missing(y) && !is.null(nms <- names(x))) {
    y <- x
    x <- nms
  }
  else if (length(x) != length(y)) 
    stop("'x' and 'y' must have the same length")
  x <- as.character(x)
  if (!length(x)) 
    return(x)
  y <- as.character(y)
  style <- match.arg(style)
  if (is.null(indent)) 
    indent <- switch(style, table = width/3, list = width/9)
  indent <- min(indent, 0.5 * width)
  indentString <- strrep(" ", indent)
  if (style == "table") {
    i <- (nchar(x, type = "w") > indent - 3)
    if (any(i)) 
      x[i] <- paste0(x[i], "\n", indentString)
    i <- !i
    if (any(i)) 
      x[i] <- formatC(x[i], width = indent, flag = "-")
    y <- lapply(strwrap(y, width = width - indent, simplify = FALSE), paste, collapse = paste0("\n", indentString))
    r <- paste0(x, unlist(y))
  }
  else if (style == "list") {
    y <- strwrap(paste0(x, ": ", y), exdent = indent, width = width, simplify = FALSE)
    r <- unlist(lapply(y, paste, collapse = "\n"))
  }
  r
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
forwardsolve
list(`package:base` = function (l, x, k = ncol(l), upper.tri = FALSE, transpose = FALSE) 
{
  l <- as.matrix(l)
  x.mat <- is.matrix(x)
  if (!x.mat) 
    x <- as.matrix(x)
  z <- .Internal(backsolve(l, x, k, upper.tri, transpose))
  if (x.mat) 
    z
  else drop(z)
}, function (l, x, k = ncol(l), upper.tri = FALSE, transpose = FALSE) 
{
  l <- as.matrix(l)
  x.mat <- is.matrix(x)
  if (!x.mat) 
    x <- as.matrix(x)
  z <- .Internal(backsolve(l, x, k, upper.tri, transpose))
  if (x.mat) 
    z
  else drop(z)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
function
list(`package:base` = .Primitive("function"), .Primitive("function"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gamma
list(`package:base` = .Primitive("gamma"), .Primitive("gamma"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gc
list(`package:base` = function (verbose = getOption("verbose"), reset = FALSE, full = TRUE) 
{
  res <- .Internal(gc(verbose, reset, full))
  res <- matrix(res, 2, 7, dimnames = list(c("Ncells", "Vcells"), c("used", "(Mb)", "gc trigger", "(Mb)", "limit (Mb)", "max used", "(Mb)")))
  if (all(is.na(res[, 5]))) 
    res[, -5]
  else res
}, function (verbose = getOption("verbose"), reset = FALSE, full = TRUE) 
{
  res <- .Internal(gc(verbose, reset, full))
  res <- matrix(res, 2, 7, dimnames = list(c("Ncells", "Vcells"), c("used", "(Mb)", "gc trigger", "(Mb)", "limit (Mb)", "max used", "(Mb)")))
  if (all(is.na(res[, 5]))) 
    res[, -5]
  else res
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gc.time
list(`package:base` = .Primitive("gc.time"), .Primitive("gc.time"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gcinfo
list(`package:base` = function (verbose) 
  .Internal(gcinfo(verbose)), function (verbose) 
    .Internal(gcinfo(verbose)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gctorture
list(`package:base` = function (on = TRUE) 
  .Internal(gctorture(on)), function (on = TRUE) 
    .Internal(gctorture(on)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gctorture2
list(`package:base` = function (step, wait = step, inhibit_release = FALSE) 
  .Internal(gctorture2(step, wait, inhibit_release)), function (step, wait = step, inhibit_release = FALSE) 
    .Internal(gctorture2(step, wait, inhibit_release)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
get
list(`package:base` = function (x, pos = -1, envir = as.environment(pos), mode = "any", inherits = TRUE) 
  .Internal(get(x, envir, mode, inherits)), function (x, pos = -1, envir = as.environment(pos), mode = "any", inherits = TRUE) 
    .Internal(get(x, envir, mode, inherits)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
get0
list(`package:base` = function (x, envir = pos.to.env(-1), mode = "any", inherits = TRUE, ifnotfound = NULL) 
  .Internal(get0(x, envir, mode, inherits, ifnotfound)), function (x, envir = pos.to.env(-1), mode = "any", inherits = TRUE, ifnotfound = NULL) 
    .Internal(get0(x, envir, mode, inherits, ifnotfound)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getAllConnections
list(`package:base` = function () 
  .Internal(getAllConnections()), function () 
    .Internal(getAllConnections()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getCallingDLL
list(`package:base` = function (f = sys.function(-1), doStop = FALSE) 
{
  e <- environment(f)
  if (!isNamespace(e)) {
    if (doStop) 
      stop("function is not in a namespace, so cannot locate associated DLL")
    else return(NULL)
  }
  if (is.null(r <- getCallingDLLe(e)) && doStop) 
    stop("looking for DLL for native routine call, but no DLLs in namespace of call")
  r
}, function (f = sys.function(-1), doStop = FALSE) 
{
  e <- environment(f)
  if (!isNamespace(e)) {
    if (doStop) 
      stop("function is not in a namespace, so cannot locate associated DLL")
    else return(NULL)
  }
  if (is.null(r <- getCallingDLLe(e)) && doStop) 
    stop("looking for DLL for native routine call, but no DLLs in namespace of call")
  r
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getCallingDLLe
list(`package:base` = function (e) 
{
  if (is.null(env <- e$.__NAMESPACE__.)) 
    env <- baseenv()
  if (!is.null(Ds <- get0("DLLs", envir = env)) && length(Ds)) 
    Ds[[1]]
}, function (e) 
{
  if (is.null(env <- e$.__NAMESPACE__.)) 
    env <- baseenv()
  if (!is.null(Ds <- get0("DLLs", envir = env)) && length(Ds)) 
    Ds[[1]]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getConnection
list(`package:base` = function (what) 
  .Internal(getConnection(what)), function (what) 
    .Internal(getConnection(what)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getDLLRegisteredRoutines
list(`package:base` = function (dll, addNames = TRUE) 
  UseMethod("getDLLRegisteredRoutines"), function (dll, addNames = TRUE) 
    UseMethod("getDLLRegisteredRoutines"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getDLLRegisteredRoutines.character
list(`package:base` = function (dll, addNames = TRUE) 
{
  dlls <- getLoadedDLLs()
  w <- vapply(dlls, function(x) x[["name"]] == dll || x[["path"]] == dll, NA)
  if (!any(w)) 
    stop(gettextf("No DLL currently loaded with name or path %s", sQuote(dll)), domain = NA)
  dll <- which.max(w)
  if (sum(w) > 1) 
    warning(gettextf("multiple DLLs match '%s'. Using '%s'", names(dll), dlls[[dll]][["path"]]), domain = NA)
  getDLLRegisteredRoutines(dlls[[dll]], addNames)
}, function (dll, addNames = TRUE) 
{
  dlls <- getLoadedDLLs()
  w <- vapply(dlls, function(x) x[["name"]] == dll || x[["path"]] == dll, NA)
  if (!any(w)) 
    stop(gettextf("No DLL currently loaded with name or path %s", sQuote(dll)), domain = NA)
  dll <- which.max(w)
  if (sum(w) > 1) 
    warning(gettextf("multiple DLLs match '%s'. Using '%s'", names(dll), dlls[[dll]][["path"]]), domain = NA)
  getDLLRegisteredRoutines(dlls[[dll]], addNames)
}, function (dll, addNames = TRUE) 
{
  dlls <- getLoadedDLLs()
  w <- vapply(dlls, function(x) x[["name"]] == dll || x[["path"]] == dll, NA)
  if (!any(w)) 
    stop(gettextf("No DLL currently loaded with name or path %s", sQuote(dll)), domain = NA)
  dll <- which.max(w)
  if (sum(w) > 1) 
    warning(gettextf("multiple DLLs match '%s'. Using '%s'", names(dll), dlls[[dll]][["path"]]), domain = NA)
  getDLLRegisteredRoutines(dlls[[dll]], addNames)
})
c("package:base", "registered S3 method for getDLLRegisteredRoutines from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
getDLLRegisteredRoutines.DLLInfo
list(`package:base` = function (dll, addNames = TRUE) 
{
  if (!inherits(dll, "DLLInfo")) 
    stop(gettextf("must specify DLL via a %s object. See getLoadedDLLs()", dQuote("DLLInfo")), domain = NA)
  info <- dll[["info"]]
  els <- .Internal(getRegisteredRoutines(info))
  if (addNames) {
    els <- lapply(els, function(x) {
      if (length(x)) 
        names(x) <- vapply(x, function(z) z$name, "")
      x
    })
  }
  class(els) <- "DLLRegisteredRoutines"
  els
}, function (dll, addNames = TRUE) 
{
  if (!inherits(dll, "DLLInfo")) 
    stop(gettextf("must specify DLL via a %s object. See getLoadedDLLs()", dQuote("DLLInfo")), domain = NA)
  info <- dll[["info"]]
  els <- .Internal(getRegisteredRoutines(info))
  if (addNames) {
    els <- lapply(els, function(x) {
      if (length(x)) 
        names(x) <- vapply(x, function(z) z$name, "")
      x
    })
  }
  class(els) <- "DLLRegisteredRoutines"
  els
}, function (dll, addNames = TRUE) 
{
  if (!inherits(dll, "DLLInfo")) 
    stop(gettextf("must specify DLL via a %s object. See getLoadedDLLs()", dQuote("DLLInfo")), domain = NA)
  info <- dll[["info"]]
  els <- .Internal(getRegisteredRoutines(info))
  if (addNames) {
    els <- lapply(els, function(x) {
      if (length(x)) 
        names(x) <- vapply(x, function(z) z$name, "")
      x
    })
  }
  class(els) <- "DLLRegisteredRoutines"
  els
})
c("package:base", "registered S3 method for getDLLRegisteredRoutines from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
getElement
list(`package:base` = function (object, name) 
{
  if (isS4(object)) 
    methods::slot(object, name)
  else object[[name, exact = TRUE]]
}, function (object, name) 
{
  if (isS4(object)) 
    methods::slot(object, name)
  else object[[name, exact = TRUE]]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
geterrmessage
list(`package:base` = function () 
  .Internal(geterrmessage()), function () 
    .Internal(geterrmessage()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getExportedValue
list(`package:base` = function (ns, name) 
  .Internal(getNamespaceValue(ns, name, TRUE)), function (ns, name) 
    .Internal(getNamespaceValue(ns, name, TRUE)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getHook
list(`package:base` = function (hookName) 
  get0(hookName, envir = .userHooksEnv, inherits = FALSE, ifnotfound = list()), function (hookName) 
    get0(hookName, envir = .userHooksEnv, inherits = FALSE, ifnotfound = list()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getLoadedDLLs
list(`package:base` = function () 
  .Internal(getLoadedDLLs()), function () 
    .Internal(getLoadedDLLs()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getNamespace
list(`package:base` = function (name) 
{
  ns <- .Internal(getRegisteredNamespace(name))
  if (!is.null(ns)) 
    ns
  else loadNamespace(name)
}, function (name) 
{
  ns <- .Internal(getRegisteredNamespace(name))
  if (!is.null(ns)) 
    ns
  else loadNamespace(name)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getNamespaceExports
list(`package:base` = function (ns) 
{
  ns <- asNamespace(ns)
  names(if (isBaseNamespace(ns)) .BaseNamespaceEnv else .getNamespaceInfo(ns, "exports"))
}, function (ns) 
{
  ns <- asNamespace(ns)
  names(if (isBaseNamespace(ns)) .BaseNamespaceEnv else .getNamespaceInfo(ns, "exports"))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getNamespaceImports
list(`package:base` = function (ns) 
{
  ns <- asNamespace(ns)
  if (isBaseNamespace(ns)) 
    NULL
  else .getNamespaceInfo(ns, "imports")
}, function (ns) 
{
  ns <- asNamespace(ns)
  if (isBaseNamespace(ns)) 
    NULL
  else .getNamespaceInfo(ns, "imports")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getNamespaceInfo
list(`package:base` = function (ns, which) 
{
  ns <- asNamespace(ns, base.OK = FALSE)
  get(which, envir = ns[[".__NAMESPACE__."]])
}, function (ns, which) 
{
  ns <- asNamespace(ns, base.OK = FALSE)
  get(which, envir = ns[[".__NAMESPACE__."]])
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getNamespaceName
list(`package:base` = function (ns) 
{
  ns <- asNamespace(ns)
  if (isBaseNamespace(ns)) 
    "base"
  else .getNamespaceInfo(ns, "spec")["name"]
}, function (ns) 
{
  ns <- asNamespace(ns)
  if (isBaseNamespace(ns)) 
    "base"
  else .getNamespaceInfo(ns, "spec")["name"]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getNamespaceUsers
list(`package:base` = function (ns) 
{
  nsname <- getNamespaceName(asNamespace(ns))
  users <- character()
  for (n in loadedNamespaces()) {
    inames <- names(getNamespaceImports(n))
    if (match(nsname, inames, 0)) 
      users <- c(n, users)
  }
  users
}, function (ns) 
{
  nsname <- getNamespaceName(asNamespace(ns))
  users <- character()
  for (n in loadedNamespaces()) {
    inames <- names(getNamespaceImports(n))
    if (match(nsname, inames, 0)) 
      users <- c(n, users)
  }
  users
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getNamespaceVersion
list(`package:base` = function (ns) 
{
  ns <- asNamespace(ns)
  if (isBaseNamespace(ns)) 
    c(version = paste(R.version$major, R.version$minor, sep = "."))
  else .getNamespaceInfo(ns, "spec")["version"]
}, function (ns) 
{
  ns <- asNamespace(ns)
  if (isBaseNamespace(ns)) 
    c(version = paste(R.version$major, R.version$minor, sep = "."))
  else .getNamespaceInfo(ns, "spec")["version"]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getNativeSymbolInfo
list(`package:base` = function (name, PACKAGE, unlist = TRUE, withRegistrationInfo = FALSE) 
{
  if (missing(PACKAGE)) 
    PACKAGE <- ""
  if (is.character(PACKAGE)) 
    pkgName <- PACKAGE
  else if (inherits(PACKAGE, "DLLInfo")) {
    pkgName <- PACKAGE[["path"]]
    PACKAGE <- PACKAGE[["info"]]
  }
  else if (inherits(PACKAGE, "DLLInfoReference")) {
    pkgName <- character()
  }
  else stop(gettextf("must pass a package name, %s or %s object", dQuote("DLLInfo"), dQuote("DllInfoReference")), domain = NA)
  syms <- lapply(name, function(id) {
    v <- .Internal(getSymbolInfo(as.character(id), PACKAGE, as.logical(withRegistrationInfo)))
    if (is.null(v)) {
      msg <- paste("no such symbol", id)
      if (length(pkgName) && nzchar(pkgName)) 
        msg <- paste(msg, "in package", pkgName)
      stop(msg, domain = NA)
    }
    names(v) <- c("name", "address", "dll", "numParameters")[seq_along(v)]
    v
  })
  if (length(name) == 1 && unlist) 
    syms <- syms[[1]]
  else names(syms) <- name
  syms
}, function (name, PACKAGE, unlist = TRUE, withRegistrationInfo = FALSE) 
{
  if (missing(PACKAGE)) 
    PACKAGE <- ""
  if (is.character(PACKAGE)) 
    pkgName <- PACKAGE
  else if (inherits(PACKAGE, "DLLInfo")) {
    pkgName <- PACKAGE[["path"]]
    PACKAGE <- PACKAGE[["info"]]
  }
  else if (inherits(PACKAGE, "DLLInfoReference")) {
    pkgName <- character()
  }
  else stop(gettextf("must pass a package name, %s or %s object", dQuote("DLLInfo"), dQuote("DllInfoReference")), domain = NA)
  syms <- lapply(name, function(id) {
    v <- .Internal(getSymbolInfo(as.character(id), PACKAGE, as.logical(withRegistrationInfo)))
    if (is.null(v)) {
      msg <- paste("no such symbol", id)
      if (length(pkgName) && nzchar(pkgName)) 
        msg <- paste(msg, "in package", pkgName)
      stop(msg, domain = NA)
    }
    names(v) <- c("name", "address", "dll", "numParameters")[seq_along(v)]
    v
  })
  if (length(name) == 1 && unlist) 
    syms <- syms[[1]]
  else names(syms) <- name
  syms
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getOption
list(`package:base` = function (x, default = NULL) 
{
  if (missing(default)) 
    .Internal(getOption(x))
  else {
    ans <- .Internal(getOption(x))
    if (is.null(ans)) 
      default
    else ans
  }
}, function (x, default = NULL) 
{
  if (missing(default) || match(x, table = names(.Options), nomatch = 0) > 0) 
    go(x)
  else default
}, function (x, default = NULL) 
{
  if (missing(default) || match(x, table = names(.Options), nomatch = 0) > 0) 
    go(x)
  else default
}, function (x, default = NULL) 
{
  if (missing(default) || match(x, table = names(.Options), nomatch = 0) > 0) 
    go(x)
  else default
}, function (x, default = NULL) 
{
  if (missing(default)) 
    .Internal(getOption(x))
  else {
    ans <- .Internal(getOption(x))
    if (is.null(ans)) 
      default
    else ans
  }
}, function (x, default = NULL) 
{
  if (missing(default) || match(x, table = names(.Options), nomatch = 0) > 0) 
    go(x)
  else default
})
c("package:base", "namespace:future", "namespace:parallelly", "namespace:future.apply", "namespace:base", "namespace:globals")
c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)
getRversion
list(`package:base` = function () 
  package_version(R.version), function (...) 
    stop("Reminder to data.table developers: don't use getRversion() internally. Add a behaviour test to .onLoad instead."), function () 
      package_version(R.version))
c("package:base", "namespace:data.table", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
getSrcLines
list(`package:base` = function (srcfile, first, last) 
{
  if (first > last) 
    return(character())
  if (inherits(srcfile, "srcfilealias")) 
    srcfile <- srcfile$original
  if (inherits(srcfile, "srcfilecopy")) {
    if (is.null(srcfile$fixedNewlines)) {
      lines <- srcfile$lines
      if (any(grepl("\n", lines, fixed = TRUE, useBytes = TRUE))) 
        srcfile$lines <- unlist(strsplit(sub("$", "\n", as.character(lines)), "\n"))
      srcfile$fixedNewlines <- TRUE
    }
    last <- min(last, length(srcfile$lines))
    if (first > last) 
      return(character())
    else return(srcfile$lines[first:last])
  }
  if (!.isOpen(srcfile)) 
    on.exit(close(srcfile))
  conn <- open(srcfile, first)
  lines <- readLines(conn, n = last - first + 1, warn = FALSE)
  if (!is.null(Enc <- srcfile$Enc) && !(Enc %in% c("unknown", "native.enc"))) 
    lines <- iconv(lines, "", Enc)
  srcfile$line <- first + length(lines)
  return(lines)
}, function (srcfile, first, last) 
{
  if (first > last) 
    return(character())
  if (inherits(srcfile, "srcfilealias")) 
    srcfile <- srcfile$original
  if (inherits(srcfile, "srcfilecopy")) {
    if (is.null(srcfile$fixedNewlines)) {
      lines <- srcfile$lines
      if (any(grepl("\n", lines, fixed = TRUE, useBytes = TRUE))) 
        srcfile$lines <- unlist(strsplit(sub("$", "\n", as.character(lines)), "\n"))
      srcfile$fixedNewlines <- TRUE
    }
    last <- min(last, length(srcfile$lines))
    if (first > last) 
      return(character())
    else return(srcfile$lines[first:last])
  }
  if (!.isOpen(srcfile)) 
    on.exit(close(srcfile))
  conn <- open(srcfile, first)
  lines <- readLines(conn, n = last - first + 1, warn = FALSE)
  if (!is.null(Enc <- srcfile$Enc) && !(Enc %in% c("unknown", "native.enc"))) 
    lines <- iconv(lines, "", Enc)
  srcfile$line <- first + length(lines)
  return(lines)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getTaskCallbackNames
list(`package:base` = function () 
  .Call(.C_R_getTaskCallbackNames), function () 
    .Call(.C_R_getTaskCallbackNames))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gettext
list(`package:base` = function (..., domain = NULL, trim = TRUE) 
{
  char <- unlist(lapply(list(...), as.character))
  .Internal(gettext(domain, char, trim))
}, function (..., domain = NULL, trim = TRUE) 
{
  char <- unlist(lapply(list(...), as.character))
  .Internal(gettext(domain, char, trim))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gettextf
list(`package:base` = function (fmt, ..., domain = NULL, trim = TRUE) 
  sprintf(gettext(fmt, domain = domain, trim = trim), ...), function (fmt, ..., domain = NULL, trim = TRUE) 
    sprintf(gettext(fmt, domain = domain, trim = trim), ...))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
getwd
list(`package:base` = function () 
  .Internal(getwd()), function () 
    .Internal(getwd()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gl
list(`package:base` = function (n, k, length = n * k, labels = seq_len(n), ordered = FALSE) 
{
  f <- rep_len(rep.int(seq_len(n), rep.int(k, n)), length)
  levels(f) <- as.character(labels)
  class(f) <- c(if (ordered) "ordered", "factor")
  f
}, function (n, k, length = n * k, labels = seq_len(n), ordered = FALSE) 
{
  f <- rep_len(rep.int(seq_len(n), rep.int(k, n)), length)
  levels(f) <- as.character(labels)
  class(f) <- c(if (ordered) "ordered", "factor")
  f
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
globalCallingHandlers
list(`package:base` = function (...) 
{
  handlers <- list(...)
  if (length(handlers) == 0) 
    gh
  else {
    if (length(handlers) == 1 && is.list(handlers[[1]])) 
      handlers <- handlers[[1]]
    if (identical(handlers, list(NULL))) {
      out <- gh
      gh <- list()
    }
    else {
      classes <- names(handlers)
      if (length(classes) != length(handlers)) 
        stop("condition handlers must be specified with a condition class")
      if (!all(vapply(handlers, is.function, logical(1)))) 
        stop("condition handlers must be functions")
      out <- NULL
      gh <- c(handlers, gh)
    }
    for (class in unique(names(gh))) {
      idx <- which(class == names(gh))
      funAsList <- function(x) {
        x <- utils::removeSource(x)
        out <- list(formals(x), body(x), environment(x))
        attributes(out) <- attributes(x)
        out
      }
      classHandlers <- lapply(gh[idx], funAsList)
      dups <- duplicated(classHandlers)
      if (any(dups)) {
        message(sprintf("pushing duplicate `%s` handler on top of the stack", class))
        gh <- gh[-idx[dups]]
      }
    }
    .Internal(.addGlobHands(names(gh), gh, .GlobalEnv, NULL, TRUE))
    gh <<- gh
    invisible(out)
  }
}, function (...) 
{
  handlers <- list(...)
  if (length(handlers) == 0) 
    gh
  else {
    if (length(handlers) == 1 && is.list(handlers[[1]])) 
      handlers <- handlers[[1]]
    if (identical(handlers, list(NULL))) {
      out <- gh
      gh <- list()
    }
    else {
      classes <- names(handlers)
      if (length(classes) != length(handlers)) 
        stop("condition handlers must be specified with a condition class")
      if (!all(vapply(handlers, is.function, logical(1)))) 
        stop("condition handlers must be functions")
      out <- NULL
      gh <- c(handlers, gh)
    }
    for (class in unique(names(gh))) {
      idx <- which(class == names(gh))
      funAsList <- function(x) {
        x <- utils::removeSource(x)
        out <- list(formals(x), body(x), environment(x))
        attributes(out) <- attributes(x)
        out
      }
      classHandlers <- lapply(gh[idx], funAsList)
      dups <- duplicated(classHandlers)
      if (any(dups)) {
        message(sprintf("pushing duplicate `%s` handler on top of the stack", class))
        gh <- gh[-idx[dups]]
      }
    }
    .Internal(.addGlobHands(names(gh), gh, .GlobalEnv, NULL, TRUE))
    gh <<- gh
    invisible(out)
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
globalenv
list(`package:base` = .Primitive("globalenv"), .Primitive("globalenv"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gregexec
list(`package:base` = function (pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(text) && length(levels(text)) < length(text)) {
    out <- gregexec(pattern, c(levels(text), NA), ignore.case, perl, fixed, useBytes)
    outna <- out[length(out)]
    out <- out[text]
    out[is.na(text)] <- outna
    return(out)
  }
  dat <- gregexpr(pattern = pattern, text = text, ignore.case = ignore.case, fixed = fixed, useBytes = useBytes, perl = perl)
  if (perl && !fixed) {
    capt.attr <- c("capture.start", "capture.length", "capture.names")
    process <- function(x) {
      if (anyNA(x) || any(x < 0)) 
        y <- x
      else {
        y <- t(cbind(x, attr(x, "capture.start")))
        attributes(y)[names(attributes(x))] <- attributes(x)
        ml <- t(cbind(attr(x, "match.length"), attr(x, "capture.length")))
        nm <- attr(x, "capture.names")
        dimnames(ml) <- dimnames(y) <- if (any(nzchar(nm))) 
          list(c("", nm), NULL)
        attr(y, "match.length") <- ml
        y
      }
      attributes(y)[capt.attr] <- NULL
      y
    }
    lapply(dat, process)
  }
  else {
    m1 <- lapply(regmatches(text, dat), regexec, pattern = pattern, ignore.case = ignore.case, perl = perl, fixed = fixed, useBytes = useBytes)
    mlen <- lengths(m1)
    res <- vector("list", length(m1))
    im <- mlen > 0
    res[!im] <- dat[!im]
    res[im] <- Map(function(outer, inner) {
      tmp <- do.call(cbind, inner)
      attributes(tmp)[names(attributes(inner))] <- attributes(inner)
      attr(tmp, "match.length") <- do.call(cbind, lapply(inner, attr, "match.length"))
      attr(tmp, "useBytes") <- attr(outer, "useBytes")
      attr(tmp, "index.type") <- attr(outer, "index.type")
      tmp + rep(outer - 1, each = nrow(tmp))
    }, dat[im], m1[im])
    res
  }
}, function (pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(text) && length(levels(text)) < length(text)) {
    out <- gregexec(pattern, c(levels(text), NA), ignore.case, perl, fixed, useBytes)
    outna <- out[length(out)]
    out <- out[text]
    out[is.na(text)] <- outna
    return(out)
  }
  dat <- gregexpr(pattern = pattern, text = text, ignore.case = ignore.case, fixed = fixed, useBytes = useBytes, perl = perl)
  if (perl && !fixed) {
    capt.attr <- c("capture.start", "capture.length", "capture.names")
    process <- function(x) {
      if (anyNA(x) || any(x < 0)) 
        y <- x
      else {
        y <- t(cbind(x, attr(x, "capture.start")))
        attributes(y)[names(attributes(x))] <- attributes(x)
        ml <- t(cbind(attr(x, "match.length"), attr(x, "capture.length")))
        nm <- attr(x, "capture.names")
        dimnames(ml) <- dimnames(y) <- if (any(nzchar(nm))) 
          list(c("", nm), NULL)
        attr(y, "match.length") <- ml
        y
      }
      attributes(y)[capt.attr] <- NULL
      y
    }
    lapply(dat, process)
  }
  else {
    m1 <- lapply(regmatches(text, dat), regexec, pattern = pattern, ignore.case = ignore.case, perl = perl, fixed = fixed, useBytes = useBytes)
    mlen <- lengths(m1)
    res <- vector("list", length(m1))
    im <- mlen > 0
    res[!im] <- dat[!im]
    res[im] <- Map(function(outer, inner) {
      tmp <- do.call(cbind, inner)
      attributes(tmp)[names(attributes(inner))] <- attributes(inner)
      attr(tmp, "match.length") <- do.call(cbind, lapply(inner, attr, "match.length"))
      attr(tmp, "useBytes") <- attr(outer, "useBytes")
      attr(tmp, "index.type") <- attr(outer, "index.type")
      tmp + rep(outer - 1, each = nrow(tmp))
    }, dat[im], m1[im])
    res
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gregexpr
list(`package:base` = function (pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(text) && length(levels(text)) < length(text)) {
    out <- gregexpr(pattern, c(levels(text), NA), ignore.case, perl, fixed, useBytes)
    outna <- out[length(out)]
    out <- out[text]
    out[is.na(text)] <- outna
    out
  }
  else {
    if (!is.character(text)) 
      text <- as.character(text)
    .Internal(gregexpr(as.character(pattern), text, ignore.case, perl, fixed, useBytes))
  }
}, function (pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(text) && length(levels(text)) < length(text)) {
    out <- gregexpr(pattern, c(levels(text), NA), ignore.case, perl, fixed, useBytes)
    outna <- out[length(out)]
    out <- out[text]
    out[is.na(text)] <- outna
    out
  }
  else {
    if (!is.character(text)) 
      text <- as.character(text)
    .Internal(gregexpr(as.character(pattern), text, ignore.case, perl, fixed, useBytes))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
grep
list(`package:base` = function (pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE) 
{
  pattern <- as.character(pattern)
  if (is.factor(x) && length(levx <- levels(x)) < length(x) && !is.na(pattern[1])) {
    value <- is.character(idxna <- suppressWarnings(grep(pattern, NA, ignore.case, perl, value, fixed, useBytes, invert)))
    idx <- logical(length(levx))
    idx[grep(pattern, levx, ignore.case, perl, FALSE, fixed, useBytes, invert)] <- TRUE
    idx <- idx[x]
    if (length(idxna)) 
      idx[is.na(x)] <- TRUE
    idx <- which(idx)
    if (value) {
      idx <- x[idx]
      structure(as.character(idx), names = names(idx))
    }
    else idx
  }
  else {
    if (!is.character(x)) 
      x <- structure(as.character(x), names = names(x))
    .Internal(grep(pattern, x, ignore.case, value, perl, fixed, useBytes, invert))
  }
}, function (pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE) 
{
  pattern <- as.character(pattern)
  if (is.factor(x) && length(levx <- levels(x)) < length(x) && !is.na(pattern[1])) {
    value <- is.character(idxna <- suppressWarnings(grep(pattern, NA, ignore.case, perl, value, fixed, useBytes, invert)))
    idx <- logical(length(levx))
    idx[grep(pattern, levx, ignore.case, perl, FALSE, fixed, useBytes, invert)] <- TRUE
    idx <- idx[x]
    if (length(idxna)) 
      idx[is.na(x)] <- TRUE
    idx <- which(idx)
    if (value) {
      idx <- x[idx]
      structure(as.character(idx), names = names(idx))
    }
    else idx
  }
  else {
    if (!is.character(x)) 
      x <- structure(as.character(x), names = names(x))
    .Internal(grep(pattern, x, ignore.case, value, perl, fixed, useBytes, invert))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
grepl
list(`package:base` = function (pattern, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(x) && length(levels(x)) < length(x)) {
    out <- grepl(pattern, c(levels(x), NA), ignore.case, perl, fixed, useBytes)
    outna <- out[length(out)]
    out <- out[x]
    out[is.na(x)] <- outna
    out
  }
  else {
    if (!is.character(x)) 
      x <- as.character(x)
    .Internal(grepl(as.character(pattern), x, ignore.case, FALSE, perl, fixed, useBytes, FALSE))
  }
}, function (pattern, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(x) && length(levels(x)) < length(x)) {
    out <- grepl(pattern, c(levels(x), NA), ignore.case, perl, fixed, useBytes)
    outna <- out[length(out)]
    out <- out[x]
    out[is.na(x)] <- outna
    out
  }
  else {
    if (!is.character(x)) 
      x <- as.character(x)
    .Internal(grepl(as.character(pattern), x, ignore.case, FALSE, perl, fixed, useBytes, FALSE))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
grepRaw
list(`package:base` = function (pattern, x, offset = 1, ignore.case = FALSE, value = FALSE, fixed = FALSE, all = FALSE, invert = FALSE) 
{
  if (!is.raw(pattern)) 
    pattern <- charToRaw(as.character(pattern))
  if (!is.raw(x)) 
    x <- charToRaw(as.character(x))
  .Internal(grepRaw(pattern, x, offset, ignore.case, fixed, value, all, invert))
}, function (pattern, x, offset = 1, ignore.case = FALSE, value = FALSE, fixed = FALSE, all = FALSE, invert = FALSE) 
{
  if (!is.raw(pattern)) 
    pattern <- charToRaw(as.character(pattern))
  if (!is.raw(x)) 
    x <- charToRaw(as.character(x))
  .Internal(grepRaw(pattern, x, offset, ignore.case, fixed, value, all, invert))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
grouping
list(`package:base` = function (...) 
{
  z <- list(...)
  if (any(vapply(z, is.object, logical(1)))) {
    z <- lapply(z, function(x) if (is.object(x)) 
      as.vector(xtfrm(x))
      else x)
    return(do.call("grouping", z))
  }
  nalast <- TRUE
  decreasing <- rep_len(FALSE, length(z))
  group <- TRUE
  sortStr <- FALSE
  return(.Internal(radixsort(nalast, decreasing, group, sortStr, ...)))
}, function (...) 
{
  z <- list(...)
  if (any(vapply(z, is.object, logical(1)))) {
    z <- lapply(z, function(x) if (is.object(x)) 
      as.vector(xtfrm(x))
      else x)
    return(do.call("grouping", z))
  }
  nalast <- TRUE
  decreasing <- rep_len(FALSE, length(z))
  group <- TRUE
  sortStr <- FALSE
  return(.Internal(radixsort(nalast, decreasing, group, sortStr, ...)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gsub
list(`package:base` = function (pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(x) && length(levels(x)) < length(x)) {
    gsub(pattern, replacement, levels(x), ignore.case, perl, fixed, useBytes)[x]
  }
  else {
    if (!is.character(x)) 
      x <- as.character(x)
    .Internal(gsub(as.character(pattern), as.character(replacement), x, ignore.case, perl, fixed, useBytes))
  }
}, function (pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(x) && length(levels(x)) < length(x)) {
    gsub(pattern, replacement, levels(x), ignore.case, perl, fixed, useBytes)[x]
  }
  else {
    if (!is.character(x)) 
      x <- as.character(x)
    .Internal(gsub(as.character(pattern), as.character(replacement), x, ignore.case, perl, fixed, useBytes))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gzcon
list(`package:base` = function (con, level = 6, allowNonCompressed = TRUE, text = FALSE) 
  .Internal(gzcon(con, level, allowNonCompressed, text)), function (con, level = 6, allowNonCompressed = TRUE, text = FALSE) 
    .Internal(gzcon(con, level, allowNonCompressed, text)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
gzfile
list(`package:base` = function (description, open = "", encoding = getOption("encoding"), compression = 6) 
  .Internal(gzfile(description, open, encoding, compression)), function (description, open = "", encoding = getOption("encoding"), compression = 6) 
    .Internal(gzfile(description, open, encoding, compression)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
I
list(`package:base` = function (x) 
{
  class(x) <- unique.default(c("AsIs", oldClass(x)))
  x
}, function (x) 
{
  class(x) <- unique.default(c("AsIs", oldClass(x)))
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
iconv
list(`package:base` = function (x, from = "", to = "", sub = NA, mark = TRUE, toRaw = FALSE) 
{
  if (!(is.character(x) || (is.list(x) && is.null(oldClass(x))))) 
    x <- as.character(x)
  .Internal(iconv(x, from, to, as.character(sub), mark, toRaw))
}, function (x, from = "", to = "", sub = NA, mark = TRUE, toRaw = FALSE) 
{
  if (!(is.character(x) || (is.list(x) && is.null(oldClass(x))))) 
    x <- as.character(x)
  .Internal(iconv(x, from, to, as.character(sub), mark, toRaw))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
iconvlist
list(`package:base` = function () 
{
  int <- .Internal(iconv(NULL, "", "", "", TRUE, FALSE))
  if (length(int)) 
    return(sort.int(int))
  icfile <- system.file("iconvlist", package = "utils")
  if (!nzchar(icfile)) 
    stop("'iconvlist' is not available on this system")
  ext <- readLines(icfile)
  if (!length(ext)) 
    stop("'iconvlist' is not available on this system")
  cnt <- grep("//$", ext)
  if (length(cnt)/length(ext) > 0.5) {
    ext <- grep("//$", ext, value = TRUE)
    ext <- sub("//$", "", ext)
  }
  else if (any(grepl(",", ext, fixed = TRUE))) {
    ext <- gsub(",[[:space:]]", " ", sub(",$", "", ext))
  }
  sort.int(unlist(strsplit(ext, "[[:space:]]")))
}, function () 
{
  int <- .Internal(iconv(NULL, "", "", "", TRUE, FALSE))
  if (length(int)) 
    return(sort.int(int))
  icfile <- system.file("iconvlist", package = "utils")
  if (!nzchar(icfile)) 
    stop("'iconvlist' is not available on this system")
  ext <- readLines(icfile)
  if (!length(ext)) 
    stop("'iconvlist' is not available on this system")
  cnt <- grep("//$", ext)
  if (length(cnt)/length(ext) > 0.5) {
    ext <- grep("//$", ext, value = TRUE)
    ext <- sub("//$", "", ext)
  }
  else if (any(grepl(",", ext, fixed = TRUE))) {
    ext <- gsub(",[[:space:]]", " ", sub(",$", "", ext))
  }
  sort.int(unlist(strsplit(ext, "[[:space:]]")))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
icuGetCollate
list(`package:base` = function (type = c("actual", "valid")) 
{
  type <- match.arg(type)
  .Internal(icuGetCollate(match(type, c("actual", "valid"))))
}, function (type = c("actual", "valid")) 
{
  type <- match.arg(type)
  .Internal(icuGetCollate(match(type, c("actual", "valid"))))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
icuSetCollate
list(`package:base` = function (...) 
  .Internal(icuSetCollate(...)), function (...) 
    .Internal(icuSetCollate(...)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
identical
list(`package:base` = function (x, y, num.eq = TRUE, single.NA = TRUE, attrib.as.set = TRUE, ignore.bytecode = TRUE, ignore.environment = FALSE, ignore.srcref = TRUE, extptr.as.ref = FALSE) 
  .Internal(identical(x, y, num.eq, single.NA, attrib.as.set, ignore.bytecode, ignore.environment, ignore.srcref, extptr.as.ref)), function (x, y, num.eq = TRUE, single.NA = TRUE, attrib.as.set = TRUE, ignore.bytecode = TRUE, ignore.environment = FALSE, ignore.srcref = TRUE, extptr.as.ref = FALSE) 
    .Internal(identical(x, y, num.eq, single.NA, attrib.as.set, ignore.bytecode, ignore.environment, ignore.srcref, extptr.as.ref)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
identity
list(`package:base` = function (x) 
  x, function (x) 
    x)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
if
list(`package:base` = .Primitive("if"), .Primitive("if"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
ifelse
list(`package:base` = function (test, yes, no) 
{
  if (is.atomic(test)) {
    if (typeof(test) != "logical") 
      storage.mode(test) <- "logical"
    if (length(test) == 1 && is.null(attributes(test))) {
      if (is.na(test)) 
        return(NA)
      else if (test) {
        if (length(yes) == 1) {
          yat <- attributes(yes)
          if (is.null(yat) || (is.function(yes) && identical(names(yat), "srcref"))) 
            return(yes)
        }
      }
      else if (length(no) == 1) {
        nat <- attributes(no)
        if (is.null(nat) || (is.function(no) && identical(names(nat), "srcref"))) 
          return(no)
      }
    }
  }
  else test <- if (isS4(test)) 
    methods::as(test, "logical")
  else as.logical(test)
  ans <- test
  len <- length(ans)
  ypos <- which(test)
  npos <- which(!test)
  if (length(ypos) > 0) 
    ans[ypos] <- rep(yes, length.out = len)[ypos]
  if (length(npos) > 0) 
    ans[npos] <- rep(no, length.out = len)[npos]
  ans
}, function (test, yes, no) 
{
  if (is.atomic(test)) {
    if (typeof(test) != "logical") 
      storage.mode(test) <- "logical"
    if (length(test) == 1 && is.null(attributes(test))) {
      if (is.na(test)) 
        return(NA)
      else if (test) {
        if (length(yes) == 1) {
          yat <- attributes(yes)
          if (is.null(yat) || (is.function(yes) && identical(names(yat), "srcref"))) 
            return(yes)
        }
      }
      else if (length(no) == 1) {
        nat <- attributes(no)
        if (is.null(nat) || (is.function(no) && identical(names(nat), "srcref"))) 
          return(no)
      }
    }
  }
  else test <- if (isS4(test)) 
    methods::as(test, "logical")
  else as.logical(test)
  ans <- test
  len <- length(ans)
  ypos <- which(test)
  npos <- which(!test)
  if (length(ypos) > 0) 
    ans[ypos] <- rep(yes, length.out = len)[ypos]
  if (length(npos) > 0) 
    ans[npos] <- rep(no, length.out = len)[npos]
  ans
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Im
list(`package:base` = .Primitive("Im"), .Primitive("Im"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
importIntoEnv
list(`package:base` = function (impenv, impnames, expenv, expnames) 
{
  exports <- getNamespaceInfo(expenv, "exports")
  ex <- names(exports)
  if (!all(eie <- expnames %in% ex)) {
    miss <- expnames[!eie]
    if (all(startsWith(miss, ".__C__"))) {
      miss <- sub("^\\.__C__", "", miss)
      stop(sprintf(ngettext(length(miss), "class %s is not exported by 'namespace:%s'", "classes %s are not exported by 'namespace:%s'"), paste(paste0("\"", miss, "\""), collapse = ", "), getNamespaceName(expenv)), call. = FALSE, domain = NA)
    }
    else {
      stop(sprintf(ngettext(length(miss), "object %s is not exported by 'namespace:%s'", "objects %s are not exported by 'namespace:%s'"), paste(sQuote(miss), collapse = ", "), getNamespaceName(expenv)), call. = FALSE, domain = NA)
    }
  }
  expnames <- unlist(mget(expnames, envir = exports, inherits = FALSE), recursive = FALSE)
  if (is.null(impnames)) 
    impnames <- character()
  if (is.null(expnames)) 
    expnames <- character()
  .Internal(importIntoEnv(impenv, impnames, expenv, expnames))
}, function (impenv, impnames, expenv, expnames) 
{
  exports <- getNamespaceInfo(expenv, "exports")
  ex <- names(exports)
  if (!all(eie <- expnames %in% ex)) {
    miss <- expnames[!eie]
    if (all(startsWith(miss, ".__C__"))) {
      miss <- sub("^\\.__C__", "", miss)
      stop(sprintf(ngettext(length(miss), "class %s is not exported by 'namespace:%s'", "classes %s are not exported by 'namespace:%s'"), paste(paste0("\"", miss, "\""), collapse = ", "), getNamespaceName(expenv)), call. = FALSE, domain = NA)
    }
    else {
      stop(sprintf(ngettext(length(miss), "object %s is not exported by 'namespace:%s'", "objects %s are not exported by 'namespace:%s'"), paste(sQuote(miss), collapse = ", "), getNamespaceName(expenv)), call. = FALSE, domain = NA)
    }
  }
  expnames <- unlist(mget(expnames, envir = exports, inherits = FALSE), recursive = FALSE)
  if (is.null(impnames)) 
    impnames <- character()
  if (is.null(expnames)) 
    expnames <- character()
  .Internal(importIntoEnv(impenv, impnames, expenv, expnames))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
infoRDS
list(`package:base` = function (file) 
{
  if (is.character(file)) {
    con <- gzfile(file, "rb")
    on.exit(close(con))
  }
  else if (inherits(file, "connection")) 
    con <- if (inherits(file, "url")) 
      gzcon(file)
  else file
  else stop("bad 'file' argument")
  .Internal(serializeInfoFromConn(con))
}, function (file) 
{
  if (is.character(file)) {
    con <- gzfile(file, "rb")
    on.exit(close(con))
  }
  else if (inherits(file, "connection")) 
    con <- if (inherits(file, "url")) 
      gzcon(file)
  else file
  else stop("bad 'file' argument")
  .Internal(serializeInfoFromConn(con))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
inherits
list(`package:base` = function (x, what, which = FALSE) 
  .Internal(inherits(x, what, which)), function (x, what, which = FALSE) 
    .Internal(inherits(x, what, which)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
integer
list(`package:base` = function (length = 0) 
  .Internal(vector("integer", length)), function (length = 0) 
    .Internal(vector("integer", length)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
interaction
list(`package:base` = function (..., drop = FALSE, sep = ".", lex.order = FALSE) 
{
  args <- list(...)
  narg <- length(args)
  if (narg < 1) 
    stop("No factors specified")
  if (narg == 1 && is.list(args[[1]])) {
    args <- args[[1]]
    narg <- length(args)
  }
  for (i in narg:1) {
    f <- as.factor(args[[i]])[, drop = drop]
    l <- levels(f)
    if1 <- as.integer(f) - 1
    if (i == narg) {
      ans <- if1
      lvs <- l
    }
    else {
      if (lex.order) {
        ll <- length(lvs)
        ans <- ans + ll * if1
        lvs <- paste(rep(l, each = ll), rep(lvs, length(l)), sep = sep)
      }
      else {
        ans <- ans * length(l) + if1
        lvs <- paste(rep(l, length(lvs)), rep(lvs, each = length(l)), sep = sep)
      }
      if (anyDuplicated(lvs)) {
        ulvs <- unique(lvs)
        while ((i <- anyDuplicated(flv <- match(lvs, ulvs)))) {
          lvs <- lvs[-i]
          ans[ans + 1 == i] <- match(flv[i], flv[1:(i - 1)]) - 1
          ans[ans + 1 > i] <- ans[ans + 1 > i] - 1
        }
        lvs <- ulvs
      }
      if (drop) {
        olvs <- lvs
        lvs <- lvs[sort(unique(ans + 1))]
        ans <- match(olvs[ans + 1], lvs) - 1
      }
    }
  }
  structure(as.integer(ans + 1), levels = lvs, class = "factor")
}, function (..., drop = FALSE, sep = ".", lex.order = FALSE) 
{
  args <- list(...)
  narg <- length(args)
  if (narg < 1) 
    stop("No factors specified")
  if (narg == 1 && is.list(args[[1]])) {
    args <- args[[1]]
    narg <- length(args)
  }
  for (i in narg:1) {
    f <- as.factor(args[[i]])[, drop = drop]
    l <- levels(f)
    if1 <- as.integer(f) - 1
    if (i == narg) {
      ans <- if1
      lvs <- l
    }
    else {
      if (lex.order) {
        ll <- length(lvs)
        ans <- ans + ll * if1
        lvs <- paste(rep(l, each = ll), rep(lvs, length(l)), sep = sep)
      }
      else {
        ans <- ans * length(l) + if1
        lvs <- paste(rep(l, length(lvs)), rep(lvs, each = length(l)), sep = sep)
      }
      if (anyDuplicated(lvs)) {
        ulvs <- unique(lvs)
        while ((i <- anyDuplicated(flv <- match(lvs, ulvs)))) {
          lvs <- lvs[-i]
          ans[ans + 1 == i] <- match(flv[i], flv[1:(i - 1)]) - 1
          ans[ans + 1 > i] <- ans[ans + 1 > i] - 1
        }
        lvs <- ulvs
      }
      if (drop) {
        olvs <- lvs
        lvs <- lvs[sort(unique(ans + 1))]
        ans <- match(olvs[ans + 1], lvs) - 1
      }
    }
  }
  structure(as.integer(ans + 1), levels = lvs, class = "factor")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
interactive
list(`package:base` = .Primitive("interactive"), .Primitive("interactive"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
intersect
list(`package:base` = function (x, y) 
{
  if (is.null(x) || is.null(y)) 
    return(NULL)
  u <- as.vector(x)
  v <- as.vector(y)
  c(u[!duplicated(unclass(u)) & (match(u, v, 0) > 0)], v[numeric()])
}, function (x, y, ...) 
  UseMethod("intersect"), function (x, y) 
  {
    if (is.null(x) || is.null(y)) 
      return(NULL)
    u <- as.vector(x)
    v <- as.vector(y)
    c(u[!duplicated(unclass(u)) & (match(u, v, 0) > 0)], v[numeric()])
  })
c("package:base", "namespace:generics", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
intToBits
list(`package:base` = function (x) 
  .Internal(intToBits(x)), function (x) 
    .Internal(intToBits(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
intToUtf8
list(`package:base` = function (x, multiple = FALSE, allow_surrogate_pairs = FALSE) 
  .Internal(intToUtf8(x, multiple, allow_surrogate_pairs)), function (x, multiple = FALSE, allow_surrogate_pairs = FALSE) 
    .Internal(intToUtf8(x, multiple, allow_surrogate_pairs)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
inverse.rle
list(`package:base` = function (x, ...) 
{
  if (is.null(le <- x$lengths) || is.null(v <- x$values) || length(le) != length(v)) 
    stop("invalid 'rle' structure")
  rep.int(v, le)
}, function (x, ...) 
{
  if (is.null(le <- x$lengths) || is.null(v <- x$values) || length(le) != length(v)) 
    stop("invalid 'rle' structure")
  rep.int(v, le)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
invisible
list(`package:base` = .Primitive("invisible"), .Primitive("invisible"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
invokeRestart
list(`package:base` = function (r, ...) 
{
  if (!isRestart(r)) {
    res <- findRestart(r)
    if (is.null(res)) 
      stop(gettextf("no 'restart' '%s' found", as.character(r)), domain = NA)
    r <- res
  }
  .Internal(.invokeRestart(r, list(...)))
}, function (r, ...) 
{
  if (!isRestart(r)) {
    res <- findRestart(r)
    if (is.null(res)) 
      stop(gettextf("no 'restart' '%s' found", as.character(r)), domain = NA)
    r <- res
  }
  .Internal(.invokeRestart(r, list(...)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
invokeRestartInteractively
list(`package:base` = function (r) 
{
  if (!interactive()) 
    stop("not an interactive session")
  if (!isRestart(r)) {
    res <- findRestart(r)
    if (is.null(res)) 
      stop(gettextf("no 'restart' '%s' found", as.character(r)), domain = NA)
    r <- res
  }
  if (is.null(r$interactive)) {
    pars <- names(restartFormals(r))
    args <- NULL
    if (length(pars)) {
      cat("Enter values for restart arguments:\n\n")
      for (p in pars) {
        if (p == "...") {
          prompt <- "... (a list): "
          args <- c(args, eval(parse(prompt = prompt)))
        }
        else {
          prompt <- paste0(p, ": ")
          args <- c(args, list(eval(parse(prompt = prompt))))
        }
      }
    }
  }
  else args <- r$interactive()
  .Internal(.invokeRestart(r, args))
}, function (r) 
{
  if (!interactive()) 
    stop("not an interactive session")
  if (!isRestart(r)) {
    res <- findRestart(r)
    if (is.null(res)) 
      stop(gettextf("no 'restart' '%s' found", as.character(r)), domain = NA)
    r <- res
  }
  if (is.null(r$interactive)) {
    pars <- names(restartFormals(r))
    args <- NULL
    if (length(pars)) {
      cat("Enter values for restart arguments:\n\n")
      for (p in pars) {
        if (p == "...") {
          prompt <- "... (a list): "
          args <- c(args, eval(parse(prompt = prompt)))
        }
        else {
          prompt <- paste0(p, ": ")
          args <- c(args, list(eval(parse(prompt = prompt))))
        }
      }
    }
  }
  else args <- r$interactive()
  .Internal(.invokeRestart(r, args))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.array
list(`package:base` = .Primitive("is.array"), .Primitive("is.array"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.atomic
list(`package:base` = .Primitive("is.atomic"), .Primitive("is.atomic"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.call
list(`package:base` = .Primitive("is.call"), .Primitive("is.call"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.character
list(`package:base` = .Primitive("is.character"), .Primitive("is.character"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.complex
list(`package:base` = .Primitive("is.complex"), .Primitive("is.complex"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.data.frame
list(`package:base` = function (x) 
  inherits(x, "data.frame"), function (x) 
    inherits(x, "data.frame"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.double
list(`package:base` = .Primitive("is.double"), .Primitive("is.double"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.element
list(`package:base` = function (el, set) 
  match(as.vector(el), as.vector(set), 0) > 0, function (el, set, ...) 
    UseMethod("is.element"), function (el, set) 
      match(as.vector(el), as.vector(set), 0) > 0)
c("package:base", "namespace:generics", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
is.environment
list(`package:base` = .Primitive("is.environment"), .Primitive("is.environment"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.expression
list(`package:base` = .Primitive("is.expression"), .Primitive("is.expression"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.factor
list(`package:base` = function (x) 
  inherits(x, "factor"), function (x) 
    inherits(x, "factor"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.finite
list(`package:base` = .Primitive("is.finite"), .Primitive("is.finite"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.function
list(`package:base` = .Primitive("is.function"), .Primitive("is.function"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.infinite
list(`package:base` = .Primitive("is.infinite"), .Primitive("is.infinite"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.integer
list(`package:base` = .Primitive("is.integer"), .Primitive("is.integer"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.language
list(`package:base` = .Primitive("is.language"), .Primitive("is.language"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.list
list(`package:base` = .Primitive("is.list"), .Primitive("is.list"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.loaded
list(`package:base` = function (symbol, PACKAGE = "", type = "") 
  .Internal(is.loaded(symbol, PACKAGE, type)), function (symbol, PACKAGE = "", type = "") 
    .Internal(is.loaded(symbol, PACKAGE, type)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.logical
list(`package:base` = .Primitive("is.logical"), .Primitive("is.logical"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.matrix
list(`package:base` = .Primitive("is.matrix"), .Primitive("is.matrix"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.na
list(`package:base` = .Primitive("is.na"), .Primitive("is.na"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.na.data.frame
list(`package:base` = function (x) 
{
  y <- if (length(x)) {
    do.call(cbind, lapply(x, is.na))
  }
  else matrix(FALSE, length(row.names(x)), 0)
  if (.row_names_info(x) > 0) 
    rownames(y) <- row.names(x)
  y
}, function (x) 
{
  y <- if (length(x)) {
    do.call(cbind, lapply(x, is.na))
  }
  else matrix(FALSE, length(row.names(x)), 0)
  if (.row_names_info(x) > 0) 
    rownames(y) <- row.names(x)
  y
}, function (x) 
{
  y <- if (length(x)) {
    do.call(cbind, lapply(x, is.na))
  }
  else matrix(FALSE, length(row.names(x)), 0)
  if (.row_names_info(x) > 0) 
    rownames(y) <- row.names(x)
  y
})
c("package:base", "registered S3 method for is.na from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.na.numeric_version
list(`package:base` = function (x) 
  is.na(.encode_numeric_version(x)), function (x) 
    is.na(.encode_numeric_version(x)), function (x) 
      is.na(.encode_numeric_version(x)))
c("package:base", "registered S3 method for is.na from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.na.POSIXlt
list(`package:base` = function (x) 
  is.na(as.POSIXct(x)), function (x) 
    is.na(as.POSIXct(x)), function (x) 
      is.na(as.POSIXct(x)))
c("package:base", "registered S3 method for is.na from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.na<-
  list(`package:base` = function (x, value) 
    UseMethod("is.na<-"), function (x, value) 
      UseMethod("is.na<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.na<-.default
list(`package:base` = function (x, value) 
{
  x[value] <- NA
  x
}, function (x, value) 
{
  x[value] <- NA
  x
}, function (x, value) 
{
  x[value] <- NA
  x
})
c("package:base", "registered S3 method for is.na<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.na<-.factor
list(`package:base` = function (x, value) 
{
  lx <- levels(x)
  cx <- oldClass(x)
  class(x) <- NULL
  x[value] <- NA
  structure(x, levels = lx, class = cx)
}, function (x, value) 
{
  lx <- levels(x)
  cx <- oldClass(x)
  class(x) <- NULL
  x[value] <- NA
  structure(x, levels = lx, class = cx)
}, function (x, value) 
{
  lx <- levels(x)
  cx <- oldClass(x)
  class(x) <- NULL
  x[value] <- NA
  structure(x, levels = lx, class = cx)
})
c("package:base", "registered S3 method for is.na<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.na<-.numeric_version
list(`package:base` = function (x, value) 
{
  x[value] <- rep.int(list(integer()), length(value))
  x
}, function (x, value) 
{
  x[value] <- rep.int(list(integer()), length(value))
  x
}, function (x, value) 
{
  x[value] <- rep.int(list(integer()), length(value))
  x
})
c("package:base", "registered S3 method for is.na<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.name
list(`package:base` = .Primitive("is.symbol"), .Primitive("is.symbol"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.nan
list(`package:base` = .Primitive("is.nan"), .Primitive("is.nan"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.null
list(`package:base` = .Primitive("is.null"), .Primitive("is.null"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.numeric
list(`package:base` = .Primitive("is.numeric"), .Primitive("is.numeric"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.numeric.Date
list(`package:base` = function (x) 
  FALSE, function (x) 
    FALSE, function (x) 
      FALSE)
c("package:base", "registered S3 method for is.numeric from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.numeric.difftime
list(`package:base` = function (x) 
  FALSE, function (x) 
    FALSE, function (x) 
      FALSE)
c("package:base", "registered S3 method for is.numeric from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.numeric.POSIXt
list(`package:base` = function (x) 
  FALSE, function (x) 
    FALSE, function (x) 
      FALSE)
c("package:base", "registered S3 method for is.numeric from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
is.numeric_version
list(`package:base` = function (x) 
  inherits(x, "numeric_version"), function (x) 
    inherits(x, "numeric_version"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.object
list(`package:base` = .Primitive("is.object"), .Primitive("is.object"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.ordered
list(`package:base` = function (x) 
  inherits(x, "ordered"), function (x) 
    inherits(x, "ordered"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.package_version
list(`package:base` = function (x) 
  inherits(x, "package_version"), function (x) 
    inherits(x, "package_version"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.pairlist
list(`package:base` = .Primitive("is.pairlist"), .Primitive("is.pairlist"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.primitive
list(`package:base` = function (x) 
  switch(typeof(x), special = , builtin = TRUE, FALSE), function (x) 
    switch(typeof(x), special = , builtin = TRUE, FALSE))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.qr
list(`package:base` = function (x) 
  is.list(x) && inherits(x, "qr"), function (x) 
    is.list(x) && inherits(x, "qr"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.R
list(`package:base` = function () 
  exists("version") && !is.null(vl <- version$language) && vl == "R", function () 
    exists("version") && !is.null(vl <- version$language) && vl == "R")
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.raw
list(`package:base` = .Primitive("is.raw"), .Primitive("is.raw"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.recursive
list(`package:base` = .Primitive("is.recursive"), .Primitive("is.recursive"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.single
list(`package:base` = .Primitive("is.single"), .Primitive("is.single"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.symbol
list(`package:base` = .Primitive("is.symbol"), .Primitive("is.symbol"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.table
list(`package:base` = function (x) 
  inherits(x, "table"), function (x) 
    inherits(x, "table"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.unsorted
list(`package:base` = function (x, na.rm = FALSE, strictly = FALSE) 
{
  if (length(x) <= 1) 
    return(FALSE)
  if (!na.rm && anyNA(x)) 
    return(NA)
  if (na.rm && any(ii <- is.na(x))) 
    x <- x[!ii]
  .Internal(is.unsorted(x, na.rm, strictly))
}, function (x, na.rm = FALSE, strictly = FALSE) 
{
  if (length(x) <= 1) 
    return(FALSE)
  if (!na.rm && anyNA(x)) 
    return(NA)
  if (na.rm && any(ii <- is.na(x))) 
    x <- x[!ii]
  .Internal(is.unsorted(x, na.rm, strictly))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.vector
list(`package:base` = function (x, mode = "any") 
  .Internal(is.vector(x, mode)), function (x, mode = "any") 
    .Internal(is.vector(x, mode)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isa
list(`package:base` = function (x, what) 
{
  if (isS4(x)) 
    methods::is(x, what)
  else all(class(x) %in% what)
}, function (x, what) 
{
  if (isS4(x)) 
    methods::is(x, what)
  else all(class(x) %in% what)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isatty
list(`package:base` = function (con) 
{
  if (!inherits(con, "terminal")) 
    FALSE
  else .Internal(isatty(con))
}, function (con) 
{
  if (!inherits(con, "terminal")) 
    FALSE
  else .Internal(isatty(con))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isBaseNamespace
list(`package:base` = function (ns) 
  identical(ns, .BaseNamespaceEnv), function (ns) 
    identical(ns, .BaseNamespaceEnv))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isdebugged
list(`package:base` = function (fun, signature = NULL) 
{
  if (is.null(signature)) 
    .Internal(isdebugged(fun))
  else if (requireNamespace("methods")) 
    methods::.isMethodDebugged(fun, signature)
  else stop("failed to load methods package for handling signature")
}, function (fun, signature = NULL) 
{
  if (is.null(signature)) 
    .Internal(isdebugged(fun))
  else if (requireNamespace("methods")) 
    methods::.isMethodDebugged(fun, signature)
  else stop("failed to load methods package for handling signature")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isFALSE
list(`package:base` = function (x) 
  is.logical(x) && length(x) == 1 && !is.na(x) && !x, function (x) 
  {
    is.logical(x) && length(x) == 1 && !is.na(x) && !x
  }, function (x) 
  {
    is.logical(x) && length(x) == 1 && !is.na(x) && !x
  }, function (x) 
  {
    is.logical(x) && length(x) == 1 && !is.na(x) && !x
  }, function (x) 
  {
    is.logical(x) && length(x) == 1 && !is.na(x) && !x
  }, function (x) 
    is.logical(x) && length(x) == 1 && !is.na(x) && !x)
c("package:base", "namespace:future", "namespace:parallelly", "namespace:cli", "namespace:future.apply", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)
isIncomplete
list(`package:base` = function (con) 
  .Internal(isIncomplete(con)), function (con) 
    .Internal(isIncomplete(con)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isNamespace
list(`package:base` = function (ns) 
  .Internal(isNamespaceEnv(ns)), function (ns) 
    .Internal(isNamespaceEnv(ns)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isNamespaceLoaded
list(`package:base` = function (name) 
  .Internal(isRegisteredNamespace(name)), function (name) 
  {
    name %in% loadedNamespaces()
  }, function (name) 
    .Internal(isRegisteredNamespace(name)))
c("package:base", "namespace:tidyselect", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
ISOdate
list(`package:base` = function (year, month, day, hour = 12, min = 0, sec = 0, tz = "GMT") 
  ISOdatetime(year, month, day, hour, min, sec, tz), function (year, month, day, hour = 12, min = 0, sec = 0, tz = "GMT") 
    ISOdatetime(year, month, day, hour, min, sec, tz))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
ISOdatetime
list(`package:base` = function (year, month, day, hour, min, sec, tz = "") 
{
  if (min(vapply(list(year, month, day, hour, min, sec), length, 1, USE.NAMES = FALSE)) == 0) 
    .POSIXct(numeric(), tz = tz)
  else {
    x <- paste(year, month, day, hour, min, sec, sep = "-")
    as.POSIXct(strptime(x, "%Y-%m-%d-%H-%M-%OS", tz = tz), tz = tz)
  }
}, function (year, month, day, hour, min, sec, tz = "") 
{
  if (min(vapply(list(year, month, day, hour, min, sec), length, 1, USE.NAMES = FALSE)) == 0) 
    .POSIXct(numeric(), tz = tz)
  else {
    x <- paste(year, month, day, hour, min, sec, sep = "-")
    as.POSIXct(strptime(x, "%Y-%m-%d-%H-%M-%OS", tz = tz), tz = tz)
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isOpen
list(`package:base` = function (con, rw = "") 
{
  rw <- pmatch(rw, c("read", "write"), 0)
  .Internal(isOpen(con, rw))
}, function (con, rw = "") 
{
  rw <- pmatch(rw, c("read", "write"), 0)
  .Internal(isOpen(con, rw))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isRestart
list(`package:base` = function (x) 
  inherits(x, "restart"), function (x) 
    inherits(x, "restart"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isS4
list(`package:base` = .Primitive("isS4"), .Primitive("isS4"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isSeekable
list(`package:base` = function (con) 
  .Internal(isSeekable(con)), function (con) 
    .Internal(isSeekable(con)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
isSymmetric
list(`package:base` = function (object, ...) 
  UseMethod("isSymmetric"), new("standardGeneric", .Data = function (object, ...) 
    standardGeneric("isSymmetric"), generic = "isSymmetric", package = "base", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object, ...) 
      UseMethod("isSymmetric"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "isSymmetric"), skeleton = (new("derivedDefaultMethod", .Data = function (object, ...) 
        UseMethod("isSymmetric"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "isSymmetric"))(object, ...)), function (object, ...) 
          UseMethod("isSymmetric"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
isSymmetric.matrix
list(`package:base` = function (object, tol = 100 * .Machine$double.eps, tol1 = 8 * tol, ...) 
{
  if (!is.matrix(object)) 
    return(FALSE)
  d <- dim(object)
  if ((n <- d[1]) != d[2]) 
    return(FALSE)
  iCplx <- is.complex(object)
  if (n > 1 && length(tol1)) {
    Cj <- if (iCplx) 
      Conj
    else identity
    for (i in unique(c(1, 2, n - 1, n))) if (is.character(all.equal(object[i, ], Cj(object[, i]), tolerance = tol1, ...))) 
      return(FALSE)
  }
  test <- if (iCplx) 
    all.equal.numeric(object, Conj(t(object)), tolerance = tol, ...)
  else all.equal(object, t(object), tolerance = tol, ...)
  isTRUE(test)
}, function (object, tol = 100 * .Machine$double.eps, tol1 = 8 * tol, ...) 
{
  if (!is.matrix(object)) 
    return(FALSE)
  d <- dim(object)
  if ((n <- d[1]) != d[2]) 
    return(FALSE)
  iCplx <- is.complex(object)
  if (n > 1 && length(tol1)) {
    Cj <- if (iCplx) 
      Conj
    else identity
    for (i in unique(c(1, 2, n - 1, n))) if (is.character(all.equal(object[i, ], Cj(object[, i]), tolerance = tol1, ...))) 
      return(FALSE)
  }
  test <- if (iCplx) 
    all.equal.numeric(object, Conj(t(object)), tolerance = tol, ...)
  else all.equal(object, t(object), tolerance = tol, ...)
  isTRUE(test)
}, function (object, tol = 100 * .Machine$double.eps, tol1 = 8 * tol, ...) 
{
  if (!is.matrix(object)) 
    return(FALSE)
  d <- dim(object)
  if ((n <- d[1]) != d[2]) 
    return(FALSE)
  iCplx <- is.complex(object)
  if (n > 1 && length(tol1)) {
    Cj <- if (iCplx) 
      Conj
    else identity
    for (i in unique(c(1, 2, n - 1, n))) if (is.character(all.equal(object[i, ], Cj(object[, i]), tolerance = tol1, ...))) 
      return(FALSE)
  }
  test <- if (iCplx) 
    all.equal.numeric(object, Conj(t(object)), tolerance = tol, ...)
  else all.equal(object, t(object), tolerance = tol, ...)
  isTRUE(test)
})
c("package:base", "registered S3 method for isSymmetric from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
isTRUE
list(`package:base` = function (x) 
  is.logical(x) && length(x) == 1 && !is.na(x) && x, function (x) 
    is.logical(x) && length(x) == 1 && !is.na(x) && x)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
jitter
list(`package:base` = function (x, factor = 1, amount = NULL) 
{
  if (length(x) == 0) 
    return(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  z <- diff(r <- range(x[is.finite(x)]))
  if (z == 0) 
    z <- abs(r[1])
  if (z == 0) 
    z <- 1
  if (is.null(amount)) {
    d <- diff(xx <- unique(sort.int(round(x, 3 - floor(log10(z))))))
    d <- if (length(d)) 
      min(d)
    else if (xx != 0) 
      xx/10
    else z/10
    amount <- factor/5 * abs(d)
  }
  else if (amount == 0) 
    amount <- factor * (z/50)
  x + stats::runif(length(x), -amount, amount)
}, function (x, factor = 1, amount = NULL) 
{
  if (length(x) == 0) 
    return(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  z <- diff(r <- range(x[is.finite(x)]))
  if (z == 0) 
    z <- abs(r[1])
  if (z == 0) 
    z <- 1
  if (is.null(amount)) {
    d <- diff(xx <- unique(sort.int(round(x, 3 - floor(log10(z))))))
    d <- if (length(d)) 
      min(d)
    else if (xx != 0) 
      xx/10
    else z/10
    amount <- factor/5 * abs(d)
  }
  else if (amount == 0) 
    amount <- factor * (z/50)
  x + stats::runif(length(x), -amount, amount)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
julian
list(`package:base` = function (x, ...) 
  UseMethod("julian"), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("julian"), generic = "julian", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
      UseMethod("julian"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "julian"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("julian"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "julian"))(x, ...)), function (x, ...) 
          UseMethod("julian"))
c("package:base", "namespace:timeDate", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
julian.Date
list(`package:base` = function (x, origin = as.Date("1970-01-01"), ...) 
{
  if (length(origin) != 1) 
    stop("'origin' must be of length one")
  structure(unclass(x) - unclass(origin), origin = origin)
}, function (x, origin = as.Date("1970-01-01"), ...) 
{
  if (length(origin) != 1) 
    stop("'origin' must be of length one")
  structure(unclass(x) - unclass(origin), origin = origin)
}, function (x, origin = as.Date("1970-01-01"), ...) 
{
  if (length(origin) != 1) 
    stop("'origin' must be of length one")
  structure(unclass(x) - unclass(origin), origin = origin)
})
c("package:base", "registered S3 method for julian from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
julian.POSIXt
list(`package:base` = function (x, origin = as.POSIXct("1970-01-01", tz = "GMT"), ...) 
{
  origin <- as.POSIXct(origin)
  if (length(origin) != 1) 
    stop("'origin' must be of length one")
  res <- difftime(as.POSIXct(x), origin, units = "days")
  structure(res, origin = origin)
}, function (x, origin = as.POSIXct("1970-01-01", tz = "GMT"), ...) 
{
  origin <- as.POSIXct(origin)
  if (length(origin) != 1) 
    stop("'origin' must be of length one")
  res <- difftime(as.POSIXct(x), origin, units = "days")
  structure(res, origin = origin)
}, function (x, origin = as.POSIXct("1970-01-01", tz = "GMT"), ...) 
{
  origin <- as.POSIXct(origin)
  if (length(origin) != 1) 
    stop("'origin' must be of length one")
  res <- difftime(as.POSIXct(x), origin, units = "days")
  structure(res, origin = origin)
})
c("package:base", "registered S3 method for julian from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
kappa
list(`package:base` = function (z, ...) 
  UseMethod("kappa"), function (actual, predicted, cutoff = 0.5) 
  {
    kappa_(actual, predicted, cutoff)
  }, function (z, ...) 
    UseMethod("kappa"))
c("package:base", "namespace:ModelMetrics", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
kappa.default
list(`package:base` = function (z, exact = FALSE, norm = NULL, method = c("qr", "direct"), ...) 
{
  method <- match.arg(method)
  z <- as.matrix(z)
  norm <- if (!is.null(norm)) 
    match.arg(norm, c("2", "1", "O", "I"))
  else "2"
  if (exact && norm == "2") {
    s <- svd(z, nu = 0, nv = 0)$d
    max(s)/min(s[s > 0])
  }
  else {
    if (exact) 
      warning(gettextf("norm '%s' currently always uses exact = FALSE", norm))
    d <- dim(z)
    if (method == "qr" || d[1] != d[2]) 
      kappa.qr(qr(if (d[1] < d[2]) 
        t(z)
        else z), exact = FALSE, norm = norm, ...)
    else .kappa_tri(z, exact = FALSE, norm = norm, ...)
  }
}, function (z, exact = FALSE, norm = NULL, method = c("qr", "direct"), ...) 
{
  method <- match.arg(method)
  z <- as.matrix(z)
  norm <- if (!is.null(norm)) 
    match.arg(norm, c("2", "1", "O", "I"))
  else "2"
  if (exact && norm == "2") {
    s <- svd(z, nu = 0, nv = 0)$d
    max(s)/min(s[s > 0])
  }
  else {
    if (exact) 
      warning(gettextf("norm '%s' currently always uses exact = FALSE", norm))
    d <- dim(z)
    if (method == "qr" || d[1] != d[2]) 
      kappa.qr(qr(if (d[1] < d[2]) 
        t(z)
        else z), exact = FALSE, norm = norm, ...)
    else .kappa_tri(z, exact = FALSE, norm = norm, ...)
  }
}, function (z, exact = FALSE, norm = NULL, method = c("qr", "direct"), ...) 
{
  method <- match.arg(method)
  z <- as.matrix(z)
  norm <- if (!is.null(norm)) 
    match.arg(norm, c("2", "1", "O", "I"))
  else "2"
  if (exact && norm == "2") {
    s <- svd(z, nu = 0, nv = 0)$d
    max(s)/min(s[s > 0])
  }
  else {
    if (exact) 
      warning(gettextf("norm '%s' currently always uses exact = FALSE", norm))
    d <- dim(z)
    if (method == "qr" || d[1] != d[2]) 
      kappa.qr(qr(if (d[1] < d[2]) 
        t(z)
        else z), exact = FALSE, norm = norm, ...)
    else .kappa_tri(z, exact = FALSE, norm = norm, ...)
  }
})
c("package:base", "registered S3 method for kappa from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
kappa.lm
list(`package:base` = function (z, ...) 
  kappa.qr(z$qr, ...), function (z, ...) 
    kappa.qr(z$qr, ...), function (z, ...) 
      kappa.qr(z$qr, ...))
c("package:base", "registered S3 method for kappa from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
kappa.qr
list(`package:base` = function (z, ...) 
{
  qr <- z$qr
  R <- qr[1:min(dim(qr)), , drop = FALSE]
  R[lower.tri(R)] <- 0
  .kappa_tri(R, ...)
}, function (z, ...) 
{
  qr <- z$qr
  R <- qr[1:min(dim(qr)), , drop = FALSE]
  R[lower.tri(R)] <- 0
  .kappa_tri(R, ...)
}, function (z, ...) 
{
  qr <- z$qr
  R <- qr[1:min(dim(qr)), , drop = FALSE]
  R[lower.tri(R)] <- 0
  .kappa_tri(R, ...)
})
c("package:base", "registered S3 method for kappa from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
kronecker
list(`package:methods` = new("standardGeneric", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  standardGeneric("kronecker"), generic = "kronecker", package = "base", group = list(), valueClass = character(0), signature = c("X", "Y", "FUN", "make.dimnames"), default = new("derivedDefaultMethod", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
      return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
    }
    .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
  }, target = new("signature", .Data = "ANY", names = "X", package = "methods"), defined = new("signature", .Data = "ANY", names = "X", package = "methods"), generic = "kronecker"), skeleton = (new("derivedDefaultMethod", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
      return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
    }
    .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
  }, target = new("signature", .Data = "ANY", names = "X", package = "methods"), defined = new("signature", .Data = "ANY", names = "X", package = "methods"), generic = "kronecker"))(X, Y, FUN, make.dimnames, ...)), `package:base` = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
  {
    if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
      return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
    }
    .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
  }, new("standardGeneric", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
    standardGeneric("kronecker"), generic = "kronecker", package = "base", group = list(), valueClass = character(0), signature = c("X", "Y", "FUN", "make.dimnames"), default = new("derivedDefaultMethod", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
    {
      if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
        return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
      }
      .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
    }, target = new("signature", .Data = "ANY", names = "X", package = "methods"), defined = new("signature", .Data = "ANY", names = "X", package = "methods"), generic = "kronecker"), skeleton = (new("derivedDefaultMethod", .Data = function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
    {
      if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
        return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
      }
      .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
    }, target = new("signature", .Data = "ANY", names = "X", package = "methods"), defined = new("signature", .Data = "ANY", names = "X", package = "methods"), generic = "kronecker"))(X, Y, FUN, make.dimnames, ...)), function (X, Y, FUN = "*", make.dimnames = FALSE, ...) 
    {
      if (.isMethodsDispatchOn() && (isS4(X) || isS4(Y))) {
        return(methods::kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...))
      }
      .kronecker(X, Y, FUN = FUN, make.dimnames = make.dimnames, ...)
    })
c("package:methods", "package:base", "namespace:methods", "namespace:base")
c(TRUE, TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
l10n_info
list(`package:base` = function () 
  .Internal(l10n_info()), function () 
    .Internal(l10n_info()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
La.svd
list(`package:base` = function (x, nu = min(n, p), nv = min(n, p)) 
{
  if (!is.logical(x) && !is.numeric(x) && !is.complex(x)) 
    stop("argument to 'La.svd' must be numeric or complex")
  if (any(!is.finite(x))) 
    stop("infinite or missing values in 'x'")
  x <- as.matrix(x)
  n <- nrow(x)
  p <- ncol(x)
  if (!n || !p) 
    stop("a dimension is zero")
  zero <- if (is.complex(x)) 
    0 + (0+0i)
  else 0
  if (nu || nv) {
    np <- min(n, p)
    if (nu <= np && nv <= np) {
      jobu <- "S"
      u <- matrix(zero, n, np)
      vt <- matrix(zero, np, p)
      nu0 <- nv0 <- np
    }
    else {
      jobu <- "A"
      u <- matrix(zero, n, n)
      vt <- matrix(zero, p, p)
      nu0 <- n
      nv0 <- p
    }
  }
  else {
    jobu <- "N"
    u <- matrix(zero, 1, 1)
    vt <- matrix(zero, 1, 1)
  }
  res <- if (is.complex(x)) 
    .Internal(La_svd_cmplx(jobu, x, double(min(n, p)), u, vt))
  else .Internal(La_svd(jobu, x, double(min(n, p)), u, vt))
  res <- res[c("d", if (nu) "u", if (nv) "vt")]
  if (nu && nu < nu0) 
    res$u <- res$u[, seq_len(min(n, nu)), drop = FALSE]
  if (nv && nv < nv0) 
    res$vt <- res$vt[seq_len(min(p, nv)), , drop = FALSE]
  res
}, function (x, nu = min(n, p), nv = min(n, p)) 
{
  if (!is.logical(x) && !is.numeric(x) && !is.complex(x)) 
    stop("argument to 'La.svd' must be numeric or complex")
  if (any(!is.finite(x))) 
    stop("infinite or missing values in 'x'")
  x <- as.matrix(x)
  n <- nrow(x)
  p <- ncol(x)
  if (!n || !p) 
    stop("a dimension is zero")
  zero <- if (is.complex(x)) 
    0 + (0+0i)
  else 0
  if (nu || nv) {
    np <- min(n, p)
    if (nu <= np && nv <= np) {
      jobu <- "S"
      u <- matrix(zero, n, np)
      vt <- matrix(zero, np, p)
      nu0 <- nv0 <- np
    }
    else {
      jobu <- "A"
      u <- matrix(zero, n, n)
      vt <- matrix(zero, p, p)
      nu0 <- n
      nv0 <- p
    }
  }
  else {
    jobu <- "N"
    u <- matrix(zero, 1, 1)
    vt <- matrix(zero, 1, 1)
  }
  res <- if (is.complex(x)) 
    .Internal(La_svd_cmplx(jobu, x, double(min(n, p)), u, vt))
  else .Internal(La_svd(jobu, x, double(min(n, p)), u, vt))
  res <- res[c("d", if (nu) "u", if (nv) "vt")]
  if (nu && nu < nu0) 
    res$u <- res$u[, seq_len(min(n, nu)), drop = FALSE]
  if (nv && nv < nv0) 
    res$vt <- res$vt[seq_len(min(p, nv)), , drop = FALSE]
  res
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
La_library
list(`package:base` = function () 
  .Internal(La_library()), function () 
    .Internal(La_library()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
La_version
list(`package:base` = function () 
  .Internal(La_version()), function () 
    .Internal(La_version()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
labels
list(`package:base` = function (object, ...) 
  UseMethod("labels"), function (object, ...) 
    UseMethod("labels"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
labels.default
list(`package:base` = function (object, ...) 
{
  if (length(d <- dim(object))) {
    nt <- dimnames(object)
    if (is.null(nt)) 
      nt <- vector("list", length(d))
    for (i in seq_along(d)) if (!length(nt[[i]])) 
      nt[[i]] <- as.character(seq_len(d[i]))
  }
  else {
    nt <- names(object)
    if (!length(nt)) 
      nt <- as.character(seq_along(object))
  }
  nt
}, function (object, ...) 
{
  if (length(d <- dim(object))) {
    nt <- dimnames(object)
    if (is.null(nt)) 
      nt <- vector("list", length(d))
    for (i in seq_along(d)) if (!length(nt[[i]])) 
      nt[[i]] <- as.character(seq_len(d[i]))
  }
  else {
    nt <- names(object)
    if (!length(nt)) 
      nt <- as.character(seq_along(object))
  }
  nt
}, function (object, ...) 
{
  if (length(d <- dim(object))) {
    nt <- dimnames(object)
    if (is.null(nt)) 
      nt <- vector("list", length(d))
    for (i in seq_along(d)) if (!length(nt[[i]])) 
      nt[[i]] <- as.character(seq_len(d[i]))
  }
  else {
    nt <- names(object)
    if (!length(nt)) 
      nt <- as.character(seq_along(object))
  }
  nt
})
c("package:base", "registered S3 method for labels from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
lapply
list(`package:base` = function (X, FUN, ...) 
{
  FUN <- match.fun(FUN)
  if (!is.vector(X) || is.object(X)) 
    X <- as.list(X)
  .Internal(lapply(X, FUN))
}, function (X, FUN, ...) 
{
  FUN <- match.fun(FUN)
  if (!is.vector(X) || is.object(X)) 
    X <- as.list(X)
  .Internal(lapply(X, FUN))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lazyLoad
list(`package:base` = function (filebase, envir = parent.frame(), filter) 
{
  fun <- function(db) {
    vals <- db$vals
    vars <- db$vars
    expr <- quote(lazyLoadDBfetch(key, datafile, compressed, envhook))
    .Internal(makeLazy(vars, vals, expr, db, envir))
  }
  lazyLoadDBexec(filebase, fun, filter)
}, function (filebase, envir = parent.frame(), filter) 
{
  fun <- function(db) {
    vals <- db$vals
    vars <- db$vars
    expr <- quote(lazyLoadDBfetch(key, datafile, compressed, envhook))
    .Internal(makeLazy(vars, vals, expr, db, envir))
  }
  lazyLoadDBexec(filebase, fun, filter)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lazyLoadDBexec
list(`package:base` = function (filebase, fun, filter) 
{
  glue <- function(..., sep = " ", collapse = NULL) .Internal(paste(list(...), sep, collapse, FALSE))
  readRDS <- function(file) {
    halt <- function(message) .Internal(stop(TRUE, message))
    gzfile <- function(description, open) .Internal(gzfile(description, open, "", 6))
    close <- function(con) .Internal(close(con, "rw"))
    if (!is.character(file)) 
      halt("bad file name")
    con <- gzfile(file, "rb")
    on.exit(close(con))
    .Internal(unserializeFromConn(con, baseenv()))
  }
  `parent.env<-` <- function(env, value) .Internal(`parent.env<-`(env, value))
  existsInFrame <- function(x, env) .Internal(exists(x, env, "any", FALSE))
  list2env <- function(x, envir) .Internal(list2env(x, envir))
  environment <- function() .Internal(environment(NULL))
  mkenv <- function() .Internal(new.env(TRUE, baseenv(), 29))
  mapfile <- glue(filebase, "rdx", sep = ".")
  datafile <- glue(filebase, "rdb", sep = ".")
  env <- mkenv()
  map <- readRDS(mapfile)
  vars <- names(map$variables)
  compressed <- map$compressed
  list2env(map$references, env)
  envenv <- mkenv()
  envhook <- function(n) {
    if (existsInFrame(n, envenv)) 
      envenv[[n]]
    else {
      e <- mkenv()
      envenv[[n]] <- e
      key <- env[[n]]
      ekey <- if (is.list(key)) 
        key$eagerKey
      else key
      data <- lazyLoadDBfetch(ekey, datafile, compressed, envhook)
      parent.env(e) <- if (!is.null(data$enclos)) 
        data$enclos
      else emptyenv()
      list2env(data$bindings, e)
      if (!is.null(data$attributes)) 
        attributes(e) <- data$attributes
      if (!is.null(data$isS4) && data$isS4) 
        .Internal(setS4Object(e, TRUE, TRUE))
      if (is.list(key)) {
        expr <- quote(lazyLoadDBfetch(KEY, datafile, compressed, envhook))
        .Internal(makeLazy(names(key$lazyKeys), key$lazyKeys, expr, parent.env(environment()), e))
      }
      if (!is.null(data$locked) && data$locked) 
        .Internal(lockEnvironment(e, FALSE))
      e
    }
  }
  if (!missing(filter)) {
    use <- filter(vars)
    vars <- vars[use]
    vals <- map$variables[use]
    use <- NULL
  }
  else vals <- map$variables
  res <- fun(environment())
  map <- NULL
  vars <- NULL
  vals <- NULL
  rvars <- NULL
  mapfile <- NULL
  readRDS <- NULL
  res
}, function (filebase, fun, filter) 
{
  glue <- function(..., sep = " ", collapse = NULL) .Internal(paste(list(...), sep, collapse, FALSE))
  readRDS <- function(file) {
    halt <- function(message) .Internal(stop(TRUE, message))
    gzfile <- function(description, open) .Internal(gzfile(description, open, "", 6))
    close <- function(con) .Internal(close(con, "rw"))
    if (!is.character(file)) 
      halt("bad file name")
    con <- gzfile(file, "rb")
    on.exit(close(con))
    .Internal(unserializeFromConn(con, baseenv()))
  }
  `parent.env<-` <- function(env, value) .Internal(`parent.env<-`(env, value))
  existsInFrame <- function(x, env) .Internal(exists(x, env, "any", FALSE))
  list2env <- function(x, envir) .Internal(list2env(x, envir))
  environment <- function() .Internal(environment(NULL))
  mkenv <- function() .Internal(new.env(TRUE, baseenv(), 29))
  mapfile <- glue(filebase, "rdx", sep = ".")
  datafile <- glue(filebase, "rdb", sep = ".")
  env <- mkenv()
  map <- readRDS(mapfile)
  vars <- names(map$variables)
  compressed <- map$compressed
  list2env(map$references, env)
  envenv <- mkenv()
  envhook <- function(n) {
    if (existsInFrame(n, envenv)) 
      envenv[[n]]
    else {
      e <- mkenv()
      envenv[[n]] <- e
      key <- env[[n]]
      ekey <- if (is.list(key)) 
        key$eagerKey
      else key
      data <- lazyLoadDBfetch(ekey, datafile, compressed, envhook)
      parent.env(e) <- if (!is.null(data$enclos)) 
        data$enclos
      else emptyenv()
      list2env(data$bindings, e)
      if (!is.null(data$attributes)) 
        attributes(e) <- data$attributes
      if (!is.null(data$isS4) && data$isS4) 
        .Internal(setS4Object(e, TRUE, TRUE))
      if (is.list(key)) {
        expr <- quote(lazyLoadDBfetch(KEY, datafile, compressed, envhook))
        .Internal(makeLazy(names(key$lazyKeys), key$lazyKeys, expr, parent.env(environment()), e))
      }
      if (!is.null(data$locked) && data$locked) 
        .Internal(lockEnvironment(e, FALSE))
      e
    }
  }
  if (!missing(filter)) {
    use <- filter(vars)
    vars <- vars[use]
    vals <- map$variables[use]
    use <- NULL
  }
  else vals <- map$variables
  res <- fun(environment())
  map <- NULL
  vars <- NULL
  vals <- NULL
  rvars <- NULL
  mapfile <- NULL
  readRDS <- NULL
  res
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lazyLoadDBfetch
list(`package:base` = .Primitive("lazyLoadDBfetch"), .Primitive("lazyLoadDBfetch"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lbeta
list(`package:base` = function (a, b) 
  .Internal(lbeta(a, b)), function (a, b) 
    .Internal(lbeta(a, b)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lchoose
list(`package:base` = function (n, k) 
  .Internal(lchoose(n, k)), function (n, k) 
    .Internal(lchoose(n, k)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
length
list(`package:base` = .Primitive("length"), .Primitive("length"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
length.POSIXlt
list(`package:base` = function (x) 
  length(unclass(x)[[1]]), function (x) 
    length(unclass(x)[[1]]), function (x) 
      length(unclass(x)[[1]]))
c("package:base", "registered S3 method for length from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
length<-
  list(`package:base` = .Primitive("length<-"), .Primitive("length<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
length<-.Date
list(`package:base` = function (x, value) 
  .Date(NextMethod(), oldClass(x)), function (x, value) 
    .Date(NextMethod(), oldClass(x)), function (x, value) 
      .Date(NextMethod(), oldClass(x)))
c("package:base", "registered S3 method for length<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
length<-.difftime
list(`package:base` = function (x, value) 
  .difftime(NextMethod(), attr(x, "units"), oldClass(x)), function (x, value) 
    .difftime(NextMethod(), attr(x, "units"), oldClass(x)), function (x, value) 
      .difftime(NextMethod(), attr(x, "units"), oldClass(x)))
c("package:base", "registered S3 method for length<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
length<-.factor
list(`package:base` = function (x, value) 
{
  cl <- class(x)
  levs <- levels(x)
  x <- NextMethod()
  structure(x, levels = levs, class = cl)
}, function (x, value) 
{
  cl <- class(x)
  levs <- levels(x)
  x <- NextMethod()
  structure(x, levels = levs, class = cl)
}, function (x, value) 
{
  cl <- class(x)
  levs <- levels(x)
  x <- NextMethod()
  structure(x, levels = levs, class = cl)
})
c("package:base", "registered S3 method for length<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
length<-.POSIXct
list(`package:base` = function (x, value) 
  .POSIXct(NextMethod(), attr(x, "tzone"), oldClass(x)), function (x, value) 
    .POSIXct(NextMethod(), attr(x, "tzone"), oldClass(x)), function (x, value) 
      .POSIXct(NextMethod(), attr(x, "tzone"), oldClass(x)))
c("package:base", "registered S3 method for length<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
length<-.POSIXlt
list(`package:base` = function (x, value) 
  .POSIXlt(lapply(unclass(x), `length<-`, value), attr(x, "tzone"), oldClass(x)), function (x, value) 
    .POSIXlt(lapply(unclass(x), `length<-`, value), attr(x, "tzone"), oldClass(x)), function (x, value) 
      .POSIXlt(lapply(unclass(x), `length<-`, value), attr(x, "tzone"), oldClass(x)))
c("package:base", "registered S3 method for length<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
lengths
list(`package:base` = function (x, use.names = TRUE) 
  .Internal(lengths(x, use.names)), function (x) 
  {
    vapply(x, length, integer(1))
  }, function (x, use.names = TRUE) 
    .Internal(lengths(x, use.names)))
c("package:base", "namespace:glue", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
letters
list(`package:base` = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"), c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
LETTERS
list(`package:base` = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"), c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
levels
list(`package:base` = function (x) 
  UseMethod("levels"), function (x) 
    UseMethod("levels"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
levels.default
list(`package:base` = function (x) 
  attr(x, "levels"), function (x) 
    attr(x, "levels"), function (x) 
      attr(x, "levels"))
c("package:base", "registered S3 method for levels from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
levels<-
  list(`package:base` = .Primitive("levels<-"), .Primitive("levels<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
levels<-.factor
list(`package:base` = function (x, value) 
{
  xlevs <- levels(x)
  if (is.list(value)) {
    nlevs <- rep.int(names(value), lapply(value, length))
    value <- unlist(value)
    m <- match(value, xlevs, nomatch = 0)
    xlevs[m] <- nlevs[m > 0]
  }
  else {
    if (length(xlevs) > length(value)) 
      stop("number of levels differs")
    nlevs <- xlevs <- as.character(value)
    nlevs <- nlevs[!is.na(nlevs)]
  }
  nlevs <- unique(nlevs)
  at <- attributes(x)
  at$levels <- nlevs
  y <- match(xlevs, nlevs)[x]
  attributes(y) <- at
  y
}, function (x, value) 
{
  xlevs <- levels(x)
  if (is.list(value)) {
    nlevs <- rep.int(names(value), lapply(value, length))
    value <- unlist(value)
    m <- match(value, xlevs, nomatch = 0)
    xlevs[m] <- nlevs[m > 0]
  }
  else {
    if (length(xlevs) > length(value)) 
      stop("number of levels differs")
    nlevs <- xlevs <- as.character(value)
    nlevs <- nlevs[!is.na(nlevs)]
  }
  nlevs <- unique(nlevs)
  at <- attributes(x)
  at$levels <- nlevs
  y <- match(xlevs, nlevs)[x]
  attributes(y) <- at
  y
}, function (x, value) 
{
  xlevs <- levels(x)
  if (is.list(value)) {
    nlevs <- rep.int(names(value), lapply(value, length))
    value <- unlist(value)
    m <- match(value, xlevs, nomatch = 0)
    xlevs[m] <- nlevs[m > 0]
  }
  else {
    if (length(xlevs) > length(value)) 
      stop("number of levels differs")
    nlevs <- xlevs <- as.character(value)
    nlevs <- nlevs[!is.na(nlevs)]
  }
  nlevs <- unique(nlevs)
  at <- attributes(x)
  at$levels <- nlevs
  y <- match(xlevs, nlevs)[x]
  attributes(y) <- at
  y
})
c("package:base", "registered S3 method for levels<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
lfactorial
list(`package:base` = function (x) 
  lgamma(x + 1), function (x) 
    lgamma(x + 1))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lgamma
list(`package:base` = .Primitive("lgamma"), .Primitive("lgamma"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
libcurlVersion
list(`package:base` = function () 
  .Internal(curlVersion()), function () 
    .Internal(curlVersion()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
library
list(`package:base` = function (package, help, pos = 2, lib.loc = NULL, character.only = FALSE, logical.return = FALSE, warn.conflicts, quietly = FALSE, verbose = getOption("verbose"), mask.ok, exclude, include.only, attach.required = missing(include.only)) 
{
  conf.ctrl <- getOption("conflicts.policy")
  if (is.character(conf.ctrl)) 
    conf.ctrl <- switch(conf.ctrl, strict = list(error = TRUE, warn = FALSE), depends.ok = list(error = TRUE, generics.ok = TRUE, can.mask = c("base", "methods", "utils", "grDevices", "graphics", "stats"), depends.ok = TRUE), warning(gettextf("unknown conflict policy: %s", sQuote(conf.ctrl)), call. = FALSE, domain = NA))
  if (!is.list(conf.ctrl)) 
    conf.ctrl <- NULL
  stopOnConflict <- isTRUE(conf.ctrl$error)
  if (missing(warn.conflicts)) 
    warn.conflicts <- !isFALSE(conf.ctrl$warn)
  if (!missing(include.only) && !missing(exclude)) 
    stop("only one of 'include.only' and 'exclude' can be used", call. = FALSE)
  testRversion <- function(pkgInfo, pkgname, pkgpath) {
    if (is.null(built <- pkgInfo$Built)) 
      stop(gettextf("package %s has not been installed properly\n", sQuote(pkgname)), call. = FALSE, domain = NA)
    R_version_built_under <- as.numeric_version(built$R)
    if (R_version_built_under < "3.0.0") 
      stop(gettextf("package %s was built before R 3.0.0: please re-install it", sQuote(pkgname)), call. = FALSE, domain = NA)
    current <- getRversion()
    if (length(Rdeps <- pkgInfo$Rdepends2)) {
      for (dep in Rdeps) if (length(dep) > 1) {
        target <- dep$version
        res <- do.call(dep$op, if (is.character(target)) 
          list(as.numeric(R.version[["svn rev"]]), as.numeric(sub("^r", "", target)))
          else list(current, as.numeric_version(target)))
        if (!res) 
          stop(gettextf("This is R %s, package %s needs %s %s", current, sQuote(pkgname), dep$op, target), call. = FALSE, domain = NA)
      }
    }
    if (R_version_built_under > current) 
      warning(gettextf("package %s was built under R version %s", sQuote(pkgname), as.character(built$R)), call. = FALSE, domain = NA)
    platform <- built$Platform
    r_arch <- .Platform$r_arch
    if (.Platform$OS.type == "unix") {
    }
    else {
      if (nzchar(platform) && !grepl("mingw", platform)) 
        stop(gettextf("package %s was built for %s", sQuote(pkgname), platform), call. = FALSE, domain = NA)
    }
    if (nzchar(r_arch) && file.exists(file.path(pkgpath, "libs")) && !file.exists(file.path(pkgpath, "libs", r_arch))) 
      stop(gettextf("package %s is not installed for 'arch = %s'", sQuote(pkgname), r_arch), call. = FALSE, domain = NA)
  }
  checkNoGenerics <- function(env, pkg) {
    nenv <- env
    ns <- .getNamespace(as.name(pkg))
    if (!is.null(ns)) 
      nenv <- asNamespace(ns)
    if (exists(".noGenerics", envir = nenv, inherits = FALSE)) 
      TRUE
    else {
      !any(startsWith(names(env), ".__T"))
    }
  }
  checkConflicts <- function(package, pkgname, pkgpath, nogenerics, env) {
    dont.mind <- c("last.dump", "last.warning", ".Last.value", ".Random.seed", ".Last.lib", ".onDetach", ".packageName", ".noGenerics", ".required", ".no_S3_generics", ".Depends", ".requireCachedGenerics")
    sp <- search()
    lib.pos <- which(sp == pkgname)
    ob <- names(as.environment(lib.pos))
    if (!nogenerics) {
      these <- ob[startsWith(ob, ".__T__")]
      gen <- gsub(".__T__(.*):([^:]+)", "\\1", these)
      from <- gsub(".__T__(.*):([^:]+)", "\\2", these)
      gen <- gen[from != package]
      ob <- ob[!(ob %in% gen)]
    }
    ipos <- seq_along(sp)[-c(lib.pos, match(c("Autoloads", "CheckExEnv"), sp, 0))]
    cpos <- NULL
    conflicts <- vector("list", 0)
    for (i in ipos) {
      obj.same <- match(names(as.environment(i)), ob, nomatch = 0)
      if (any(obj.same > 0)) {
        same <- ob[obj.same]
        same <- same[!(same %in% dont.mind)]
        Classobjs <- which(startsWith(same, ".__"))
        if (length(Classobjs)) 
          same <- same[-Classobjs]
        same.isFn <- function(where) vapply(same, exists, NA, where = where, mode = "function", inherits = FALSE)
        same <- same[same.isFn(i) == same.isFn(lib.pos)]
        not.Ident <- function(ch, TRAFO = identity, ...) vapply(ch, function(.) !identical(TRAFO(get(., i)), TRAFO(get(., lib.pos)), ...), NA)
        if (length(same)) 
          same <- same[not.Ident(same)]
        if (length(same) && identical(sp[i], "package:base")) 
          same <- same[not.Ident(same, ignore.environment = TRUE)]
        if (length(same)) {
          conflicts[[sp[i]]] <- same
          cpos[sp[i]] <- i
        }
      }
    }
    if (length(conflicts)) {
      if (stopOnConflict) {
        emsg <- ""
        pkg <- names(conflicts)
        notOK <- vector("list", 0)
        for (i in seq_along(conflicts)) {
          pkgname <- sub("^package:", "", pkg[i])
          if (pkgname %in% canMaskEnv$canMask) 
            next
          same <- conflicts[[i]]
          if (is.list(mask.ok)) 
            myMaskOK <- mask.ok[[pkgname]]
          else myMaskOK <- mask.ok
          if (isTRUE(myMaskOK)) 
            same <- NULL
          else if (is.character(myMaskOK)) 
            same <- setdiff(same, myMaskOK)
          if (length(same)) {
            notOK[[pkg[i]]] <- same
            msg <- .maskedMsg(sort(same), pkg = sQuote(pkg[i]), by = cpos[i] < lib.pos)
            emsg <- paste(emsg, msg, sep = "\n")
          }
        }
        if (length(notOK)) {
          msg <- gettextf("Conflicts attaching package %s:\n%s", sQuote(package), emsg)
          stop(errorCondition(msg, package = package, conflicts = conflicts, class = "packageConflictError"))
        }
      }
      if (warn.conflicts) {
        packageStartupMessage(gettextf("\nAttaching package: %s\n", sQuote(package)), domain = NA)
        pkg <- names(conflicts)
        for (i in seq_along(conflicts)) {
          msg <- .maskedMsg(sort(conflicts[[i]]), pkg = sQuote(pkg[i]), by = cpos[i] < lib.pos)
          packageStartupMessage(msg, domain = NA)
        }
      }
    }
  }
  if (verbose && quietly) 
    message("'verbose' and 'quietly' are both true; being verbose then ..")
  if (!missing(package)) {
    if (is.null(lib.loc)) 
      lib.loc <- .libPaths()
    lib.loc <- lib.loc[dir.exists(lib.loc)]
    if (!character.only) 
      package <- as.character(substitute(package))
    if (length(package) != 1) 
      stop("'package' must be of length 1")
    if (is.na(package) || (package == "")) 
      stop("invalid package name")
    pkgname <- paste0("package:", package)
    newpackage <- is.na(match(pkgname, search()))
    if (newpackage) {
      pkgpath <- find.package(package, lib.loc, quiet = TRUE, verbose = verbose)
      if (length(pkgpath) == 0) {
        if (length(lib.loc) && !logical.return) 
          stop(packageNotFoundError(package, lib.loc, sys.call()))
        txt <- if (length(lib.loc)) 
          gettextf("there is no package called %s", sQuote(package))
        else gettext("no library trees found in 'lib.loc'")
        if (logical.return) {
          if (!quietly) 
            warning(txt, domain = NA)
          return(FALSE)
        }
        else stop(txt, domain = NA)
      }
      which.lib.loc <- normalizePath(dirname(pkgpath), "/", TRUE)
      pfile <- system.file("Meta", "package.rds", package = package, lib.loc = which.lib.loc)
      if (!nzchar(pfile)) 
        stop(gettextf("%s is not a valid installed package", sQuote(package)), domain = NA)
      pkgInfo <- readRDS(pfile)
      testRversion(pkgInfo, package, pkgpath)
      if (is.character(pos)) {
        npos <- match(pos, search())
        if (is.na(npos)) {
          warning(gettextf("%s not found on search path, using pos = 2", sQuote(pos)), domain = NA)
          pos <- 2
        }
        else pos <- npos
      }
      deps <- unique(names(pkgInfo$Depends))
      depsOK <- isTRUE(conf.ctrl$depends.ok)
      if (depsOK) {
        canMaskEnv <- dynGet("__library_can_mask__", NULL)
        if (is.null(canMaskEnv)) {
          canMaskEnv <- new.env()
          canMaskEnv$canMask <- union("base", conf.ctrl$can.mask)
          "__library_can_mask__" <- canMaskEnv
        }
        canMaskEnv$canMask <- unique(c(package, deps, canMaskEnv$canMask))
      }
      else canMaskEnv <- NULL
      if (attach.required) 
        .getRequiredPackages2(pkgInfo, quietly = quietly)
      cr <- conflictRules(package)
      if (missing(mask.ok)) 
        mask.ok <- cr$mask.ok
      if (missing(exclude)) 
        exclude <- cr$exclude
      if (packageHasNamespace(package, which.lib.loc)) {
        if (isNamespaceLoaded(package)) {
          newversion <- as.numeric_version(pkgInfo$DESCRIPTION["Version"])
          oldversion <- as.numeric_version(getNamespaceVersion(package))
          if (newversion != oldversion) {
            tryCatch(unloadNamespace(package), error = function(e) {
              P <- if (!is.null(cc <- conditionCall(e))) 
                paste("Error in", deparse(cc)[1], ": ")
              else "Error : "
              stop(gettextf("Package %s version %s cannot be unloaded:\n %s", sQuote(package), oldversion, paste0(P, conditionMessage(e), "\n")), domain = NA)
            })
          }
        }
        tt <- tryCatch({
          attr(package, "LibPath") <- which.lib.loc
          ns <- loadNamespace(package, lib.loc)
          env <- attachNamespace(ns, pos = pos, deps, exclude, include.only)
        }, error = function(e) {
          P <- if (!is.null(cc <- conditionCall(e))) 
            paste(" in", deparse(cc)[1])
          else ""
          msg <- gettextf("package or namespace load failed for %s%s:\n %s", sQuote(package), P, conditionMessage(e))
          if (logical.return && !quietly) 
            message(paste("Error:", msg), domain = NA)
          else stop(msg, call. = FALSE, domain = NA)
        })
        if (logical.return && is.null(tt)) 
          return(FALSE)
        attr(package, "LibPath") <- NULL
        {
          on.exit(detach(pos = pos))
          nogenerics <- !.isMethodsDispatchOn() || checkNoGenerics(env, package)
          if (isFALSE(conf.ctrl$generics.ok) || (stopOnConflict && !isTRUE(conf.ctrl$generics.ok))) 
            nogenerics <- TRUE
          if (stopOnConflict || (warn.conflicts && !exists(".conflicts.OK", envir = env, inherits = FALSE))) 
            checkConflicts(package, pkgname, pkgpath, nogenerics, ns)
          on.exit()
          if (logical.return) 
            return(TRUE)
          else return(invisible(.packages()))
        }
      }
      else stop(gettextf("package %s does not have a namespace and should be re-installed", sQuote(package)), domain = NA)
    }
    if (verbose && !newpackage) 
      warning(gettextf("package %s already present in search()", sQuote(package)), domain = NA)
  }
  else if (!missing(help)) {
    if (!character.only) 
      help <- as.character(substitute(help))
    pkgName <- help[1]
    pkgPath <- find.package(pkgName, lib.loc, verbose = verbose)
    docFiles <- c(file.path(pkgPath, "Meta", "package.rds"), file.path(pkgPath, "INDEX"))
    if (file.exists(vignetteIndexRDS <- file.path(pkgPath, "Meta", "vignette.rds"))) 
      docFiles <- c(docFiles, vignetteIndexRDS)
    pkgInfo <- vector("list", 3)
    readDocFile <- function(f) {
      if (basename(f) %in% "package.rds") {
        txt <- readRDS(f)$DESCRIPTION
        if ("Encoding" %in% names(txt)) {
          to <- if (Sys.getlocale("LC_CTYPE") == "C") 
            "ASCII//TRANSLIT"
          else ""
          tmp <- try(iconv(txt, from = txt["Encoding"], to = to))
          if (!inherits(tmp, "try-error")) 
            txt <- tmp
          else warning("'DESCRIPTION' has an 'Encoding' field and re-encoding is not possible", call. = FALSE)
        }
        nm <- paste0(names(txt), ":")
        formatDL(nm, txt, indent = max(nchar(nm, "w")) + 3)
      }
      else if (basename(f) %in% "vignette.rds") {
        txt <- readRDS(f)
        if (is.data.frame(txt) && nrow(txt)) 
          cbind(basename(gsub("\\.[[:alpha:]]+$", "", txt$File)), paste(txt$Title, paste0(rep.int("(source", NROW(txt)), ifelse(nzchar(txt$PDF), ", pdf", ""), ")")))
        else NULL
      }
      else readLines(f)
    }
    for (i in which(file.exists(docFiles))) pkgInfo[[i]] <- readDocFile(docFiles[i])
    y <- list(name = pkgName, path = pkgPath, info = pkgInfo)
    class(y) <- "packageInfo"
    return(y)
  }
  else {
    if (is.null(lib.loc)) 
      lib.loc <- .libPaths()
    db <- matrix(character(), nrow = 0, ncol = 3)
    nopkgs <- character()
    for (lib in lib.loc) {
      a <- .packages(all.available = TRUE, lib.loc = lib)
      for (i in sort(a)) {
        file <- system.file("Meta", "package.rds", package = i, lib.loc = lib)
        title <- if (nzchar(file)) {
          txt <- readRDS(file)
          if (is.list(txt)) 
            txt <- txt$DESCRIPTION
          if ("Encoding" %in% names(txt)) {
            to <- if (Sys.getlocale("LC_CTYPE") == "C") 
              "ASCII//TRANSLIT"
            else ""
            tmp <- try(iconv(txt, txt["Encoding"], to, "?"))
            if (!inherits(tmp, "try-error")) 
              txt <- tmp
            else warning("'DESCRIPTION' has an 'Encoding' field and re-encoding is not possible", call. = FALSE)
          }
          txt["Title"]
        }
        else NA
        if (is.na(title)) 
          title <- " ** No title available ** "
        db <- rbind(db, cbind(i, lib, title))
      }
      if (length(a) == 0) 
        nopkgs <- c(nopkgs, lib)
    }
    dimnames(db) <- list(NULL, c("Package", "LibPath", "Title"))
    if (length(nopkgs) && !missing(lib.loc)) {
      pkglist <- paste(sQuote(nopkgs), collapse = ", ")
      msg <- sprintf(ngettext(length(nopkgs), "library %s contains no packages", "libraries %s contain no packages"), pkglist)
      warning(msg, domain = NA)
    }
    y <- list(header = NULL, results = db, footer = NULL)
    class(y) <- "libraryIQR"
    return(y)
  }
  if (logical.return) 
    TRUE
  else invisible(.packages())
}, function (package, help, pos = 2, lib.loc = NULL, character.only = FALSE, logical.return = FALSE, warn.conflicts, quietly = FALSE, verbose = getOption("verbose"), mask.ok, exclude, include.only, attach.required = missing(include.only)) 
{
  conf.ctrl <- getOption("conflicts.policy")
  if (is.character(conf.ctrl)) 
    conf.ctrl <- switch(conf.ctrl, strict = list(error = TRUE, warn = FALSE), depends.ok = list(error = TRUE, generics.ok = TRUE, can.mask = c("base", "methods", "utils", "grDevices", "graphics", "stats"), depends.ok = TRUE), warning(gettextf("unknown conflict policy: %s", sQuote(conf.ctrl)), call. = FALSE, domain = NA))
  if (!is.list(conf.ctrl)) 
    conf.ctrl <- NULL
  stopOnConflict <- isTRUE(conf.ctrl$error)
  if (missing(warn.conflicts)) 
    warn.conflicts <- !isFALSE(conf.ctrl$warn)
  if (!missing(include.only) && !missing(exclude)) 
    stop("only one of 'include.only' and 'exclude' can be used", call. = FALSE)
  testRversion <- function(pkgInfo, pkgname, pkgpath) {
    if (is.null(built <- pkgInfo$Built)) 
      stop(gettextf("package %s has not been installed properly\n", sQuote(pkgname)), call. = FALSE, domain = NA)
    R_version_built_under <- as.numeric_version(built$R)
    if (R_version_built_under < "3.0.0") 
      stop(gettextf("package %s was built before R 3.0.0: please re-install it", sQuote(pkgname)), call. = FALSE, domain = NA)
    current <- getRversion()
    if (length(Rdeps <- pkgInfo$Rdepends2)) {
      for (dep in Rdeps) if (length(dep) > 1) {
        target <- dep$version
        res <- do.call(dep$op, if (is.character(target)) 
          list(as.numeric(R.version[["svn rev"]]), as.numeric(sub("^r", "", target)))
          else list(current, as.numeric_version(target)))
        if (!res) 
          stop(gettextf("This is R %s, package %s needs %s %s", current, sQuote(pkgname), dep$op, target), call. = FALSE, domain = NA)
      }
    }
    if (R_version_built_under > current) 
      warning(gettextf("package %s was built under R version %s", sQuote(pkgname), as.character(built$R)), call. = FALSE, domain = NA)
    platform <- built$Platform
    r_arch <- .Platform$r_arch
    if (.Platform$OS.type == "unix") {
    }
    else {
      if (nzchar(platform) && !grepl("mingw", platform)) 
        stop(gettextf("package %s was built for %s", sQuote(pkgname), platform), call. = FALSE, domain = NA)
    }
    if (nzchar(r_arch) && file.exists(file.path(pkgpath, "libs")) && !file.exists(file.path(pkgpath, "libs", r_arch))) 
      stop(gettextf("package %s is not installed for 'arch = %s'", sQuote(pkgname), r_arch), call. = FALSE, domain = NA)
  }
  checkNoGenerics <- function(env, pkg) {
    nenv <- env
    ns <- .getNamespace(as.name(pkg))
    if (!is.null(ns)) 
      nenv <- asNamespace(ns)
    if (exists(".noGenerics", envir = nenv, inherits = FALSE)) 
      TRUE
    else {
      !any(startsWith(names(env), ".__T"))
    }
  }
  checkConflicts <- function(package, pkgname, pkgpath, nogenerics, env) {
    dont.mind <- c("last.dump", "last.warning", ".Last.value", ".Random.seed", ".Last.lib", ".onDetach", ".packageName", ".noGenerics", ".required", ".no_S3_generics", ".Depends", ".requireCachedGenerics")
    sp <- search()
    lib.pos <- which(sp == pkgname)
    ob <- names(as.environment(lib.pos))
    if (!nogenerics) {
      these <- ob[startsWith(ob, ".__T__")]
      gen <- gsub(".__T__(.*):([^:]+)", "\\1", these)
      from <- gsub(".__T__(.*):([^:]+)", "\\2", these)
      gen <- gen[from != package]
      ob <- ob[!(ob %in% gen)]
    }
    ipos <- seq_along(sp)[-c(lib.pos, match(c("Autoloads", "CheckExEnv"), sp, 0))]
    cpos <- NULL
    conflicts <- vector("list", 0)
    for (i in ipos) {
      obj.same <- match(names(as.environment(i)), ob, nomatch = 0)
      if (any(obj.same > 0)) {
        same <- ob[obj.same]
        same <- same[!(same %in% dont.mind)]
        Classobjs <- which(startsWith(same, ".__"))
        if (length(Classobjs)) 
          same <- same[-Classobjs]
        same.isFn <- function(where) vapply(same, exists, NA, where = where, mode = "function", inherits = FALSE)
        same <- same[same.isFn(i) == same.isFn(lib.pos)]
        not.Ident <- function(ch, TRAFO = identity, ...) vapply(ch, function(.) !identical(TRAFO(get(., i)), TRAFO(get(., lib.pos)), ...), NA)
        if (length(same)) 
          same <- same[not.Ident(same)]
        if (length(same) && identical(sp[i], "package:base")) 
          same <- same[not.Ident(same, ignore.environment = TRUE)]
        if (length(same)) {
          conflicts[[sp[i]]] <- same
          cpos[sp[i]] <- i
        }
      }
    }
    if (length(conflicts)) {
      if (stopOnConflict) {
        emsg <- ""
        pkg <- names(conflicts)
        notOK <- vector("list", 0)
        for (i in seq_along(conflicts)) {
          pkgname <- sub("^package:", "", pkg[i])
          if (pkgname %in% canMaskEnv$canMask) 
            next
          same <- conflicts[[i]]
          if (is.list(mask.ok)) 
            myMaskOK <- mask.ok[[pkgname]]
          else myMaskOK <- mask.ok
          if (isTRUE(myMaskOK)) 
            same <- NULL
          else if (is.character(myMaskOK)) 
            same <- setdiff(same, myMaskOK)
          if (length(same)) {
            notOK[[pkg[i]]] <- same
            msg <- .maskedMsg(sort(same), pkg = sQuote(pkg[i]), by = cpos[i] < lib.pos)
            emsg <- paste(emsg, msg, sep = "\n")
          }
        }
        if (length(notOK)) {
          msg <- gettextf("Conflicts attaching package %s:\n%s", sQuote(package), emsg)
          stop(errorCondition(msg, package = package, conflicts = conflicts, class = "packageConflictError"))
        }
      }
      if (warn.conflicts) {
        packageStartupMessage(gettextf("\nAttaching package: %s\n", sQuote(package)), domain = NA)
        pkg <- names(conflicts)
        for (i in seq_along(conflicts)) {
          msg <- .maskedMsg(sort(conflicts[[i]]), pkg = sQuote(pkg[i]), by = cpos[i] < lib.pos)
          packageStartupMessage(msg, domain = NA)
        }
      }
    }
  }
  if (verbose && quietly) 
    message("'verbose' and 'quietly' are both true; being verbose then ..")
  if (!missing(package)) {
    if (is.null(lib.loc)) 
      lib.loc <- .libPaths()
    lib.loc <- lib.loc[dir.exists(lib.loc)]
    if (!character.only) 
      package <- as.character(substitute(package))
    if (length(package) != 1) 
      stop("'package' must be of length 1")
    if (is.na(package) || (package == "")) 
      stop("invalid package name")
    pkgname <- paste0("package:", package)
    newpackage <- is.na(match(pkgname, search()))
    if (newpackage) {
      pkgpath <- find.package(package, lib.loc, quiet = TRUE, verbose = verbose)
      if (length(pkgpath) == 0) {
        if (length(lib.loc) && !logical.return) 
          stop(packageNotFoundError(package, lib.loc, sys.call()))
        txt <- if (length(lib.loc)) 
          gettextf("there is no package called %s", sQuote(package))
        else gettext("no library trees found in 'lib.loc'")
        if (logical.return) {
          if (!quietly) 
            warning(txt, domain = NA)
          return(FALSE)
        }
        else stop(txt, domain = NA)
      }
      which.lib.loc <- normalizePath(dirname(pkgpath), "/", TRUE)
      pfile <- system.file("Meta", "package.rds", package = package, lib.loc = which.lib.loc)
      if (!nzchar(pfile)) 
        stop(gettextf("%s is not a valid installed package", sQuote(package)), domain = NA)
      pkgInfo <- readRDS(pfile)
      testRversion(pkgInfo, package, pkgpath)
      if (is.character(pos)) {
        npos <- match(pos, search())
        if (is.na(npos)) {
          warning(gettextf("%s not found on search path, using pos = 2", sQuote(pos)), domain = NA)
          pos <- 2
        }
        else pos <- npos
      }
      deps <- unique(names(pkgInfo$Depends))
      depsOK <- isTRUE(conf.ctrl$depends.ok)
      if (depsOK) {
        canMaskEnv <- dynGet("__library_can_mask__", NULL)
        if (is.null(canMaskEnv)) {
          canMaskEnv <- new.env()
          canMaskEnv$canMask <- union("base", conf.ctrl$can.mask)
          "__library_can_mask__" <- canMaskEnv
        }
        canMaskEnv$canMask <- unique(c(package, deps, canMaskEnv$canMask))
      }
      else canMaskEnv <- NULL
      if (attach.required) 
        .getRequiredPackages2(pkgInfo, quietly = quietly)
      cr <- conflictRules(package)
      if (missing(mask.ok)) 
        mask.ok <- cr$mask.ok
      if (missing(exclude)) 
        exclude <- cr$exclude
      if (packageHasNamespace(package, which.lib.loc)) {
        if (isNamespaceLoaded(package)) {
          newversion <- as.numeric_version(pkgInfo$DESCRIPTION["Version"])
          oldversion <- as.numeric_version(getNamespaceVersion(package))
          if (newversion != oldversion) {
            tryCatch(unloadNamespace(package), error = function(e) {
              P <- if (!is.null(cc <- conditionCall(e))) 
                paste("Error in", deparse(cc)[1], ": ")
              else "Error : "
              stop(gettextf("Package %s version %s cannot be unloaded:\n %s", sQuote(package), oldversion, paste0(P, conditionMessage(e), "\n")), domain = NA)
            })
          }
        }
        tt <- tryCatch({
          attr(package, "LibPath") <- which.lib.loc
          ns <- loadNamespace(package, lib.loc)
          env <- attachNamespace(ns, pos = pos, deps, exclude, include.only)
        }, error = function(e) {
          P <- if (!is.null(cc <- conditionCall(e))) 
            paste(" in", deparse(cc)[1])
          else ""
          msg <- gettextf("package or namespace load failed for %s%s:\n %s", sQuote(package), P, conditionMessage(e))
          if (logical.return && !quietly) 
            message(paste("Error:", msg), domain = NA)
          else stop(msg, call. = FALSE, domain = NA)
        })
        if (logical.return && is.null(tt)) 
          return(FALSE)
        attr(package, "LibPath") <- NULL
        {
          on.exit(detach(pos = pos))
          nogenerics <- !.isMethodsDispatchOn() || checkNoGenerics(env, package)
          if (isFALSE(conf.ctrl$generics.ok) || (stopOnConflict && !isTRUE(conf.ctrl$generics.ok))) 
            nogenerics <- TRUE
          if (stopOnConflict || (warn.conflicts && !exists(".conflicts.OK", envir = env, inherits = FALSE))) 
            checkConflicts(package, pkgname, pkgpath, nogenerics, ns)
          on.exit()
          if (logical.return) 
            return(TRUE)
          else return(invisible(.packages()))
        }
      }
      else stop(gettextf("package %s does not have a namespace and should be re-installed", sQuote(package)), domain = NA)
    }
    if (verbose && !newpackage) 
      warning(gettextf("package %s already present in search()", sQuote(package)), domain = NA)
  }
  else if (!missing(help)) {
    if (!character.only) 
      help <- as.character(substitute(help))
    pkgName <- help[1]
    pkgPath <- find.package(pkgName, lib.loc, verbose = verbose)
    docFiles <- c(file.path(pkgPath, "Meta", "package.rds"), file.path(pkgPath, "INDEX"))
    if (file.exists(vignetteIndexRDS <- file.path(pkgPath, "Meta", "vignette.rds"))) 
      docFiles <- c(docFiles, vignetteIndexRDS)
    pkgInfo <- vector("list", 3)
    readDocFile <- function(f) {
      if (basename(f) %in% "package.rds") {
        txt <- readRDS(f)$DESCRIPTION
        if ("Encoding" %in% names(txt)) {
          to <- if (Sys.getlocale("LC_CTYPE") == "C") 
            "ASCII//TRANSLIT"
          else ""
          tmp <- try(iconv(txt, from = txt["Encoding"], to = to))
          if (!inherits(tmp, "try-error")) 
            txt <- tmp
          else warning("'DESCRIPTION' has an 'Encoding' field and re-encoding is not possible", call. = FALSE)
        }
        nm <- paste0(names(txt), ":")
        formatDL(nm, txt, indent = max(nchar(nm, "w")) + 3)
      }
      else if (basename(f) %in% "vignette.rds") {
        txt <- readRDS(f)
        if (is.data.frame(txt) && nrow(txt)) 
          cbind(basename(gsub("\\.[[:alpha:]]+$", "", txt$File)), paste(txt$Title, paste0(rep.int("(source", NROW(txt)), ifelse(nzchar(txt$PDF), ", pdf", ""), ")")))
        else NULL
      }
      else readLines(f)
    }
    for (i in which(file.exists(docFiles))) pkgInfo[[i]] <- readDocFile(docFiles[i])
    y <- list(name = pkgName, path = pkgPath, info = pkgInfo)
    class(y) <- "packageInfo"
    return(y)
  }
  else {
    if (is.null(lib.loc)) 
      lib.loc <- .libPaths()
    db <- matrix(character(), nrow = 0, ncol = 3)
    nopkgs <- character()
    for (lib in lib.loc) {
      a <- .packages(all.available = TRUE, lib.loc = lib)
      for (i in sort(a)) {
        file <- system.file("Meta", "package.rds", package = i, lib.loc = lib)
        title <- if (nzchar(file)) {
          txt <- readRDS(file)
          if (is.list(txt)) 
            txt <- txt$DESCRIPTION
          if ("Encoding" %in% names(txt)) {
            to <- if (Sys.getlocale("LC_CTYPE") == "C") 
              "ASCII//TRANSLIT"
            else ""
            tmp <- try(iconv(txt, txt["Encoding"], to, "?"))
            if (!inherits(tmp, "try-error")) 
              txt <- tmp
            else warning("'DESCRIPTION' has an 'Encoding' field and re-encoding is not possible", call. = FALSE)
          }
          txt["Title"]
        }
        else NA
        if (is.na(title)) 
          title <- " ** No title available ** "
        db <- rbind(db, cbind(i, lib, title))
      }
      if (length(a) == 0) 
        nopkgs <- c(nopkgs, lib)
    }
    dimnames(db) <- list(NULL, c("Package", "LibPath", "Title"))
    if (length(nopkgs) && !missing(lib.loc)) {
      pkglist <- paste(sQuote(nopkgs), collapse = ", ")
      msg <- sprintf(ngettext(length(nopkgs), "library %s contains no packages", "libraries %s contain no packages"), pkglist)
      warning(msg, domain = NA)
    }
    y <- list(header = NULL, results = db, footer = NULL)
    class(y) <- "libraryIQR"
    return(y)
  }
  if (logical.return) 
    TRUE
  else invisible(.packages())
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
library.dynam
list(`package:base` = function (chname, package, lib.loc, verbose = getOption("verbose"), file.ext = .Platform$dynlib.ext, ...) 
{
  dll_list <- .dynLibs()
  if (missing(chname) || !nzchar(chname)) 
    return(dll_list)
  package
  lib.loc
  r_arch <- .Platform$r_arch
  chname1 <- paste0(chname, file.ext)
  for (pkg in find.package(package, lib.loc, verbose = verbose)) {
    DLLpath <- if (nzchar(r_arch)) 
      file.path(pkg, "libs", r_arch)
    else file.path(pkg, "libs")
    file <- file.path(DLLpath, chname1)
    if (file.exists(file)) 
      break
    else file <- ""
  }
  if (file == "") 
    if (.Platform$OS.type == "windows") 
      stop(gettextf("DLL %s not found: maybe not installed for this architecture?", sQuote(chname)), domain = NA)
  else stop(gettextf("shared object %s not found", sQuote(chname1)), domain = NA)
  file <- file.path(normalizePath(DLLpath, "/", TRUE), chname1)
  ind <- vapply(dll_list, function(x) x[["path"]] == file, NA)
  if (length(ind) && any(ind)) {
    if (verbose) 
      if (.Platform$OS.type == "windows") 
        message(gettextf("DLL %s already loaded", sQuote(chname1)), domain = NA)
    else message(gettextf("shared object '%s' already loaded", sQuote(chname1)), domain = NA)
    return(invisible(dll_list[[seq_along(dll_list)[ind]]]))
  }
  if (.Platform$OS.type == "windows") {
    PATH <- Sys.getenv("PATH")
    Sys.setenv(PATH = paste(gsub("/", "\\\\", DLLpath), PATH, sep = ";"))
    on.exit(Sys.setenv(PATH = PATH))
  }
  if (verbose) 
    message(gettextf("now dyn.load(\"%s\") ...", file), domain = NA)
  dll <- if ("DLLpath" %in% ...names()) 
    dyn.load(file, ...)
  else dyn.load(file, DLLpath = DLLpath, ...)
  .dynLibs(c(dll_list, list(dll)))
  invisible(dll)
}, function (chname, package, lib.loc, verbose = getOption("verbose"), file.ext = .Platform$dynlib.ext, ...) 
{
  dll_list <- .dynLibs()
  if (missing(chname) || !nzchar(chname)) 
    return(dll_list)
  package
  lib.loc
  r_arch <- .Platform$r_arch
  chname1 <- paste0(chname, file.ext)
  for (pkg in find.package(package, lib.loc, verbose = verbose)) {
    DLLpath <- if (nzchar(r_arch)) 
      file.path(pkg, "libs", r_arch)
    else file.path(pkg, "libs")
    file <- file.path(DLLpath, chname1)
    if (file.exists(file)) 
      break
    else file <- ""
  }
  if (file == "") 
    if (.Platform$OS.type == "windows") 
      stop(gettextf("DLL %s not found: maybe not installed for this architecture?", sQuote(chname)), domain = NA)
  else stop(gettextf("shared object %s not found", sQuote(chname1)), domain = NA)
  file <- file.path(normalizePath(DLLpath, "/", TRUE), chname1)
  ind <- vapply(dll_list, function(x) x[["path"]] == file, NA)
  if (length(ind) && any(ind)) {
    if (verbose) 
      if (.Platform$OS.type == "windows") 
        message(gettextf("DLL %s already loaded", sQuote(chname1)), domain = NA)
    else message(gettextf("shared object '%s' already loaded", sQuote(chname1)), domain = NA)
    return(invisible(dll_list[[seq_along(dll_list)[ind]]]))
  }
  if (.Platform$OS.type == "windows") {
    PATH <- Sys.getenv("PATH")
    Sys.setenv(PATH = paste(gsub("/", "\\\\", DLLpath), PATH, sep = ";"))
    on.exit(Sys.setenv(PATH = PATH))
  }
  if (verbose) 
    message(gettextf("now dyn.load(\"%s\") ...", file), domain = NA)
  dll <- if ("DLLpath" %in% ...names()) 
    dyn.load(file, ...)
  else dyn.load(file, DLLpath = DLLpath, ...)
  .dynLibs(c(dll_list, list(dll)))
  invisible(dll)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
library.dynam.unload
list(`package:base` = function (chname, libpath, verbose = getOption("verbose"), file.ext = .Platform$dynlib.ext) 
{
  dll_list <- .dynLibs()
  if (missing(chname) || nchar(chname, "c") == 0) 
    if (.Platform$OS.type == "windows") 
      stop("no DLL was specified")
  else stop("no shared object was specified")
  libpath <- normalizePath(libpath, "/", TRUE)
  chname1 <- paste0(chname, file.ext)
  file <- if (nzchar(.Platform$r_arch)) 
    file.path(libpath, "libs", .Platform$r_arch, chname1)
  else file.path(libpath, "libs", chname1)
  pos <- which(vapply(dll_list, function(x) x[["path"]] == file, NA))
  if (!length(pos)) 
    if (.Platform$OS.type == "windows") 
      stop(gettextf("DLL %s was not loaded", sQuote(chname1)), domain = NA)
  else stop(gettextf("shared object %s was not loaded", sQuote(chname1)), domain = NA)
  if (!file.exists(file)) 
    if (.Platform$OS.type == "windows") 
      stop(gettextf("DLL %s not found", sQuote(chname1)), domain = NA)
  else stop(gettextf("shared object '%s' not found", sQuote(chname1)), domain = NA)
  if (verbose) 
    message(gettextf("now dyn.unload(\"%s\") ...", file), domain = NA)
  dyn.unload(file)
  .dynLibs(dll_list[-pos])
  invisible(dll_list[[pos]])
}, function (chname, libpath, verbose = getOption("verbose"), file.ext = .Platform$dynlib.ext) 
{
  dll_list <- .dynLibs()
  if (missing(chname) || nchar(chname, "c") == 0) 
    if (.Platform$OS.type == "windows") 
      stop("no DLL was specified")
  else stop("no shared object was specified")
  libpath <- normalizePath(libpath, "/", TRUE)
  chname1 <- paste0(chname, file.ext)
  file <- if (nzchar(.Platform$r_arch)) 
    file.path(libpath, "libs", .Platform$r_arch, chname1)
  else file.path(libpath, "libs", chname1)
  pos <- which(vapply(dll_list, function(x) x[["path"]] == file, NA))
  if (!length(pos)) 
    if (.Platform$OS.type == "windows") 
      stop(gettextf("DLL %s was not loaded", sQuote(chname1)), domain = NA)
  else stop(gettextf("shared object %s was not loaded", sQuote(chname1)), domain = NA)
  if (!file.exists(file)) 
    if (.Platform$OS.type == "windows") 
      stop(gettextf("DLL %s not found", sQuote(chname1)), domain = NA)
  else stop(gettextf("shared object '%s' not found", sQuote(chname1)), domain = NA)
  if (verbose) 
    message(gettextf("now dyn.unload(\"%s\") ...", file), domain = NA)
  dyn.unload(file)
  .dynLibs(dll_list[-pos])
  invisible(dll_list[[pos]])
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
licence
list(`package:base` = function () 
{
  cat("\nThis software is distributed under the terms of the GNU General\n")
  cat("Public License, either Version 2, June 1991 or Version 3, June 2007.\n")
  cat("The terms of version 2 of the license are in a file called COPYING\nwhich you should have received with\n")
  cat("this software and which can be displayed by RShowDoc(\"COPYING\").\n")
  cat("Version 3 of the license can be displayed by RShowDoc(\"GPL-3\").\n")
  cat("\n")
  cat("Copies of both versions 2 and 3 of the license can be found\n")
  cat("at https://www.R-project.org/Licenses/.\n")
  cat("\n")
  cat("A small number of files (the API header files listed in\n")
  cat("R_DOC_DIR/COPYRIGHTS) are distributed under the\n")
  cat("LESSER GNU GENERAL PUBLIC LICENSE, version 2.1 or later.\n")
  cat("This can be displayed by RShowDoc(\"LGPL-2.1\"),\n")
  cat("or obtained at the URI given.\n")
  cat("Version 3 of the license can be displayed by RShowDoc(\"LGPL-3\").\n")
  cat("\n")
  cat("'Share and Enjoy.'\n\n")
}, function () 
{
  cat("\nThis software is distributed under the terms of the GNU General\n")
  cat("Public License, either Version 2, June 1991 or Version 3, June 2007.\n")
  cat("The terms of version 2 of the license are in a file called COPYING\nwhich you should have received with\n")
  cat("this software and which can be displayed by RShowDoc(\"COPYING\").\n")
  cat("Version 3 of the license can be displayed by RShowDoc(\"GPL-3\").\n")
  cat("\n")
  cat("Copies of both versions 2 and 3 of the license can be found\n")
  cat("at https://www.R-project.org/Licenses/.\n")
  cat("\n")
  cat("A small number of files (the API header files listed in\n")
  cat("R_DOC_DIR/COPYRIGHTS) are distributed under the\n")
  cat("LESSER GNU GENERAL PUBLIC LICENSE, version 2.1 or later.\n")
  cat("This can be displayed by RShowDoc(\"LGPL-2.1\"),\n")
  cat("or obtained at the URI given.\n")
  cat("Version 3 of the license can be displayed by RShowDoc(\"LGPL-3\").\n")
  cat("\n")
  cat("'Share and Enjoy.'\n\n")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
license
list(`package:base` = function () 
{
  cat("\nThis software is distributed under the terms of the GNU General\n")
  cat("Public License, either Version 2, June 1991 or Version 3, June 2007.\n")
  cat("The terms of version 2 of the license are in a file called COPYING\nwhich you should have received with\n")
  cat("this software and which can be displayed by RShowDoc(\"COPYING\").\n")
  cat("Version 3 of the license can be displayed by RShowDoc(\"GPL-3\").\n")
  cat("\n")
  cat("Copies of both versions 2 and 3 of the license can be found\n")
  cat("at https://www.R-project.org/Licenses/.\n")
  cat("\n")
  cat("A small number of files (the API header files listed in\n")
  cat("R_DOC_DIR/COPYRIGHTS) are distributed under the\n")
  cat("LESSER GNU GENERAL PUBLIC LICENSE, version 2.1 or later.\n")
  cat("This can be displayed by RShowDoc(\"LGPL-2.1\"),\n")
  cat("or obtained at the URI given.\n")
  cat("Version 3 of the license can be displayed by RShowDoc(\"LGPL-3\").\n")
  cat("\n")
  cat("'Share and Enjoy.'\n\n")
}, function () 
{
  cat("\nThis software is distributed under the terms of the GNU General\n")
  cat("Public License, either Version 2, June 1991 or Version 3, June 2007.\n")
  cat("The terms of version 2 of the license are in a file called COPYING\nwhich you should have received with\n")
  cat("this software and which can be displayed by RShowDoc(\"COPYING\").\n")
  cat("Version 3 of the license can be displayed by RShowDoc(\"GPL-3\").\n")
  cat("\n")
  cat("Copies of both versions 2 and 3 of the license can be found\n")
  cat("at https://www.R-project.org/Licenses/.\n")
  cat("\n")
  cat("A small number of files (the API header files listed in\n")
  cat("R_DOC_DIR/COPYRIGHTS) are distributed under the\n")
  cat("LESSER GNU GENERAL PUBLIC LICENSE, version 2.1 or later.\n")
  cat("This can be displayed by RShowDoc(\"LGPL-2.1\"),\n")
  cat("or obtained at the URI given.\n")
  cat("Version 3 of the license can be displayed by RShowDoc(\"LGPL-3\").\n")
  cat("\n")
  cat("'Share and Enjoy.'\n\n")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
list
list(`package:base` = .Primitive("list"), .Primitive("list"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
list.dirs
list(`package:base` = function (path = ".", full.names = TRUE, recursive = TRUE) 
  .Internal(list.dirs(path, full.names, recursive)), function (path = ".", full.names = TRUE, recursive = TRUE) 
    .Internal(list.dirs(path, full.names, recursive)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
list.files
list(`package:base` = function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) 
  .Internal(list.files(path, pattern, all.files, full.names, recursive, ignore.case, include.dirs, no..)), function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) 
    .Internal(list.files(path, pattern, all.files, full.names, recursive, ignore.case, include.dirs, no..)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
list2DF
list(`package:base` = function (x = list(), nrow = 0) 
{
  stopifnot(is.list(x), is.null(nrow) || nrow >= 0)
  if (n <- length(x)) {
    if (length(nrow <- unique(lengths(x))) > 1) 
      stop("all variables should have the same length")
  }
  else {
    if (is.null(nrow)) 
      nrow <- 0
  }
  if (is.null(names(x))) 
    names(x) <- character(n)
  class(x) <- "data.frame"
  attr(x, "row.names") <- .set_row_names(nrow)
  x
}, function (x = list(), nrow = 0) 
{
  stopifnot(is.list(x), is.null(nrow) || nrow >= 0)
  if (n <- length(x)) {
    if (length(nrow <- unique(lengths(x))) > 1) 
      stop("all variables should have the same length")
  }
  else {
    if (is.null(nrow)) 
      nrow <- 0
  }
  if (is.null(names(x))) 
    names(x) <- character(n)
  class(x) <- "data.frame"
  attr(x, "row.names") <- .set_row_names(nrow)
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
list2env
list(`package:base` = function (x, envir = NULL, parent = parent.frame(), hash = (length(x) > 100), size = max(29, length(x))) 
{
  if (is.null(envir)) 
    envir <- new.env(hash = hash, parent = parent, size = size)
  .Internal(list2env(x, envir))
}, function (x, envir = NULL, parent = parent.frame(), hash = (length(x) > 100), size = max(29, length(x))) 
{
  if (is.null(envir)) 
    envir <- new.env(hash = hash, parent = parent, size = size)
  .Internal(list2env(x, envir))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
load
list(`package:base` = function (file, envir = parent.frame(), verbose = FALSE) 
{
  if (is.character(file)) {
    con <- gzfile(file)
    on.exit(close(con))
    magic <- readChar(con, 5, useBytes = TRUE)
    if (!length(magic)) 
      stop("empty (zero-byte) input file")
    if (!grepl("RD[ABX][2-9]\n", magic)) {
      if (grepl("RD[ABX][2-9]\r", magic)) 
        stop("input has been corrupted, with LF replaced by CR")
      warning(sprintf("file %s has magic number '%s'\n", sQuote(basename(file)), gsub("[\n\r]*", "", magic)), "  ", "Use of save versions prior to 2 is deprecated", domain = NA, call. = FALSE)
      return(.Internal(load(file, envir)))
    }
  }
  else if (inherits(file, "connection")) {
    con <- if (inherits(file, "gzfile") || inherits(file, "gzcon")) 
      file
    else gzcon(file)
  }
  else stop("bad 'file' argument")
  if (verbose) 
    cat("Loading objects:\n")
  .Internal(loadFromConn2(con, envir, verbose))
}, function (file, envir = parent.frame(), verbose = FALSE) 
{
  if (is.character(file)) {
    con <- gzfile(file)
    on.exit(close(con))
    magic <- readChar(con, 5, useBytes = TRUE)
    if (!length(magic)) 
      stop("empty (zero-byte) input file")
    if (!grepl("RD[ABX][2-9]\n", magic)) {
      if (grepl("RD[ABX][2-9]\r", magic)) 
        stop("input has been corrupted, with LF replaced by CR")
      warning(sprintf("file %s has magic number '%s'\n", sQuote(basename(file)), gsub("[\n\r]*", "", magic)), "  ", "Use of save versions prior to 2 is deprecated", domain = NA, call. = FALSE)
      return(.Internal(load(file, envir)))
    }
  }
  else if (inherits(file, "connection")) {
    con <- if (inherits(file, "gzfile") || inherits(file, "gzcon")) 
      file
    else gzcon(file)
  }
  else stop("bad 'file' argument")
  if (verbose) 
    cat("Loading objects:\n")
  .Internal(loadFromConn2(con, envir, verbose))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
loadedNamespaces
list(`package:base` = function () 
  names(.Internal(getNamespaceRegistry())), function () 
    names(.Internal(getNamespaceRegistry())))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
loadingNamespaceInfo
list(`package:base` = function () 
{
  dynGet("__LoadingNamespaceInfo__", stop("not loading a namespace"))
}, function () 
{
  dynGet("__LoadingNamespaceInfo__", stop("not loading a namespace"))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
loadNamespace
list(`package:base` = function (package, lib.loc = NULL, keep.source = getOption("keep.source.pkgs"), partial = FALSE, versionCheck = NULL, keep.parse.data = getOption("keep.parse.data.pkgs")) 
{
  libpath <- attr(package, "LibPath")
  package <- as.character(package)[[1]]
  loading <- dynGet("__NameSpacesLoading__", NULL)
  if (match(package, loading, 0)) 
    stop("cyclic namespace dependency detected when loading ", sQuote(package), ", already loading ", paste(sQuote(loading), collapse = ", "), domain = NA)
  "__NameSpacesLoading__" <- c(package, loading)
  ns <- .Internal(getRegisteredNamespace(package))
  if (!is.null(ns)) {
    if (!is.null(zop <- versionCheck[["op"]]) && !is.null(zversion <- versionCheck[["version"]])) {
      current <- getNamespaceVersion(ns)
      if (!do.call(zop, list(as.numeric_version(current), zversion))) 
        stop(gettextf("namespace %s %s is already loaded, but %s %s is required", sQuote(package), current, zop, zversion), domain = NA)
    }
    ns
  }
  else {
    lev <- 0
    msg <- Sys.getenv("_R_TRACE_LOADNAMESPACE_", "")
    if (nzchar(msg)) {
      if (package %in% c("base", "tools", "utils", "grDevices", "graphics", "stats", "datasets", "methods", "grid", "splines", "stats4", "tcltk", "compiler", "parallel")) 
        lev <- 0
      else {
        lev <- as.integer(msg)
        if (is.na(lev)) 
          lev <- 0
      }
    }
    if (lev > 0) 
      message("- loading ", dQuote(package))
    runHook <- function(hookname, env, libname, pkgname) {
      if (!is.null(fun <- env[[hookname]])) {
        res <- tryCatch(fun(libname, pkgname), error = identity)
        if (inherits(res, "error")) {
          stop(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", hookname, "loadNamespace", pkgname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
        }
      }
    }
    runUserHook <- function(pkgname, pkgpath) {
      hooks <- getHook(packageEvent(pkgname, "onLoad"))
      for (fun in hooks) try(fun(pkgname, pkgpath))
    }
    makeNamespace <- function(name, version = NULL, lib = NULL) {
      impenv <- new.env(parent = .BaseNamespaceEnv, hash = TRUE)
      attr(impenv, "name") <- paste0("imports:", name)
      env <- new.env(parent = impenv, hash = TRUE)
      name <- as.character(as.name(name))
      version <- as.character(version)
      info <- new.env(hash = TRUE, parent = baseenv())
      env$.__NAMESPACE__. <- info
      info$spec <- c(name = name, version = version)
      setNamespaceInfo(env, "exports", new.env(hash = TRUE, parent = baseenv()))
      dimpenv <- new.env(parent = baseenv(), hash = TRUE)
      attr(dimpenv, "name") <- paste0("lazydata:", name)
      setNamespaceInfo(env, "lazydata", dimpenv)
      setNamespaceInfo(env, "imports", list(base = TRUE))
      setNamespaceInfo(env, "path", normalizePath(file.path(lib, name), "/", TRUE))
      setNamespaceInfo(env, "dynlibs", NULL)
      setNamespaceInfo(env, "S3methods", matrix(NA, 0, 4))
      env$.__S3MethodsTable__. <- new.env(hash = TRUE, parent = baseenv())
      .Internal(registerNamespace(name, env))
      env
    }
    sealNamespace <- function(ns) {
      namespaceIsSealed <- function(ns) environmentIsLocked(ns)
      ns <- asNamespace(ns, base.OK = FALSE)
      if (namespaceIsSealed(ns)) 
        stop(gettextf("namespace %s is already sealed in 'loadNamespace'", sQuote(getNamespaceName(ns))), call. = FALSE, domain = NA)
      lockEnvironment(ns, TRUE)
      lockEnvironment(parent.env(ns), TRUE)
    }
    addNamespaceDynLibs <- function(ns, newlibs) {
      dynlibs <- .getNamespaceInfo(ns, "dynlibs")
      setNamespaceInfo(ns, "dynlibs", c(dynlibs, newlibs))
    }
    bindTranslations <- function(pkgname, pkgpath) {
      std <- c("compiler", "foreign", "grDevices", "graphics", "grid", "methods", "parallel", "splines", "stats", "stats4", "tcltk", "tools", "utils")
      popath <- if (pkgname %in% std) 
        .popath
      else file.path(pkgpath, "po")
      if (!file.exists(popath)) 
        return()
      bindtextdomain(pkgname, popath)
      bindtextdomain(paste0("R-", pkgname), popath)
    }
    assignNativeRoutines <- function(dll, lib, env, nativeRoutines) {
      if (length(nativeRoutines) == 0) 
        return(character())
      varnames <- character()
      symnames <- character()
      if (nativeRoutines$useRegistration) {
        fixes <- nativeRoutines$registrationFixes
        routines <- getDLLRegisteredRoutines.DLLInfo(dll, addNames = FALSE)
        lapply(routines, function(type) {
          lapply(type, function(sym) {
            varName <- paste0(fixes[1], sym$name, fixes[2])
            if (exists(varName, envir = env, inherits = FALSE)) 
              warning(gettextf("failed to assign RegisteredNativeSymbol for %s to %s since %s is already defined in the %s namespace", sym$name, varName, varName, sQuote(package)), domain = NA, call. = FALSE)
            else {
              env[[varName]] <- sym
              varnames <<- c(varnames, varName)
              symnames <<- c(symnames, sym$name)
            }
          })
        })
      }
      symNames <- nativeRoutines$symbolNames
      if (length(symNames)) {
        symbols <- getNativeSymbolInfo(symNames, dll, unlist = FALSE, withRegistrationInfo = TRUE)
        lapply(seq_along(symNames), function(i) {
          varName <- names(symNames)[i]
          origVarName <- symNames[i]
          if (exists(varName, envir = env, inherits = FALSE)) 
            if (origVarName != varName) 
              warning(gettextf("failed to assign NativeSymbolInfo for %s to %s since %s is already defined in the %s namespace", origVarName, varName, varName, sQuote(package)), domain = NA, call. = FALSE)
          else warning(gettextf("failed to assign NativeSymbolInfo for %s since %s is already defined in the %s namespace", origVarName, varName, sQuote(package)), domain = NA, call. = FALSE)
          else {
            assign(varName, symbols[[origVarName]], envir = env)
            varnames <<- c(varnames, varName)
            symnames <<- c(symnames, origVarName)
          }
        })
      }
      names(symnames) <- varnames
      symnames
    }
    fp.lib.loc <- c(libpath, lib.loc)
    pkgpath <- find.package(package, fp.lib.loc, quiet = TRUE)
    if (length(pkgpath) == 0) {
      cond <- packageNotFoundError(package, fp.lib.loc, sys.call())
      withRestarts(stop(cond), retry_loadNamespace = function() NULL)
      pkgpath <- find.package(package, fp.lib.loc, quiet = TRUE)
      if (length(pkgpath) == 0) 
        stop(cond)
    }
    bindTranslations(package, pkgpath)
    package.lib <- dirname(pkgpath)
    package <- basename(pkgpath)
    if (!packageHasNamespace(package, package.lib)) {
      hasNoNamespaceError <- function(package, package.lib, call = NULL) {
        class <- c("hasNoNamespaceError", "error", "condition")
        msg <- gettextf("package %s does not have a namespace", sQuote(package))
        structure(list(message = msg, package = package, package.lib = package.lib, call = call), class = class)
      }
      stop(hasNoNamespaceError(package, package.lib))
    }
    iniStdPkgs <- c("methods", "stats", "stats4", "tools", "utils")
    nsInfoFilePath <- file.path(pkgpath, "Meta", "nsInfo.rds")
    nsInfo <- if (file.exists(nsInfoFilePath)) 
      readRDS(nsInfoFilePath)
    else parseNamespaceFile(package, package.lib, mustExist = FALSE)
    pkgInfoFP <- file.path(pkgpath, "Meta", "package.rds")
    if (file.exists(pkgInfoFP)) {
      pkgInfo <- readRDS(pkgInfoFP)
      version <- pkgInfo$DESCRIPTION["Version"]
      vI <- pkgInfo$Imports
      if (is.null(built <- pkgInfo$Built)) 
        stop(gettextf("package %s has not been installed properly\n", sQuote(package)), call. = FALSE, domain = NA)
      R_version_built_under <- as.numeric_version(built$R)
      if (R_version_built_under < "4.0.0") 
        stop(gettextf("package %s was installed before R 4.0.0: please re-install it", sQuote(package)), call. = FALSE, domain = NA)
      dependsMethods <- "methods" %in% names(pkgInfo$Depends)
      if (dependsMethods) 
        loadNamespace("methods")
      if (!is.null(zop <- versionCheck[["op"]]) && !is.null(zversion <- versionCheck[["version"]]) && !do.call(zop, list(as.numeric_version(version), zversion))) 
        stop(gettextf("namespace %s %s is being loaded, but %s %s is required", sQuote(package), version, zop, zversion), domain = NA)
    }
    else {
      if (!any(package == iniStdPkgs)) 
        warning(gettextf("package %s has no 'package.rds' in Meta/", sQuote(package)), domain = NA)
      vI <- NULL
    }
    checkLicense <- function(pkg, pkgInfo, pkgPath) {
      L <- tools:::analyze_license(pkgInfo$DESCRIPTION["License"])
      if (!L$is_empty && !L$is_verified) {
        site_file <- path.expand(file.path(R.home("etc"), "licensed.site"))
        if (file.exists(site_file) && pkg %in% readLines(site_file)) 
          return()
        personal_file <- path.expand("~/.R/licensed")
        if (file.exists(personal_file)) {
          agreed <- readLines(personal_file)
          if (pkg %in% agreed) 
            return()
        }
        else agreed <- character()
        if (!interactive()) 
          stop(gettextf("package %s has a license that you need to accept in an interactive session", sQuote(pkg)), domain = NA)
        lfiles <- file.path(pkgpath, c("LICENSE", "LICENCE"))
        lfiles <- lfiles[file.exists(lfiles)]
        if (length(lfiles)) {
          message(gettextf("package %s has a license that you need to accept after viewing", sQuote(pkg)), domain = NA)
          readline("press RETURN to view license")
          encoding <- pkgInfo$DESCRIPTION["Encoding"]
          if (is.na(encoding)) 
            encoding <- ""
          if (encoding == "latin1") 
            encoding <- "cp1252"
          file.show(lfiles[1], encoding = encoding)
        }
        else {
          message(gettextf(paste("package %s has a license that you need to accept:", "according to the DESCRIPTION file it is", "%s", sep = "\n"), sQuote(pkg), pkgInfo$DESCRIPTION["License"]), domain = NA)
        }
        choice <- utils::menu(c("accept", "decline"), title = paste("License for", sQuote(pkg)))
        if (choice != 1) 
          stop(gettextf("license for package %s not accepted", sQuote(package)), domain = NA, call. = FALSE)
        dir.create(dirname(personal_file), showWarnings = FALSE)
        writeLines(c(agreed, pkg), personal_file)
      }
    }
    if (!package %in% c("datasets", "grDevices", "graphics", iniStdPkgs) && isTRUE(getOption("checkPackageLicense", FALSE))) 
      checkLicense(package, pkgInfo, pkgpath)
    if (dir.exists(file.path(pkgpath, "Meta"))) {
      ffile <- file.path(pkgpath, "Meta", "features.rds")
      features <- if (file.exists(ffile)) 
        readRDS(ffile)
      else NULL
      needsComp <- as.character(pkgInfo$DESCRIPTION["NeedsCompilation"])
      if (identical(needsComp, "yes") || file.exists(file.path(pkgpath, "libs"))) {
        internalsID <- features$internalsID
        if (is.null(internalsID)) 
          internalsID <- "0310d4b8-ccb1-4bb8-ba94-d36a55f60262"
        if (internalsID != .Internal(internalsID())) 
          stop(gettextf("package %s was installed by an R version with different internals; it needs to be reinstalled for use with this R version", sQuote(package)), call. = FALSE, domain = NA)
      }
    }
    ns <- makeNamespace(package, version = version, lib = package.lib)
    on.exit(.Internal(unregisterNamespace(package)))
    if (lev > 1) 
      message("-- processing imports for ", dQuote(package))
    for (i in nsInfo$imports) {
      if (is.character(i)) 
        namespaceImport(ns, loadNamespace(i, c(lib.loc, .libPaths()), versionCheck = vI[[i]]), from = package)
      else if (!is.null(i$except)) 
        namespaceImport(ns, loadNamespace(j <- i[[1]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]), from = package, except = i$except)
      else namespaceImportFrom(ns, loadNamespace(j <- i[[1]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]), i[[2]], from = package)
    }
    for (imp in nsInfo$importClasses) namespaceImportClasses(ns, loadNamespace(j <- imp[[1]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]), imp[[2]], from = package)
    for (imp in nsInfo$importMethods) namespaceImportMethods(ns, loadNamespace(j <- imp[[1]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]), imp[[2]], from = package)
    if (lev > 1) 
      message("-- done processing imports for ", dQuote(package))
    "__LoadingNamespaceInfo__" <- list(libname = package.lib, pkgname = package)
    env <- asNamespace(ns)
    env$.packageName <- package
    codename <- strsplit(package, "_", fixed = TRUE)[[1]][1]
    codeFile <- file.path(pkgpath, "R", codename)
    if (file.exists(codeFile)) {
      if (lev > 1) 
        message("-- loading code for ", dQuote(package))
      save.enc <- options(encoding = "native.enc")
      res <- try(sys.source(codeFile, env, keep.source = keep.source, keep.parse.data = keep.parse.data))
      options(save.enc)
      if (inherits(res, "try-error")) 
        stop(gettextf("unable to load R code in package %s", sQuote(package)), call. = FALSE, domain = NA)
      if (lev > 1) 
        message("-- loading code for ", dQuote(package))
    }
    if (partial) 
      return(ns)
    dbbase <- file.path(pkgpath, "R", "sysdata")
    if (file.exists(paste0(dbbase, ".rdb"))) {
      if (lev > 1) 
        message("-- loading sysdata for ", dQuote(package))
      lazyLoad(dbbase, env)
    }
    dbbase <- file.path(pkgpath, "data", "Rdata")
    if (file.exists(paste0(dbbase, ".rdb"))) {
      if (lev > 1) 
        message("-- loading lazydata for ", dQuote(package))
      lazyLoad(dbbase, .getNamespaceInfo(env, "lazydata"))
    }
    if (lev > 1) 
      message("-- registerS3methods for ", dQuote(package))
    registerS3methods(nsInfo$S3methods, package, env)
    if (lev > 1) 
      message("-- done registerS3methods for ", dQuote(package))
    dlls <- list()
    dynLibs <- nsInfo$dynlibs
    nativeRoutines <- list()
    for (i in seq_along(dynLibs)) {
      lib <- dynLibs[i]
      dlls[[lib]] <- library.dynam(lib, package, package.lib)
      routines <- assignNativeRoutines(dlls[[lib]], lib, env, nsInfo$nativeRoutines[[lib]])
      nativeRoutines[[lib]] <- routines
      if (!is.null(names(nsInfo$dynlibs)) && nzchar(names(nsInfo$dynlibs)[i])) 
        env[[names(nsInfo$dynlibs)[i]]] <- dlls[[lib]]
      setNamespaceInfo(env, "DLLs", dlls)
    }
    addNamespaceDynLibs(env, nsInfo$dynlibs)
    setNamespaceInfo(env, "nativeRoutines", nativeRoutines)
    Sys.setenv(`_R_NS_LOAD_` = package)
    on.exit(Sys.unsetenv("_R_NS_LOAD_"), add = TRUE)
    if (lev > 1) 
      message("-- running .onLoad for ", dQuote(package))
    runHook(".onLoad", env, package.lib, package)
    if (lev > 1) 
      message("-- done running .onLoad for ", dQuote(package))
    exports <- nsInfo$exports
    for (p in nsInfo$exportPatterns) exports <- c(ls(env, pattern = p, all.names = TRUE), exports)
    if (.isMethodsDispatchOn() && !(hasS4m <- methods:::.hasS4MetaData(ns)) && any(lengths(nsInfo[c("exportClasses", "exportMethods", "exportClassPatterns")])) && Sys.getenv("_R_LOAD_CHECK_S4_EXPORTS_") %in% c(package, "all")) {
      warning(gettextf("S4 exports specified in 'NAMESPACE' but not defined in package %s", sQuote(package)), call. = FALSE, domain = NA)
    }
    if (.isMethodsDispatchOn() && hasS4m && !identical(package, "methods")) {
      if (lev > 1 || lev == -5) 
        message("-- processing S4 stuff for ", dQuote(package))
      if (lev > 2) 
        message("--- caching metadata")
      methods::cacheMetaData(ns, TRUE, ns)
      if (lev > 2) 
        message("--- done caching metadata")
      for (p in nsInfo$exportPatterns) {
        expp <- ls(ns, pattern = p, all.names = TRUE)
        newEx <- !(expp %in% exports)
        if (any(newEx)) 
          exports <- c(expp[newEx], exports)
      }
      expClasses <- nsInfo$exportClasses
      if (lev > 2) 
        message("--- processing classes")
      pClasses <- character()
      aClasses <- methods::getClasses(ns)
      classPatterns <- nsInfo$exportClassPatterns
      if (!length(classPatterns)) 
        classPatterns <- nsInfo$exportPatterns
      pClasses <- unique(unlist(lapply(classPatterns, grep, aClasses, value = TRUE)))
      if (length(pClasses)) {
        good <- vapply(pClasses, methods::isClass, NA, where = ns)
        if (!any(good) && length(nsInfo$exportClassPatterns)) 
          warning(gettextf("'exportClassPattern' specified in 'NAMESPACE' but no matching classes in package %s", sQuote(package)), call. = FALSE, domain = NA)
        expClasses <- c(expClasses, pClasses[good])
      }
      if (length(expClasses)) {
        missingClasses <- !vapply(expClasses, methods::isClass, NA, where = ns)
        if (any(missingClasses)) 
          stop(gettextf("in package %s classes %s were specified for export but not defined", sQuote(package), paste(expClasses[missingClasses], collapse = ", ")), domain = NA)
        expClasses <- paste0(methods::classMetaName(""), expClasses)
      }
      allGenerics <- unique(c(methods:::.getGenerics(ns), methods:::.getGenerics(parent.env(ns))))
      expMethods <- nsInfo$exportMethods
      addGenerics <- expMethods[is.na(match(expMethods, exports))]
      if (length(addGenerics)) {
        nowhere <- vapply(addGenerics, function(what) !exists(what, mode = "function", envir = ns), NA, USE.NAMES = FALSE)
        if (any(nowhere)) {
          warning(gettextf("no function found corresponding to methods exports from %s for: %s", sQuote(package), paste(sQuote(sort(unique(addGenerics[nowhere]))), collapse = ", ")), domain = NA, call. = FALSE)
          addGenerics <- addGenerics[!nowhere]
        }
        if (length(addGenerics)) {
          addGenerics <- addGenerics[vapply(addGenerics, function(what) !is.primitive(get(what, mode = "function", envir = ns)), NA)]
          ok <- vapply(addGenerics, methods:::.findsGeneric, 1, ns)
          if (!all(ok)) {
            bad <- sort(unique(addGenerics[!ok]))
            msg <- ngettext(length(bad), "Function found when exporting methods from the namespace %s which is not S4 generic: %s", "Functions found when exporting methods from the namespace %s which are not S4 generic: %s")
            stop(sprintf(msg, sQuote(package), paste(sQuote(bad), collapse = ", ")), domain = NA, call. = FALSE)
          }
          else if (any(ok > 1)) 
            addGenerics <- addGenerics[ok < 2]
        }
        exports <- c(exports, addGenerics)
      }
      expTables <- character()
      if (length(allGenerics)) {
        expMethods <- unique(c(expMethods, exports[!is.na(match(exports, allGenerics))]))
        missingMethods <- !(expMethods %in% allGenerics)
        if (any(missingMethods)) 
          stop(gettextf("in %s methods for export not found: %s", sQuote(package), paste(expMethods[missingMethods], collapse = ", ")), domain = NA)
        tPrefix <- methods:::.TableMetaPrefix()
        allMethodTables <- unique(c(methods:::.getGenerics(ns, tPrefix), methods:::.getGenerics(parent.env(ns), tPrefix)))
        needMethods <- (exports %in% allGenerics) & !(exports %in% expMethods)
        if (any(needMethods)) 
          expMethods <- c(expMethods, exports[needMethods])
        pm <- allGenerics[!(allGenerics %in% expMethods)]
        if (length(pm)) {
          prim <- vapply(pm, function(pmi) {
            f <- methods::getFunction(pmi, FALSE, FALSE, ns)
            is.primitive(f)
          }, logical(1))
          expMethods <- c(expMethods, pm[prim])
        }
        for (i in seq_along(expMethods)) {
          mi <- expMethods[[i]]
          if (lev > 3) 
            message("---- export method ", sQuote(mi))
          if (!(mi %in% exports) && exists(mi, envir = ns, mode = "function", inherits = FALSE)) 
            exports <- c(exports, mi)
          pattern <- paste0(tPrefix, mi, ":")
          ii <- grep(pattern, allMethodTables, fixed = TRUE)
          if (length(ii)) {
            if (length(ii) > 1) {
              warning(gettextf("multiple methods tables found for %s", sQuote(mi)), call. = FALSE, domain = NA)
              ii <- ii[1]
            }
            expTables[[i]] <- allMethodTables[ii]
          }
          else {
            warning(gettextf("failed to find metadata object for %s", sQuote(mi)), call. = FALSE, domain = NA)
          }
        }
      }
      else if (length(expMethods)) 
        stop(gettextf("in package %s methods %s were specified for export but not defined", sQuote(package), paste(expMethods, collapse = ", ")), domain = NA)
      exports <- unique(c(exports, expClasses, expTables))
      if (lev > 1 || lev == -5) 
        message("-- done processing S4 stuff for ", dQuote(package))
    }
    if (length(exports)) {
      stoplist <- c(".__NAMESPACE__.", ".__S3MethodsTable__.", ".packageName", ".First.lib", ".onLoad", ".onAttach", ".conflicts.OK", ".noGenerics")
      exports <- exports[!exports %in% stoplist]
    }
    if (lev > 2) 
      message("--- processing exports for ", dQuote(package))
    namespaceExport(ns, exports)
    if (lev > 2) 
      message("--- sealing exports for ", dQuote(package))
    sealNamespace(ns)
    runUserHook(package, pkgpath)
    on.exit()
    if (lev > 0) 
      message("- done loading ", dQuote(package))
    Sys.unsetenv("_R_NS_LOAD_")
    ns
  }
}, function (package, lib.loc = NULL, keep.source = getOption("keep.source.pkgs"), partial = FALSE, versionCheck = NULL, keep.parse.data = getOption("keep.parse.data.pkgs")) 
{
  libpath <- attr(package, "LibPath")
  package <- as.character(package)[[1]]
  loading <- dynGet("__NameSpacesLoading__", NULL)
  if (match(package, loading, 0)) 
    stop("cyclic namespace dependency detected when loading ", sQuote(package), ", already loading ", paste(sQuote(loading), collapse = ", "), domain = NA)
  "__NameSpacesLoading__" <- c(package, loading)
  ns <- .Internal(getRegisteredNamespace(package))
  if (!is.null(ns)) {
    if (!is.null(zop <- versionCheck[["op"]]) && !is.null(zversion <- versionCheck[["version"]])) {
      current <- getNamespaceVersion(ns)
      if (!do.call(zop, list(as.numeric_version(current), zversion))) 
        stop(gettextf("namespace %s %s is already loaded, but %s %s is required", sQuote(package), current, zop, zversion), domain = NA)
    }
    ns
  }
  else {
    lev <- 0
    msg <- Sys.getenv("_R_TRACE_LOADNAMESPACE_", "")
    if (nzchar(msg)) {
      if (package %in% c("base", "tools", "utils", "grDevices", "graphics", "stats", "datasets", "methods", "grid", "splines", "stats4", "tcltk", "compiler", "parallel")) 
        lev <- 0
      else {
        lev <- as.integer(msg)
        if (is.na(lev)) 
          lev <- 0
      }
    }
    if (lev > 0) 
      message("- loading ", dQuote(package))
    runHook <- function(hookname, env, libname, pkgname) {
      if (!is.null(fun <- env[[hookname]])) {
        res <- tryCatch(fun(libname, pkgname), error = identity)
        if (inherits(res, "error")) {
          stop(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", hookname, "loadNamespace", pkgname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
        }
      }
    }
    runUserHook <- function(pkgname, pkgpath) {
      hooks <- getHook(packageEvent(pkgname, "onLoad"))
      for (fun in hooks) try(fun(pkgname, pkgpath))
    }
    makeNamespace <- function(name, version = NULL, lib = NULL) {
      impenv <- new.env(parent = .BaseNamespaceEnv, hash = TRUE)
      attr(impenv, "name") <- paste0("imports:", name)
      env <- new.env(parent = impenv, hash = TRUE)
      name <- as.character(as.name(name))
      version <- as.character(version)
      info <- new.env(hash = TRUE, parent = baseenv())
      env$.__NAMESPACE__. <- info
      info$spec <- c(name = name, version = version)
      setNamespaceInfo(env, "exports", new.env(hash = TRUE, parent = baseenv()))
      dimpenv <- new.env(parent = baseenv(), hash = TRUE)
      attr(dimpenv, "name") <- paste0("lazydata:", name)
      setNamespaceInfo(env, "lazydata", dimpenv)
      setNamespaceInfo(env, "imports", list(base = TRUE))
      setNamespaceInfo(env, "path", normalizePath(file.path(lib, name), "/", TRUE))
      setNamespaceInfo(env, "dynlibs", NULL)
      setNamespaceInfo(env, "S3methods", matrix(NA, 0, 4))
      env$.__S3MethodsTable__. <- new.env(hash = TRUE, parent = baseenv())
      .Internal(registerNamespace(name, env))
      env
    }
    sealNamespace <- function(ns) {
      namespaceIsSealed <- function(ns) environmentIsLocked(ns)
      ns <- asNamespace(ns, base.OK = FALSE)
      if (namespaceIsSealed(ns)) 
        stop(gettextf("namespace %s is already sealed in 'loadNamespace'", sQuote(getNamespaceName(ns))), call. = FALSE, domain = NA)
      lockEnvironment(ns, TRUE)
      lockEnvironment(parent.env(ns), TRUE)
    }
    addNamespaceDynLibs <- function(ns, newlibs) {
      dynlibs <- .getNamespaceInfo(ns, "dynlibs")
      setNamespaceInfo(ns, "dynlibs", c(dynlibs, newlibs))
    }
    bindTranslations <- function(pkgname, pkgpath) {
      std <- c("compiler", "foreign", "grDevices", "graphics", "grid", "methods", "parallel", "splines", "stats", "stats4", "tcltk", "tools", "utils")
      popath <- if (pkgname %in% std) 
        .popath
      else file.path(pkgpath, "po")
      if (!file.exists(popath)) 
        return()
      bindtextdomain(pkgname, popath)
      bindtextdomain(paste0("R-", pkgname), popath)
    }
    assignNativeRoutines <- function(dll, lib, env, nativeRoutines) {
      if (length(nativeRoutines) == 0) 
        return(character())
      varnames <- character()
      symnames <- character()
      if (nativeRoutines$useRegistration) {
        fixes <- nativeRoutines$registrationFixes
        routines <- getDLLRegisteredRoutines.DLLInfo(dll, addNames = FALSE)
        lapply(routines, function(type) {
          lapply(type, function(sym) {
            varName <- paste0(fixes[1], sym$name, fixes[2])
            if (exists(varName, envir = env, inherits = FALSE)) 
              warning(gettextf("failed to assign RegisteredNativeSymbol for %s to %s since %s is already defined in the %s namespace", sym$name, varName, varName, sQuote(package)), domain = NA, call. = FALSE)
            else {
              env[[varName]] <- sym
              varnames <<- c(varnames, varName)
              symnames <<- c(symnames, sym$name)
            }
          })
        })
      }
      symNames <- nativeRoutines$symbolNames
      if (length(symNames)) {
        symbols <- getNativeSymbolInfo(symNames, dll, unlist = FALSE, withRegistrationInfo = TRUE)
        lapply(seq_along(symNames), function(i) {
          varName <- names(symNames)[i]
          origVarName <- symNames[i]
          if (exists(varName, envir = env, inherits = FALSE)) 
            if (origVarName != varName) 
              warning(gettextf("failed to assign NativeSymbolInfo for %s to %s since %s is already defined in the %s namespace", origVarName, varName, varName, sQuote(package)), domain = NA, call. = FALSE)
          else warning(gettextf("failed to assign NativeSymbolInfo for %s since %s is already defined in the %s namespace", origVarName, varName, sQuote(package)), domain = NA, call. = FALSE)
          else {
            assign(varName, symbols[[origVarName]], envir = env)
            varnames <<- c(varnames, varName)
            symnames <<- c(symnames, origVarName)
          }
        })
      }
      names(symnames) <- varnames
      symnames
    }
    fp.lib.loc <- c(libpath, lib.loc)
    pkgpath <- find.package(package, fp.lib.loc, quiet = TRUE)
    if (length(pkgpath) == 0) {
      cond <- packageNotFoundError(package, fp.lib.loc, sys.call())
      withRestarts(stop(cond), retry_loadNamespace = function() NULL)
      pkgpath <- find.package(package, fp.lib.loc, quiet = TRUE)
      if (length(pkgpath) == 0) 
        stop(cond)
    }
    bindTranslations(package, pkgpath)
    package.lib <- dirname(pkgpath)
    package <- basename(pkgpath)
    if (!packageHasNamespace(package, package.lib)) {
      hasNoNamespaceError <- function(package, package.lib, call = NULL) {
        class <- c("hasNoNamespaceError", "error", "condition")
        msg <- gettextf("package %s does not have a namespace", sQuote(package))
        structure(list(message = msg, package = package, package.lib = package.lib, call = call), class = class)
      }
      stop(hasNoNamespaceError(package, package.lib))
    }
    iniStdPkgs <- c("methods", "stats", "stats4", "tools", "utils")
    nsInfoFilePath <- file.path(pkgpath, "Meta", "nsInfo.rds")
    nsInfo <- if (file.exists(nsInfoFilePath)) 
      readRDS(nsInfoFilePath)
    else parseNamespaceFile(package, package.lib, mustExist = FALSE)
    pkgInfoFP <- file.path(pkgpath, "Meta", "package.rds")
    if (file.exists(pkgInfoFP)) {
      pkgInfo <- readRDS(pkgInfoFP)
      version <- pkgInfo$DESCRIPTION["Version"]
      vI <- pkgInfo$Imports
      if (is.null(built <- pkgInfo$Built)) 
        stop(gettextf("package %s has not been installed properly\n", sQuote(package)), call. = FALSE, domain = NA)
      R_version_built_under <- as.numeric_version(built$R)
      if (R_version_built_under < "4.0.0") 
        stop(gettextf("package %s was installed before R 4.0.0: please re-install it", sQuote(package)), call. = FALSE, domain = NA)
      dependsMethods <- "methods" %in% names(pkgInfo$Depends)
      if (dependsMethods) 
        loadNamespace("methods")
      if (!is.null(zop <- versionCheck[["op"]]) && !is.null(zversion <- versionCheck[["version"]]) && !do.call(zop, list(as.numeric_version(version), zversion))) 
        stop(gettextf("namespace %s %s is being loaded, but %s %s is required", sQuote(package), version, zop, zversion), domain = NA)
    }
    else {
      if (!any(package == iniStdPkgs)) 
        warning(gettextf("package %s has no 'package.rds' in Meta/", sQuote(package)), domain = NA)
      vI <- NULL
    }
    checkLicense <- function(pkg, pkgInfo, pkgPath) {
      L <- tools:::analyze_license(pkgInfo$DESCRIPTION["License"])
      if (!L$is_empty && !L$is_verified) {
        site_file <- path.expand(file.path(R.home("etc"), "licensed.site"))
        if (file.exists(site_file) && pkg %in% readLines(site_file)) 
          return()
        personal_file <- path.expand("~/.R/licensed")
        if (file.exists(personal_file)) {
          agreed <- readLines(personal_file)
          if (pkg %in% agreed) 
            return()
        }
        else agreed <- character()
        if (!interactive()) 
          stop(gettextf("package %s has a license that you need to accept in an interactive session", sQuote(pkg)), domain = NA)
        lfiles <- file.path(pkgpath, c("LICENSE", "LICENCE"))
        lfiles <- lfiles[file.exists(lfiles)]
        if (length(lfiles)) {
          message(gettextf("package %s has a license that you need to accept after viewing", sQuote(pkg)), domain = NA)
          readline("press RETURN to view license")
          encoding <- pkgInfo$DESCRIPTION["Encoding"]
          if (is.na(encoding)) 
            encoding <- ""
          if (encoding == "latin1") 
            encoding <- "cp1252"
          file.show(lfiles[1], encoding = encoding)
        }
        else {
          message(gettextf(paste("package %s has a license that you need to accept:", "according to the DESCRIPTION file it is", "%s", sep = "\n"), sQuote(pkg), pkgInfo$DESCRIPTION["License"]), domain = NA)
        }
        choice <- utils::menu(c("accept", "decline"), title = paste("License for", sQuote(pkg)))
        if (choice != 1) 
          stop(gettextf("license for package %s not accepted", sQuote(package)), domain = NA, call. = FALSE)
        dir.create(dirname(personal_file), showWarnings = FALSE)
        writeLines(c(agreed, pkg), personal_file)
      }
    }
    if (!package %in% c("datasets", "grDevices", "graphics", iniStdPkgs) && isTRUE(getOption("checkPackageLicense", FALSE))) 
      checkLicense(package, pkgInfo, pkgpath)
    if (dir.exists(file.path(pkgpath, "Meta"))) {
      ffile <- file.path(pkgpath, "Meta", "features.rds")
      features <- if (file.exists(ffile)) 
        readRDS(ffile)
      else NULL
      needsComp <- as.character(pkgInfo$DESCRIPTION["NeedsCompilation"])
      if (identical(needsComp, "yes") || file.exists(file.path(pkgpath, "libs"))) {
        internalsID <- features$internalsID
        if (is.null(internalsID)) 
          internalsID <- "0310d4b8-ccb1-4bb8-ba94-d36a55f60262"
        if (internalsID != .Internal(internalsID())) 
          stop(gettextf("package %s was installed by an R version with different internals; it needs to be reinstalled for use with this R version", sQuote(package)), call. = FALSE, domain = NA)
      }
    }
    ns <- makeNamespace(package, version = version, lib = package.lib)
    on.exit(.Internal(unregisterNamespace(package)))
    if (lev > 1) 
      message("-- processing imports for ", dQuote(package))
    for (i in nsInfo$imports) {
      if (is.character(i)) 
        namespaceImport(ns, loadNamespace(i, c(lib.loc, .libPaths()), versionCheck = vI[[i]]), from = package)
      else if (!is.null(i$except)) 
        namespaceImport(ns, loadNamespace(j <- i[[1]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]), from = package, except = i$except)
      else namespaceImportFrom(ns, loadNamespace(j <- i[[1]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]), i[[2]], from = package)
    }
    for (imp in nsInfo$importClasses) namespaceImportClasses(ns, loadNamespace(j <- imp[[1]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]), imp[[2]], from = package)
    for (imp in nsInfo$importMethods) namespaceImportMethods(ns, loadNamespace(j <- imp[[1]], c(lib.loc, .libPaths()), versionCheck = vI[[j]]), imp[[2]], from = package)
    if (lev > 1) 
      message("-- done processing imports for ", dQuote(package))
    "__LoadingNamespaceInfo__" <- list(libname = package.lib, pkgname = package)
    env <- asNamespace(ns)
    env$.packageName <- package
    codename <- strsplit(package, "_", fixed = TRUE)[[1]][1]
    codeFile <- file.path(pkgpath, "R", codename)
    if (file.exists(codeFile)) {
      if (lev > 1) 
        message("-- loading code for ", dQuote(package))
      save.enc <- options(encoding = "native.enc")
      res <- try(sys.source(codeFile, env, keep.source = keep.source, keep.parse.data = keep.parse.data))
      options(save.enc)
      if (inherits(res, "try-error")) 
        stop(gettextf("unable to load R code in package %s", sQuote(package)), call. = FALSE, domain = NA)
      if (lev > 1) 
        message("-- loading code for ", dQuote(package))
    }
    if (partial) 
      return(ns)
    dbbase <- file.path(pkgpath, "R", "sysdata")
    if (file.exists(paste0(dbbase, ".rdb"))) {
      if (lev > 1) 
        message("-- loading sysdata for ", dQuote(package))
      lazyLoad(dbbase, env)
    }
    dbbase <- file.path(pkgpath, "data", "Rdata")
    if (file.exists(paste0(dbbase, ".rdb"))) {
      if (lev > 1) 
        message("-- loading lazydata for ", dQuote(package))
      lazyLoad(dbbase, .getNamespaceInfo(env, "lazydata"))
    }
    if (lev > 1) 
      message("-- registerS3methods for ", dQuote(package))
    registerS3methods(nsInfo$S3methods, package, env)
    if (lev > 1) 
      message("-- done registerS3methods for ", dQuote(package))
    dlls <- list()
    dynLibs <- nsInfo$dynlibs
    nativeRoutines <- list()
    for (i in seq_along(dynLibs)) {
      lib <- dynLibs[i]
      dlls[[lib]] <- library.dynam(lib, package, package.lib)
      routines <- assignNativeRoutines(dlls[[lib]], lib, env, nsInfo$nativeRoutines[[lib]])
      nativeRoutines[[lib]] <- routines
      if (!is.null(names(nsInfo$dynlibs)) && nzchar(names(nsInfo$dynlibs)[i])) 
        env[[names(nsInfo$dynlibs)[i]]] <- dlls[[lib]]
      setNamespaceInfo(env, "DLLs", dlls)
    }
    addNamespaceDynLibs(env, nsInfo$dynlibs)
    setNamespaceInfo(env, "nativeRoutines", nativeRoutines)
    Sys.setenv(`_R_NS_LOAD_` = package)
    on.exit(Sys.unsetenv("_R_NS_LOAD_"), add = TRUE)
    if (lev > 1) 
      message("-- running .onLoad for ", dQuote(package))
    runHook(".onLoad", env, package.lib, package)
    if (lev > 1) 
      message("-- done running .onLoad for ", dQuote(package))
    exports <- nsInfo$exports
    for (p in nsInfo$exportPatterns) exports <- c(ls(env, pattern = p, all.names = TRUE), exports)
    if (.isMethodsDispatchOn() && !(hasS4m <- methods:::.hasS4MetaData(ns)) && any(lengths(nsInfo[c("exportClasses", "exportMethods", "exportClassPatterns")])) && Sys.getenv("_R_LOAD_CHECK_S4_EXPORTS_") %in% c(package, "all")) {
      warning(gettextf("S4 exports specified in 'NAMESPACE' but not defined in package %s", sQuote(package)), call. = FALSE, domain = NA)
    }
    if (.isMethodsDispatchOn() && hasS4m && !identical(package, "methods")) {
      if (lev > 1 || lev == -5) 
        message("-- processing S4 stuff for ", dQuote(package))
      if (lev > 2) 
        message("--- caching metadata")
      methods::cacheMetaData(ns, TRUE, ns)
      if (lev > 2) 
        message("--- done caching metadata")
      for (p in nsInfo$exportPatterns) {
        expp <- ls(ns, pattern = p, all.names = TRUE)
        newEx <- !(expp %in% exports)
        if (any(newEx)) 
          exports <- c(expp[newEx], exports)
      }
      expClasses <- nsInfo$exportClasses
      if (lev > 2) 
        message("--- processing classes")
      pClasses <- character()
      aClasses <- methods::getClasses(ns)
      classPatterns <- nsInfo$exportClassPatterns
      if (!length(classPatterns)) 
        classPatterns <- nsInfo$exportPatterns
      pClasses <- unique(unlist(lapply(classPatterns, grep, aClasses, value = TRUE)))
      if (length(pClasses)) {
        good <- vapply(pClasses, methods::isClass, NA, where = ns)
        if (!any(good) && length(nsInfo$exportClassPatterns)) 
          warning(gettextf("'exportClassPattern' specified in 'NAMESPACE' but no matching classes in package %s", sQuote(package)), call. = FALSE, domain = NA)
        expClasses <- c(expClasses, pClasses[good])
      }
      if (length(expClasses)) {
        missingClasses <- !vapply(expClasses, methods::isClass, NA, where = ns)
        if (any(missingClasses)) 
          stop(gettextf("in package %s classes %s were specified for export but not defined", sQuote(package), paste(expClasses[missingClasses], collapse = ", ")), domain = NA)
        expClasses <- paste0(methods::classMetaName(""), expClasses)
      }
      allGenerics <- unique(c(methods:::.getGenerics(ns), methods:::.getGenerics(parent.env(ns))))
      expMethods <- nsInfo$exportMethods
      addGenerics <- expMethods[is.na(match(expMethods, exports))]
      if (length(addGenerics)) {
        nowhere <- vapply(addGenerics, function(what) !exists(what, mode = "function", envir = ns), NA, USE.NAMES = FALSE)
        if (any(nowhere)) {
          warning(gettextf("no function found corresponding to methods exports from %s for: %s", sQuote(package), paste(sQuote(sort(unique(addGenerics[nowhere]))), collapse = ", ")), domain = NA, call. = FALSE)
          addGenerics <- addGenerics[!nowhere]
        }
        if (length(addGenerics)) {
          addGenerics <- addGenerics[vapply(addGenerics, function(what) !is.primitive(get(what, mode = "function", envir = ns)), NA)]
          ok <- vapply(addGenerics, methods:::.findsGeneric, 1, ns)
          if (!all(ok)) {
            bad <- sort(unique(addGenerics[!ok]))
            msg <- ngettext(length(bad), "Function found when exporting methods from the namespace %s which is not S4 generic: %s", "Functions found when exporting methods from the namespace %s which are not S4 generic: %s")
            stop(sprintf(msg, sQuote(package), paste(sQuote(bad), collapse = ", ")), domain = NA, call. = FALSE)
          }
          else if (any(ok > 1)) 
            addGenerics <- addGenerics[ok < 2]
        }
        exports <- c(exports, addGenerics)
      }
      expTables <- character()
      if (length(allGenerics)) {
        expMethods <- unique(c(expMethods, exports[!is.na(match(exports, allGenerics))]))
        missingMethods <- !(expMethods %in% allGenerics)
        if (any(missingMethods)) 
          stop(gettextf("in %s methods for export not found: %s", sQuote(package), paste(expMethods[missingMethods], collapse = ", ")), domain = NA)
        tPrefix <- methods:::.TableMetaPrefix()
        allMethodTables <- unique(c(methods:::.getGenerics(ns, tPrefix), methods:::.getGenerics(parent.env(ns), tPrefix)))
        needMethods <- (exports %in% allGenerics) & !(exports %in% expMethods)
        if (any(needMethods)) 
          expMethods <- c(expMethods, exports[needMethods])
        pm <- allGenerics[!(allGenerics %in% expMethods)]
        if (length(pm)) {
          prim <- vapply(pm, function(pmi) {
            f <- methods::getFunction(pmi, FALSE, FALSE, ns)
            is.primitive(f)
          }, logical(1))
          expMethods <- c(expMethods, pm[prim])
        }
        for (i in seq_along(expMethods)) {
          mi <- expMethods[[i]]
          if (lev > 3) 
            message("---- export method ", sQuote(mi))
          if (!(mi %in% exports) && exists(mi, envir = ns, mode = "function", inherits = FALSE)) 
            exports <- c(exports, mi)
          pattern <- paste0(tPrefix, mi, ":")
          ii <- grep(pattern, allMethodTables, fixed = TRUE)
          if (length(ii)) {
            if (length(ii) > 1) {
              warning(gettextf("multiple methods tables found for %s", sQuote(mi)), call. = FALSE, domain = NA)
              ii <- ii[1]
            }
            expTables[[i]] <- allMethodTables[ii]
          }
          else {
            warning(gettextf("failed to find metadata object for %s", sQuote(mi)), call. = FALSE, domain = NA)
          }
        }
      }
      else if (length(expMethods)) 
        stop(gettextf("in package %s methods %s were specified for export but not defined", sQuote(package), paste(expMethods, collapse = ", ")), domain = NA)
      exports <- unique(c(exports, expClasses, expTables))
      if (lev > 1 || lev == -5) 
        message("-- done processing S4 stuff for ", dQuote(package))
    }
    if (length(exports)) {
      stoplist <- c(".__NAMESPACE__.", ".__S3MethodsTable__.", ".packageName", ".First.lib", ".onLoad", ".onAttach", ".conflicts.OK", ".noGenerics")
      exports <- exports[!exports %in% stoplist]
    }
    if (lev > 2) 
      message("--- processing exports for ", dQuote(package))
    namespaceExport(ns, exports)
    if (lev > 2) 
      message("--- sealing exports for ", dQuote(package))
    sealNamespace(ns)
    runUserHook(package, pkgpath)
    on.exit()
    if (lev > 0) 
      message("- done loading ", dQuote(package))
    Sys.unsetenv("_R_NS_LOAD_")
    ns
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
local
list(`package:base` = function (expr, envir = new.env()) 
  eval.parent(substitute(eval(quote(expr), envir))), function (expr, envir = new.env()) 
    eval.parent(substitute(eval(quote(expr), envir))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lockBinding
list(`package:base` = function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(lockBinding(sym, env))
}, function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(lockBinding(sym, env))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lockEnvironment
list(`package:base` = function (env, bindings = FALSE) 
  .Internal(lockEnvironment(env, bindings)), function (env, bindings = FALSE) 
    .Internal(lockEnvironment(env, bindings)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
log
list(`package:base` = .Primitive("log"), .Primitive("log"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
log10
list(`package:base` = .Primitive("log10"), .Primitive("log10"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
log1p
list(`package:base` = .Primitive("log1p"), .Primitive("log1p"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
log2
list(`package:base` = .Primitive("log2"), .Primitive("log2"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
logb
list(`package:base` = function (x, base = exp(1)) 
  if (missing(base)) log(x) else log(x, base), function (x, base = exp(1)) 
    if (missing(base)) log(x) else log(x, base))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
logical
list(`package:base` = function (length = 0) 
  .Internal(vector("logical", length)), function (length = 0) 
    .Internal(vector("logical", length)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
lower.tri
list(`package:base` = function (x, diag = FALSE) 
{
  d <- dim(x)
  if (length(d) != 2) 
    d <- dim(as.matrix(x))
  if (diag) 
    .row(d) >= .col(d)
  else .row(d) > .col(d)
}, function (x, diag = FALSE) 
{
  d <- dim(x)
  if (length(d) != 2) 
    d <- dim(as.matrix(x))
  if (diag) 
    .row(d) >= .col(d)
  else .row(d) > .col(d)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
ls
list(`package:base` = function (name, pos = -1, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE) 
{
  if (!missing(name)) {
    pos <- tryCatch(name, error = function(e) e)
    if (inherits(pos, "error")) {
      name <- substitute(name)
      if (!is.character(name)) 
        name <- deparse(name)
      warning(gettextf("%s converted to character string", sQuote(name)), domain = NA)
      pos <- name
    }
  }
  all.names <- .Internal(ls(envir, all.names, sorted))
  if (!missing(pattern)) {
    if ((ll <- length(grep("[", pattern, fixed = TRUE))) && ll != length(grep("]", pattern, fixed = TRUE))) {
      if (pattern == "[") {
        pattern <- "\\["
        warning("replaced regular expression pattern '[' by  '\\\\['")
      }
      else if (length(grep("[^\\\\]\\[<-", pattern))) {
        pattern <- sub("\\[<-", "\\\\\\[<-", pattern)
        warning("replaced '[<-' by '\\\\[<-' in regular expression pattern")
      }
    }
    grep(pattern, all.names, value = TRUE)
  }
  else all.names
}, function (name, pos = -1, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE) 
{
  if (!missing(name)) {
    pos <- tryCatch(name, error = function(e) e)
    if (inherits(pos, "error")) {
      name <- substitute(name)
      if (!is.character(name)) 
        name <- deparse(name)
      warning(gettextf("%s converted to character string", sQuote(name)), domain = NA)
      pos <- name
    }
  }
  all.names <- .Internal(ls(envir, all.names, sorted))
  if (!missing(pattern)) {
    if ((ll <- length(grep("[", pattern, fixed = TRUE))) && ll != length(grep("]", pattern, fixed = TRUE))) {
      if (pattern == "[") {
        pattern <- "\\["
        warning("replaced regular expression pattern '[' by  '\\\\['")
      }
      else if (length(grep("[^\\\\]\\[<-", pattern))) {
        pattern <- sub("\\[<-", "\\\\\\[<-", pattern)
        warning("replaced '[<-' by '\\\\[<-' in regular expression pattern")
      }
    }
    grep(pattern, all.names, value = TRUE)
  }
  else all.names
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
make.names
list(`package:base` = function (names, unique = FALSE, allow_ = TRUE) 
{
  names <- as.character(names)
  names2 <- .Internal(make.names(names, allow_))
  if (unique) {
    o <- order(names != names2)
    names2[o] <- make.unique(names2[o])
  }
  names2
}, function (names, unique = FALSE, allow_ = TRUE) 
{
  names <- as.character(names)
  names2 <- .Internal(make.names(names, allow_))
  if (unique) {
    o <- order(names != names2)
    names2[o] <- make.unique(names2[o])
  }
  names2
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
make.unique
list(`package:base` = function (names, sep = ".") 
  .Internal(make.unique(names, sep)), function (names, sep = ".") 
    .Internal(make.unique(names, sep)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeActiveBinding
list(`package:base` = function (sym, fun, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(makeActiveBinding(sym, fun, env))
}, function (sym, fun, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(makeActiveBinding(sym, fun, env))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Map
list(`package:base` = function (f, ...) 
{
  f <- match.fun(f)
  mapply(FUN = f, ..., SIMPLIFY = FALSE)
}, function (f, ...) 
{
  f <- match.fun(f)
  mapply(FUN = f, ..., SIMPLIFY = FALSE)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
mapply
list(`package:base` = function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE) 
{
  FUN <- match.fun(FUN)
  dots <- list(...)
  answer <- .Internal(mapply(FUN, dots, MoreArgs))
  if (USE.NAMES && length(dots)) {
    if (is.null(names1 <- names(dots[[1]])) && is.character(dots[[1]])) 
      names(answer) <- if (length(answer)) 
        dots[[1]]
    else character()
    else if (!is.null(names1)) 
      names(answer) <- names1
  }
  if (!isFALSE(SIMPLIFY)) 
    simplify2array(answer, higher = (SIMPLIFY == "array"))
  else answer
}, function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE) 
{
  FUN <- match.fun(FUN)
  dots <- list(...)
  answer <- .Internal(mapply(FUN, dots, MoreArgs))
  if (USE.NAMES && length(dots)) {
    if (is.null(names1 <- names(dots[[1]])) && is.character(dots[[1]])) 
      names(answer) <- if (length(answer)) 
        dots[[1]]
    else character()
    else if (!is.null(names1)) 
      names(answer) <- names1
  }
  if (!isFALSE(SIMPLIFY)) 
    simplify2array(answer, higher = (SIMPLIFY == "array"))
  else answer
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
margin.table
list(`package:base` = function (x, margin = NULL) 
{
  if (!is.array(x)) 
    if (is.numeric(x)) 
      dim(x) <- length(x)
  else stop("'x' is not an array")
  if (length(margin)) {
    z <- apply(x, margin, sum)
    if (!is.array(z)) {
      if (is.character(margin)) 
        margin <- match(margin, names(dimnames(x)))
      dim(z) <- dim(x)[margin]
      dimnames(z) <- dimnames(x)[margin]
    }
    class(z) <- oldClass(x)
    z
  }
  else sum(x)
}, function (x, margin = NULL) 
{
  if (!is.array(x)) 
    if (is.numeric(x)) 
      dim(x) <- length(x)
  else stop("'x' is not an array")
  if (length(margin)) {
    z <- apply(x, margin, sum)
    if (!is.array(z)) {
      if (is.character(margin)) 
        margin <- match(margin, names(dimnames(x)))
      dim(z) <- dim(x)[margin]
      dimnames(z) <- dimnames(x)[margin]
    }
    class(z) <- oldClass(x)
    z
  }
  else sum(x)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
marginSums
list(`package:base` = function (x, margin = NULL) 
{
  if (!is.array(x)) 
    if (is.numeric(x)) 
      dim(x) <- length(x)
  else stop("'x' is not an array")
  if (length(margin)) {
    z <- apply(x, margin, sum)
    if (!is.array(z)) {
      if (is.character(margin)) 
        margin <- match(margin, names(dimnames(x)))
      dim(z) <- dim(x)[margin]
      dimnames(z) <- dimnames(x)[margin]
    }
    class(z) <- oldClass(x)
    z
  }
  else sum(x)
}, function (x, margin = NULL) 
{
  if (!is.array(x)) 
    if (is.numeric(x)) 
      dim(x) <- length(x)
  else stop("'x' is not an array")
  if (length(margin)) {
    z <- apply(x, margin, sum)
    if (!is.array(z)) {
      if (is.character(margin)) 
        margin <- match(margin, names(dimnames(x)))
      dim(z) <- dim(x)[margin]
      dimnames(z) <- dimnames(x)[margin]
    }
    class(z) <- oldClass(x)
    z
  }
  else sum(x)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
mat.or.vec
list(`package:base` = function (nr, nc) 
  if (nc == 1) numeric(nr) else matrix(0, nr, nc), function (nr, nc) 
    if (nc == 1) numeric(nr) else matrix(0, nr, nc))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
match
list(`package:base` = function (x, table, nomatch = NA, incomparables = NULL) 
  .Internal(match(x, table, nomatch, incomparables)), function (x, table, nomatch = NA, incomparables = NULL) 
    .Internal(match(x, table, nomatch, incomparables)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
match.arg
list(`package:base` = function (arg, choices, several.ok = FALSE) 
{
  if (missing(choices)) {
    formal.args <- formals(sys.function(sysP <- sys.parent()))
    choices <- eval(formal.args[[as.character(substitute(arg))]], envir = sys.frame(sysP))
  }
  if (is.null(arg)) 
    return(choices[1])
  else if (!is.character(arg)) 
    stop("'arg' must be NULL or a character vector")
  if (!several.ok) {
    if (identical(arg, choices)) 
      return(arg[1])
    if (length(arg) > 1) 
      stop("'arg' must be of length 1")
  }
  else if (length(arg) == 0) 
    stop("'arg' must be of length >= 1")
  i <- pmatch(arg, choices, nomatch = 0, duplicates.ok = TRUE)
  if (all(i == 0)) 
    stop(sprintf(ngettext(length(chs <- unique(choices[nzchar(choices)])), "'arg' should be %s", "'arg' should be one of %s"), paste(dQuote(chs), collapse = ", ")), domain = NA)
  i <- i[i > 0]
  if (!several.ok && length(i) > 1) 
    stop("there is more than one match in 'match.arg'")
  choices[i]
}, function (arg, choices, several.ok = FALSE) 
{
  if (missing(choices)) {
    formal.args <- formals(sys.function(sysP <- sys.parent()))
    choices <- eval(formal.args[[as.character(substitute(arg))]], envir = sys.frame(sysP))
  }
  if (is.null(arg)) 
    return(choices[1])
  else if (!is.character(arg)) 
    stop("'arg' must be NULL or a character vector")
  if (!several.ok) {
    if (identical(arg, choices)) 
      return(arg[1])
    if (length(arg) > 1) 
      stop("'arg' must be of length 1")
  }
  else if (length(arg) == 0) 
    stop("'arg' must be of length >= 1")
  i <- pmatch(arg, choices, nomatch = 0, duplicates.ok = TRUE)
  if (all(i == 0)) 
    stop(sprintf(ngettext(length(chs <- unique(choices[nzchar(choices)])), "'arg' should be %s", "'arg' should be one of %s"), paste(dQuote(chs), collapse = ", ")), domain = NA)
  i <- i[i > 0]
  if (!several.ok && length(i) > 1) 
    stop("there is more than one match in 'match.arg'")
  choices[i]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
match.call
list(`package:base` = function (definition = sys.function(sys.parent()), call = sys.call(sys.parent()), expand.dots = TRUE, envir = parent.frame(2)) 
{
  if (!missing(definition) && is.null(definition)) {
    definition <- sys.function(sys.parent())
  }
  .Internal(match.call(definition, call, expand.dots, envir))
}, function (definition = sys.function(sys.parent()), call = sys.call(sys.parent()), expand.dots = TRUE, envir = parent.frame(2)) 
{
  if (!missing(definition) && is.null(definition)) {
    definition <- sys.function(sys.parent())
  }
  .Internal(match.call(definition, call, expand.dots, envir))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
match.fun
list(`package:base` = function (FUN, descend = TRUE) 
{
  if (is.function(FUN)) 
    return(FUN)
  if (!(is.character(FUN) && length(FUN) == 1 || is.symbol(FUN))) {
    FUN <- eval.parent(substitute(substitute(FUN)))
    if (!is.symbol(FUN)) 
      stop(gettextf("'%s' is not a function, character or symbol", deparse(FUN)), domain = NA)
  }
  envir <- parent.frame(2)
  if (descend) 
    FUN <- get(as.character(FUN), mode = "function", envir = envir)
  else {
    FUN <- get(as.character(FUN), mode = "any", envir = envir)
    if (!is.function(FUN)) 
      stop(gettextf("found non-function '%s'", FUN), domain = NA)
  }
  return(FUN)
}, function (FUN, descend = TRUE) 
{
  if (is.function(FUN)) 
    return(FUN)
  if (!(is.character(FUN) && length(FUN) == 1 || is.symbol(FUN))) {
    FUN <- eval.parent(substitute(substitute(FUN)))
    if (!is.symbol(FUN)) 
      stop(gettextf("'%s' is not a function, character or symbol", deparse(FUN)), domain = NA)
  }
  envir <- parent.frame(2)
  if (descend) 
    FUN <- get(as.character(FUN), mode = "function", envir = envir)
  else {
    FUN <- get(as.character(FUN), mode = "any", envir = envir)
    if (!is.function(FUN)) 
      stop(gettextf("found non-function '%s'", FUN), domain = NA)
  }
  return(FUN)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Math.data.frame
list(`package:base` = function (x, ...) 
{
  mode.ok <- vapply(x, function(x) is.numeric(x) || is.logical(x) || is.complex(x), NA)
  if (all(mode.ok)) {
    x[] <- lapply(X = x, FUN = .Generic, ...)
    return(x)
  }
  else {
    vnames <- names(x)
    if (is.null(vnames)) 
      vnames <- seq_along(x)
    stop("non-numeric-alike variable(s) in data frame: ", paste(vnames[!mode.ok], collapse = ", "))
  }
}, function (x, ...) 
{
  mode.ok <- vapply(x, function(x) is.numeric(x) || is.logical(x) || is.complex(x), NA)
  if (all(mode.ok)) {
    x[] <- lapply(X = x, FUN = .Generic, ...)
    return(x)
  }
  else {
    vnames <- names(x)
    if (is.null(vnames)) 
      vnames <- seq_along(x)
    stop("non-numeric-alike variable(s) in data frame: ", paste(vnames[!mode.ok], collapse = ", "))
  }
}, function (x, ...) 
{
  mode.ok <- vapply(x, function(x) is.numeric(x) || is.logical(x) || is.complex(x), NA)
  if (all(mode.ok)) {
    x[] <- lapply(X = x, FUN = .Generic, ...)
    return(x)
  }
  else {
    vnames <- names(x)
    if (is.null(vnames)) 
      vnames <- seq_along(x)
    stop("non-numeric-alike variable(s) in data frame: ", paste(vnames[!mode.ok], collapse = ", "))
  }
})
c("package:base", "registered S3 method for Math from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Math.Date
list(`package:base` = function (x, ...) 
  stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA), function (x, ...) 
    stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA), function (x, ...) 
      stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA))
c("package:base", "registered S3 method for Math from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Math.difftime
list(`package:base` = function (x, ...) 
{
  switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , round = , signif = {
    units <- attr(x, "units")
    .difftime(NextMethod(), units)
  }, stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA))
}, function (x, ...) 
{
  switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , round = , signif = {
    units <- attr(x, "units")
    .difftime(NextMethod(), units)
  }, stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA))
}, function (x, ...) 
{
  switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , round = , signif = {
    units <- attr(x, "units")
    .difftime(NextMethod(), units)
  }, stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA))
})
c("package:base", "registered S3 method for Math from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Math.factor
list(`package:base` = function (x, ...) 
  stop(gettextf("%s not meaningful for factors", sQuote(.Generic))), function (x, ...) 
    stop(gettextf("%s not meaningful for factors", sQuote(.Generic))), function (x, ...) 
      stop(gettextf("%s not meaningful for factors", sQuote(.Generic))))
c("package:base", "registered S3 method for Math from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Math.POSIXt
list(`package:base` = function (x, ...) 
{
  stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
}, function (x, ...) 
{
  stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
}, function (x, ...) 
{
  stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
})
c("package:base", "registered S3 method for Math from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
matrix
list(`package:base` = function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) 
{
  if (is.object(data) || !is.atomic(data)) 
    data <- as.vector(data)
  .Internal(matrix(data, nrow, ncol, byrow, dimnames, missing(nrow), missing(ncol)))
}, function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) 
{
  if (is.object(data) || !is.atomic(data)) 
    data <- as.vector(data)
  .Internal(matrix(data, nrow, ncol, byrow, dimnames, missing(nrow), missing(ncol)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
max
list(`package:base` = .Primitive("max"), .Primitive("max"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
max.col
list(`package:base` = function (m, ties.method = c("random", "first", "last")) 
{
  ties.method <- match.arg(ties.method)
  tieM <- which(ties.method == eval(formals()[["ties.method"]]))
  .Internal(max.col(as.matrix(m), tieM))
}, function (m, ties.method = c("random", "first", "last")) 
{
  ties.method <- match.arg(ties.method)
  tieM <- which(ties.method == eval(formals()[["ties.method"]]))
  .Internal(max.col(as.matrix(m), tieM))
}, function (m, ties.method = c("random", "first", "last")) 
{
  ties.method <- match.arg(ties.method)
  tieM <- which(ties.method == eval(formals()[["ties.method"]]))
  .Internal(max.col(as.matrix(m), tieM))
})
c("package:base", "registered S3 method for max from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
mean
list(`package:base` = function (x, ...) 
  UseMethod("mean"), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("mean"), generic = "mean", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
      UseMethod("mean"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "mean"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("mean"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "mean"))(x, ...)), function (x, ...) 
          UseMethod("mean"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
mean.Date
list(`package:base` = function (x, ...) 
  .Date(mean(unclass(x), ...)), function (x, ...) 
    .Date(mean(unclass(x), ...)), function (x, ...) 
      .Date(mean(unclass(x), ...)))
c("package:base", "registered S3 method for mean from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
mean.default
list(`package:base` = function (x, trim = 0, na.rm = FALSE, ...) 
{
  if (!is.numeric(x) && !is.complex(x) && !is.logical(x)) {
    warning("argument is not numeric or logical: returning NA")
    return(NA)
  }
  if (isTRUE(na.rm)) 
    x <- x[!is.na(x)]
  if (!is.numeric(trim) || length(trim) != 1) 
    stop("'trim' must be numeric of length one")
  n <- length(x)
  if (trim > 0 && n) {
    if (is.complex(x)) 
      stop("trimmed means are not defined for complex data")
    if (anyNA(x)) 
      return(NA)
    if (trim >= 0.5) 
      return(stats::median(x, na.rm = FALSE))
    lo <- floor(n * trim) + 1
    hi <- n + 1 - lo
    x <- sort.int(x, partial = unique(c(lo, hi)))[lo:hi]
  }
  .Internal(mean(x))
}, function (x, trim = 0, na.rm = FALSE, ...) 
{
  if (!is.numeric(x) && !is.complex(x) && !is.logical(x)) {
    warning("argument is not numeric or logical: returning NA")
    return(NA)
  }
  if (isTRUE(na.rm)) 
    x <- x[!is.na(x)]
  if (!is.numeric(trim) || length(trim) != 1) 
    stop("'trim' must be numeric of length one")
  n <- length(x)
  if (trim > 0 && n) {
    if (is.complex(x)) 
      stop("trimmed means are not defined for complex data")
    if (anyNA(x)) 
      return(NA)
    if (trim >= 0.5) 
      return(stats::median(x, na.rm = FALSE))
    lo <- floor(n * trim) + 1
    hi <- n + 1 - lo
    x <- sort.int(x, partial = unique(c(lo, hi)))[lo:hi]
  }
  .Internal(mean(x))
}, function (x, trim = 0, na.rm = FALSE, ...) 
{
  if (!is.numeric(x) && !is.complex(x) && !is.logical(x)) {
    warning("argument is not numeric or logical: returning NA")
    return(NA)
  }
  if (isTRUE(na.rm)) 
    x <- x[!is.na(x)]
  if (!is.numeric(trim) || length(trim) != 1) 
    stop("'trim' must be numeric of length one")
  n <- length(x)
  if (trim > 0 && n) {
    if (is.complex(x)) 
      stop("trimmed means are not defined for complex data")
    if (anyNA(x)) 
      return(NA)
    if (trim >= 0.5) 
      return(stats::median(x, na.rm = FALSE))
    lo <- floor(n * trim) + 1
    hi <- n + 1 - lo
    x <- sort.int(x, partial = unique(c(lo, hi)))[lo:hi]
  }
  .Internal(mean(x))
})
c("package:base", "registered S3 method for mean from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
mean.difftime
list(`package:base` = function (x, ...) 
  .difftime(mean(unclass(x), ...), attr(x, "units")), function (x, ...) 
    .difftime(mean(unclass(x), ...), attr(x, "units")), function (x, ...) 
      .difftime(mean(unclass(x), ...), attr(x, "units")))
c("package:base", "registered S3 method for mean from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
mean.POSIXct
list(`package:base` = function (x, ...) 
  .POSIXct(mean(unclass(x), ...), attr(x, "tzone")), function (x, ...) 
    .POSIXct(mean(unclass(x), ...), attr(x, "tzone")), function (x, ...) 
      .POSIXct(mean(unclass(x), ...), attr(x, "tzone")))
c("package:base", "registered S3 method for mean from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
mean.POSIXlt
list(`package:base` = function (x, ...) 
  as.POSIXlt(mean(as.POSIXct(x), ...)), function (x, ...) 
    as.POSIXlt(mean(as.POSIXct(x), ...)), function (x, ...) 
      as.POSIXlt(mean(as.POSIXct(x), ...)))
c("package:base", "registered S3 method for mean from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
mem.maxNSize
list(`package:base` = function (nsize = 0) 
  .Internal(mem.maxNSize(nsize)), function (nsize = 0) 
    .Internal(mem.maxNSize(nsize)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
mem.maxVSize
list(`package:base` = function (vsize = 0) 
  .Internal(mem.maxVSize(vsize)), function (vsize = 0) 
    .Internal(mem.maxVSize(vsize)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
memCompress
list(`package:base` = function (from, type = c("gzip", "bzip2", "xz", "none")) 
{
  if (is.character(from)) 
    from <- charToRaw(paste(from, collapse = "\n"))
  else if (!is.raw(from)) 
    stop("'from' must be raw or character")
  type <- match(match.arg(type), c("none", "gzip", "bzip2", "xz"))
  .Internal(memCompress(from, type))
}, function (from, type = c("gzip", "bzip2", "xz", "none")) 
{
  if (is.character(from)) 
    from <- charToRaw(paste(from, collapse = "\n"))
  else if (!is.raw(from)) 
    stop("'from' must be raw or character")
  type <- match(match.arg(type), c("none", "gzip", "bzip2", "xz"))
  .Internal(memCompress(from, type))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
memDecompress
list(`package:base` = function (from, type = c("unknown", "gzip", "bzip2", "xz", "none"), asChar = FALSE) 
{
  type <- match(match.arg(type), c("none", "gzip", "bzip2", "xz", "unknown"))
  ans <- .Internal(memDecompress(from, type))
  if (asChar) 
    rawToChar(ans)
  else ans
}, function (from, type = c("unknown", "gzip", "bzip2", "xz", "none"), asChar = FALSE) 
{
  type <- match(match.arg(type), c("none", "gzip", "bzip2", "xz", "unknown"))
  ans <- .Internal(memDecompress(from, type))
  if (asChar) 
    rawToChar(ans)
  else ans
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
memory.profile
list(`package:base` = function () 
  .Internal(memory.profile()), function () 
    .Internal(memory.profile()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
merge
list(`package:base` = function (x, y, ...) 
  UseMethod("merge"), function (x, y, ...) 
    UseMethod("merge"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
merge.data.frame
list(`package:base` = function (x, y, by = intersect(names(x), names(y)), by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all, sort = TRUE, suffixes = c(".x", ".y"), no.dups = TRUE, incomparables = NULL, ...) 
{
  fix.by <- function(by, df) {
    if (is.null(by)) 
      by <- numeric()
    by <- as.vector(by)
    nc <- ncol(df)
    if (is.character(by)) {
      poss <- c("row.names", names(df))
      if (any(bad <- !charmatch(by, poss, 0))) 
        stop(ngettext(sum(bad), "'by' must specify a uniquely valid column", "'by' must specify uniquely valid columns"), domain = NA)
      by <- match(by, poss) - 1
    }
    else if (is.numeric(by)) {
      if (any(by < 0) || any(by > nc)) 
        stop("'by' must match numbers of columns")
    }
    else if (is.logical(by)) {
      if (length(by) != nc) 
        stop("'by' must match number of columns")
      by <- seq_along(by)[by]
    }
    else stop("'by' must specify one or more columns as numbers, names or logical")
    if (any(bad <- is.na(by))) 
      stop(ngettext(sum(bad), "'by' must specify a uniquely valid column", "'by' must specify uniquely valid columns"), domain = NA)
    unique(by)
  }
  nx <- nrow(x <- as.data.frame(x))
  ny <- nrow(y <- as.data.frame(y))
  if (nx >= 2^31 || ny >= 2^31) 
    stop("long vectors are not supported")
  by.x <- fix.by(by.x, x)
  by.y <- fix.by(by.y, y)
  if ((l.b <- length(by.x)) != length(by.y)) 
    stop("'by.x' and 'by.y' specify different numbers of columns")
  if (l.b == 0) {
    nm <- nm.x <- names(x)
    nm.y <- names(y)
    has.common.nms <- any(cnm <- nm.x %in% nm.y)
    if (has.common.nms) {
      names(x)[cnm] <- paste0(nm.x[cnm], suffixes[1])
      cnm <- nm.y %in% nm
      names(y)[cnm] <- paste0(nm.y[cnm], suffixes[2])
    }
    if (nx == 0 || ny == 0) {
      res <- cbind(x[FALSE, ], y[FALSE, ])
    }
    else {
      ij <- expand.grid(seq_len(nx), seq_len(ny))
      res <- cbind(x[ij[, 1], , drop = FALSE], y[ij[, 2], , drop = FALSE])
    }
  }
  else {
    if (any(by.x == 0)) {
      x <- cbind(Row.names = I(row.names(x)), x)
      by.x <- by.x + 1
    }
    if (any(by.y == 0)) {
      y <- cbind(Row.names = I(row.names(y)), y)
      by.y <- by.y + 1
    }
    row.names(x) <- NULL
    row.names(y) <- NULL
    if (l.b == 1) {
      bx <- x[, by.x]
      if (is.factor(bx)) 
        bx <- as.character(bx)
      by <- y[, by.y]
      if (is.factor(by)) 
        by <- as.character(by)
    }
    else {
      if (!is.null(incomparables)) 
        stop("'incomparables' is supported only for merging on a single column")
      bx <- x[, by.x, drop = FALSE]
      by <- y[, by.y, drop = FALSE]
      names(bx) <- names(by) <- paste0("V", seq_len(ncol(bx)))
      bz <- do.call("paste", c(rbind(bx, by), sep = "\r"))
      bx <- bz[seq_len(nx)]
      by <- bz[nx + seq_len(ny)]
    }
    comm <- match(bx, by, 0)
    bxy <- bx[comm > 0]
    xinds <- match(bx, bxy, 0, incomparables)
    yinds <- match(by, bxy, 0, incomparables)
    if (nx > 0 && ny > 0) 
      m <- .Internal(merge(xinds, yinds, all.x, all.y))
    else m <- list(xi = integer(), yi = integer(), x.alone = seq_len(nx), y.alone = seq_len(ny))
    nm <- nm.x <- names(x)[-by.x]
    nm.by <- names(x)[by.x]
    nm.y <- names(y)[-by.y]
    ncx <- ncol(x)
    if (all.x) 
      all.x <- (nxx <- length(m$x.alone)) > 0
    if (all.y) 
      all.y <- (nyy <- length(m$y.alone)) > 0
    lxy <- length(m$xi)
    has.common.nms <- any(cnm <- nm.x %in% nm.y)
    if (has.common.nms && nzchar(suffixes[1])) 
      nm.x[cnm] <- paste0(nm.x[cnm], suffixes[1])
    x <- x[c(m$xi, if (all.x) m$x.alone), c(by.x, seq_len(ncx)[-by.x]), drop = FALSE]
    names(x) <- c(nm.by, nm.x)
    if (all.y) {
      ya <- y[m$y.alone, by.y, drop = FALSE]
      names(ya) <- nm.by
      xa <- x[rep.int(NA, nyy), nm.x, drop = FALSE]
      names(xa) <- nm.x
      x <- rbind(x, cbind(ya, xa))
    }
    if (has.common.nms && nzchar(suffixes[2])) {
      cnm <- nm.y %in% nm
      nm.y[cnm] <- paste0(nm.y[cnm], suffixes[2])
    }
    y <- y[c(m$yi, if (all.x) rep.int(1, nxx), if (all.y) m$y.alone), -by.y, drop = FALSE]
    if (all.x) {
      zap <- (lxy + 1):(lxy + nxx)
      for (i in seq_along(y)) {
        if (is.matrix(y[[i]])) 
          y[[i]][zap, ] <- NA
        else is.na(y[[i]]) <- zap
      }
    }
    if (has.common.nms) 
      names(y) <- nm.y
    if (no.dups && any((mi <- match(nm.by, names(y), 0)) > 0) && nzchar(suffixes[2])) 
      names(y)[mi] <- paste0(names(y)[mi], suffixes[2])
    nm <- c(names(x), names(y))
    if (any(d <- duplicated(nm))) 
      if (sum(d) > 1) 
        warning("column names ", paste(sQuote(nm[d]), collapse = ", "), " are duplicated in the result", domain = NA)
    else warning("column name ", sQuote(nm[d]), " is duplicated in the result", domain = NA)
    res <- cbind(x, y)
    if (sort) 
      res <- res[if (all.x || all.y) {
        x <- x[, seq_len(l.b), drop = FALSE]
        attributes(x) <- NULL
        do.call("order", x)
      }
      else sort.list(bx[m$xi]), , drop = FALSE]
  }
  attr(res, "row.names") <- .set_row_names(nrow(res))
  res
}, function (x, y, by = intersect(names(x), names(y)), by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all, sort = TRUE, suffixes = c(".x", ".y"), no.dups = TRUE, incomparables = NULL, ...) 
{
  fix.by <- function(by, df) {
    if (is.null(by)) 
      by <- numeric()
    by <- as.vector(by)
    nc <- ncol(df)
    if (is.character(by)) {
      poss <- c("row.names", names(df))
      if (any(bad <- !charmatch(by, poss, 0))) 
        stop(ngettext(sum(bad), "'by' must specify a uniquely valid column", "'by' must specify uniquely valid columns"), domain = NA)
      by <- match(by, poss) - 1
    }
    else if (is.numeric(by)) {
      if (any(by < 0) || any(by > nc)) 
        stop("'by' must match numbers of columns")
    }
    else if (is.logical(by)) {
      if (length(by) != nc) 
        stop("'by' must match number of columns")
      by <- seq_along(by)[by]
    }
    else stop("'by' must specify one or more columns as numbers, names or logical")
    if (any(bad <- is.na(by))) 
      stop(ngettext(sum(bad), "'by' must specify a uniquely valid column", "'by' must specify uniquely valid columns"), domain = NA)
    unique(by)
  }
  nx <- nrow(x <- as.data.frame(x))
  ny <- nrow(y <- as.data.frame(y))
  if (nx >= 2^31 || ny >= 2^31) 
    stop("long vectors are not supported")
  by.x <- fix.by(by.x, x)
  by.y <- fix.by(by.y, y)
  if ((l.b <- length(by.x)) != length(by.y)) 
    stop("'by.x' and 'by.y' specify different numbers of columns")
  if (l.b == 0) {
    nm <- nm.x <- names(x)
    nm.y <- names(y)
    has.common.nms <- any(cnm <- nm.x %in% nm.y)
    if (has.common.nms) {
      names(x)[cnm] <- paste0(nm.x[cnm], suffixes[1])
      cnm <- nm.y %in% nm
      names(y)[cnm] <- paste0(nm.y[cnm], suffixes[2])
    }
    if (nx == 0 || ny == 0) {
      res <- cbind(x[FALSE, ], y[FALSE, ])
    }
    else {
      ij <- expand.grid(seq_len(nx), seq_len(ny))
      res <- cbind(x[ij[, 1], , drop = FALSE], y[ij[, 2], , drop = FALSE])
    }
  }
  else {
    if (any(by.x == 0)) {
      x <- cbind(Row.names = I(row.names(x)), x)
      by.x <- by.x + 1
    }
    if (any(by.y == 0)) {
      y <- cbind(Row.names = I(row.names(y)), y)
      by.y <- by.y + 1
    }
    row.names(x) <- NULL
    row.names(y) <- NULL
    if (l.b == 1) {
      bx <- x[, by.x]
      if (is.factor(bx)) 
        bx <- as.character(bx)
      by <- y[, by.y]
      if (is.factor(by)) 
        by <- as.character(by)
    }
    else {
      if (!is.null(incomparables)) 
        stop("'incomparables' is supported only for merging on a single column")
      bx <- x[, by.x, drop = FALSE]
      by <- y[, by.y, drop = FALSE]
      names(bx) <- names(by) <- paste0("V", seq_len(ncol(bx)))
      bz <- do.call("paste", c(rbind(bx, by), sep = "\r"))
      bx <- bz[seq_len(nx)]
      by <- bz[nx + seq_len(ny)]
    }
    comm <- match(bx, by, 0)
    bxy <- bx[comm > 0]
    xinds <- match(bx, bxy, 0, incomparables)
    yinds <- match(by, bxy, 0, incomparables)
    if (nx > 0 && ny > 0) 
      m <- .Internal(merge(xinds, yinds, all.x, all.y))
    else m <- list(xi = integer(), yi = integer(), x.alone = seq_len(nx), y.alone = seq_len(ny))
    nm <- nm.x <- names(x)[-by.x]
    nm.by <- names(x)[by.x]
    nm.y <- names(y)[-by.y]
    ncx <- ncol(x)
    if (all.x) 
      all.x <- (nxx <- length(m$x.alone)) > 0
    if (all.y) 
      all.y <- (nyy <- length(m$y.alone)) > 0
    lxy <- length(m$xi)
    has.common.nms <- any(cnm <- nm.x %in% nm.y)
    if (has.common.nms && nzchar(suffixes[1])) 
      nm.x[cnm] <- paste0(nm.x[cnm], suffixes[1])
    x <- x[c(m$xi, if (all.x) m$x.alone), c(by.x, seq_len(ncx)[-by.x]), drop = FALSE]
    names(x) <- c(nm.by, nm.x)
    if (all.y) {
      ya <- y[m$y.alone, by.y, drop = FALSE]
      names(ya) <- nm.by
      xa <- x[rep.int(NA, nyy), nm.x, drop = FALSE]
      names(xa) <- nm.x
      x <- rbind(x, cbind(ya, xa))
    }
    if (has.common.nms && nzchar(suffixes[2])) {
      cnm <- nm.y %in% nm
      nm.y[cnm] <- paste0(nm.y[cnm], suffixes[2])
    }
    y <- y[c(m$yi, if (all.x) rep.int(1, nxx), if (all.y) m$y.alone), -by.y, drop = FALSE]
    if (all.x) {
      zap <- (lxy + 1):(lxy + nxx)
      for (i in seq_along(y)) {
        if (is.matrix(y[[i]])) 
          y[[i]][zap, ] <- NA
        else is.na(y[[i]]) <- zap
      }
    }
    if (has.common.nms) 
      names(y) <- nm.y
    if (no.dups && any((mi <- match(nm.by, names(y), 0)) > 0) && nzchar(suffixes[2])) 
      names(y)[mi] <- paste0(names(y)[mi], suffixes[2])
    nm <- c(names(x), names(y))
    if (any(d <- duplicated(nm))) 
      if (sum(d) > 1) 
        warning("column names ", paste(sQuote(nm[d]), collapse = ", "), " are duplicated in the result", domain = NA)
    else warning("column name ", sQuote(nm[d]), " is duplicated in the result", domain = NA)
    res <- cbind(x, y)
    if (sort) 
      res <- res[if (all.x || all.y) {
        x <- x[, seq_len(l.b), drop = FALSE]
        attributes(x) <- NULL
        do.call("order", x)
      }
      else sort.list(bx[m$xi]), , drop = FALSE]
  }
  attr(res, "row.names") <- .set_row_names(nrow(res))
  res
}, function (x, y, by = intersect(names(x), names(y)), by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all, sort = TRUE, suffixes = c(".x", ".y"), no.dups = TRUE, incomparables = NULL, ...) 
{
  fix.by <- function(by, df) {
    if (is.null(by)) 
      by <- numeric()
    by <- as.vector(by)
    nc <- ncol(df)
    if (is.character(by)) {
      poss <- c("row.names", names(df))
      if (any(bad <- !charmatch(by, poss, 0))) 
        stop(ngettext(sum(bad), "'by' must specify a uniquely valid column", "'by' must specify uniquely valid columns"), domain = NA)
      by <- match(by, poss) - 1
    }
    else if (is.numeric(by)) {
      if (any(by < 0) || any(by > nc)) 
        stop("'by' must match numbers of columns")
    }
    else if (is.logical(by)) {
      if (length(by) != nc) 
        stop("'by' must match number of columns")
      by <- seq_along(by)[by]
    }
    else stop("'by' must specify one or more columns as numbers, names or logical")
    if (any(bad <- is.na(by))) 
      stop(ngettext(sum(bad), "'by' must specify a uniquely valid column", "'by' must specify uniquely valid columns"), domain = NA)
    unique(by)
  }
  nx <- nrow(x <- as.data.frame(x))
  ny <- nrow(y <- as.data.frame(y))
  if (nx >= 2^31 || ny >= 2^31) 
    stop("long vectors are not supported")
  by.x <- fix.by(by.x, x)
  by.y <- fix.by(by.y, y)
  if ((l.b <- length(by.x)) != length(by.y)) 
    stop("'by.x' and 'by.y' specify different numbers of columns")
  if (l.b == 0) {
    nm <- nm.x <- names(x)
    nm.y <- names(y)
    has.common.nms <- any(cnm <- nm.x %in% nm.y)
    if (has.common.nms) {
      names(x)[cnm] <- paste0(nm.x[cnm], suffixes[1])
      cnm <- nm.y %in% nm
      names(y)[cnm] <- paste0(nm.y[cnm], suffixes[2])
    }
    if (nx == 0 || ny == 0) {
      res <- cbind(x[FALSE, ], y[FALSE, ])
    }
    else {
      ij <- expand.grid(seq_len(nx), seq_len(ny))
      res <- cbind(x[ij[, 1], , drop = FALSE], y[ij[, 2], , drop = FALSE])
    }
  }
  else {
    if (any(by.x == 0)) {
      x <- cbind(Row.names = I(row.names(x)), x)
      by.x <- by.x + 1
    }
    if (any(by.y == 0)) {
      y <- cbind(Row.names = I(row.names(y)), y)
      by.y <- by.y + 1
    }
    row.names(x) <- NULL
    row.names(y) <- NULL
    if (l.b == 1) {
      bx <- x[, by.x]
      if (is.factor(bx)) 
        bx <- as.character(bx)
      by <- y[, by.y]
      if (is.factor(by)) 
        by <- as.character(by)
    }
    else {
      if (!is.null(incomparables)) 
        stop("'incomparables' is supported only for merging on a single column")
      bx <- x[, by.x, drop = FALSE]
      by <- y[, by.y, drop = FALSE]
      names(bx) <- names(by) <- paste0("V", seq_len(ncol(bx)))
      bz <- do.call("paste", c(rbind(bx, by), sep = "\r"))
      bx <- bz[seq_len(nx)]
      by <- bz[nx + seq_len(ny)]
    }
    comm <- match(bx, by, 0)
    bxy <- bx[comm > 0]
    xinds <- match(bx, bxy, 0, incomparables)
    yinds <- match(by, bxy, 0, incomparables)
    if (nx > 0 && ny > 0) 
      m <- .Internal(merge(xinds, yinds, all.x, all.y))
    else m <- list(xi = integer(), yi = integer(), x.alone = seq_len(nx), y.alone = seq_len(ny))
    nm <- nm.x <- names(x)[-by.x]
    nm.by <- names(x)[by.x]
    nm.y <- names(y)[-by.y]
    ncx <- ncol(x)
    if (all.x) 
      all.x <- (nxx <- length(m$x.alone)) > 0
    if (all.y) 
      all.y <- (nyy <- length(m$y.alone)) > 0
    lxy <- length(m$xi)
    has.common.nms <- any(cnm <- nm.x %in% nm.y)
    if (has.common.nms && nzchar(suffixes[1])) 
      nm.x[cnm] <- paste0(nm.x[cnm], suffixes[1])
    x <- x[c(m$xi, if (all.x) m$x.alone), c(by.x, seq_len(ncx)[-by.x]), drop = FALSE]
    names(x) <- c(nm.by, nm.x)
    if (all.y) {
      ya <- y[m$y.alone, by.y, drop = FALSE]
      names(ya) <- nm.by
      xa <- x[rep.int(NA, nyy), nm.x, drop = FALSE]
      names(xa) <- nm.x
      x <- rbind(x, cbind(ya, xa))
    }
    if (has.common.nms && nzchar(suffixes[2])) {
      cnm <- nm.y %in% nm
      nm.y[cnm] <- paste0(nm.y[cnm], suffixes[2])
    }
    y <- y[c(m$yi, if (all.x) rep.int(1, nxx), if (all.y) m$y.alone), -by.y, drop = FALSE]
    if (all.x) {
      zap <- (lxy + 1):(lxy + nxx)
      for (i in seq_along(y)) {
        if (is.matrix(y[[i]])) 
          y[[i]][zap, ] <- NA
        else is.na(y[[i]]) <- zap
      }
    }
    if (has.common.nms) 
      names(y) <- nm.y
    if (no.dups && any((mi <- match(nm.by, names(y), 0)) > 0) && nzchar(suffixes[2])) 
      names(y)[mi] <- paste0(names(y)[mi], suffixes[2])
    nm <- c(names(x), names(y))
    if (any(d <- duplicated(nm))) 
      if (sum(d) > 1) 
        warning("column names ", paste(sQuote(nm[d]), collapse = ", "), " are duplicated in the result", domain = NA)
    else warning("column name ", sQuote(nm[d]), " is duplicated in the result", domain = NA)
    res <- cbind(x, y)
    if (sort) 
      res <- res[if (all.x || all.y) {
        x <- x[, seq_len(l.b), drop = FALSE]
        attributes(x) <- NULL
        do.call("order", x)
      }
      else sort.list(bx[m$xi]), , drop = FALSE]
  }
  attr(res, "row.names") <- .set_row_names(nrow(res))
  res
})
c("package:base", "registered S3 method for merge from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
merge.default
list(`package:base` = function (x, y, ...) 
  merge(as.data.frame(x), as.data.frame(y), ...), function (x, y, ...) 
    merge(as.data.frame(x), as.data.frame(y), ...), function (x, y, ...) 
      merge(as.data.frame(x), as.data.frame(y), ...))
c("package:base", "registered S3 method for merge from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
message
list(`package:base` = function (..., domain = NULL, appendLF = TRUE) 
{
  cond <- if (...length() == 1 && inherits(..1, "condition")) {
    if (nargs() > 1) 
      warning("additional arguments ignored in message()")
    ..1
  }
  else {
    msg <- .makeMessage(..., domain = domain, appendLF = appendLF)
    call <- sys.call()
    simpleMessage(msg, call)
  }
  defaultHandler <- function(c) {
    cat(conditionMessage(c), file = stderr(), sep = "")
  }
  withRestarts({
    signalCondition(cond)
    defaultHandler(cond)
  }, muffleMessage = function() NULL)
  invisible()
}, function (..., domain = NULL, appendLF = TRUE) 
{
  cond <- if (...length() == 1 && inherits(..1, "condition")) {
    if (nargs() > 1) 
      warning("additional arguments ignored in message()")
    ..1
  }
  else {
    msg <- .makeMessage(..., domain = domain, appendLF = appendLF)
    call <- sys.call()
    simpleMessage(msg, call)
  }
  defaultHandler <- function(c) {
    cat(conditionMessage(c), file = stderr(), sep = "")
  }
  withRestarts({
    signalCondition(cond)
    defaultHandler(cond)
  }, muffleMessage = function() NULL)
  invisible()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
mget
list(`package:base` = function (x, envir = as.environment(-1), mode = "any", ifnotfound, inherits = FALSE) 
  .Internal(mget(x, envir, mode, if (missing(ifnotfound)) list(function(x) stop(gettextf("value for %s not found", sQuote(x)), call. = FALSE)) else ifnotfound, inherits)), function (x, envir = as.environment(-1), mode = "any", ifnotfound, inherits = FALSE) 
    .Internal(mget(x, envir, mode, if (missing(ifnotfound)) list(function(x) stop(gettextf("value for %s not found", sQuote(x)), call. = FALSE)) else ifnotfound, inherits)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
min
list(`package:base` = .Primitive("min"), .Primitive("min"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
missing
list(`package:base` = .Primitive("missing"), .Primitive("missing"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Mod
list(`package:base` = .Primitive("Mod"), .Primitive("Mod"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
mode
list(`package:base` = function (x) 
{
  if (is.expression(x)) 
    return("expression")
  if (is.call(x)) 
    return(switch(deparse(x[[1]])[1], `(` = "(", "call"))
  if (is.name(x)) 
    "name"
  else switch(tx <- typeof(x), double = , integer = "numeric", closure = , builtin = , special = "function", tx)
}, function (x) 
{
  if (is.expression(x)) 
    return("expression")
  if (is.call(x)) 
    return(switch(deparse(x[[1]])[1], `(` = "(", "call"))
  if (is.name(x)) 
    "name"
  else switch(tx <- typeof(x), double = , integer = "numeric", closure = , builtin = , special = "function", tx)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
mode<-
  list(`package:base` = function (x, value) 
  {
    if (storage.mode(x) == value) 
      return(x)
    if (is.factor(x)) 
      stop("invalid to change the storage mode of a factor")
    atr <- attributes(x)
    isSingle <- !is.null(attr(x, "Csingle"))
    setSingle <- value == "single"
    mde <- get(paste0("as.", value), mode = "function", envir = parent.frame())
    x <- mde(x)
    attributes(x) <- atr
    if (setSingle != isSingle) 
      attr(x, "Csingle") <- if (setSingle) 
        TRUE
    x
  }, function (x, value) 
  {
    if (storage.mode(x) == value) 
      return(x)
    if (is.factor(x)) 
      stop("invalid to change the storage mode of a factor")
    atr <- attributes(x)
    isSingle <- !is.null(attr(x, "Csingle"))
    setSingle <- value == "single"
    mde <- get(paste0("as.", value), mode = "function", envir = parent.frame())
    x <- mde(x)
    attributes(x) <- atr
    if (setSingle != isSingle) 
      attr(x, "Csingle") <- if (setSingle) 
        TRUE
    x
  })
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
month.abb
list(`package:base` = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"), c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
month.name
list(`package:base` = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"), c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
months
list(`package:base` = function (x, abbreviate) 
  UseMethod("months"), new("standardGeneric", .Data = function (x, abbreviate) 
    standardGeneric("months"), generic = "months", package = "base", group = list(), valueClass = character(0), signature = c("x", "abbreviate"), default = new("derivedDefaultMethod", .Data = function (x, abbreviate) 
      UseMethod("months"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "months"), skeleton = (new("derivedDefaultMethod", .Data = function (x, abbreviate) 
        UseMethod("months"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "months"))(x, abbreviate)), function (x, abbreviate) 
          UseMethod("months"))
c("package:base", "namespace:timeDate", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
months.Date
list(`package:base` = function (x, abbreviate = FALSE) 
  format(x, ifelse(abbreviate, "%b", "%B")), function (x, abbreviate = FALSE) 
    format(x, ifelse(abbreviate, "%b", "%B")), function (x, abbreviate = FALSE) 
      format(x, ifelse(abbreviate, "%b", "%B")))
c("package:base", "registered S3 method for months from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
months.POSIXt
list(`package:base` = function (x, abbreviate = FALSE) 
{
  format(x, ifelse(abbreviate, "%b", "%B"))
}, function (x, abbreviate = FALSE) 
{
  format(x, ifelse(abbreviate, "%b", "%B"))
}, function (x, abbreviate = FALSE) 
{
  format(x, ifelse(abbreviate, "%b", "%B"))
})
c("package:base", "registered S3 method for months from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
mostattributes<-
  list(`package:base` = function (x, value) 
  {
    if (length(value)) {
      if (!is.list(value)) 
        stop("'value' must be a list")
      if (h.nam <- !is.na(inam <- match("names", names(value)))) {
        n1 <- value[[inam]]
        value <- value[-inam]
      }
      if (h.dim <- !is.na(idin <- match("dim", names(value)))) {
        d1 <- value[[idin]]
        value <- value[-idin]
      }
      if (h.dmn <- !is.na(idmn <- match("dimnames", names(value)))) {
        dn1 <- value[[idmn]]
        value <- value[-idmn]
      }
      attributes(x) <- value
      dm <- attr(x, "dim")
      L <- length(if (is.list(x)) unclass(x) else x)
      if (h.dim && L == prod(d1)) 
        attr(x, "dim") <- dm <- d1
      if (h.dmn && !is.null(dm)) {
        ddn <- vapply(dn1, length, 1, USE.NAMES = FALSE)
        if (all((dm == ddn)[ddn > 0])) 
          attr(x, "dimnames") <- dn1
      }
      if (h.nam && is.null(dm) && L == length(n1)) 
        attr(x, "names") <- n1
    }
    x
  }, function (x, value) 
  {
    if (length(value)) {
      if (!is.list(value)) 
        stop("'value' must be a list")
      if (h.nam <- !is.na(inam <- match("names", names(value)))) {
        n1 <- value[[inam]]
        value <- value[-inam]
      }
      if (h.dim <- !is.na(idin <- match("dim", names(value)))) {
        d1 <- value[[idin]]
        value <- value[-idin]
      }
      if (h.dmn <- !is.na(idmn <- match("dimnames", names(value)))) {
        dn1 <- value[[idmn]]
        value <- value[-idmn]
      }
      attributes(x) <- value
      dm <- attr(x, "dim")
      L <- length(if (is.list(x)) unclass(x) else x)
      if (h.dim && L == prod(d1)) 
        attr(x, "dim") <- dm <- d1
      if (h.dmn && !is.null(dm)) {
        ddn <- vapply(dn1, length, 1, USE.NAMES = FALSE)
        if (all((dm == ddn)[ddn > 0])) 
          attr(x, "dimnames") <- dn1
      }
      if (h.nam && is.null(dm) && L == length(n1)) 
        attr(x, "names") <- n1
    }
    x
  })
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
mtfrm
list(`package:base` = function (x) 
  UseMethod("mtfrm"), function (x) 
    UseMethod("mtfrm"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
mtfrm.default
list(`package:base` = function (x) 
{
  if (length(y <- as.vector(x)) != length(x)) 
    stop("cannot mtfrm")
  y
}, function (x) 
{
  if (length(y <- as.vector(x)) != length(x)) 
    stop("cannot mtfrm")
  y
}, function (x) 
{
  if (length(y <- as.vector(x)) != length(x)) 
    stop("cannot mtfrm")
  y
})
c("package:base", "registered S3 method for mtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
names
list(`package:base` = .Primitive("names"), .Primitive("names"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
names.POSIXlt
list(`package:base` = function (x) 
  names(x$year), function (x) 
    names(x$year), function (x) 
      names(x$year))
c("package:base", "registered S3 method for names from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
names<-
  list(`package:base` = .Primitive("names<-"), .Primitive("names<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
names<-.POSIXlt
list(`package:base` = function (x, value) 
{
  names(x$year) <- value
  x
}, function (x, value) 
{
  names(x$year) <- value
  x
}, function (x, value) 
{
  names(x$year) <- value
  x
})
c("package:base", "registered S3 method for names<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
namespaceExport
list(`package:base` = function (ns, vars) 
{
  namespaceIsSealed <- function(ns) environmentIsLocked(ns)
  if (namespaceIsSealed(ns)) 
    stop("cannot add to exports of a sealed namespace")
  ns <- asNamespace(ns, base.OK = FALSE)
  if (length(vars)) {
    addExports <- function(ns, new) {
      exports <- .getNamespaceInfo(ns, "exports")
      expnames <- names(new)
      objs <- names(exports)
      ex <- expnames %in% objs
      if (any(ex)) 
        warning(sprintf(ngettext(sum(ex), "previous export '%s' is being replaced", "previous exports '%s' are being replaced"), paste(sQuote(expnames[ex]), collapse = ", ")), call. = FALSE, domain = NA)
      list2env(as.list(new), exports)
    }
    makeImportExportNames <- function(spec) {
      old <- as.character(spec)
      new <- names(spec)
      if (is.null(new)) 
        new <- old
      else {
        change <- !nzchar(new)
        new[change] <- old[change]
      }
      names(old) <- new
      old
    }
    new <- makeImportExportNames(unique(vars))
    undef <- new[!new %in% names(ns)]
    undef <- undef[!vapply(undef, exists, NA, envir = ns)]
    if (length(undef)) {
      undef <- do.call("paste", as.list(c(undef, sep = ", ")))
      undef <- gsub("^\\.__C__", "class ", undef)
      stop(gettextf("undefined exports: %s", undef), domain = NA)
    }
    if (.isMethodsDispatchOn()) 
      .mergeExportMethods(new, ns)
    addExports(ns, new)
  }
}, function (ns, vars) 
{
  namespaceIsSealed <- function(ns) environmentIsLocked(ns)
  if (namespaceIsSealed(ns)) 
    stop("cannot add to exports of a sealed namespace")
  ns <- asNamespace(ns, base.OK = FALSE)
  if (length(vars)) {
    addExports <- function(ns, new) {
      exports <- .getNamespaceInfo(ns, "exports")
      expnames <- names(new)
      objs <- names(exports)
      ex <- expnames %in% objs
      if (any(ex)) 
        warning(sprintf(ngettext(sum(ex), "previous export '%s' is being replaced", "previous exports '%s' are being replaced"), paste(sQuote(expnames[ex]), collapse = ", ")), call. = FALSE, domain = NA)
      list2env(as.list(new), exports)
    }
    makeImportExportNames <- function(spec) {
      old <- as.character(spec)
      new <- names(spec)
      if (is.null(new)) 
        new <- old
      else {
        change <- !nzchar(new)
        new[change] <- old[change]
      }
      names(old) <- new
      old
    }
    new <- makeImportExportNames(unique(vars))
    undef <- new[!new %in% names(ns)]
    undef <- undef[!vapply(undef, exists, NA, envir = ns)]
    if (length(undef)) {
      undef <- do.call("paste", as.list(c(undef, sep = ", ")))
      undef <- gsub("^\\.__C__", "class ", undef)
      stop(gettextf("undefined exports: %s", undef), domain = NA)
    }
    if (.isMethodsDispatchOn()) 
      .mergeExportMethods(new, ns)
    addExports(ns, new)
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
namespaceImport
list(`package:base` = function (self, ..., from = NULL, except = character(0)) 
  for (ns in list(...)) namespaceImportFrom(self, asNamespace(ns), from = from, except = except), function (self, ..., from = NULL, except = character(0)) 
    for (ns in list(...)) namespaceImportFrom(self, asNamespace(ns), from = from, except = except))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
namespaceImportClasses
list(`package:base` = function (self, ns, vars, from = NULL) 
{
  for (i in seq_along(vars)) vars[[i]] <- methods::classMetaName(vars[[i]])
  namespaceImportFrom(self, asNamespace(ns), vars, from = from)
}, function (self, ns, vars, from = NULL) 
{
  for (i in seq_along(vars)) vars[[i]] <- methods::classMetaName(vars[[i]])
  namespaceImportFrom(self, asNamespace(ns), vars, from = from)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
namespaceImportFrom
list(`package:base` = function (self, ns, vars, generics, packages, from = "non-package environment", except = character(0)) 
{
  addImports <- function(ns, from, what) {
    imp <- structure(list(what), names = getNamespaceName(from))
    imports <- getNamespaceImports(ns)
    setNamespaceInfo(ns, "imports", c(imports, imp))
  }
  namespaceIsSealed <- function(ns) environmentIsLocked(ns)
  makeImportExportNames <- function(spec) {
    old <- as.character(spec)
    new <- names(spec)
    if (is.null(new)) 
      new <- old
    else {
      change <- !nzchar(new)
      new[change] <- old[change]
    }
    names(old) <- new
    old
  }
  whichMethodMetaNames <- function(impvars) {
    if (!.isMethodsDispatchOn()) 
      return(numeric())
    seq_along(impvars)[startsWith(impvars, ".__T__")]
  }
  genericPackage <- function(f) {
    if (methods::is(f, "genericFunction")) 
      f@package
    else if (is.primitive(f)) 
      "base"
    else "<unknown>"
  }
  if (is.character(self)) 
    self <- getNamespace(self)
  ns <- asNamespace(ns)
  nsname <- getNamespaceName(ns)
  impvars <- if (missing(vars)) {
    stoplist <- c(".__NAMESPACE__.", ".__S3MethodsTable__.", ".packageName", ".First.lib", ".Last.lib", ".onLoad", ".onAttach", ".onDetach", ".conflicts.OK", ".noGenerics")
    vars <- getNamespaceExports(ns)
    vars <- vars[!vars %in% stoplist]
  }
  else vars
  impvars <- impvars[!impvars %in% except]
  impvars <- makeImportExportNames(impvars)
  impnames <- names(impvars)
  if (anyDuplicated(impnames)) {
    stop(gettextf("duplicate import names %s", paste(sQuote(impnames[duplicated(impnames)]), collapse = ", ")), domain = NA)
  }
  if (isNamespace(self)) {
    if (isBaseNamespace(self)) {
      impenv <- self
      msg <- gettext("replacing local value with import %s when loading %s")
      register <- FALSE
    }
    else {
      if (namespaceIsSealed(self)) 
        stop("cannot import into a sealed namespace")
      impenv <- parent.env(self)
      msg <- gettext("replacing previous import by %s when loading %s")
      register <- TRUE
    }
  }
  else if (is.environment(self)) {
    impenv <- self
    msg <- gettext("replacing local value with import %s when loading %s")
    register <- FALSE
  }
  else stop("invalid import target")
  which <- whichMethodMetaNames(impvars)
  if (length(which)) {
    delete <- integer()
    for (i in which) {
      methodsTable <- .mergeImportMethods(impenv, ns, impvars[[i]])
      if (is.null(methodsTable)) {
      }
      else {
        delete <- c(delete, i)
        if (!missing(generics)) {
          genName <- generics[[i]]
          fdef <- methods::getGeneric(genName, where = impenv, package = packages[[i]])
          if (is.null(fdef)) 
            warning(gettextf("found methods to import for function %s but not the generic itself", sQuote(genName)), call. = FALSE, domain = NA)
          else methods:::.updateMethodsInTable(fdef, ns, TRUE)
        }
      }
    }
    if (length(delete)) {
      impvars <- impvars[-delete]
      impnames <- impnames[-delete]
    }
  }
  for (n in impnames) if (!is.null(genImp <- impenv[[n]])) {
    if (.isMethodsDispatchOn() && methods::isGeneric(n, ns)) {
      genNs <- genericPackage(get(n, envir = ns))
      if (identical(genNs, genericPackage(genImp))) 
        next
      genImpenv <- environmentName(environment(genImp))
      if (!identical(genNs, genImpenv) || methods::isGeneric(n, impenv)) {
      }
      else next
    }
    if (identical(genImp, get(n, ns))) 
      next
    if (isNamespace(self) && !isBaseNamespace(self)) {
      current <- getNamespaceInfo(self, "imports")
      poss <- lapply(rev(current), `[`, n)
      poss <- poss[!sapply(poss, is.na)]
      if (length(poss) >= 1) {
        prev <- names(poss)[1]
        warning(sprintf(gettext("replacing previous import %s by %s when loading %s"), sQuote(paste(prev, n, sep = "::")), sQuote(paste(nsname, n, sep = "::")), sQuote(from)), call. = FALSE, domain = NA)
      }
      else warning(sprintf(msg, sQuote(paste(nsname, n, sep = "::")), sQuote(from)), call. = FALSE, domain = NA)
    }
    else {
      warning(sprintf(msg, sQuote(paste(nsname, n, sep = "::")), sQuote(from)), call. = FALSE, domain = NA)
    }
  }
  importIntoEnv(impenv, impnames, ns, impvars)
  if (register) 
    addImports(self, ns, if (missing(vars)) 
      TRUE
      else impvars)
}, function (self, ns, vars, generics, packages, from = "non-package environment", except = character(0)) 
{
  addImports <- function(ns, from, what) {
    imp <- structure(list(what), names = getNamespaceName(from))
    imports <- getNamespaceImports(ns)
    setNamespaceInfo(ns, "imports", c(imports, imp))
  }
  namespaceIsSealed <- function(ns) environmentIsLocked(ns)
  makeImportExportNames <- function(spec) {
    old <- as.character(spec)
    new <- names(spec)
    if (is.null(new)) 
      new <- old
    else {
      change <- !nzchar(new)
      new[change] <- old[change]
    }
    names(old) <- new
    old
  }
  whichMethodMetaNames <- function(impvars) {
    if (!.isMethodsDispatchOn()) 
      return(numeric())
    seq_along(impvars)[startsWith(impvars, ".__T__")]
  }
  genericPackage <- function(f) {
    if (methods::is(f, "genericFunction")) 
      f@package
    else if (is.primitive(f)) 
      "base"
    else "<unknown>"
  }
  if (is.character(self)) 
    self <- getNamespace(self)
  ns <- asNamespace(ns)
  nsname <- getNamespaceName(ns)
  impvars <- if (missing(vars)) {
    stoplist <- c(".__NAMESPACE__.", ".__S3MethodsTable__.", ".packageName", ".First.lib", ".Last.lib", ".onLoad", ".onAttach", ".onDetach", ".conflicts.OK", ".noGenerics")
    vars <- getNamespaceExports(ns)
    vars <- vars[!vars %in% stoplist]
  }
  else vars
  impvars <- impvars[!impvars %in% except]
  impvars <- makeImportExportNames(impvars)
  impnames <- names(impvars)
  if (anyDuplicated(impnames)) {
    stop(gettextf("duplicate import names %s", paste(sQuote(impnames[duplicated(impnames)]), collapse = ", ")), domain = NA)
  }
  if (isNamespace(self)) {
    if (isBaseNamespace(self)) {
      impenv <- self
      msg <- gettext("replacing local value with import %s when loading %s")
      register <- FALSE
    }
    else {
      if (namespaceIsSealed(self)) 
        stop("cannot import into a sealed namespace")
      impenv <- parent.env(self)
      msg <- gettext("replacing previous import by %s when loading %s")
      register <- TRUE
    }
  }
  else if (is.environment(self)) {
    impenv <- self
    msg <- gettext("replacing local value with import %s when loading %s")
    register <- FALSE
  }
  else stop("invalid import target")
  which <- whichMethodMetaNames(impvars)
  if (length(which)) {
    delete <- integer()
    for (i in which) {
      methodsTable <- .mergeImportMethods(impenv, ns, impvars[[i]])
      if (is.null(methodsTable)) {
      }
      else {
        delete <- c(delete, i)
        if (!missing(generics)) {
          genName <- generics[[i]]
          fdef <- methods::getGeneric(genName, where = impenv, package = packages[[i]])
          if (is.null(fdef)) 
            warning(gettextf("found methods to import for function %s but not the generic itself", sQuote(genName)), call. = FALSE, domain = NA)
          else methods:::.updateMethodsInTable(fdef, ns, TRUE)
        }
      }
    }
    if (length(delete)) {
      impvars <- impvars[-delete]
      impnames <- impnames[-delete]
    }
  }
  for (n in impnames) if (!is.null(genImp <- impenv[[n]])) {
    if (.isMethodsDispatchOn() && methods::isGeneric(n, ns)) {
      genNs <- genericPackage(get(n, envir = ns))
      if (identical(genNs, genericPackage(genImp))) 
        next
      genImpenv <- environmentName(environment(genImp))
      if (!identical(genNs, genImpenv) || methods::isGeneric(n, impenv)) {
      }
      else next
    }
    if (identical(genImp, get(n, ns))) 
      next
    if (isNamespace(self) && !isBaseNamespace(self)) {
      current <- getNamespaceInfo(self, "imports")
      poss <- lapply(rev(current), `[`, n)
      poss <- poss[!sapply(poss, is.na)]
      if (length(poss) >= 1) {
        prev <- names(poss)[1]
        warning(sprintf(gettext("replacing previous import %s by %s when loading %s"), sQuote(paste(prev, n, sep = "::")), sQuote(paste(nsname, n, sep = "::")), sQuote(from)), call. = FALSE, domain = NA)
      }
      else warning(sprintf(msg, sQuote(paste(nsname, n, sep = "::")), sQuote(from)), call. = FALSE, domain = NA)
    }
    else {
      warning(sprintf(msg, sQuote(paste(nsname, n, sep = "::")), sQuote(from)), call. = FALSE, domain = NA)
    }
  }
  importIntoEnv(impenv, impnames, ns, impvars)
  if (register) 
    addImports(self, ns, if (missing(vars)) 
      TRUE
      else impvars)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
namespaceImportMethods
list(`package:base` = function (self, ns, vars, from = NULL) 
{
  allVars <- character()
  generics <- character()
  packages <- character()
  allFuns <- methods:::.getGenerics(ns)
  allPackages <- attr(allFuns, "package")
  pkg <- methods::getPackageName(ns)
  found <- vars %in% allFuns
  if (!all(found)) {
    message(sprintf(ngettext(sum(!found), "No methods found in package %s for request: %s when loading %s", "No methods found in package %s for requests: %s when loading %s"), sQuote(pkg), paste(sQuote(vars[!found]), collapse = ", "), sQuote(getNamespaceName(self))), domain = NA)
    vars <- vars[found]
  }
  found <- vars %in% allFuns
  if (!all(found)) 
    stop(sprintf(ngettext(sum(!found), "requested method not found in environment/package %s: %s when loading %s", "requested methods not found in environment/package %s: %s when loading %s"), sQuote(pkg), paste(sQuote(vars[!found]), collapse = ", "), sQuote(getNamespaceName(self))), call. = FALSE, domain = NA)
  for (i in seq_along(allFuns)) {
    g <- allFuns[[i]]
    p <- allPackages[[i]]
    if (exists(g, envir = self, inherits = FALSE) || g %in% vars) {
      tbl <- methods:::.TableMetaName(g, p)
      if (is.null(.mergeImportMethods(self, ns, tbl))) {
        allVars <- c(allVars, tbl)
        generics <- c(generics, g)
        packages <- c(packages, p)
      }
    }
    if (g %in% vars && !exists(g, envir = self, inherits = FALSE)) {
      if (!is.null(f <- get0(g, envir = ns)) && methods::is(f, "genericFunction")) {
        allVars <- c(allVars, g)
        generics <- c(generics, g)
        packages <- c(packages, p)
      }
      else if (g %in% c("as.vector", "is.unsorted", "unlist")) {
      }
      else {
        fun <- methods::getFunction(g, mustFind = FALSE, where = self)
        if (is.primitive(fun) || methods::is(fun, "genericFunction")) {
        }
        else warning(gettextf("No generic function %s found corresponding to requested imported methods from package %s when loading %s (malformed exports?)", sQuote(g), sQuote(pkg), sQuote(from)), domain = NA, call. = FALSE)
      }
    }
  }
  namespaceImportFrom(self, asNamespace(ns), allVars, generics, packages, from = from)
}, function (self, ns, vars, from = NULL) 
{
  allVars <- character()
  generics <- character()
  packages <- character()
  allFuns <- methods:::.getGenerics(ns)
  allPackages <- attr(allFuns, "package")
  pkg <- methods::getPackageName(ns)
  found <- vars %in% allFuns
  if (!all(found)) {
    message(sprintf(ngettext(sum(!found), "No methods found in package %s for request: %s when loading %s", "No methods found in package %s for requests: %s when loading %s"), sQuote(pkg), paste(sQuote(vars[!found]), collapse = ", "), sQuote(getNamespaceName(self))), domain = NA)
    vars <- vars[found]
  }
  found <- vars %in% allFuns
  if (!all(found)) 
    stop(sprintf(ngettext(sum(!found), "requested method not found in environment/package %s: %s when loading %s", "requested methods not found in environment/package %s: %s when loading %s"), sQuote(pkg), paste(sQuote(vars[!found]), collapse = ", "), sQuote(getNamespaceName(self))), call. = FALSE, domain = NA)
  for (i in seq_along(allFuns)) {
    g <- allFuns[[i]]
    p <- allPackages[[i]]
    if (exists(g, envir = self, inherits = FALSE) || g %in% vars) {
      tbl <- methods:::.TableMetaName(g, p)
      if (is.null(.mergeImportMethods(self, ns, tbl))) {
        allVars <- c(allVars, tbl)
        generics <- c(generics, g)
        packages <- c(packages, p)
      }
    }
    if (g %in% vars && !exists(g, envir = self, inherits = FALSE)) {
      if (!is.null(f <- get0(g, envir = ns)) && methods::is(f, "genericFunction")) {
        allVars <- c(allVars, g)
        generics <- c(generics, g)
        packages <- c(packages, p)
      }
      else if (g %in% c("as.vector", "is.unsorted", "unlist")) {
      }
      else {
        fun <- methods::getFunction(g, mustFind = FALSE, where = self)
        if (is.primitive(fun) || methods::is(fun, "genericFunction")) {
        }
        else warning(gettextf("No generic function %s found corresponding to requested imported methods from package %s when loading %s (malformed exports?)", sQuote(g), sQuote(pkg), sQuote(from)), domain = NA, call. = FALSE)
      }
    }
  }
  namespaceImportFrom(self, asNamespace(ns), allVars, generics, packages, from = from)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
nargs
list(`package:base` = .Primitive("nargs"), .Primitive("nargs"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
nchar
list(`package:base` = function (x, type = "chars", allowNA = FALSE, keepNA = NA) 
  .Internal(nchar(x, type, allowNA, keepNA)), function (x, type = "chars", allowNA = FALSE, keepNA = NA) 
    .Internal(nchar(x, type, allowNA, keepNA)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
ncol
list(`package:base` = function (x) 
  dim(x)[2], function (x) 
    dim(x)[2])
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
NCOL
list(`package:base` = function (x) 
  if (length(d <- dim(x)) > 1) d[2] else 1, NULL, function (x) 
    if (length(d <- dim(x)) > 1) d[2] else 1)
c("package:base", "namespace:data.table", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
Negate
list(`package:base` = function (f) 
{
  f <- match.fun(f)
  function(...) !f(...)
}, function (f) 
{
  f <- match.fun(f)
  function(...) !f(...)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
new.env
list(`package:base` = function (hash = TRUE, parent = parent.frame(), size = 29) 
  .Internal(new.env(hash, parent, size)), function (hash = TRUE, parent = parent.frame(), size = 29) 
    .Internal(new.env(hash, parent, size)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
next
list(`package:base` = .Primitive("next"), .Primitive("next"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
NextMethod
list(`package:base` = function (generic = NULL, object = NULL, ...) 
  .Internal(NextMethod(generic, object, ...)), function (generic = NULL, object = NULL, ...) 
    .Internal(NextMethod(generic, object, ...)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
ngettext
list(`package:base` = function (n, msg1, msg2, domain = NULL) 
  .Internal(ngettext(n, msg1, msg2, domain)), function (n, msg1, msg2, domain = NULL) 
    .Internal(ngettext(n, msg1, msg2, domain)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
nlevels
list(`package:base` = function (x) 
  length(levels(x)), function (x) 
  {
    n <- attr(x, "n")
    if (!is.null(n)) 
      n
    else max(x)
  }, function (x) 
    length(levels(x)))
c("package:base", "namespace:plyr", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
noquote
list(`package:base` = function (obj, right = FALSE) 
{
  if (!inherits(obj, "noquote")) 
    class(obj) <- c(attr(obj, "class"), if (right) c(right = "noquote") else "noquote")
  obj
}, function (obj, right = FALSE) 
{
  if (!inherits(obj, "noquote")) 
    class(obj) <- c(attr(obj, "class"), if (right) c(right = "noquote") else "noquote")
  obj
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
norm
list(`package:base` = function (x, type = c("O", "I", "F", "M", "2")) 
{
  if (identical("2", type)) {
    if (anyNA(x)) 
      return(NA)
    svd(x, nu = 0, nv = 0)$d[1]
  }
  else .Internal(La_dlange(x, type))
}, new("standardGeneric", .Data = function (x, type, ...) 
  standardGeneric("norm"), generic = "norm", package = "base", group = list(), valueClass = character(0), signature = c("x", "type"), default = new("derivedDefaultMethod", .Data = function (x, type, ...) 
    base::norm(x, type, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "norm"), skeleton = (new("derivedDefaultMethod", .Data = function (x, type, ...) 
      base::norm(x, type, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "norm"))(x, type, ...)), function (x, type = c("O", "I", "F", "M", "2")) 
      {
        if (identical("2", type)) {
          if (anyNA(x)) 
            return(NA)
          svd(x, nu = 0, nv = 0)$d[1]
        }
        else .Internal(La_dlange(x, type))
      })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
normalizePath
list(`package:base` = function (path, winslash = "\\", mustWork = NA) 
  .Internal(normalizePath(path.expand(path), winslash, mustWork)), function (path, winslash = "\\", mustWork = NA) 
    .Internal(normalizePath(path.expand(path), winslash, mustWork)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
nrow
list(`package:base` = function (x) 
  dim(x)[1], function (x) 
    dim(x)[1])
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
NROW
list(`package:base` = function (x) 
  if (length(d <- dim(x))) d[1] else length(x), NULL, function (x) 
    if (length(d <- dim(x))) d[1] else length(x))
c("package:base", "namespace:data.table", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
nullfile
list(`package:base` = function () 
  if (.Platform$OS.type == "windows") "nul:" else "/dev/null", function () 
    if (.Platform$OS.type == "windows") "nul:" else "/dev/null")
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
numeric
list(`package:base` = function (length = 0) 
  .Internal(vector("double", length)), function (length = 0) 
    .Internal(vector("double", length)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
numeric_version
list(`package:base` = function (x, strict = TRUE) 
  .make_numeric_version(x, strict, .standard_regexps()$valid_numeric_version), function (x, strict = TRUE) 
    .make_numeric_version(x, strict, .standard_regexps()$valid_numeric_version))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
numToBits
list(`package:base` = function (x) 
  .Internal(numToBits(x)), function (x) 
    .Internal(numToBits(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
numToInts
list(`package:base` = function (x) 
  .Internal(numToInts(x)), function (x) 
    .Internal(numToInts(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
nzchar
list(`package:base` = .Primitive("nzchar"), .Primitive("nzchar"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
objects
list(`package:base` = function (name, pos = -1, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE) 
{
  if (!missing(name)) {
    pos <- tryCatch(name, error = function(e) e)
    if (inherits(pos, "error")) {
      name <- substitute(name)
      if (!is.character(name)) 
        name <- deparse(name)
      warning(gettextf("%s converted to character string", sQuote(name)), domain = NA)
      pos <- name
    }
  }
  all.names <- .Internal(ls(envir, all.names, sorted))
  if (!missing(pattern)) {
    if ((ll <- length(grep("[", pattern, fixed = TRUE))) && ll != length(grep("]", pattern, fixed = TRUE))) {
      if (pattern == "[") {
        pattern <- "\\["
        warning("replaced regular expression pattern '[' by  '\\\\['")
      }
      else if (length(grep("[^\\\\]\\[<-", pattern))) {
        pattern <- sub("\\[<-", "\\\\\\[<-", pattern)
        warning("replaced '[<-' by '\\\\[<-' in regular expression pattern")
      }
    }
    grep(pattern, all.names, value = TRUE)
  }
  else all.names
}, function (name, pos = -1, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE) 
{
  if (!missing(name)) {
    pos <- tryCatch(name, error = function(e) e)
    if (inherits(pos, "error")) {
      name <- substitute(name)
      if (!is.character(name)) 
        name <- deparse(name)
      warning(gettextf("%s converted to character string", sQuote(name)), domain = NA)
      pos <- name
    }
  }
  all.names <- .Internal(ls(envir, all.names, sorted))
  if (!missing(pattern)) {
    if ((ll <- length(grep("[", pattern, fixed = TRUE))) && ll != length(grep("]", pattern, fixed = TRUE))) {
      if (pattern == "[") {
        pattern <- "\\["
        warning("replaced regular expression pattern '[' by  '\\\\['")
      }
      else if (length(grep("[^\\\\]\\[<-", pattern))) {
        pattern <- sub("\\[<-", "\\\\\\[<-", pattern)
        warning("replaced '[<-' by '\\\\[<-' in regular expression pattern")
      }
    }
    grep(pattern, all.names, value = TRUE)
  }
  else all.names
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
oldClass
list(`package:base` = .Primitive("oldClass"), .Primitive("oldClass"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
oldClass<-
  list(`package:base` = .Primitive("oldClass<-"), .Primitive("oldClass<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
OlsonNames
list(`package:base` = function (tzdir = NULL) 
{
  if (is.null(tzdir)) {
    if (.Platform$OS.type == "windows") 
      tzdir <- Sys.getenv("TZDIR", file.path(R.home("share"), "zoneinfo"))
    else {
      if (Sys.getenv("TZDIR") == "internal") 
        tzdir <- file.path(R.home("share"), "zoneinfo")
      else if (grepl("darwin", R.Version()$os) && Sys.getenv("TZDIR") == "macOS") {
        tzdir <- "/var/db/timezone/zoneinfo"
      }
      else {
        tzdirs <- c(Sys.getenv("TZDIR"), file.path(R.home("share"), "zoneinfo"), "/usr/share/zoneinfo", "/share/zoneinfo", "/usr/share/lib/zoneinfo", "/usr/lib/zoneinfo", "/usr/local/etc/zoneinfo", "/etc/zoneinfo", "/usr/etc/zoneinfo")
        tzdirs <- tzdirs[file.exists(tzdirs)]
        if (!length(tzdirs)) {
          warning("no Olson database found")
          return(character())
        }
        else tzdir <- tzdirs[1]
      }
    }
  }
  else if (!dir.exists(tzdir)) 
    stop(sprintf("%s is not a directory", sQuote(tzdir)), domain = NA)
  x <- list.files(tzdir, recursive = TRUE)
  ver <- if (file.exists(vf <- file.path(tzdir, "VERSION"))) 
    readLines(vf, warn = FALSE)
  else if (file.exists(vf <- file.path(tzdir, "+VERSION"))) 
    readLines(vf, warn = FALSE)
  x <- setdiff(x, "VERSION")
  ans <- grep("^[ABCDEFGHIJKLMNOPQRSTUVWXYZ]", x, value = TRUE)
  if (!is.null(ver)) 
    attr(ans, "Version") <- ver
  ans
}, function (tzdir = NULL) 
{
  if (is.null(tzdir)) {
    if (.Platform$OS.type == "windows") 
      tzdir <- Sys.getenv("TZDIR", file.path(R.home("share"), "zoneinfo"))
    else {
      if (Sys.getenv("TZDIR") == "internal") 
        tzdir <- file.path(R.home("share"), "zoneinfo")
      else if (grepl("darwin", R.Version()$os) && Sys.getenv("TZDIR") == "macOS") {
        tzdir <- "/var/db/timezone/zoneinfo"
      }
      else {
        tzdirs <- c(Sys.getenv("TZDIR"), file.path(R.home("share"), "zoneinfo"), "/usr/share/zoneinfo", "/share/zoneinfo", "/usr/share/lib/zoneinfo", "/usr/lib/zoneinfo", "/usr/local/etc/zoneinfo", "/etc/zoneinfo", "/usr/etc/zoneinfo")
        tzdirs <- tzdirs[file.exists(tzdirs)]
        if (!length(tzdirs)) {
          warning("no Olson database found")
          return(character())
        }
        else tzdir <- tzdirs[1]
      }
    }
  }
  else if (!dir.exists(tzdir)) 
    stop(sprintf("%s is not a directory", sQuote(tzdir)), domain = NA)
  x <- list.files(tzdir, recursive = TRUE)
  ver <- if (file.exists(vf <- file.path(tzdir, "VERSION"))) 
    readLines(vf, warn = FALSE)
  else if (file.exists(vf <- file.path(tzdir, "+VERSION"))) 
    readLines(vf, warn = FALSE)
  x <- setdiff(x, "VERSION")
  ans <- grep("^[ABCDEFGHIJKLMNOPQRSTUVWXYZ]", x, value = TRUE)
  if (!is.null(ver)) 
    attr(ans, "Version") <- ver
  ans
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
on.exit
list(`package:base` = .Primitive("on.exit"), .Primitive("on.exit"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
open
list(`package:base` = function (con, ...) 
  UseMethod("open"), function (con, ...) 
    UseMethod("open"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
open.connection
list(`package:base` = function (con, open = "r", blocking = TRUE, ...) 
  .Internal(open(con, open, blocking)), function (con, open = "r", blocking = TRUE, ...) 
    .Internal(open(con, open, blocking)), function (con, open = "r", blocking = TRUE, ...) 
      .Internal(open(con, open, blocking)))
c("package:base", "registered S3 method for open from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
open.srcfile
list(`package:base` = function (con, line, ...) 
{
  srcfile <- con
  oldline <- srcfile$line
  if (!is.null(oldline) && oldline > line) 
    close(srcfile)
  conn <- srcfile$conn
  if (is.null(conn)) {
    if (!is.null(srcfile$wd)) {
      olddir <- setwd(srcfile$wd)
      on.exit(setwd(olddir))
    }
    timestamp <- file.mtime(srcfile$filename)
    if (!is.null(srcfile$timestamp) && !is.na(srcfile$timestamp) && (is.na(timestamp) || timestamp != srcfile$timestamp)) 
      warning(gettextf("Timestamp of %s has changed", sQuote(srcfile$filename)), call. = FALSE, domain = NA)
    if (is.null(srcfile$encoding)) 
      encoding <- getOption("encoding")
    else encoding <- srcfile$encoding
    srcfile$conn <- conn <- file(srcfile$filename, open = "rt", encoding = encoding)
    srcfile$line <- 1
    oldline <- 1
  }
  else if (!isOpen(conn)) {
    open(conn, open = "rt")
    srcfile$line <- 1
    oldline <- 1
  }
  if (oldline < line) {
    readLines(conn, line - oldline, warn = FALSE)
    srcfile$line <- line
  }
  invisible(conn)
}, function (con, line, ...) 
{
  srcfile <- con
  oldline <- srcfile$line
  if (!is.null(oldline) && oldline > line) 
    close(srcfile)
  conn <- srcfile$conn
  if (is.null(conn)) {
    if (!is.null(srcfile$wd)) {
      olddir <- setwd(srcfile$wd)
      on.exit(setwd(olddir))
    }
    timestamp <- file.mtime(srcfile$filename)
    if (!is.null(srcfile$timestamp) && !is.na(srcfile$timestamp) && (is.na(timestamp) || timestamp != srcfile$timestamp)) 
      warning(gettextf("Timestamp of %s has changed", sQuote(srcfile$filename)), call. = FALSE, domain = NA)
    if (is.null(srcfile$encoding)) 
      encoding <- getOption("encoding")
    else encoding <- srcfile$encoding
    srcfile$conn <- conn <- file(srcfile$filename, open = "rt", encoding = encoding)
    srcfile$line <- 1
    oldline <- 1
  }
  else if (!isOpen(conn)) {
    open(conn, open = "rt")
    srcfile$line <- 1
    oldline <- 1
  }
  if (oldline < line) {
    readLines(conn, line - oldline, warn = FALSE)
    srcfile$line <- line
  }
  invisible(conn)
}, function (con, line, ...) 
{
  srcfile <- con
  oldline <- srcfile$line
  if (!is.null(oldline) && oldline > line) 
    close(srcfile)
  conn <- srcfile$conn
  if (is.null(conn)) {
    if (!is.null(srcfile$wd)) {
      olddir <- setwd(srcfile$wd)
      on.exit(setwd(olddir))
    }
    timestamp <- file.mtime(srcfile$filename)
    if (!is.null(srcfile$timestamp) && !is.na(srcfile$timestamp) && (is.na(timestamp) || timestamp != srcfile$timestamp)) 
      warning(gettextf("Timestamp of %s has changed", sQuote(srcfile$filename)), call. = FALSE, domain = NA)
    if (is.null(srcfile$encoding)) 
      encoding <- getOption("encoding")
    else encoding <- srcfile$encoding
    srcfile$conn <- conn <- file(srcfile$filename, open = "rt", encoding = encoding)
    srcfile$line <- 1
    oldline <- 1
  }
  else if (!isOpen(conn)) {
    open(conn, open = "rt")
    srcfile$line <- 1
    oldline <- 1
  }
  if (oldline < line) {
    readLines(conn, line - oldline, warn = FALSE)
    srcfile$line <- line
  }
  invisible(conn)
})
c("package:base", "registered S3 method for open from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
open.srcfilealias
list(`package:base` = function (con, line, ...) 
  open(con$original, line, ...), function (con, line, ...) 
    open(con$original, line, ...), function (con, line, ...) 
      open(con$original, line, ...))
c("package:base", "registered S3 method for open from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
open.srcfilecopy
list(`package:base` = function (con, line, ...) 
{
  srcfile <- con
  oldline <- srcfile$line
  if (!is.null(oldline) && oldline > line) 
    close(srcfile)
  conn <- srcfile$conn
  if (is.null(conn)) {
    srcfile$conn <- conn <- textConnection(srcfile$lines, open = "r")
    srcfile$line <- 1
    oldline <- 1
  }
  else if (!isOpen(conn)) {
    open(conn, open = "r")
    srcfile$line <- 1
    oldline <- 1
  }
  if (oldline < line) {
    readLines(conn, line - oldline, warn = FALSE)
    srcfile$line <- line
  }
  invisible(conn)
}, function (con, line, ...) 
{
  srcfile <- con
  oldline <- srcfile$line
  if (!is.null(oldline) && oldline > line) 
    close(srcfile)
  conn <- srcfile$conn
  if (is.null(conn)) {
    srcfile$conn <- conn <- textConnection(srcfile$lines, open = "r")
    srcfile$line <- 1
    oldline <- 1
  }
  else if (!isOpen(conn)) {
    open(conn, open = "r")
    srcfile$line <- 1
    oldline <- 1
  }
  if (oldline < line) {
    readLines(conn, line - oldline, warn = FALSE)
    srcfile$line <- line
  }
  invisible(conn)
}, function (con, line, ...) 
{
  srcfile <- con
  oldline <- srcfile$line
  if (!is.null(oldline) && oldline > line) 
    close(srcfile)
  conn <- srcfile$conn
  if (is.null(conn)) {
    srcfile$conn <- conn <- textConnection(srcfile$lines, open = "r")
    srcfile$line <- 1
    oldline <- 1
  }
  else if (!isOpen(conn)) {
    open(conn, open = "r")
    srcfile$line <- 1
    oldline <- 1
  }
  if (oldline < line) {
    readLines(conn, line - oldline, warn = FALSE)
    srcfile$line <- line
  }
  invisible(conn)
})
c("package:base", "registered S3 method for open from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Ops.data.frame
list(`package:base` = function (e1, e2 = NULL) 
{
  unary <- nargs() == 1
  lclass <- nzchar(.Method[1])
  rclass <- !unary && (nzchar(.Method[2]))
  value <- list()
  rn <- NULL
  FUN <- get(.Generic, envir = parent.frame(), mode = "function")
  f <- if (unary) 
    quote(FUN(left))
  else quote(FUN(left, right))
  lscalar <- rscalar <- FALSE
  if (lclass && rclass) {
    nr <- .row_names_info(e1, 2)
    if (.row_names_info(e1) > 0) 
      rn <- attr(e1, "row.names")
    cn <- names(e1)
    if (any(dim(e2) != dim(e1))) 
      stop(gettextf("%s only defined for equally-sized data frames", sQuote(.Generic)), domain = NA)
  }
  else if (lclass) {
    nr <- .row_names_info(e1, 2)
    if (.row_names_info(e1) > 0) 
      rn <- attr(e1, "row.names")
    cn <- names(e1)
    rscalar <- length(e2) <= 1
    if (is.list(e2)) {
      if (rscalar) 
        e2 <- e2[[1]]
      else if (length(e2) != ncol(e1)) 
        stop(gettextf("list of length %d not meaningful", length(e2)), domain = NA)
    }
    else {
      if (!rscalar) 
        e2 <- split(rep_len(as.vector(e2), prod(dim(e1))), rep.int(seq_len(ncol(e1)), rep.int(nrow(e1), ncol(e1))))
    }
  }
  else {
    nr <- .row_names_info(e2, 2)
    if (.row_names_info(e2) > 0) 
      rn <- attr(e2, "row.names")
    cn <- names(e2)
    lscalar <- length(e1) <= 1
    if (is.list(e1)) {
      if (lscalar) 
        e1 <- e1[[1]]
      else if (length(e1) != ncol(e2)) 
        stop(gettextf("list of length %d not meaningful", length(e1)), domain = NA)
    }
    else {
      if (!lscalar) 
        e1 <- split(rep_len(as.vector(e1), prod(dim(e2))), rep.int(seq_len(ncol(e2)), rep.int(nrow(e2), ncol(e2))))
    }
  }
  for (j in seq_along(cn)) {
    left <- if (!lscalar) 
      e1[[j]]
    else e1
    right <- if (!rscalar) 
      e2[[j]]
    else e2
    value[[j]] <- eval(f)
  }
  if (.Generic %in% c("+", "-", "*", "^", "%%", "%/%", "/")) {
    if (length(value)) {
      names(value) <- cn
      data.frame(value, row.names = rn, check.names = FALSE)
    }
    else data.frame(row.names = rn, check.names = FALSE)
  }
  else {
    value <- unlist(value, recursive = FALSE, use.names = FALSE)
    if (!length(value)) 
      matrix(logical(), nrow = nr, ncol = length(cn), dimnames = list(rn, cn))
    else matrix(value, nrow = nr, dimnames = list(rn, cn))
  }
}, function (e1, e2 = NULL) 
{
  unary <- nargs() == 1
  lclass <- nzchar(.Method[1])
  rclass <- !unary && (nzchar(.Method[2]))
  value <- list()
  rn <- NULL
  FUN <- get(.Generic, envir = parent.frame(), mode = "function")
  f <- if (unary) 
    quote(FUN(left))
  else quote(FUN(left, right))
  lscalar <- rscalar <- FALSE
  if (lclass && rclass) {
    nr <- .row_names_info(e1, 2)
    if (.row_names_info(e1) > 0) 
      rn <- attr(e1, "row.names")
    cn <- names(e1)
    if (any(dim(e2) != dim(e1))) 
      stop(gettextf("%s only defined for equally-sized data frames", sQuote(.Generic)), domain = NA)
  }
  else if (lclass) {
    nr <- .row_names_info(e1, 2)
    if (.row_names_info(e1) > 0) 
      rn <- attr(e1, "row.names")
    cn <- names(e1)
    rscalar <- length(e2) <= 1
    if (is.list(e2)) {
      if (rscalar) 
        e2 <- e2[[1]]
      else if (length(e2) != ncol(e1)) 
        stop(gettextf("list of length %d not meaningful", length(e2)), domain = NA)
    }
    else {
      if (!rscalar) 
        e2 <- split(rep_len(as.vector(e2), prod(dim(e1))), rep.int(seq_len(ncol(e1)), rep.int(nrow(e1), ncol(e1))))
    }
  }
  else {
    nr <- .row_names_info(e2, 2)
    if (.row_names_info(e2) > 0) 
      rn <- attr(e2, "row.names")
    cn <- names(e2)
    lscalar <- length(e1) <= 1
    if (is.list(e1)) {
      if (lscalar) 
        e1 <- e1[[1]]
      else if (length(e1) != ncol(e2)) 
        stop(gettextf("list of length %d not meaningful", length(e1)), domain = NA)
    }
    else {
      if (!lscalar) 
        e1 <- split(rep_len(as.vector(e1), prod(dim(e2))), rep.int(seq_len(ncol(e2)), rep.int(nrow(e2), ncol(e2))))
    }
  }
  for (j in seq_along(cn)) {
    left <- if (!lscalar) 
      e1[[j]]
    else e1
    right <- if (!rscalar) 
      e2[[j]]
    else e2
    value[[j]] <- eval(f)
  }
  if (.Generic %in% c("+", "-", "*", "^", "%%", "%/%", "/")) {
    if (length(value)) {
      names(value) <- cn
      data.frame(value, row.names = rn, check.names = FALSE)
    }
    else data.frame(row.names = rn, check.names = FALSE)
  }
  else {
    value <- unlist(value, recursive = FALSE, use.names = FALSE)
    if (!length(value)) 
      matrix(logical(), nrow = nr, ncol = length(cn), dimnames = list(rn, cn))
    else matrix(value, nrow = nr, dimnames = list(rn, cn))
  }
}, function (e1, e2 = NULL) 
{
  unary <- nargs() == 1
  lclass <- nzchar(.Method[1])
  rclass <- !unary && (nzchar(.Method[2]))
  value <- list()
  rn <- NULL
  FUN <- get(.Generic, envir = parent.frame(), mode = "function")
  f <- if (unary) 
    quote(FUN(left))
  else quote(FUN(left, right))
  lscalar <- rscalar <- FALSE
  if (lclass && rclass) {
    nr <- .row_names_info(e1, 2)
    if (.row_names_info(e1) > 0) 
      rn <- attr(e1, "row.names")
    cn <- names(e1)
    if (any(dim(e2) != dim(e1))) 
      stop(gettextf("%s only defined for equally-sized data frames", sQuote(.Generic)), domain = NA)
  }
  else if (lclass) {
    nr <- .row_names_info(e1, 2)
    if (.row_names_info(e1) > 0) 
      rn <- attr(e1, "row.names")
    cn <- names(e1)
    rscalar <- length(e2) <= 1
    if (is.list(e2)) {
      if (rscalar) 
        e2 <- e2[[1]]
      else if (length(e2) != ncol(e1)) 
        stop(gettextf("list of length %d not meaningful", length(e2)), domain = NA)
    }
    else {
      if (!rscalar) 
        e2 <- split(rep_len(as.vector(e2), prod(dim(e1))), rep.int(seq_len(ncol(e1)), rep.int(nrow(e1), ncol(e1))))
    }
  }
  else {
    nr <- .row_names_info(e2, 2)
    if (.row_names_info(e2) > 0) 
      rn <- attr(e2, "row.names")
    cn <- names(e2)
    lscalar <- length(e1) <= 1
    if (is.list(e1)) {
      if (lscalar) 
        e1 <- e1[[1]]
      else if (length(e1) != ncol(e2)) 
        stop(gettextf("list of length %d not meaningful", length(e1)), domain = NA)
    }
    else {
      if (!lscalar) 
        e1 <- split(rep_len(as.vector(e1), prod(dim(e2))), rep.int(seq_len(ncol(e2)), rep.int(nrow(e2), ncol(e2))))
    }
  }
  for (j in seq_along(cn)) {
    left <- if (!lscalar) 
      e1[[j]]
    else e1
    right <- if (!rscalar) 
      e2[[j]]
    else e2
    value[[j]] <- eval(f)
  }
  if (.Generic %in% c("+", "-", "*", "^", "%%", "%/%", "/")) {
    if (length(value)) {
      names(value) <- cn
      data.frame(value, row.names = rn, check.names = FALSE)
    }
    else data.frame(row.names = rn, check.names = FALSE)
  }
  else {
    value <- unlist(value, recursive = FALSE, use.names = FALSE)
    if (!length(value)) 
      matrix(logical(), nrow = nr, ncol = length(cn), dimnames = list(rn, cn))
    else matrix(value, nrow = nr, dimnames = list(rn, cn))
  }
})
c("package:base", "registered S3 method for Ops from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Ops.Date
list(`package:base` = function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary %s not defined for \"Date\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA)
  if (is.character(e1)) 
    e1 <- as.Date(e1)
  if (is.character(e2)) 
    e2 <- as.Date(e2)
  NextMethod(.Generic)
}, function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary %s not defined for \"Date\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA)
  if (is.character(e1)) 
    e1 <- as.Date(e1)
  if (is.character(e2)) 
    e2 <- as.Date(e2)
  NextMethod(.Generic)
}, function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary %s not defined for \"Date\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA)
  if (is.character(e1)) 
    e1 <- as.Date(e1)
  if (is.character(e2)) 
    e2 <- as.Date(e2)
  NextMethod(.Generic)
})
c("package:base", "registered S3 method for Ops from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Ops.difftime
list(`package:base` = function (e1, e2) 
{
  coerceTimeUnit <- function(x) {
    switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x)
  }
  if (nargs() == 1) {
    switch(.Generic, `+` = {
    }, `-` = {
      e1[] <- -unclass(e1)
    }, stop(gettextf("unary '%s' not defined for \"difftime\" objects", .Generic), domain = NA, call. = FALSE))
    return(e1)
  }
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (boolean) {
    if (inherits(e1, "difftime") && inherits(e2, "difftime")) {
      e1 <- coerceTimeUnit(e1)
      e2 <- coerceTimeUnit(e2)
    }
    NextMethod(.Generic)
  }
  else if (.Generic == "+" || .Generic == "-") {
    if (inherits(e1, "difftime") && !inherits(e2, "difftime")) 
      return(.difftime(NextMethod(.Generic), units = attr(e1, "units")))
    if (!inherits(e1, "difftime") && inherits(e2, "difftime")) 
      return(.difftime(NextMethod(.Generic), units = attr(e2, "units")))
    u1 <- attr(e1, "units")
    if (attr(e2, "units") == u1) {
      .difftime(NextMethod(.Generic), units = u1)
    }
    else {
      e1 <- coerceTimeUnit(e1)
      e2 <- coerceTimeUnit(e2)
      .difftime(NextMethod(.Generic), units = "secs")
    }
  }
  else {
    stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA)
  }
}, function (e1, e2) 
{
  coerceTimeUnit <- function(x) {
    switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x)
  }
  if (nargs() == 1) {
    switch(.Generic, `+` = {
    }, `-` = {
      e1[] <- -unclass(e1)
    }, stop(gettextf("unary '%s' not defined for \"difftime\" objects", .Generic), domain = NA, call. = FALSE))
    return(e1)
  }
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (boolean) {
    if (inherits(e1, "difftime") && inherits(e2, "difftime")) {
      e1 <- coerceTimeUnit(e1)
      e2 <- coerceTimeUnit(e2)
    }
    NextMethod(.Generic)
  }
  else if (.Generic == "+" || .Generic == "-") {
    if (inherits(e1, "difftime") && !inherits(e2, "difftime")) 
      return(.difftime(NextMethod(.Generic), units = attr(e1, "units")))
    if (!inherits(e1, "difftime") && inherits(e2, "difftime")) 
      return(.difftime(NextMethod(.Generic), units = attr(e2, "units")))
    u1 <- attr(e1, "units")
    if (attr(e2, "units") == u1) {
      .difftime(NextMethod(.Generic), units = u1)
    }
    else {
      e1 <- coerceTimeUnit(e1)
      e2 <- coerceTimeUnit(e2)
      .difftime(NextMethod(.Generic), units = "secs")
    }
  }
  else {
    stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA)
  }
}, function (e1, e2) 
{
  coerceTimeUnit <- function(x) {
    switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x)
  }
  if (nargs() == 1) {
    switch(.Generic, `+` = {
    }, `-` = {
      e1[] <- -unclass(e1)
    }, stop(gettextf("unary '%s' not defined for \"difftime\" objects", .Generic), domain = NA, call. = FALSE))
    return(e1)
  }
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (boolean) {
    if (inherits(e1, "difftime") && inherits(e2, "difftime")) {
      e1 <- coerceTimeUnit(e1)
      e2 <- coerceTimeUnit(e2)
    }
    NextMethod(.Generic)
  }
  else if (.Generic == "+" || .Generic == "-") {
    if (inherits(e1, "difftime") && !inherits(e2, "difftime")) 
      return(.difftime(NextMethod(.Generic), units = attr(e1, "units")))
    if (!inherits(e1, "difftime") && inherits(e2, "difftime")) 
      return(.difftime(NextMethod(.Generic), units = attr(e2, "units")))
    u1 <- attr(e1, "units")
    if (attr(e2, "units") == u1) {
      .difftime(NextMethod(.Generic), units = u1)
    }
    else {
      e1 <- coerceTimeUnit(e1)
      e2 <- coerceTimeUnit(e2)
      .difftime(NextMethod(.Generic), units = "secs")
    }
  }
  else {
    stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA)
  }
})
c("package:base", "registered S3 method for Ops from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Ops.factor
list(`package:base` = function (e1, e2) 
{
  ok <- switch(.Generic, `==` = , `!=` = TRUE, FALSE)
  if (!ok) {
    warning(gettextf("%s not meaningful for factors", sQuote(.Generic)))
    return(rep.int(NA, max(length(e1), if (!missing(e2)) length(e2))))
  }
  noNA.levels <- function(f) {
    r <- levels(f)
    if (any(ina <- is.na(r))) {
      n <- "  NA "
      while (n %in% r) n <- paste(n, ".")
      r[ina] <- n
    }
    r
  }
  if (nzchar(.Method[1])) {
    if (!anyNA(levels(e1)) && is.character(e2) && length(e2) == 1) {
      if (.Generic == "==") {
        leq <- (levels(e1) == e2)
        return(leq[e1])
      }
      else {
        leq <- (levels(e1) != e2)
        return(leq[e1])
      }
    }
    l1 <- noNA.levels(e1)
    e1 <- l1[e1]
  }
  if (nzchar(.Method[2])) {
    if (!anyNA(levels(e2)) && is.character(e1) && length(e1) == 1) {
      if (.Generic == "==") {
        leq <- (levels(e2) == e1)
        return(leq[e2])
      }
      else {
        leq <- (levels(e2) != e1)
        return(leq[e2])
      }
    }
    l2 <- noNA.levels(e2)
    e2 <- l2[e2]
  }
  if (all(nzchar(.Method)) && (length(l1) != length(l2) || !all(sort.int(l2) == sort.int(l1)))) 
    stop("level sets of factors are different")
  value <- NextMethod(.Generic)
  nas <- is.na(e1) | is.na(e2)
  value[nas] <- NA
  value
}, function (e1, e2) 
{
  ok <- switch(.Generic, `==` = , `!=` = TRUE, FALSE)
  if (!ok) {
    warning(gettextf("%s not meaningful for factors", sQuote(.Generic)))
    return(rep.int(NA, max(length(e1), if (!missing(e2)) length(e2))))
  }
  noNA.levels <- function(f) {
    r <- levels(f)
    if (any(ina <- is.na(r))) {
      n <- "  NA "
      while (n %in% r) n <- paste(n, ".")
      r[ina] <- n
    }
    r
  }
  if (nzchar(.Method[1])) {
    if (!anyNA(levels(e1)) && is.character(e2) && length(e2) == 1) {
      if (.Generic == "==") {
        leq <- (levels(e1) == e2)
        return(leq[e1])
      }
      else {
        leq <- (levels(e1) != e2)
        return(leq[e1])
      }
    }
    l1 <- noNA.levels(e1)
    e1 <- l1[e1]
  }
  if (nzchar(.Method[2])) {
    if (!anyNA(levels(e2)) && is.character(e1) && length(e1) == 1) {
      if (.Generic == "==") {
        leq <- (levels(e2) == e1)
        return(leq[e2])
      }
      else {
        leq <- (levels(e2) != e1)
        return(leq[e2])
      }
    }
    l2 <- noNA.levels(e2)
    e2 <- l2[e2]
  }
  if (all(nzchar(.Method)) && (length(l1) != length(l2) || !all(sort.int(l2) == sort.int(l1)))) 
    stop("level sets of factors are different")
  value <- NextMethod(.Generic)
  nas <- is.na(e1) | is.na(e2)
  value[nas] <- NA
  value
}, function (e1, e2) 
{
  ok <- switch(.Generic, `==` = , `!=` = TRUE, FALSE)
  if (!ok) {
    warning(gettextf("%s not meaningful for factors", sQuote(.Generic)))
    return(rep.int(NA, max(length(e1), if (!missing(e2)) length(e2))))
  }
  noNA.levels <- function(f) {
    r <- levels(f)
    if (any(ina <- is.na(r))) {
      n <- "  NA "
      while (n %in% r) n <- paste(n, ".")
      r[ina] <- n
    }
    r
  }
  if (nzchar(.Method[1])) {
    if (!anyNA(levels(e1)) && is.character(e2) && length(e2) == 1) {
      if (.Generic == "==") {
        leq <- (levels(e1) == e2)
        return(leq[e1])
      }
      else {
        leq <- (levels(e1) != e2)
        return(leq[e1])
      }
    }
    l1 <- noNA.levels(e1)
    e1 <- l1[e1]
  }
  if (nzchar(.Method[2])) {
    if (!anyNA(levels(e2)) && is.character(e1) && length(e1) == 1) {
      if (.Generic == "==") {
        leq <- (levels(e2) == e1)
        return(leq[e2])
      }
      else {
        leq <- (levels(e2) != e1)
        return(leq[e2])
      }
    }
    l2 <- noNA.levels(e2)
    e2 <- l2[e2]
  }
  if (all(nzchar(.Method)) && (length(l1) != length(l2) || !all(sort.int(l2) == sort.int(l1)))) 
    stop("level sets of factors are different")
  value <- NextMethod(.Generic)
  nas <- is.na(e1) | is.na(e2)
  value[nas] <- NA
  value
})
c("package:base", "registered S3 method for Ops from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Ops.numeric_version
list(`package:base` = function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary '%s' not defined for \"numeric_version\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("'%s' not defined for \"numeric_version\" objects", .Generic), domain = NA)
  if (!is.numeric_version(e1)) 
    e1 <- as.numeric_version(e1)
  if (!is.numeric_version(e2)) 
    e2 <- as.numeric_version(e2)
  n1 <- length(e1)
  n2 <- length(e2)
  if (!n1 || !n2) 
    return(logical())
  e <- split(.encode_numeric_version(c(e1, e2)), rep.int(c(1, 2), c(n1, n2)))
  e1 <- e[[1]]
  e2 <- e[[2]]
  NextMethod(.Generic)
}, function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary '%s' not defined for \"numeric_version\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("'%s' not defined for \"numeric_version\" objects", .Generic), domain = NA)
  if (!is.numeric_version(e1)) 
    e1 <- as.numeric_version(e1)
  if (!is.numeric_version(e2)) 
    e2 <- as.numeric_version(e2)
  n1 <- length(e1)
  n2 <- length(e2)
  if (!n1 || !n2) 
    return(logical())
  e <- split(.encode_numeric_version(c(e1, e2)), rep.int(c(1, 2), c(n1, n2)))
  e1 <- e[[1]]
  e2 <- e[[2]]
  NextMethod(.Generic)
}, function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary '%s' not defined for \"numeric_version\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("'%s' not defined for \"numeric_version\" objects", .Generic), domain = NA)
  if (!is.numeric_version(e1)) 
    e1 <- as.numeric_version(e1)
  if (!is.numeric_version(e2)) 
    e2 <- as.numeric_version(e2)
  n1 <- length(e1)
  n2 <- length(e2)
  if (!n1 || !n2) 
    return(logical())
  e <- split(.encode_numeric_version(c(e1, e2)), rep.int(c(1, 2), c(n1, n2)))
  e1 <- e[[1]]
  e2 <- e[[2]]
  NextMethod(.Generic)
})
c("package:base", "registered S3 method for Ops from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Ops.ordered
list(`package:base` = function (e1, e2) 
{
  ok <- switch(.Generic, `<` = , `>` = , `<=` = , `>=` = , `==` = , `!=` = TRUE, FALSE)
  if (!ok) {
    warning(sprintf("'%s' is not meaningful for ordered factors", .Generic))
    return(rep.int(NA, max(length(e1), if (!missing(e2)) length(e2))))
  }
  if (.Generic %in% c("==", "!=")) 
    return(NextMethod(.Generic))
  nas <- is.na(e1) | is.na(e2)
  ord1 <- FALSE
  ord2 <- FALSE
  if (nzchar(.Method[1])) {
    l1 <- levels(e1)
    ord1 <- TRUE
  }
  if (nzchar(.Method[2])) {
    l2 <- levels(e2)
    ord2 <- TRUE
  }
  if (all(nzchar(.Method)) && (length(l1) != length(l2) || !all(l2 == l1))) 
    stop("level sets of factors are different")
  if (ord1 && ord2) {
    e1 <- as.integer(e1)
    e2 <- as.integer(e2)
  }
  else if (!ord1) {
    e1 <- match(e1, l2)
    e2 <- as.integer(e2)
  }
  else if (!ord2) {
    e2 <- match(e2, l1)
    e1 <- as.integer(e1)
  }
  value <- get(.Generic, mode = "function")(e1, e2)
  value[nas] <- NA
  value
}, function (e1, e2) 
{
  ok <- switch(.Generic, `<` = , `>` = , `<=` = , `>=` = , `==` = , `!=` = TRUE, FALSE)
  if (!ok) {
    warning(sprintf("'%s' is not meaningful for ordered factors", .Generic))
    return(rep.int(NA, max(length(e1), if (!missing(e2)) length(e2))))
  }
  if (.Generic %in% c("==", "!=")) 
    return(NextMethod(.Generic))
  nas <- is.na(e1) | is.na(e2)
  ord1 <- FALSE
  ord2 <- FALSE
  if (nzchar(.Method[1])) {
    l1 <- levels(e1)
    ord1 <- TRUE
  }
  if (nzchar(.Method[2])) {
    l2 <- levels(e2)
    ord2 <- TRUE
  }
  if (all(nzchar(.Method)) && (length(l1) != length(l2) || !all(l2 == l1))) 
    stop("level sets of factors are different")
  if (ord1 && ord2) {
    e1 <- as.integer(e1)
    e2 <- as.integer(e2)
  }
  else if (!ord1) {
    e1 <- match(e1, l2)
    e2 <- as.integer(e2)
  }
  else if (!ord2) {
    e2 <- match(e2, l1)
    e1 <- as.integer(e1)
  }
  value <- get(.Generic, mode = "function")(e1, e2)
  value[nas] <- NA
  value
}, function (e1, e2) 
{
  ok <- switch(.Generic, `<` = , `>` = , `<=` = , `>=` = , `==` = , `!=` = TRUE, FALSE)
  if (!ok) {
    warning(sprintf("'%s' is not meaningful for ordered factors", .Generic))
    return(rep.int(NA, max(length(e1), if (!missing(e2)) length(e2))))
  }
  if (.Generic %in% c("==", "!=")) 
    return(NextMethod(.Generic))
  nas <- is.na(e1) | is.na(e2)
  ord1 <- FALSE
  ord2 <- FALSE
  if (nzchar(.Method[1])) {
    l1 <- levels(e1)
    ord1 <- TRUE
  }
  if (nzchar(.Method[2])) {
    l2 <- levels(e2)
    ord2 <- TRUE
  }
  if (all(nzchar(.Method)) && (length(l1) != length(l2) || !all(l2 == l1))) 
    stop("level sets of factors are different")
  if (ord1 && ord2) {
    e1 <- as.integer(e1)
    e2 <- as.integer(e2)
  }
  else if (!ord1) {
    e1 <- match(e1, l2)
    e2 <- as.integer(e2)
  }
  else if (!ord2) {
    e2 <- match(e2, l1)
    e1 <- as.integer(e1)
  }
  value <- get(.Generic, mode = "function")(e1, e2)
  value[nas] <- NA
  value
})
c("package:base", "registered S3 method for Ops from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Ops.POSIXt
list(`package:base` = function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary '%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  if (inherits(e1, "POSIXlt") || is.character(e1)) 
    e1 <- as.POSIXct(e1)
  if (inherits(e2, "POSIXlt") || is.character(e2)) 
    e2 <- as.POSIXct(e2)
  check_tzones(e1, e2)
  NextMethod(.Generic)
}, function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary '%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  if (inherits(e1, "POSIXlt") || is.character(e1)) 
    e1 <- as.POSIXct(e1)
  if (inherits(e2, "POSIXlt") || is.character(e2)) 
    e2 <- as.POSIXct(e2)
  check_tzones(e1, e2)
  NextMethod(.Generic)
}, function (e1, e2) 
{
  if (nargs() == 1) 
    stop(gettextf("unary '%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , `<=` = , `>=` = TRUE, FALSE)
  if (!boolean) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  if (inherits(e1, "POSIXlt") || is.character(e1)) 
    e1 <- as.POSIXct(e1)
  if (inherits(e2, "POSIXlt") || is.character(e2)) 
    e2 <- as.POSIXct(e2)
  check_tzones(e1, e2)
  NextMethod(.Generic)
})
c("package:base", "registered S3 method for Ops from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
options
list(`package:base` = function (...) 
  .Internal(options(...)), function (...) 
    .Internal(options(...)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
order
list(`package:base` = function (..., na.last = TRUE, decreasing = FALSE, method = c("auto", "shell", "radix")) 
{
  z <- list(...)
  decreasing <- as.logical(decreasing)
  if (length(z) == 1 && is.numeric(x <- z[[1]]) && !is.object(x) && length(x) > 0) {
    if (.Internal(sorted_fpass(x, decreasing, na.last))) 
      return(seq_along(x))
  }
  method <- match.arg(method)
  if (any(vapply(z, is.object, logical(1)))) {
    z <- lapply(z, function(x) if (is.object(x)) 
      as.vector(xtfrm(x))
      else x)
    return(do.call("order", c(z, list(na.last = na.last, decreasing = decreasing, method = method))))
  }
  if (method == "auto") {
    useRadix <- all(vapply(z, function(x) {
      (is.numeric(x) || is.factor(x) || is.logical(x)) && is.integer(length(x))
    }, logical(1)))
    method <- if (useRadix) 
      "radix"
    else "shell"
  }
  if (method != "radix" && !is.na(na.last)) {
    if (length(decreasing) > 1) 
      stop("'decreasing' of length > 1 is only for method = \"radix\"")
    return(.Internal(order(na.last, decreasing, ...)))
  }
  if (method == "radix") {
    decreasing <- rep_len(as.logical(decreasing), length(z))
    return(.Internal(radixsort(na.last, decreasing, FALSE, TRUE, ...)))
  }
  if (any(diff((l.z <- lengths(z)) != 0))) 
    stop("argument lengths differ")
  na <- vapply(z, is.na, rep.int(NA, l.z[1]))
  ok <- if (is.matrix(na)) 
    rowSums(na) == 0
  else !any(na)
  if (all(!ok)) 
    return(integer())
  z[[1]][!ok] <- NA
  ans <- do.call("order", c(z, list(decreasing = decreasing)))
  ans[ok[ans]]
}, function (..., na.last = TRUE, decreasing = FALSE, method = c("auto", "shell", "radix")) 
{
  z <- list(...)
  decreasing <- as.logical(decreasing)
  if (length(z) == 1 && is.numeric(x <- z[[1]]) && !is.object(x) && length(x) > 0) {
    if (.Internal(sorted_fpass(x, decreasing, na.last))) 
      return(seq_along(x))
  }
  method <- match.arg(method)
  if (any(vapply(z, is.object, logical(1)))) {
    z <- lapply(z, function(x) if (is.object(x)) 
      as.vector(xtfrm(x))
      else x)
    return(do.call("order", c(z, list(na.last = na.last, decreasing = decreasing, method = method))))
  }
  if (method == "auto") {
    useRadix <- all(vapply(z, function(x) {
      (is.numeric(x) || is.factor(x) || is.logical(x)) && is.integer(length(x))
    }, logical(1)))
    method <- if (useRadix) 
      "radix"
    else "shell"
  }
  if (method != "radix" && !is.na(na.last)) {
    if (length(decreasing) > 1) 
      stop("'decreasing' of length > 1 is only for method = \"radix\"")
    return(.Internal(order(na.last, decreasing, ...)))
  }
  if (method == "radix") {
    decreasing <- rep_len(as.logical(decreasing), length(z))
    return(.Internal(radixsort(na.last, decreasing, FALSE, TRUE, ...)))
  }
  if (any(diff((l.z <- lengths(z)) != 0))) 
    stop("argument lengths differ")
  na <- vapply(z, is.na, rep.int(NA, l.z[1]))
  ok <- if (is.matrix(na)) 
    rowSums(na) == 0
  else !any(na)
  if (all(!ok)) 
    return(integer())
  z[[1]][!ok] <- NA
  ans <- do.call("order", c(z, list(decreasing = decreasing)))
  ans[ok[ans]]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
ordered
list(`package:base` = function (x, ...) 
  factor(x, ..., ordered = TRUE), function (x, ...) 
    factor(x, ..., ordered = TRUE))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
outer
list(`package:base` = function (X, Y, FUN = "*", ...) 
{
  if (is.array(X)) {
    dX <- dim(X)
    nx <- dimnames(X)
    no.nx <- is.null(nx)
  }
  else {
    dX <- length(X)
    no.nx <- is.null(names(X))
    if (!no.nx) 
      nx <- list(names(X))
  }
  if (is.array(Y)) {
    dY <- dim(Y)
    ny <- dimnames(Y)
    no.ny <- is.null(ny)
  }
  else {
    dY <- length(Y)
    no.ny <- is.null(names(Y))
    if (!no.ny) 
      ny <- list(names(Y))
  }
  robj <- if (is.character(FUN) && FUN == "*") {
    if (!missing(...)) 
      stop("using ... with FUN = \"*\" is an error")
    tcrossprod(as.vector(X), as.vector(Y))
  }
  else {
    FUN <- match.fun(FUN)
    Y <- rep(Y, rep.int(length(X), length(Y)))
    if (length(X)) 
      X <- rep(X, times = ceiling(length(Y)/length(X)))
    FUN(X, Y, ...)
  }
  dim(robj) <- c(dX, dY)
  if (!(no.nx && no.ny)) {
    if (no.nx) 
      nx <- vector("list", length(dX))
    else if (no.ny) 
      ny <- vector("list", length(dY))
    dimnames(robj) <- c(nx, ny)
  }
  robj
}, function (X, Y, FUN = "*", ...) 
{
  if (is.array(X)) {
    dX <- dim(X)
    nx <- dimnames(X)
    no.nx <- is.null(nx)
  }
  else {
    dX <- length(X)
    no.nx <- is.null(names(X))
    if (!no.nx) 
      nx <- list(names(X))
  }
  if (is.array(Y)) {
    dY <- dim(Y)
    ny <- dimnames(Y)
    no.ny <- is.null(ny)
  }
  else {
    dY <- length(Y)
    no.ny <- is.null(names(Y))
    if (!no.ny) 
      ny <- list(names(Y))
  }
  robj <- if (is.character(FUN) && FUN == "*") {
    if (!missing(...)) 
      stop("using ... with FUN = \"*\" is an error")
    tcrossprod(as.vector(X), as.vector(Y))
  }
  else {
    FUN <- match.fun(FUN)
    Y <- rep(Y, rep.int(length(X), length(Y)))
    if (length(X)) 
      X <- rep(X, times = ceiling(length(Y)/length(X)))
    FUN(X, Y, ...)
  }
  dim(robj) <- c(dX, dY)
  if (!(no.nx && no.ny)) {
    if (no.nx) 
      nx <- vector("list", length(dX))
    else if (no.ny) 
      ny <- vector("list", length(dY))
    dimnames(robj) <- c(nx, ny)
  }
  robj
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
package_version
list(`package:base` = function (x, strict = TRUE) 
{
  if (is.list(x) && all(c("major", "minor") %in% names(x))) 
    return(R_system_version(paste(x[c("major", "minor")], collapse = ".")))
  .make_numeric_version(x, strict, .standard_regexps()$valid_package_version, "package_version")
}, function (x, strict = TRUE) 
{
  if (is.list(x) && all(c("major", "minor") %in% names(x))) 
    return(R_system_version(paste(x[c("major", "minor")], collapse = ".")))
  .make_numeric_version(x, strict, .standard_regexps()$valid_package_version, "package_version")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageEvent
list(`package:base` = function (pkgname, event = c("onLoad", "attach", "detach", "onUnload")) 
{
  event <- match.arg(event)
  pkgname <- strsplit(pkgname, "_", fixed = TRUE)[[1]][1]
  paste("UserHook", pkgname, event, sep = "::")
}, function (pkgname, event = c("onLoad", "attach", "detach", "onUnload")) 
{
  event <- match.arg(event)
  pkgname <- strsplit(pkgname, "_", fixed = TRUE)[[1]][1]
  paste("UserHook", pkgname, event, sep = "::")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageHasNamespace
list(`package:base` = function (package, package.lib) 
  file.exists(file.path(package.lib, package, "NAMESPACE")), function (package, package.lib) 
    file.exists(file.path(package.lib, package, "NAMESPACE")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageNotFoundError
list(`package:base` = function (package, lib.loc, call = NULL) 
{
  if (length(package) == 1) 
    msg <- gettextf("there is no package called %s", sQuote(package))
  else msg <- paste0(ngettext(length(package), "there is no package called", "there are no packages called"), " ", paste(sQuote(package), collapse = ", "))
  errorCondition(msg, package = package, lib.loc = lib.loc, call = call, class = "packageNotFoundError")
}, function (package, lib.loc, call = NULL) 
{
  if (length(package) == 1) 
    msg <- gettextf("there is no package called %s", sQuote(package))
  else msg <- paste0(ngettext(length(package), "there is no package called", "there are no packages called"), " ", paste(sQuote(package), collapse = ", "))
  errorCondition(msg, package = package, lib.loc = lib.loc, call = call, class = "packageNotFoundError")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageStartupMessage
list(`package:base` = function (..., domain = NULL, appendLF = TRUE) 
{
  call <- sys.call()
  msg <- .makeMessage(..., domain = domain, appendLF = appendLF)
  message(.packageStartupMessage(msg, call))
}, function (..., domain = NULL, appendLF = TRUE) 
{
  call <- sys.call()
  msg <- .makeMessage(..., domain = domain, appendLF = appendLF)
  message(.packageStartupMessage(msg, call))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
packBits
list(`package:base` = function (x, type = c("raw", "integer", "double")) 
{
  type <- match.arg(type)
  .Internal(packBits(x, type))
}, function (x, type = c("raw", "integer", "double")) 
{
  type <- match.arg(type)
  .Internal(packBits(x, type))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pairlist
list(`package:base` = function (...) 
  as.pairlist(list(...)), function (...) 
    as.pairlist(list(...)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
parent.env
list(`package:base` = function (env) 
  .Internal(parent.env(env)), function (env) 
    .Internal(parent.env(env)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
parent.env<-
  list(`package:base` = function (env, value) 
    .Internal(`parent.env<-`(env, value)), function (env, value) 
      .Internal(`parent.env<-`(env, value)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
parent.frame
list(`package:base` = function (n = 1) 
  .Internal(parent.frame(n)), function (n = 1) 
    .Internal(parent.frame(n)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
parse
list(`package:base` = function (file = "", n = NULL, text = NULL, prompt = "?", keep.source = getOption("keep.source"), srcfile = NULL, encoding = "unknown") 
{
  keep.source <- isTRUE(keep.source)
  if (!is.null(text)) {
    if (length(text) == 0) 
      return(expression())
    if (missing(srcfile)) {
      srcfile <- "<text>"
      if (keep.source) 
        srcfile <- srcfilecopy(srcfile, text)
    }
    file <- stdin()
  }
  else {
    if (is.character(file)) {
      if (file == "") {
        file <- stdin()
        if (missing(srcfile)) 
          srcfile <- "<stdin>"
      }
      else {
        filename <- file
        file <- file(filename, "r")
        if (missing(srcfile)) 
          srcfile <- filename
        if (keep.source) {
          text <- readLines(file, warn = FALSE, encoding = encoding)
          if (!length(text)) 
            text <- ""
          close(file)
          file <- stdin()
          srcfile <- srcfilecopy(filename, text, file.mtime(filename), isFile = TRUE)
        }
        else on.exit(close(file))
      }
    }
  }
  .Internal(parse(file, n, text, prompt, srcfile, encoding))
}, function (file = "", n = NULL, text = NULL, prompt = "?", keep.source = getOption("keep.source"), srcfile = NULL, encoding = "unknown") 
{
  keep.source <- isTRUE(keep.source)
  if (!is.null(text)) {
    if (length(text) == 0) 
      return(expression())
    if (missing(srcfile)) {
      srcfile <- "<text>"
      if (keep.source) 
        srcfile <- srcfilecopy(srcfile, text)
    }
    file <- stdin()
  }
  else {
    if (is.character(file)) {
      if (file == "") {
        file <- stdin()
        if (missing(srcfile)) 
          srcfile <- "<stdin>"
      }
      else {
        filename <- file
        file <- file(filename, "r")
        if (missing(srcfile)) 
          srcfile <- filename
        if (keep.source) {
          text <- readLines(file, warn = FALSE, encoding = encoding)
          if (!length(text)) 
            text <- ""
          close(file)
          file <- stdin()
          srcfile <- srcfilecopy(filename, text, file.mtime(filename), isFile = TRUE)
        }
        else on.exit(close(file))
      }
    }
  }
  .Internal(parse(file, n, text, prompt, srcfile, encoding))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
parseNamespaceFile
list(`package:base` = function (package, package.lib, mustExist = TRUE) 
{
  namespaceFilePath <- function(package, package.lib) file.path(package.lib, package, "NAMESPACE")
  nativeRoutineMap <- function(useRegistration, symbolNames, fixes) {
    proto <- list(useRegistration = FALSE, symbolNames = character())
    class(proto) <- "NativeRoutineMap"
    mergeNativeRoutineMaps(proto, useRegistration, symbolNames, fixes)
  }
  mergeNativeRoutineMaps <- function(map, useRegistration, symbolNames, fixes) {
    if (!useRegistration) 
      names(symbolNames) <- paste0(fixes[1], names(symbolNames), fixes[2])
    else map$registrationFixes <- fixes
    map$useRegistration <- map$useRegistration || useRegistration
    map$symbolNames <- c(map$symbolNames, symbolNames)
    map
  }
  nsFile <- namespaceFilePath(package, package.lib)
  descfile <- file.path(package.lib, package, "DESCRIPTION")
  enc <- if (file.exists(descfile)) {
    read.dcf(file = descfile, "Encoding")[1]
  }
  else NA
  if (file.exists(nsFile)) 
    directives <- if (!is.na(enc) && !Sys.getlocale("LC_CTYPE") %in% c("C", "POSIX")) {
      lines <- readLines(nsFile, warn = FALSE)
      tmp <- iconv(lines, from = enc, to = "")
      bad <- which(is.na(tmp))
      comm <- grep("^[[:space:]]*#", lines[bad], invert = TRUE, useBytes = TRUE)
      if (length(bad[comm])) 
        stop("unable to re-encode some lines in NAMESPACE file")
      tmp <- iconv(lines, from = enc, to = "", sub = "byte")
      con <- textConnection(tmp)
      on.exit(close(con))
      parse(con, keep.source = FALSE, srcfile = NULL)
    }
  else parse(nsFile, keep.source = FALSE, srcfile = NULL)
  else if (mustExist) 
    stop(gettextf("package %s has no 'NAMESPACE' file", sQuote(package)), domain = NA)
  else directives <- NULL
  exports <- character()
  exportPatterns <- character()
  exportClasses <- character()
  exportClassPatterns <- character()
  exportMethods <- character()
  imports <- list()
  importMethods <- list()
  importClasses <- list()
  dynlibs <- character()
  nS3methods <- 1000
  S3methods <- matrix(NA, nS3methods, 4)
  nativeRoutines <- list()
  nS3 <- 0
  parseDirective <- function(e) {
    asChar <- function(cc) {
      r <- as.character(cc)
      if (any(r == "")) 
        stop(gettextf("empty name in directive '%s' in 'NAMESPACE' file", as.character(e[[1]])), domain = NA)
      r
    }
    evalToChar <- function(cc) {
      vars <- all.vars(cc)
      names(vars) <- vars
      as.character(eval(eval(call("substitute", cc, as.list(vars))), .GlobalEnv))
    }
    switch(as.character(e[[1]]), `if` = if (eval(e[[2]], .GlobalEnv)) parseDirective(e[[3]]) else if (length(e) == 4) parseDirective(e[[4]]), `{` = for (ee in as.list(e[-1])) parseDirective(ee), `=` = , `<-` = {
      parseDirective(e[[3]])
      if (as.character(e[[3]][[1]]) == "useDynLib") names(dynlibs)[length(dynlibs)] <<- asChar(e[[2]])
    }, export = {
      exp <- e[-1]
      exp <- structure(asChar(exp), names = names(exp))
      exports <<- c(exports, exp)
    }, exportPattern = {
      pat <- asChar(e[-1])
      exportPatterns <<- c(pat, exportPatterns)
    }, exportClassPattern = {
      pat <- asChar(e[-1])
      exportClassPatterns <<- c(pat, exportClassPatterns)
    }, exportClass = , exportClasses = {
      exportClasses <<- c(asChar(e[-1]), exportClasses)
    }, exportMethods = {
      exportMethods <<- c(asChar(e[-1]), exportMethods)
    }, import = {
      except <- e$except
      e$except <- NULL
      pkgs <- as.list(asChar(e[-1]))
      if (!is.null(except)) {
        pkgs <- lapply(pkgs, list, except = evalToChar(except))
      }
      imports <<- c(imports, pkgs)
    }, importFrom = {
      imp <- e[-1]
      ivars <- imp[-1]
      inames <- names(ivars)
      imp <- list(asChar(imp[1]), structure(asChar(ivars), names = inames))
      imports <<- c(imports, list(imp))
    }, importClassFrom = , importClassesFrom = {
      imp <- asChar(e[-1])
      pkg <- imp[[1]]
      impClasses <- imp[-1]
      imp <- list(asChar(pkg), asChar(impClasses))
      importClasses <<- c(importClasses, list(imp))
    }, importMethodsFrom = {
      imp <- asChar(e[-1])
      pkg <- imp[[1]]
      impMethods <- imp[-1]
      imp <- list(asChar(pkg), asChar(impMethods))
      importMethods <<- c(importMethods, list(imp))
    }, useDynLib = {
      dyl <- as.character(e[2])
      dynlibs <<- structure(c(dynlibs, dyl), names = c(names(dynlibs), ifelse(!is.null(names(e)) && nzchar(names(e)[2]), names(e)[2], "")))
      if (length(e) > 2) {
        symNames <- as.character(e[-c(1, 2)])
        names(symNames) <- names(e[-c(1, 2)])
        if (length(names(symNames)) == 0) names(symNames) <- symNames else if (any(w <- names(symNames) == "")) {
          names(symNames)[w] <- symNames[w]
        }
        dup <- duplicated(names(symNames))
        if (any(dup)) warning(gettextf("duplicate symbol names %s in useDynLib(\"%s\")", paste(sQuote(names(symNames)[dup]), collapse = ", "), dyl), domain = NA, call. = FALSE)
        symNames <- symNames[!dup]
        fixes <- c("", "")
        idx <- match(".fixes", names(symNames))
        if (!is.na(idx)) {
          if (nzchar(symNames[idx])) {
            e <- parse(text = symNames[idx], keep.source = FALSE, srcfile = NULL)[[1]]
            if (is.call(e)) val <- eval(e, .GlobalEnv) else val <- as.character(e)
            if (length(val)) fixes[seq_along(val)] <- val
          }
          symNames <- symNames[-idx]
        }
        useRegistration <- FALSE
        idx <- match(".registration", names(symNames))
        if (!is.na(idx)) {
          useRegistration <- as.logical(symNames[idx])
          symNames <- symNames[-idx]
        }
        nativeRoutines[[dyl]] <<- if (dyl %in% names(nativeRoutines)) mergeNativeRoutineMaps(nativeRoutines[[dyl]], useRegistration, symNames, fixes) else nativeRoutineMap(useRegistration, symNames, fixes)
      }
    }, S3method = {
      spec <- e[-1]
      if (length(spec) != 2 && length(spec) != 3) stop(gettextf("bad 'S3method' directive: %s", deparse(e)), call. = FALSE, domain = NA)
      nS3 <<- nS3 + 1
      if (nS3 > nS3methods) {
        old <- S3methods
        nold <- nS3methods
        nS3methods <<- nS3methods * 2
        new <- matrix(NA, nS3methods, 4)
        ind <- seq_len(nold)
        for (i in 1:4) new[ind, i] <- old[ind, i]
        S3methods <<- new
        rm(old, new)
      }
      if (is.call(gen <- spec[[1]]) && identical(as.character(gen[[1]]), "::")) {
        pkg <- as.character(gen[[2]])[1]
        gen <- as.character(gen[[3]])[1]
        S3methods[nS3, c(seq_along(spec), 4)] <<- c(gen, asChar(spec[-1]), pkg)
      } else S3methods[nS3, seq_along(spec)] <<- asChar(spec)
    }, stop(gettextf("unknown namespace directive: %s", deparse(e, nlines = 1)), call. = FALSE, domain = NA))
  }
  for (e in directives) parseDirective(e)
  dynlibs <- dynlibs[!duplicated(dynlibs)]
  list(imports = imports, exports = exports, exportPatterns = unique(exportPatterns), importClasses = importClasses, importMethods = importMethods, exportClasses = unique(exportClasses), exportMethods = unique(exportMethods), exportClassPatterns = unique(exportClassPatterns), dynlibs = dynlibs, nativeRoutines = nativeRoutines, S3methods = unique(S3methods[seq_len(nS3), , drop = FALSE]))
}, function (package, package.lib, mustExist = TRUE) 
{
  namespaceFilePath <- function(package, package.lib) file.path(package.lib, package, "NAMESPACE")
  nativeRoutineMap <- function(useRegistration, symbolNames, fixes) {
    proto <- list(useRegistration = FALSE, symbolNames = character())
    class(proto) <- "NativeRoutineMap"
    mergeNativeRoutineMaps(proto, useRegistration, symbolNames, fixes)
  }
  mergeNativeRoutineMaps <- function(map, useRegistration, symbolNames, fixes) {
    if (!useRegistration) 
      names(symbolNames) <- paste0(fixes[1], names(symbolNames), fixes[2])
    else map$registrationFixes <- fixes
    map$useRegistration <- map$useRegistration || useRegistration
    map$symbolNames <- c(map$symbolNames, symbolNames)
    map
  }
  nsFile <- namespaceFilePath(package, package.lib)
  descfile <- file.path(package.lib, package, "DESCRIPTION")
  enc <- if (file.exists(descfile)) {
    read.dcf(file = descfile, "Encoding")[1]
  }
  else NA
  if (file.exists(nsFile)) 
    directives <- if (!is.na(enc) && !Sys.getlocale("LC_CTYPE") %in% c("C", "POSIX")) {
      lines <- readLines(nsFile, warn = FALSE)
      tmp <- iconv(lines, from = enc, to = "")
      bad <- which(is.na(tmp))
      comm <- grep("^[[:space:]]*#", lines[bad], invert = TRUE, useBytes = TRUE)
      if (length(bad[comm])) 
        stop("unable to re-encode some lines in NAMESPACE file")
      tmp <- iconv(lines, from = enc, to = "", sub = "byte")
      con <- textConnection(tmp)
      on.exit(close(con))
      parse(con, keep.source = FALSE, srcfile = NULL)
    }
  else parse(nsFile, keep.source = FALSE, srcfile = NULL)
  else if (mustExist) 
    stop(gettextf("package %s has no 'NAMESPACE' file", sQuote(package)), domain = NA)
  else directives <- NULL
  exports <- character()
  exportPatterns <- character()
  exportClasses <- character()
  exportClassPatterns <- character()
  exportMethods <- character()
  imports <- list()
  importMethods <- list()
  importClasses <- list()
  dynlibs <- character()
  nS3methods <- 1000
  S3methods <- matrix(NA, nS3methods, 4)
  nativeRoutines <- list()
  nS3 <- 0
  parseDirective <- function(e) {
    asChar <- function(cc) {
      r <- as.character(cc)
      if (any(r == "")) 
        stop(gettextf("empty name in directive '%s' in 'NAMESPACE' file", as.character(e[[1]])), domain = NA)
      r
    }
    evalToChar <- function(cc) {
      vars <- all.vars(cc)
      names(vars) <- vars
      as.character(eval(eval(call("substitute", cc, as.list(vars))), .GlobalEnv))
    }
    switch(as.character(e[[1]]), `if` = if (eval(e[[2]], .GlobalEnv)) parseDirective(e[[3]]) else if (length(e) == 4) parseDirective(e[[4]]), `{` = for (ee in as.list(e[-1])) parseDirective(ee), `=` = , `<-` = {
      parseDirective(e[[3]])
      if (as.character(e[[3]][[1]]) == "useDynLib") names(dynlibs)[length(dynlibs)] <<- asChar(e[[2]])
    }, export = {
      exp <- e[-1]
      exp <- structure(asChar(exp), names = names(exp))
      exports <<- c(exports, exp)
    }, exportPattern = {
      pat <- asChar(e[-1])
      exportPatterns <<- c(pat, exportPatterns)
    }, exportClassPattern = {
      pat <- asChar(e[-1])
      exportClassPatterns <<- c(pat, exportClassPatterns)
    }, exportClass = , exportClasses = {
      exportClasses <<- c(asChar(e[-1]), exportClasses)
    }, exportMethods = {
      exportMethods <<- c(asChar(e[-1]), exportMethods)
    }, import = {
      except <- e$except
      e$except <- NULL
      pkgs <- as.list(asChar(e[-1]))
      if (!is.null(except)) {
        pkgs <- lapply(pkgs, list, except = evalToChar(except))
      }
      imports <<- c(imports, pkgs)
    }, importFrom = {
      imp <- e[-1]
      ivars <- imp[-1]
      inames <- names(ivars)
      imp <- list(asChar(imp[1]), structure(asChar(ivars), names = inames))
      imports <<- c(imports, list(imp))
    }, importClassFrom = , importClassesFrom = {
      imp <- asChar(e[-1])
      pkg <- imp[[1]]
      impClasses <- imp[-1]
      imp <- list(asChar(pkg), asChar(impClasses))
      importClasses <<- c(importClasses, list(imp))
    }, importMethodsFrom = {
      imp <- asChar(e[-1])
      pkg <- imp[[1]]
      impMethods <- imp[-1]
      imp <- list(asChar(pkg), asChar(impMethods))
      importMethods <<- c(importMethods, list(imp))
    }, useDynLib = {
      dyl <- as.character(e[2])
      dynlibs <<- structure(c(dynlibs, dyl), names = c(names(dynlibs), ifelse(!is.null(names(e)) && nzchar(names(e)[2]), names(e)[2], "")))
      if (length(e) > 2) {
        symNames <- as.character(e[-c(1, 2)])
        names(symNames) <- names(e[-c(1, 2)])
        if (length(names(symNames)) == 0) names(symNames) <- symNames else if (any(w <- names(symNames) == "")) {
          names(symNames)[w] <- symNames[w]
        }
        dup <- duplicated(names(symNames))
        if (any(dup)) warning(gettextf("duplicate symbol names %s in useDynLib(\"%s\")", paste(sQuote(names(symNames)[dup]), collapse = ", "), dyl), domain = NA, call. = FALSE)
        symNames <- symNames[!dup]
        fixes <- c("", "")
        idx <- match(".fixes", names(symNames))
        if (!is.na(idx)) {
          if (nzchar(symNames[idx])) {
            e <- parse(text = symNames[idx], keep.source = FALSE, srcfile = NULL)[[1]]
            if (is.call(e)) val <- eval(e, .GlobalEnv) else val <- as.character(e)
            if (length(val)) fixes[seq_along(val)] <- val
          }
          symNames <- symNames[-idx]
        }
        useRegistration <- FALSE
        idx <- match(".registration", names(symNames))
        if (!is.na(idx)) {
          useRegistration <- as.logical(symNames[idx])
          symNames <- symNames[-idx]
        }
        nativeRoutines[[dyl]] <<- if (dyl %in% names(nativeRoutines)) mergeNativeRoutineMaps(nativeRoutines[[dyl]], useRegistration, symNames, fixes) else nativeRoutineMap(useRegistration, symNames, fixes)
      }
    }, S3method = {
      spec <- e[-1]
      if (length(spec) != 2 && length(spec) != 3) stop(gettextf("bad 'S3method' directive: %s", deparse(e)), call. = FALSE, domain = NA)
      nS3 <<- nS3 + 1
      if (nS3 > nS3methods) {
        old <- S3methods
        nold <- nS3methods
        nS3methods <<- nS3methods * 2
        new <- matrix(NA, nS3methods, 4)
        ind <- seq_len(nold)
        for (i in 1:4) new[ind, i] <- old[ind, i]
        S3methods <<- new
        rm(old, new)
      }
      if (is.call(gen <- spec[[1]]) && identical(as.character(gen[[1]]), "::")) {
        pkg <- as.character(gen[[2]])[1]
        gen <- as.character(gen[[3]])[1]
        S3methods[nS3, c(seq_along(spec), 4)] <<- c(gen, asChar(spec[-1]), pkg)
      } else S3methods[nS3, seq_along(spec)] <<- asChar(spec)
    }, stop(gettextf("unknown namespace directive: %s", deparse(e, nlines = 1)), call. = FALSE, domain = NA))
  }
  for (e in directives) parseDirective(e)
  dynlibs <- dynlibs[!duplicated(dynlibs)]
  list(imports = imports, exports = exports, exportPatterns = unique(exportPatterns), importClasses = importClasses, importMethods = importMethods, exportClasses = unique(exportClasses), exportMethods = unique(exportMethods), exportClassPatterns = unique(exportClassPatterns), dynlibs = dynlibs, nativeRoutines = nativeRoutines, S3methods = unique(S3methods[seq_len(nS3), , drop = FALSE]))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
paste
list(`package:base` = function (..., sep = " ", collapse = NULL, recycle0 = FALSE) 
  .Internal(paste(list(...), sep, collapse, recycle0)), function (..., sep = " ", collapse = NULL, recycle0 = FALSE) 
    .Internal(paste(list(...), sep, collapse, recycle0)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
paste0
list(`package:base` = function (..., collapse = NULL, recycle0 = FALSE) 
  .Internal(paste0(list(...), collapse, recycle0)), function (..., collapse = NULL, recycle0 = FALSE) 
    .Internal(paste0(list(...), collapse, recycle0)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
path.expand
list(`package:base` = function (path) 
  .Internal(path.expand(path)), function (path) 
    .Internal(path.expand(path)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
path.package
list(`package:base` = function (package = NULL, quiet = FALSE) 
{
  if (is.null(package)) 
    package <- .packages()
  if (length(package) == 0) 
    return(character())
  s <- search()
  searchpaths <- lapply(seq_along(s), function(i) attr(as.environment(i), "path"))
  searchpaths[[length(s)]] <- system.file()
  pkgs <- paste0("package:", package)
  pos <- match(pkgs, s)
  if (any(m <- is.na(pos))) {
    if (!quiet) {
      if (all(m)) 
        stop("none of the packages are loaded")
      else warning(sprintf(ngettext(as.integer(sum(m)), "package %s is not loaded", "packages %s are not loaded"), paste(package[m], collapse = ", ")), domain = NA)
    }
    pos <- pos[!m]
  }
  unlist(searchpaths[pos], use.names = FALSE)
}, function (package = NULL, quiet = FALSE) 
{
  if (is.null(package)) 
    package <- .packages()
  if (length(package) == 0) 
    return(character())
  s <- search()
  searchpaths <- lapply(seq_along(s), function(i) attr(as.environment(i), "path"))
  searchpaths[[length(s)]] <- system.file()
  pkgs <- paste0("package:", package)
  pos <- match(pkgs, s)
  if (any(m <- is.na(pos))) {
    if (!quiet) {
      if (all(m)) 
        stop("none of the packages are loaded")
      else warning(sprintf(ngettext(as.integer(sum(m)), "package %s is not loaded", "packages %s are not loaded"), paste(package[m], collapse = ", ")), domain = NA)
    }
    pos <- pos[!m]
  }
  unlist(searchpaths[pos], use.names = FALSE)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pcre_config
list(`package:base` = function () 
  .Internal(pcre_config()), function () 
    .Internal(pcre_config()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pi
list(`package:base` = 3.14159265358979, 3.14159265358979)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pipe
list(`package:base` = function (description, open = "", encoding = getOption("encoding")) 
  .Internal(pipe(description, open, encoding)), function (description, open = "", encoding = getOption("encoding")) 
    .Internal(pipe(description, open, encoding)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
plot
list(`package:graphics` = function (x, y, ...) 
  UseMethod("plot"), `package:base` = function (x, y, ...) 
    UseMethod("plot"), new("standardGeneric", .Data = function (x, y, ...) 
      standardGeneric("plot"), generic = "plot", package = "base", group = list(), valueClass = character(0), signature = c("x", "y"), default = new("derivedDefaultMethod", .Data = function (x, y, ...) 
        UseMethod("plot"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "plot"), skeleton = (new("derivedDefaultMethod", .Data = function (x, y, ...) 
          UseMethod("plot"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "plot"))(x, y, ...)), new("standardGeneric", .Data = function (x, y, ...) 
            standardGeneric("plot"), generic = "plot", package = "base", group = list(), valueClass = character(0), signature = c("x", "y"), default = new("derivedDefaultMethod", .Data = function (x, y, ...) 
              UseMethod("plot"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "plot"), skeleton = (new("derivedDefaultMethod", .Data = function (x, y, ...) 
                UseMethod("plot"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "plot"))(x, y, ...)), new("standardGeneric", .Data = function (x, y, ...) 
                  standardGeneric("plot"), generic = "plot", package = "base", group = list(), valueClass = character(0), signature = c("x", "y"), default = new("derivedDefaultMethod", .Data = function (x, y, ...) 
                    UseMethod("plot"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "plot"), skeleton = (new("derivedDefaultMethod", .Data = function (x, y, ...) 
                      UseMethod("plot"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "plot"))(x, y, ...)), function (x, y, ...) 
                        UseMethod("plot"))
c("package:graphics", "package:base", "namespace:colorspace", "namespace:stats4", "namespace:timeDate", "namespace:base")
c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE, TRUE, TRUE)
pmatch
list(`package:base` = function (x, table, nomatch = NA, duplicates.ok = FALSE) 
  .Internal(pmatch(as.character(x), as.character(table), nomatch, duplicates.ok)), function (x, table, nomatch = NA, duplicates.ok = FALSE) 
    .Internal(pmatch(as.character(x), as.character(table), nomatch, duplicates.ok)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pmax
list(`package:base` = function (..., na.rm = FALSE) 
{
  elts <- list(...)
  if (length(elts) == 0) 
    stop("no arguments")
  if (all(vapply(elts, function(x) is.atomic(x) && !is.object(x), NA))) {
    mmm <- .Internal(pmax(na.rm, ...))
    mostattributes(mmm) <- attributes(elts[[1]])
  }
  else {
    mmm <- elts[[1]]
    has.na <- FALSE
    as <- methods::as
    asL <- function(x) if (isS4(x)) 
      as(x, "logical")
    else x
    for (each in elts[-1]) {
      l1 <- length(each)
      l2 <- length(mmm)
      if (l2 && (l2 < l1 || !l1)) {
        if (l1%%l2) 
          warning("an argument will be fractionally recycled")
        mmm <- rep(mmm, length.out = l1)
      }
      else if (l1 && (l1 < l2 || !l2)) {
        if (l2%%l1) 
          warning("an argument will be fractionally recycled")
        each <- rep(each, length.out = l2)
      }
      na.m <- is.na(mmm)
      na.e <- is.na(each)
      if (has.na || (has.na <- any(na.m) || any(na.e))) {
        if (any(na.m <- asL(na.m))) 
          mmm[na.m] <- each[na.m]
        if (any(na.e <- asL(na.e))) 
          each[na.e] <- mmm[na.e]
      }
      nS4 <- !isS4(mmm)
      if (isS4(change <- mmm < each) && (nS4 || !isS4(each))) 
        change <- as(change, "logical")
      change <- change & !is.na(change)
      mmm[change] <- each[change]
      if (has.na && !na.rm) 
        mmm[na.m | na.e] <- NA
      if (nS4) 
        mostattributes(mmm) <- attributes(elts[[1]])
    }
  }
  mmm
}, function (..., na.rm = FALSE) 
{
  elts <- list(...)
  if (length(elts) == 0) 
    stop("no arguments")
  if (all(vapply(elts, function(x) is.atomic(x) && !is.object(x), NA))) {
    mmm <- .Internal(pmax(na.rm, ...))
    mostattributes(mmm) <- attributes(elts[[1]])
  }
  else {
    mmm <- elts[[1]]
    has.na <- FALSE
    as <- methods::as
    asL <- function(x) if (isS4(x)) 
      as(x, "logical")
    else x
    for (each in elts[-1]) {
      l1 <- length(each)
      l2 <- length(mmm)
      if (l2 && (l2 < l1 || !l1)) {
        if (l1%%l2) 
          warning("an argument will be fractionally recycled")
        mmm <- rep(mmm, length.out = l1)
      }
      else if (l1 && (l1 < l2 || !l2)) {
        if (l2%%l1) 
          warning("an argument will be fractionally recycled")
        each <- rep(each, length.out = l2)
      }
      na.m <- is.na(mmm)
      na.e <- is.na(each)
      if (has.na || (has.na <- any(na.m) || any(na.e))) {
        if (any(na.m <- asL(na.m))) 
          mmm[na.m] <- each[na.m]
        if (any(na.e <- asL(na.e))) 
          each[na.e] <- mmm[na.e]
      }
      nS4 <- !isS4(mmm)
      if (isS4(change <- mmm < each) && (nS4 || !isS4(each))) 
        change <- as(change, "logical")
      change <- change & !is.na(change)
      mmm[change] <- each[change]
      if (has.na && !na.rm) 
        mmm[na.m | na.e] <- NA
      if (nS4) 
        mostattributes(mmm) <- attributes(elts[[1]])
    }
  }
  mmm
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pmax.int
list(`package:base` = function (..., na.rm = FALSE) 
  .Internal(pmax(na.rm, ...)), function (..., na.rm = FALSE) 
    .Internal(pmax(na.rm, ...)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pmin
list(`package:base` = function (..., na.rm = FALSE) 
{
  elts <- list(...)
  if (length(elts) == 0) 
    stop("no arguments")
  if (all(vapply(elts, function(x) is.atomic(x) && !is.object(x), NA))) {
    mmm <- .Internal(pmin(na.rm, ...))
    mostattributes(mmm) <- attributes(elts[[1]])
  }
  else {
    mmm <- elts[[1]]
    has.na <- FALSE
    as <- methods::as
    asL <- function(x) if (isS4(x)) 
      as(x, "logical")
    else x
    for (each in elts[-1]) {
      l1 <- length(each)
      l2 <- length(mmm)
      if (l2 && (l2 < l1 || !l1)) {
        if (l1%%l2) 
          warning("an argument will be fractionally recycled")
        mmm <- rep(mmm, length.out = l1)
      }
      else if (l1 && (l1 < l2 || !l2)) {
        if (l2%%l1) 
          warning("an argument will be fractionally recycled")
        each <- rep(each, length.out = l2)
      }
      na.m <- is.na(mmm)
      na.e <- is.na(each)
      if (has.na || (has.na <- any(na.m) || any(na.e))) {
        if (any(na.m <- asL(na.m))) 
          mmm[na.m] <- each[na.m]
        if (any(na.e <- asL(na.e))) 
          each[na.e] <- mmm[na.e]
      }
      nS4 <- !isS4(mmm)
      if (isS4(change <- mmm > each) && (nS4 || !isS4(each))) 
        change <- as(change, "logical")
      change <- change & !is.na(change)
      mmm[change] <- each[change]
      if (has.na && !na.rm) 
        mmm[na.m | na.e] <- NA
      if (nS4) 
        mostattributes(mmm) <- attributes(elts[[1]])
    }
  }
  mmm
}, function (..., na.rm = FALSE) 
{
  elts <- list(...)
  if (length(elts) == 0) 
    stop("no arguments")
  if (all(vapply(elts, function(x) is.atomic(x) && !is.object(x), NA))) {
    mmm <- .Internal(pmin(na.rm, ...))
    mostattributes(mmm) <- attributes(elts[[1]])
  }
  else {
    mmm <- elts[[1]]
    has.na <- FALSE
    as <- methods::as
    asL <- function(x) if (isS4(x)) 
      as(x, "logical")
    else x
    for (each in elts[-1]) {
      l1 <- length(each)
      l2 <- length(mmm)
      if (l2 && (l2 < l1 || !l1)) {
        if (l1%%l2) 
          warning("an argument will be fractionally recycled")
        mmm <- rep(mmm, length.out = l1)
      }
      else if (l1 && (l1 < l2 || !l2)) {
        if (l2%%l1) 
          warning("an argument will be fractionally recycled")
        each <- rep(each, length.out = l2)
      }
      na.m <- is.na(mmm)
      na.e <- is.na(each)
      if (has.na || (has.na <- any(na.m) || any(na.e))) {
        if (any(na.m <- asL(na.m))) 
          mmm[na.m] <- each[na.m]
        if (any(na.e <- asL(na.e))) 
          each[na.e] <- mmm[na.e]
      }
      nS4 <- !isS4(mmm)
      if (isS4(change <- mmm > each) && (nS4 || !isS4(each))) 
        change <- as(change, "logical")
      change <- change & !is.na(change)
      mmm[change] <- each[change]
      if (has.na && !na.rm) 
        mmm[na.m | na.e] <- NA
      if (nS4) 
        mostattributes(mmm) <- attributes(elts[[1]])
    }
  }
  mmm
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pmin.int
list(`package:base` = function (..., na.rm = FALSE) 
  .Internal(pmin(na.rm, ...)), function (..., na.rm = FALSE) 
    .Internal(pmin(na.rm, ...)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
polyroot
list(`package:base` = function (z) 
  .Internal(polyroot(z)), function (z) 
    .Internal(polyroot(z)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pos.to.env
list(`package:base` = .Primitive("pos.to.env"), .Primitive("pos.to.env"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Position
list(`package:base` = function (f, x, right = FALSE, nomatch = NA) 
{
  f <- match.fun(f)
  ind <- if (right) 
    rev(seq_along(x))
  else seq_along(x)
  for (i in ind) if (f(x[[i]])) 
    return(i)
  nomatch
}, <environment>, function (f, x, right = FALSE, nomatch = NA) 
{
  f <- match.fun(f)
  ind <- if (right) 
    rev(seq_along(x))
  else seq_along(x)
  for (i in ind) if (f(x[[i]])) 
    return(i)
  nomatch
})
c("package:base", "namespace:ggplot2", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
pretty
list(`package:base` = function (x, ...) 
  UseMethod("pretty"), function (x, ...) 
    UseMethod("pretty"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pretty.default
list(`package:base` = function (x, n = 5, min.n = n%/%3, shrink.sml = 0.75, high.u.bias = 1.5, u5.bias = 0.5 + 1.5 * high.u.bias, eps.correct = 0, f.min = 2^-20, ...) 
{
  x <- x[is.finite(x <- as.numeric(x))]
  if (!length(x)) 
    return(x)
  z <- .Internal(pretty(min(x), max(x), n, min.n, shrink.sml, c(high.u.bias, u5.bias, f.min), eps.correct, TRUE))
  n <- z$n
  s <- seq.int(z$l, z$u, length.out = n + 1)
  if (!eps.correct && n) {
    delta <- diff(range(z$l, z$u)/n)
    if (any(small <- abs(s) < 1e-14 * delta)) 
      s[small] <- 0
  }
  s
}, function (x, n = 5, min.n = n%/%3, shrink.sml = 0.75, high.u.bias = 1.5, u5.bias = 0.5 + 1.5 * high.u.bias, eps.correct = 0, f.min = 2^-20, ...) 
{
  x <- x[is.finite(x <- as.numeric(x))]
  if (!length(x)) 
    return(x)
  z <- .Internal(pretty(min(x), max(x), n, min.n, shrink.sml, c(high.u.bias, u5.bias, f.min), eps.correct, TRUE))
  n <- z$n
  s <- seq.int(z$l, z$u, length.out = n + 1)
  if (!eps.correct && n) {
    delta <- diff(range(z$l, z$u)/n)
    if (any(small <- abs(s) < 1e-14 * delta)) 
      s[small] <- 0
  }
  s
}, function (x, n = 5, min.n = n%/%3, shrink.sml = 0.75, high.u.bias = 1.5, u5.bias = 0.5 + 1.5 * high.u.bias, eps.correct = 0, f.min = 2^-20, ...) 
{
  x <- x[is.finite(x <- as.numeric(x))]
  if (!length(x)) 
    return(x)
  z <- .Internal(pretty(min(x), max(x), n, min.n, shrink.sml, c(high.u.bias, u5.bias, f.min), eps.correct, TRUE))
  n <- z$n
  s <- seq.int(z$l, z$u, length.out = n + 1)
  if (!eps.correct && n) {
    delta <- diff(range(z$l, z$u)/n)
    if (any(small <- abs(s) < 1e-14 * delta)) 
      s[small] <- 0
  }
  s
})
c("package:base", "registered S3 method for pretty from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
prettyNum
list(`package:base` = function (x, big.mark = "", big.interval = 3, small.mark = "", small.interval = 5, decimal.mark = getOption("OutDec"), input.d.mark = decimal.mark, preserve.width = c("common", "individual", "none"), zero.print = NULL, replace.zero = FALSE, drop0trailing = FALSE, is.cmplx = NA, ...) 
{
  if (notChar <- !is.character(x)) {
    is.cmplx <- is.complex(x)
    x <- vapply(x, format, "", big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, zero.print = zero.print, drop0trailing = drop0trailing, ...)
  }
  nMark <- big.mark == "" && small.mark == "" && (notChar || decimal.mark == input.d.mark)
  if (identical(big.mark, decimal.mark)) 
    warning(gettextf("'big.mark' and 'decimal.mark' are both '%s', which could be confusing", big.mark), domain = NA)
  nZero <- is.null(zero.print) && !drop0trailing
  if (nMark && nZero) 
    return(x)
  if (nMark && !drop0trailing) 
    return(.format.zeros(x, zero.print, replace = replace.zero))
  if (is.na(is.cmplx)) {
    ina <- is.na(x) | x == "NA"
    is.cmplx <- if (all(ina)) 
      FALSE
    else any(grepl("[0-9].*[-+][0-9].*i$", x))
  }
  preserve.width <- match.arg(preserve.width)
  if (is.cmplx) {
    x <- .format.zeros(x, zero.print, replace = replace.zero)
    z.sp <- strsplit(sub("([0-9] *)([-+])( *[0-9])", "\\1::\\2::\\3", x), "::", fixed = TRUE)
    i3 <- lengths(z.sp) == 3
    if (any(i3)) {
      z.sp <- z.sp[i3]
      z.im <- vapply(z.sp, `[[`, "", 3)
      has.i <- grep("i$", z.im)
      z.im[has.i] <- sub("i$", "", z.im[has.i])
      r <- lapply(list(vapply(z.sp, `[[`, "", 1), z.im), function(.) prettyNum(., big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, input.d.mark = input.d.mark, preserve.width = preserve.width, zero.print = zero.print, replace.zero = replace.zero, drop0trailing = drop0trailing, is.cmplx = FALSE, ...))
      r[[2]][has.i] <- paste0(r[[2]][has.i], "i")
      x[i3] <- paste0(r[[1]], vapply(z.sp, `[[`, "", 2), r[[2]])
    }
    return(x)
  }
  if (nchar(input.d.mark) == 0) 
    stop("'input.d.mark' has no characters")
  x.sp <- strsplit(x, input.d.mark, fixed = TRUE)
  if (any(lengths(x.sp) > 2)) {
    x.sp <- lapply(x.sp, function(xs) {
      lx <- length(xs)
      if (lx <= 2) 
        xs
      else c(paste(xs[-lx], collapse = input.d.mark), xs[lx])
    })
  }
  B. <- vapply(x.sp, `[`, "", 1)
  A. <- vapply(x.sp, `[`, "", 2)
  if (any(iN <- is.na(A.))) 
    A.[iN] <- ""
  if (nzchar(big.mark) && length(i.big <- grep(paste0("[0-9]{", big.interval + 1, ",}"), B.))) {
    revStr <- function(cc) vapply(lapply(strsplit(cc, NULL), rev), paste, "", collapse = "")
    B.[i.big] <- revStr(gsub(paste0("([0-9]{", big.interval, "})\\B"), paste0("\\1", revStr(big.mark)), revStr(B.[i.big])))
  }
  if (nzchar(small.mark) && length(i.sml <- grep(paste0("[0-9]{", small.interval + 1, ",}"), A.))) {
    A.[i.sml] <- gsub(paste0("([0-9]{", small.interval, "}\\B)"), paste0("\\1", small.mark), A.[i.sml])
  }
  if (drop0trailing) {
    a <- A.[!iN]
    if (length(hasE <- grep("e", a, fixed = TRUE))) {
      a[hasE] <- sub("e[+-]0+$", "", a[hasE])
      a[-hasE] <- sub("0+$", "", a[-hasE])
    }
    else a <- sub("0+$", "", a)
    A.[!iN] <- a
    iN <- !nzchar(A.)
  }
  A. <- .format.zeros(paste0(B., c(decimal.mark, "")[iN + 1], A.), zero.print, replace = replace.zero)
  if (preserve.width != "none") {
    nnc <- nchar(A., "c")
    d.len <- nnc - nchar(x, "c")
    if (any(ii <- d.len > 0)) {
      switch(preserve.width, individual = {
        A.[ii] <- vapply(which(ii), function(i) sub(sprintf("^ {1,%d}", d.len[i]), "", A.[i]), "")
      }, common = {
        A. <- format(A., justify = "right")
      })
    }
  }
  attributes(A.) <- attributes(x)
  class(A.) <- NULL
  A.
}, function (x, big.mark = "", big.interval = 3, small.mark = "", small.interval = 5, decimal.mark = getOption("OutDec"), input.d.mark = decimal.mark, preserve.width = c("common", "individual", "none"), zero.print = NULL, replace.zero = FALSE, drop0trailing = FALSE, is.cmplx = NA, ...) 
{
  if (notChar <- !is.character(x)) {
    is.cmplx <- is.complex(x)
    x <- vapply(x, format, "", big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, zero.print = zero.print, drop0trailing = drop0trailing, ...)
  }
  nMark <- big.mark == "" && small.mark == "" && (notChar || decimal.mark == input.d.mark)
  if (identical(big.mark, decimal.mark)) 
    warning(gettextf("'big.mark' and 'decimal.mark' are both '%s', which could be confusing", big.mark), domain = NA)
  nZero <- is.null(zero.print) && !drop0trailing
  if (nMark && nZero) 
    return(x)
  if (nMark && !drop0trailing) 
    return(.format.zeros(x, zero.print, replace = replace.zero))
  if (is.na(is.cmplx)) {
    ina <- is.na(x) | x == "NA"
    is.cmplx <- if (all(ina)) 
      FALSE
    else any(grepl("[0-9].*[-+][0-9].*i$", x))
  }
  preserve.width <- match.arg(preserve.width)
  if (is.cmplx) {
    x <- .format.zeros(x, zero.print, replace = replace.zero)
    z.sp <- strsplit(sub("([0-9] *)([-+])( *[0-9])", "\\1::\\2::\\3", x), "::", fixed = TRUE)
    i3 <- lengths(z.sp) == 3
    if (any(i3)) {
      z.sp <- z.sp[i3]
      z.im <- vapply(z.sp, `[[`, "", 3)
      has.i <- grep("i$", z.im)
      z.im[has.i] <- sub("i$", "", z.im[has.i])
      r <- lapply(list(vapply(z.sp, `[[`, "", 1), z.im), function(.) prettyNum(., big.mark = big.mark, big.interval = big.interval, small.mark = small.mark, small.interval = small.interval, decimal.mark = decimal.mark, input.d.mark = input.d.mark, preserve.width = preserve.width, zero.print = zero.print, replace.zero = replace.zero, drop0trailing = drop0trailing, is.cmplx = FALSE, ...))
      r[[2]][has.i] <- paste0(r[[2]][has.i], "i")
      x[i3] <- paste0(r[[1]], vapply(z.sp, `[[`, "", 2), r[[2]])
    }
    return(x)
  }
  if (nchar(input.d.mark) == 0) 
    stop("'input.d.mark' has no characters")
  x.sp <- strsplit(x, input.d.mark, fixed = TRUE)
  if (any(lengths(x.sp) > 2)) {
    x.sp <- lapply(x.sp, function(xs) {
      lx <- length(xs)
      if (lx <= 2) 
        xs
      else c(paste(xs[-lx], collapse = input.d.mark), xs[lx])
    })
  }
  B. <- vapply(x.sp, `[`, "", 1)
  A. <- vapply(x.sp, `[`, "", 2)
  if (any(iN <- is.na(A.))) 
    A.[iN] <- ""
  if (nzchar(big.mark) && length(i.big <- grep(paste0("[0-9]{", big.interval + 1, ",}"), B.))) {
    revStr <- function(cc) vapply(lapply(strsplit(cc, NULL), rev), paste, "", collapse = "")
    B.[i.big] <- revStr(gsub(paste0("([0-9]{", big.interval, "})\\B"), paste0("\\1", revStr(big.mark)), revStr(B.[i.big])))
  }
  if (nzchar(small.mark) && length(i.sml <- grep(paste0("[0-9]{", small.interval + 1, ",}"), A.))) {
    A.[i.sml] <- gsub(paste0("([0-9]{", small.interval, "}\\B)"), paste0("\\1", small.mark), A.[i.sml])
  }
  if (drop0trailing) {
    a <- A.[!iN]
    if (length(hasE <- grep("e", a, fixed = TRUE))) {
      a[hasE] <- sub("e[+-]0+$", "", a[hasE])
      a[-hasE] <- sub("0+$", "", a[-hasE])
    }
    else a <- sub("0+$", "", a)
    A.[!iN] <- a
    iN <- !nzchar(A.)
  }
  A. <- .format.zeros(paste0(B., c(decimal.mark, "")[iN + 1], A.), zero.print, replace = replace.zero)
  if (preserve.width != "none") {
    nnc <- nchar(A., "c")
    d.len <- nnc - nchar(x, "c")
    if (any(ii <- d.len > 0)) {
      switch(preserve.width, individual = {
        A.[ii] <- vapply(which(ii), function(i) sub(sprintf("^ {1,%d}", d.len[i]), "", A.[i]), "")
      }, common = {
        A. <- format(A., justify = "right")
      })
    }
  }
  attributes(A.) <- attributes(x)
  class(A.) <- NULL
  A.
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
print
list(`package:base` = function (x, ...) 
  UseMethod("print"), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("print"), generic = "print", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
      UseMethod("print"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "print"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("print"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "print"))(x, ...)), function (x, ...) 
          UseMethod("print"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
print.AsIs
list(`package:base` = function (x, ...) 
{
  cl <- oldClass(x)
  oldClass(x) <- cl[cl != "AsIs"]
  NextMethod("print")
  invisible(x)
}, function (x, ...) 
{
  cl <- oldClass(x)
  oldClass(x) <- cl[cl != "AsIs"]
  NextMethod("print")
  invisible(x)
}, function (x, ...) 
{
  cl <- oldClass(x)
  oldClass(x) <- cl[cl != "AsIs"]
  NextMethod("print")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.by
list(`package:base` = function (x, ..., vsep) 
{
  d <- dim(x)
  dn <- dimnames(x)
  dnn <- names(dn)
  if (missing(vsep)) 
    vsep <- strrep("-", 0.75 * getOption("width"))
  lapply(X = seq_along(x), FUN = function(i, x, vsep, ...) {
    if (i != 1 && !is.null(vsep)) 
      cat(vsep, "\n")
    ii <- i - 1
    for (j in seq_along(dn)) {
      iii <- ii%%d[j] + 1
      ii <- ii%/%d[j]
      cat(dnn[j], ": ", dn[[j]][iii], "\n", sep = "")
    }
    print(x[[i]], ...)
  }, x, vsep, ...)
  invisible(x)
}, function (x, ..., vsep) 
{
  d <- dim(x)
  dn <- dimnames(x)
  dnn <- names(dn)
  if (missing(vsep)) 
    vsep <- strrep("-", 0.75 * getOption("width"))
  lapply(X = seq_along(x), FUN = function(i, x, vsep, ...) {
    if (i != 1 && !is.null(vsep)) 
      cat(vsep, "\n")
    ii <- i - 1
    for (j in seq_along(dn)) {
      iii <- ii%%d[j] + 1
      ii <- ii%/%d[j]
      cat(dnn[j], ": ", dn[[j]][iii], "\n", sep = "")
    }
    print(x[[i]], ...)
  }, x, vsep, ...)
  invisible(x)
}, function (x, ..., vsep) 
{
  d <- dim(x)
  dn <- dimnames(x)
  dnn <- names(dn)
  if (missing(vsep)) 
    vsep <- strrep("-", 0.75 * getOption("width"))
  lapply(X = seq_along(x), FUN = function(i, x, vsep, ...) {
    if (i != 1 && !is.null(vsep)) 
      cat(vsep, "\n")
    ii <- i - 1
    for (j in seq_along(dn)) {
      iii <- ii%%d[j] + 1
      ii <- ii%/%d[j]
      cat(dnn[j], ": ", dn[[j]][iii], "\n", sep = "")
    }
    print(x[[i]], ...)
  }, x, vsep, ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.condition
list(`package:base` = function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  cl <- class(x)[1]
  if (!is.null(call)) 
    cat("<", cl, " in ", deparse(call), ": ", msg, ">\n", sep = "")
  else cat("<", cl, ": ", msg, ">\n", sep = "")
  invisible(x)
}, function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  cl <- class(x)[1]
  if (!is.null(call)) 
    cat("<", cl, " in ", deparse(call), ": ", msg, ">\n", sep = "")
  else cat("<", cl, ": ", msg, ">\n", sep = "")
  invisible(x)
}, function (x, ...) 
{
  msg <- conditionMessage(x)
  call <- conditionCall(x)
  cl <- class(x)[1]
  if (!is.null(call)) 
    cat("<", cl, " in ", deparse(call), ": ", msg, ">\n", sep = "")
  else cat("<", cl, ": ", msg, ">\n", sep = "")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.connection
list(`package:base` = function (x, ...) 
{
  usumm <- tryCatch(unlist(summary(x)), error = function(e) {
  })
  if (is.null(usumm)) {
    cl <- oldClass(x)
    cl <- cl[cl != "connection"]
    cat("A connection, ", if (length(cl)) 
      paste0("specifically, ", paste(sQuote(cl), collapse = ", "), ", "), "but invalid.\n", sep = "")
  }
  else {
    cat("A connection with")
    print(cbind(` ` = usumm), ...)
  }
  invisible(x)
}, function (x, ...) 
{
  usumm <- tryCatch(unlist(summary(x)), error = function(e) {
  })
  if (is.null(usumm)) {
    cl <- oldClass(x)
    cl <- cl[cl != "connection"]
    cat("A connection, ", if (length(cl)) 
      paste0("specifically, ", paste(sQuote(cl), collapse = ", "), ", "), "but invalid.\n", sep = "")
  }
  else {
    cat("A connection with")
    print(cbind(` ` = usumm), ...)
  }
  invisible(x)
}, function (x, ...) 
{
  usumm <- tryCatch(unlist(summary(x)), error = function(e) {
  })
  if (is.null(usumm)) {
    cl <- oldClass(x)
    cl <- cl[cl != "connection"]
    cat("A connection, ", if (length(cl)) 
      paste0("specifically, ", paste(sQuote(cl), collapse = ", "), ", "), "but invalid.\n", sep = "")
  }
  else {
    cat("A connection with")
    print(cbind(` ` = usumm), ...)
  }
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.data.frame
list(`package:base` = function (x, ..., digits = NULL, quote = FALSE, right = TRUE, row.names = TRUE, max = NULL) 
{
  n <- length(row.names(x))
  if (length(x) == 0) {
    cat(sprintf(ngettext(n, "data frame with 0 columns and %d row", "data frame with 0 columns and %d rows"), n), "\n", sep = "")
  }
  else if (n == 0) {
    print.default(names(x), quote = FALSE)
    cat(gettext("<0 rows> (or 0-length row.names)\n"))
  }
  else {
    if (is.null(max)) 
      max <- getOption("max.print", 99999)
    if (!is.finite(max)) 
      stop("invalid 'max' / getOption(\"max.print\"): ", max)
    omit <- (n0 <- max%/%length(x)) < n
    m <- as.matrix(format.data.frame(if (omit) 
      x[seq_len(n0), , drop = FALSE]
      else x, digits = digits, na.encode = FALSE))
    if (!isTRUE(row.names)) 
      dimnames(m)[[1]] <- if (isFALSE(row.names)) 
        rep.int("", if (omit) 
          n0
          else n)
    else row.names
    print(m, ..., quote = quote, right = right, max = max)
    if (omit) 
      cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", n - n0, "rows ]\n")
  }
  invisible(x)
}, function (x, ..., digits = NULL, quote = FALSE, right = TRUE, row.names = TRUE, max = NULL) 
{
  n <- length(row.names(x))
  if (length(x) == 0) {
    cat(sprintf(ngettext(n, "data frame with 0 columns and %d row", "data frame with 0 columns and %d rows"), n), "\n", sep = "")
  }
  else if (n == 0) {
    print.default(names(x), quote = FALSE)
    cat(gettext("<0 rows> (or 0-length row.names)\n"))
  }
  else {
    if (is.null(max)) 
      max <- getOption("max.print", 99999)
    if (!is.finite(max)) 
      stop("invalid 'max' / getOption(\"max.print\"): ", max)
    omit <- (n0 <- max%/%length(x)) < n
    m <- as.matrix(format.data.frame(if (omit) 
      x[seq_len(n0), , drop = FALSE]
      else x, digits = digits, na.encode = FALSE))
    if (!isTRUE(row.names)) 
      dimnames(m)[[1]] <- if (isFALSE(row.names)) 
        rep.int("", if (omit) 
          n0
          else n)
    else row.names
    print(m, ..., quote = quote, right = right, max = max)
    if (omit) 
      cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", n - n0, "rows ]\n")
  }
  invisible(x)
}, function (x, ..., digits = NULL, quote = FALSE, right = TRUE, row.names = TRUE, max = NULL) 
{
  n <- length(row.names(x))
  if (length(x) == 0) {
    cat(sprintf(ngettext(n, "data frame with 0 columns and %d row", "data frame with 0 columns and %d rows"), n), "\n", sep = "")
  }
  else if (n == 0) {
    print.default(names(x), quote = FALSE)
    cat(gettext("<0 rows> (or 0-length row.names)\n"))
  }
  else {
    if (is.null(max)) 
      max <- getOption("max.print", 99999)
    if (!is.finite(max)) 
      stop("invalid 'max' / getOption(\"max.print\"): ", max)
    omit <- (n0 <- max%/%length(x)) < n
    m <- as.matrix(format.data.frame(if (omit) 
      x[seq_len(n0), , drop = FALSE]
      else x, digits = digits, na.encode = FALSE))
    if (!isTRUE(row.names)) 
      dimnames(m)[[1]] <- if (isFALSE(row.names)) 
        rep.int("", if (omit) 
          n0
          else n)
    else row.names
    print(m, ..., quote = quote, right = right, max = max)
    if (omit) 
      cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", n - n0, "rows ]\n")
  }
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.Date
list(`package:base` = function (x, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  if (max < length(x)) {
    print(format(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(format(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
}, function (x, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  if (max < length(x)) {
    print(format(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(format(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
}, function (x, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  if (max < length(x)) {
    print(format(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(format(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.default
list(`package:base` = function (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, right = FALSE, max = NULL, width = NULL, useSource = TRUE, ...) 
{
  args <- pairlist(digits = digits, quote = quote, na.print = na.print, print.gap = print.gap, right = right, max = max, width = width, useSource = useSource, ...)
  missings <- c(missing(digits), missing(quote), missing(na.print), missing(print.gap), missing(right), missing(max), missing(width), missing(useSource))
  .Internal(print.default(x, args, missings))
}, function (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, right = FALSE, max = NULL, width = NULL, useSource = TRUE, ...) 
{
  args <- pairlist(digits = digits, quote = quote, na.print = na.print, print.gap = print.gap, right = right, max = max, width = width, useSource = useSource, ...)
  missings <- c(missing(digits), missing(quote), missing(na.print), missing(print.gap), missing(right), missing(max), missing(width), missing(useSource))
  .Internal(print.default(x, args, missings))
}, function (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, right = FALSE, max = NULL, width = NULL, useSource = TRUE, ...) 
{
  args <- pairlist(digits = digits, quote = quote, na.print = na.print, print.gap = print.gap, right = right, max = max, width = width, useSource = useSource, ...)
  missings <- c(missing(digits), missing(quote), missing(na.print), missing(print.gap), missing(right), missing(max), missing(width), missing(useSource))
  .Internal(print.default(x, args, missings))
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.difftime
list(`package:base` = function (x, digits = getOption("digits"), ...) 
{
  if (is.array(x) || length(x) > 1) {
    cat("Time differences in ", attr(x, "units"), "\n", sep = "")
    y <- unclass(x)
    attr(y, "units") <- NULL
    print(y, digits = digits, ...)
  }
  else cat("Time difference of ", format(unclass(x), digits = digits), " ", attr(x, "units"), "\n", sep = "")
  invisible(x)
}, function (x, digits = getOption("digits"), ...) 
{
  if (is.array(x) || length(x) > 1) {
    cat("Time differences in ", attr(x, "units"), "\n", sep = "")
    y <- unclass(x)
    attr(y, "units") <- NULL
    print(y, digits = digits, ...)
  }
  else cat("Time difference of ", format(unclass(x), digits = digits), " ", attr(x, "units"), "\n", sep = "")
  invisible(x)
}, function (x, digits = getOption("digits"), ...) 
{
  if (is.array(x) || length(x) > 1) {
    cat("Time differences in ", attr(x, "units"), "\n", sep = "")
    y <- unclass(x)
    attr(y, "units") <- NULL
    print(y, digits = digits, ...)
  }
  else cat("Time difference of ", format(unclass(x), digits = digits), " ", attr(x, "units"), "\n", sep = "")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.Dlist
list(`package:base` = function (x, ...) 
{
  if (!is.list(x) && !is.matrix(x) && is.null(names(x))) 
    return(NextMethod())
  cat(formatDL(x, ...), sep = "\n")
  invisible(x)
}, function (x, ...) 
{
  if (!is.list(x) && !is.matrix(x) && is.null(names(x))) 
    return(NextMethod())
  cat(formatDL(x, ...), sep = "\n")
  invisible(x)
}, function (x, ...) 
{
  if (!is.list(x) && !is.matrix(x) && is.null(names(x))) 
    return(NextMethod())
  cat(formatDL(x, ...), sep = "\n")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.DLLInfo
list(`package:base` = function (x, ...) 
{
  tmp <- as.data.frame.list(x[c("name", "path", "dynamicLookup")])
  names(tmp) <- c("DLL name", "Filename", "Dynamic lookup")
  write.dcf(tmp, ...)
  invisible(x)
}, function (x, ...) 
{
  tmp <- as.data.frame.list(x[c("name", "path", "dynamicLookup")])
  names(tmp) <- c("DLL name", "Filename", "Dynamic lookup")
  write.dcf(tmp, ...)
  invisible(x)
}, function (x, ...) 
{
  tmp <- as.data.frame.list(x[c("name", "path", "dynamicLookup")])
  names(tmp) <- c("DLL name", "Filename", "Dynamic lookup")
  write.dcf(tmp, ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.DLLInfoList
list(`package:base` = function (x, ...) 
{
  if (length(x)) {
    m <- data.frame(Filename = sapply(x, function(x) x[["path"]]), `Dynamic Lookup` = sapply(x, function(x) x[["dynamicLookup"]]))
    print(m, ...)
  }
  invisible(x)
}, function (x, ...) 
{
  if (length(x)) {
    m <- data.frame(Filename = sapply(x, function(x) x[["path"]]), `Dynamic Lookup` = sapply(x, function(x) x[["dynamicLookup"]]))
    print(m, ...)
  }
  invisible(x)
}, function (x, ...) 
{
  if (length(x)) {
    m <- data.frame(Filename = sapply(x, function(x) x[["path"]]), `Dynamic Lookup` = sapply(x, function(x) x[["dynamicLookup"]]))
    print(m, ...)
  }
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.DLLRegisteredRoutines
list(`package:base` = function (x, ...) 
{
  n <- lengths(x)
  x <- x[n > 0]
  n <- max(n)
  d <- list()
  sapply(names(x), function(id) {
    d[[id]] <<- rep.int("", n)
    names <- vapply(x[[id]], function(x) x$name, "")
    if (length(names)) 
      d[[id]][seq_along(names)] <<- names
    d[[paste(id, "numParameters")]] <<- rep.int("", n)
    names <- sapply(x[[id]], function(x) x$numParameters)
    if (length(names)) 
      d[[paste(id, "numParameters")]][seq_along(names)] <<- names
  })
  print(as.data.frame(d), ...)
  invisible(x)
}, function (x, ...) 
{
  n <- lengths(x)
  x <- x[n > 0]
  n <- max(n)
  d <- list()
  sapply(names(x), function(id) {
    d[[id]] <<- rep.int("", n)
    names <- vapply(x[[id]], function(x) x$name, "")
    if (length(names)) 
      d[[id]][seq_along(names)] <<- names
    d[[paste(id, "numParameters")]] <<- rep.int("", n)
    names <- sapply(x[[id]], function(x) x$numParameters)
    if (length(names)) 
      d[[paste(id, "numParameters")]][seq_along(names)] <<- names
  })
  print(as.data.frame(d), ...)
  invisible(x)
}, function (x, ...) 
{
  n <- lengths(x)
  x <- x[n > 0]
  n <- max(n)
  d <- list()
  sapply(names(x), function(id) {
    d[[id]] <<- rep.int("", n)
    names <- vapply(x[[id]], function(x) x$name, "")
    if (length(names)) 
      d[[id]][seq_along(names)] <<- names
    d[[paste(id, "numParameters")]] <<- rep.int("", n)
    names <- sapply(x[[id]], function(x) x$numParameters)
    if (length(names)) 
      d[[paste(id, "numParameters")]][seq_along(names)] <<- names
  })
  print(as.data.frame(d), ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.eigen
list(`package:base` = function (x, ...) 
{
  cat("eigen() decomposition\n")
  print(unclass(x), ...)
  invisible(x)
}, function (x, ...) 
{
  cat("eigen() decomposition\n")
  print(unclass(x), ...)
  invisible(x)
}, function (x, ...) 
{
  cat("eigen() decomposition\n")
  print(unclass(x), ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.factor
list(`package:base` = function (x, quote = FALSE, max.levels = NULL, width = getOption("width"), ...) 
{
  ord <- is.ordered(x)
  if (length(x) == 0) 
    cat(if (ord) 
      "ordered"
      else "factor", "(0)\n", sep = "")
  else {
    xx <- character(length(x))
    xx[] <- as.character(x)
    keepAttrs <- setdiff(names(attributes(x)), c("levels", "class"))
    attributes(xx)[keepAttrs] <- attributes(x)[keepAttrs]
    print(xx, quote = quote, ...)
  }
  maxl <- if (is.null(max.levels)) 
    TRUE
  else max.levels
  if (maxl) {
    n <- length(lev <- encodeString(levels(x), quote = ifelse(quote, "\"", "")))
    colsep <- if (ord) 
      " < "
    else " "
    T0 <- "Levels: "
    if (is.logical(maxl)) 
      maxl <- {
        width <- width - (nchar(T0, "w") + 3 + 1 + 3)
        lenl <- cumsum(nchar(lev, "w") + nchar(colsep, "w"))
        if (n <= 1 || lenl[n] <= width) 
          n
        else max(1, which.max(lenl > width) - 1)
      }
    drop <- n > maxl
    cat(if (drop) 
      paste(format(n), ""), T0, paste(if (drop) 
        c(lev[1:max(1, maxl - 1)], "...", if (maxl > 1) lev[n])
        else lev, collapse = colsep), "\n", sep = "")
  }
  if (!isTRUE(val <- .valid.factor(x))) 
    warning(val)
  invisible(x)
}, function (x, quote = FALSE, max.levels = NULL, width = getOption("width"), ...) 
{
  ord <- is.ordered(x)
  if (length(x) == 0) 
    cat(if (ord) 
      "ordered"
      else "factor", "(0)\n", sep = "")
  else {
    xx <- character(length(x))
    xx[] <- as.character(x)
    keepAttrs <- setdiff(names(attributes(x)), c("levels", "class"))
    attributes(xx)[keepAttrs] <- attributes(x)[keepAttrs]
    print(xx, quote = quote, ...)
  }
  maxl <- if (is.null(max.levels)) 
    TRUE
  else max.levels
  if (maxl) {
    n <- length(lev <- encodeString(levels(x), quote = ifelse(quote, "\"", "")))
    colsep <- if (ord) 
      " < "
    else " "
    T0 <- "Levels: "
    if (is.logical(maxl)) 
      maxl <- {
        width <- width - (nchar(T0, "w") + 3 + 1 + 3)
        lenl <- cumsum(nchar(lev, "w") + nchar(colsep, "w"))
        if (n <= 1 || lenl[n] <= width) 
          n
        else max(1, which.max(lenl > width) - 1)
      }
    drop <- n > maxl
    cat(if (drop) 
      paste(format(n), ""), T0, paste(if (drop) 
        c(lev[1:max(1, maxl - 1)], "...", if (maxl > 1) lev[n])
        else lev, collapse = colsep), "\n", sep = "")
  }
  if (!isTRUE(val <- .valid.factor(x))) 
    warning(val)
  invisible(x)
}, function (x, quote = FALSE, max.levels = NULL, width = getOption("width"), ...) 
{
  ord <- is.ordered(x)
  if (length(x) == 0) 
    cat(if (ord) 
      "ordered"
      else "factor", "(0)\n", sep = "")
  else {
    xx <- character(length(x))
    xx[] <- as.character(x)
    keepAttrs <- setdiff(names(attributes(x)), c("levels", "class"))
    attributes(xx)[keepAttrs] <- attributes(x)[keepAttrs]
    print(xx, quote = quote, ...)
  }
  maxl <- if (is.null(max.levels)) 
    TRUE
  else max.levels
  if (maxl) {
    n <- length(lev <- encodeString(levels(x), quote = ifelse(quote, "\"", "")))
    colsep <- if (ord) 
      " < "
    else " "
    T0 <- "Levels: "
    if (is.logical(maxl)) 
      maxl <- {
        width <- width - (nchar(T0, "w") + 3 + 1 + 3)
        lenl <- cumsum(nchar(lev, "w") + nchar(colsep, "w"))
        if (n <= 1 || lenl[n] <= width) 
          n
        else max(1, which.max(lenl > width) - 1)
      }
    drop <- n > maxl
    cat(if (drop) 
      paste(format(n), ""), T0, paste(if (drop) 
        c(lev[1:max(1, maxl - 1)], "...", if (maxl > 1) lev[n])
        else lev, collapse = colsep), "\n", sep = "")
  }
  if (!isTRUE(val <- .valid.factor(x))) 
    warning(val)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.function
list(`package:base` = function (x, useSource = TRUE, ...) 
  print.default(x, useSource = useSource, ...), function (x, useSource = TRUE, ...) 
    print.default(x, useSource = useSource, ...), function (x, useSource = TRUE, ...) 
      print.default(x, useSource = useSource, ...))
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.hexmode
list(`package:base` = function (x, ...) 
{
  print(format(x), ...)
  invisible(x)
}, function (x, ...) 
{
  print(format(x), ...)
  invisible(x)
}, function (x, ...) 
{
  print(format(x), ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.libraryIQR
list(`package:base` = function (x, ...) 
{
  s <- format(x)
  if (!length(s)) {
    message("no packages found")
  }
  else {
    outFile <- tempfile("RlibraryIQR")
    writeLines(s, outFile)
    file.show(outFile, delete.file = TRUE, title = gettext("R packages available"))
  }
  invisible(x)
}, function (x, ...) 
{
  s <- format(x)
  if (!length(s)) {
    message("no packages found")
  }
  else {
    outFile <- tempfile("RlibraryIQR")
    writeLines(s, outFile)
    file.show(outFile, delete.file = TRUE, title = gettext("R packages available"))
  }
  invisible(x)
}, function (x, ...) 
{
  s <- format(x)
  if (!length(s)) {
    message("no packages found")
  }
  else {
    outFile <- tempfile("RlibraryIQR")
    writeLines(s, outFile)
    file.show(outFile, delete.file = TRUE, title = gettext("R packages available"))
  }
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.listof
list(`package:base` = function (x, ...) 
{
  nn <- names(x)
  ll <- length(x)
  if (length(nn) != ll) 
    nn <- paste("Component", seq.int(ll))
  for (i in seq_len(ll)) {
    cat(nn[i], ":\n")
    print(x[[i]], ...)
    cat("\n")
  }
  invisible(x)
}, function (x, ...) 
{
  nn <- names(x)
  ll <- length(x)
  if (length(nn) != ll) 
    nn <- paste("Component", seq.int(ll))
  for (i in seq_len(ll)) {
    cat(nn[i], ":\n")
    print(x[[i]], ...)
    cat("\n")
  }
  invisible(x)
}, function (x, ...) 
{
  nn <- names(x)
  ll <- length(x)
  if (length(nn) != ll) 
    nn <- paste("Component", seq.int(ll))
  for (i in seq_len(ll)) {
    cat(nn[i], ":\n")
    print(x[[i]], ...)
    cat("\n")
  }
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.NativeRoutineList
list(`package:base` = function (x, ...) 
{
  if (length(x)) {
    m <- data.frame(numParameters = sapply(x, function(x) x$numParameters), row.names = sapply(x, function(x) x$name))
    print(m, ...)
  }
  invisible(x)
}, function (x, ...) 
{
  if (length(x)) {
    m <- data.frame(numParameters = sapply(x, function(x) x$numParameters), row.names = sapply(x, function(x) x$name))
    print(m, ...)
  }
  invisible(x)
}, function (x, ...) 
{
  if (length(x)) {
    m <- data.frame(numParameters = sapply(x, function(x) x$numParameters), row.names = sapply(x, function(x) x$name))
    print(m, ...)
  }
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.noquote
list(`package:base` = function (x, quote = FALSE, right = FALSE, ...) 
{
  if (copy <- !is.null(cl <- attr(x, "class"))) {
    isNQ <- cl == "noquote"
    if (missing(right)) 
      right <- any("right" == names(cl[isNQ]))
    if (copy <- any(isNQ)) {
      ox <- x
      cl <- cl[!isNQ]
      attr(x, "class") <- if (length(cl)) 
        cl
    }
  }
  print(x, quote = quote, right = right, ...)
  invisible(if (copy) ox else x)
}, function (x, quote = FALSE, right = FALSE, ...) 
{
  if (copy <- !is.null(cl <- attr(x, "class"))) {
    isNQ <- cl == "noquote"
    if (missing(right)) 
      right <- any("right" == names(cl[isNQ]))
    if (copy <- any(isNQ)) {
      ox <- x
      cl <- cl[!isNQ]
      attr(x, "class") <- if (length(cl)) 
        cl
    }
  }
  print(x, quote = quote, right = right, ...)
  invisible(if (copy) ox else x)
}, function (x, quote = FALSE, right = FALSE, ...) 
{
  if (copy <- !is.null(cl <- attr(x, "class"))) {
    isNQ <- cl == "noquote"
    if (missing(right)) 
      right <- any("right" == names(cl[isNQ]))
    if (copy <- any(isNQ)) {
      ox <- x
      cl <- cl[!isNQ]
      attr(x, "class") <- if (length(cl)) 
        cl
    }
  }
  print(x, quote = quote, right = right, ...)
  invisible(if (copy) ox else x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.numeric_version
list(`package:base` = function (x, quote = FALSE, ...) 
{
  y <- as.character(x)
  if (!length(y)) 
    writeLines(gettext("<0 elements>"))
  else print(ifelse(is.na(y), NA, sQuote(y)), quote = quote, ...)
  invisible(x)
}, function (x, quote = FALSE, ...) 
{
  y <- as.character(x)
  if (!length(y)) 
    writeLines(gettext("<0 elements>"))
  else print(ifelse(is.na(y), NA, sQuote(y)), quote = quote, ...)
  invisible(x)
}, function (x, quote = FALSE, ...) 
{
  y <- as.character(x)
  if (!length(y)) 
    writeLines(gettext("<0 elements>"))
  else print(ifelse(is.na(y), NA, sQuote(y)), quote = quote, ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.octmode
list(`package:base` = function (x, ...) 
{
  print(format(x), ...)
  invisible(x)
}, function (x, ...) 
{
  print(format(x), ...)
  invisible(x)
}, function (x, ...) 
{
  print(format(x), ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.packageInfo
list(`package:base` = function (x, ...) 
{
  outFile <- tempfile("RpackageInfo")
  writeLines(format(x), outFile)
  file.show(outFile, delete.file = TRUE, title = gettextf("Documentation for package %s", sQuote(x$name)))
  invisible(x)
}, function (x, ...) 
{
  outFile <- tempfile("RpackageInfo")
  writeLines(format(x), outFile)
  file.show(outFile, delete.file = TRUE, title = gettextf("Documentation for package %s", sQuote(x$name)))
  invisible(x)
}, function (x, ...) 
{
  outFile <- tempfile("RpackageInfo")
  writeLines(format(x), outFile)
  file.show(outFile, delete.file = TRUE, title = gettextf("Documentation for package %s", sQuote(x$name)))
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.POSIXct
list(`package:base` = function (x, tz = "", usetz = TRUE, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  FORM <- if (missing(tz)) 
    function(z) format(z, usetz = usetz)
  else function(z) format(z, tz = tz, usetz = usetz)
  if (max < length(x)) {
    print(FORM(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(FORM(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
}, function (x, tz = "", usetz = TRUE, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  FORM <- if (missing(tz)) 
    function(z) format(z, usetz = usetz)
  else function(z) format(z, tz = tz, usetz = usetz)
  if (max < length(x)) {
    print(FORM(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(FORM(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
}, function (x, tz = "", usetz = TRUE, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  FORM <- if (missing(tz)) 
    function(z) format(z, usetz = usetz)
  else function(z) format(z, tz = tz, usetz = usetz)
  if (max < length(x)) {
    print(FORM(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(FORM(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.POSIXlt
list(`package:base` = function (x, tz = "", usetz = TRUE, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  FORM <- if (missing(tz)) 
    function(z) format(z, usetz = usetz)
  else function(z) format(z, tz = tz, usetz = usetz)
  if (max < length(x)) {
    print(FORM(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(FORM(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
}, function (x, tz = "", usetz = TRUE, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  FORM <- if (missing(tz)) 
    function(z) format(z, usetz = usetz)
  else function(z) format(z, tz = tz, usetz = usetz)
  if (max < length(x)) {
    print(FORM(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(FORM(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
}, function (x, tz = "", usetz = TRUE, max = NULL, ...) 
{
  if (is.null(max)) 
    max <- getOption("max.print", 9999)
  FORM <- if (missing(tz)) 
    function(z) format(z, usetz = usetz)
  else function(z) format(z, tz = tz, usetz = usetz)
  if (max < length(x)) {
    print(FORM(x[seq_len(max)]), max = max + 1, ...)
    cat(" [ reached 'max' / getOption(\"max.print\") -- omitted", length(x) - max, "entries ]\n")
  }
  else if (length(x)) 
    print(FORM(x), max = max, ...)
  else cat(class(x)[1], "of length 0\n")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.proc_time
list(`package:base` = function (x, ...) 
{
  print(summary(x, ...))
  invisible(x)
}, function (x, ...) 
{
  print(summary(x, ...))
  invisible(x)
}, function (x, ...) 
{
  print(summary(x, ...))
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.restart
list(`package:base` = function (x, ...) 
{
  cat(paste("<restart:", x[[1]], ">\n"))
  invisible(x)
}, function (x, ...) 
{
  cat(paste("<restart:", x[[1]], ">\n"))
  invisible(x)
}, function (x, ...) 
{
  cat(paste("<restart:", x[[1]], ">\n"))
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.rle
list(`package:base` = function (x, digits = getOption("digits"), prefix = "", ...) 
{
  if (is.null(digits)) 
    digits <- getOption("digits")
  cat("", "Run Length Encoding\n", "  lengths:", sep = prefix)
  utils::str(x$lengths)
  cat("", "  values :", sep = prefix)
  utils::str(x$values, digits.d = digits)
  invisible(x)
}, function (x, digits = getOption("digits"), prefix = "", ...) 
{
  if (is.null(digits)) 
    digits <- getOption("digits")
  cat("", "Run Length Encoding\n", "  lengths:", sep = prefix)
  utils::str(x$lengths)
  cat("", "  values :", sep = prefix)
  utils::str(x$values, digits.d = digits)
  invisible(x)
}, function (x, digits = getOption("digits"), prefix = "", ...) 
{
  if (is.null(digits)) 
    digits <- getOption("digits")
  cat("", "Run Length Encoding\n", "  lengths:", sep = prefix)
  utils::str(x$lengths)
  cat("", "  values :", sep = prefix)
  utils::str(x$values, digits.d = digits)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.simple.list
list(`package:base` = function (x, ...) 
  print(noquote(cbind(`_` = unlist(x))), ...), function (x, ...) 
    print(noquote(cbind(`_` = unlist(x))), ...), function (x, ...) 
      print(noquote(cbind(`_` = unlist(x))), ...))
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.srcfile
list(`package:base` = function (x, ...) 
{
  cat(x$filename, "\n")
  invisible(x)
}, function (x, ...) 
{
  cat(x$filename, "\n")
  invisible(x)
}, function (x, ...) 
{
  cat(x$filename, "\n")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.srcref
list(`package:base` = function (x, useSource = TRUE, ...) 
{
  cat(as.character(x, useSource = useSource), sep = "\n")
  invisible(x)
}, function (x, useSource = TRUE, ...) 
{
  cat(as.character(x, useSource = useSource), sep = "\n")
  invisible(x)
}, function (x, useSource = TRUE, ...) 
{
  cat(as.character(x, useSource = useSource), sep = "\n")
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.summary.table
list(`package:base` = function (x, digits = max(1, getOption("digits") - 3), ...) 
{
  if (!inherits(x, "summary.table")) 
    stop(gettextf("'x' must inherit from class %s", dQuote("summary.table")), domain = NA)
  if (!is.null(x$call)) {
    cat("Call: ")
    print(x$call)
  }
  cat("Number of cases in table:", x$n.cases, "\n")
  cat("Number of factors:", x$n.vars, "\n")
  if (x$n.vars > 1) {
    cat("Test for independence of all factors:\n")
    ch <- x$statistic
    cat("\tChisq = ", format(round(ch, max(0, digits - log10(ch)))), ", df = ", x$parameter, ", p-value = ", format.pval(x$p.value, digits, eps = 0), "\n", sep = "")
    if (!x$approx.ok) 
      cat("\tChi-squared approximation may be incorrect\n")
  }
  invisible(x)
}, function (x, digits = max(1, getOption("digits") - 3), ...) 
{
  if (!inherits(x, "summary.table")) 
    stop(gettextf("'x' must inherit from class %s", dQuote("summary.table")), domain = NA)
  if (!is.null(x$call)) {
    cat("Call: ")
    print(x$call)
  }
  cat("Number of cases in table:", x$n.cases, "\n")
  cat("Number of factors:", x$n.vars, "\n")
  if (x$n.vars > 1) {
    cat("Test for independence of all factors:\n")
    ch <- x$statistic
    cat("\tChisq = ", format(round(ch, max(0, digits - log10(ch)))), ", df = ", x$parameter, ", p-value = ", format.pval(x$p.value, digits, eps = 0), "\n", sep = "")
    if (!x$approx.ok) 
      cat("\tChi-squared approximation may be incorrect\n")
  }
  invisible(x)
}, function (x, digits = max(1, getOption("digits") - 3), ...) 
{
  if (!inherits(x, "summary.table")) 
    stop(gettextf("'x' must inherit from class %s", dQuote("summary.table")), domain = NA)
  if (!is.null(x$call)) {
    cat("Call: ")
    print(x$call)
  }
  cat("Number of cases in table:", x$n.cases, "\n")
  cat("Number of factors:", x$n.vars, "\n")
  if (x$n.vars > 1) {
    cat("Test for independence of all factors:\n")
    ch <- x$statistic
    cat("\tChisq = ", format(round(ch, max(0, digits - log10(ch)))), ", df = ", x$parameter, ", p-value = ", format.pval(x$p.value, digits, eps = 0), "\n", sep = "")
    if (!x$approx.ok) 
      cat("\tChi-squared approximation may be incorrect\n")
  }
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.summary.warnings
list(`package:base` = function (x, ...) 
{
  n <- length(x)
  cn <- attr(x, "counts")
  if (n == 0) 
    cat("No warnings\n")
  else if (n == 1) 
    print.warnings(x, header = paste(sum(cn), "identical warnings:\n"))
  else print.warnings(x, tags = paste0(format(cn), "x : "), header = gettextf("Summary of (a total of %d) warning messages:\n", sum(cn)))
  invisible(x)
}, function (x, ...) 
{
  n <- length(x)
  cn <- attr(x, "counts")
  if (n == 0) 
    cat("No warnings\n")
  else if (n == 1) 
    print.warnings(x, header = paste(sum(cn), "identical warnings:\n"))
  else print.warnings(x, tags = paste0(format(cn), "x : "), header = gettextf("Summary of (a total of %d) warning messages:\n", sum(cn)))
  invisible(x)
}, function (x, ...) 
{
  n <- length(x)
  cn <- attr(x, "counts")
  if (n == 0) 
    cat("No warnings\n")
  else if (n == 1) 
    print.warnings(x, header = paste(sum(cn), "identical warnings:\n"))
  else print.warnings(x, tags = paste0(format(cn), "x : "), header = gettextf("Summary of (a total of %d) warning messages:\n", sum(cn)))
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.summaryDefault
list(`package:base` = function (x, digits = max(3, getOption("digits") - 3), ...) 
{
  xx <- x
  if (is.numeric(x) || is.complex(x)) {
    finite <- is.finite(x)
    xx[finite] <- zapsmall(x[finite])
  }
  class(xx) <- class(x)[-1]
  m <- match("NA's", names(xx), 0)
  if (inherits(x, "Date") || inherits(x, "POSIXct")) {
    xx <- if (length(a <- attr(x, "NAs"))) 
      c(format(xx, digits = digits), `NA's` = as.character(a))
    else format(xx, digits = digits)
    print(xx, digits = digits, ...)
    return(invisible(x))
  }
  else if (m && !is.character(x)) 
    xx <- c(format(xx[-m], digits = digits), `NA's` = as.character(xx[m]))
  print.table(xx, digits = digits, ...)
  invisible(x)
}, function (x, digits = max(3, getOption("digits") - 3), ...) 
{
  xx <- x
  if (is.numeric(x) || is.complex(x)) {
    finite <- is.finite(x)
    xx[finite] <- zapsmall(x[finite])
  }
  class(xx) <- class(x)[-1]
  m <- match("NA's", names(xx), 0)
  if (inherits(x, "Date") || inherits(x, "POSIXct")) {
    xx <- if (length(a <- attr(x, "NAs"))) 
      c(format(xx, digits = digits), `NA's` = as.character(a))
    else format(xx, digits = digits)
    print(xx, digits = digits, ...)
    return(invisible(x))
  }
  else if (m && !is.character(x)) 
    xx <- c(format(xx[-m], digits = digits), `NA's` = as.character(xx[m]))
  print.table(xx, digits = digits, ...)
  invisible(x)
}, function (x, digits = max(3, getOption("digits") - 3), ...) 
{
  xx <- x
  if (is.numeric(x) || is.complex(x)) {
    finite <- is.finite(x)
    xx[finite] <- zapsmall(x[finite])
  }
  class(xx) <- class(x)[-1]
  m <- match("NA's", names(xx), 0)
  if (inherits(x, "Date") || inherits(x, "POSIXct")) {
    xx <- if (length(a <- attr(x, "NAs"))) 
      c(format(xx, digits = digits), `NA's` = as.character(a))
    else format(xx, digits = digits)
    print(xx, digits = digits, ...)
    return(invisible(x))
  }
  else if (m && !is.character(x)) 
    xx <- c(format(xx[-m], digits = digits), `NA's` = as.character(xx[m]))
  print.table(xx, digits = digits, ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.table
list(`package:base` = function (x, digits = getOption("digits"), quote = FALSE, na.print = "", zero.print = "0", right = is.numeric(x) || is.complex(x), justify = "none", ...) 
{
  d <- dim(x)
  if (any(d == 0)) {
    cat("< table of extent", paste(d, collapse = " x "), ">\n")
    return(invisible(x))
  }
  xx <- format(unclass(x), digits = digits, justify = justify)
  if (any(ina <- is.na(x))) 
    xx[ina] <- na.print
  if (zero.print != "0" && any(i0 <- !ina & x == 0)) 
    xx[i0] <- zero.print
  print(xx, quote = quote, right = right, ...)
  invisible(x)
}, function (x, digits = getOption("digits"), quote = FALSE, na.print = "", zero.print = "0", right = is.numeric(x) || is.complex(x), justify = "none", ...) 
{
  d <- dim(x)
  if (any(d == 0)) {
    cat("< table of extent", paste(d, collapse = " x "), ">\n")
    return(invisible(x))
  }
  xx <- format(unclass(x), digits = digits, justify = justify)
  if (any(ina <- is.na(x))) 
    xx[ina] <- na.print
  if (zero.print != "0" && any(i0 <- !ina & x == 0)) 
    xx[i0] <- zero.print
  print(xx, quote = quote, right = right, ...)
  invisible(x)
}, function (x, digits = getOption("digits"), quote = FALSE, na.print = "", zero.print = "0", right = is.numeric(x) || is.complex(x), justify = "none", ...) 
{
  d <- dim(x)
  if (any(d == 0)) {
    cat("< table of extent", paste(d, collapse = " x "), ">\n")
    return(invisible(x))
  }
  xx <- format(unclass(x), digits = digits, justify = justify)
  if (any(ina <- is.na(x))) 
    xx[ina] <- na.print
  if (zero.print != "0" && any(i0 <- !ina & x == 0)) 
    xx[i0] <- zero.print
  print(xx, quote = quote, right = right, ...)
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
print.warnings
list(`package:base` = function (x, tags, header = ngettext(n, "Warning message:\n", "Warning messages:\n"), ...) 
{
  if (n <- length(x)) {
    if (length(header)) 
      cat(header)
    if (missing(tags) || length(tags) == 0) 
      tags <- if (n == 1) 
        ""
    else paste0(seq_len(n), ": ")
    else if (length(tags <- as.character(tags)) != n) 
      stop("'tags' must be a character vector of the same length as 'x'")
    msgs <- names(x)
    for (i in seq_len(n)) {
      out <- if (length(x[[i]])) {
        temp <- deparse(x[[i]], width.cutoff = 50, nlines = 2)
        sm <- strsplit(msgs[i], "\n")[[1]]
        nl <- if (nchar(tags[i], "w") + nchar(temp[1], "w") + nchar(sm[1], "w") <= 75) 
          " "
        else "\n  "
        paste0(tags[i], "In ", temp[1], if (length(temp) > 1) 
          " ...", " :", nl, msgs[i])
      }
      else paste0(tags[i], msgs[i])
      do.call("cat", c(list(out), attr(x, "dots"), fill = TRUE))
    }
  }
  invisible(x)
}, function (x, tags, header = ngettext(n, "Warning message:\n", "Warning messages:\n"), ...) 
{
  if (n <- length(x)) {
    if (length(header)) 
      cat(header)
    if (missing(tags) || length(tags) == 0) 
      tags <- if (n == 1) 
        ""
    else paste0(seq_len(n), ": ")
    else if (length(tags <- as.character(tags)) != n) 
      stop("'tags' must be a character vector of the same length as 'x'")
    msgs <- names(x)
    for (i in seq_len(n)) {
      out <- if (length(x[[i]])) {
        temp <- deparse(x[[i]], width.cutoff = 50, nlines = 2)
        sm <- strsplit(msgs[i], "\n")[[1]]
        nl <- if (nchar(tags[i], "w") + nchar(temp[1], "w") + nchar(sm[1], "w") <= 75) 
          " "
        else "\n  "
        paste0(tags[i], "In ", temp[1], if (length(temp) > 1) 
          " ...", " :", nl, msgs[i])
      }
      else paste0(tags[i], msgs[i])
      do.call("cat", c(list(out), attr(x, "dots"), fill = TRUE))
    }
  }
  invisible(x)
}, function (x, tags, header = ngettext(n, "Warning message:\n", "Warning messages:\n"), ...) 
{
  if (n <- length(x)) {
    if (length(header)) 
      cat(header)
    if (missing(tags) || length(tags) == 0) 
      tags <- if (n == 1) 
        ""
    else paste0(seq_len(n), ": ")
    else if (length(tags <- as.character(tags)) != n) 
      stop("'tags' must be a character vector of the same length as 'x'")
    msgs <- names(x)
    for (i in seq_len(n)) {
      out <- if (length(x[[i]])) {
        temp <- deparse(x[[i]], width.cutoff = 50, nlines = 2)
        sm <- strsplit(msgs[i], "\n")[[1]]
        nl <- if (nchar(tags[i], "w") + nchar(temp[1], "w") + nchar(sm[1], "w") <= 75) 
          " "
        else "\n  "
        paste0(tags[i], "In ", temp[1], if (length(temp) > 1) 
          " ...", " :", nl, msgs[i])
      }
      else paste0(tags[i], msgs[i])
      do.call("cat", c(list(out), attr(x, "dots"), fill = TRUE))
    }
  }
  invisible(x)
})
c("package:base", "registered S3 method for print from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
prmatrix
list(`package:base` = function (x, rowlab = dn[[1]], collab = dn[[2]], quote = TRUE, right = FALSE, na.print = NULL, ...) 
{
  x <- as.matrix(x)
  dn <- dimnames(x)
  .Internal(prmatrix(x, rowlab, collab, quote, right, na.print))
}, function (x, rowlab = dn[[1]], collab = dn[[2]], quote = TRUE, right = FALSE, na.print = NULL, ...) 
{
  x <- as.matrix(x)
  dn <- dimnames(x)
  .Internal(prmatrix(x, rowlab, collab, quote, right, na.print))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
proc.time
list(`package:base` = .Primitive("proc.time"), .Primitive("proc.time"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
prod
list(`package:base` = .Primitive("prod"), .Primitive("prod"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
prop.table
list(`package:base` = function (x, margin = NULL) 
{
  if (length(margin)) 
    sweep(x, margin, marginSums(x, margin), `/`, check.margin = FALSE)
  else x/sum(x)
}, function (x, margin = NULL) 
{
  if (length(margin)) 
    sweep(x, margin, marginSums(x, margin), `/`, check.margin = FALSE)
  else x/sum(x)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
proportions
list(`package:base` = function (x, margin = NULL) 
{
  if (length(margin)) 
    sweep(x, margin, marginSums(x, margin), `/`, check.margin = FALSE)
  else x/sum(x)
}, function (x, margin = NULL) 
{
  if (length(margin)) 
    sweep(x, margin, marginSums(x, margin), `/`, check.margin = FALSE)
  else x/sum(x)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
provideDimnames
list(`package:base` = function (x, sep = "", base = list(LETTERS), unique = TRUE) 
{
  dx <- dim(x)
  dnx <- dimnames(x)
  if (new <- is.null(dnx)) 
    dnx <- vector("list", length(dx))
  k <- length(M <- lengths(base))
  for (i in which(vapply(dnx, is.null, NA))) {
    ii <- 1 + (i - 1)%%k
    ss <- seq_len(dx[i]) - 1
    bi <- base[[ii]][1 + (ss%%M[ii])]
    dnx[[i]] <- if (unique) 
      make.unique(bi, sep = sep)
    else bi
    new <- TRUE
  }
  if (new) 
    dimnames(x) <- dnx
  x
}, function (x, sep = "", base = list(LETTERS), unique = TRUE) 
{
  dx <- dim(x)
  dnx <- dimnames(x)
  if (new <- is.null(dnx)) 
    dnx <- vector("list", length(dx))
  k <- length(M <- lengths(base))
  for (i in which(vapply(dnx, is.null, NA))) {
    ii <- 1 + (i - 1)%%k
    ss <- seq_len(dx[i]) - 1
    bi <- base[[ii]][1 + (ss%%M[ii])]
    dnx[[i]] <- if (unique) 
      make.unique(bi, sep = sep)
    else bi
    new <- TRUE
  }
  if (new) 
    dimnames(x) <- dnx
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
psigamma
list(`package:base` = function (x, deriv = 0) 
  .Internal(psigamma(x, deriv)), function (x, deriv = 0) 
    .Internal(psigamma(x, deriv)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pushBack
list(`package:base` = function (data, connection, newLine = TRUE, encoding = c("", "bytes", "UTF-8")) 
{
  if (length(encoding) > 1) 
    encoding <- encoding[1]
  if (nzchar(encoding)) 
    encoding <- match.arg(encoding)
  type <- match(encoding, c("", "bytes", "UTF-8"))
  .Internal(pushBack(data, connection, newLine, type))
}, function (data, connection, newLine = TRUE, encoding = c("", "bytes", "UTF-8")) 
{
  if (length(encoding) > 1) 
    encoding <- encoding[1]
  if (nzchar(encoding)) 
    encoding <- match.arg(encoding)
  type <- match(encoding, c("", "bytes", "UTF-8"))
  .Internal(pushBack(data, connection, newLine, type))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
pushBackLength
list(`package:base` = function (connection) 
  .Internal(pushBackLength(connection)), function (connection) 
    .Internal(pushBackLength(connection)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
q
list(`package:base` = function (save = "default", status = 0, runLast = TRUE) 
  .Internal(quit(save, status, runLast)), function (save = "default", status = 0, runLast = TRUE) 
    .Internal(quit(save, status, runLast)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
qr
list(`package:base` = function (x, ...) 
  UseMethod("qr"), new("standardGeneric", .Data = function (x, ...) 
    standardGeneric("qr"), generic = "qr", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
      UseMethod("qr"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "qr"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("qr"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "qr"))(x, ...)), function (x, ...) 
          UseMethod("qr"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
qr.coef
list(`package:base` = function (qr, y) 
{
  if (!is.qr(qr)) 
    stop("first argument must be a QR decomposition")
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  p <- as.integer(ncol(qr$qr))
  if (is.na(p)) 
    stop("invalid ncol(qr$qr)")
  k <- as.integer(qr$rank)
  if (is.na(k)) 
    stop("invalid ncol(qr$rank)")
  im <- is.matrix(y)
  if (!im) 
    y <- as.matrix(y)
  ny <- as.integer(ncol(y))
  if (is.na(ny)) 
    stop("invalid ncol(y)")
  if (nrow(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  isC <- is.complex(qr$qr)
  coef <- matrix(if (isC) 
    NA
    else NA, p, ny)
  ix <- if (p > n) 
    c(seq_len(n), rep(NA, p - n))
  else seq_len(p)
  if (!is.null(nam <- colnames(qr$qr))) 
    pivotted <- NA
  if (p == 0) {
    pivotted <- FALSE
  }
  else if (isC) {
    coef[qr$pivot, ] <- .Internal(qr_coef_cmplx(qr, y))[ix, ]
  }
  else if (isTRUE(attr(qr, "useLAPACK"))) {
    coef[qr$pivot, ] <- .Internal(qr_coef_real(qr, y))[ix, ]
  }
  else if (k > 0) {
    storage.mode(y) <- "double"
    z <- .Fortran(.F_dqrcf, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, coef = matrix(0, nrow = k, ncol = ny), info = integer(1), NAOK = TRUE)[c("coef", "info")]
    if (z$info) 
      stop("exact singularity in 'qr.coef'")
    pivotted <- k < p
    if (pivotted) 
      coef[qr$pivot[seq_len(k)], ] <- z$coef
    else coef <- z$coef
  }
  if (!is.null(nam)) {
    if (is.na(pivotted)) 
      pivotted <- is.unsorted(qr$pivot)
    if (pivotted) 
      rownames(coef)[qr$pivot] <- nam
    else rownames(coef) <- nam
  }
  if (im && !is.null(nam <- colnames(y))) 
    colnames(coef) <- nam
  if (im) 
    coef
  else drop(coef)
}, function (qr, y) 
{
  if (!is.qr(qr)) 
    stop("first argument must be a QR decomposition")
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  p <- as.integer(ncol(qr$qr))
  if (is.na(p)) 
    stop("invalid ncol(qr$qr)")
  k <- as.integer(qr$rank)
  if (is.na(k)) 
    stop("invalid ncol(qr$rank)")
  im <- is.matrix(y)
  if (!im) 
    y <- as.matrix(y)
  ny <- as.integer(ncol(y))
  if (is.na(ny)) 
    stop("invalid ncol(y)")
  if (nrow(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  isC <- is.complex(qr$qr)
  coef <- matrix(if (isC) 
    NA
    else NA, p, ny)
  ix <- if (p > n) 
    c(seq_len(n), rep(NA, p - n))
  else seq_len(p)
  if (!is.null(nam <- colnames(qr$qr))) 
    pivotted <- NA
  if (p == 0) {
    pivotted <- FALSE
  }
  else if (isC) {
    coef[qr$pivot, ] <- .Internal(qr_coef_cmplx(qr, y))[ix, ]
  }
  else if (isTRUE(attr(qr, "useLAPACK"))) {
    coef[qr$pivot, ] <- .Internal(qr_coef_real(qr, y))[ix, ]
  }
  else if (k > 0) {
    storage.mode(y) <- "double"
    z <- .Fortran(.F_dqrcf, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, coef = matrix(0, nrow = k, ncol = ny), info = integer(1), NAOK = TRUE)[c("coef", "info")]
    if (z$info) 
      stop("exact singularity in 'qr.coef'")
    pivotted <- k < p
    if (pivotted) 
      coef[qr$pivot[seq_len(k)], ] <- z$coef
    else coef <- z$coef
  }
  if (!is.null(nam)) {
    if (is.na(pivotted)) 
      pivotted <- is.unsorted(qr$pivot)
    if (pivotted) 
      rownames(coef)[qr$pivot] <- nam
    else rownames(coef) <- nam
  }
  if (im && !is.null(nam <- colnames(y))) 
    colnames(coef) <- nam
  if (im) 
    coef
  else drop(coef)
}, new("standardGeneric", .Data = function (qr, y) 
  standardGeneric("qr.coef"), generic = "qr.coef", package = "base", group = list(), valueClass = character(0), signature = c("qr", "y"), default = new("derivedDefaultMethod", .Data = function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("first argument must be a QR decomposition")
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    p <- as.integer(ncol(qr$qr))
    if (is.na(p)) 
      stop("invalid ncol(qr$qr)")
    k <- as.integer(qr$rank)
    if (is.na(k)) 
      stop("invalid ncol(qr$rank)")
    im <- is.matrix(y)
    if (!im) 
      y <- as.matrix(y)
    ny <- as.integer(ncol(y))
    if (is.na(ny)) 
      stop("invalid ncol(y)")
    if (nrow(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    isC <- is.complex(qr$qr)
    coef <- matrix(if (isC) 
      NA
      else NA, p, ny)
    ix <- if (p > n) 
      c(seq_len(n), rep(NA, p - n))
    else seq_len(p)
    if (!is.null(nam <- colnames(qr$qr))) 
      pivotted <- NA
    if (p == 0) {
      pivotted <- FALSE
    }
    else if (isC) {
      coef[qr$pivot, ] <- .Internal(qr_coef_cmplx(qr, y))[ix, ]
    }
    else if (isTRUE(attr(qr, "useLAPACK"))) {
      coef[qr$pivot, ] <- .Internal(qr_coef_real(qr, y))[ix, ]
    }
    else if (k > 0) {
      storage.mode(y) <- "double"
      z <- .Fortran(.F_dqrcf, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, coef = matrix(0, nrow = k, ncol = ny), info = integer(1), NAOK = TRUE)[c("coef", "info")]
      if (z$info) 
        stop("exact singularity in 'qr.coef'")
      pivotted <- k < p
      if (pivotted) 
        coef[qr$pivot[seq_len(k)], ] <- z$coef
      else coef <- z$coef
    }
    if (!is.null(nam)) {
      if (is.na(pivotted)) 
        pivotted <- is.unsorted(qr$pivot)
      if (pivotted) 
        rownames(coef)[qr$pivot] <- nam
      else rownames(coef) <- nam
    }
    if (im && !is.null(nam <- colnames(y))) 
      colnames(coef) <- nam
    if (im) 
      coef
    else drop(coef)
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.coef"), skeleton = (new("derivedDefaultMethod", .Data = function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("first argument must be a QR decomposition")
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    p <- as.integer(ncol(qr$qr))
    if (is.na(p)) 
      stop("invalid ncol(qr$qr)")
    k <- as.integer(qr$rank)
    if (is.na(k)) 
      stop("invalid ncol(qr$rank)")
    im <- is.matrix(y)
    if (!im) 
      y <- as.matrix(y)
    ny <- as.integer(ncol(y))
    if (is.na(ny)) 
      stop("invalid ncol(y)")
    if (nrow(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    isC <- is.complex(qr$qr)
    coef <- matrix(if (isC) 
      NA
      else NA, p, ny)
    ix <- if (p > n) 
      c(seq_len(n), rep(NA, p - n))
    else seq_len(p)
    if (!is.null(nam <- colnames(qr$qr))) 
      pivotted <- NA
    if (p == 0) {
      pivotted <- FALSE
    }
    else if (isC) {
      coef[qr$pivot, ] <- .Internal(qr_coef_cmplx(qr, y))[ix, ]
    }
    else if (isTRUE(attr(qr, "useLAPACK"))) {
      coef[qr$pivot, ] <- .Internal(qr_coef_real(qr, y))[ix, ]
    }
    else if (k > 0) {
      storage.mode(y) <- "double"
      z <- .Fortran(.F_dqrcf, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, coef = matrix(0, nrow = k, ncol = ny), info = integer(1), NAOK = TRUE)[c("coef", "info")]
      if (z$info) 
        stop("exact singularity in 'qr.coef'")
      pivotted <- k < p
      if (pivotted) 
        coef[qr$pivot[seq_len(k)], ] <- z$coef
      else coef <- z$coef
    }
    if (!is.null(nam)) {
      if (is.na(pivotted)) 
        pivotted <- is.unsorted(qr$pivot)
      if (pivotted) 
        rownames(coef)[qr$pivot] <- nam
      else rownames(coef) <- nam
    }
    if (im && !is.null(nam <- colnames(y))) 
      colnames(coef) <- nam
    if (im) 
      coef
    else drop(coef)
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.coef"))(qr, y)), function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("first argument must be a QR decomposition")
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    p <- as.integer(ncol(qr$qr))
    if (is.na(p)) 
      stop("invalid ncol(qr$qr)")
    k <- as.integer(qr$rank)
    if (is.na(k)) 
      stop("invalid ncol(qr$rank)")
    im <- is.matrix(y)
    if (!im) 
      y <- as.matrix(y)
    ny <- as.integer(ncol(y))
    if (is.na(ny)) 
      stop("invalid ncol(y)")
    if (nrow(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    isC <- is.complex(qr$qr)
    coef <- matrix(if (isC) 
      NA
      else NA, p, ny)
    ix <- if (p > n) 
      c(seq_len(n), rep(NA, p - n))
    else seq_len(p)
    if (!is.null(nam <- colnames(qr$qr))) 
      pivotted <- NA
    if (p == 0) {
      pivotted <- FALSE
    }
    else if (isC) {
      coef[qr$pivot, ] <- .Internal(qr_coef_cmplx(qr, y))[ix, ]
    }
    else if (isTRUE(attr(qr, "useLAPACK"))) {
      coef[qr$pivot, ] <- .Internal(qr_coef_real(qr, y))[ix, ]
    }
    else if (k > 0) {
      storage.mode(y) <- "double"
      z <- .Fortran(.F_dqrcf, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, coef = matrix(0, nrow = k, ncol = ny), info = integer(1), NAOK = TRUE)[c("coef", "info")]
      if (z$info) 
        stop("exact singularity in 'qr.coef'")
      pivotted <- k < p
      if (pivotted) 
        coef[qr$pivot[seq_len(k)], ] <- z$coef
      else coef <- z$coef
    }
    if (!is.null(nam)) {
      if (is.na(pivotted)) 
        pivotted <- is.unsorted(qr$pivot)
      if (pivotted) 
        rownames(coef)[qr$pivot] <- nam
      else rownames(coef) <- nam
    }
    if (im && !is.null(nam <- colnames(y))) 
      colnames(coef) <- nam
    if (im) 
      coef
    else drop(coef)
  })
c("package:base", "registered S3 method for qr from namespace base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
qr.default
list(`package:base` = function (x, tol = 1e-07, LAPACK = FALSE, ...) 
{
  x <- as.matrix(x)
  if (is.complex(x)) 
    return(structure(.Internal(La_qr_cmplx(x)), class = "qr"))
  if (LAPACK) 
    return(structure(.Internal(La_qr(x)), useLAPACK = TRUE, class = "qr"))
  p <- as.integer(ncol(x))
  if (is.na(p)) 
    stop("invalid ncol(x)")
  n <- as.integer(nrow(x))
  if (is.na(n)) 
    stop("invalid nrow(x)")
  if (1 * n * p > 2147483647) 
    stop("too large a matrix for LINPACK")
  storage.mode(x) <- "double"
  res <- .Fortran(.F_dqrdc2, qr = x, n, n, p, as.double(tol), rank = integer(1), qraux = double(p), pivot = as.integer(seq_len(p)), double(2 * p))[c(1, 6, 7, 8)]
  if (!is.null(cn <- colnames(x))) 
    colnames(res$qr) <- cn[res$pivot]
  class(res) <- "qr"
  res
}, function (x, tol = 1e-07, LAPACK = FALSE, ...) 
{
  x <- as.matrix(x)
  if (is.complex(x)) 
    return(structure(.Internal(La_qr_cmplx(x)), class = "qr"))
  if (LAPACK) 
    return(structure(.Internal(La_qr(x)), useLAPACK = TRUE, class = "qr"))
  p <- as.integer(ncol(x))
  if (is.na(p)) 
    stop("invalid ncol(x)")
  n <- as.integer(nrow(x))
  if (is.na(n)) 
    stop("invalid nrow(x)")
  if (1 * n * p > 2147483647) 
    stop("too large a matrix for LINPACK")
  storage.mode(x) <- "double"
  res <- .Fortran(.F_dqrdc2, qr = x, n, n, p, as.double(tol), rank = integer(1), qraux = double(p), pivot = as.integer(seq_len(p)), double(2 * p))[c(1, 6, 7, 8)]
  if (!is.null(cn <- colnames(x))) 
    colnames(res$qr) <- cn[res$pivot]
  class(res) <- "qr"
  res
}, function (x, tol = 1e-07, LAPACK = FALSE, ...) 
{
  x <- as.matrix(x)
  if (is.complex(x)) 
    return(structure(.Internal(La_qr_cmplx(x)), class = "qr"))
  if (LAPACK) 
    return(structure(.Internal(La_qr(x)), useLAPACK = TRUE, class = "qr"))
  p <- as.integer(ncol(x))
  if (is.na(p)) 
    stop("invalid ncol(x)")
  n <- as.integer(nrow(x))
  if (is.na(n)) 
    stop("invalid nrow(x)")
  if (1 * n * p > 2147483647) 
    stop("too large a matrix for LINPACK")
  storage.mode(x) <- "double"
  res <- .Fortran(.F_dqrdc2, qr = x, n, n, p, as.double(tol), rank = integer(1), qraux = double(p), pivot = as.integer(seq_len(p)), double(2 * p))[c(1, 6, 7, 8)]
  if (!is.null(cn <- colnames(x))) 
    colnames(res$qr) <- cn[res$pivot]
  class(res) <- "qr"
  res
})
c("package:base", "registered S3 method for qr from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
qr.fitted
list(`package:base` = function (qr, y, k = qr$rank) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  if (is.complex(qr$qr)) 
    stop("not implemented for complex 'qr'")
  if (isTRUE(attr(qr, "useLAPACK"))) 
    stop("not supported for LAPACK QR")
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  k <- as.integer(k)
  if (k > qr$rank) 
    stop("'k' is too large")
  ny <- as.integer(NCOL(y))
  if (is.na(ny)) 
    stop("invalid NCOL(y)")
  if (NROW(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  storage.mode(y) <- "double"
  .Fortran(.F_dqrxb, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, xb = y)$xb
}, function (qr, y, k = qr$rank) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  if (is.complex(qr$qr)) 
    stop("not implemented for complex 'qr'")
  if (isTRUE(attr(qr, "useLAPACK"))) 
    stop("not supported for LAPACK QR")
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  k <- as.integer(k)
  if (k > qr$rank) 
    stop("'k' is too large")
  ny <- as.integer(NCOL(y))
  if (is.na(ny)) 
    stop("invalid NCOL(y)")
  if (NROW(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  storage.mode(y) <- "double"
  .Fortran(.F_dqrxb, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, xb = y)$xb
}, new("standardGeneric", .Data = function (qr, y, k = qr$rank) 
  standardGeneric("qr.fitted"), generic = "qr.fitted", package = "base", group = list(), valueClass = character(0), signature = c("qr", "y", "k"), default = new("derivedDefaultMethod", .Data = function (qr, y, k = qr$rank) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      stop("not implemented for complex 'qr'")
    if (isTRUE(attr(qr, "useLAPACK"))) 
      stop("not supported for LAPACK QR")
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(k)
    if (k > qr$rank) 
      stop("'k' is too large")
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrxb, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, xb = y)$xb
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.fitted"), skeleton = (new("derivedDefaultMethod", .Data = function (qr, y, k = qr$rank) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      stop("not implemented for complex 'qr'")
    if (isTRUE(attr(qr, "useLAPACK"))) 
      stop("not supported for LAPACK QR")
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(k)
    if (k > qr$rank) 
      stop("'k' is too large")
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrxb, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, xb = y)$xb
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.fitted"))(qr, y, k)), function (qr, y, k = qr$rank) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      stop("not implemented for complex 'qr'")
    if (isTRUE(attr(qr, "useLAPACK"))) 
      stop("not supported for LAPACK QR")
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(k)
    if (k > qr$rank) 
      stop("'k' is too large")
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrxb, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, xb = y)$xb
  })
c("package:base", "registered S3 method for qr from namespace base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
qr.Q
list(`package:base` = function (qr, complete = FALSE, Dvec) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  dqr <- dim(qr$qr)
  n <- dqr[1]
  cmplx <- mode(qr$qr) == "complex"
  if (missing(Dvec)) 
    Dvec <- rep.int(if (cmplx) 
      1 + (0+0i)
      else 1, if (complete) 
        n
      else min(dqr))
  D <- if (complete) 
    diag(Dvec, n)
  else {
    ncols <- min(dqr)
    diag(Dvec[seq_len(ncols)], nrow = n, ncol = ncols)
  }
  qr.qy(qr, D)
}, function (qr, complete = FALSE, Dvec) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  dqr <- dim(qr$qr)
  n <- dqr[1]
  cmplx <- mode(qr$qr) == "complex"
  if (missing(Dvec)) 
    Dvec <- rep.int(if (cmplx) 
      1 + (0+0i)
      else 1, if (complete) 
        n
      else min(dqr))
  D <- if (complete) 
    diag(Dvec, n)
  else {
    ncols <- min(dqr)
    diag(Dvec[seq_len(ncols)], nrow = n, ncol = ncols)
  }
  qr.qy(qr, D)
}, new("standardGeneric", .Data = function (qr, complete = FALSE, Dvec) 
  standardGeneric("qr.Q"), generic = "qr.Q", package = "base", group = list(), valueClass = character(0), signature = c("qr", "complete", "Dvec"), default = new("derivedDefaultMethod", .Data = function (qr, complete = FALSE, Dvec) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    dqr <- dim(qr$qr)
    n <- dqr[1]
    cmplx <- mode(qr$qr) == "complex"
    if (missing(Dvec)) 
      Dvec <- rep.int(if (cmplx) 
        1 + (0+0i)
        else 1, if (complete) 
          n
        else min(dqr))
    D <- if (complete) 
      diag(Dvec, n)
    else {
      ncols <- min(dqr)
      diag(Dvec[seq_len(ncols)], nrow = n, ncol = ncols)
    }
    qr.qy(qr, D)
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.Q"), skeleton = (new("derivedDefaultMethod", .Data = function (qr, complete = FALSE, Dvec) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    dqr <- dim(qr$qr)
    n <- dqr[1]
    cmplx <- mode(qr$qr) == "complex"
    if (missing(Dvec)) 
      Dvec <- rep.int(if (cmplx) 
        1 + (0+0i)
        else 1, if (complete) 
          n
        else min(dqr))
    D <- if (complete) 
      diag(Dvec, n)
    else {
      ncols <- min(dqr)
      diag(Dvec[seq_len(ncols)], nrow = n, ncol = ncols)
    }
    qr.qy(qr, D)
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.Q"))(qr, complete, Dvec)), function (qr, complete = FALSE, Dvec) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    dqr <- dim(qr$qr)
    n <- dqr[1]
    cmplx <- mode(qr$qr) == "complex"
    if (missing(Dvec)) 
      Dvec <- rep.int(if (cmplx) 
        1 + (0+0i)
        else 1, if (complete) 
          n
        else min(dqr))
    D <- if (complete) 
      diag(Dvec, n)
    else {
      ncols <- min(dqr)
      diag(Dvec[seq_len(ncols)], nrow = n, ncol = ncols)
    }
    qr.qy(qr, D)
  })
c("package:base", "registered S3 method for qr from namespace base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
qr.qty
list(`package:base` = function (qr, y) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  if (is.complex(qr$qr)) 
    return(.Internal(qr_qy_cmplx(qr, as.matrix(y), TRUE)))
  if (isTRUE(attr(qr, "useLAPACK"))) 
    return(.Internal(qr_qy_real(qr, as.matrix(y), TRUE)))
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  k <- as.integer(qr$rank)
  ny <- as.integer(NCOL(y))
  if (is.na(ny)) 
    stop("invalid NCOL(y)")
  if (NROW(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  storage.mode(y) <- "double"
  .Fortran(.F_dqrqty, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qty = y)$qty
}, function (qr, y) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  if (is.complex(qr$qr)) 
    return(.Internal(qr_qy_cmplx(qr, as.matrix(y), TRUE)))
  if (isTRUE(attr(qr, "useLAPACK"))) 
    return(.Internal(qr_qy_real(qr, as.matrix(y), TRUE)))
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  k <- as.integer(qr$rank)
  ny <- as.integer(NCOL(y))
  if (is.na(ny)) 
    stop("invalid NCOL(y)")
  if (NROW(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  storage.mode(y) <- "double"
  .Fortran(.F_dqrqty, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qty = y)$qty
}, new("standardGeneric", .Data = function (qr, y) 
  standardGeneric("qr.qty"), generic = "qr.qty", package = "base", group = list(), valueClass = character(0), signature = c("qr", "y"), default = new("derivedDefaultMethod", .Data = function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      return(.Internal(qr_qy_cmplx(qr, as.matrix(y), TRUE)))
    if (isTRUE(attr(qr, "useLAPACK"))) 
      return(.Internal(qr_qy_real(qr, as.matrix(y), TRUE)))
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(qr$rank)
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrqty, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qty = y)$qty
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.qty"), skeleton = (new("derivedDefaultMethod", .Data = function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      return(.Internal(qr_qy_cmplx(qr, as.matrix(y), TRUE)))
    if (isTRUE(attr(qr, "useLAPACK"))) 
      return(.Internal(qr_qy_real(qr, as.matrix(y), TRUE)))
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(qr$rank)
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrqty, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qty = y)$qty
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.qty"))(qr, y)), function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      return(.Internal(qr_qy_cmplx(qr, as.matrix(y), TRUE)))
    if (isTRUE(attr(qr, "useLAPACK"))) 
      return(.Internal(qr_qy_real(qr, as.matrix(y), TRUE)))
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(qr$rank)
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrqty, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qty = y)$qty
  })
c("package:base", "registered S3 method for qr from namespace base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
qr.qy
list(`package:base` = function (qr, y) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  if (is.complex(qr$qr)) 
    return(.Internal(qr_qy_cmplx(qr, as.matrix(y), FALSE)))
  if (isTRUE(attr(qr, "useLAPACK"))) 
    return(.Internal(qr_qy_real(qr, as.matrix(y), FALSE)))
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  k <- as.integer(qr$rank)
  ny <- as.integer(NCOL(y))
  if (is.na(ny)) 
    stop("invalid NCOL(y)")
  storage.mode(y) <- "double"
  if (NROW(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  .Fortran(.F_dqrqy, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qy = y)$qy
}, function (qr, y) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  if (is.complex(qr$qr)) 
    return(.Internal(qr_qy_cmplx(qr, as.matrix(y), FALSE)))
  if (isTRUE(attr(qr, "useLAPACK"))) 
    return(.Internal(qr_qy_real(qr, as.matrix(y), FALSE)))
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  k <- as.integer(qr$rank)
  ny <- as.integer(NCOL(y))
  if (is.na(ny)) 
    stop("invalid NCOL(y)")
  storage.mode(y) <- "double"
  if (NROW(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  .Fortran(.F_dqrqy, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qy = y)$qy
}, new("standardGeneric", .Data = function (qr, y) 
  standardGeneric("qr.qy"), generic = "qr.qy", package = "base", group = list(), valueClass = character(0), signature = c("qr", "y"), default = new("derivedDefaultMethod", .Data = function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      return(.Internal(qr_qy_cmplx(qr, as.matrix(y), FALSE)))
    if (isTRUE(attr(qr, "useLAPACK"))) 
      return(.Internal(qr_qy_real(qr, as.matrix(y), FALSE)))
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(qr$rank)
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    storage.mode(y) <- "double"
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    .Fortran(.F_dqrqy, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qy = y)$qy
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.qy"), skeleton = (new("derivedDefaultMethod", .Data = function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      return(.Internal(qr_qy_cmplx(qr, as.matrix(y), FALSE)))
    if (isTRUE(attr(qr, "useLAPACK"))) 
      return(.Internal(qr_qy_real(qr, as.matrix(y), FALSE)))
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(qr$rank)
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    storage.mode(y) <- "double"
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    .Fortran(.F_dqrqy, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qy = y)$qy
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.qy"))(qr, y)), function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      return(.Internal(qr_qy_cmplx(qr, as.matrix(y), FALSE)))
    if (isTRUE(attr(qr, "useLAPACK"))) 
      return(.Internal(qr_qy_real(qr, as.matrix(y), FALSE)))
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    k <- as.integer(qr$rank)
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    storage.mode(y) <- "double"
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    .Fortran(.F_dqrqy, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, qy = y)$qy
  })
c("package:base", "registered S3 method for qr from namespace base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
qr.R
list(`package:base` = function (qr, complete = FALSE) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  R <- qr$qr
  if (!complete) 
    R <- R[seq.int(min(dim(R))), , drop = FALSE]
  R[row(R) > col(R)] <- 0
  R
}, function (qr, complete = FALSE) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  R <- qr$qr
  if (!complete) 
    R <- R[seq.int(min(dim(R))), , drop = FALSE]
  R[row(R) > col(R)] <- 0
  R
}, new("standardGeneric", .Data = function (qr, complete = FALSE, ...) 
  standardGeneric("qr.R"), generic = "qr.R", package = "base", group = list(), valueClass = character(0), signature = "qr", default = new("derivedDefaultMethod", .Data = function (qr, complete = FALSE, ...) 
    base::qr.R(qr, complete = complete), target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.R"), skeleton = (new("derivedDefaultMethod", .Data = function (qr, complete = FALSE, ...) 
      base::qr.R(qr, complete = complete), target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.R"))(qr, complete, ...)), function (qr, complete = FALSE) 
      {
        if (!is.qr(qr)) 
          stop("argument is not a QR decomposition")
        R <- qr$qr
        if (!complete) 
          R <- R[seq.int(min(dim(R))), , drop = FALSE]
        R[row(R) > col(R)] <- 0
        R
      })
c("package:base", "registered S3 method for qr from namespace base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
qr.resid
list(`package:base` = function (qr, y) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  if (is.complex(qr$qr)) 
    stop("not implemented for complex 'qr'")
  if (isTRUE(attr(qr, "useLAPACK"))) 
    stop("not supported for LAPACK QR")
  k <- as.integer(qr$rank)
  if (k == 0) 
    return(y)
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  ny <- as.integer(NCOL(y))
  if (is.na(ny)) 
    stop("invalid NCOL(y)")
  if (NROW(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  storage.mode(y) <- "double"
  .Fortran(.F_dqrrsd, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, rsd = y)$rsd
}, function (qr, y) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  if (is.complex(qr$qr)) 
    stop("not implemented for complex 'qr'")
  if (isTRUE(attr(qr, "useLAPACK"))) 
    stop("not supported for LAPACK QR")
  k <- as.integer(qr$rank)
  if (k == 0) 
    return(y)
  n <- as.integer(nrow(qr$qr))
  if (is.na(n)) 
    stop("invalid nrow(qr$qr)")
  ny <- as.integer(NCOL(y))
  if (is.na(ny)) 
    stop("invalid NCOL(y)")
  if (NROW(y) != n) 
    stop("'qr' and 'y' must have the same number of rows")
  storage.mode(y) <- "double"
  .Fortran(.F_dqrrsd, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, rsd = y)$rsd
}, new("standardGeneric", .Data = function (qr, y) 
  standardGeneric("qr.resid"), generic = "qr.resid", package = "base", group = list(), valueClass = character(0), signature = c("qr", "y"), default = new("derivedDefaultMethod", .Data = function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      stop("not implemented for complex 'qr'")
    if (isTRUE(attr(qr, "useLAPACK"))) 
      stop("not supported for LAPACK QR")
    k <- as.integer(qr$rank)
    if (k == 0) 
      return(y)
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrrsd, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, rsd = y)$rsd
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.resid"), skeleton = (new("derivedDefaultMethod", .Data = function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      stop("not implemented for complex 'qr'")
    if (isTRUE(attr(qr, "useLAPACK"))) 
      stop("not supported for LAPACK QR")
    k <- as.integer(qr$rank)
    if (k == 0) 
      return(y)
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrrsd, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, rsd = y)$rsd
  }, target = new("signature", .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", .Data = "ANY", names = "qr", package = "methods"), generic = "qr.resid"))(qr, y)), function (qr, y) 
  {
    if (!is.qr(qr)) 
      stop("argument is not a QR decomposition")
    if (is.complex(qr$qr)) 
      stop("not implemented for complex 'qr'")
    if (isTRUE(attr(qr, "useLAPACK"))) 
      stop("not supported for LAPACK QR")
    k <- as.integer(qr$rank)
    if (k == 0) 
      return(y)
    n <- as.integer(nrow(qr$qr))
    if (is.na(n)) 
      stop("invalid nrow(qr$qr)")
    ny <- as.integer(NCOL(y))
    if (is.na(ny)) 
      stop("invalid NCOL(y)")
    if (NROW(y) != n) 
      stop("'qr' and 'y' must have the same number of rows")
    storage.mode(y) <- "double"
    .Fortran(.F_dqrrsd, as.double(qr$qr), n, k, as.double(qr$qraux), y, ny, rsd = y)$rsd
  })
c("package:base", "registered S3 method for qr from namespace base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, TRUE)
qr.solve
list(`package:base` = function (a, b, tol = 1e-07) 
{
  if (!inherits(a, "qr")) 
    a <- qr(a, tol = tol)
  nc <- ncol(a$qr)
  nr <- nrow(a$qr)
  if (a$rank != min(nc, nr)) 
    stop("singular matrix 'a' in solve")
  if (missing(b)) {
    if (nc != nr) 
      stop("only square matrices can be inverted")
    b <- diag(1, nc)
  }
  res <- qr.coef(a, b)
  res[is.na(res)] <- 0
  res
}, function (a, b, tol = 1e-07) 
{
  if (!inherits(a, "qr")) 
    a <- qr(a, tol = tol)
  nc <- ncol(a$qr)
  nr <- nrow(a$qr)
  if (a$rank != min(nc, nr)) 
    stop("singular matrix 'a' in solve")
  if (missing(b)) {
    if (nc != nr) 
      stop("only square matrices can be inverted")
    b <- diag(1, nc)
  }
  res <- qr.coef(a, b)
  res[is.na(res)] <- 0
  res
}, function (a, b, tol = 1e-07) 
{
  if (!inherits(a, "qr")) 
    a <- qr(a, tol = tol)
  nc <- ncol(a$qr)
  nr <- nrow(a$qr)
  if (a$rank != min(nc, nr)) 
    stop("singular matrix 'a' in solve")
  if (missing(b)) {
    if (nc != nr) 
      stop("only square matrices can be inverted")
    b <- diag(1, nc)
  }
  res <- qr.coef(a, b)
  res[is.na(res)] <- 0
  res
})
c("package:base", "registered S3 method for qr from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
qr.X
list(`package:base` = function (qr, complete = FALSE, ncol = if (complete) nrow(R) else min(dim(R))) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  pivoted <- !identical(qr$pivot, ip <- seq_along(qr$pivot))
  R <- qr.R(qr, complete = TRUE)
  if (pivoted && ncol < length(qr$pivot)) 
    stop("need larger value of 'ncol' as pivoting occurred")
  cmplx <- mode(R) == "complex"
  p <- as.integer(dim(R)[2])
  if (is.na(p)) 
    stop("invalid NCOL(R)")
  if (ncol < p) 
    R <- R[, seq_len(ncol), drop = FALSE]
  else if (ncol > p) {
    tmp <- diag(if (!cmplx) 
      1
      else 1 + (0+0i), nrow(R), ncol)
    tmp[, seq_len(p)] <- R
    R <- tmp
  }
  res <- qr.qy(qr, R)
  cn <- colnames(res)
  if (pivoted) {
    res[, qr$pivot] <- res[, ip]
    if (!is.null(cn)) 
      colnames(res)[qr$pivot] <- cn[ip]
  }
  res
}, function (qr, complete = FALSE, ncol = if (complete) nrow(R) else min(dim(R))) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  pivoted <- !identical(qr$pivot, ip <- seq_along(qr$pivot))
  R <- qr.R(qr, complete = TRUE)
  if (pivoted && ncol < length(qr$pivot)) 
    stop("need larger value of 'ncol' as pivoting occurred")
  cmplx <- mode(R) == "complex"
  p <- as.integer(dim(R)[2])
  if (is.na(p)) 
    stop("invalid NCOL(R)")
  if (ncol < p) 
    R <- R[, seq_len(ncol), drop = FALSE]
  else if (ncol > p) {
    tmp <- diag(if (!cmplx) 
      1
      else 1 + (0+0i), nrow(R), ncol)
    tmp[, seq_len(p)] <- R
    R <- tmp
  }
  res <- qr.qy(qr, R)
  cn <- colnames(res)
  if (pivoted) {
    res[, qr$pivot] <- res[, ip]
    if (!is.null(cn)) 
      colnames(res)[qr$pivot] <- cn[ip]
  }
  res
}, function (qr, complete = FALSE, ncol = if (complete) nrow(R) else min(dim(R))) 
{
  if (!is.qr(qr)) 
    stop("argument is not a QR decomposition")
  pivoted <- !identical(qr$pivot, ip <- seq_along(qr$pivot))
  R <- qr.R(qr, complete = TRUE)
  if (pivoted && ncol < length(qr$pivot)) 
    stop("need larger value of 'ncol' as pivoting occurred")
  cmplx <- mode(R) == "complex"
  p <- as.integer(dim(R)[2])
  if (is.na(p)) 
    stop("invalid NCOL(R)")
  if (ncol < p) 
    R <- R[, seq_len(ncol), drop = FALSE]
  else if (ncol > p) {
    tmp <- diag(if (!cmplx) 
      1
      else 1 + (0+0i), nrow(R), ncol)
    tmp[, seq_len(p)] <- R
    R <- tmp
  }
  res <- qr.qy(qr, R)
  cn <- colnames(res)
  if (pivoted) {
    res[, qr$pivot] <- res[, ip]
    if (!is.null(cn)) 
      colnames(res)[qr$pivot] <- cn[ip]
  }
  res
})
c("package:base", "registered S3 method for qr from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
quarters
list(`package:base` = function (x, abbreviate) 
  UseMethod("quarters"), function (x, abbreviate) 
    UseMethod("quarters"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
quarters.Date
list(`package:base` = function (x, ...) 
{
  x <- as.POSIXlt(x)$mon%/%3
  paste0("Q", x + 1)
}, function (x, ...) 
{
  x <- as.POSIXlt(x)$mon%/%3
  paste0("Q", x + 1)
}, function (x, ...) 
{
  x <- as.POSIXlt(x)$mon%/%3
  paste0("Q", x + 1)
})
c("package:base", "registered S3 method for quarters from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
quarters.POSIXt
list(`package:base` = function (x, ...) 
{
  x <- (as.POSIXlt(x)$mon)%/%3
  paste0("Q", x + 1)
}, function (x, ...) 
{
  x <- (as.POSIXlt(x)$mon)%/%3
  paste0("Q", x + 1)
}, function (x, ...) 
{
  x <- (as.POSIXlt(x)$mon)%/%3
  paste0("Q", x + 1)
})
c("package:base", "registered S3 method for quarters from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
quit
list(`package:base` = function (save = "default", status = 0, runLast = TRUE) 
  .Internal(quit(save, status, runLast)), function (save = "default", status = 0, runLast = TRUE) 
    .Internal(quit(save, status, runLast)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
quote
list(`package:base` = .Primitive("quote"), .Primitive("quote"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
R.home
list(`package:base` = function (component = "home") 
{
  rh <- .Internal(R.home())
  switch(component, home = rh, bin = if (.Platform$OS.type == "windows" && nzchar(p <- .Platform$r_arch)) file.path(rh, component, p) else file.path(rh, component), share = if (nzchar(p <- Sys.getenv("R_SHARE_DIR"))) p else file.path(rh, component), doc = if (nzchar(p <- Sys.getenv("R_DOC_DIR"))) p else file.path(rh, component), include = if (nzchar(p <- Sys.getenv("R_INCLUDE_DIR"))) p else file.path(rh, component), modules = if (nzchar(p <- .Platform$r_arch)) file.path(rh, component, p) else file.path(rh, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            component), file.path(rh, component))
}, function (component = "home") 
{
  rh <- .Internal(R.home())
  switch(component, home = rh, bin = if (.Platform$OS.type == "windows" && nzchar(p <- .Platform$r_arch)) file.path(rh, component, p) else file.path(rh, component), share = if (nzchar(p <- Sys.getenv("R_SHARE_DIR"))) p else file.path(rh, component), doc = if (nzchar(p <- Sys.getenv("R_DOC_DIR"))) p else file.path(rh, component), include = if (nzchar(p <- Sys.getenv("R_INCLUDE_DIR"))) p else file.path(rh, component), modules = if (nzchar(p <- .Platform$r_arch)) file.path(rh, component, p) else file.path(rh, 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            component), file.path(rh, component))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
R.version
list(`package:base` = list(platform = "x86_64-w64-mingw32", arch = "x86_64", os = "mingw32", crt = "ucrt", system = "x86_64, mingw32", status = "", major = "4", minor = "2.1", year = "2022", month = "06", day = "23", `svn rev` = "82513", language = "R", version.string = "R version 4.2.1 (2022-06-23 ucrt)", nickname = "Funny-Looking Kid"), list(platform = "x86_64-w64-mingw32", arch = "x86_64", os = "mingw32", crt = "ucrt", system = "x86_64, mingw32", status = "", major = "4", minor = "2.1", year = "2022", 
                                                                                                                                                                                                                                                                                                                                                          month = "06", day = "23", `svn rev` = "82513", language = "R", version.string = "R version 4.2.1 (2022-06-23 ucrt)", nickname = "Funny-Looking Kid"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
R.Version
list(`package:base` = function () 
  .Internal(Version()), function () 
    .Internal(Version()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
R.version.string
list(`package:base` = "R version 4.2.1 (2022-06-23 ucrt)", "R version 4.2.1 (2022-06-23 ucrt)")
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
R_system_version
list(`package:base` = function (x, strict = TRUE) 
  .make_numeric_version(x, strict, .standard_regexps()$valid_R_system_version, c("R_system_version", "package_version")), function (x, strict = TRUE) 
    .make_numeric_version(x, strict, .standard_regexps()$valid_R_system_version, c("R_system_version", "package_version")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
range
list(`package:base` = .Primitive("range"), .Primitive("range"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
range.default
list(`package:base` = function (..., na.rm = FALSE, finite = FALSE) 
{
  x <- c(..., recursive = TRUE)
  if (is.numeric(x)) {
    if (finite) 
      x <- x[is.finite(x)]
    else if (na.rm) 
      x <- x[!is.na(x)]
    c(min(x), max(x))
  }
  else {
    if (finite) 
      na.rm <- TRUE
    c(min(x, na.rm = na.rm), max(x, na.rm = na.rm))
  }
}, function (..., na.rm = FALSE, finite = FALSE) 
{
  x <- c(..., recursive = TRUE)
  if (is.numeric(x)) {
    if (finite) 
      x <- x[is.finite(x)]
    else if (na.rm) 
      x <- x[!is.na(x)]
    c(min(x), max(x))
  }
  else {
    if (finite) 
      na.rm <- TRUE
    c(min(x, na.rm = na.rm), max(x, na.rm = na.rm))
  }
}, function (..., na.rm = FALSE, finite = FALSE) 
{
  x <- c(..., recursive = TRUE)
  if (is.numeric(x)) {
    if (finite) 
      x <- x[is.finite(x)]
    else if (na.rm) 
      x <- x[!is.na(x)]
    c(min(x), max(x))
  }
  else {
    if (finite) 
      na.rm <- TRUE
    c(min(x, na.rm = na.rm), max(x, na.rm = na.rm))
  }
})
c("package:base", "registered S3 method for range from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rank
list(`package:base` = function (x, na.last = TRUE, ties.method = c("average", "first", "last", "random", "max", "min")) 
{
  stopifnot(length(na.last) == 1)
  nas <- is.na(x)
  nm <- names(x)
  ties.method <- match.arg(ties.method)
  if (is.factor(x)) 
    x <- as.integer(x)
  x <- x[!nas]
  y <- switch(ties.method, average = , min = , max = .Internal(rank(x, length(x), ties.method)), first = sort.list(sort.list(x)), last = sort.list(rev.default(sort.list(x, decreasing = TRUE))), random = sort.list(order(x, stats::runif(sum(!nas)))))
  if (!is.na(na.last) && any(nas)) {
    yy <- NA
    NAkeep <- (na.last == "keep")
    if (NAkeep || na.last) {
      yy[!nas] <- y
      if (!NAkeep) 
        yy[nas] <- (length(y) + 1):length(yy)
    }
    else {
      len <- sum(nas)
      yy[!nas] <- y + len
      yy[nas] <- seq_len(len)
    }
    y <- yy
    names(y) <- nm
  }
  else names(y) <- nm[!nas]
  y
}, function (x, na.last = TRUE, ties.method = c("average", "first", "last", "random", "max", "min")) 
{
  stopifnot(length(na.last) == 1)
  nas <- is.na(x)
  nm <- names(x)
  ties.method <- match.arg(ties.method)
  if (is.factor(x)) 
    x <- as.integer(x)
  x <- x[!nas]
  y <- switch(ties.method, average = , min = , max = .Internal(rank(x, length(x), ties.method)), first = sort.list(sort.list(x)), last = sort.list(rev.default(sort.list(x, decreasing = TRUE))), random = sort.list(order(x, stats::runif(sum(!nas)))))
  if (!is.na(na.last) && any(nas)) {
    yy <- NA
    NAkeep <- (na.last == "keep")
    if (NAkeep || na.last) {
      yy[!nas] <- y
      if (!NAkeep) 
        yy[nas] <- (length(y) + 1):length(yy)
    }
    else {
      len <- sum(nas)
      yy[!nas] <- y + len
      yy[nas] <- seq_len(len)
    }
    y <- yy
    names(y) <- nm
  }
  else names(y) <- nm[!nas]
  y
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rapply
list(`package:base` = function (object, f, classes = "ANY", deflt = NULL, how = c("unlist", "replace", "list"), ...) 
{
  how <- match.arg(how)
  res <- .Internal(rapply(object, f, classes, deflt, how))
  if (how == "unlist") 
    unlist(res, recursive = TRUE)
  else res
}, function (object, f, classes = "ANY", deflt = NULL, how = c("unlist", "replace", "list"), ...) 
{
  how <- match.arg(how)
  res <- .Internal(rapply(object, f, classes, deflt, how))
  if (how == "unlist") 
    unlist(res, recursive = TRUE)
  else res
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
raw
list(`package:base` = function (length = 0) 
  .Internal(vector("raw", length)), function (length = 0) 
    .Internal(vector("raw", length)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rawConnection
list(`package:base` = function (object, open = "r") 
{
  .Internal(rawConnection(deparse(substitute(object)), object, open))
}, function (object, open = "r") 
{
  .Internal(rawConnection(deparse(substitute(object)), object, open))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rawConnectionValue
list(`package:base` = function (con) 
  .Internal(rawConnectionValue(con)), function (con) 
    .Internal(rawConnectionValue(con)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rawShift
list(`package:base` = function (x, n) 
  .Internal(rawShift(x, n)), function (x, n) 
    .Internal(rawShift(x, n)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rawToBits
list(`package:base` = function (x) 
  .Internal(rawToBits(x)), function (x) 
    .Internal(rawToBits(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rawToChar
list(`package:base` = function (x, multiple = FALSE) 
  .Internal(rawToChar(x, multiple)), function (x, multiple = FALSE) 
    .Internal(rawToChar(x, multiple)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rbind
list(`package:base` = function (..., deparse.level = 1) 
  .Internal(rbind(deparse.level, ...)), function (..., deparse.level = 1) 
  {
    has.dl <- !missing(deparse.level)
    deparse.level <- as.integer(deparse.level)
    if (identical(deparse.level, -1)) 
      deparse.level <- 0
    stopifnot(0 <= deparse.level, deparse.level <= 2)
    argl <- list(...)
    na <- nargs() - has.dl
    while (na > 0 && is.null(argl[[na]])) {
      argl <- argl[-na]
      na <- na - 1
    }
    if (na == 0) 
      return(NULL)
    symarg <- as.list(substitute(list(...)))[-1]
    nmsym <- names(symarg)
    nm <- c(function(i) NULL, function(i) if (is.symbol(s <- symarg[[i]])) deparse(s) else NULL, function(i) deparse(symarg[[i]])[[1]])[[1 + deparse.level]]
    Nms <- function(i) {
      if (!is.null(s <- nmsym[i]) && nzchar(s)) 
        s
      else nm(i)
    }
    if (na == 1) {
      if (isS4(..1)) {
        r <- rbind2(..1)
        if (length(dim(..1)) < 2 && length(dim(r)) == 2) 
          rownames(r) <- Nms(1)
        return(r)
      }
      else return(base::rbind(..., deparse.level = deparse.level))
    }
    if (na == 2) {
      fix.na <- FALSE
    }
    else {
      nrs <- unname(lapply(argl, ncol))
      iV <- vapply(nrs, is.null, NA)
      fix.na <- identical(nrs[(na - 1):na], list(NULL, NULL))
      if (fix.na) {
        nr <- max(if (all(iV)) lengths(argl) else unlist(nrs[!iV]))
        argl[[na]] <- rbind(rep(argl[[na]], length.out = nr), deparse.level = 0)
      }
      if (fix.na) 
        fix.na <- !is.null(Nna <- Nms(na))
    }
    Nrow <- function(x) {
      d <- dim(x)
      if (length(d) == 2) 
        d[1]
      else as.integer(length(x) > 0)
    }
    setN <- function(i, nams) rownames(r)[i] <<- if (is.null(nams)) 
      ""
    else nams
    r <- argl[[na]]
    for (i in (na - 1):1) {
      d2 <- dim(r)
      r <- rbind2(argl[[i]], r)
      ism1 <- !is.null(d1 <- dim(argl[[i]])) && length(d1) == 2
      ism2 <- !is.null(d2) && length(d2) == 2
      if (ism1 && ism2) 
        next
      nn1 <- !is.null(N1 <- if ((l1 <- Nrow(argl[[i]])) && !ism1) Nms(i))
      nn2 <- !is.null(N2 <- if (i == na - 1 && Nrow(argl[[na]]) && !ism2) Nms(na))
      if (nn1 || nn2) {
        if (is.null(rownames(r))) 
          rownames(r) <- rep.int("", nrow(r))
        if (nn1) 
          setN(1, N1)
        if (nn2) 
          setN(1 + l1, N2)
      }
    }
    if (fix.na) {
      if (is.null(rownames(r))) 
        rownames(r) <- rep.int("", nrow(r))
      setN(nrow(r), Nna)
    }
    r
  }, function (..., deparse.level = 1) 
    .Internal(rbind(deparse.level, ...)))
c("package:base", "namespace:methods", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
rbind.data.frame
list(`package:base` = function (..., deparse.level = 1, make.row.names = TRUE, stringsAsFactors = FALSE, factor.exclude = TRUE) 
{
  match.names <- function(clabs, nmi) {
    if (identical(clabs, nmi)) 
      NULL
    else if (length(nmi) == length(clabs) && all(nmi %in% clabs)) {
      m <- pmatch(nmi, clabs, 0)
      if (any(m == 0)) 
        stop("names do not match previous names")
      m
    }
    else stop("names do not match previous names")
  }
  allargs <- list(...)
  allargs <- allargs[lengths(allargs) > 0]
  if (length(allargs)) {
    nr <- vapply(allargs, function(x) if (is.data.frame(x)) 
      .row_names_info(x, 2)
      else if (is.list(x)) 
        length(x[[1]])
      else length(x), 1)
    if (any(n0 <- nr == 0)) {
      if (all(n0)) 
        return(allargs[[1]])
      allargs <- allargs[!n0]
    }
  }
  n <- length(allargs)
  if (n == 0) 
    return(list2DF())
  nms <- names(allargs)
  if (is.null(nms)) 
    nms <- character(n)
  cl <- NULL
  perm <- rows <- vector("list", n)
  if (make.row.names) {
    rlabs <- rows
    autoRnms <- TRUE
    Make.row.names <- function(nmi, ri, ni, nrow) {
      if (nzchar(nmi)) {
        if (autoRnms) 
          autoRnms <<- FALSE
        if (ni == 0) 
          character()
        else if (ni > 1) 
          paste(nmi, ri, sep = ".")
        else nmi
      }
      else if (autoRnms && nrow > 0 && identical(ri, seq_len(ni))) 
        as.integer(seq.int(from = nrow + 1, length.out = ni))
      else {
        if (autoRnms && (nrow > 0 || !identical(ri, seq_len(ni)))) 
          autoRnms <<- FALSE
        ri
      }
    }
  }
  smartX <- isTRUE(factor.exclude)
  nrow <- 0
  value <- clabs <- NULL
  all.levs <- list()
  for (i in seq_len(n)) {
    xi <- allargs[[i]]
    nmi <- nms[i]
    if (is.matrix(xi)) 
      allargs[[i]] <- xi <- as.data.frame(xi, stringsAsFactors = stringsAsFactors)
    if (inherits(xi, "data.frame")) {
      if (is.null(cl)) 
        cl <- oldClass(xi)
      ri <- attr(xi, "row.names")
      ni <- length(ri)
      if (is.null(clabs)) 
        clabs <- names(xi)
      else {
        if (length(xi) != length(clabs)) 
          stop("numbers of columns of arguments do not match")
        pi <- match.names(clabs, names(xi))
        if (!is.null(pi)) 
          perm[[i]] <- pi
      }
      rows[[i]] <- seq.int(from = nrow + 1, length.out = ni)
      if (make.row.names) 
        rlabs[[i]] <- Make.row.names(nmi, ri, ni, nrow)
      nrow <- nrow + ni
      if (is.null(value)) {
        value <- unclass(xi)
        nvar <- length(value)
        all.levs <- vector("list", nvar)
        has.dim <- facCol <- ordCol <- logical(nvar)
        if (smartX) 
          NA.lev <- ordCol
        for (j in seq_len(nvar)) {
          xj <- value[[j]]
          facCol[j] <- fac <- if (!is.null(lj <- levels(xj))) {
            all.levs[[j]] <- lj
            TRUE
          }
          else is.factor(xj)
          if (fac) {
            ordCol[j] <- is.ordered(xj)
            if (smartX && !NA.lev[j]) 
              NA.lev[j] <- anyNA(lj)
          }
          has.dim[j] <- length(dim(xj)) == 2
        }
      }
      else for (j in seq_len(nvar)) {
        xij <- xi[[j]]
        if (is.null(pi) || is.na(jj <- pi[[j]])) 
          jj <- j
        if (facCol[jj]) {
          if (length(lij <- levels(xij))) {
            all.levs[[jj]] <- unique(c(all.levs[[jj]], lij))
            if (ordCol[jj]) 
              ordCol[jj] <- is.ordered(xij)
            if (smartX && !NA.lev[jj]) 
              NA.lev[jj] <- anyNA(lij)
          }
          else if (is.character(xij)) 
            all.levs[[jj]] <- unique(c(all.levs[[jj]], xij))
        }
      }
    }
    else if (is.list(xi)) {
      ni <- range(lengths(xi))
      if (ni[1] == ni[2]) 
        ni <- ni[1]
      else stop("invalid list argument: all variables should have the same length")
      ri <- seq_len(ni)
      rows[[i]] <- seq.int(from = nrow + 1, length.out = ni)
      if (make.row.names) 
        rlabs[[i]] <- Make.row.names(nmi, ri, ni, nrow)
      nrow <- nrow + ni
      if (length(nmi <- names(xi)) > 0) {
        if (is.null(clabs)) 
          clabs <- nmi
        else {
          if (length(xi) != length(clabs)) 
            stop("numbers of columns of arguments do not match")
          pi <- match.names(clabs, nmi)
          if (!is.null(pi)) 
            perm[[i]] <- pi
        }
      }
    }
    else if (length(xi)) {
      rows[[i]] <- nrow <- nrow + 1
      if (make.row.names) 
        rlabs[[i]] <- if (nzchar(nmi)) 
          nmi
      else as.integer(nrow)
    }
  }
  nvar <- length(clabs)
  if (nvar == 0) 
    nvar <- max(lengths(allargs))
  if (nvar == 0) 
    return(list2DF())
  pseq <- seq_len(nvar)
  if (is.null(value)) {
    value <- list()
    value[pseq] <- list(logical(nrow))
    all.levs <- vector("list", nvar)
    has.dim <- facCol <- ordCol <- logical(nvar)
    if (smartX) 
      NA.lev <- ordCol
  }
  names(value) <- clabs
  for (j in pseq) if (length(lij <- all.levs[[j]])) 
    value[[j]] <- factor(as.vector(value[[j]]), levels = lij, exclude = if (smartX) {
      if (!NA.lev[j]) 
        NA
    }
    else factor.exclude, ordered = ordCol[j])
  if (any(has.dim)) {
    jdim <- pseq[has.dim]
    if (!all(df <- vapply(jdim, function(j) inherits(value[[j]], "data.frame"), NA))) {
      rmax <- max(unlist(rows))
      for (j in jdim[!df]) {
        dn <- dimnames(vj <- value[[j]])
        rn <- dn[[1]]
        if (length(rn) > 0) 
          length(rn) <- rmax
        pj <- dim(vj)[2]
        length(vj) <- rmax * pj
        value[[j]] <- array(vj, c(rmax, pj), list(rn, dn[[2]]))
      }
    }
  }
  for (i in seq_len(n)) {
    xi <- unclass(allargs[[i]])
    if (!is.list(xi)) 
      if ((ni <- length(xi)) != nvar) {
        if (ni && nvar%%ni != 0) 
          warning(gettextf("number of columns of result, %d, is not a multiple of vector length %d of arg %d", nvar, ni, i), domain = NA)
        xi <- rep_len(xi, nvar)
      }
    ri <- rows[[i]]
    pi <- perm[[i]]
    if (is.null(pi)) 
      pi <- pseq
    for (j in pseq) {
      jj <- pi[j]
      xij <- xi[[j]]
      if (has.dim[jj]) {
        value[[jj]][ri, ] <- xij
        if (!is.null(r <- rownames(xij)) && !(inherits(xij, "data.frame") && .row_names_info(xij) <= 0)) 
          rownames(value[[jj]])[ri] <- r
      }
      else {
        value[[jj]][ri] <- if (is.factor(xij)) 
          as.vector(xij)
        else xij
        if (!is.null(nm <- names(xij))) 
          names(value[[jj]])[ri] <- nm
      }
    }
  }
  rlabs <- if (make.row.names && !autoRnms) {
    rlabs <- unlist(rlabs)
    if (anyDuplicated(rlabs)) 
      make.unique(as.character(rlabs), sep = "")
    else rlabs
  }
  if (is.null(cl)) {
    as.data.frame(value, row.names = rlabs, fix.empty.names = TRUE, stringsAsFactors = stringsAsFactors)
  }
  else {
    structure(value, class = cl, row.names = if (is.null(rlabs)) 
      .set_row_names(nrow)
      else rlabs)
  }
}, function (..., deparse.level = 1, make.row.names = TRUE, stringsAsFactors = FALSE, factor.exclude = TRUE) 
{
  match.names <- function(clabs, nmi) {
    if (identical(clabs, nmi)) 
      NULL
    else if (length(nmi) == length(clabs) && all(nmi %in% clabs)) {
      m <- pmatch(nmi, clabs, 0)
      if (any(m == 0)) 
        stop("names do not match previous names")
      m
    }
    else stop("names do not match previous names")
  }
  allargs <- list(...)
  allargs <- allargs[lengths(allargs) > 0]
  if (length(allargs)) {
    nr <- vapply(allargs, function(x) if (is.data.frame(x)) 
      .row_names_info(x, 2)
      else if (is.list(x)) 
        length(x[[1]])
      else length(x), 1)
    if (any(n0 <- nr == 0)) {
      if (all(n0)) 
        return(allargs[[1]])
      allargs <- allargs[!n0]
    }
  }
  n <- length(allargs)
  if (n == 0) 
    return(list2DF())
  nms <- names(allargs)
  if (is.null(nms)) 
    nms <- character(n)
  cl <- NULL
  perm <- rows <- vector("list", n)
  if (make.row.names) {
    rlabs <- rows
    autoRnms <- TRUE
    Make.row.names <- function(nmi, ri, ni, nrow) {
      if (nzchar(nmi)) {
        if (autoRnms) 
          autoRnms <<- FALSE
        if (ni == 0) 
          character()
        else if (ni > 1) 
          paste(nmi, ri, sep = ".")
        else nmi
      }
      else if (autoRnms && nrow > 0 && identical(ri, seq_len(ni))) 
        as.integer(seq.int(from = nrow + 1, length.out = ni))
      else {
        if (autoRnms && (nrow > 0 || !identical(ri, seq_len(ni)))) 
          autoRnms <<- FALSE
        ri
      }
    }
  }
  smartX <- isTRUE(factor.exclude)
  nrow <- 0
  value <- clabs <- NULL
  all.levs <- list()
  for (i in seq_len(n)) {
    xi <- allargs[[i]]
    nmi <- nms[i]
    if (is.matrix(xi)) 
      allargs[[i]] <- xi <- as.data.frame(xi, stringsAsFactors = stringsAsFactors)
    if (inherits(xi, "data.frame")) {
      if (is.null(cl)) 
        cl <- oldClass(xi)
      ri <- attr(xi, "row.names")
      ni <- length(ri)
      if (is.null(clabs)) 
        clabs <- names(xi)
      else {
        if (length(xi) != length(clabs)) 
          stop("numbers of columns of arguments do not match")
        pi <- match.names(clabs, names(xi))
        if (!is.null(pi)) 
          perm[[i]] <- pi
      }
      rows[[i]] <- seq.int(from = nrow + 1, length.out = ni)
      if (make.row.names) 
        rlabs[[i]] <- Make.row.names(nmi, ri, ni, nrow)
      nrow <- nrow + ni
      if (is.null(value)) {
        value <- unclass(xi)
        nvar <- length(value)
        all.levs <- vector("list", nvar)
        has.dim <- facCol <- ordCol <- logical(nvar)
        if (smartX) 
          NA.lev <- ordCol
        for (j in seq_len(nvar)) {
          xj <- value[[j]]
          facCol[j] <- fac <- if (!is.null(lj <- levels(xj))) {
            all.levs[[j]] <- lj
            TRUE
          }
          else is.factor(xj)
          if (fac) {
            ordCol[j] <- is.ordered(xj)
            if (smartX && !NA.lev[j]) 
              NA.lev[j] <- anyNA(lj)
          }
          has.dim[j] <- length(dim(xj)) == 2
        }
      }
      else for (j in seq_len(nvar)) {
        xij <- xi[[j]]
        if (is.null(pi) || is.na(jj <- pi[[j]])) 
          jj <- j
        if (facCol[jj]) {
          if (length(lij <- levels(xij))) {
            all.levs[[jj]] <- unique(c(all.levs[[jj]], lij))
            if (ordCol[jj]) 
              ordCol[jj] <- is.ordered(xij)
            if (smartX && !NA.lev[jj]) 
              NA.lev[jj] <- anyNA(lij)
          }
          else if (is.character(xij)) 
            all.levs[[jj]] <- unique(c(all.levs[[jj]], xij))
        }
      }
    }
    else if (is.list(xi)) {
      ni <- range(lengths(xi))
      if (ni[1] == ni[2]) 
        ni <- ni[1]
      else stop("invalid list argument: all variables should have the same length")
      ri <- seq_len(ni)
      rows[[i]] <- seq.int(from = nrow + 1, length.out = ni)
      if (make.row.names) 
        rlabs[[i]] <- Make.row.names(nmi, ri, ni, nrow)
      nrow <- nrow + ni
      if (length(nmi <- names(xi)) > 0) {
        if (is.null(clabs)) 
          clabs <- nmi
        else {
          if (length(xi) != length(clabs)) 
            stop("numbers of columns of arguments do not match")
          pi <- match.names(clabs, nmi)
          if (!is.null(pi)) 
            perm[[i]] <- pi
        }
      }
    }
    else if (length(xi)) {
      rows[[i]] <- nrow <- nrow + 1
      if (make.row.names) 
        rlabs[[i]] <- if (nzchar(nmi)) 
          nmi
      else as.integer(nrow)
    }
  }
  nvar <- length(clabs)
  if (nvar == 0) 
    nvar <- max(lengths(allargs))
  if (nvar == 0) 
    return(list2DF())
  pseq <- seq_len(nvar)
  if (is.null(value)) {
    value <- list()
    value[pseq] <- list(logical(nrow))
    all.levs <- vector("list", nvar)
    has.dim <- facCol <- ordCol <- logical(nvar)
    if (smartX) 
      NA.lev <- ordCol
  }
  names(value) <- clabs
  for (j in pseq) if (length(lij <- all.levs[[j]])) 
    value[[j]] <- factor(as.vector(value[[j]]), levels = lij, exclude = if (smartX) {
      if (!NA.lev[j]) 
        NA
    }
    else factor.exclude, ordered = ordCol[j])
  if (any(has.dim)) {
    jdim <- pseq[has.dim]
    if (!all(df <- vapply(jdim, function(j) inherits(value[[j]], "data.frame"), NA))) {
      rmax <- max(unlist(rows))
      for (j in jdim[!df]) {
        dn <- dimnames(vj <- value[[j]])
        rn <- dn[[1]]
        if (length(rn) > 0) 
          length(rn) <- rmax
        pj <- dim(vj)[2]
        length(vj) <- rmax * pj
        value[[j]] <- array(vj, c(rmax, pj), list(rn, dn[[2]]))
      }
    }
  }
  for (i in seq_len(n)) {
    xi <- unclass(allargs[[i]])
    if (!is.list(xi)) 
      if ((ni <- length(xi)) != nvar) {
        if (ni && nvar%%ni != 0) 
          warning(gettextf("number of columns of result, %d, is not a multiple of vector length %d of arg %d", nvar, ni, i), domain = NA)
        xi <- rep_len(xi, nvar)
      }
    ri <- rows[[i]]
    pi <- perm[[i]]
    if (is.null(pi)) 
      pi <- pseq
    for (j in pseq) {
      jj <- pi[j]
      xij <- xi[[j]]
      if (has.dim[jj]) {
        value[[jj]][ri, ] <- xij
        if (!is.null(r <- rownames(xij)) && !(inherits(xij, "data.frame") && .row_names_info(xij) <= 0)) 
          rownames(value[[jj]])[ri] <- r
      }
      else {
        value[[jj]][ri] <- if (is.factor(xij)) 
          as.vector(xij)
        else xij
        if (!is.null(nm <- names(xij))) 
          names(value[[jj]])[ri] <- nm
      }
    }
  }
  rlabs <- if (make.row.names && !autoRnms) {
    rlabs <- unlist(rlabs)
    if (anyDuplicated(rlabs)) 
      make.unique(as.character(rlabs), sep = "")
    else rlabs
  }
  if (is.null(cl)) {
    as.data.frame(value, row.names = rlabs, fix.empty.names = TRUE, stringsAsFactors = stringsAsFactors)
  }
  else {
    structure(value, class = cl, row.names = if (is.null(rlabs)) 
      .set_row_names(nrow)
      else rlabs)
  }
}, function (..., deparse.level = 1, make.row.names = TRUE, stringsAsFactors = FALSE, factor.exclude = TRUE) 
{
  match.names <- function(clabs, nmi) {
    if (identical(clabs, nmi)) 
      NULL
    else if (length(nmi) == length(clabs) && all(nmi %in% clabs)) {
      m <- pmatch(nmi, clabs, 0)
      if (any(m == 0)) 
        stop("names do not match previous names")
      m
    }
    else stop("names do not match previous names")
  }
  allargs <- list(...)
  allargs <- allargs[lengths(allargs) > 0]
  if (length(allargs)) {
    nr <- vapply(allargs, function(x) if (is.data.frame(x)) 
      .row_names_info(x, 2)
      else if (is.list(x)) 
        length(x[[1]])
      else length(x), 1)
    if (any(n0 <- nr == 0)) {
      if (all(n0)) 
        return(allargs[[1]])
      allargs <- allargs[!n0]
    }
  }
  n <- length(allargs)
  if (n == 0) 
    return(list2DF())
  nms <- names(allargs)
  if (is.null(nms)) 
    nms <- character(n)
  cl <- NULL
  perm <- rows <- vector("list", n)
  if (make.row.names) {
    rlabs <- rows
    autoRnms <- TRUE
    Make.row.names <- function(nmi, ri, ni, nrow) {
      if (nzchar(nmi)) {
        if (autoRnms) 
          autoRnms <<- FALSE
        if (ni == 0) 
          character()
        else if (ni > 1) 
          paste(nmi, ri, sep = ".")
        else nmi
      }
      else if (autoRnms && nrow > 0 && identical(ri, seq_len(ni))) 
        as.integer(seq.int(from = nrow + 1, length.out = ni))
      else {
        if (autoRnms && (nrow > 0 || !identical(ri, seq_len(ni)))) 
          autoRnms <<- FALSE
        ri
      }
    }
  }
  smartX <- isTRUE(factor.exclude)
  nrow <- 0
  value <- clabs <- NULL
  all.levs <- list()
  for (i in seq_len(n)) {
    xi <- allargs[[i]]
    nmi <- nms[i]
    if (is.matrix(xi)) 
      allargs[[i]] <- xi <- as.data.frame(xi, stringsAsFactors = stringsAsFactors)
    if (inherits(xi, "data.frame")) {
      if (is.null(cl)) 
        cl <- oldClass(xi)
      ri <- attr(xi, "row.names")
      ni <- length(ri)
      if (is.null(clabs)) 
        clabs <- names(xi)
      else {
        if (length(xi) != length(clabs)) 
          stop("numbers of columns of arguments do not match")
        pi <- match.names(clabs, names(xi))
        if (!is.null(pi)) 
          perm[[i]] <- pi
      }
      rows[[i]] <- seq.int(from = nrow + 1, length.out = ni)
      if (make.row.names) 
        rlabs[[i]] <- Make.row.names(nmi, ri, ni, nrow)
      nrow <- nrow + ni
      if (is.null(value)) {
        value <- unclass(xi)
        nvar <- length(value)
        all.levs <- vector("list", nvar)
        has.dim <- facCol <- ordCol <- logical(nvar)
        if (smartX) 
          NA.lev <- ordCol
        for (j in seq_len(nvar)) {
          xj <- value[[j]]
          facCol[j] <- fac <- if (!is.null(lj <- levels(xj))) {
            all.levs[[j]] <- lj
            TRUE
          }
          else is.factor(xj)
          if (fac) {
            ordCol[j] <- is.ordered(xj)
            if (smartX && !NA.lev[j]) 
              NA.lev[j] <- anyNA(lj)
          }
          has.dim[j] <- length(dim(xj)) == 2
        }
      }
      else for (j in seq_len(nvar)) {
        xij <- xi[[j]]
        if (is.null(pi) || is.na(jj <- pi[[j]])) 
          jj <- j
        if (facCol[jj]) {
          if (length(lij <- levels(xij))) {
            all.levs[[jj]] <- unique(c(all.levs[[jj]], lij))
            if (ordCol[jj]) 
              ordCol[jj] <- is.ordered(xij)
            if (smartX && !NA.lev[jj]) 
              NA.lev[jj] <- anyNA(lij)
          }
          else if (is.character(xij)) 
            all.levs[[jj]] <- unique(c(all.levs[[jj]], xij))
        }
      }
    }
    else if (is.list(xi)) {
      ni <- range(lengths(xi))
      if (ni[1] == ni[2]) 
        ni <- ni[1]
      else stop("invalid list argument: all variables should have the same length")
      ri <- seq_len(ni)
      rows[[i]] <- seq.int(from = nrow + 1, length.out = ni)
      if (make.row.names) 
        rlabs[[i]] <- Make.row.names(nmi, ri, ni, nrow)
      nrow <- nrow + ni
      if (length(nmi <- names(xi)) > 0) {
        if (is.null(clabs)) 
          clabs <- nmi
        else {
          if (length(xi) != length(clabs)) 
            stop("numbers of columns of arguments do not match")
          pi <- match.names(clabs, nmi)
          if (!is.null(pi)) 
            perm[[i]] <- pi
        }
      }
    }
    else if (length(xi)) {
      rows[[i]] <- nrow <- nrow + 1
      if (make.row.names) 
        rlabs[[i]] <- if (nzchar(nmi)) 
          nmi
      else as.integer(nrow)
    }
  }
  nvar <- length(clabs)
  if (nvar == 0) 
    nvar <- max(lengths(allargs))
  if (nvar == 0) 
    return(list2DF())
  pseq <- seq_len(nvar)
  if (is.null(value)) {
    value <- list()
    value[pseq] <- list(logical(nrow))
    all.levs <- vector("list", nvar)
    has.dim <- facCol <- ordCol <- logical(nvar)
    if (smartX) 
      NA.lev <- ordCol
  }
  names(value) <- clabs
  for (j in pseq) if (length(lij <- all.levs[[j]])) 
    value[[j]] <- factor(as.vector(value[[j]]), levels = lij, exclude = if (smartX) {
      if (!NA.lev[j]) 
        NA
    }
    else factor.exclude, ordered = ordCol[j])
  if (any(has.dim)) {
    jdim <- pseq[has.dim]
    if (!all(df <- vapply(jdim, function(j) inherits(value[[j]], "data.frame"), NA))) {
      rmax <- max(unlist(rows))
      for (j in jdim[!df]) {
        dn <- dimnames(vj <- value[[j]])
        rn <- dn[[1]]
        if (length(rn) > 0) 
          length(rn) <- rmax
        pj <- dim(vj)[2]
        length(vj) <- rmax * pj
        value[[j]] <- array(vj, c(rmax, pj), list(rn, dn[[2]]))
      }
    }
  }
  for (i in seq_len(n)) {
    xi <- unclass(allargs[[i]])
    if (!is.list(xi)) 
      if ((ni <- length(xi)) != nvar) {
        if (ni && nvar%%ni != 0) 
          warning(gettextf("number of columns of result, %d, is not a multiple of vector length %d of arg %d", nvar, ni, i), domain = NA)
        xi <- rep_len(xi, nvar)
      }
    ri <- rows[[i]]
    pi <- perm[[i]]
    if (is.null(pi)) 
      pi <- pseq
    for (j in pseq) {
      jj <- pi[j]
      xij <- xi[[j]]
      if (has.dim[jj]) {
        value[[jj]][ri, ] <- xij
        if (!is.null(r <- rownames(xij)) && !(inherits(xij, "data.frame") && .row_names_info(xij) <= 0)) 
          rownames(value[[jj]])[ri] <- r
      }
      else {
        value[[jj]][ri] <- if (is.factor(xij)) 
          as.vector(xij)
        else xij
        if (!is.null(nm <- names(xij))) 
          names(value[[jj]])[ri] <- nm
      }
    }
  }
  rlabs <- if (make.row.names && !autoRnms) {
    rlabs <- unlist(rlabs)
    if (anyDuplicated(rlabs)) 
      make.unique(as.character(rlabs), sep = "")
    else rlabs
  }
  if (is.null(cl)) {
    as.data.frame(value, row.names = rlabs, fix.empty.names = TRUE, stringsAsFactors = stringsAsFactors)
  }
  else {
    structure(value, class = cl, row.names = if (is.null(rlabs)) 
      .set_row_names(nrow)
      else rlabs)
  }
})
c("package:base", "registered S3 method for rbind from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rcond
list(`package:base` = function (x, norm = c("O", "I", "1"), triangular = FALSE, ...) 
{
  norm <- match.arg(norm)
  stopifnot(is.matrix(x))
  if ({
    d <- dim(x)
    d[1] != d[2]
  }) 
    return(rcond(qr.R(qr(if (d[1] < d[2]) t(x) else x)), norm = norm, ...))
  if (is.complex(x)) {
    if (triangular) 
      .Internal(La_ztrcon(x, norm))
    else .Internal(La_zgecon(x, norm))
  }
  else {
    if (triangular) 
      .Internal(La_dtrcon(x, norm))
    else .Internal(La_dgecon(x, norm))
  }
}, new("standardGeneric", .Data = function (x, norm, ...) 
  standardGeneric("rcond"), generic = "rcond", package = "base", group = list(), valueClass = character(0), signature = c("x", "norm"), default = new("derivedDefaultMethod", .Data = function (x, norm, ...) 
    base::rcond(x, norm, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "rcond"), skeleton = (new("derivedDefaultMethod", .Data = function (x, norm, ...) 
      base::rcond(x, norm, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "rcond"))(x, norm, ...)), function (x, norm = c("O", "I", "1"), triangular = FALSE, ...) 
      {
        norm <- match.arg(norm)
        stopifnot(is.matrix(x))
        if ({
          d <- dim(x)
          d[1] != d[2]
        }) 
          return(rcond(qr.R(qr(if (d[1] < d[2]) t(x) else x)), norm = norm, ...))
        if (is.complex(x)) {
          if (triangular) 
            .Internal(La_ztrcon(x, norm))
          else .Internal(La_zgecon(x, norm))
        }
        else {
          if (triangular) 
            .Internal(La_dtrcon(x, norm))
          else .Internal(La_dgecon(x, norm))
        }
      })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
Re
list(`package:base` = .Primitive("Re"), .Primitive("Re"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.dcf
list(`package:base` = function (file, fields = NULL, all = FALSE, keep.white = NULL) 
{
  if (is.character(file)) {
    file <- gzfile(file)
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  if (!all) 
    return(.Internal(readDCF(file, fields, keep.white)))
  .assemble_things_into_a_data_frame <- function(tags, vals, nums) {
    tf <- factor(tags, levels = unique(tags))
    cnts <- table(nums, tf)
    out <- array(NA, dim = dim(cnts), dimnames = list(NULL, levels(tf)))
    if (all(cnts <= 1)) {
      out[cbind(nums, tf)] <- vals
      out <- as.data.frame(out, optional = TRUE, stringsAsFactors = FALSE)
    }
    else {
      levs <- colSums(cnts > 1) == 0
      if (any(levs)) {
        inds <- tf %in% levels(tf)[levs]
        out[cbind(nums[inds], tf[inds])] <- vals[inds]
      }
      out <- as.data.frame(out, optional = TRUE, stringsAsFactors = FALSE)
      for (l in levels(tf)[!levs]) {
        out[[l]] <- rep.int(list(NA), nrow(cnts))
        i <- tf == l
        out[[l]][unique(nums[i])] <- split(vals[i], nums[i])
      }
    }
    out
  }
  ctype <- Sys.getlocale("LC_CTYPE")
  on.exit(Sys.setlocale("LC_CTYPE", ctype), add = TRUE)
  Sys.setlocale("LC_CTYPE", "C")
  lines <- readLines(file, skipNul = TRUE)
  ind <- grep("^[^[:blank:]][^:]*$", lines)
  if (length(ind)) {
    lines <- substr(lines[ind], 1, 0.7 * getOption("width"))
    stop(gettextf("Invalid DCF format.\nRegular lines must have a tag.\nOffending lines start with:\n%s", paste0("  ", lines, collapse = "\n")), domain = NA)
  }
  line_is_not_empty <- !grepl("^[[:space:]]*$", lines)
  nums <- cumsum(diff(c(FALSE, line_is_not_empty) > 0) > 0)
  nums <- nums[line_is_not_empty]
  lines <- lines[line_is_not_empty]
  line_is_escaped_blank <- grepl("^[[:space:]]+\\.[[:space:]]*$", lines)
  if (any(line_is_escaped_blank)) 
    lines[line_is_escaped_blank] <- ""
  line_has_tag <- grepl("^[^[:blank:]][^:]*:", lines)
  pos <- c(1, which(diff(nums) > 0) + 1)
  ind <- !line_has_tag[pos]
  if (any(ind)) {
    lines <- substr(lines[pos[ind]], 1, 0.7 * getOption("width"))
    stop(gettextf("Invalid DCF format.\nContinuation lines must not start a record.\nOffending lines start with:\n%s", paste0("  ", lines, collapse = "\n")), domain = NA)
  }
  lengths <- rle(cumsum(line_has_tag))$lengths
  pos <- cumsum(lengths)
  tags <- sub(":.*", "", lines[line_has_tag])
  lines[line_has_tag] <- sub("[^:]*:[[:space:]]*", "", lines[line_has_tag])
  fold <- is.na(match(tags, keep.white))
  foldable <- rep.int(fold, lengths)
  lines[foldable] <- sub("^[[:space:]]*", "", lines[foldable])
  lines[foldable] <- sub("[[:space:]]*$", "", lines[foldable])
  vals <- mapply(function(from, to) paste(lines[from:to], collapse = "\n"), c(1, pos[-length(pos)] + 1), pos)
  vals[fold] <- trimws(vals[fold])
  out <- .assemble_things_into_a_data_frame(tags, vals, nums[pos])
  if (!is.null(fields)) 
    out <- out[fields]
  out
}, function (file, fields = NULL, all = FALSE, keep.white = NULL) 
{
  if (is.character(file)) {
    file <- gzfile(file)
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  if (!all) 
    return(.Internal(readDCF(file, fields, keep.white)))
  .assemble_things_into_a_data_frame <- function(tags, vals, nums) {
    tf <- factor(tags, levels = unique(tags))
    cnts <- table(nums, tf)
    out <- array(NA, dim = dim(cnts), dimnames = list(NULL, levels(tf)))
    if (all(cnts <= 1)) {
      out[cbind(nums, tf)] <- vals
      out <- as.data.frame(out, optional = TRUE, stringsAsFactors = FALSE)
    }
    else {
      levs <- colSums(cnts > 1) == 0
      if (any(levs)) {
        inds <- tf %in% levels(tf)[levs]
        out[cbind(nums[inds], tf[inds])] <- vals[inds]
      }
      out <- as.data.frame(out, optional = TRUE, stringsAsFactors = FALSE)
      for (l in levels(tf)[!levs]) {
        out[[l]] <- rep.int(list(NA), nrow(cnts))
        i <- tf == l
        out[[l]][unique(nums[i])] <- split(vals[i], nums[i])
      }
    }
    out
  }
  ctype <- Sys.getlocale("LC_CTYPE")
  on.exit(Sys.setlocale("LC_CTYPE", ctype), add = TRUE)
  Sys.setlocale("LC_CTYPE", "C")
  lines <- readLines(file, skipNul = TRUE)
  ind <- grep("^[^[:blank:]][^:]*$", lines)
  if (length(ind)) {
    lines <- substr(lines[ind], 1, 0.7 * getOption("width"))
    stop(gettextf("Invalid DCF format.\nRegular lines must have a tag.\nOffending lines start with:\n%s", paste0("  ", lines, collapse = "\n")), domain = NA)
  }
  line_is_not_empty <- !grepl("^[[:space:]]*$", lines)
  nums <- cumsum(diff(c(FALSE, line_is_not_empty) > 0) > 0)
  nums <- nums[line_is_not_empty]
  lines <- lines[line_is_not_empty]
  line_is_escaped_blank <- grepl("^[[:space:]]+\\.[[:space:]]*$", lines)
  if (any(line_is_escaped_blank)) 
    lines[line_is_escaped_blank] <- ""
  line_has_tag <- grepl("^[^[:blank:]][^:]*:", lines)
  pos <- c(1, which(diff(nums) > 0) + 1)
  ind <- !line_has_tag[pos]
  if (any(ind)) {
    lines <- substr(lines[pos[ind]], 1, 0.7 * getOption("width"))
    stop(gettextf("Invalid DCF format.\nContinuation lines must not start a record.\nOffending lines start with:\n%s", paste0("  ", lines, collapse = "\n")), domain = NA)
  }
  lengths <- rle(cumsum(line_has_tag))$lengths
  pos <- cumsum(lengths)
  tags <- sub(":.*", "", lines[line_has_tag])
  lines[line_has_tag] <- sub("[^:]*:[[:space:]]*", "", lines[line_has_tag])
  fold <- is.na(match(tags, keep.white))
  foldable <- rep.int(fold, lengths)
  lines[foldable] <- sub("^[[:space:]]*", "", lines[foldable])
  lines[foldable] <- sub("[[:space:]]*$", "", lines[foldable])
  vals <- mapply(function(from, to) paste(lines[from:to], collapse = "\n"), c(1, pos[-length(pos)] + 1), pos)
  vals[fold] <- trimws(vals[fold])
  out <- .assemble_things_into_a_data_frame(tags, vals, nums[pos])
  if (!is.null(fields)) 
    out <- out[fields]
  out
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
readBin
list(`package:base` = function (con, what, n = 1, size = NA, signed = TRUE, endian = .Platform$endian) 
{
  if (!endian %in% c("big", "little", "swap")) 
    stop("invalid 'endian' argument")
  if (is.character(con)) {
    con <- file(con, "rb")
    on.exit(close(con))
  }
  swap <- endian != .Platform$endian
  if (!is.character(what) || is.na(what) || length(what) != 1 || !any(what == c("numeric", "double", "integer", "int", "logical", "complex", "character", "raw"))) 
    what <- typeof(what)
  .Internal(readBin(con, what, n, size, signed, swap))
}, function (con, what, n = 1, size = NA, signed = TRUE, endian = .Platform$endian) 
{
  if (!endian %in% c("big", "little", "swap")) 
    stop("invalid 'endian' argument")
  if (is.character(con)) {
    con <- file(con, "rb")
    on.exit(close(con))
  }
  swap <- endian != .Platform$endian
  if (!is.character(what) || is.na(what) || length(what) != 1 || !any(what == c("numeric", "double", "integer", "int", "logical", "complex", "character", "raw"))) 
    what <- typeof(what)
  .Internal(readBin(con, what, n, size, signed, swap))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
readChar
list(`package:base` = function (con, nchars, useBytes = FALSE) 
{
  if (is.character(con)) {
    con <- file(con, "rb")
    on.exit(close(con))
  }
  .Internal(readChar(con, as.integer(nchars), useBytes))
}, function (con, nchars, useBytes = FALSE) 
{
  if (is.character(con)) {
    con <- file(con, "rb")
    on.exit(close(con))
  }
  .Internal(readChar(con, as.integer(nchars), useBytes))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
readline
list(`package:base` = function (prompt = "") 
  .Internal(readline(prompt)), function (prompt = "") 
    .Internal(readline(prompt)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
readLines
list(`package:base` = function (con = stdin(), n = -1, ok = TRUE, warn = TRUE, encoding = "unknown", skipNul = FALSE) 
{
  if (is.character(con)) {
    con <- file(con, "r")
    on.exit(close(con))
  }
  .Internal(readLines(con, n, ok, warn, encoding, skipNul))
}, function (con = stdin(), n = -1, ok = TRUE, warn = TRUE, encoding = "unknown", skipNul = FALSE) 
{
  if (is.character(con)) {
    con <- file(con, "r")
    on.exit(close(con))
  }
  .Internal(readLines(con, n, ok, warn, encoding, skipNul))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
readRDS
list(`package:base` = function (file, refhook = NULL) 
{
  if (is.character(file)) {
    con <- gzfile(file, "rb")
    on.exit(close(con))
  }
  else if (inherits(file, "connection")) 
    con <- if (inherits(file, "url")) 
      gzcon(file)
  else file
  else stop("bad 'file' argument")
  .Internal(unserializeFromConn(con, refhook))
}, function (file, refhook = NULL) 
{
  if (is.character(file)) {
    con <- gzfile(file, "rb")
    on.exit(close(con))
  }
  else if (inherits(file, "connection")) 
    con <- if (inherits(file, "url")) 
      gzcon(file)
  else file
  else stop("bad 'file' argument")
  .Internal(unserializeFromConn(con, refhook))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
readRenviron
list(`package:base` = function (path) 
  .Internal(readRenviron(path)), function (path) 
    .Internal(readRenviron(path)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Recall
list(`package:base` = function (...) 
  .Internal(Recall(...)), function (...) 
    .Internal(Recall(...)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Reduce
list(`package:base` = function (f, x, init, right = FALSE, accumulate = FALSE) 
{
  mis <- missing(init)
  len <- length(x)
  if (len == 0) 
    return(if (mis) NULL else init)
  f <- match.fun(f)
  if (!is.vector(x) || is.object(x)) 
    x <- as.list(x)
  ind <- seq_len(len)
  if (mis) {
    if (right) {
      init <- x[[len]]
      ind <- ind[-len]
    }
    else {
      init <- x[[1]]
      ind <- ind[-1]
    }
  }
  if (!accumulate) {
    if (right) {
      for (i in rev(ind)) init <- forceAndCall(2, f, x[[i]], init)
    }
    else {
      for (i in ind) init <- forceAndCall(2, f, init, x[[i]])
    }
    init
  }
  else {
    len <- length(ind) + 1
    out <- vector("list", len)
    if (mis) {
      if (right) {
        out[[len]] <- init
        for (i in rev(ind)) {
          init <- forceAndCall(2, f, x[[i]], init)
          out[[i]] <- init
        }
      }
      else {
        out[[1]] <- init
        for (i in ind) {
          init <- forceAndCall(2, f, init, x[[i]])
          out[[i]] <- init
        }
      }
    }
    else {
      if (right) {
        out[[len]] <- init
        for (i in rev(ind)) {
          init <- forceAndCall(2, f, x[[i]], init)
          out[[i]] <- init
        }
      }
      else {
        for (i in ind) {
          out[[i]] <- init
          init <- forceAndCall(2, f, init, x[[i]])
        }
        out[[len]] <- init
      }
    }
    if (all(lengths(out) == 1)) 
      out <- unlist(out, recursive = FALSE)
    out
  }
}, function (f, x, init, right = FALSE, accumulate = FALSE) 
{
  mis <- missing(init)
  len <- length(x)
  if (len == 0) 
    return(if (mis) NULL else init)
  f <- match.fun(f)
  if (!is.vector(x) || is.object(x)) 
    x <- as.list(x)
  ind <- seq_len(len)
  if (mis) {
    if (right) {
      init <- x[[len]]
      ind <- ind[-len]
    }
    else {
      init <- x[[1]]
      ind <- ind[-1]
    }
  }
  if (!accumulate) {
    if (right) {
      for (i in rev(ind)) init <- forceAndCall(2, f, x[[i]], init)
    }
    else {
      for (i in ind) init <- forceAndCall(2, f, init, x[[i]])
    }
    init
  }
  else {
    len <- length(ind) + 1
    out <- vector("list", len)
    if (mis) {
      if (right) {
        out[[len]] <- init
        for (i in rev(ind)) {
          init <- forceAndCall(2, f, x[[i]], init)
          out[[i]] <- init
        }
      }
      else {
        out[[1]] <- init
        for (i in ind) {
          init <- forceAndCall(2, f, init, x[[i]])
          out[[i]] <- init
        }
      }
    }
    else {
      if (right) {
        out[[len]] <- init
        for (i in rev(ind)) {
          init <- forceAndCall(2, f, x[[i]], init)
          out[[i]] <- init
        }
      }
      else {
        for (i in ind) {
          out[[i]] <- init
          init <- forceAndCall(2, f, init, x[[i]])
        }
        out[[len]] <- init
      }
    }
    if (all(lengths(out) == 1)) 
      out <- unlist(out, recursive = FALSE)
    out
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
reg.finalizer
list(`package:base` = function (e, f, onexit = FALSE) 
  .Internal(reg.finalizer(e, f, onexit)), function (e, f, onexit = FALSE) 
    .Internal(reg.finalizer(e, f, onexit)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
regexec
list(`package:base` = function (pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(text) && length(levels(text)) < length(text)) {
    out <- regexec(pattern, c(levels(text), NA), ignore.case, perl, fixed, useBytes)
    outna <- out[length(out)]
    out <- out[text]
    out[is.na(text)] <- outna
    return(out)
  }
  if (!is.character(text)) 
    text <- as.character(text)
  if (!perl || fixed) {
    if (perl) 
      warning(gettextf("argument '%s' will be ignored", "perl = TRUE"), domain = NA)
    return(.Internal(regexec(as.character(pattern), text, ignore.case, fixed, useBytes)))
  }
  m <- regexpr(pattern, text, ignore.case = ignore.case, useBytes = useBytes, perl = TRUE)
  nm <- attr(m, "capture.names")
  nm <- if (any(nzchar(nm))) 
    c("", nm)
  match_data_from_pos_and_len <- function(pos, len, nm = NULL) {
    attr(pos, "match.length") <- len
    names(pos) <- nm
    pos
  }
  y <- vector("list", length(text))
  y[is.na(m)] <- list(match_data_from_pos_and_len(NA, NA))
  ind <- !is.na(m) & (m == -1)
  if (any(ind)) {
    y[ind] <- list(match_data_from_pos_and_len(-1, -1))
  }
  ind <- !is.na(m) & !ind
  if (any(ind)) {
    pos <- cbind(m[ind], attr(m, "capture.start")[ind, , drop = FALSE])
    len <- cbind(attr(m, "match.length")[ind], attr(m, "capture.length")[ind, , drop = FALSE])
    y[ind] <- Map(match_data_from_pos_and_len, split(pos, row(pos)), split(len, row(len)), list(nm))
  }
  if (identical(attr(m, "useBytes"), TRUE)) 
    y <- lapply(y, `attr<-`, "useBytes", TRUE)
  lapply(y, `attr<-`, "index.type", attr(m, "index.type"))
}, function (pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(text) && length(levels(text)) < length(text)) {
    out <- regexec(pattern, c(levels(text), NA), ignore.case, perl, fixed, useBytes)
    outna <- out[length(out)]
    out <- out[text]
    out[is.na(text)] <- outna
    return(out)
  }
  if (!is.character(text)) 
    text <- as.character(text)
  if (!perl || fixed) {
    if (perl) 
      warning(gettextf("argument '%s' will be ignored", "perl = TRUE"), domain = NA)
    return(.Internal(regexec(as.character(pattern), text, ignore.case, fixed, useBytes)))
  }
  m <- regexpr(pattern, text, ignore.case = ignore.case, useBytes = useBytes, perl = TRUE)
  nm <- attr(m, "capture.names")
  nm <- if (any(nzchar(nm))) 
    c("", nm)
  match_data_from_pos_and_len <- function(pos, len, nm = NULL) {
    attr(pos, "match.length") <- len
    names(pos) <- nm
    pos
  }
  y <- vector("list", length(text))
  y[is.na(m)] <- list(match_data_from_pos_and_len(NA, NA))
  ind <- !is.na(m) & (m == -1)
  if (any(ind)) {
    y[ind] <- list(match_data_from_pos_and_len(-1, -1))
  }
  ind <- !is.na(m) & !ind
  if (any(ind)) {
    pos <- cbind(m[ind], attr(m, "capture.start")[ind, , drop = FALSE])
    len <- cbind(attr(m, "match.length")[ind], attr(m, "capture.length")[ind, , drop = FALSE])
    y[ind] <- Map(match_data_from_pos_and_len, split(pos, row(pos)), split(len, row(len)), list(nm))
  }
  if (identical(attr(m, "useBytes"), TRUE)) 
    y <- lapply(y, `attr<-`, "useBytes", TRUE)
  lapply(y, `attr<-`, "index.type", attr(m, "index.type"))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
regexpr
list(`package:base` = function (pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(text) && length(levels(text)) < length(text)) {
    out <- regexpr(pattern, levels(text), ignore.case, perl, fixed, useBytes)
    structure(out[text], match.length = attr(out, "match.length")[text], index.type = attr(out, "index.type"), useBytes = attr(out, "useBytes"), capture.start = attr(out, "capture.start")[text, , drop = FALSE], capture.length = attr(out, "capture.length")[text, , drop = FALSE], capture.names = attr(out, "capture.names"))
  }
  else {
    if (!is.character(text)) 
      text <- as.character(text)
    .Internal(regexpr(as.character(pattern), text, ignore.case, perl, fixed, useBytes))
  }
}, function (pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(text) && length(levels(text)) < length(text)) {
    out <- regexpr(pattern, levels(text), ignore.case, perl, fixed, useBytes)
    structure(out[text], match.length = attr(out, "match.length")[text], index.type = attr(out, "index.type"), useBytes = attr(out, "useBytes"), capture.start = attr(out, "capture.start")[text, , drop = FALSE], capture.length = attr(out, "capture.length")[text, , drop = FALSE], capture.names = attr(out, "capture.names"))
  }
  else {
    if (!is.character(text)) 
      text <- as.character(text)
    .Internal(regexpr(as.character(pattern), text, ignore.case, perl, fixed, useBytes))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
registerS3method
list(`package:base` = function (genname, class, method, envir = parent.frame()) 
{
  addNamespaceS3method <- function(ns, generic, class, method) {
    regs <- rbind(.getNamespaceInfo(ns, "S3methods"), c(generic, class, method, NA))
    setNamespaceInfo(ns, "S3methods", regs)
  }
  groupGenerics <- c("Math", "Ops", "Summary", "Complex")
  defenv <- if (genname %in% groupGenerics) 
    .BaseNamespaceEnv
  else {
    genfun <- get(genname, envir = envir)
    if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
      genfun <- methods::finalDefaultMethod(genfun@default)
    if (typeof(genfun) == "closure") 
      environment(genfun)
    else .BaseNamespaceEnv
  }
  if (is.null(table <- defenv[[".__S3MethodsTable__."]])) {
    table <- new.env(hash = TRUE, parent = baseenv())
    defenv[[".__S3MethodsTable__."]] <- table
  }
  if (is.character(method)) {
    assignWrapped <- function(x, method, home, envir) {
      method <- method
      home <- home
      delayedAssign(x, get(method, envir = home), assign.env = envir)
    }
    if (!exists(method, envir = envir)) {
      warning(gettextf("S3 method %s was declared but not found", sQuote(method)), call. = FALSE)
    }
    else {
      assignWrapped(paste(genname, class, sep = "."), method, home = envir, envir = table)
    }
  }
  else if (is.function(method)) 
    assign(paste(genname, class, sep = "."), method, envir = table)
  else stop("bad method")
  if (isNamespace(envir) && !identical(envir, .BaseNamespaceEnv)) 
    addNamespaceS3method(envir, genname, class, method)
}, function (genname, class, method, envir = parent.frame()) 
{
  addNamespaceS3method <- function(ns, generic, class, method) {
    regs <- rbind(.getNamespaceInfo(ns, "S3methods"), c(generic, class, method, NA))
    setNamespaceInfo(ns, "S3methods", regs)
  }
  groupGenerics <- c("Math", "Ops", "Summary", "Complex")
  defenv <- if (genname %in% groupGenerics) 
    .BaseNamespaceEnv
  else {
    genfun <- get(genname, envir = envir)
    if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
      genfun <- methods::finalDefaultMethod(genfun@default)
    if (typeof(genfun) == "closure") 
      environment(genfun)
    else .BaseNamespaceEnv
  }
  if (is.null(table <- defenv[[".__S3MethodsTable__."]])) {
    table <- new.env(hash = TRUE, parent = baseenv())
    defenv[[".__S3MethodsTable__."]] <- table
  }
  if (is.character(method)) {
    assignWrapped <- function(x, method, home, envir) {
      method <- method
      home <- home
      delayedAssign(x, get(method, envir = home), assign.env = envir)
    }
    if (!exists(method, envir = envir)) {
      warning(gettextf("S3 method %s was declared but not found", sQuote(method)), call. = FALSE)
    }
    else {
      assignWrapped(paste(genname, class, sep = "."), method, home = envir, envir = table)
    }
  }
  else if (is.function(method)) 
    assign(paste(genname, class, sep = "."), method, envir = table)
  else stop("bad method")
  if (isNamespace(envir) && !identical(envir, .BaseNamespaceEnv)) 
    addNamespaceS3method(envir, genname, class, method)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
registerS3methods
list(`package:base` = function (info, package, env) 
{
  n <- NROW(info)
  if (n == 0) 
    return()
  assignWrapped <- function(x, method, home, envir) {
    method <- method
    home <- home
    delayedAssign(x, get(method, envir = home), assign.env = envir)
  }
  overwrite <- matrix(NA, 0, 2)
  .registerS3method <- function(genname, class, method, nm, envir) {
    defenv <- if (!is.na(w <- .knownS3Generics[genname])) 
      asNamespace(w)
    else {
      if (is.null(genfun <- get0(genname, envir = parent.env(envir)))) 
        stop(gettextf("object '%s' not found whilst loading namespace '%s'", genname, package), call. = FALSE, domain = NA)
      if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
        genfun <- genfun@default
      if (typeof(genfun) == "closure") 
        environment(genfun)
      else .BaseNamespaceEnv
    }
    if (is.null(table <- defenv[[".__S3MethodsTable__."]])) {
      table <- new.env(hash = TRUE, parent = baseenv())
      defenv[[".__S3MethodsTable__."]] <- table
    }
    e <- tryCatch(table[[nm]], error = function(e) NULL)
    if (!is.null(e) && !identical(e, get(method, envir = envir))) {
      current <- environmentName(environment(e))
      overwrite <<- rbind(overwrite, c(as.vector(nm), current))
    }
    assignWrapped(nm, method, home = envir, envir = table)
  }
  methname <- paste(info[, 1], info[, 2], sep = ".")
  z <- is.na(info[, 3])
  info[z, 3] <- methname[z]
  if (ncol(info) == 3) 
    info <- cbind(info, NA)
  Info <- cbind(info[, 1:3, drop = FALSE], methname, info[, 4])
  loc <- names(env)
  if (any(notex <- match(info[, 3], loc, nomatch = 0) == 0)) {
    warning(sprintf(ngettext(sum(notex), "S3 method %s was declared in NAMESPACE but not found", "S3 methods %s were declared in NAMESPACE but not found"), paste(sQuote(info[notex, 3]), collapse = ", ")), call. = FALSE, domain = NA)
    Info <- Info[!notex, , drop = FALSE]
  }
  eager <- is.na(Info[, 5])
  delayed <- Info[!eager, , drop = FALSE]
  Info <- Info[eager, , drop = FALSE]
  l2 <- localGeneric <- Info[, 1] %in% loc
  if (.isMethodsDispatchOn()) 
    for (i in which(localGeneric)) {
      genfun <- get(Info[i, 1], envir = env)
      if (methods::is(genfun, "genericFunction")) {
        localGeneric[i] <- FALSE
        registerS3method(Info[i, 1], Info[i, 2], Info[i, 3], env)
      }
    }
  if (any(localGeneric)) {
    lin <- Info[localGeneric, , drop = FALSE]
    S3MethodsTable <- env[[".__S3MethodsTable__."]]
    .Internal(importIntoEnv(S3MethodsTable, lin[, 4], env, lin[, 3]))
  }
  fin <- Info[!l2, , drop = FALSE]
  for (i in seq_len(nrow(fin))) .registerS3method(fin[i, 1], fin[i, 2], fin[i, 3], fin[i, 4], env)
  if (package != "MASS" && nrow(overwrite)) {
    .fmt <- function(o) {
      sprintf("  %s %s", format(c("method", o[, 1])), format(c("from", o[, 2])))
    }
    overwrite <- overwrite[overwrite[, 2] != package, , drop = FALSE]
    if (Sys.getenv("_R_LOAD_CHECK_OVERWRITE_S3_METHODS_") %in% c(package, "all")) {
      ind <- overwrite[, 2] %in% unlist(tools:::.get_standard_package_names(), use.names = FALSE)
      bad <- overwrite[ind, , drop = FALSE]
      if (nr <- nrow(bad)) {
        msg <- ngettext(nr, "Registered S3 method from a standard package overwritten by '%s':", "Registered S3 methods from standard package(s) overwritten by '%s':", domain = NA)
        msg <- paste(c(sprintf(msg, package), .fmt(bad)), collapse = "\n")
        message(msg, domain = NA)
        overwrite <- overwrite[!ind, , drop = FALSE]
      }
    }
    if ((nr <- nrow(overwrite)) && is.na(match(tolower(Sys.getenv("_R_S3_METHOD_REGISTRATION_NOTE_OVERWRITES_")), c("0", "no", "false"))) && (!is.na(match(Sys.getenv("_R_CHECK_PACKAGE_NAME_"), c("", package))))) {
      msg <- ngettext(nr, "Registered S3 method overwritten by '%s':", "Registered S3 methods overwritten by '%s':", domain = NA)
      msg <- paste(c(sprintf(msg, package), .fmt(overwrite)), collapse = "\n")
      packageStartupMessage(msg, domain = NA)
    }
  }
  register_S3_method_delayed <- function(pkg, gen, cls, fun) {
    pkg <- pkg
    gen <- gen
    cls <- cls
    fun <- fun
    if (isNamespaceLoaded(pkg)) {
      registerS3method(gen, cls, fun, envir = asNamespace(pkg))
    }
    setHook(packageEvent(pkg, "onLoad"), function(...) {
      registerS3method(gen, cls, fun, envir = asNamespace(pkg))
    })
  }
  if (nrow(delayed)) {
    for (i in seq_len(nrow(delayed))) {
      gen <- delayed[i, 1]
      cls <- delayed[i, 2]
      fun <- get(delayed[i, 3], envir = env)
      pkg <- delayed[i, 5]
      register_S3_method_delayed(pkg, gen, cls, fun)
    }
  }
  nsI <- getNamespaceInfo(env, "S3methods")
  if (!is.null(p1 <- ncol(nsI)) && !is.null(p2 <- ncol(info)) && p1 != p2) 
    stop(gettextf(paste("While loading namespace \"%s\": \"%s\" differ in ncol(.), env=%d, newNS=%d.", "Maybe package installed with version of R newer than %s ?", sep = "\n"), package, "S3methods", p1, p2, getRversion()), domain = NA)
  setNamespaceInfo(env, "S3methods", rbind(info, nsI))
}, function (info, package, env) 
{
  n <- NROW(info)
  if (n == 0) 
    return()
  assignWrapped <- function(x, method, home, envir) {
    method <- method
    home <- home
    delayedAssign(x, get(method, envir = home), assign.env = envir)
  }
  overwrite <- matrix(NA, 0, 2)
  .registerS3method <- function(genname, class, method, nm, envir) {
    defenv <- if (!is.na(w <- .knownS3Generics[genname])) 
      asNamespace(w)
    else {
      if (is.null(genfun <- get0(genname, envir = parent.env(envir)))) 
        stop(gettextf("object '%s' not found whilst loading namespace '%s'", genname, package), call. = FALSE, domain = NA)
      if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
        genfun <- genfun@default
      if (typeof(genfun) == "closure") 
        environment(genfun)
      else .BaseNamespaceEnv
    }
    if (is.null(table <- defenv[[".__S3MethodsTable__."]])) {
      table <- new.env(hash = TRUE, parent = baseenv())
      defenv[[".__S3MethodsTable__."]] <- table
    }
    e <- tryCatch(table[[nm]], error = function(e) NULL)
    if (!is.null(e) && !identical(e, get(method, envir = envir))) {
      current <- environmentName(environment(e))
      overwrite <<- rbind(overwrite, c(as.vector(nm), current))
    }
    assignWrapped(nm, method, home = envir, envir = table)
  }
  methname <- paste(info[, 1], info[, 2], sep = ".")
  z <- is.na(info[, 3])
  info[z, 3] <- methname[z]
  if (ncol(info) == 3) 
    info <- cbind(info, NA)
  Info <- cbind(info[, 1:3, drop = FALSE], methname, info[, 4])
  loc <- names(env)
  if (any(notex <- match(info[, 3], loc, nomatch = 0) == 0)) {
    warning(sprintf(ngettext(sum(notex), "S3 method %s was declared in NAMESPACE but not found", "S3 methods %s were declared in NAMESPACE but not found"), paste(sQuote(info[notex, 3]), collapse = ", ")), call. = FALSE, domain = NA)
    Info <- Info[!notex, , drop = FALSE]
  }
  eager <- is.na(Info[, 5])
  delayed <- Info[!eager, , drop = FALSE]
  Info <- Info[eager, , drop = FALSE]
  l2 <- localGeneric <- Info[, 1] %in% loc
  if (.isMethodsDispatchOn()) 
    for (i in which(localGeneric)) {
      genfun <- get(Info[i, 1], envir = env)
      if (methods::is(genfun, "genericFunction")) {
        localGeneric[i] <- FALSE
        registerS3method(Info[i, 1], Info[i, 2], Info[i, 3], env)
      }
    }
  if (any(localGeneric)) {
    lin <- Info[localGeneric, , drop = FALSE]
    S3MethodsTable <- env[[".__S3MethodsTable__."]]
    .Internal(importIntoEnv(S3MethodsTable, lin[, 4], env, lin[, 3]))
  }
  fin <- Info[!l2, , drop = FALSE]
  for (i in seq_len(nrow(fin))) .registerS3method(fin[i, 1], fin[i, 2], fin[i, 3], fin[i, 4], env)
  if (package != "MASS" && nrow(overwrite)) {
    .fmt <- function(o) {
      sprintf("  %s %s", format(c("method", o[, 1])), format(c("from", o[, 2])))
    }
    overwrite <- overwrite[overwrite[, 2] != package, , drop = FALSE]
    if (Sys.getenv("_R_LOAD_CHECK_OVERWRITE_S3_METHODS_") %in% c(package, "all")) {
      ind <- overwrite[, 2] %in% unlist(tools:::.get_standard_package_names(), use.names = FALSE)
      bad <- overwrite[ind, , drop = FALSE]
      if (nr <- nrow(bad)) {
        msg <- ngettext(nr, "Registered S3 method from a standard package overwritten by '%s':", "Registered S3 methods from standard package(s) overwritten by '%s':", domain = NA)
        msg <- paste(c(sprintf(msg, package), .fmt(bad)), collapse = "\n")
        message(msg, domain = NA)
        overwrite <- overwrite[!ind, , drop = FALSE]
      }
    }
    if ((nr <- nrow(overwrite)) && is.na(match(tolower(Sys.getenv("_R_S3_METHOD_REGISTRATION_NOTE_OVERWRITES_")), c("0", "no", "false"))) && (!is.na(match(Sys.getenv("_R_CHECK_PACKAGE_NAME_"), c("", package))))) {
      msg <- ngettext(nr, "Registered S3 method overwritten by '%s':", "Registered S3 methods overwritten by '%s':", domain = NA)
      msg <- paste(c(sprintf(msg, package), .fmt(overwrite)), collapse = "\n")
      packageStartupMessage(msg, domain = NA)
    }
  }
  register_S3_method_delayed <- function(pkg, gen, cls, fun) {
    pkg <- pkg
    gen <- gen
    cls <- cls
    fun <- fun
    if (isNamespaceLoaded(pkg)) {
      registerS3method(gen, cls, fun, envir = asNamespace(pkg))
    }
    setHook(packageEvent(pkg, "onLoad"), function(...) {
      registerS3method(gen, cls, fun, envir = asNamespace(pkg))
    })
  }
  if (nrow(delayed)) {
    for (i in seq_len(nrow(delayed))) {
      gen <- delayed[i, 1]
      cls <- delayed[i, 2]
      fun <- get(delayed[i, 3], envir = env)
      pkg <- delayed[i, 5]
      register_S3_method_delayed(pkg, gen, cls, fun)
    }
  }
  nsI <- getNamespaceInfo(env, "S3methods")
  if (!is.null(p1 <- ncol(nsI)) && !is.null(p2 <- ncol(info)) && p1 != p2) 
    stop(gettextf(paste("While loading namespace \"%s\": \"%s\" differ in ncol(.), env=%d, newNS=%d.", "Maybe package installed with version of R newer than %s ?", sep = "\n"), package, "S3methods", p1, p2, getRversion()), domain = NA)
  setNamespaceInfo(env, "S3methods", rbind(info, nsI))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
regmatches
list(`package:base` = function (x, m, invert = FALSE) 
{
  if (length(x) != length(m)) 
    stop(gettextf("%s and %s must have the same length", sQuote("x"), sQuote("m")), domain = NA)
  ili <- is.list(m)
  itype <- "chars"
  useBytes <- if (ili) 
    any(unlist(lapply(m, attr, "index.type")) == "bytes")
  else any(attr(m, "index.type") == "bytes")
  if (useBytes) {
    itype <- Encoding(x) <- "bytes"
  }
  if (!ili && isFALSE(invert)) {
    so <- m[ind <- (!is.na(m) & (m > -1))]
    eo <- so + attr(m, "match.length")[ind] - 1
    return(substring(x[ind], so, eo))
  }
  y <- if (is.na(invert)) {
    Map(function(u, so, ml) {
      if ((n <- length(so)) == 1) {
        if (is.na(so)) 
          return(NA)
        else if (so == -1) 
          return(u)
      }
      eo <- so + ml - 1
      if (n > 1) {
        if (any(eo[-n] >= so[-1])) 
          stop(gettextf("need non-overlapping matches for %s", sQuote("invert = NA")), domain = NA)
      }
      beg <- c(1, c(rbind(so, eo + 1)))
      end <- c(c(rbind(so - 1, eo)), nchar(u, itype))
      substring(u, beg, end)
    }, x, m, if (ili) 
      lapply(m, attr, "match.length")
    else attr(m, "match.length"), USE.NAMES = FALSE)
  }
  else if (invert) {
    Map(function(u, so, ml) {
      if ((n <- length(so)) == 1) {
        if (is.na(so)) 
          return(NA)
        else if (so == -1) 
          return(u)
      }
      beg <- if (n > 1) {
        eo <- so + ml - 1
        if (any(eo[-n] >= so[-1])) 
          stop(gettextf("need non-overlapping matches for %s", sQuote("invert = TRUE")), domain = NA)
        c(1, eo + 1)
      }
      else {
        c(1, so + ml)
      }
      end <- c(so - 1, nchar(u, itype))
      substring(u, beg, end)
    }, x, m, if (ili) 
      lapply(m, attr, "match.length")
    else attr(m, "match.length"), USE.NAMES = FALSE)
  }
  else {
    Map(function(u, so, ml) {
      if (length(so) == 1) {
        if (is.na(so) || (so == -1)) 
          return(character())
      }
      tmp <- substring(u, so, so + ml - 1)
      dim(tmp) <- dim(so)
      dimnames(tmp) <- dimnames(so)
      names(tmp) <- names(so)
      tmp
    }, x, m, lapply(m, attr, "match.length"), USE.NAMES = FALSE)
  }
  names(y) <- names(x)
  y
}, function (x, m, invert = FALSE) 
{
  if (length(x) != length(m)) 
    stop(gettextf("%s and %s must have the same length", sQuote("x"), sQuote("m")), domain = NA)
  ili <- is.list(m)
  itype <- "chars"
  useBytes <- if (ili) 
    any(unlist(lapply(m, attr, "index.type")) == "bytes")
  else any(attr(m, "index.type") == "bytes")
  if (useBytes) {
    itype <- Encoding(x) <- "bytes"
  }
  if (!ili && isFALSE(invert)) {
    so <- m[ind <- (!is.na(m) & (m > -1))]
    eo <- so + attr(m, "match.length")[ind] - 1
    return(substring(x[ind], so, eo))
  }
  y <- if (is.na(invert)) {
    Map(function(u, so, ml) {
      if ((n <- length(so)) == 1) {
        if (is.na(so)) 
          return(NA)
        else if (so == -1) 
          return(u)
      }
      eo <- so + ml - 1
      if (n > 1) {
        if (any(eo[-n] >= so[-1])) 
          stop(gettextf("need non-overlapping matches for %s", sQuote("invert = NA")), domain = NA)
      }
      beg <- c(1, c(rbind(so, eo + 1)))
      end <- c(c(rbind(so - 1, eo)), nchar(u, itype))
      substring(u, beg, end)
    }, x, m, if (ili) 
      lapply(m, attr, "match.length")
    else attr(m, "match.length"), USE.NAMES = FALSE)
  }
  else if (invert) {
    Map(function(u, so, ml) {
      if ((n <- length(so)) == 1) {
        if (is.na(so)) 
          return(NA)
        else if (so == -1) 
          return(u)
      }
      beg <- if (n > 1) {
        eo <- so + ml - 1
        if (any(eo[-n] >= so[-1])) 
          stop(gettextf("need non-overlapping matches for %s", sQuote("invert = TRUE")), domain = NA)
        c(1, eo + 1)
      }
      else {
        c(1, so + ml)
      }
      end <- c(so - 1, nchar(u, itype))
      substring(u, beg, end)
    }, x, m, if (ili) 
      lapply(m, attr, "match.length")
    else attr(m, "match.length"), USE.NAMES = FALSE)
  }
  else {
    Map(function(u, so, ml) {
      if (length(so) == 1) {
        if (is.na(so) || (so == -1)) 
          return(character())
      }
      tmp <- substring(u, so, so + ml - 1)
      dim(tmp) <- dim(so)
      dimnames(tmp) <- dimnames(so)
      names(tmp) <- names(so)
      tmp
    }, x, m, lapply(m, attr, "match.length"), USE.NAMES = FALSE)
  }
  names(y) <- names(x)
  y
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
regmatches<-
  list(`package:base` = function (x, m, invert = FALSE, value) 
  {
    if (!length(x)) 
      return(x)
    ili <- is.list(m)
    if (!ili && invert && any(m == -1)) {
      y <- rep_len(list(character()), length(x))
      y[m > -1] <- as.list(regmatches(x, m, FALSE))
    }
    else {
      y <- regmatches(x, m, !invert)
    }
    if (!ili && !invert) {
      value <- as.character(value)
      if (anyNA(value)) 
        stop("missing replacement values are not allowed")
      pos <- which(lengths(y) == 2)
      np <- length(pos)
      nv <- length(value)
      if (np != nv) {
        if (!nv) 
          stop("must have replacement values for matches")
        value <- rep_len(value, np)
      }
      y <- y[pos]
      x[pos] <- paste0(sapply(y, `[`, 1), value, sapply(y, `[`, 2))
      return(x)
    }
    value <- lapply(value, as.character)
    if (anyNA(value)) 
      stop("missing replacement values are not allowed")
    if (!length(value)) 
      stop("value does not provide any replacement values")
    value <- rep_len(value, length(x))
    y <- if (invert) {
      Map(function(u, v) {
        nu <- length(u)
        nv <- length(v)
        if (nv != (nu + 1)) {
          if (!nv) 
            stop("must have replacements for non-matches")
          v <- rep_len(v, nu + 1)
        }
        paste0(v, c(u, ""), collapse = "")
      }, y, value, USE.NAMES = FALSE)
    }
    else {
      Map(function(u, v) {
        nu <- length(u)
        nv <- length(v)
        if (nv != (nu - 1)) {
          if (!nv) 
            stop("must have replacements for matches")
          v <- rep_len(v, nu - 1)
        }
        paste0(u, c(v, ""), collapse = "")
      }, y, value, USE.NAMES = FALSE)
    }
    y <- unlist(y)
    names(y) <- names(x)
    y
  }, function (x, m, invert = FALSE, value) 
  {
    if (!length(x)) 
      return(x)
    ili <- is.list(m)
    if (!ili && invert && any(m == -1)) {
      y <- rep_len(list(character()), length(x))
      y[m > -1] <- as.list(regmatches(x, m, FALSE))
    }
    else {
      y <- regmatches(x, m, !invert)
    }
    if (!ili && !invert) {
      value <- as.character(value)
      if (anyNA(value)) 
        stop("missing replacement values are not allowed")
      pos <- which(lengths(y) == 2)
      np <- length(pos)
      nv <- length(value)
      if (np != nv) {
        if (!nv) 
          stop("must have replacement values for matches")
        value <- rep_len(value, np)
      }
      y <- y[pos]
      x[pos] <- paste0(sapply(y, `[`, 1), value, sapply(y, `[`, 2))
      return(x)
    }
    value <- lapply(value, as.character)
    if (anyNA(value)) 
      stop("missing replacement values are not allowed")
    if (!length(value)) 
      stop("value does not provide any replacement values")
    value <- rep_len(value, length(x))
    y <- if (invert) {
      Map(function(u, v) {
        nu <- length(u)
        nv <- length(v)
        if (nv != (nu + 1)) {
          if (!nv) 
            stop("must have replacements for non-matches")
          v <- rep_len(v, nu + 1)
        }
        paste0(v, c(u, ""), collapse = "")
      }, y, value, USE.NAMES = FALSE)
    }
    else {
      Map(function(u, v) {
        nu <- length(u)
        nv <- length(v)
        if (nv != (nu - 1)) {
          if (!nv) 
            stop("must have replacements for matches")
          v <- rep_len(v, nu - 1)
        }
        paste0(u, c(v, ""), collapse = "")
      }, y, value, USE.NAMES = FALSE)
    }
    y <- unlist(y)
    names(y) <- names(x)
    y
  })
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
remove
list(`package:base` = function (..., list = character(), pos = -1, envir = as.environment(pos), inherits = FALSE) 
{
  dots <- match.call(expand.dots = FALSE)$...
  if (length(dots) && !all(vapply(dots, function(x) is.symbol(x) || is.character(x), NA, USE.NAMES = FALSE))) 
    stop("... must contain names or character strings")
  names <- vapply(dots, as.character, "")
  if (length(names) == 0) 
    names <- character()
  list <- .Primitive("c")(list, names)
  .Internal(remove(list, envir, inherits))
}, function (..., list = character(), pos = -1, envir = as.environment(pos), inherits = FALSE) 
{
  dots <- match.call(expand.dots = FALSE)$...
  if (length(dots) && !all(vapply(dots, function(x) is.symbol(x) || is.character(x), NA, USE.NAMES = FALSE))) 
    stop("... must contain names or character strings")
  names <- vapply(dots, as.character, "")
  if (length(names) == 0) 
    names <- character()
  list <- .Primitive("c")(list, names)
  .Internal(remove(list, envir, inherits))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
removeTaskCallback
list(`package:base` = function (id) 
{
  if (!is.character(id)) 
    id <- as.integer(id)
  .Call(.C_R_removeTaskCallback, id)
}, function (id) 
{
  if (!is.character(id)) 
    id <- as.integer(id)
  .Call(.C_R_removeTaskCallback, id)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rep
list(`package:base` = .Primitive("rep"), .Primitive("rep"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rep.Date
list(`package:base` = function (x, ...) 
{
  .Date(NextMethod(), oldClass(x))
}, function (x, ...) 
{
  .Date(NextMethod(), oldClass(x))
}, function (x, ...) 
{
  .Date(NextMethod(), oldClass(x))
})
c("package:base", "registered S3 method for rep from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rep.difftime
list(`package:base` = function (x, ...) 
  .difftime(NextMethod("rep"), attr(x, "units"), oldClass(x)), function (x, ...) 
    .difftime(NextMethod("rep"), attr(x, "units"), oldClass(x)), function (x, ...) 
      .difftime(NextMethod("rep"), attr(x, "units"), oldClass(x)))
c("package:base", "registered S3 method for rep from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rep.factor
list(`package:base` = function (x, ...) 
{
  y <- NextMethod()
  structure(y, class = class(x), levels = levels(x))
}, function (x, ...) 
{
  y <- NextMethod()
  structure(y, class = class(x), levels = levels(x))
}, function (x, ...) 
{
  y <- NextMethod()
  structure(y, class = class(x), levels = levels(x))
})
c("package:base", "registered S3 method for rep from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rep.int
list(`package:base` = function (x, times) 
  .Internal(rep.int(x, times)), function (x, times) 
    .Internal(rep.int(x, times)), function (x, times) 
      .Internal(rep.int(x, times)))
c("package:base", "registered S3 method for rep from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rep.numeric_version
list(`package:base` = function (x, ...) 
  structure(NextMethod("rep"), class = oldClass(x)), function (x, ...) 
    structure(NextMethod("rep"), class = oldClass(x)), function (x, ...) 
      structure(NextMethod("rep"), class = oldClass(x)))
c("package:base", "registered S3 method for rep from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rep.POSIXct
list(`package:base` = function (x, ...) 
  .POSIXct(NextMethod(), attr(x, "tzone"), oldClass(x)), function (x, ...) 
    .POSIXct(NextMethod(), attr(x, "tzone"), oldClass(x)), function (x, ...) 
      .POSIXct(NextMethod(), attr(x, "tzone"), oldClass(x)))
c("package:base", "registered S3 method for rep from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rep.POSIXlt
list(`package:base` = function (x, ...) 
  .POSIXlt(lapply(X = unclass(x), FUN = rep, ...), attr(x, "tzone"), oldClass(x)), function (x, ...) 
    .POSIXlt(lapply(X = unclass(x), FUN = rep, ...), attr(x, "tzone"), oldClass(x)), function (x, ...) 
      .POSIXlt(lapply(X = unclass(x), FUN = rep, ...), attr(x, "tzone"), oldClass(x)))
c("package:base", "registered S3 method for rep from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rep_len
list(`package:base` = function (x, length.out) 
  .Internal(rep_len(x, length.out)), function (x, length.out) 
    .Internal(rep_len(x, length.out)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
repeat
  list(`package:base` = .Primitive("repeat"), .Primitive("repeat"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
replace
list(`package:base` = function (x, list, values) 
{
  x[list] <- values
  x
}, function (x, list, values) 
{
  x[list] <- values
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
replicate
list(`package:base` = function (n, expr, simplify = "array") 
  sapply(integer(n), eval.parent(substitute(function(...) expr)), simplify = simplify), function (n, expr, simplify = "array") 
    sapply(integer(n), eval.parent(substitute(function(...) expr)), simplify = simplify))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
require
list(`package:base` = function (package, lib.loc = NULL, quietly = FALSE, warn.conflicts, character.only = FALSE, mask.ok, exclude, include.only, attach.required = missing(include.only)) 
{
  if (!character.only) 
    package <- as.character(substitute(package))
  loaded <- paste0("package:", package) %in% search()
  if (!loaded) {
    if (!quietly) 
      packageStartupMessage(gettextf("Loading required package: %s", package), domain = NA)
    value <- tryCatch(library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE, warn.conflicts = warn.conflicts, quietly = quietly, mask.ok = mask.ok, exclude = exclude, include.only = include.only, attach.required = attach.required), error = function(e) e)
    if (inherits(value, "error")) {
      if (!quietly) {
        msg <- conditionMessage(value)
        cat("Failed with error:  ", sQuote(msg), "\n", file = stderr(), sep = "")
        .Internal(printDeferredWarnings())
      }
      return(invisible(FALSE))
    }
    if (!value) 
      return(invisible(FALSE))
  }
  else value <- TRUE
  invisible(value)
}, function (package, lib.loc = NULL, quietly = FALSE, warn.conflicts, character.only = FALSE, mask.ok, exclude, include.only, attach.required = missing(include.only)) 
{
  if (!character.only) 
    package <- as.character(substitute(package))
  loaded <- paste0("package:", package) %in% search()
  if (!loaded) {
    if (!quietly) 
      packageStartupMessage(gettextf("Loading required package: %s", package), domain = NA)
    value <- tryCatch(library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE, warn.conflicts = warn.conflicts, quietly = quietly, mask.ok = mask.ok, exclude = exclude, include.only = include.only, attach.required = attach.required), error = function(e) e)
    if (inherits(value, "error")) {
      if (!quietly) {
        msg <- conditionMessage(value)
        cat("Failed with error:  ", sQuote(msg), "\n", file = stderr(), sep = "")
        .Internal(printDeferredWarnings())
      }
      return(invisible(FALSE))
    }
    if (!value) 
      return(invisible(FALSE))
  }
  else value <- TRUE
  invisible(value)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
requireNamespace
list(`package:base` = function (package, ..., quietly = FALSE) 
{
  package <- as.character(package)[[1]]
  ns <- .Internal(getRegisteredNamespace(package))
  res <- TRUE
  if (is.null(ns)) {
    if (!quietly) 
      packageStartupMessage(gettextf("Loading required namespace: %s", package), domain = NA)
    value <- tryCatch(loadNamespace(package, ...), error = function(e) e)
    if (inherits(value, "error")) {
      if (!quietly) {
        msg <- conditionMessage(value)
        cat("Failed with error:  ", sQuote(msg), "\n", file = stderr(), sep = "")
        .Internal(printDeferredWarnings())
      }
      res <- FALSE
    }
  }
  invisible(res)
}, function (package, ..., quietly = FALSE) 
{
  package <- as.character(package)[[1]]
  ns <- .Internal(getRegisteredNamespace(package))
  res <- TRUE
  if (is.null(ns)) {
    if (!quietly) 
      packageStartupMessage(gettextf("Loading required namespace: %s", package), domain = NA)
    value <- tryCatch(loadNamespace(package, ...), error = function(e) e)
    if (inherits(value, "error")) {
      if (!quietly) {
        msg <- conditionMessage(value)
        cat("Failed with error:  ", sQuote(msg), "\n", file = stderr(), sep = "")
        .Internal(printDeferredWarnings())
      }
      res <- FALSE
    }
  }
  invisible(res)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
restartDescription
list(`package:base` = function (r) 
  r$description, function (r) 
    r$description)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
restartFormals
list(`package:base` = function (r) 
  formals(r$handler), function (r) 
    formals(r$handler))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
retracemem
list(`package:base` = .Primitive("retracemem"), .Primitive("retracemem"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
return
list(`package:base` = .Primitive("return"), .Primitive("return"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
returnValue
list(`package:base` = function (default = NULL) 
  .Internal(returnValue(default)), function (default = NULL) 
    .Internal(returnValue(default)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rev
list(`package:base` = function (x) 
  UseMethod("rev"), function (x) 
    UseMethod("rev"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rev.default
list(`package:base` = function (x) 
  if (length(x)) x[length(x):1] else x, function (x) 
    if (length(x)) x[length(x):1] else x, function (x) 
      if (length(x)) x[length(x):1] else x)
c("package:base", "registered S3 method for rev from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rle
list(`package:base` = function (x) 
{
  if (!is.vector(x) && !is.list(x)) 
    stop("'x' must be a vector of an atomic type")
  n <- length(x)
  if (n == 0) 
    return(structure(list(lengths = integer(), values = x), class = "rle"))
  y <- x[-1] != x[-n]
  i <- c(which(y | is.na(y)), n)
  structure(list(lengths = diff(c(0, i)), values = x[i]), class = "rle")
}, function (x) 
{
  if (!is.vector(x) && !is.list(x)) 
    stop("'x' must be a vector of an atomic type")
  n <- length(x)
  if (n == 0) 
    return(structure(list(lengths = integer(), values = x), class = "rle"))
  y <- x[-1] != x[-n]
  i <- c(which(y | is.na(y)), n)
  structure(list(lengths = diff(c(0, i)), values = x[i]), class = "rle")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rm
list(`package:base` = function (..., list = character(), pos = -1, envir = as.environment(pos), inherits = FALSE) 
{
  dots <- match.call(expand.dots = FALSE)$...
  if (length(dots) && !all(vapply(dots, function(x) is.symbol(x) || is.character(x), NA, USE.NAMES = FALSE))) 
    stop("... must contain names or character strings")
  names <- vapply(dots, as.character, "")
  if (length(names) == 0) 
    names <- character()
  list <- .Primitive("c")(list, names)
  .Internal(remove(list, envir, inherits))
}, function (..., list = character(), pos = -1, envir = as.environment(pos), inherits = FALSE) 
{
  dots <- match.call(expand.dots = FALSE)$...
  if (length(dots) && !all(vapply(dots, function(x) is.symbol(x) || is.character(x), NA, USE.NAMES = FALSE))) 
    stop("... must contain names or character strings")
  names <- vapply(dots, as.character, "")
  if (length(names) == 0) 
    names <- character()
  list <- .Primitive("c")(list, names)
  .Internal(remove(list, envir, inherits))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
RNGkind
list(`package:base` = function (kind = NULL, normal.kind = NULL, sample.kind = NULL) 
{
  kinds <- c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister", "Knuth-TAOCP", "user-supplied", "Knuth-TAOCP-2002", "L'Ecuyer-CMRG", "default")
  n.kinds <- c("Buggy Kinderman-Ramage", "Ahrens-Dieter", "Box-Muller", "user-supplied", "Inversion", "Kinderman-Ramage", "default")
  s.kinds <- c("Rounding", "Rejection", "default")
  do.set <- length(kind) > 0
  if (do.set) {
    if (!is.character(kind) || length(kind) > 1) 
      stop("'kind' must be a character string of length 1 (RNG to be used).")
    if (is.na(i.knd <- pmatch(kind, kinds) - 1)) 
      stop(gettextf("'%s' is not a valid abbreviation of an RNG", kind), domain = NA)
    if (i.knd == length(kinds) - 1) 
      i.knd <- -1
  }
  else i.knd <- NULL
  if (!is.null(normal.kind)) {
    if (!is.character(normal.kind) || length(normal.kind) != 1) 
      stop("'normal.kind' must be a character string of length 1")
    normal.kind <- pmatch(normal.kind, n.kinds) - 1
    if (is.na(normal.kind)) 
      stop(gettextf("'%s' is not a valid choice", normal.kind), domain = NA)
    if (normal.kind == 0) 
      warning("buggy version of Kinderman-Ramage generator used", domain = NA)
    if (normal.kind == length(n.kinds) - 1) 
      normal.kind <- -1
  }
  if (!is.null(sample.kind)) {
    if (!is.character(sample.kind) || length(sample.kind) != 1) 
      stop("'sample.kind' must be a character string of length 1")
    sample.kind <- pmatch(sample.kind, s.kinds) - 1
    if (is.na(sample.kind)) 
      stop(gettextf("'%s' is not a valid choice", sample.kind), domain = NA)
    if (sample.kind == 0) 
      warning("non-uniform 'Rounding' sampler used", domain = NA)
    if (sample.kind == length(s.kinds) - 1) 
      sample.kind <- -1
  }
  r <- 1 + .Internal(RNGkind(i.knd, normal.kind, sample.kind))
  r <- c(kinds[r[1]], n.kinds[r[2]], s.kinds[r[3]])
  if (do.set || !is.null(normal.kind) || !is.null(sample.kind)) 
    invisible(r)
  else r
}, function (kind = NULL, normal.kind = NULL, sample.kind = NULL) 
{
  kinds <- c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister", "Knuth-TAOCP", "user-supplied", "Knuth-TAOCP-2002", "L'Ecuyer-CMRG", "default")
  n.kinds <- c("Buggy Kinderman-Ramage", "Ahrens-Dieter", "Box-Muller", "user-supplied", "Inversion", "Kinderman-Ramage", "default")
  s.kinds <- c("Rounding", "Rejection", "default")
  do.set <- length(kind) > 0
  if (do.set) {
    if (!is.character(kind) || length(kind) > 1) 
      stop("'kind' must be a character string of length 1 (RNG to be used).")
    if (is.na(i.knd <- pmatch(kind, kinds) - 1)) 
      stop(gettextf("'%s' is not a valid abbreviation of an RNG", kind), domain = NA)
    if (i.knd == length(kinds) - 1) 
      i.knd <- -1
  }
  else i.knd <- NULL
  if (!is.null(normal.kind)) {
    if (!is.character(normal.kind) || length(normal.kind) != 1) 
      stop("'normal.kind' must be a character string of length 1")
    normal.kind <- pmatch(normal.kind, n.kinds) - 1
    if (is.na(normal.kind)) 
      stop(gettextf("'%s' is not a valid choice", normal.kind), domain = NA)
    if (normal.kind == 0) 
      warning("buggy version of Kinderman-Ramage generator used", domain = NA)
    if (normal.kind == length(n.kinds) - 1) 
      normal.kind <- -1
  }
  if (!is.null(sample.kind)) {
    if (!is.character(sample.kind) || length(sample.kind) != 1) 
      stop("'sample.kind' must be a character string of length 1")
    sample.kind <- pmatch(sample.kind, s.kinds) - 1
    if (is.na(sample.kind)) 
      stop(gettextf("'%s' is not a valid choice", sample.kind), domain = NA)
    if (sample.kind == 0) 
      warning("non-uniform 'Rounding' sampler used", domain = NA)
    if (sample.kind == length(s.kinds) - 1) 
      sample.kind <- -1
  }
  r <- 1 + .Internal(RNGkind(i.knd, normal.kind, sample.kind))
  r <- c(kinds[r[1]], n.kinds[r[2]], s.kinds[r[3]])
  if (do.set || !is.null(normal.kind) || !is.null(sample.kind)) 
    invisible(r)
  else r
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
RNGversion
list(`package:base` = function (vstr) 
{
  vnum <- as.numeric(strsplit(as.character(vstr), ".", fixed = TRUE)[[1]])
  if (length(vnum) < 2) 
    stop("malformed version string")
  if (vnum[1] == 0 && vnum[2] < 99) 
    RNGkind("Wichmann-Hill", "Buggy Kinderman-Ramage", "Rounding")
  else if (vnum[1] == 0 || vnum[1] == 1 && vnum[2] <= 6) 
    RNGkind("Marsaglia-Multicarry", "Buggy Kinderman-Ramage", "Rounding")
  else if (vnum[1] <= 2 || vnum[1] == 3 && vnum[2] <= 5) 
    RNGkind("Mersenne-Twister", "Inversion", "Rounding")
  else RNGkind("Mersenne-Twister", "Inversion", "Rejection")
}, function (vstr) 
{
  vnum <- as.numeric(strsplit(as.character(vstr), ".", fixed = TRUE)[[1]])
  if (length(vnum) < 2) 
    stop("malformed version string")
  if (vnum[1] == 0 && vnum[2] < 99) 
    RNGkind("Wichmann-Hill", "Buggy Kinderman-Ramage", "Rounding")
  else if (vnum[1] == 0 || vnum[1] == 1 && vnum[2] <= 6) 
    RNGkind("Marsaglia-Multicarry", "Buggy Kinderman-Ramage", "Rounding")
  else if (vnum[1] <= 2 || vnum[1] == 3 && vnum[2] <= 5) 
    RNGkind("Mersenne-Twister", "Inversion", "Rounding")
  else RNGkind("Mersenne-Twister", "Inversion", "Rejection")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
round
list(`package:base` = .Primitive("round"), .Primitive("round"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
round.Date
list(`package:base` = function (x, ...) 
{
  .Date(NextMethod(), oldClass(x))
}, function (x, ...) 
{
  .Date(NextMethod(), oldClass(x))
}, function (x, ...) 
{
  .Date(NextMethod(), oldClass(x))
})
c("package:base", "registered S3 method for round from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
round.POSIXt
list(`package:base` = function (x, units = c("secs", "mins", "hours", "days", "months", "years")) 
{
  .round_x_to_l_or_u <- function(lx, ll, lu) {
    cu <- as.POSIXct(lu)
    lu <- as.POSIXlt(cu)
    tu <- unclass(cu)
    tx <- unclass(as.POSIXct(lx))
    tl <- unclass(as.POSIXct(ll))
    up <- ((tu - tx) <= (tx - tl))
    up <- !is.na(up) & up
    y <- ll
    y[up] <- lu[up]
    y
  }
  units <- if (is.numeric(units) && units == 0) 
    "secs"
  else match.arg(units)
  if (units == "months") {
    x <- as.POSIXlt(x)
    ll <- trunc.POSIXt(x, "months")
    lu <- ll
    lu$mon <- lu$mon + 1
    .round_x_to_l_or_u(x, ll, lu)
  }
  else if (units == "years") {
    x <- as.POSIXlt(x)
    ll <- trunc.POSIXt(x, "years")
    lu <- ll
    lu$year <- lu$year + 1
    .round_x_to_l_or_u(x, ll, lu)
  }
  else trunc.POSIXt(as.POSIXct(x) + switch(units, secs = 0.5, mins = 30, hours = 1800, days = 43200), units = units)
}, function (x, units = c("secs", "mins", "hours", "days", "months", "years")) 
{
  .round_x_to_l_or_u <- function(lx, ll, lu) {
    cu <- as.POSIXct(lu)
    lu <- as.POSIXlt(cu)
    tu <- unclass(cu)
    tx <- unclass(as.POSIXct(lx))
    tl <- unclass(as.POSIXct(ll))
    up <- ((tu - tx) <= (tx - tl))
    up <- !is.na(up) & up
    y <- ll
    y[up] <- lu[up]
    y
  }
  units <- if (is.numeric(units) && units == 0) 
    "secs"
  else match.arg(units)
  if (units == "months") {
    x <- as.POSIXlt(x)
    ll <- trunc.POSIXt(x, "months")
    lu <- ll
    lu$mon <- lu$mon + 1
    .round_x_to_l_or_u(x, ll, lu)
  }
  else if (units == "years") {
    x <- as.POSIXlt(x)
    ll <- trunc.POSIXt(x, "years")
    lu <- ll
    lu$year <- lu$year + 1
    .round_x_to_l_or_u(x, ll, lu)
  }
  else trunc.POSIXt(as.POSIXct(x) + switch(units, secs = 0.5, mins = 30, hours = 1800, days = 43200), units = units)
}, function (x, units = c("secs", "mins", "hours", "days", "months", "years")) 
{
  .round_x_to_l_or_u <- function(lx, ll, lu) {
    cu <- as.POSIXct(lu)
    lu <- as.POSIXlt(cu)
    tu <- unclass(cu)
    tx <- unclass(as.POSIXct(lx))
    tl <- unclass(as.POSIXct(ll))
    up <- ((tu - tx) <= (tx - tl))
    up <- !is.na(up) & up
    y <- ll
    y[up] <- lu[up]
    y
  }
  units <- if (is.numeric(units) && units == 0) 
    "secs"
  else match.arg(units)
  if (units == "months") {
    x <- as.POSIXlt(x)
    ll <- trunc.POSIXt(x, "months")
    lu <- ll
    lu$mon <- lu$mon + 1
    .round_x_to_l_or_u(x, ll, lu)
  }
  else if (units == "years") {
    x <- as.POSIXlt(x)
    ll <- trunc.POSIXt(x, "years")
    lu <- ll
    lu$year <- lu$year + 1
    .round_x_to_l_or_u(x, ll, lu)
  }
  else trunc.POSIXt(as.POSIXct(x) + switch(units, secs = 0.5, mins = 30, hours = 1800, days = 43200), units = units)
})
c("package:base", "registered S3 method for round from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
row
list(`package:base` = function (x, as.factor = FALSE) 
{
  if (as.factor) {
    labs <- rownames(x, do.NULL = FALSE, prefix = "")
    res <- factor(.Internal(row(dim(x))), labels = labs)
    dim(res) <- dim(x)
    res
  }
  else .Internal(row(dim(x)))
}, function (x, as.factor = FALSE) 
{
  if (as.factor) {
    labs <- rownames(x, do.NULL = FALSE, prefix = "")
    res <- factor(.Internal(row(dim(x))), labels = labs)
    dim(res) <- dim(x)
    res
  }
  else .Internal(row(dim(x)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
row.names
list(`package:base` = function (x) 
  UseMethod("row.names"), function (x) 
    UseMethod("row.names"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
row.names.data.frame
list(`package:base` = function (x) 
  as.character(attr(x, "row.names")), function (x) 
    as.character(attr(x, "row.names")), function (x) 
      as.character(attr(x, "row.names")))
c("package:base", "registered S3 method for row.names from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
row.names.default
list(`package:base` = function (x) 
  if (!is.null(dim(x))) rownames(x), function (x) 
    if (!is.null(dim(x))) rownames(x), function (x) 
      if (!is.null(dim(x))) rownames(x))
c("package:base", "registered S3 method for row.names from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
row.names<-
  list(`package:base` = function (x, value) 
    UseMethod("row.names<-"), function (x, value) 
      UseMethod("row.names<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
row.names<-.data.frame
list(`package:base` = function (x, value) 
  `.rowNamesDF<-`(x, value = value), function (x, value) 
    `.rowNamesDF<-`(x, value = value), function (x, value) 
      `.rowNamesDF<-`(x, value = value))
c("package:base", "registered S3 method for row.names<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
row.names<-.default
list(`package:base` = function (x, value) 
  `rownames<-`(x, value), function (x, value) 
    `rownames<-`(x, value), function (x, value) 
      `rownames<-`(x, value))
c("package:base", "registered S3 method for row.names<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rowMeans
list(`package:base` = function (x, na.rm = FALSE, dims = 1) 
{
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (!is.array(x) || length(dn <- dim(x)) < 2) 
    stop("'x' must be an array of at least two dimensions")
  if (dims < 1 || dims > length(dn) - 1) 
    stop("invalid 'dims'")
  p <- prod(dn[-(id <- seq_len(dims))])
  dn <- dn[id]
  z <- if (is.complex(x)) 
    .Internal(rowMeans(Re(x), prod(dn), p, na.rm)) + (0+1i) * .Internal(rowMeans(Im(x), prod(dn), p, na.rm))
  else .Internal(rowMeans(x, prod(dn), p, na.rm))
  if (length(dn) > 1) {
    dim(z) <- dn
    dimnames(z) <- dimnames(x)[id]
  }
  else names(z) <- dimnames(x)[[1]]
  z
}, new("standardGeneric", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
  standardGeneric("rowMeans"), generic = "rowMeans", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
    base::rowMeans(x, na.rm = na.rm, dims = dims, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "rowMeans"), skeleton = (new("derivedDefaultMethod", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
      base::rowMeans(x, na.rm = na.rm, dims = dims, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "rowMeans"))(x, na.rm, dims, ...)), function (x, na.rm = FALSE, dims = 1) 
      {
        if (is.data.frame(x)) 
          x <- as.matrix(x)
        if (!is.array(x) || length(dn <- dim(x)) < 2) 
          stop("'x' must be an array of at least two dimensions")
        if (dims < 1 || dims > length(dn) - 1) 
          stop("invalid 'dims'")
        p <- prod(dn[-(id <- seq_len(dims))])
        dn <- dn[id]
        z <- if (is.complex(x)) 
          .Internal(rowMeans(Re(x), prod(dn), p, na.rm)) + (0+1i) * .Internal(rowMeans(Im(x), prod(dn), p, na.rm))
        else .Internal(rowMeans(x, prod(dn), p, na.rm))
        if (length(dn) > 1) {
          dim(z) <- dn
          dimnames(z) <- dimnames(x)[id]
        }
        else names(z) <- dimnames(x)[[1]]
        z
      })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
rownames
list(`package:base` = function (x, do.NULL = TRUE, prefix = "row") 
{
  dn <- dimnames(x)
  if (!is.null(dn[[1]])) 
    dn[[1]]
  else {
    nr <- NROW(x)
    if (do.NULL) 
      NULL
    else if (nr > 0) 
      paste0(prefix, seq_len(nr))
    else character()
  }
}, function (x, do.NULL = TRUE, prefix = "row") 
{
  dn <- dimnames(x)
  if (!is.null(dn[[1]])) 
    dn[[1]]
  else {
    nr <- NROW(x)
    if (do.NULL) 
      NULL
    else if (nr > 0) 
      paste0(prefix, seq_len(nr))
    else character()
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rownames<-
  list(`package:base` = function (x, value) 
  {
    if (is.data.frame(x)) {
      row.names(x) <- value
    }
    else {
      dn <- dimnames(x)
      if (is.null(dn)) {
        if (is.null(value)) 
          return(x)
        if ((nd <- length(dim(x))) < 1) 
          stop("attempt to set 'rownames' on an object with no dimensions")
        dn <- vector("list", nd)
      }
      if (length(dn) < 1) 
        stop("attempt to set 'rownames' on an object with no dimensions")
      if (is.null(value)) 
        dn[1] <- list(NULL)
      else dn[[1]] <- value
      dimnames(x) <- dn
    }
    x
  }, function (x, value) 
  {
    if (is.data.frame(x)) {
      row.names(x) <- value
    }
    else {
      dn <- dimnames(x)
      if (is.null(dn)) {
        if (is.null(value)) 
          return(x)
        if ((nd <- length(dim(x))) < 1) 
          stop("attempt to set 'rownames' on an object with no dimensions")
        dn <- vector("list", nd)
      }
      if (length(dn) < 1) 
        stop("attempt to set 'rownames' on an object with no dimensions")
      if (is.null(value)) 
        dn[1] <- list(NULL)
      else dn[[1]] <- value
      dimnames(x) <- dn
    }
    x
  })
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rowsum
list(`package:base` = function (x, group, reorder = TRUE, ...) 
  UseMethod("rowsum"), function (x, group, reorder = TRUE, ...) 
    UseMethod("rowsum"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
rowsum.data.frame
list(`package:base` = function (x, group, reorder = TRUE, na.rm = FALSE, ...) 
{
  if (!is.data.frame(x)) 
    stop("not a data frame")
  if (length(group) != NROW(x)) 
    stop("incorrect length for 'group'")
  if (anyNA(group)) 
    warning("missing values for 'group'")
  ugroup <- unique(group)
  if (reorder) 
    ugroup <- sort(ugroup, na.last = TRUE, method = "quick")
  .Internal(rowsum_df(x, group, ugroup, na.rm, as.character(ugroup)))
}, function (x, group, reorder = TRUE, na.rm = FALSE, ...) 
{
  if (!is.data.frame(x)) 
    stop("not a data frame")
  if (length(group) != NROW(x)) 
    stop("incorrect length for 'group'")
  if (anyNA(group)) 
    warning("missing values for 'group'")
  ugroup <- unique(group)
  if (reorder) 
    ugroup <- sort(ugroup, na.last = TRUE, method = "quick")
  .Internal(rowsum_df(x, group, ugroup, na.rm, as.character(ugroup)))
}, function (x, group, reorder = TRUE, na.rm = FALSE, ...) 
{
  if (!is.data.frame(x)) 
    stop("not a data frame")
  if (length(group) != NROW(x)) 
    stop("incorrect length for 'group'")
  if (anyNA(group)) 
    warning("missing values for 'group'")
  ugroup <- unique(group)
  if (reorder) 
    ugroup <- sort(ugroup, na.last = TRUE, method = "quick")
  .Internal(rowsum_df(x, group, ugroup, na.rm, as.character(ugroup)))
})
c("package:base", "registered S3 method for rowsum from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rowsum.default
list(`package:base` = function (x, group, reorder = TRUE, na.rm = FALSE, ...) 
{
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (length(group) != NROW(x)) 
    stop("incorrect length for 'group'")
  if (anyNA(group)) 
    warning("missing values for 'group'")
  ugroup <- unique(group)
  if (reorder) 
    ugroup <- sort(ugroup, na.last = TRUE, method = "quick")
  .Internal(rowsum_matrix(x, group, ugroup, na.rm, as.character(ugroup)))
}, function (x, group, reorder = TRUE, na.rm = FALSE, ...) 
{
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (length(group) != NROW(x)) 
    stop("incorrect length for 'group'")
  if (anyNA(group)) 
    warning("missing values for 'group'")
  ugroup <- unique(group)
  if (reorder) 
    ugroup <- sort(ugroup, na.last = TRUE, method = "quick")
  .Internal(rowsum_matrix(x, group, ugroup, na.rm, as.character(ugroup)))
}, function (x, group, reorder = TRUE, na.rm = FALSE, ...) 
{
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (length(group) != NROW(x)) 
    stop("incorrect length for 'group'")
  if (anyNA(group)) 
    warning("missing values for 'group'")
  ugroup <- unique(group)
  if (reorder) 
    ugroup <- sort(ugroup, na.last = TRUE, method = "quick")
  .Internal(rowsum_matrix(x, group, ugroup, na.rm, as.character(ugroup)))
})
c("package:base", "registered S3 method for rowsum from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rowSums
list(`package:base` = function (x, na.rm = FALSE, dims = 1) 
{
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (!is.array(x) || length(dn <- dim(x)) < 2) 
    stop("'x' must be an array of at least two dimensions")
  if (dims < 1 || dims > length(dn) - 1) 
    stop("invalid 'dims'")
  p <- prod(dn[-(id <- seq_len(dims))])
  dn <- dn[id]
  z <- if (is.complex(x)) 
    .Internal(rowSums(Re(x), prod(dn), p, na.rm)) + (0+1i) * .Internal(rowSums(Im(x), prod(dn), p, na.rm))
  else .Internal(rowSums(x, prod(dn), p, na.rm))
  if (length(dn) > 1) {
    dim(z) <- dn
    dimnames(z) <- dimnames(x)[id]
  }
  else names(z) <- dimnames(x)[[1]]
  z
}, new("standardGeneric", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
  standardGeneric("rowSums"), generic = "rowSums", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
    base::rowSums(x, na.rm = na.rm, dims = dims, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "rowSums"), skeleton = (new("derivedDefaultMethod", .Data = function (x, na.rm = FALSE, dims = 1, ...) 
      base::rowSums(x, na.rm = na.rm, dims = dims, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "rowSums"))(x, na.rm, dims, ...)), function (x, na.rm = FALSE, dims = 1) 
      {
        if (is.data.frame(x)) 
          x <- as.matrix(x)
        if (!is.array(x) || length(dn <- dim(x)) < 2) 
          stop("'x' must be an array of at least two dimensions")
        if (dims < 1 || dims > length(dn) - 1) 
          stop("invalid 'dims'")
        p <- prod(dn[-(id <- seq_len(dims))])
        dn <- dn[id]
        z <- if (is.complex(x)) 
          .Internal(rowSums(Re(x), prod(dn), p, na.rm)) + (0+1i) * .Internal(rowSums(Im(x), prod(dn), p, na.rm))
        else .Internal(rowSums(x, prod(dn), p, na.rm))
        if (length(dn) > 1) {
          dim(z) <- dn
          dimnames(z) <- dimnames(x)[id]
        }
        else names(z) <- dimnames(x)[[1]]
        z
      })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
sample
list(`package:base` = function (x, size, replace = FALSE, prob = NULL) 
{
  if (length(x) == 1 && is.numeric(x) && is.finite(x) && x >= 1) {
    if (missing(size)) 
      size <- x
    sample.int(x, size, replace, prob)
  }
  else {
    if (missing(size)) 
      size <- length(x)
    x[sample.int(length(x), size, replace, prob)]
  }
}, new("standardGeneric", .Data = function (x, size, replace = FALSE, prob = NULL, ...) 
  standardGeneric("sample"), generic = "sample", package = "base", group = list(), valueClass = character(0), signature = c("x", "size"), default = new("derivedDefaultMethod", .Data = function (x, size, replace = FALSE, prob = NULL, ...) 
    base::sample(x, size, replace = replace, prob = prob, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "sample"), skeleton = (new("derivedDefaultMethod", .Data = function (x, size, replace = FALSE, prob = NULL, ...) 
      base::sample(x, size, replace = replace, prob = prob, ...), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "sample"))(x, size, replace, prob, ...)), function (x, size, replace = FALSE, prob = NULL) 
      {
        if (length(x) == 1 && is.numeric(x) && is.finite(x) && x >= 1) {
          if (missing(size)) 
            size <- x
          sample.int(x, size, replace, prob)
        }
        else {
          if (missing(size)) 
            size <- length(x)
          x[sample.int(length(x), size, replace, prob)]
        }
      })
c("package:base", "namespace:timeDate", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
sample.int
list(`package:base` = function (n, size = n, replace = FALSE, prob = NULL, useHash = (n > 1e+07 && !replace && is.null(prob) && size <= n/2)) 
{
  stopifnot(length(n) == 1)
  if (useHash) {
    stopifnot(is.null(prob), !replace)
    .Internal(sample2(n, size))
  }
  else .Internal(sample(n, size, replace, prob))
}, function (n, size = n, replace = FALSE, prob = NULL, useHash = (n > 1e+07 && !replace && is.null(prob) && size <= n/2)) 
{
  stopifnot(length(n) == 1)
  if (useHash) {
    stopifnot(is.null(prob), !replace)
    .Internal(sample2(n, size))
  }
  else .Internal(sample(n, size, replace, prob))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sapply
list(`package:base` = function (X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) 
{
  FUN <- match.fun(FUN)
  answer <- lapply(X = X, FUN = FUN, ...)
  if (USE.NAMES && is.character(X) && is.null(names(answer))) 
    names(answer) <- X
  if (!isFALSE(simplify)) 
    simplify2array(answer, higher = (simplify == "array"))
  else answer
}, function (X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) 
{
  FUN <- match.fun(FUN)
  answer <- lapply(X = X, FUN = FUN, ...)
  if (USE.NAMES && is.character(X) && is.null(names(answer))) 
    names(answer) <- X
  if (!isFALSE(simplify)) 
    simplify2array(answer, higher = (simplify == "array"))
  else answer
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
save
list(`package:base` = function (..., list = character(), file = stop("'file' must be specified"), ascii = FALSE, version = NULL, envir = parent.frame(), compress = isTRUE(!ascii), compression_level, eval.promises = TRUE, precheck = TRUE) 
{
  opts <- getOption("save.defaults")
  if (missing(compress) && !is.null(opts$compress)) 
    compress <- opts$compress
  if (missing(compression_level) && !is.null(opts$compression_level)) 
    compression_level <- opts$compression_level
  if (missing(ascii) && !is.null(opts$ascii)) 
    ascii <- opts$ascii
  if (missing(version)) 
    version <- opts$version
  if (!is.null(version) && version < 2) 
    warning("Use of save versions prior to 2 is deprecated", domain = NA)
  names <- as.character(substitute(list(...)))[-1]
  if (missing(list) && !length(names)) 
    warning("nothing specified to be save()d")
  list <- c(list, names)
  if (!is.null(version) && version == 1) 
    .Internal(save(list, file, ascii, version, envir, eval.promises))
  else {
    if (precheck) {
      ok <- vapply(list, exists, NA, envir = envir)
      if (!all(ok)) {
        n <- sum(!ok)
        stop(sprintf(ngettext(n, "object %s not found", "objects %s not found"), paste(sQuote(list[!ok]), collapse = ", ")), domain = NA)
      }
    }
    if (is.character(file)) {
      if (!nzchar(file)) 
        stop("'file' must be non-empty string")
      if (!is.character(compress)) {
        if (!is.logical(compress)) 
          stop("'compress' must be logical or character")
        compress <- if (compress) 
          "gzip"
        else "no compression"
      }
      con <- switch(compress, bzip2 = {
        if (!missing(compression_level)) bzfile(file, "wb", compression = compression_level) else bzfile(file, "wb")
      }, xz = {
        if (!missing(compression_level)) xzfile(file, "wb", compression = compression_level) else xzfile(file, "wb", compression = 9)
      }, gzip = {
        if (!missing(compression_level)) gzfile(file, "wb", compression = compression_level) else gzfile(file, "wb")
      }, `no compression` = file(file, "wb"), stop(gettextf("'compress = \"%s\"' is invalid", compress)))
      on.exit(close(con))
    }
    else if (inherits(file, "connection")) 
      con <- file
    else stop("bad file argument")
    if (isOpen(con) && !ascii && summary(con)$text != "binary") 
      stop("can only save to a binary connection")
    .Internal(saveToConn(list, con, ascii, version, envir, eval.promises))
  }
}, function (..., list = character(), file = stop("'file' must be specified"), ascii = FALSE, version = NULL, envir = parent.frame(), compress = isTRUE(!ascii), compression_level, eval.promises = TRUE, precheck = TRUE) 
{
  opts <- getOption("save.defaults")
  if (missing(compress) && !is.null(opts$compress)) 
    compress <- opts$compress
  if (missing(compression_level) && !is.null(opts$compression_level)) 
    compression_level <- opts$compression_level
  if (missing(ascii) && !is.null(opts$ascii)) 
    ascii <- opts$ascii
  if (missing(version)) 
    version <- opts$version
  if (!is.null(version) && version < 2) 
    warning("Use of save versions prior to 2 is deprecated", domain = NA)
  names <- as.character(substitute(list(...)))[-1]
  if (missing(list) && !length(names)) 
    warning("nothing specified to be save()d")
  list <- c(list, names)
  if (!is.null(version) && version == 1) 
    .Internal(save(list, file, ascii, version, envir, eval.promises))
  else {
    if (precheck) {
      ok <- vapply(list, exists, NA, envir = envir)
      if (!all(ok)) {
        n <- sum(!ok)
        stop(sprintf(ngettext(n, "object %s not found", "objects %s not found"), paste(sQuote(list[!ok]), collapse = ", ")), domain = NA)
      }
    }
    if (is.character(file)) {
      if (!nzchar(file)) 
        stop("'file' must be non-empty string")
      if (!is.character(compress)) {
        if (!is.logical(compress)) 
          stop("'compress' must be logical or character")
        compress <- if (compress) 
          "gzip"
        else "no compression"
      }
      con <- switch(compress, bzip2 = {
        if (!missing(compression_level)) bzfile(file, "wb", compression = compression_level) else bzfile(file, "wb")
      }, xz = {
        if (!missing(compression_level)) xzfile(file, "wb", compression = compression_level) else xzfile(file, "wb", compression = 9)
      }, gzip = {
        if (!missing(compression_level)) gzfile(file, "wb", compression = compression_level) else gzfile(file, "wb")
      }, `no compression` = file(file, "wb"), stop(gettextf("'compress = \"%s\"' is invalid", compress)))
      on.exit(close(con))
    }
    else if (inherits(file, "connection")) 
      con <- file
    else stop("bad file argument")
    if (isOpen(con) && !ascii && summary(con)$text != "binary") 
      stop("can only save to a binary connection")
    .Internal(saveToConn(list, con, ascii, version, envir, eval.promises))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
save.image
list(`package:base` = function (file = ".RData", version = NULL, ascii = FALSE, compress = !ascii, safe = TRUE) 
{
  if (!is.character(file) || file == "") 
    stop("'file' must be non-empty string")
  opts <- getOption("save.image.defaults")
  if (is.null(opts)) 
    opts <- getOption("save.defaults")
  if (missing(safe) && !is.null(opts$safe)) 
    safe <- opts$safe
  if (missing(ascii) && !is.null(opts$ascii)) 
    ascii <- opts$ascii
  if (missing(compress) && !is.null(opts$compress)) 
    compress <- opts$compress
  if (missing(version)) 
    version <- opts$version
  if (safe) {
    outfile <- paste0(file, "Tmp")
    i <- 0
    while (file.exists(outfile)) {
      i <- i + 1
      outfile <- paste0(file, "Tmp", i)
    }
  }
  else outfile <- file
  on.exit(file.remove(outfile))
  save(list = names(.GlobalEnv), file = outfile, version = version, ascii = ascii, compress = compress, envir = .GlobalEnv, precheck = FALSE)
  if (safe) 
    if (!file.rename(outfile, file)) {
      on.exit()
      stop(gettextf("image could not be renamed and is left in %s", outfile), domain = NA)
    }
  on.exit()
}, function (file = ".RData", version = NULL, ascii = FALSE, compress = !ascii, safe = TRUE) 
{
  if (!is.character(file) || file == "") 
    stop("'file' must be non-empty string")
  opts <- getOption("save.image.defaults")
  if (is.null(opts)) 
    opts <- getOption("save.defaults")
  if (missing(safe) && !is.null(opts$safe)) 
    safe <- opts$safe
  if (missing(ascii) && !is.null(opts$ascii)) 
    ascii <- opts$ascii
  if (missing(compress) && !is.null(opts$compress)) 
    compress <- opts$compress
  if (missing(version)) 
    version <- opts$version
  if (safe) {
    outfile <- paste0(file, "Tmp")
    i <- 0
    while (file.exists(outfile)) {
      i <- i + 1
      outfile <- paste0(file, "Tmp", i)
    }
  }
  else outfile <- file
  on.exit(file.remove(outfile))
  save(list = names(.GlobalEnv), file = outfile, version = version, ascii = ascii, compress = compress, envir = .GlobalEnv, precheck = FALSE)
  if (safe) 
    if (!file.rename(outfile, file)) {
      on.exit()
      stop(gettextf("image could not be renamed and is left in %s", outfile), domain = NA)
    }
  on.exit()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
saveRDS
list(`package:base` = function (object, file = "", ascii = FALSE, version = NULL, compress = TRUE, refhook = NULL) 
{
  if (is.character(file)) {
    if (file == "") 
      stop("'file' must be non-empty string")
    object <- object
    mode <- if (ascii %in% FALSE) 
      "wb"
    else "w"
    con <- if (is.logical(compress)) 
      if (compress) 
        gzfile(file, mode)
    else file(file, mode)
    else switch(compress, bzip2 = bzfile(file, mode), xz = xzfile(file, mode), gzip = gzfile(file, mode), stop("invalid 'compress' argument: ", compress))
    on.exit(close(con))
  }
  else if (inherits(file, "connection")) {
    if (!missing(compress)) 
      warning("'compress' is ignored unless 'file' is a file name")
    con <- file
  }
  else stop("bad 'file' argument")
  .Internal(serializeToConn(object, con, ascii, version, refhook))
}, function (object, file = "", ascii = FALSE, version = NULL, compress = TRUE, refhook = NULL) 
{
  if (is.character(file)) {
    if (file == "") 
      stop("'file' must be non-empty string")
    object <- object
    mode <- if (ascii %in% FALSE) 
      "wb"
    else "w"
    con <- if (is.logical(compress)) 
      if (compress) 
        gzfile(file, mode)
    else file(file, mode)
    else switch(compress, bzip2 = bzfile(file, mode), xz = xzfile(file, mode), gzip = gzfile(file, mode), stop("invalid 'compress' argument: ", compress))
    on.exit(close(con))
  }
  else if (inherits(file, "connection")) {
    if (!missing(compress)) 
      warning("'compress' is ignored unless 'file' is a file name")
    con <- file
  }
  else stop("bad 'file' argument")
  .Internal(serializeToConn(object, con, ascii, version, refhook))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
scale
list(`package:base` = function (x, center = TRUE, scale = TRUE) 
  UseMethod("scale"), function (x, from = c(0, 255), to = c(0, 5), round = TRUE) 
  {
    y <- (x - from[1])/(from[2] - from[1]) * (to[2] - to[1]) + to[1]
    if (round) {
      round(y)
    }
    else {
      y
    }
  }, function (x, center = TRUE, scale = TRUE) 
    UseMethod("scale"))
c("package:base", "namespace:crayon", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
scale.default
list(`package:base` = function (x, center = TRUE, scale = TRUE) 
{
  x <- as.matrix(x)
  nc <- ncol(x)
  if (is.logical(center)) {
    if (center) {
      center <- colMeans(x, na.rm = TRUE)
      x <- sweep(x, 2, center, check.margin = FALSE)
    }
  }
  else {
    if (!is.numeric(center)) 
      center <- as.numeric(center)
    if (length(center) == nc) 
      x <- sweep(x, 2, center, check.margin = FALSE)
    else stop("length of 'center' must equal the number of columns of 'x'")
  }
  if (is.logical(scale)) {
    if (scale) {
      f <- function(v) {
        v <- v[!is.na(v)]
        sqrt(sum(v^2)/max(1, length(v) - 1))
      }
      scale <- apply(x, 2, f)
      x <- sweep(x, 2, scale, `/`, check.margin = FALSE)
    }
  }
  else {
    if (!is.numeric(scale)) 
      scale <- as.numeric(scale)
    if (length(scale) == nc) 
      x <- sweep(x, 2, scale, `/`, check.margin = FALSE)
    else stop("length of 'scale' must equal the number of columns of 'x'")
  }
  if (is.numeric(center)) 
    attr(x, "scaled:center") <- center
  if (is.numeric(scale)) 
    attr(x, "scaled:scale") <- scale
  x
}, function (x, center = TRUE, scale = TRUE) 
{
  x <- as.matrix(x)
  nc <- ncol(x)
  if (is.logical(center)) {
    if (center) {
      center <- colMeans(x, na.rm = TRUE)
      x <- sweep(x, 2, center, check.margin = FALSE)
    }
  }
  else {
    if (!is.numeric(center)) 
      center <- as.numeric(center)
    if (length(center) == nc) 
      x <- sweep(x, 2, center, check.margin = FALSE)
    else stop("length of 'center' must equal the number of columns of 'x'")
  }
  if (is.logical(scale)) {
    if (scale) {
      f <- function(v) {
        v <- v[!is.na(v)]
        sqrt(sum(v^2)/max(1, length(v) - 1))
      }
      scale <- apply(x, 2, f)
      x <- sweep(x, 2, scale, `/`, check.margin = FALSE)
    }
  }
  else {
    if (!is.numeric(scale)) 
      scale <- as.numeric(scale)
    if (length(scale) == nc) 
      x <- sweep(x, 2, scale, `/`, check.margin = FALSE)
    else stop("length of 'scale' must equal the number of columns of 'x'")
  }
  if (is.numeric(center)) 
    attr(x, "scaled:center") <- center
  if (is.numeric(scale)) 
    attr(x, "scaled:scale") <- scale
  x
}, function (x, center = TRUE, scale = TRUE) 
{
  x <- as.matrix(x)
  nc <- ncol(x)
  if (is.logical(center)) {
    if (center) {
      center <- colMeans(x, na.rm = TRUE)
      x <- sweep(x, 2, center, check.margin = FALSE)
    }
  }
  else {
    if (!is.numeric(center)) 
      center <- as.numeric(center)
    if (length(center) == nc) 
      x <- sweep(x, 2, center, check.margin = FALSE)
    else stop("length of 'center' must equal the number of columns of 'x'")
  }
  if (is.logical(scale)) {
    if (scale) {
      f <- function(v) {
        v <- v[!is.na(v)]
        sqrt(sum(v^2)/max(1, length(v) - 1))
      }
      scale <- apply(x, 2, f)
      x <- sweep(x, 2, scale, `/`, check.margin = FALSE)
    }
  }
  else {
    if (!is.numeric(scale)) 
      scale <- as.numeric(scale)
    if (length(scale) == nc) 
      x <- sweep(x, 2, scale, `/`, check.margin = FALSE)
    else stop("length of 'scale' must equal the number of columns of 'x'")
  }
  if (is.numeric(center)) 
    attr(x, "scaled:center") <- center
  if (is.numeric(scale)) 
    attr(x, "scaled:scale") <- scale
  x
})
c("package:base", "registered S3 method for scale from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
seq_along
list(`package:base` = .Primitive("seq_along"), .Primitive("seq_along"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
seq_len
list(`package:base` = .Primitive("seq_len"), .Primitive("seq_len"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sequence
list(`package:base` = function (nvec, ...) 
  UseMethod("sequence"), function (nvec, ...) 
    UseMethod("sequence"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sequence.default
list(`package:base` = function (nvec, from = 1, by = 1, ...) 
{
  .Internal(sequence(as.integer(nvec), as.integer(from), as.integer(by)))
}, function (nvec, from = 1, by = 1, ...) 
{
  .Internal(sequence(as.integer(nvec), as.integer(from), as.integer(by)))
}, function (nvec, from = 1, by = 1, ...) 
{
  .Internal(sequence(as.integer(nvec), as.integer(from), as.integer(by)))
})
c("package:base", "registered S3 method for sequence from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
serialize
list(`package:base` = function (object, connection, ascii = FALSE, xdr = TRUE, version = NULL, refhook = NULL) 
{
  if (!is.null(connection)) {
    if (!inherits(connection, "connection")) 
      stop("'connection' must be a connection")
    if (missing(ascii)) 
      ascii <- summary(connection)$text == "text"
  }
  if (!ascii && inherits(connection, "sockconn")) 
    .Internal(serializeb(object, connection, xdr, version, refhook))
  else {
    type <- if (is.na(ascii)) 
      2
    else if (ascii) 
      1
    else if (!xdr) 
      3
    else 0
    .Internal(serialize(object, connection, type, version, refhook))
  }
}, function (object, connection, ascii = FALSE, xdr = TRUE, version = NULL, refhook = NULL) 
{
  if (!is.null(connection)) {
    if (!inherits(connection, "connection")) 
      stop("'connection' must be a connection")
    if (missing(ascii)) 
      ascii <- summary(connection)$text == "text"
  }
  if (!ascii && inherits(connection, "sockconn")) 
    .Internal(serializeb(object, connection, xdr, version, refhook))
  else {
    type <- if (is.na(ascii)) 
      2
    else if (ascii) 
      1
    else if (!xdr) 
      3
    else 0
    .Internal(serialize(object, connection, type, version, refhook))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
serverSocket
list(`package:base` = function (port) 
  .Internal(serverSocket(port)), function (port) 
    .Internal(serverSocket(port)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
set.seed
list(`package:base` = function (seed, kind = NULL, normal.kind = NULL, sample.kind = NULL) 
{
  kinds <- c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister", "Knuth-TAOCP", "user-supplied", "Knuth-TAOCP-2002", "L'Ecuyer-CMRG", "default")
  n.kinds <- c("Buggy Kinderman-Ramage", "Ahrens-Dieter", "Box-Muller", "user-supplied", "Inversion", "Kinderman-Ramage", "default")
  s.kinds <- c("Rounding", "Rejection", "default")
  if (length(kind)) {
    if (!is.character(kind) || length(kind) > 1) 
      stop("'kind' must be a character string of length 1 (RNG to be used).")
    if (is.na(i.knd <- pmatch(kind, kinds) - 1)) 
      stop(gettextf("'%s' is not a valid abbreviation of an RNG", kind), domain = NA)
    if (i.knd == length(kinds) - 1) 
      i.knd <- -1
  }
  else i.knd <- NULL
  if (!is.null(normal.kind)) {
    if (!is.character(normal.kind) || length(normal.kind) != 1) 
      stop("'normal.kind' must be a character string of length 1")
    normal.kind <- pmatch(normal.kind, n.kinds) - 1
    if (is.na(normal.kind)) 
      stop(gettextf("'%s' is not a valid choice", normal.kind), domain = NA)
    if (normal.kind == 0) 
      stop("buggy version of Kinderman-Ramage generator is not allowed", domain = NA)
    if (normal.kind == length(n.kinds) - 1) 
      normal.kind <- -1
  }
  if (!is.null(sample.kind)) {
    if (!is.character(sample.kind) || length(sample.kind) != 1) 
      stop("'sample.kind' must be a character string of length 1")
    sample.kind <- pmatch(sample.kind, s.kinds) - 1
    if (is.na(sample.kind)) 
      stop(gettextf("'%s' is not a valid choice", sample.kind), domain = NA)
    if (sample.kind == 0) 
      warning("non-uniform 'Rounding' sampler used", domain = NA)
    if (sample.kind == length(s.kinds) - 1) 
      sample.kind <- -1
  }
  .Internal(set.seed(seed, i.knd, normal.kind, sample.kind))
}, function (seed, kind = NULL, normal.kind = NULL, sample.kind = NULL) 
{
  kinds <- c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister", "Knuth-TAOCP", "user-supplied", "Knuth-TAOCP-2002", "L'Ecuyer-CMRG", "default")
  n.kinds <- c("Buggy Kinderman-Ramage", "Ahrens-Dieter", "Box-Muller", "user-supplied", "Inversion", "Kinderman-Ramage", "default")
  s.kinds <- c("Rounding", "Rejection", "default")
  if (length(kind)) {
    if (!is.character(kind) || length(kind) > 1) 
      stop("'kind' must be a character string of length 1 (RNG to be used).")
    if (is.na(i.knd <- pmatch(kind, kinds) - 1)) 
      stop(gettextf("'%s' is not a valid abbreviation of an RNG", kind), domain = NA)
    if (i.knd == length(kinds) - 1) 
      i.knd <- -1
  }
  else i.knd <- NULL
  if (!is.null(normal.kind)) {
    if (!is.character(normal.kind) || length(normal.kind) != 1) 
      stop("'normal.kind' must be a character string of length 1")
    normal.kind <- pmatch(normal.kind, n.kinds) - 1
    if (is.na(normal.kind)) 
      stop(gettextf("'%s' is not a valid choice", normal.kind), domain = NA)
    if (normal.kind == 0) 
      stop("buggy version of Kinderman-Ramage generator is not allowed", domain = NA)
    if (normal.kind == length(n.kinds) - 1) 
      normal.kind <- -1
  }
  if (!is.null(sample.kind)) {
    if (!is.character(sample.kind) || length(sample.kind) != 1) 
      stop("'sample.kind' must be a character string of length 1")
    sample.kind <- pmatch(sample.kind, s.kinds) - 1
    if (is.na(sample.kind)) 
      stop(gettextf("'%s' is not a valid choice", sample.kind), domain = NA)
    if (sample.kind == 0) 
      warning("non-uniform 'Rounding' sampler used", domain = NA)
    if (sample.kind == length(s.kinds) - 1) 
      sample.kind <- -1
  }
  .Internal(set.seed(seed, i.knd, normal.kind, sample.kind))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
setdiff
list(`package:base` = function (x, y) 
{
  u <- as.vector(x)
  v <- as.vector(y)
  u[!duplicated(unclass(u)) & (match(u, v, 0) == 0)]
}, function (x, y, ...) 
  UseMethod("setdiff"), function (x, y) 
  {
    u <- as.vector(x)
    v <- as.vector(y)
    u[!duplicated(unclass(u)) & (match(u, v, 0) == 0)]
  })
c("package:base", "namespace:generics", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
setequal
list(`package:base` = function (x, y) 
{
  x <- as.vector(x)
  y <- as.vector(y)
  !(anyNA(match(x, y)) || anyNA(match(y, x)))
}, function (x, y, ...) 
  UseMethod("setequal"), function (x, y) 
  {
    x <- as.vector(x)
    y <- as.vector(y)
    !(anyNA(match(x, y)) || anyNA(match(y, x)))
  })
c("package:base", "namespace:generics", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
setHook
list(`package:base` = function (hookName, value, action = c("append", "prepend", "replace")) 
{
  action <- match.arg(action)
  old <- getHook(hookName)
  new <- switch(action, append = c(old, value), prepend = c(value, old), replace = if (is.null(value) || is.list(value)) value else list(value))
  if (length(new)) 
    assign(hookName, new, envir = .userHooksEnv, inherits = FALSE)
  else if (exists(hookName, envir = .userHooksEnv, inherits = FALSE)) 
    remove(list = hookName, envir = .userHooksEnv, inherits = FALSE)
  invisible()
}, function (hookName, value, action = c("append", "prepend", "replace")) 
{
  action <- match.arg(action)
  old <- getHook(hookName)
  new <- switch(action, append = c(old, value), prepend = c(value, old), replace = if (is.null(value) || is.list(value)) value else list(value))
  if (length(new)) 
    assign(hookName, new, envir = .userHooksEnv, inherits = FALSE)
  else if (exists(hookName, envir = .userHooksEnv, inherits = FALSE)) 
    remove(list = hookName, envir = .userHooksEnv, inherits = FALSE)
  invisible()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
setNamespaceInfo
list(`package:base` = function (ns, which, val) 
{
  ns <- asNamespace(ns, base.OK = FALSE)
  info <- ns[[".__NAMESPACE__."]]
  info[[which]] <- val
}, function (ns, which, val) 
{
  ns <- asNamespace(ns, base.OK = FALSE)
  info <- ns[[".__NAMESPACE__."]]
  info[[which]] <- val
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
setSessionTimeLimit
list(`package:base` = function (cpu = Inf, elapsed = Inf) 
  .Internal(setSessionTimeLimit(cpu, elapsed)), function (cpu = Inf, elapsed = Inf) 
    .Internal(setSessionTimeLimit(cpu, elapsed)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
setTimeLimit
list(`package:base` = function (cpu = Inf, elapsed = Inf, transient = FALSE) 
  .Internal(setTimeLimit(cpu, elapsed, transient)), function (cpu = Inf, elapsed = Inf, transient = FALSE) 
    .Internal(setTimeLimit(cpu, elapsed, transient)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
setwd
list(`package:base` = function (dir) 
  .Internal(setwd(dir)), function (dir) 
    .Internal(setwd(dir)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
shell
list(`package:base` = function (cmd, shell, flag = "/c", intern = FALSE, wait = TRUE, translate = FALSE, mustWork = FALSE, ...) 
{
  if (missing(shell)) {
    shell <- Sys.getenv("R_SHELL")
    if (!nzchar(shell)) 
      shell <- Sys.getenv("COMSPEC")
  }
  if (missing(flag) && any(!is.na(pmatch(c("bash", "tcsh", "sh"), basename(shell))))) 
    flag <- "-c"
  cmd0 <- cmd
  if (translate) 
    cmd <- chartr("/", "\\", cmd)
  if (!is.null(shell)) 
    cmd <- paste(shell, flag, cmd)
  res <- system(cmd, intern = intern, wait = wait | intern, show.output.on.console = wait, ...)
  if (!intern && res && !is.na(mustWork)) 
    if (mustWork) 
      if (res == -1) 
        stop(gettextf("'%s' could not be run", cmd0), domain = NA)
  else stop(gettextf("'%s' execution failed with error code %d", cmd0, res), domain = NA)
  else if (res == -1) 
    warning(gettextf("'%s' could not be run", cmd0), domain = NA)
  else warning(gettextf("'%s' execution failed with error code %d", cmd0, res), domain = NA)
  if (intern) 
    res
  else invisible(res)
}, function (cmd, shell, flag = "/c", intern = FALSE, wait = TRUE, translate = FALSE, mustWork = FALSE, ...) 
{
  if (missing(shell)) {
    shell <- Sys.getenv("R_SHELL")
    if (!nzchar(shell)) 
      shell <- Sys.getenv("COMSPEC")
  }
  if (missing(flag) && any(!is.na(pmatch(c("bash", "tcsh", "sh"), basename(shell))))) 
    flag <- "-c"
  cmd0 <- cmd
  if (translate) 
    cmd <- chartr("/", "\\", cmd)
  if (!is.null(shell)) 
    cmd <- paste(shell, flag, cmd)
  res <- system(cmd, intern = intern, wait = wait | intern, show.output.on.console = wait, ...)
  if (!intern && res && !is.na(mustWork)) 
    if (mustWork) 
      if (res == -1) 
        stop(gettextf("'%s' could not be run", cmd0), domain = NA)
  else stop(gettextf("'%s' execution failed with error code %d", cmd0, res), domain = NA)
  else if (res == -1) 
    warning(gettextf("'%s' could not be run", cmd0), domain = NA)
  else warning(gettextf("'%s' execution failed with error code %d", cmd0, res), domain = NA)
  if (intern) 
    res
  else invisible(res)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
shell.exec
list(`package:base` = function (file) 
  .Internal(shell.exec(file)), function (file) 
    .Internal(shell.exec(file)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
showConnections
list(`package:base` = function (all = FALSE) 
{
  gc()
  set <- getAllConnections()
  if (!all) 
    set <- set[set > 2]
  ans <- matrix("", length(set), 7)
  for (i in seq_along(set)) ans[i, ] <- unlist(summary.connection(set[i]))
  rownames(ans) <- set
  colnames(ans) <- c("description", "class", "mode", "text", "isopen", "can read", "can write")
  if (!all) 
    ans[ans[, 5] == "opened", , drop = FALSE]
  else ans[, , drop = FALSE]
}, function (all = FALSE) 
{
  gc()
  set <- getAllConnections()
  if (!all) 
    set <- set[set > 2]
  ans <- matrix("", length(set), 7)
  for (i in seq_along(set)) ans[i, ] <- unlist(summary.connection(set[i]))
  rownames(ans) <- set
  colnames(ans) <- c("description", "class", "mode", "text", "isopen", "can read", "can write")
  if (!all) 
    ans[ans[, 5] == "opened", , drop = FALSE]
  else ans[, , drop = FALSE]
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
shQuote
list(`package:base` = function (string, type = c("sh", "csh", "cmd", "cmd2")) 
{
  if (missing(type) && .Platform$OS.type == "windows") 
    type <- "cmd"
  type <- match.arg(type)
  if (type == "cmd") {
    string <- gsub("(\\\\*)\"", "\\1\\1\\\\\"", string)
    string <- sub("(\\\\+)$", "\\1\\1", string)
    paste0("\"", string, "\"", recycle0 = TRUE)
  }
  else if (type == "cmd2") 
    gsub("([()%!^\"<>&|])", "^\\1", string)
  else if (!any(grepl("'", string))) 
    paste0("'", string, "'", recycle0 = TRUE)
  else if (type == "sh") 
    paste0("\"", gsub("([\"$`\\])", "\\\\\\1", string), "\"")
  else if (!any(grepl("([$`])", string))) 
    paste0("\"", gsub("([\"!\\])", "\\\\\\1", string), "\"")
  else paste0("'", gsub("'", "'\"'\"'", string, fixed = TRUE), "'")
}, function (string, type = c("sh", "csh", "cmd", "cmd2")) 
{
  if (missing(type) && .Platform$OS.type == "windows") 
    type <- "cmd"
  type <- match.arg(type)
  if (type == "cmd") {
    string <- gsub("(\\\\*)\"", "\\1\\1\\\\\"", string)
    string <- sub("(\\\\+)$", "\\1\\1", string)
    paste0("\"", string, "\"", recycle0 = TRUE)
  }
  else if (type == "cmd2") 
    gsub("([()%!^\"<>&|])", "^\\1", string)
  else if (!any(grepl("'", string))) 
    paste0("'", string, "'", recycle0 = TRUE)
  else if (type == "sh") 
    paste0("\"", gsub("([\"$`\\])", "\\\\\\1", string), "\"")
  else if (!any(grepl("([$`])", string))) 
    paste0("\"", gsub("([\"!\\])", "\\\\\\1", string), "\"")
  else paste0("'", gsub("'", "'\"'\"'", string, fixed = TRUE), "'")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sign
list(`package:base` = .Primitive("sign"), .Primitive("sign"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
signalCondition
list(`package:base` = function (cond) 
{
  if (!inherits(cond, "condition")) 
    cond <- simpleCondition(cond)
  msg <- conditionMessage(cond)
  call <- conditionCall(cond)
  .Internal(.signalCondition(cond, msg, call))
}, function (cond) 
{
  if (!inherits(cond, "condition")) 
    cond <- simpleCondition(cond)
  msg <- conditionMessage(cond)
  call <- conditionCall(cond)
  .Internal(.signalCondition(cond, msg, call))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
signif
list(`package:base` = .Primitive("signif"), .Primitive("signif"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
simpleCondition
list(`package:base` = function (message, call = NULL) 
{
  class <- c("simpleCondition", "condition")
  structure(list(message = as.character(message), call = call), class = class)
}, function (message, call = NULL) 
{
  class <- c("simpleCondition", "condition")
  structure(list(message = as.character(message), call = call), class = class)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
simpleError
list(`package:base` = function (message, call = NULL) 
{
  class <- c("simpleError", "error", "condition")
  structure(list(message = as.character(message), call = call), class = class)
}, function (message, call = NULL) 
{
  class <- c("simpleError", "error", "condition")
  structure(list(message = as.character(message), call = call), class = class)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
simpleMessage
list(`package:base` = function (message, call = NULL) 
  structure(list(message = message, call = call), class = c("simpleMessage", "message", "condition")), function (message, call = NULL) 
    structure(list(message = message, call = call), class = c("simpleMessage", "message", "condition")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
simpleWarning
list(`package:base` = function (message, call = NULL) 
{
  class <- c("simpleWarning", "warning", "condition")
  structure(list(message = as.character(message), call = call), class = class)
}, function (message, call = NULL) 
{
  class <- c("simpleWarning", "warning", "condition")
  structure(list(message = as.character(message), call = call), class = class)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
simplify2array
list(`package:base` = function (x, higher = TRUE, except = c(0, 1)) 
{
  if (!length(x)) 
    return(x)
  if (length(common.len <- unique(lengths(x))) > 1) 
    return(x)
  except <- as.integer(except)
  except <- except[except <= 1]
  if ((common.len == 1) && (1 %in% except)) {
    n <- length(x)
    r <- unlist(x, recursive = FALSE)
    if (length(r) == n) 
      r
    else x
  }
  else if (!(common.len %in% except)) {
    n <- length(x)
    r <- unlist(x, recursive = FALSE, use.names = FALSE)
    if (is.null(r)) 
      x
    else if (higher && length(c.dim <- unique(lapply(x, dim))) == 1 && is.numeric(c.dim <- c.dim[[1]]) && prod(d <- c(c.dim, n)) == length(r)) {
      iN1 <- is.null(n1 <- dimnames(x[[1]]))
      n2 <- names(x)
      dnam <- if (!(iN1 && is.null(n2))) 
        c(if (iN1) rep.int(list(n1), length(c.dim)) else n1, list(n2))
      array(r, dim = d, dimnames = dnam)
    }
    else if (prod(d <- c(common.len, n)) == length(r)) 
      array(r, dim = d, dimnames = if (!(is.null(n1 <- names(x[[1]])) & is.null(n2 <- names(x)))) 
        list(n1, n2))
    else x
  }
  else x
}, function (x, higher = TRUE, except = c(0, 1)) 
{
  if (!length(x)) 
    return(x)
  if (length(common.len <- unique(lengths(x))) > 1) 
    return(x)
  except <- as.integer(except)
  except <- except[except <= 1]
  if ((common.len == 1) && (1 %in% except)) {
    n <- length(x)
    r <- unlist(x, recursive = FALSE)
    if (length(r) == n) 
      r
    else x
  }
  else if (!(common.len %in% except)) {
    n <- length(x)
    r <- unlist(x, recursive = FALSE, use.names = FALSE)
    if (is.null(r)) 
      x
    else if (higher && length(c.dim <- unique(lapply(x, dim))) == 1 && is.numeric(c.dim <- c.dim[[1]]) && prod(d <- c(c.dim, n)) == length(r)) {
      iN1 <- is.null(n1 <- dimnames(x[[1]]))
      n2 <- names(x)
      dnam <- if (!(iN1 && is.null(n2))) 
        c(if (iN1) rep.int(list(n1), length(c.dim)) else n1, list(n2))
      array(r, dim = d, dimnames = dnam)
    }
    else if (prod(d <- c(common.len, n)) == length(r)) 
      array(r, dim = d, dimnames = if (!(is.null(n1 <- names(x[[1]])) & is.null(n2 <- names(x)))) 
        list(n1, n2))
    else x
  }
  else x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sin
list(`package:base` = .Primitive("sin"), .Primitive("sin"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
single
list(`package:base` = function (length = 0) 
  structure(vector("double", length), Csingle = TRUE), function (length = 0) 
    structure(vector("double", length), Csingle = TRUE))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sinh
list(`package:base` = .Primitive("sinh"), .Primitive("sinh"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sink
list(`package:base` = function (file = NULL, append = FALSE, type = c("output", "message"), split = FALSE) 
{
  type <- match.arg(type)
  if (type == "message") {
    if (is.null(file)) 
      file <- stderr()
    else if (!inherits(file, "connection") || !isOpen(file)) 
      stop("'file' must be NULL or an already open connection")
    if (split) 
      stop("cannot split the message connection")
    .Internal(sink(file, FALSE, TRUE, FALSE))
  }
  else {
    closeOnExit <- FALSE
    if (is.null(file)) 
      file <- -1
    else if (is.character(file)) {
      file <- file(file, if (append) 
        "a"
        else "w")
      closeOnExit <- TRUE
    }
    else if (!inherits(file, "connection")) 
      stop("'file' must be NULL, a connection or a character string")
    .Internal(sink(file, closeOnExit, FALSE, split))
  }
}, function (file = NULL, append = FALSE, type = c("output", "message"), split = FALSE) 
{
  type <- match.arg(type)
  if (type == "message") {
    if (is.null(file)) 
      file <- stderr()
    else if (!inherits(file, "connection") || !isOpen(file)) 
      stop("'file' must be NULL or an already open connection")
    if (split) 
      stop("cannot split the message connection")
    .Internal(sink(file, FALSE, TRUE, FALSE))
  }
  else {
    closeOnExit <- FALSE
    if (is.null(file)) 
      file <- -1
    else if (is.character(file)) {
      file <- file(file, if (append) 
        "a"
        else "w")
      closeOnExit <- TRUE
    }
    else if (!inherits(file, "connection")) 
      stop("'file' must be NULL, a connection or a character string")
    .Internal(sink(file, closeOnExit, FALSE, split))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sink.number
list(`package:base` = function (type = c("output", "message")) 
{
  type <- match.arg(type)
  .Internal(sink.number(type != "message"))
}, function (type = c("output", "message")) 
{
  type <- match.arg(type)
  .Internal(sink.number(type != "message"))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sinpi
list(`package:base` = .Primitive("sinpi"), .Primitive("sinpi"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
slice.index
list(`package:base` = function (x, MARGIN) 
{
  d <- dim(x)
  if (is.null(d)) 
    d <- length(x)
  n <- length(d)
  if (is.character(MARGIN)) {
    dn <- dimnames(x)
    if (is.null(dnn <- names(dn))) 
      stop("'x' must have named dimnames")
    MARGIN <- match(MARGIN, dnn)
    if (anyNA(MARGIN)) 
      stop("not all elements of 'MARGIN' are names of dimensions")
  }
  if (!length(MARGIN) || any(MARGIN < 1) || any(MARGIN > n)) 
    stop("incorrect value for 'MARGIN'")
  if (any(d == 0)) 
    return(array(integer(), d))
  m <- MARGIN[1]
  y <- rep.int(rep.int(1:d[m], prod(d[seq_len(m - 1)]) * rep.int(1, d[m])), prod(d[seq.int(from = m + 1, length.out = n - m)]))
  if (length(MARGIN) > 1) {
    p <- d[m]
    for (m in MARGIN[-1]) {
      y <- y + p * rep.int(rep.int(seq.int(0, d[m] - 1), prod(d[seq_len(m - 1)]) * rep.int(1, d[m])), prod(d[seq.int(from = m + 1, length.out = n - m)]))
      p <- p * d[m]
    }
  }
  dim(y) <- d
  y
}, function (x, MARGIN) 
{
  d <- dim(x)
  if (is.null(d)) 
    d <- length(x)
  n <- length(d)
  if (is.character(MARGIN)) {
    dn <- dimnames(x)
    if (is.null(dnn <- names(dn))) 
      stop("'x' must have named dimnames")
    MARGIN <- match(MARGIN, dnn)
    if (anyNA(MARGIN)) 
      stop("not all elements of 'MARGIN' are names of dimensions")
  }
  if (!length(MARGIN) || any(MARGIN < 1) || any(MARGIN > n)) 
    stop("incorrect value for 'MARGIN'")
  if (any(d == 0)) 
    return(array(integer(), d))
  m <- MARGIN[1]
  y <- rep.int(rep.int(1:d[m], prod(d[seq_len(m - 1)]) * rep.int(1, d[m])), prod(d[seq.int(from = m + 1, length.out = n - m)]))
  if (length(MARGIN) > 1) {
    p <- d[m]
    for (m in MARGIN[-1]) {
      y <- y + p * rep.int(rep.int(seq.int(0, d[m] - 1), prod(d[seq_len(m - 1)]) * rep.int(1, d[m])), prod(d[seq.int(from = m + 1, length.out = n - m)]))
      p <- p * d[m]
    }
  }
  dim(y) <- d
  y
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
socketAccept
list(`package:base` = function (socket, blocking = FALSE, open = "a+", encoding = getOption("encoding"), timeout = getOption("timeout"), options = getOption("socketOptions")) 
  .Internal(socketAccept(socket, blocking, open, encoding, timeout, options)), function (socket, blocking = FALSE, open = "a+", encoding = getOption("encoding"), timeout = getOption("timeout"), options = getOption("socketOptions")) 
    .Internal(socketAccept(socket, blocking, open, encoding, timeout, options)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
socketConnection
list(`package:base` = function (host = "localhost", port, server = FALSE, blocking = FALSE, open = "a+", encoding = getOption("encoding"), timeout = getOption("timeout"), options = getOption("socketOptions")) 
  .Internal(socketConnection(host, port, server, blocking, open, encoding, timeout, options)), function (host = "localhost", port, server = FALSE, blocking = FALSE, open = "a+", encoding = getOption("encoding"), timeout = getOption("timeout"), options = getOption("socketOptions")) 
    .Internal(socketConnection(host, port, server, blocking, open, encoding, timeout, options)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
socketSelect
list(`package:base` = function (socklist, write = FALSE, timeout = NULL) 
{
  if (is.null(timeout)) 
    timeout <- -1
  else if (timeout < 0) 
    stop("'timeout' must be NULL or a non-negative number")
  if (length(write) < length(socklist)) 
    write <- rep_len(write, length(socklist))
  .Internal(sockSelect(socklist, write, timeout))
}, function (socklist, write = FALSE, timeout = NULL) 
{
  if (is.null(timeout)) 
    timeout <- -1
  else if (timeout < 0) 
    stop("'timeout' must be NULL or a non-negative number")
  if (length(write) < length(socklist)) 
    write <- rep_len(write, length(socklist))
  .Internal(sockSelect(socklist, write, timeout))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
socketTimeout
list(`package:base` = function (socket, timeout = -1) 
  .Internal(socketTimeout(socket, timeout)), function (socket, timeout = -1) 
    .Internal(socketTimeout(socket, timeout)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
solve
list(`package:base` = function (a, b, ...) 
  UseMethod("solve"), new("standardGeneric", .Data = function (a, b, ...) 
    standardGeneric("solve"), generic = "solve", package = "base", group = list(), valueClass = character(0), signature = c("a", "b"), default = new("derivedDefaultMethod", .Data = function (a, b, ...) 
      UseMethod("solve"), target = new("signature", .Data = "ANY", names = "a", package = "methods"), defined = new("signature", .Data = "ANY", names = "a", package = "methods"), generic = "solve"), skeleton = (new("derivedDefaultMethod", .Data = function (a, b, ...) 
        UseMethod("solve"), target = new("signature", .Data = "ANY", names = "a", package = "methods"), defined = new("signature", .Data = "ANY", names = "a", package = "methods"), generic = "solve"))(a, b, ...)), function (a, b, ...) 
          UseMethod("solve"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
solve.default
list(`package:base` = function (a, b, tol = .Machine$double.eps, LINPACK = FALSE, ...) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  if (is.complex(a) || (!missing(b) && is.complex(b))) {
    a <- as.matrix(a)
    if (missing(b)) {
      b <- diag(1 + (0+0i), nrow(a))
      colnames(b) <- rownames(a)
    }
    return(.Internal(La_solve_cmplx(a, b)))
  }
  if (inherits(a, "qr")) {
    warning("solve.default called with a \"qr\" object: use 'qr.solve'")
    return(solve.qr(a, b, tol))
  }
  a <- as.matrix(a)
  if (missing(b)) {
    b <- diag(1, nrow(a))
    colnames(b) <- rownames(a)
  }
  .Internal(La_solve(a, b, tol))
}, function (a, b, tol = .Machine$double.eps, LINPACK = FALSE, ...) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  if (is.complex(a) || (!missing(b) && is.complex(b))) {
    a <- as.matrix(a)
    if (missing(b)) {
      b <- diag(1 + (0+0i), nrow(a))
      colnames(b) <- rownames(a)
    }
    return(.Internal(La_solve_cmplx(a, b)))
  }
  if (inherits(a, "qr")) {
    warning("solve.default called with a \"qr\" object: use 'qr.solve'")
    return(solve.qr(a, b, tol))
  }
  a <- as.matrix(a)
  if (missing(b)) {
    b <- diag(1, nrow(a))
    colnames(b) <- rownames(a)
  }
  .Internal(La_solve(a, b, tol))
}, function (a, b, tol = .Machine$double.eps, LINPACK = FALSE, ...) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  if (is.complex(a) || (!missing(b) && is.complex(b))) {
    a <- as.matrix(a)
    if (missing(b)) {
      b <- diag(1 + (0+0i), nrow(a))
      colnames(b) <- rownames(a)
    }
    return(.Internal(La_solve_cmplx(a, b)))
  }
  if (inherits(a, "qr")) {
    warning("solve.default called with a \"qr\" object: use 'qr.solve'")
    return(solve.qr(a, b, tol))
  }
  a <- as.matrix(a)
  if (missing(b)) {
    b <- diag(1, nrow(a))
    colnames(b) <- rownames(a)
  }
  .Internal(La_solve(a, b, tol))
})
c("package:base", "registered S3 method for solve from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
solve.qr
list(`package:base` = function (a, b, ...) 
{
  if (!inherits(a, "qr")) 
    stop("this is the \"qr\" method for the generic function solve()")
  nc <- ncol(a$qr)
  nr <- nrow(a$qr)
  if (a$rank != min(nc, nr)) 
    stop("singular matrix 'a' in 'solve'")
  if (missing(b)) {
    if (nc != nr) 
      stop("only square matrices can be inverted")
    b <- diag(1, nc)
  }
  res <- qr.coef(a, b)
  res[is.na(res)] <- 0
  res
}, function (a, b, ...) 
{
  if (!inherits(a, "qr")) 
    stop("this is the \"qr\" method for the generic function solve()")
  nc <- ncol(a$qr)
  nr <- nrow(a$qr)
  if (a$rank != min(nc, nr)) 
    stop("singular matrix 'a' in 'solve'")
  if (missing(b)) {
    if (nc != nr) 
      stop("only square matrices can be inverted")
    b <- diag(1, nc)
  }
  res <- qr.coef(a, b)
  res[is.na(res)] <- 0
  res
}, function (a, b, ...) 
{
  if (!inherits(a, "qr")) 
    stop("this is the \"qr\" method for the generic function solve()")
  nc <- ncol(a$qr)
  nr <- nrow(a$qr)
  if (a$rank != min(nc, nr)) 
    stop("singular matrix 'a' in 'solve'")
  if (missing(b)) {
    if (nc != nr) 
      stop("only square matrices can be inverted")
    b <- diag(1, nc)
  }
  res <- qr.coef(a, b)
  res[is.na(res)] <- 0
  res
})
c("package:base", "registered S3 method for solve from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
sort
list(`package:base` = function (x, decreasing = FALSE, ...) 
{
  if (!is.logical(decreasing) || length(decreasing) != 1) 
    stop("'decreasing' must be a length-1 logical vector.\nDid you intend to set 'partial'?")
  UseMethod("sort")
}, function (x, decreasing = FALSE, ...) 
{
  if (!is.logical(decreasing) || length(decreasing) != 1) 
    stop("'decreasing' must be a length-1 logical vector.\nDid you intend to set 'partial'?")
  UseMethod("sort")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sort.default
list(`package:base` = function (x, decreasing = FALSE, na.last = NA, ...) 
{
  if (is.object(x)) 
    x[order(x, na.last = na.last, decreasing = decreasing)]
  else sort.int(x, na.last = na.last, decreasing = decreasing, ...)
}, function (x, decreasing = FALSE, na.last = NA, ...) 
{
  if (is.object(x)) 
    x[order(x, na.last = na.last, decreasing = decreasing)]
  else sort.int(x, na.last = na.last, decreasing = decreasing, ...)
}, function (x, decreasing = FALSE, na.last = NA, ...) 
{
  if (is.object(x)) 
    x[order(x, na.last = na.last, decreasing = decreasing)]
  else sort.int(x, na.last = na.last, decreasing = decreasing, ...)
})
c("package:base", "registered S3 method for sort from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
sort.int
list(`package:base` = function (x, partial = NULL, na.last = NA, decreasing = FALSE, method = c("auto", "shell", "quick", "radix"), index.return = FALSE) 
{
  decreasing <- as.logical(decreasing)
  if (is.null(partial) && !index.return && is.numeric(x)) {
    if (.Internal(sorted_fpass(x, decreasing, na.last))) {
      attr <- attributes(x)
      if (!is.null(attr) && !identical(names(attr), "names")) 
        attributes(x) <- list(names = names(x))
      return(x)
    }
  }
  method <- match.arg(method)
  if (method == "auto" && is.null(partial) && (is.numeric(x) || is.factor(x) || is.logical(x)) && is.integer(length(x))) 
    method <- "radix"
  if (method == "radix") {
    if (!is.null(partial)) {
      stop("'partial' sorting not supported by radix method")
    }
    if (index.return && is.na(na.last)) {
      x <- x[!is.na(x)]
      na.last <- TRUE
    }
    o <- order(x, na.last = na.last, decreasing = decreasing, method = "radix")
    y <- x[o]
    y <- .doSortWrap(y, decreasing, na.last)
    return(if (index.return) list(x = y, ix = o) else y)
  }
  else if (method == "auto" || !is.numeric(x)) 
    method <- "shell"
  if (isfact <- is.factor(x)) {
    if (index.return) 
      stop("'index.return' only for non-factors")
    lev <- levels(x)
    nlev <- nlevels(x)
    isord <- is.ordered(x)
    x <- c(x)
  }
  else if (!is.atomic(x)) 
    stop("'x' must be atomic")
  if (has.na <- any(ina <- is.na(x))) {
    nas <- x[ina]
    x <- x[!ina]
  }
  if (index.return && !is.na(na.last)) 
    stop("'index.return' only for 'na.last = NA'")
  if (!is.null(partial)) {
    if (index.return || decreasing || isfact || method != "shell") 
      stop("unsupported options for partial sorting")
    if (!all(is.finite(partial))) 
      stop("non-finite 'partial'")
    if (has.na && !is.na(na.last)) 
      partial <- if (na.last) 
        partial[partial <= length(x)]
    else {
      k <- sum(ina)
      partial[partial > k] - k
    }
    y <- if (length(partial) <= 10) {
      partial <- .Internal(qsort(partial, FALSE))
      .Internal(psort(x, partial))
    }
    else if (is.double(x)) 
      .Internal(qsort(x, FALSE))
    else .Internal(sort(x, FALSE))
  }
  else {
    nms <- names(x)
    switch(method, quick = {
      if (!is.null(nms)) {
        if (decreasing) x <- -x
        y <- .Internal(qsort(x, TRUE))
        if (decreasing) y$x <- -y$x
        names(y$x) <- nms[y$ix]
        if (!index.return) y <- y$x
      } else {
        if (decreasing) x <- -x
        y <- .Internal(qsort(x, index.return))
        if (decreasing) if (index.return) y$x <- -y$x else y <- -y
      }
    }, shell = {
      if (index.return || !is.null(nms)) {
        o <- sort.list(x, decreasing = decreasing)
        y <- if (index.return) list(x = x[o], ix = o) else x[o]
      } else y <- .Internal(sort(x, decreasing))
    })
  }
  if (!is.na(na.last) && has.na) 
    y <- if (!na.last) 
      c(nas, y)
  else c(y, nas)
  if (isfact) 
    y <- (if (isord) 
      ordered
      else factor)(y, levels = seq_len(nlev), labels = lev)
  if (is.null(partial)) {
    y <- .doSortWrap(y, decreasing, na.last)
  }
  y
}, function (x, partial = NULL, na.last = NA, decreasing = FALSE, method = c("auto", "shell", "quick", "radix"), index.return = FALSE) 
{
  decreasing <- as.logical(decreasing)
  if (is.null(partial) && !index.return && is.numeric(x)) {
    if (.Internal(sorted_fpass(x, decreasing, na.last))) {
      attr <- attributes(x)
      if (!is.null(attr) && !identical(names(attr), "names")) 
        attributes(x) <- list(names = names(x))
      return(x)
    }
  }
  method <- match.arg(method)
  if (method == "auto" && is.null(partial) && (is.numeric(x) || is.factor(x) || is.logical(x)) && is.integer(length(x))) 
    method <- "radix"
  if (method == "radix") {
    if (!is.null(partial)) {
      stop("'partial' sorting not supported by radix method")
    }
    if (index.return && is.na(na.last)) {
      x <- x[!is.na(x)]
      na.last <- TRUE
    }
    o <- order(x, na.last = na.last, decreasing = decreasing, method = "radix")
    y <- x[o]
    y <- .doSortWrap(y, decreasing, na.last)
    return(if (index.return) list(x = y, ix = o) else y)
  }
  else if (method == "auto" || !is.numeric(x)) 
    method <- "shell"
  if (isfact <- is.factor(x)) {
    if (index.return) 
      stop("'index.return' only for non-factors")
    lev <- levels(x)
    nlev <- nlevels(x)
    isord <- is.ordered(x)
    x <- c(x)
  }
  else if (!is.atomic(x)) 
    stop("'x' must be atomic")
  if (has.na <- any(ina <- is.na(x))) {
    nas <- x[ina]
    x <- x[!ina]
  }
  if (index.return && !is.na(na.last)) 
    stop("'index.return' only for 'na.last = NA'")
  if (!is.null(partial)) {
    if (index.return || decreasing || isfact || method != "shell") 
      stop("unsupported options for partial sorting")
    if (!all(is.finite(partial))) 
      stop("non-finite 'partial'")
    if (has.na && !is.na(na.last)) 
      partial <- if (na.last) 
        partial[partial <= length(x)]
    else {
      k <- sum(ina)
      partial[partial > k] - k
    }
    y <- if (length(partial) <= 10) {
      partial <- .Internal(qsort(partial, FALSE))
      .Internal(psort(x, partial))
    }
    else if (is.double(x)) 
      .Internal(qsort(x, FALSE))
    else .Internal(sort(x, FALSE))
  }
  else {
    nms <- names(x)
    switch(method, quick = {
      if (!is.null(nms)) {
        if (decreasing) x <- -x
        y <- .Internal(qsort(x, TRUE))
        if (decreasing) y$x <- -y$x
        names(y$x) <- nms[y$ix]
        if (!index.return) y <- y$x
      } else {
        if (decreasing) x <- -x
        y <- .Internal(qsort(x, index.return))
        if (decreasing) if (index.return) y$x <- -y$x else y <- -y
      }
    }, shell = {
      if (index.return || !is.null(nms)) {
        o <- sort.list(x, decreasing = decreasing)
        y <- if (index.return) list(x = x[o], ix = o) else x[o]
      } else y <- .Internal(sort(x, decreasing))
    })
  }
  if (!is.na(na.last) && has.na) 
    y <- if (!na.last) 
      c(nas, y)
  else c(y, nas)
  if (isfact) 
    y <- (if (isord) 
      ordered
      else factor)(y, levels = seq_len(nlev), labels = lev)
  if (is.null(partial)) {
    y <- .doSortWrap(y, decreasing, na.last)
  }
  y
}, function (x, partial = NULL, na.last = NA, decreasing = FALSE, method = c("auto", "shell", "quick", "radix"), index.return = FALSE) 
{
  decreasing <- as.logical(decreasing)
  if (is.null(partial) && !index.return && is.numeric(x)) {
    if (.Internal(sorted_fpass(x, decreasing, na.last))) {
      attr <- attributes(x)
      if (!is.null(attr) && !identical(names(attr), "names")) 
        attributes(x) <- list(names = names(x))
      return(x)
    }
  }
  method <- match.arg(method)
  if (method == "auto" && is.null(partial) && (is.numeric(x) || is.factor(x) || is.logical(x)) && is.integer(length(x))) 
    method <- "radix"
  if (method == "radix") {
    if (!is.null(partial)) {
      stop("'partial' sorting not supported by radix method")
    }
    if (index.return && is.na(na.last)) {
      x <- x[!is.na(x)]
      na.last <- TRUE
    }
    o <- order(x, na.last = na.last, decreasing = decreasing, method = "radix")
    y <- x[o]
    y <- .doSortWrap(y, decreasing, na.last)
    return(if (index.return) list(x = y, ix = o) else y)
  }
  else if (method == "auto" || !is.numeric(x)) 
    method <- "shell"
  if (isfact <- is.factor(x)) {
    if (index.return) 
      stop("'index.return' only for non-factors")
    lev <- levels(x)
    nlev <- nlevels(x)
    isord <- is.ordered(x)
    x <- c(x)
  }
  else if (!is.atomic(x)) 
    stop("'x' must be atomic")
  if (has.na <- any(ina <- is.na(x))) {
    nas <- x[ina]
    x <- x[!ina]
  }
  if (index.return && !is.na(na.last)) 
    stop("'index.return' only for 'na.last = NA'")
  if (!is.null(partial)) {
    if (index.return || decreasing || isfact || method != "shell") 
      stop("unsupported options for partial sorting")
    if (!all(is.finite(partial))) 
      stop("non-finite 'partial'")
    if (has.na && !is.na(na.last)) 
      partial <- if (na.last) 
        partial[partial <= length(x)]
    else {
      k <- sum(ina)
      partial[partial > k] - k
    }
    y <- if (length(partial) <= 10) {
      partial <- .Internal(qsort(partial, FALSE))
      .Internal(psort(x, partial))
    }
    else if (is.double(x)) 
      .Internal(qsort(x, FALSE))
    else .Internal(sort(x, FALSE))
  }
  else {
    nms <- names(x)
    switch(method, quick = {
      if (!is.null(nms)) {
        if (decreasing) x <- -x
        y <- .Internal(qsort(x, TRUE))
        if (decreasing) y$x <- -y$x
        names(y$x) <- nms[y$ix]
        if (!index.return) y <- y$x
      } else {
        if (decreasing) x <- -x
        y <- .Internal(qsort(x, index.return))
        if (decreasing) if (index.return) y$x <- -y$x else y <- -y
      }
    }, shell = {
      if (index.return || !is.null(nms)) {
        o <- sort.list(x, decreasing = decreasing)
        y <- if (index.return) list(x = x[o], ix = o) else x[o]
      } else y <- .Internal(sort(x, decreasing))
    })
  }
  if (!is.na(na.last) && has.na) 
    y <- if (!na.last) 
      c(nas, y)
  else c(y, nas)
  if (isfact) 
    y <- (if (isord) 
      ordered
      else factor)(y, levels = seq_len(nlev), labels = lev)
  if (is.null(partial)) {
    y <- .doSortWrap(y, decreasing, na.last)
  }
  y
})
c("package:base", "registered S3 method for sort from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
sort.list
list(`package:base` = function (x, partial = NULL, na.last = TRUE, decreasing = FALSE, method = c("auto", "shell", "quick", "radix")) 
{
  decreasing <- as.logical(decreasing)
  if (is.null(partial) && is.numeric(x) && !is.object(x) && length(x) > 0) {
    if (.Internal(sorted_fpass(x, decreasing, na.last))) 
      return(seq_along(x))
  }
  method <- match.arg(method)
  if (method == "auto" && (is.numeric(x) || is.factor(x) || is.logical(x) || (is.object(x) && !is.atomic(x))) && is.integer(length(x))) 
    method <- "radix"
  if (!is.null(partial)) 
    .NotYetUsed("partial != NULL")
  if (method == "quick") {
    if (is.factor(x)) 
      x <- as.integer(x)
    if (is.numeric(x)) 
      return(sort(x, na.last = na.last, decreasing = decreasing, method = "quick", index.return = TRUE)$ix)
    else stop("method = \"quick\" is only for numeric 'x'")
  }
  if (is.na(na.last)) {
    x <- x[!is.na(x)]
    na.last <- TRUE
  }
  if (method == "radix") {
    return(order(x, na.last = na.last, decreasing = decreasing, method = "radix"))
  }
  if (!is.atomic(x)) 
    stop("'x' must be atomic for 'sort.list', method \"shell\" and \"quick\"\nHave you called 'sort' on a list?")
  .Internal(order(na.last, decreasing, x))
}, function (x, partial = NULL, na.last = TRUE, decreasing = FALSE, method = c("auto", "shell", "quick", "radix")) 
{
  decreasing <- as.logical(decreasing)
  if (is.null(partial) && is.numeric(x) && !is.object(x) && length(x) > 0) {
    if (.Internal(sorted_fpass(x, decreasing, na.last))) 
      return(seq_along(x))
  }
  method <- match.arg(method)
  if (method == "auto" && (is.numeric(x) || is.factor(x) || is.logical(x) || (is.object(x) && !is.atomic(x))) && is.integer(length(x))) 
    method <- "radix"
  if (!is.null(partial)) 
    .NotYetUsed("partial != NULL")
  if (method == "quick") {
    if (is.factor(x)) 
      x <- as.integer(x)
    if (is.numeric(x)) 
      return(sort(x, na.last = na.last, decreasing = decreasing, method = "quick", index.return = TRUE)$ix)
    else stop("method = \"quick\" is only for numeric 'x'")
  }
  if (is.na(na.last)) {
    x <- x[!is.na(x)]
    na.last <- TRUE
  }
  if (method == "radix") {
    return(order(x, na.last = na.last, decreasing = decreasing, method = "radix"))
  }
  if (!is.atomic(x)) 
    stop("'x' must be atomic for 'sort.list', method \"shell\" and \"quick\"\nHave you called 'sort' on a list?")
  .Internal(order(na.last, decreasing, x))
}, function (x, partial = NULL, na.last = TRUE, decreasing = FALSE, method = c("auto", "shell", "quick", "radix")) 
{
  decreasing <- as.logical(decreasing)
  if (is.null(partial) && is.numeric(x) && !is.object(x) && length(x) > 0) {
    if (.Internal(sorted_fpass(x, decreasing, na.last))) 
      return(seq_along(x))
  }
  method <- match.arg(method)
  if (method == "auto" && (is.numeric(x) || is.factor(x) || is.logical(x) || (is.object(x) && !is.atomic(x))) && is.integer(length(x))) 
    method <- "radix"
  if (!is.null(partial)) 
    .NotYetUsed("partial != NULL")
  if (method == "quick") {
    if (is.factor(x)) 
      x <- as.integer(x)
    if (is.numeric(x)) 
      return(sort(x, na.last = na.last, decreasing = decreasing, method = "quick", index.return = TRUE)$ix)
    else stop("method = \"quick\" is only for numeric 'x'")
  }
  if (is.na(na.last)) {
    x <- x[!is.na(x)]
    na.last <- TRUE
  }
  if (method == "radix") {
    return(order(x, na.last = na.last, decreasing = decreasing, method = "radix"))
  }
  if (!is.atomic(x)) 
    stop("'x' must be atomic for 'sort.list', method \"shell\" and \"quick\"\nHave you called 'sort' on a list?")
  .Internal(order(na.last, decreasing, x))
})
c("package:base", "registered S3 method for sort from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
sort.POSIXlt
list(`package:base` = function (x, decreasing = FALSE, na.last = NA, ...) 
  x[order(as.POSIXct(x), na.last = na.last, decreasing = decreasing)], function (x, decreasing = FALSE, na.last = NA, ...) 
    x[order(as.POSIXct(x), na.last = na.last, decreasing = decreasing)], function (x, decreasing = FALSE, na.last = NA, ...) 
      x[order(as.POSIXct(x), na.last = na.last, decreasing = decreasing)])
c("package:base", "registered S3 method for sort from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
source
list(`package:base` = function (file, local = FALSE, echo = verbose, print.eval = echo, exprs, spaced = use_file, verbose = getOption("verbose"), prompt.echo = getOption("prompt"), max.deparse.length = 150, width.cutoff = 60, deparseCtrl = "showAttributes", chdir = FALSE, encoding = getOption("encoding"), continue.echo = getOption("continue"), skip.echo = 0, keep.source = getOption("keep.source")) 
{
  envir <- if (isTRUE(local)) 
    parent.frame()
  else if (isFALSE(local)) 
    .GlobalEnv
  else if (is.environment(local)) 
    local
  else stop("'local' must be TRUE, FALSE or an environment")
  if (!missing(echo)) {
    if (!is.logical(echo)) 
      stop("'echo' must be logical")
    if (!echo && verbose) {
      warning("'verbose' is TRUE, 'echo' not; ... coercing 'echo <- TRUE'")
      echo <- TRUE
    }
  }
  if (verbose) {
    cat("'envir' chosen:")
    print(envir)
  }
  if (use_file <- missing(exprs)) {
    ofile <- file
    from_file <- FALSE
    srcfile <- NULL
    if (is.character(file)) {
      have_encoding <- !missing(encoding) && encoding != "unknown"
      if (identical(encoding, "unknown")) {
        enc <- utils::localeToCharset()
        encoding <- enc[length(enc)]
      }
      else enc <- encoding
      if (length(enc) > 1) {
        encoding <- NA
        owarn <- options(warn = 2)
        for (e in enc) {
          if (is.na(e)) 
            next
          zz <- file(file, encoding = e)
          res <- tryCatch(readLines(zz, warn = FALSE), error = identity)
          close(zz)
          if (!inherits(res, "error")) {
            encoding <- e
            break
          }
        }
        options(owarn)
      }
      if (is.na(encoding)) 
        stop("unable to find a plausible encoding")
      if (verbose) 
        cat(gettextf("encoding = \"%s\" chosen", encoding), "\n", sep = "")
      if (file == "") {
        file <- stdin()
        srcfile <- "<stdin>"
      }
      else {
        filename <- file
        file <- file(filename, "r", encoding = encoding)
        on.exit(close(file))
        if (isTRUE(keep.source)) {
          lines <- readLines(file, warn = FALSE)
          on.exit()
          close(file)
          srcfile <- srcfilecopy(filename, lines, file.mtime(filename)[1], isFile = TRUE)
        }
        else {
          from_file <- TRUE
          srcfile <- filename
        }
        loc <- utils::localeToCharset()[1]
        encoding <- if (have_encoding) 
          switch(loc, `UTF-8` = "UTF-8", `ISO8859-1` = "latin1", "unknown")
        else "unknown"
      }
    }
    else {
      lines <- readLines(file, warn = FALSE)
      srcfile <- if (isTRUE(keep.source)) 
        srcfilecopy(deparse1(substitute(file), ""), lines)
      else deparse1(substitute(file), "")
    }
    exprs <- if (!from_file) {
      if (length(lines)) 
        .Internal(parse(stdin(), n = -1, lines, "?", srcfile, encoding))
      else expression()
    }
    else .Internal(parse(file, n = -1, NULL, "?", srcfile, encoding))
    on.exit()
    if (from_file) 
      close(file)
    if (verbose) 
      cat("--> parsed", length(exprs), "expressions; now eval(.)ing them:\n")
    if (chdir) {
      if (is.character(ofile)) {
        if (grepl("^(ftp|ftps|http|https|file)://", ofile)) 
          warning("'chdir = TRUE' makes no sense for a URL")
        else if ((path <- dirname(ofile)) != ".") {
          owd <- getwd()
          if (is.null(owd)) 
            stop("cannot 'chdir' as current directory is unknown")
          on.exit(setwd(owd), add = TRUE)
          setwd(path)
        }
      }
      else {
        warning("'chdir = TRUE' makes no sense for a connection")
      }
    }
  }
  else {
    if (!missing(file)) 
      stop("specify either 'file' or 'exprs' but not both")
    if (!is.expression(exprs)) 
      exprs <- as.expression(exprs)
  }
  Ne <- length(exprs)
  if (echo) {
    sd <- "\""
    nos <- "[^\"]*"
    oddsd <- paste0("^", nos, sd, "(", nos, sd, nos, sd, ")*", nos, "$")
    trySrcLines <- function(srcfile, showfrom, showto) {
      tryCatch(suppressWarnings(getSrcLines(srcfile, showfrom, showto)), error = function(e) character())
    }
  }
  yy <- NULL
  lastshown <- 0
  srcrefs <- attr(exprs, "srcref")
  if (verbose && !is.null(srcrefs)) {
    cat("has srcrefs:\n")
    utils::str(srcrefs)
  }
  for (i in seq_len(Ne + echo)) {
    tail <- i > Ne
    if (!tail) {
      if (verbose) 
        cat("\n>>>> eval(expression_nr.", i, ")\n\t\t =================\n")
      ei <- exprs[i]
    }
    if (echo) {
      nd <- 0
      srcref <- if (tail) 
        attr(exprs, "wholeSrcref")
      else if (i <= length(srcrefs)) 
        srcrefs[[i]]
      if (!is.null(srcref)) {
        if (i == 1) 
          lastshown <- min(skip.echo, srcref[3] - 1)
        if (lastshown < srcref[3]) {
          srcfile <- attr(srcref, "srcfile")
          dep <- trySrcLines(srcfile, lastshown + 1, srcref[3])
          if (length(dep)) {
            leading <- if (tail) 
              length(dep)
            else srcref[1] - lastshown
            lastshown <- srcref[3]
            while (length(dep) && grepl("^[[:blank:]]*$", dep[1])) {
              dep <- dep[-1]
              leading <- leading - 1
            }
            dep <- paste0(rep.int(c(prompt.echo, continue.echo), pmax(0, c(leading, length(dep) - leading))), dep, collapse = "\n")
            nd <- nchar(dep, "c")
          }
          else srcref <- NULL
        }
      }
      if (is.null(srcref)) {
        if (!tail) {
          dep <- substr(paste(deparse(ei, width.cutoff = width.cutoff, control = deparseCtrl), collapse = "\n"), 12, 1000000)
          dep <- paste0(prompt.echo, gsub("\n", paste0("\n", continue.echo), dep, fixed = TRUE))
          nd <- nchar(dep, "c") - 1
        }
      }
      if (nd) {
        do.trunc <- nd > max.deparse.length
        dep <- substr(dep, 1, if (do.trunc) 
          max.deparse.length
          else nd)
        cat(if (spaced) 
          "\n", dep, if (do.trunc) 
            paste(if (grepl(sd, dep) && grepl(oddsd, dep)) 
              " ...\" ..."
              else " ....", "[TRUNCATED] "), "\n", sep = "")
      }
    }
    if (!tail) {
      yy <- withVisible(eval(ei, envir))
      i.symbol <- mode(ei[[1]]) == "name"
      if (!i.symbol) {
        curr.fun <- ei[[1]][[1]]
        if (verbose) {
          cat("curr.fun:")
          utils::str(curr.fun)
        }
      }
      if (verbose >= 2) {
        cat(".... mode(ei[[1L]])=", mode(ei[[1]]), "; paste(curr.fun)=")
        utils::str(paste(curr.fun))
      }
      if (print.eval && yy$visible) {
        if (isS4(yy$value)) 
          methods::show(yy$value)
        else print(yy$value)
      }
      if (verbose) 
        cat(" .. after ", sQuote(deparse(ei, control = unique(c(deparseCtrl, "useSource")))), "\n", sep = "")
    }
  }
  invisible(yy)
}, function (file, local = FALSE, echo = verbose, print.eval = echo, exprs, spaced = use_file, verbose = getOption("verbose"), prompt.echo = getOption("prompt"), max.deparse.length = 150, width.cutoff = 60, deparseCtrl = "showAttributes", chdir = FALSE, encoding = getOption("encoding"), continue.echo = getOption("continue"), skip.echo = 0, keep.source = getOption("keep.source")) 
{
  envir <- if (isTRUE(local)) 
    parent.frame()
  else if (isFALSE(local)) 
    .GlobalEnv
  else if (is.environment(local)) 
    local
  else stop("'local' must be TRUE, FALSE or an environment")
  if (!missing(echo)) {
    if (!is.logical(echo)) 
      stop("'echo' must be logical")
    if (!echo && verbose) {
      warning("'verbose' is TRUE, 'echo' not; ... coercing 'echo <- TRUE'")
      echo <- TRUE
    }
  }
  if (verbose) {
    cat("'envir' chosen:")
    print(envir)
  }
  if (use_file <- missing(exprs)) {
    ofile <- file
    from_file <- FALSE
    srcfile <- NULL
    if (is.character(file)) {
      have_encoding <- !missing(encoding) && encoding != "unknown"
      if (identical(encoding, "unknown")) {
        enc <- utils::localeToCharset()
        encoding <- enc[length(enc)]
      }
      else enc <- encoding
      if (length(enc) > 1) {
        encoding <- NA
        owarn <- options(warn = 2)
        for (e in enc) {
          if (is.na(e)) 
            next
          zz <- file(file, encoding = e)
          res <- tryCatch(readLines(zz, warn = FALSE), error = identity)
          close(zz)
          if (!inherits(res, "error")) {
            encoding <- e
            break
          }
        }
        options(owarn)
      }
      if (is.na(encoding)) 
        stop("unable to find a plausible encoding")
      if (verbose) 
        cat(gettextf("encoding = \"%s\" chosen", encoding), "\n", sep = "")
      if (file == "") {
        file <- stdin()
        srcfile <- "<stdin>"
      }
      else {
        filename <- file
        file <- file(filename, "r", encoding = encoding)
        on.exit(close(file))
        if (isTRUE(keep.source)) {
          lines <- readLines(file, warn = FALSE)
          on.exit()
          close(file)
          srcfile <- srcfilecopy(filename, lines, file.mtime(filename)[1], isFile = TRUE)
        }
        else {
          from_file <- TRUE
          srcfile <- filename
        }
        loc <- utils::localeToCharset()[1]
        encoding <- if (have_encoding) 
          switch(loc, `UTF-8` = "UTF-8", `ISO8859-1` = "latin1", "unknown")
        else "unknown"
      }
    }
    else {
      lines <- readLines(file, warn = FALSE)
      srcfile <- if (isTRUE(keep.source)) 
        srcfilecopy(deparse1(substitute(file), ""), lines)
      else deparse1(substitute(file), "")
    }
    exprs <- if (!from_file) {
      if (length(lines)) 
        .Internal(parse(stdin(), n = -1, lines, "?", srcfile, encoding))
      else expression()
    }
    else .Internal(parse(file, n = -1, NULL, "?", srcfile, encoding))
    on.exit()
    if (from_file) 
      close(file)
    if (verbose) 
      cat("--> parsed", length(exprs), "expressions; now eval(.)ing them:\n")
    if (chdir) {
      if (is.character(ofile)) {
        if (grepl("^(ftp|ftps|http|https|file)://", ofile)) 
          warning("'chdir = TRUE' makes no sense for a URL")
        else if ((path <- dirname(ofile)) != ".") {
          owd <- getwd()
          if (is.null(owd)) 
            stop("cannot 'chdir' as current directory is unknown")
          on.exit(setwd(owd), add = TRUE)
          setwd(path)
        }
      }
      else {
        warning("'chdir = TRUE' makes no sense for a connection")
      }
    }
  }
  else {
    if (!missing(file)) 
      stop("specify either 'file' or 'exprs' but not both")
    if (!is.expression(exprs)) 
      exprs <- as.expression(exprs)
  }
  Ne <- length(exprs)
  if (echo) {
    sd <- "\""
    nos <- "[^\"]*"
    oddsd <- paste0("^", nos, sd, "(", nos, sd, nos, sd, ")*", nos, "$")
    trySrcLines <- function(srcfile, showfrom, showto) {
      tryCatch(suppressWarnings(getSrcLines(srcfile, showfrom, showto)), error = function(e) character())
    }
  }
  yy <- NULL
  lastshown <- 0
  srcrefs <- attr(exprs, "srcref")
  if (verbose && !is.null(srcrefs)) {
    cat("has srcrefs:\n")
    utils::str(srcrefs)
  }
  for (i in seq_len(Ne + echo)) {
    tail <- i > Ne
    if (!tail) {
      if (verbose) 
        cat("\n>>>> eval(expression_nr.", i, ")\n\t\t =================\n")
      ei <- exprs[i]
    }
    if (echo) {
      nd <- 0
      srcref <- if (tail) 
        attr(exprs, "wholeSrcref")
      else if (i <= length(srcrefs)) 
        srcrefs[[i]]
      if (!is.null(srcref)) {
        if (i == 1) 
          lastshown <- min(skip.echo, srcref[3] - 1)
        if (lastshown < srcref[3]) {
          srcfile <- attr(srcref, "srcfile")
          dep <- trySrcLines(srcfile, lastshown + 1, srcref[3])
          if (length(dep)) {
            leading <- if (tail) 
              length(dep)
            else srcref[1] - lastshown
            lastshown <- srcref[3]
            while (length(dep) && grepl("^[[:blank:]]*$", dep[1])) {
              dep <- dep[-1]
              leading <- leading - 1
            }
            dep <- paste0(rep.int(c(prompt.echo, continue.echo), pmax(0, c(leading, length(dep) - leading))), dep, collapse = "\n")
            nd <- nchar(dep, "c")
          }
          else srcref <- NULL
        }
      }
      if (is.null(srcref)) {
        if (!tail) {
          dep <- substr(paste(deparse(ei, width.cutoff = width.cutoff, control = deparseCtrl), collapse = "\n"), 12, 1000000)
          dep <- paste0(prompt.echo, gsub("\n", paste0("\n", continue.echo), dep, fixed = TRUE))
          nd <- nchar(dep, "c") - 1
        }
      }
      if (nd) {
        do.trunc <- nd > max.deparse.length
        dep <- substr(dep, 1, if (do.trunc) 
          max.deparse.length
          else nd)
        cat(if (spaced) 
          "\n", dep, if (do.trunc) 
            paste(if (grepl(sd, dep) && grepl(oddsd, dep)) 
              " ...\" ..."
              else " ....", "[TRUNCATED] "), "\n", sep = "")
      }
    }
    if (!tail) {
      yy <- withVisible(eval(ei, envir))
      i.symbol <- mode(ei[[1]]) == "name"
      if (!i.symbol) {
        curr.fun <- ei[[1]][[1]]
        if (verbose) {
          cat("curr.fun:")
          utils::str(curr.fun)
        }
      }
      if (verbose >= 2) {
        cat(".... mode(ei[[1L]])=", mode(ei[[1]]), "; paste(curr.fun)=")
        utils::str(paste(curr.fun))
      }
      if (print.eval && yy$visible) {
        if (isS4(yy$value)) 
          methods::show(yy$value)
        else print(yy$value)
      }
      if (verbose) 
        cat(" .. after ", sQuote(deparse(ei, control = unique(c(deparseCtrl, "useSource")))), "\n", sep = "")
    }
  }
  invisible(yy)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
split
list(`package:base` = function (x, f, drop = FALSE, ...) 
  UseMethod("split"), function (x, f, drop = FALSE, ...) 
    UseMethod("split"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
split.data.frame
list(`package:base` = function (x, f, drop = FALSE, ...) 
{
  if (inherits(f, "formula")) 
    f <- eval(attr(stats::terms(f), "variables"), x, environment(f))
  lapply(split(x = seq_len(nrow(x)), f = f, drop = drop, ...), function(ind) x[ind, , drop = FALSE])
}, function (x, f, drop = FALSE, ...) 
{
  if (inherits(f, "formula")) 
    f <- eval(attr(stats::terms(f), "variables"), x, environment(f))
  lapply(split(x = seq_len(nrow(x)), f = f, drop = drop, ...), function(ind) x[ind, , drop = FALSE])
}, function (x, f, drop = FALSE, ...) 
{
  if (inherits(f, "formula")) 
    f <- eval(attr(stats::terms(f), "variables"), x, environment(f))
  lapply(split(x = seq_len(nrow(x)), f = f, drop = drop, ...), function(ind) x[ind, , drop = FALSE])
})
c("package:base", "registered S3 method for split from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
split.Date
list(`package:base` = function (x, f, drop = FALSE, ...) 
{
  lapply(split.default(unclass(x), f, drop = drop, ...), .Date, oldClass(x))
}, function (x, f, drop = FALSE, ...) 
{
  lapply(split.default(unclass(x), f, drop = drop, ...), .Date, oldClass(x))
}, function (x, f, drop = FALSE, ...) 
{
  lapply(split.default(unclass(x), f, drop = drop, ...), .Date, oldClass(x))
})
c("package:base", "registered S3 method for split from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
split.default
list(`package:base` = function (x, f, drop = FALSE, sep = ".", lex.order = FALSE, ...) 
{
  if (!missing(...)) 
    .NotYetUsed(deparse(...), error = FALSE)
  if (is.list(f)) 
    f <- interaction(f, drop = drop, sep = sep, lex.order = lex.order)
  else if (!is.factor(f)) 
    f <- as.factor(f)
  else if (drop) 
    f <- factor(f)
  storage.mode(f) <- "integer"
  if (is.null(attr(x, "class"))) 
    return(.Internal(split(x, f)))
  ind <- .Internal(split(seq_along(x), f))
  lapply(ind, function(i) x[i])
}, function (x, f, drop = FALSE, sep = ".", lex.order = FALSE, ...) 
{
  if (!missing(...)) 
    .NotYetUsed(deparse(...), error = FALSE)
  if (is.list(f)) 
    f <- interaction(f, drop = drop, sep = sep, lex.order = lex.order)
  else if (!is.factor(f)) 
    f <- as.factor(f)
  else if (drop) 
    f <- factor(f)
  storage.mode(f) <- "integer"
  if (is.null(attr(x, "class"))) 
    return(.Internal(split(x, f)))
  ind <- .Internal(split(seq_along(x), f))
  lapply(ind, function(i) x[i])
}, function (x, f, drop = FALSE, sep = ".", lex.order = FALSE, ...) 
{
  if (!missing(...)) 
    .NotYetUsed(deparse(...), error = FALSE)
  if (is.list(f)) 
    f <- interaction(f, drop = drop, sep = sep, lex.order = lex.order)
  else if (!is.factor(f)) 
    f <- as.factor(f)
  else if (drop) 
    f <- factor(f)
  storage.mode(f) <- "integer"
  if (is.null(attr(x, "class"))) 
    return(.Internal(split(x, f)))
  ind <- .Internal(split(seq_along(x), f))
  lapply(ind, function(i) x[i])
})
c("package:base", "registered S3 method for split from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
split.POSIXct
list(`package:base` = function (x, f, drop = FALSE, ...) 
  lapply(split.default(as.double(x), f, drop = drop, ...), .POSIXct, attr(x, "tzone"), oldClass(x)), function (x, f, drop = FALSE, ...) 
    lapply(split.default(as.double(x), f, drop = drop, ...), .POSIXct, attr(x, "tzone"), oldClass(x)), function (x, f, drop = FALSE, ...) 
      lapply(split.default(as.double(x), f, drop = drop, ...), .POSIXct, attr(x, "tzone"), oldClass(x)))
c("package:base", "registered S3 method for split from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
split<-
  list(`package:base` = function (x, f, drop = FALSE, ..., value) 
    UseMethod("split<-"), function (x, f, drop = FALSE, ..., value) 
      UseMethod("split<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
split<-.data.frame
list(`package:base` = function (x, f, drop = FALSE, ..., value) 
{
  if (inherits(f, "formula")) 
    f <- eval(attr(stats::terms(f), "variables"), x, environment(f))
  ix <- split(seq_len(nrow(x)), f, drop = drop, ...)
  n <- length(value)
  j <- 0
  for (i in ix) {
    j <- j%%n + 1
    x[i, ] <- value[[j]]
  }
  x
}, function (x, f, drop = FALSE, ..., value) 
{
  if (inherits(f, "formula")) 
    f <- eval(attr(stats::terms(f), "variables"), x, environment(f))
  ix <- split(seq_len(nrow(x)), f, drop = drop, ...)
  n <- length(value)
  j <- 0
  for (i in ix) {
    j <- j%%n + 1
    x[i, ] <- value[[j]]
  }
  x
}, function (x, f, drop = FALSE, ..., value) 
{
  if (inherits(f, "formula")) 
    f <- eval(attr(stats::terms(f), "variables"), x, environment(f))
  ix <- split(seq_len(nrow(x)), f, drop = drop, ...)
  n <- length(value)
  j <- 0
  for (i in ix) {
    j <- j%%n + 1
    x[i, ] <- value[[j]]
  }
  x
})
c("package:base", "registered S3 method for split<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
split<-.default
list(`package:base` = function (x, f, drop = FALSE, ..., value) 
{
  ix <- split(seq_along(x), f, drop = drop, ...)
  n <- length(value)
  j <- 0
  for (i in ix) {
    j <- j%%n + 1
    x[i] <- value[[j]]
  }
  x
}, function (x, f, drop = FALSE, ..., value) 
{
  ix <- split(seq_along(x), f, drop = drop, ...)
  n <- length(value)
  j <- 0
  for (i in ix) {
    j <- j%%n + 1
    x[i] <- value[[j]]
  }
  x
}, function (x, f, drop = FALSE, ..., value) 
{
  ix <- split(seq_along(x), f, drop = drop, ...)
  n <- length(value)
  j <- 0
  for (i in ix) {
    j <- j%%n + 1
    x[i] <- value[[j]]
  }
  x
})
c("package:base", "registered S3 method for split<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
sprintf
list(`package:base` = function (fmt, ...) 
  .Internal(sprintf(fmt, ...)), function (fmt, ...) 
    .Internal(sprintf(fmt, ...)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sqrt
list(`package:base` = .Primitive("sqrt"), .Primitive("sqrt"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sQuote
list(`package:base` = function (x, q = getOption("useFancyQuotes")) 
{
  if (!length(x)) 
    return(character())
  before <- after <- "'"
  if (!is.null(q)) {
    if (isTRUE(q)) {
      li <- l10n_info()
      if (li$"UTF-8") 
        q <- "UTF-8"
      if (!is.null(li$codepage) && li$codepage > 0) {
        if (li$codepage >= 1250 && li$codepage <= 1258 || li$codepage == 874) {
          before <- rawToChar(as.raw(145))
          after <- rawToChar(as.raw(146))
        }
        else {
          z <- iconv(c(intToUtf8(8216), intToUtf8(8217)), "UTF-8", "")
          before <- z[1]
          after <- z[2]
        }
      }
    }
    if (identical(q, "TeX")) {
      before <- "`"
      after <- "'"
    }
    if (identical(q, "UTF-8")) {
      before <- intToUtf8(8216)
      after <- intToUtf8(8217)
    }
    if (is.character(q) && length(q) >= 4) {
      before <- q[1]
      after <- q[2]
    }
  }
  paste0(before, x, after)
}, function (x, q = getOption("useFancyQuotes")) 
{
  if (!length(x)) 
    return(character())
  before <- after <- "'"
  if (!is.null(q)) {
    if (isTRUE(q)) {
      li <- l10n_info()
      if (li$"UTF-8") 
        q <- "UTF-8"
      if (!is.null(li$codepage) && li$codepage > 0) {
        if (li$codepage >= 1250 && li$codepage <= 1258 || li$codepage == 874) {
          before <- rawToChar(as.raw(145))
          after <- rawToChar(as.raw(146))
        }
        else {
          z <- iconv(c(intToUtf8(8216), intToUtf8(8217)), "UTF-8", "")
          before <- z[1]
          after <- z[2]
        }
      }
    }
    if (identical(q, "TeX")) {
      before <- "`"
      after <- "'"
    }
    if (identical(q, "UTF-8")) {
      before <- intToUtf8(8216)
      after <- intToUtf8(8217)
    }
    if (is.character(q) && length(q) >= 4) {
      before <- q[1]
      after <- q[2]
    }
  }
  paste0(before, x, after)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
srcfile
list(`package:base` = function (filename, encoding = getOption("encoding"), Enc = "unknown") 
{
  stopifnot(is.character(filename), length(filename) == 1)
  e <- new.env(hash = FALSE, parent = emptyenv())
  e$wd <- getwd()
  e$filename <- filename
  e$timestamp <- file.mtime(filename)
  if (identical(encoding, "unknown")) 
    encoding <- "native.enc"
  e$encoding <- encoding
  e$Enc <- Enc
  class(e) <- "srcfile"
  return(e)
}, function (filename, encoding = getOption("encoding"), Enc = "unknown") 
{
  stopifnot(is.character(filename), length(filename) == 1)
  e <- new.env(hash = FALSE, parent = emptyenv())
  e$wd <- getwd()
  e$filename <- filename
  e$timestamp <- file.mtime(filename)
  if (identical(encoding, "unknown")) 
    encoding <- "native.enc"
  e$encoding <- encoding
  e$Enc <- Enc
  class(e) <- "srcfile"
  return(e)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
srcfilealias
list(`package:base` = function (filename, srcfile) 
{
  stopifnot(is.character(filename), length(filename) == 1)
  e <- new.env(parent = emptyenv())
  e$filename <- filename
  e$original <- srcfile
  class(e) <- c("srcfilealias", "srcfile")
  return(e)
}, function (filename, srcfile) 
{
  stopifnot(is.character(filename), length(filename) == 1)
  e <- new.env(parent = emptyenv())
  e$filename <- filename
  e$original <- srcfile
  class(e) <- c("srcfilealias", "srcfile")
  return(e)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
srcfilecopy
list(`package:base` = function (filename, lines, timestamp = Sys.time(), isFile = FALSE) 
{
  stopifnot(is.character(filename), length(filename) == 1)
  e <- new.env(parent = emptyenv())
  if (any(grepl("\n", lines, fixed = TRUE, useBytes = TRUE))) 
    lines <- unlist(strsplit(sub("$", "\n", as.character(lines)), "\n"))
  e$filename <- filename
  e$wd <- getwd()
  e$isFile <- isFile
  e$lines <- as.character(lines)
  e$fixedNewlines <- TRUE
  e$timestamp <- timestamp
  e$Enc <- "unknown"
  class(e) <- c("srcfilecopy", "srcfile")
  return(e)
}, function (filename, lines, timestamp = Sys.time(), isFile = FALSE) 
{
  stopifnot(is.character(filename), length(filename) == 1)
  e <- new.env(parent = emptyenv())
  if (any(grepl("\n", lines, fixed = TRUE, useBytes = TRUE))) 
    lines <- unlist(strsplit(sub("$", "\n", as.character(lines)), "\n"))
  e$filename <- filename
  e$wd <- getwd()
  e$isFile <- isFile
  e$lines <- as.character(lines)
  e$fixedNewlines <- TRUE
  e$timestamp <- timestamp
  e$Enc <- "unknown"
  class(e) <- c("srcfilecopy", "srcfile")
  return(e)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
srcref
list(`package:base` = function (srcfile, lloc) 
{
  stopifnot(inherits(srcfile, "srcfile"), length(lloc) %in% c(4, 6, 8))
  if (length(lloc) == 4) 
    lloc <- c(lloc, lloc[c(2, 4)])
  if (length(lloc) == 6) 
    lloc <- c(lloc, lloc[c(1, 3)])
  structure(as.integer(lloc), srcfile = srcfile, class = "srcref")
}, function (srcfile, lloc) 
{
  stopifnot(inherits(srcfile, "srcfile"), length(lloc) %in% c(4, 6, 8))
  if (length(lloc) == 4) 
    lloc <- c(lloc, lloc[c(2, 4)])
  if (length(lloc) == 6) 
    lloc <- c(lloc, lloc[c(1, 3)])
  structure(as.integer(lloc), srcfile = srcfile, class = "srcref")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
standardGeneric
list(`package:base` = .Primitive("standardGeneric"), .Primitive("standardGeneric"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
startsWith
list(`package:base` = function (x, prefix) 
  .Internal(startsWith(x, prefix)), function (x, prefix) 
    .Internal(startsWith(x, prefix)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
stderr
list(`package:base` = function () 
  .Internal(stderr()), function () 
    .Internal(stderr()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
stdin
list(`package:base` = function () 
  .Internal(stdin()), function () 
    .Internal(stdin()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
stdout
list(`package:base` = function () 
  .Internal(stdout()), function () 
    .Internal(stdout()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
stop
list(`package:base` = function (..., call. = TRUE, domain = NULL) 
{
  if (...length() == 1 && inherits(..1, "condition")) {
    cond <- ..1
    if (nargs() > 1) 
      warning("additional arguments ignored in stop()")
    message <- conditionMessage(cond)
    call <- conditionCall(cond)
    .Internal(.signalCondition(cond, message, call))
    .Internal(.dfltStop(message, call))
  }
  else .Internal(stop(call., .makeMessage(..., domain = domain)))
}, function (..., call. = FALSE) 
{
  base::stop(..., call. = FALSE)
}, function (..., call. = TRUE, domain = NULL) 
{
  if (...length() == 1 && inherits(..1, "condition")) {
    cond <- ..1
    if (nargs() > 1) 
      warning("additional arguments ignored in stop()")
    message <- conditionMessage(cond)
    call <- conditionCall(cond)
    .Internal(.signalCondition(cond, message, call))
    .Internal(.dfltStop(message, call))
  }
  else .Internal(stop(call., .makeMessage(..., domain = domain)))
})
c("package:base", "namespace:jsonlite", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
stopifnot
list(`package:base` = function (..., exprs, exprObject, local = TRUE) 
{
  n <- ...length()
  if ((has.e <- !missing(exprs)) || !missing(exprObject)) {
    if (n || (has.e && !missing(exprObject))) 
      stop("Only one of 'exprs', 'exprObject' or expressions, not more")
    envir <- if (isTRUE(local)) 
      parent.frame()
    else if (isFALSE(local)) 
      .GlobalEnv
    else if (is.environment(local)) 
      local
    else stop("'local' must be TRUE, FALSE or an environment")
    E1 <- if (has.e && is.call(exprs <- substitute(exprs))) 
      exprs[[1]]
    cl <- if (is.symbol(E1) && E1 == quote(`{`)) {
      exprs[[1]] <- quote(stopifnot)
      exprs
    }
    else as.call(c(quote(stopifnot), if (!has.e) exprObject else as.expression(exprs)))
    names(cl) <- NULL
    return(eval(cl, envir = envir))
  }
  Dparse <- function(call, cutoff = 60) {
    ch <- deparse(call, width.cutoff = cutoff)
    if (length(ch) > 1) 
      paste(ch[1], "....")
    else ch
  }
  head <- function(x, n = 6) x[seq_len(if (n < 0) max(length(x) + n, 0) else min(n, length(x)))]
  abbrev <- function(ae, n = 3) paste(c(head(ae, n), if (length(ae) > n) "...."), collapse = "\n  ")
  for (i in seq_len(n)) {
    r <- ...elt(i)
    if (!(is.logical(r) && !anyNA(r) && all(r))) {
      dots <- match.call()[-1]
      if (is.null(msg <- names(dots)) || !nzchar(msg <- msg[i])) {
        cl.i <- dots[[i]]
        msg <- if (is.call(cl.i) && identical(cl.i[[1]], quote(all.equal)) && (is.null(ni <- names(cl.i)) || length(cl.i) == 3 || length(cl.i <- cl.i[!nzchar(ni)]) == 3)) 
          sprintf(gettext("%s and %s are not equal:\n  %s"), Dparse(cl.i[[2]]), Dparse(cl.i[[3]]), abbrev(r))
        else sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), Dparse(cl.i))
      }
      stop(simpleError(msg, call = if (p <- sys.parent(1)) 
        sys.call(p)))
    }
  }
  invisible()
}, function (..., exprs, exprObject, local = TRUE) 
{
  n <- ...length()
  if ((has.e <- !missing(exprs)) || !missing(exprObject)) {
    if (n || (has.e && !missing(exprObject))) 
      stop("Only one of 'exprs', 'exprObject' or expressions, not more")
    envir <- if (isTRUE(local)) 
      parent.frame()
    else if (isFALSE(local)) 
      .GlobalEnv
    else if (is.environment(local)) 
      local
    else stop("'local' must be TRUE, FALSE or an environment")
    E1 <- if (has.e && is.call(exprs <- substitute(exprs))) 
      exprs[[1]]
    cl <- if (is.symbol(E1) && E1 == quote(`{`)) {
      exprs[[1]] <- quote(stopifnot)
      exprs
    }
    else as.call(c(quote(stopifnot), if (!has.e) exprObject else as.expression(exprs)))
    names(cl) <- NULL
    return(eval(cl, envir = envir))
  }
  Dparse <- function(call, cutoff = 60) {
    ch <- deparse(call, width.cutoff = cutoff)
    if (length(ch) > 1) 
      paste(ch[1], "....")
    else ch
  }
  head <- function(x, n = 6) x[seq_len(if (n < 0) max(length(x) + n, 0) else min(n, length(x)))]
  abbrev <- function(ae, n = 3) paste(c(head(ae, n), if (length(ae) > n) "...."), collapse = "\n  ")
  for (i in seq_len(n)) {
    r <- ...elt(i)
    if (!(is.logical(r) && !anyNA(r) && all(r))) {
      dots <- match.call()[-1]
      if (is.null(msg <- names(dots)) || !nzchar(msg <- msg[i])) {
        cl.i <- dots[[i]]
        msg <- if (is.call(cl.i) && identical(cl.i[[1]], quote(all.equal)) && (is.null(ni <- names(cl.i)) || length(cl.i) == 3 || length(cl.i <- cl.i[!nzchar(ni)]) == 3)) 
          sprintf(gettext("%s and %s are not equal:\n  %s"), Dparse(cl.i[[2]]), Dparse(cl.i[[3]]), abbrev(r))
        else sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), Dparse(cl.i))
      }
      stop(simpleError(msg, call = if (p <- sys.parent(1)) 
        sys.call(p)))
    }
  }
  invisible()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
storage.mode
list(`package:base` = function (x) 
  switch(tx <- typeof(x), closure = , builtin = , special = "function", tx), function (x) 
    switch(tx <- typeof(x), closure = , builtin = , special = "function", tx))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
storage.mode<-
  list(`package:base` = .Primitive("storage.mode<-"), .Primitive("storage.mode<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
str2expression
list(`package:base` = function (text) 
  .Internal(str2expression(text)), function (text) 
    .Internal(str2expression(text)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
str2lang
list(`package:base` = function (s) 
  .Internal(str2lang(s)), function (s) 
    .Internal(str2lang(s)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
strftime
list(`package:base` = function (x, format = "", tz = "", usetz = FALSE, ...) 
  format(as.POSIXlt(x, tz = tz), format = format, usetz = usetz, ...), function (x, format = "", tz = "", usetz = FALSE, ...) 
    format(as.POSIXlt(x, tz = tz), format = format, usetz = usetz, ...))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
strptime
list(`package:base` = function (x, format, tz = "") 
{
  y <- .Internal(strptime(as.character(x), format, tz))
  names(y$year) <- names(x)
  y
}, function (x, format, tz = "") 
{
  y <- .Internal(strptime(as.character(x), format, tz))
  names(y$year) <- names(x)
  y
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
strrep
list(`package:base` = function (x, times) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(strrep(x, as.integer(times)))
}, function (x, times) 
{
  x = as.character(x)
  if (length(x) == 0) 
    return(x)
  mapply(function(x, times) {
    if (is.na(x) || is.na(times)) {
      NA
    }
    else if (times <= 0) {
      ""
    }
    else {
      paste0(rep(x, times), collapse = "")
    }
  }, x, times, USE.NAMES = FALSE)
}, function (x, times) 
{
  x = as.character(x)
  if (length(x) == 0) 
    return(x)
  mapply(function(x, times) {
    if (is.na(x) || is.na(times)) {
      NA
    }
    else if (times <= 0) {
      ""
    }
    else {
      paste0(rep(x, times), collapse = "")
    }
  }, x, times, USE.NAMES = FALSE)
}, function (x, times) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(strrep(x, as.integer(times)))
})
c("package:base", "namespace:cli", "namespace:crayon", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
strsplit
list(`package:base` = function (x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE) 
  .Internal(strsplit(x, as.character(split), fixed, perl, useBytes)), function (x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE) 
    .Internal(strsplit(x, as.character(split), fixed, perl, useBytes)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
strtoi
list(`package:base` = function (x, base = 0) 
  .Internal(strtoi(as.character(x), as.integer(base))), function (x, base = 0) 
    .Internal(strtoi(as.character(x), as.integer(base))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
strtrim
list(`package:base` = function (x, width) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(strtrim(x, width))
}, function (x, width) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(strtrim(x, width))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
structure
list(`package:base` = function (.Data, ...) 
{
  if (is.null(.Data)) 
    warning("Calling 'structure(NULL, *)' is deprecated, as NULL cannot have attributes.\n  Consider 'structure(list(), *)' instead.")
  attrib <- list(...)
  if (length(attrib)) {
    specials <- c(".Dim", ".Dimnames", ".Names", ".Tsp", ".Label")
    attrnames <- names(attrib)
    m <- match(attrnames, specials)
    ok <- !is.na(m)
    if (any(ok)) {
      replace <- c("dim", "dimnames", "names", "tsp", "levels")
      names(attrib)[ok] <- replace[m[ok]]
    }
    if (any(attrib[["class", exact = TRUE]] == "factor") && typeof(.Data) == "double") 
      storage.mode(.Data) <- "integer"
    attributes(.Data) <- c(attributes(.Data), attrib)
  }
  .Data
}, function (.Data, ...) 
{
  if (is.null(.Data)) 
    warning("Calling 'structure(NULL, *)' is deprecated, as NULL cannot have attributes.\n  Consider 'structure(list(), *)' instead.")
  attrib <- list(...)
  if (length(attrib)) {
    specials <- c(".Dim", ".Dimnames", ".Names", ".Tsp", ".Label")
    attrnames <- names(attrib)
    m <- match(attrnames, specials)
    ok <- !is.na(m)
    if (any(ok)) {
      replace <- c("dim", "dimnames", "names", "tsp", "levels")
      names(attrib)[ok] <- replace[m[ok]]
    }
    if (any(attrib[["class", exact = TRUE]] == "factor") && typeof(.Data) == "double") 
      storage.mode(.Data) <- "integer"
    attributes(.Data) <- c(attributes(.Data), attrib)
  }
  .Data
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
strwrap
list(`package:base` = function (x, width = 0.9 * getOption("width"), indent = 0, exdent = 0, prefix = "", simplify = TRUE, initial = prefix) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  indentString <- strrep(" ", indent)
  exdentString <- strrep(" ", exdent)
  y <- list()
  enc <- Encoding(x)
  x <- enc2utf8(x)
  if (any(ind <- !validEnc(x))) 
    x[ind] <- iconv(x[ind], "UTF-8", "UTF-8", sub = "byte")
  z <- lapply(strsplit(x, "\n[ \t\n]*\n", perl = TRUE), strsplit, "[ \t\n]", perl = TRUE)
  for (i in seq_along(z)) {
    yi <- character()
    for (j in seq_along(z[[i]])) {
      words <- z[[i]][[j]]
      nc <- nchar(words, type = "w")
      if (anyNA(nc)) {
        nc0 <- nchar(words, type = "b")
        nc[is.na(nc)] <- nc0[is.na(nc)]
      }
      if (any(nc == 0)) {
        zLenInd <- which(nc == 0)
        zLenInd <- zLenInd[!(zLenInd %in% (grep("[.?!][)\"']{0,1}$", words, perl = TRUE, useBytes = TRUE) + 1))]
        if (length(zLenInd)) {
          words <- words[-zLenInd]
          nc <- nc[-zLenInd]
        }
      }
      if (!length(words)) {
        yi <- c(yi, "", initial)
        next
      }
      currentIndex <- 0
      lowerBlockIndex <- 1
      upperBlockIndex <- integer()
      lens <- cumsum(nc + 1)
      first <- TRUE
      maxLength <- width - nchar(initial, type = "w") - indent
      while (length(lens)) {
        k <- max(sum(lens <= maxLength), 1)
        if (first) {
          first <- FALSE
          maxLength <- width - nchar(prefix, type = "w") - exdent
        }
        currentIndex <- currentIndex + k
        if (nc[currentIndex] == 0) 
          upperBlockIndex <- c(upperBlockIndex, currentIndex - 1)
        else upperBlockIndex <- c(upperBlockIndex, currentIndex)
        if (length(lens) > k) {
          if (nc[currentIndex + 1] == 0) {
            currentIndex <- currentIndex + 1
            k <- k + 1
          }
          lowerBlockIndex <- c(lowerBlockIndex, currentIndex + 1)
        }
        if (length(lens) > k) 
          lens <- lens[-seq_len(k)] - lens[k]
        else lens <- NULL
      }
      nBlocks <- length(upperBlockIndex)
      s <- paste0(c(initial, rep.int(prefix, nBlocks - 1)), c(indentString, rep.int(exdentString, nBlocks - 1)))
      initial <- prefix
      for (k in seq_len(nBlocks)) s[k] <- paste0(s[k], paste(words[lowerBlockIndex[k]:upperBlockIndex[k]], collapse = " "))
      yi <- c(yi, s, prefix)
    }
    y <- if (length(yi)) 
      c(y, list(yi[-length(yi)]))
    else c(y, "")
  }
  if (length(pos <- which(enc == "latin1"))) {
    y[pos] <- lapply(y[pos], function(s) {
      e <- Encoding(s)
      if (length(p <- which(e == "UTF-8"))) 
        s[p] <- iconv(s[p], "UTF-8", "latin1", sub = "byte")
      s
    })
  }
  if (simplify) 
    y <- as.character(unlist(y))
  y
}, function (x, width = 0.9 * getOption("width"), indent = 0, exdent = 0, prefix = "", simplify = TRUE, initial = prefix) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  indentString <- strrep(" ", indent)
  exdentString <- strrep(" ", exdent)
  y <- list()
  enc <- Encoding(x)
  x <- enc2utf8(x)
  if (any(ind <- !validEnc(x))) 
    x[ind] <- iconv(x[ind], "UTF-8", "UTF-8", sub = "byte")
  z <- lapply(strsplit(x, "\n[ \t\n]*\n", perl = TRUE), strsplit, "[ \t\n]", perl = TRUE)
  for (i in seq_along(z)) {
    yi <- character()
    for (j in seq_along(z[[i]])) {
      words <- z[[i]][[j]]
      nc <- nchar(words, type = "w")
      if (anyNA(nc)) {
        nc0 <- nchar(words, type = "b")
        nc[is.na(nc)] <- nc0[is.na(nc)]
      }
      if (any(nc == 0)) {
        zLenInd <- which(nc == 0)
        zLenInd <- zLenInd[!(zLenInd %in% (grep("[.?!][)\"']{0,1}$", words, perl = TRUE, useBytes = TRUE) + 1))]
        if (length(zLenInd)) {
          words <- words[-zLenInd]
          nc <- nc[-zLenInd]
        }
      }
      if (!length(words)) {
        yi <- c(yi, "", initial)
        next
      }
      currentIndex <- 0
      lowerBlockIndex <- 1
      upperBlockIndex <- integer()
      lens <- cumsum(nc + 1)
      first <- TRUE
      maxLength <- width - nchar(initial, type = "w") - indent
      while (length(lens)) {
        k <- max(sum(lens <= maxLength), 1)
        if (first) {
          first <- FALSE
          maxLength <- width - nchar(prefix, type = "w") - exdent
        }
        currentIndex <- currentIndex + k
        if (nc[currentIndex] == 0) 
          upperBlockIndex <- c(upperBlockIndex, currentIndex - 1)
        else upperBlockIndex <- c(upperBlockIndex, currentIndex)
        if (length(lens) > k) {
          if (nc[currentIndex + 1] == 0) {
            currentIndex <- currentIndex + 1
            k <- k + 1
          }
          lowerBlockIndex <- c(lowerBlockIndex, currentIndex + 1)
        }
        if (length(lens) > k) 
          lens <- lens[-seq_len(k)] - lens[k]
        else lens <- NULL
      }
      nBlocks <- length(upperBlockIndex)
      s <- paste0(c(initial, rep.int(prefix, nBlocks - 1)), c(indentString, rep.int(exdentString, nBlocks - 1)))
      initial <- prefix
      for (k in seq_len(nBlocks)) s[k] <- paste0(s[k], paste(words[lowerBlockIndex[k]:upperBlockIndex[k]], collapse = " "))
      yi <- c(yi, s, prefix)
    }
    y <- if (length(yi)) 
      c(y, list(yi[-length(yi)]))
    else c(y, "")
  }
  if (length(pos <- which(enc == "latin1"))) {
    y[pos] <- lapply(y[pos], function(s) {
      e <- Encoding(s)
      if (length(p <- which(e == "UTF-8"))) 
        s[p] <- iconv(s[p], "UTF-8", "latin1", sub = "byte")
      s
    })
  }
  if (simplify) 
    y <- as.character(unlist(y))
  y
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sub
list(`package:base` = function (pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(x) && length(levels(x)) < length(x)) {
    sub(pattern, replacement, levels(x), ignore.case, perl, fixed, useBytes)[x]
  }
  else {
    if (!is.character(x)) 
      x <- as.character(x)
    .Internal(sub(as.character(pattern), as.character(replacement), x, ignore.case, perl, fixed, useBytes))
  }
}, function (pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  if (is.factor(x) && length(levels(x)) < length(x)) {
    sub(pattern, replacement, levels(x), ignore.case, perl, fixed, useBytes)[x]
  }
  else {
    if (!is.character(x)) 
      x <- as.character(x)
    .Internal(sub(as.character(pattern), as.character(replacement), x, ignore.case, perl, fixed, useBytes))
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
subset
list(`package:base` = function (x, ...) 
  UseMethod("subset"), function (x, ...) 
    UseMethod("subset"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
subset.data.frame
list(`package:base` = function (x, subset, select, drop = FALSE, ...) 
{
  r <- if (missing(subset)) 
    rep_len(TRUE, nrow(x))
  else {
    e <- substitute(subset)
    r <- eval(e, x, parent.frame())
    if (!is.logical(r)) 
      stop("'subset' must be logical")
    r & !is.na(r)
  }
  vars <- if (missing(select)) 
    rep_len(TRUE, ncol(x))
  else {
    nl <- as.list(seq_along(x))
    names(nl) <- names(x)
    eval(substitute(select), nl, parent.frame())
  }
  x[r, vars, drop = drop]
}, function (x, subset, select, drop = FALSE, ...) 
{
  r <- if (missing(subset)) 
    rep_len(TRUE, nrow(x))
  else {
    e <- substitute(subset)
    r <- eval(e, x, parent.frame())
    if (!is.logical(r)) 
      stop("'subset' must be logical")
    r & !is.na(r)
  }
  vars <- if (missing(select)) 
    rep_len(TRUE, ncol(x))
  else {
    nl <- as.list(seq_along(x))
    names(nl) <- names(x)
    eval(substitute(select), nl, parent.frame())
  }
  x[r, vars, drop = drop]
}, function (x, subset, select, drop = FALSE, ...) 
{
  r <- if (missing(subset)) 
    rep_len(TRUE, nrow(x))
  else {
    e <- substitute(subset)
    r <- eval(e, x, parent.frame())
    if (!is.logical(r)) 
      stop("'subset' must be logical")
    r & !is.na(r)
  }
  vars <- if (missing(select)) 
    rep_len(TRUE, ncol(x))
  else {
    nl <- as.list(seq_along(x))
    names(nl) <- names(x)
    eval(substitute(select), nl, parent.frame())
  }
  x[r, vars, drop = drop]
})
c("package:base", "registered S3 method for subset from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
subset.default
list(`package:base` = function (x, subset, ...) 
{
  if (!is.logical(subset)) 
    stop("'subset' must be logical")
  x[subset & !is.na(subset)]
}, function (x, subset, ...) 
{
  if (!is.logical(subset)) 
    stop("'subset' must be logical")
  x[subset & !is.na(subset)]
}, function (x, subset, ...) 
{
  if (!is.logical(subset)) 
    stop("'subset' must be logical")
  x[subset & !is.na(subset)]
})
c("package:base", "registered S3 method for subset from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
subset.matrix
list(`package:base` = function (x, subset, select, drop = FALSE, ...) 
{
  if (missing(select)) 
    vars <- TRUE
  else {
    nl <- as.list(1:ncol(x))
    names(nl) <- colnames(x)
    vars <- eval(substitute(select), nl, parent.frame())
  }
  if (missing(subset)) 
    subset <- TRUE
  else if (!is.logical(subset)) 
    stop("'subset' must be logical")
  x[subset & !is.na(subset), vars, drop = drop]
}, function (x, subset, select, drop = FALSE, ...) 
{
  if (missing(select)) 
    vars <- TRUE
  else {
    nl <- as.list(1:ncol(x))
    names(nl) <- colnames(x)
    vars <- eval(substitute(select), nl, parent.frame())
  }
  if (missing(subset)) 
    subset <- TRUE
  else if (!is.logical(subset)) 
    stop("'subset' must be logical")
  x[subset & !is.na(subset), vars, drop = drop]
}, function (x, subset, select, drop = FALSE, ...) 
{
  if (missing(select)) 
    vars <- TRUE
  else {
    nl <- as.list(1:ncol(x))
    names(nl) <- colnames(x)
    vars <- eval(substitute(select), nl, parent.frame())
  }
  if (missing(subset)) 
    subset <- TRUE
  else if (!is.logical(subset)) 
    stop("'subset' must be logical")
  x[subset & !is.na(subset), vars, drop = drop]
})
c("package:base", "registered S3 method for subset from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
substitute
list(`package:base` = .Primitive("substitute"), .Primitive("substitute"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
substr
list(`package:base` = function (x, start, stop) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(substr(x, as.integer(start), as.integer(stop)))
}, function (x, start, stop) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(substr(x, as.integer(start), as.integer(stop)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
substr<-
  list(`package:base` = function (x, start, stop, value) 
    .Internal(`substr<-`(x, as.integer(start), as.integer(stop), value)), function (x, start, stop, value) 
      .Internal(`substr<-`(x, as.integer(start), as.integer(stop), value)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
substring
list(`package:base` = function (text, first, last = 1000000) 
{
  if (!is.character(text)) 
    text <- as.character(text)
  n <- max(lt <- length(text), length(first), length(last))
  if (lt && lt < n) 
    text <- rep_len(text, length.out = n)
  .Internal(substr(text, as.integer(first), as.integer(last)))
}, function (text, first, last = 1000000) 
{
  if (!is.character(text)) 
    text <- as.character(text)
  n <- max(lt <- length(text), length(first), length(last))
  if (lt && lt < n) 
    text <- rep_len(text, length.out = n)
  .Internal(substr(text, as.integer(first), as.integer(last)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
substring<-
  list(`package:base` = function (text, first, last = 1000000, value) 
    .Internal(`substr<-`(text, as.integer(first), as.integer(last), value)), function (text, first, last = 1000000, value) 
      .Internal(`substr<-`(text, as.integer(first), as.integer(last), value)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sum
list(`package:base` = .Primitive("sum"), .Primitive("sum"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
summary
list(`package:base` = function (object, ...) 
  UseMethod("summary"), new("standardGeneric", .Data = function (object, ...) 
    standardGeneric("summary"), generic = "summary", package = "base", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object, ...) 
      UseMethod("summary"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "summary"), skeleton = (new("derivedDefaultMethod", .Data = function (object, ...) 
        UseMethod("summary"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "summary"))(object, ...)), new("standardGeneric", .Data = function (object, ...) 
          standardGeneric("summary"), generic = "summary", package = "base", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object, ...) 
            UseMethod("summary"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "summary"), skeleton = (new("derivedDefaultMethod", .Data = function (object, ...) 
              UseMethod("summary"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "summary"))(object, ...)), function (object, ...) 
                UseMethod("summary"))
c("package:base", "namespace:stats4", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, TRUE)
summary.connection
list(`package:base` = function (object, ...) 
  .Internal(summary.connection(object)), function (object, ...) 
    .Internal(summary.connection(object)), function (object, ...) 
      .Internal(summary.connection(object)))
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.data.frame
list(`package:base` = function (object, maxsum = 7, digits = max(3, getOption("digits") - 3), ...) 
{
  ncw <- function(x) {
    z <- nchar(x, type = "w", allowNA = TRUE)
    if (any(na <- is.na(z))) {
      z[na] <- nchar(encodeString(z[na]), "b")
    }
    z
  }
  z <- lapply(X = as.list(object), FUN = summary, maxsum = maxsum, digits = 12, ...)
  nv <- length(object)
  nm <- names(object)
  lw <- numeric(nv)
  nr <- if (nv) 
    max(vapply(z, function(x) NROW(x) + !is.null(attr(x, "NAs")), integer(1)))
  else 0
  for (i in seq_len(nv)) {
    sms <- z[[i]]
    if (is.matrix(sms)) {
      cn <- paste(nm[i], gsub("^ +", "", colnames(sms), useBytes = TRUE), sep = ".")
      tmp <- format(sms)
      if (nrow(sms) < nr) 
        tmp <- rbind(tmp, matrix("", nr - nrow(sms), ncol(sms)))
      sms <- apply(tmp, 1, function(x) paste(x, collapse = "  "))
      wid <- sapply(tmp[1, ], nchar, type = "w")
      blanks <- paste(character(max(wid)), collapse = " ")
      wcn <- ncw(cn)
      pad0 <- floor((wid - wcn)/2)
      pad1 <- wid - wcn - pad0
      cn <- paste0(substring(blanks, 1, pad0), cn, substring(blanks, 1, pad1))
      nm[i] <- paste(cn, collapse = "  ")
    }
    else {
      sms <- format(sms, digits = digits)
      lbs <- format(names(sms))
      sms <- paste0(lbs, ":", sms, "  ")
      lw[i] <- ncw(lbs[1])
      length(sms) <- nr
    }
    z[[i]] <- sms
  }
  if (nv) {
    z <- unlist(z, use.names = TRUE)
    dim(z) <- c(nr, nv)
    if (anyNA(lw)) 
      warning("probably wrong encoding in names(.) of column ", paste(which(is.na(lw)), collapse = ", "))
    blanks <- paste(character(max(lw, na.rm = TRUE) + 2), collapse = " ")
    pad <- floor(lw - ncw(nm)/2)
    nm <- paste0(substring(blanks, 1, pad), nm)
    dimnames(z) <- list(rep.int("", nr), nm)
  }
  else {
    z <- character()
    dim(z) <- c(nr, nv)
  }
  attr(z, "class") <- c("table")
  z
}, function (object, maxsum = 7, digits = max(3, getOption("digits") - 3), ...) 
{
  ncw <- function(x) {
    z <- nchar(x, type = "w", allowNA = TRUE)
    if (any(na <- is.na(z))) {
      z[na] <- nchar(encodeString(z[na]), "b")
    }
    z
  }
  z <- lapply(X = as.list(object), FUN = summary, maxsum = maxsum, digits = 12, ...)
  nv <- length(object)
  nm <- names(object)
  lw <- numeric(nv)
  nr <- if (nv) 
    max(vapply(z, function(x) NROW(x) + !is.null(attr(x, "NAs")), integer(1)))
  else 0
  for (i in seq_len(nv)) {
    sms <- z[[i]]
    if (is.matrix(sms)) {
      cn <- paste(nm[i], gsub("^ +", "", colnames(sms), useBytes = TRUE), sep = ".")
      tmp <- format(sms)
      if (nrow(sms) < nr) 
        tmp <- rbind(tmp, matrix("", nr - nrow(sms), ncol(sms)))
      sms <- apply(tmp, 1, function(x) paste(x, collapse = "  "))
      wid <- sapply(tmp[1, ], nchar, type = "w")
      blanks <- paste(character(max(wid)), collapse = " ")
      wcn <- ncw(cn)
      pad0 <- floor((wid - wcn)/2)
      pad1 <- wid - wcn - pad0
      cn <- paste0(substring(blanks, 1, pad0), cn, substring(blanks, 1, pad1))
      nm[i] <- paste(cn, collapse = "  ")
    }
    else {
      sms <- format(sms, digits = digits)
      lbs <- format(names(sms))
      sms <- paste0(lbs, ":", sms, "  ")
      lw[i] <- ncw(lbs[1])
      length(sms) <- nr
    }
    z[[i]] <- sms
  }
  if (nv) {
    z <- unlist(z, use.names = TRUE)
    dim(z) <- c(nr, nv)
    if (anyNA(lw)) 
      warning("probably wrong encoding in names(.) of column ", paste(which(is.na(lw)), collapse = ", "))
    blanks <- paste(character(max(lw, na.rm = TRUE) + 2), collapse = " ")
    pad <- floor(lw - ncw(nm)/2)
    nm <- paste0(substring(blanks, 1, pad), nm)
    dimnames(z) <- list(rep.int("", nr), nm)
  }
  else {
    z <- character()
    dim(z) <- c(nr, nv)
  }
  attr(z, "class") <- c("table")
  z
}, function (object, maxsum = 7, digits = max(3, getOption("digits") - 3), ...) 
{
  ncw <- function(x) {
    z <- nchar(x, type = "w", allowNA = TRUE)
    if (any(na <- is.na(z))) {
      z[na] <- nchar(encodeString(z[na]), "b")
    }
    z
  }
  z <- lapply(X = as.list(object), FUN = summary, maxsum = maxsum, digits = 12, ...)
  nv <- length(object)
  nm <- names(object)
  lw <- numeric(nv)
  nr <- if (nv) 
    max(vapply(z, function(x) NROW(x) + !is.null(attr(x, "NAs")), integer(1)))
  else 0
  for (i in seq_len(nv)) {
    sms <- z[[i]]
    if (is.matrix(sms)) {
      cn <- paste(nm[i], gsub("^ +", "", colnames(sms), useBytes = TRUE), sep = ".")
      tmp <- format(sms)
      if (nrow(sms) < nr) 
        tmp <- rbind(tmp, matrix("", nr - nrow(sms), ncol(sms)))
      sms <- apply(tmp, 1, function(x) paste(x, collapse = "  "))
      wid <- sapply(tmp[1, ], nchar, type = "w")
      blanks <- paste(character(max(wid)), collapse = " ")
      wcn <- ncw(cn)
      pad0 <- floor((wid - wcn)/2)
      pad1 <- wid - wcn - pad0
      cn <- paste0(substring(blanks, 1, pad0), cn, substring(blanks, 1, pad1))
      nm[i] <- paste(cn, collapse = "  ")
    }
    else {
      sms <- format(sms, digits = digits)
      lbs <- format(names(sms))
      sms <- paste0(lbs, ":", sms, "  ")
      lw[i] <- ncw(lbs[1])
      length(sms) <- nr
    }
    z[[i]] <- sms
  }
  if (nv) {
    z <- unlist(z, use.names = TRUE)
    dim(z) <- c(nr, nv)
    if (anyNA(lw)) 
      warning("probably wrong encoding in names(.) of column ", paste(which(is.na(lw)), collapse = ", "))
    blanks <- paste(character(max(lw, na.rm = TRUE) + 2), collapse = " ")
    pad <- floor(lw - ncw(nm)/2)
    nm <- paste0(substring(blanks, 1, pad), nm)
    dimnames(z) <- list(rep.int("", nr), nm)
  }
  else {
    z <- character()
    dim(z) <- c(nr, nv)
  }
  attr(z, "class") <- c("table")
  z
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Summary.data.frame
list(`package:base` = function (..., na.rm) 
{
  args <- list(...)
  args <- lapply(args, function(x) {
    x <- as.matrix(x)
    if (!is.numeric(x) && !is.logical(x) && !is.complex(x)) 
      stop("only defined on a data frame with all numeric-alike variables")
    x
  })
  do.call(.Generic, c(args, na.rm = na.rm))
}, function (..., na.rm) 
{
  args <- list(...)
  args <- lapply(args, function(x) {
    x <- as.matrix(x)
    if (!is.numeric(x) && !is.logical(x) && !is.complex(x)) 
      stop("only defined on a data frame with all numeric-alike variables")
    x
  })
  do.call(.Generic, c(args, na.rm = na.rm))
}, function (..., na.rm) 
{
  args <- list(...)
  args <- lapply(args, function(x) {
    x <- as.matrix(x)
    if (!is.numeric(x) && !is.logical(x) && !is.complex(x)) 
      stop("only defined on a data frame with all numeric-alike variables")
    x
  })
  do.call(.Generic, c(args, na.rm = na.rm))
})
c("package:base", "registered S3 method for Summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.Date
list(`package:base` = function (object, digits = 12, ...) 
{
  x <- summary.default(unclass(object), digits = digits, ...)
  if (m <- match("NA's", names(x), 0)) {
    NAs <- as.integer(x[m])
    x <- x[-m]
    attr(x, "NAs") <- NAs
  }
  .Date(x, c("summaryDefault", "table", oldClass(object)))
}, function (object, digits = 12, ...) 
{
  x <- summary.default(unclass(object), digits = digits, ...)
  if (m <- match("NA's", names(x), 0)) {
    NAs <- as.integer(x[m])
    x <- x[-m]
    attr(x, "NAs") <- NAs
  }
  .Date(x, c("summaryDefault", "table", oldClass(object)))
}, function (object, digits = 12, ...) 
{
  x <- summary.default(unclass(object), digits = digits, ...)
  if (m <- match("NA's", names(x), 0)) {
    NAs <- as.integer(x[m])
    x <- x[-m]
    attr(x, "NAs") <- NAs
  }
  .Date(x, c("summaryDefault", "table", oldClass(object)))
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Summary.Date
list(`package:base` = function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA)
  .Date(NextMethod(.Generic), oldClass(list(...)[[1]]))
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA)
  .Date(NextMethod(.Generic), oldClass(list(...)[[1]]))
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("%s not defined for \"Date\" objects", .Generic), domain = NA)
  .Date(NextMethod(.Generic), oldClass(list(...)[[1]]))
})
c("package:base", "registered S3 method for Summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.default
list(`package:base` = function (object, ..., digits, quantile.type = 7) 
{
  if (is.factor(object)) 
    return(summary.factor(object, ...))
  else if (is.matrix(object)) {
    if (missing(digits)) 
      return(summary.matrix(object, quantile.type = quantile.type, ...))
    else return(summary.matrix(object, digits = digits, quantile.type = quantile.type, ...))
  }
  value <- if (is.logical(object)) 
    c(Mode = "logical", {
      tb <- table(object, exclude = NULL, useNA = "ifany")
      if (!is.null(n <- dimnames(tb)[[1]]) && any(iN <- is.na(n))) dimnames(tb)[[1]][iN] <- "NA's"
      tb
    })
  else if (is.numeric(object)) {
    nas <- is.na(object)
    object <- object[!nas]
    qq <- stats::quantile(object, names = FALSE, type = quantile.type)
    qq <- c(qq[1:3], mean(object), qq[4:5])
    if (!missing(digits)) 
      qq <- signif(qq, digits)
    names(qq) <- c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.")
    if (any(nas)) 
      c(qq, `NA's` = sum(nas))
    else qq
  }
  else if (is.recursive(object) && !is.language(object) && (n <- length(object))) {
    sumry <- array("", c(n, 3), list(names(object), c("Length", "Class", "Mode")))
    ll <- numeric(n)
    for (i in 1:n) {
      ii <- object[[i]]
      ll[i] <- length(ii)
      cls <- oldClass(ii)
      sumry[i, 2] <- if (length(cls)) 
        cls[1]
      else "-none-"
      sumry[i, 3] <- mode(ii)
    }
    sumry[, 1] <- format(as.integer(ll))
    sumry
  }
  else c(Length = length(object), Class = class(object), Mode = mode(object))
  class(value) <- c("summaryDefault", "table")
  value
}, function (object, ..., digits, quantile.type = 7) 
{
  if (is.factor(object)) 
    return(summary.factor(object, ...))
  else if (is.matrix(object)) {
    if (missing(digits)) 
      return(summary.matrix(object, quantile.type = quantile.type, ...))
    else return(summary.matrix(object, digits = digits, quantile.type = quantile.type, ...))
  }
  value <- if (is.logical(object)) 
    c(Mode = "logical", {
      tb <- table(object, exclude = NULL, useNA = "ifany")
      if (!is.null(n <- dimnames(tb)[[1]]) && any(iN <- is.na(n))) dimnames(tb)[[1]][iN] <- "NA's"
      tb
    })
  else if (is.numeric(object)) {
    nas <- is.na(object)
    object <- object[!nas]
    qq <- stats::quantile(object, names = FALSE, type = quantile.type)
    qq <- c(qq[1:3], mean(object), qq[4:5])
    if (!missing(digits)) 
      qq <- signif(qq, digits)
    names(qq) <- c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.")
    if (any(nas)) 
      c(qq, `NA's` = sum(nas))
    else qq
  }
  else if (is.recursive(object) && !is.language(object) && (n <- length(object))) {
    sumry <- array("", c(n, 3), list(names(object), c("Length", "Class", "Mode")))
    ll <- numeric(n)
    for (i in 1:n) {
      ii <- object[[i]]
      ll[i] <- length(ii)
      cls <- oldClass(ii)
      sumry[i, 2] <- if (length(cls)) 
        cls[1]
      else "-none-"
      sumry[i, 3] <- mode(ii)
    }
    sumry[, 1] <- format(as.integer(ll))
    sumry
  }
  else c(Length = length(object), Class = class(object), Mode = mode(object))
  class(value) <- c("summaryDefault", "table")
  value
}, function (object, ..., digits, quantile.type = 7) 
{
  if (is.factor(object)) 
    return(summary.factor(object, ...))
  else if (is.matrix(object)) {
    if (missing(digits)) 
      return(summary.matrix(object, quantile.type = quantile.type, ...))
    else return(summary.matrix(object, digits = digits, quantile.type = quantile.type, ...))
  }
  value <- if (is.logical(object)) 
    c(Mode = "logical", {
      tb <- table(object, exclude = NULL, useNA = "ifany")
      if (!is.null(n <- dimnames(tb)[[1]]) && any(iN <- is.na(n))) dimnames(tb)[[1]][iN] <- "NA's"
      tb
    })
  else if (is.numeric(object)) {
    nas <- is.na(object)
    object <- object[!nas]
    qq <- stats::quantile(object, names = FALSE, type = quantile.type)
    qq <- c(qq[1:3], mean(object), qq[4:5])
    if (!missing(digits)) 
      qq <- signif(qq, digits)
    names(qq) <- c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.")
    if (any(nas)) 
      c(qq, `NA's` = sum(nas))
    else qq
  }
  else if (is.recursive(object) && !is.language(object) && (n <- length(object))) {
    sumry <- array("", c(n, 3), list(names(object), c("Length", "Class", "Mode")))
    ll <- numeric(n)
    for (i in 1:n) {
      ii <- object[[i]]
      ll[i] <- length(ii)
      cls <- oldClass(ii)
      sumry[i, 2] <- if (length(cls)) 
        cls[1]
      else "-none-"
      sumry[i, 3] <- mode(ii)
    }
    sumry[, 1] <- format(as.integer(ll))
    sumry
  }
  else c(Length = length(object), Class = class(object), Mode = mode(object))
  class(value) <- c("summaryDefault", "table")
  value
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Summary.difftime
list(`package:base` = function (..., na.rm) 
{
  coerceTimeUnit <- function(x) {
    as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
  }
  ok <- switch(.Generic, max = , min = , sum = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA)
  x <- list(...)
  Nargs <- length(x)
  if (Nargs == 0) {
    .difftime(do.call(.Generic), "secs")
  }
  else {
    units <- sapply(x, attr, "units")
    if (all(units == units[1])) {
      args <- c(lapply(x, as.vector), na.rm = na.rm)
    }
    else {
      args <- c(lapply(x, coerceTimeUnit), na.rm = na.rm)
      units <- "secs"
    }
    .difftime(do.call(.Generic, args), units[[1]])
  }
}, function (..., na.rm) 
{
  coerceTimeUnit <- function(x) {
    as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
  }
  ok <- switch(.Generic, max = , min = , sum = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA)
  x <- list(...)
  Nargs <- length(x)
  if (Nargs == 0) {
    .difftime(do.call(.Generic), "secs")
  }
  else {
    units <- sapply(x, attr, "units")
    if (all(units == units[1])) {
      args <- c(lapply(x, as.vector), na.rm = na.rm)
    }
    else {
      args <- c(lapply(x, coerceTimeUnit), na.rm = na.rm)
      units <- "secs"
    }
    .difftime(do.call(.Generic, args), units[[1]])
  }
}, function (..., na.rm) 
{
  coerceTimeUnit <- function(x) {
    as.vector(switch(attr(x, "units"), secs = x, mins = 60 * x, hours = 60 * 60 * x, days = 60 * 60 * 24 * x, weeks = 60 * 60 * 24 * 7 * x))
  }
  ok <- switch(.Generic, max = , min = , sum = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"difftime\" objects", .Generic), domain = NA)
  x <- list(...)
  Nargs <- length(x)
  if (Nargs == 0) {
    .difftime(do.call(.Generic), "secs")
  }
  else {
    units <- sapply(x, attr, "units")
    if (all(units == units[1])) {
      args <- c(lapply(x, as.vector), na.rm = na.rm)
    }
    else {
      args <- c(lapply(x, coerceTimeUnit), na.rm = na.rm)
      units <- "secs"
    }
    .difftime(do.call(.Generic, args), units[[1]])
  }
})
c("package:base", "registered S3 method for Summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.factor
list(`package:base` = function (object, maxsum = 100, ...) 
{
  nas <- is.na(object)
  ll <- levels(object)
  if (ana <- any(nas)) 
    maxsum <- maxsum - 1
  tbl <- table(object)
  tt <- c(tbl)
  names(tt) <- dimnames(tbl)[[1]]
  if (length(ll) > maxsum) {
    drop <- maxsum:length(ll)
    o <- sort.list(tt, decreasing = TRUE)
    tt <- c(tt[o[-drop]], `(Other)` = sum(tt[o[drop]]))
  }
  if (ana) 
    c(tt, `NA's` = sum(nas))
  else tt
}, function (object, maxsum = 100, ...) 
{
  nas <- is.na(object)
  ll <- levels(object)
  if (ana <- any(nas)) 
    maxsum <- maxsum - 1
  tbl <- table(object)
  tt <- c(tbl)
  names(tt) <- dimnames(tbl)[[1]]
  if (length(ll) > maxsum) {
    drop <- maxsum:length(ll)
    o <- sort.list(tt, decreasing = TRUE)
    tt <- c(tt[o[-drop]], `(Other)` = sum(tt[o[drop]]))
  }
  if (ana) 
    c(tt, `NA's` = sum(nas))
  else tt
}, function (object, maxsum = 100, ...) 
{
  nas <- is.na(object)
  ll <- levels(object)
  if (ana <- any(nas)) 
    maxsum <- maxsum - 1
  tbl <- table(object)
  tt <- c(tbl)
  names(tt) <- dimnames(tbl)[[1]]
  if (length(ll) > maxsum) {
    drop <- maxsum:length(ll)
    o <- sort.list(tt, decreasing = TRUE)
    tt <- c(tt[o[-drop]], `(Other)` = sum(tt[o[drop]]))
  }
  if (ana) 
    c(tt, `NA's` = sum(nas))
  else tt
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Summary.factor
list(`package:base` = function (..., na.rm) 
  stop(gettextf("%s not meaningful for factors", sQuote(.Generic))), function (..., na.rm) 
    stop(gettextf("%s not meaningful for factors", sQuote(.Generic))), function (..., na.rm) 
      stop(gettextf("%s not meaningful for factors", sQuote(.Generic))))
c("package:base", "registered S3 method for Summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.matrix
list(`package:base` = function (object, ...) 
{
  summary.data.frame(as.data.frame.matrix(object), ...)
}, function (object, ...) 
{
  summary.data.frame(as.data.frame.matrix(object), ...)
}, function (object, ...) 
{
  summary.data.frame(as.data.frame.matrix(object), ...)
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Summary.numeric_version
list(`package:base` = function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("%s not defined for \"numeric_version\" objects", .Generic), domain = NA)
  x <- do.call(c, lapply(list(...), as.numeric_version))
  v <- xtfrm(x)
  if (!na.rm && length(pos <- which(is.na(v)))) {
    y <- x[pos[1]]
    if (as.character(.Generic) == "range") 
      c(y, y)
    else y
  }
  else switch(.Generic, max = x[which.max(v)], min = x[which.min(v)], range = x[c(which.min(v), which.max(v))])
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("%s not defined for \"numeric_version\" objects", .Generic), domain = NA)
  x <- do.call(c, lapply(list(...), as.numeric_version))
  v <- xtfrm(x)
  if (!na.rm && length(pos <- which(is.na(v)))) {
    y <- x[pos[1]]
    if (as.character(.Generic) == "range") 
      c(y, y)
    else y
  }
  else switch(.Generic, max = x[which.max(v)], min = x[which.min(v)], range = x[c(which.min(v), which.max(v))])
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("%s not defined for \"numeric_version\" objects", .Generic), domain = NA)
  x <- do.call(c, lapply(list(...), as.numeric_version))
  v <- xtfrm(x)
  if (!na.rm && length(pos <- which(is.na(v)))) {
    y <- x[pos[1]]
    if (as.character(.Generic) == "range") 
      c(y, y)
    else y
  }
  else switch(.Generic, max = x[which.max(v)], min = x[which.min(v)], range = x[c(which.min(v), which.max(v))])
})
c("package:base", "registered S3 method for Summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Summary.ordered
list(`package:base` = function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for ordered factors", .Generic), domain = NA)
  args <- list(...)
  levl <- lapply(args, levels)
  levset <- levl[[1]]
  if (!all(vapply(args, is.ordered, NA)) || !all(vapply(levl, identical, NA, levset))) 
    stop(gettextf("'%s' is only meaningful for ordered factors if all arguments have the same level sets", .Generic))
  codes <- lapply(args, as.integer)
  ind <- do.call(.Generic, c(codes, na.rm = na.rm))
  ordered(levset[ind], levels = levset)
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for ordered factors", .Generic), domain = NA)
  args <- list(...)
  levl <- lapply(args, levels)
  levset <- levl[[1]]
  if (!all(vapply(args, is.ordered, NA)) || !all(vapply(levl, identical, NA, levset))) 
    stop(gettextf("'%s' is only meaningful for ordered factors if all arguments have the same level sets", .Generic))
  codes <- lapply(args, as.integer)
  ind <- do.call(.Generic, c(codes, na.rm = na.rm))
  ordered(levset[ind], levels = levset)
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for ordered factors", .Generic), domain = NA)
  args <- list(...)
  levl <- lapply(args, levels)
  levset <- levl[[1]]
  if (!all(vapply(args, is.ordered, NA)) || !all(vapply(levl, identical, NA, levset))) 
    stop(gettextf("'%s' is only meaningful for ordered factors if all arguments have the same level sets", .Generic))
  codes <- lapply(args, as.integer)
  ind <- do.call(.Generic, c(codes, na.rm = na.rm))
  ordered(levset[ind], levels = levset)
})
c("package:base", "registered S3 method for Summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.POSIXct
list(`package:base` = function (object, digits = 15, ...) 
{
  x <- summary.default(unclass(object), digits = digits, ...)
  if (m <- match("NA's", names(x), 0)) {
    NAs <- as.integer(x[m])
    x <- x[-m]
    attr(x, "NAs") <- NAs
  }
  .POSIXct(x, tz = attr(object, "tzone"), cl = c("summaryDefault", "table", oldClass(object)))
}, function (object, digits = 15, ...) 
{
  x <- summary.default(unclass(object), digits = digits, ...)
  if (m <- match("NA's", names(x), 0)) {
    NAs <- as.integer(x[m])
    x <- x[-m]
    attr(x, "NAs") <- NAs
  }
  .POSIXct(x, tz = attr(object, "tzone"), cl = c("summaryDefault", "table", oldClass(object)))
}, function (object, digits = 15, ...) 
{
  x <- summary.default(unclass(object), digits = digits, ...)
  if (m <- match("NA's", names(x), 0)) {
    NAs <- as.integer(x[m])
    x <- x[-m]
    attr(x, "NAs") <- NAs
  }
  .POSIXct(x, tz = attr(object, "tzone"), cl = c("summaryDefault", "table", oldClass(object)))
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Summary.POSIXct
list(`package:base` = function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  args <- list(...)
  tz <- do.call(check_tzones, args)
  .POSIXct(NextMethod(.Generic), tz = tz, cl = oldClass(args[[1]]))
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  args <- list(...)
  tz <- do.call(check_tzones, args)
  .POSIXct(NextMethod(.Generic), tz = tz, cl = oldClass(args[[1]]))
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  args <- list(...)
  tz <- do.call(check_tzones, args)
  .POSIXct(NextMethod(.Generic), tz = tz, cl = oldClass(args[[1]]))
})
c("package:base", "registered S3 method for Summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.POSIXlt
list(`package:base` = function (object, digits = 15, ...) 
  summary(as.POSIXct(object), digits = digits, ...), function (object, digits = 15, ...) 
    summary(as.POSIXct(object), digits = digits, ...), function (object, digits = 15, ...) 
      summary(as.POSIXct(object), digits = digits, ...))
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
Summary.POSIXlt
list(`package:base` = function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  args <- list(...)
  tz <- do.call(check_tzones, args)
  args <- lapply(args, as.POSIXct)
  val <- do.call(.Generic, c(args, na.rm = na.rm))
  as.POSIXlt(.POSIXct(val, tz))
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  args <- list(...)
  tz <- do.call(check_tzones, args)
  args <- lapply(args, as.POSIXct)
  val <- do.call(.Generic, c(args, na.rm = na.rm))
  as.POSIXlt(.POSIXct(val, tz))
}, function (..., na.rm) 
{
  ok <- switch(.Generic, max = , min = , range = TRUE, FALSE)
  if (!ok) 
    stop(gettextf("'%s' not defined for \"POSIXt\" objects", .Generic), domain = NA)
  args <- list(...)
  tz <- do.call(check_tzones, args)
  args <- lapply(args, as.POSIXct)
  val <- do.call(.Generic, c(args, na.rm = na.rm))
  as.POSIXlt(.POSIXct(val, tz))
})
c("package:base", "registered S3 method for Summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.proc_time
list(`package:base` = function (object, ...) 
{
  if (!is.na(object[4])) 
    object[1] <- object[1] + object[4]
  if (!is.na(object[5])) 
    object[2] <- object[2] + object[5]
  object <- object[1:3]
  names(object) <- c(gettext("user"), gettext("system"), gettext("elapsed"))
  object
}, function (object, ...) 
{
  if (!is.na(object[4])) 
    object[1] <- object[1] + object[4]
  if (!is.na(object[5])) 
    object[2] <- object[2] + object[5]
  object <- object[1:3]
  names(object) <- c(gettext("user"), gettext("system"), gettext("elapsed"))
  object
}, function (object, ...) 
{
  if (!is.na(object[4])) 
    object[1] <- object[1] + object[4]
  if (!is.na(object[5])) 
    object[2] <- object[2] + object[5]
  object <- object[1:3]
  names(object) <- c(gettext("user"), gettext("system"), gettext("elapsed"))
  object
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.srcfile
list(`package:base` = function (object, ...) 
{
  cat(utils:::.normalizePath(object$filename, object$wd), "\n")
  if (inherits(object$timestamp, "POSIXt")) 
    cat("Timestamp: ", format(object$timestamp, usetz = TRUE), "\n", sep = "")
  cat("Encoding: \"", object$encoding, "\"", sep = "")
  if (!is.null(object$Enc) && object$Enc != object$encoding && object$Enc != "unknown") 
    cat(", re-encoded to \"", object$Enc, "\"", sep = "")
  cat("\n")
  invisible(object)
}, function (object, ...) 
{
  cat(utils:::.normalizePath(object$filename, object$wd), "\n")
  if (inherits(object$timestamp, "POSIXt")) 
    cat("Timestamp: ", format(object$timestamp, usetz = TRUE), "\n", sep = "")
  cat("Encoding: \"", object$encoding, "\"", sep = "")
  if (!is.null(object$Enc) && object$Enc != object$encoding && object$Enc != "unknown") 
    cat(", re-encoded to \"", object$Enc, "\"", sep = "")
  cat("\n")
  invisible(object)
}, function (object, ...) 
{
  cat(utils:::.normalizePath(object$filename, object$wd), "\n")
  if (inherits(object$timestamp, "POSIXt")) 
    cat("Timestamp: ", format(object$timestamp, usetz = TRUE), "\n", sep = "")
  cat("Encoding: \"", object$encoding, "\"", sep = "")
  if (!is.null(object$Enc) && object$Enc != object$encoding && object$Enc != "unknown") 
    cat(", re-encoded to \"", object$Enc, "\"", sep = "")
  cat("\n")
  invisible(object)
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.srcref
list(`package:base` = function (object, useSource = FALSE, ...) 
{
  cat(as.character(object, useSource = useSource), sep = "\n")
  invisible(object)
}, function (object, useSource = FALSE, ...) 
{
  cat(as.character(object, useSource = useSource), sep = "\n")
  invisible(object)
}, function (object, useSource = FALSE, ...) 
{
  cat(as.character(object, useSource = useSource), sep = "\n")
  invisible(object)
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.table
list(`package:base` = function (object, ...) 
{
  if (!inherits(object, "table")) 
    stop(gettextf("'object' must inherit from class %s", dQuote("table")), domain = NA)
  n.cases <- sum(object)
  n.vars <- length(dim(object))
  y <- list(n.vars = n.vars, n.cases = n.cases)
  if (n.vars > 1) {
    m <- vector("list", length = n.vars)
    relFreqs <- object/n.cases
    for (k in 1:n.vars) m[[k]] <- apply(relFreqs, k, sum)
    expected <- apply(do.call("expand.grid", m), 1, prod) * n.cases
    statistic <- sum((c(object) - expected)^2/expected)
    lm <- lengths(m)
    parameter <- prod(lm) - 1 - sum(lm - 1)
    y <- c(y, list(statistic = statistic, parameter = parameter, approx.ok = all(expected >= 5), p.value = stats::pchisq(statistic, parameter, lower.tail = FALSE), call = attr(object, "call")))
  }
  class(y) <- "summary.table"
  y
}, function (object, ...) 
{
  if (!inherits(object, "table")) 
    stop(gettextf("'object' must inherit from class %s", dQuote("table")), domain = NA)
  n.cases <- sum(object)
  n.vars <- length(dim(object))
  y <- list(n.vars = n.vars, n.cases = n.cases)
  if (n.vars > 1) {
    m <- vector("list", length = n.vars)
    relFreqs <- object/n.cases
    for (k in 1:n.vars) m[[k]] <- apply(relFreqs, k, sum)
    expected <- apply(do.call("expand.grid", m), 1, prod) * n.cases
    statistic <- sum((c(object) - expected)^2/expected)
    lm <- lengths(m)
    parameter <- prod(lm) - 1 - sum(lm - 1)
    y <- c(y, list(statistic = statistic, parameter = parameter, approx.ok = all(expected >= 5), p.value = stats::pchisq(statistic, parameter, lower.tail = FALSE), call = attr(object, "call")))
  }
  class(y) <- "summary.table"
  y
}, function (object, ...) 
{
  if (!inherits(object, "table")) 
    stop(gettextf("'object' must inherit from class %s", dQuote("table")), domain = NA)
  n.cases <- sum(object)
  n.vars <- length(dim(object))
  y <- list(n.vars = n.vars, n.cases = n.cases)
  if (n.vars > 1) {
    m <- vector("list", length = n.vars)
    relFreqs <- object/n.cases
    for (k in 1:n.vars) m[[k]] <- apply(relFreqs, k, sum)
    expected <- apply(do.call("expand.grid", m), 1, prod) * n.cases
    statistic <- sum((c(object) - expected)^2/expected)
    lm <- lengths(m)
    parameter <- prod(lm) - 1 - sum(lm - 1)
    y <- c(y, list(statistic = statistic, parameter = parameter, approx.ok = all(expected >= 5), p.value = stats::pchisq(statistic, parameter, lower.tail = FALSE), call = attr(object, "call")))
  }
  class(y) <- "summary.table"
  y
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.warnings
list(`package:base` = function (object, ...) 
{
  msgs <- names(object)
  calls <- as.character(object)
  ss <- " |<:>| "
  c.m. <- paste(calls, msgs, sep = ss)
  if (length(i.no.call <- which(calls == "NULL"))) 
    c.m.[i.no.call] <- substr(c.m.[i.no.call], nchar(paste0("NULL", ss)) + 1, 100000)
  i.uniq <- which(!duplicated(object, incomparables = FALSE))
  tm <- table(factor(c.m., levels = c.m.[i.uniq]), deparse.level = 0)
  structure(object[i.uniq], counts = as.vector(tm), class = "summary.warnings")
}, function (object, ...) 
{
  msgs <- names(object)
  calls <- as.character(object)
  ss <- " |<:>| "
  c.m. <- paste(calls, msgs, sep = ss)
  if (length(i.no.call <- which(calls == "NULL"))) 
    c.m.[i.no.call] <- substr(c.m.[i.no.call], nchar(paste0("NULL", ss)) + 1, 100000)
  i.uniq <- which(!duplicated(object, incomparables = FALSE))
  tm <- table(factor(c.m., levels = c.m.[i.uniq]), deparse.level = 0)
  structure(object[i.uniq], counts = as.vector(tm), class = "summary.warnings")
}, function (object, ...) 
{
  msgs <- names(object)
  calls <- as.character(object)
  ss <- " |<:>| "
  c.m. <- paste(calls, msgs, sep = ss)
  if (length(i.no.call <- which(calls == "NULL"))) 
    c.m.[i.no.call] <- substr(c.m.[i.no.call], nchar(paste0("NULL", ss)) + 1, 100000)
  i.uniq <- which(!duplicated(object, incomparables = FALSE))
  tm <- table(factor(c.m., levels = c.m.[i.uniq]), deparse.level = 0)
  structure(object[i.uniq], counts = as.vector(tm), class = "summary.warnings")
})
c("package:base", "registered S3 method for summary from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
suppressMessages
list(`package:base` = function (expr, classes = "message") 
  withCallingHandlers(expr, message = function(c) if (inherits(c, classes)) tryInvokeRestart("muffleMessage")), function (expr, classes = "message") 
    withCallingHandlers(expr, message = function(c) if (inherits(c, classes)) tryInvokeRestart("muffleMessage")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
suppressPackageStartupMessages
list(`package:base` = function (expr) 
  withCallingHandlers(expr, packageStartupMessage = function(c) tryInvokeRestart("muffleMessage")), function (expr) 
    withCallingHandlers(expr, packageStartupMessage = function(c) tryInvokeRestart("muffleMessage")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
suppressWarnings
list(`package:base` = function (expr, classes = "warning") 
{
  withCallingHandlers(expr, warning = function(w) if (inherits(w, classes)) 
    tryInvokeRestart("muffleWarning"))
}, function (expr, classes = "warning") 
{
  withCallingHandlers(expr, warning = function(w) if (inherits(w, classes)) 
    tryInvokeRestart("muffleWarning"))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
suspendInterrupts
list(`package:base` = function (expr) 
{
  suspended <- .Internal(interruptsSuspended())
  if (suspended) 
    expr
  else {
    on.exit(.Internal(interruptsSuspended(suspended)))
    .Internal(interruptsSuspended(TRUE))
    expr
  }
}, function (expr) 
{
  suspended <- .Internal(interruptsSuspended())
  if (suspended) 
    expr
  else {
    on.exit(.Internal(interruptsSuspended(suspended)))
    .Internal(interruptsSuspended(TRUE))
    expr
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
svd
list(`package:base` = function (x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  x <- as.matrix(x)
  if (any(!is.finite(x))) 
    stop("infinite or missing values in 'x'")
  dx <- dim(x)
  n <- dx[1]
  p <- dx[2]
  if (!n || !p) 
    stop("a dimension is zero")
  La.res <- La.svd(x, nu, nv)
  res <- list(d = La.res$d)
  if (nu) 
    res$u <- La.res$u
  if (nv) {
    if (is.complex(x)) 
      res$v <- Conj(t(La.res$vt))
    else res$v <- t(La.res$vt)
  }
  res
}, function (x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE) 
{
  if (!missing(LINPACK)) 
    stop("the LINPACK argument has been defunct since R 3.1.0")
  x <- as.matrix(x)
  if (any(!is.finite(x))) 
    stop("infinite or missing values in 'x'")
  dx <- dim(x)
  n <- dx[1]
  p <- dx[2]
  if (!n || !p) 
    stop("a dimension is zero")
  La.res <- La.svd(x, nu, nv)
  res <- list(d = La.res$d)
  if (nu) 
    res$u <- La.res$u
  if (nv) {
    if (is.complex(x)) 
      res$v <- Conj(t(La.res$vt))
    else res$v <- t(La.res$vt)
  }
  res
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sweep
list(`package:base` = function (x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...) 
{
  FUN <- match.fun(FUN)
  dims <- dim(x)
  if (is.character(MARGIN)) {
    dn <- dimnames(x)
    if (is.null(dnn <- names(dn))) 
      stop("'x' must have named dimnames")
    MARGIN <- match(MARGIN, dnn)
    if (anyNA(MARGIN)) 
      stop("not all elements of 'MARGIN' are names of dimensions")
  }
  if (check.margin) {
    dimmargin <- dims[MARGIN]
    dimstats <- dim(STATS)
    lstats <- length(STATS)
    if (lstats > prod(dimmargin)) {
      warning("STATS is longer than the extent of 'dim(x)[MARGIN]'")
    }
    else if (is.null(dimstats)) {
      cumDim <- c(1, cumprod(dimmargin))
      upper <- min(cumDim[cumDim >= lstats])
      lower <- max(cumDim[cumDim <= lstats])
      if (lstats && (upper%%lstats != 0 || lstats%%lower != 0)) 
        warning("STATS does not recycle exactly across MARGIN")
    }
    else {
      dimmargin <- dimmargin[dimmargin > 1]
      dimstats <- dimstats[dimstats > 1]
      if (length(dimstats) != length(dimmargin) || any(dimstats != dimmargin)) 
        warning("length(STATS) or dim(STATS) do not match dim(x)[MARGIN]")
    }
  }
  perm <- c(MARGIN, seq_along(dims)[-MARGIN])
  FUN(x, aperm(array(STATS, dims[perm]), order(perm)), ...)
}, function (x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...) 
{
  FUN <- match.fun(FUN)
  dims <- dim(x)
  if (is.character(MARGIN)) {
    dn <- dimnames(x)
    if (is.null(dnn <- names(dn))) 
      stop("'x' must have named dimnames")
    MARGIN <- match(MARGIN, dnn)
    if (anyNA(MARGIN)) 
      stop("not all elements of 'MARGIN' are names of dimensions")
  }
  if (check.margin) {
    dimmargin <- dims[MARGIN]
    dimstats <- dim(STATS)
    lstats <- length(STATS)
    if (lstats > prod(dimmargin)) {
      warning("STATS is longer than the extent of 'dim(x)[MARGIN]'")
    }
    else if (is.null(dimstats)) {
      cumDim <- c(1, cumprod(dimmargin))
      upper <- min(cumDim[cumDim >= lstats])
      lower <- max(cumDim[cumDim <= lstats])
      if (lstats && (upper%%lstats != 0 || lstats%%lower != 0)) 
        warning("STATS does not recycle exactly across MARGIN")
    }
    else {
      dimmargin <- dimmargin[dimmargin > 1]
      dimstats <- dimstats[dimstats > 1]
      if (length(dimstats) != length(dimmargin) || any(dimstats != dimmargin)) 
        warning("length(STATS) or dim(STATS) do not match dim(x)[MARGIN]")
    }
  }
  perm <- c(MARGIN, seq_along(dims)[-MARGIN])
  FUN(x, aperm(array(STATS, dims[perm]), order(perm)), ...)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
switch
list(`package:base` = .Primitive("switch"), .Primitive("switch"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.call
list(`package:base` = function (which = 0) 
  .Internal(sys.call(which)), function (which = 0) 
    .Internal(sys.call(which)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.calls
list(`package:base` = function () 
  .Internal(sys.calls()), function () 
    .Internal(sys.calls()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.chmod
list(`package:base` = function (paths, mode = "0777", use_umask = TRUE) 
  .Internal(Sys.chmod(paths, as.octmode(mode), use_umask)), function (paths, mode = "0777", use_umask = TRUE) 
    .Internal(Sys.chmod(paths, as.octmode(mode), use_umask)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.Date
list(`package:base` = function () 
  as.Date(as.POSIXlt(Sys.time())), function () 
    as.Date(as.POSIXlt(Sys.time())))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.frame
list(`package:base` = function (which = 0) 
  .Internal(sys.frame(which)), function (which = 0) 
    .Internal(sys.frame(which)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.frames
list(`package:base` = function () 
  .Internal(sys.frames()), function () 
    .Internal(sys.frames()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.function
list(`package:base` = function (which = 0) 
  .Internal(sys.function(which)), function (which = 0) 
    .Internal(sys.function(which)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.getenv
list(`package:base` = function (x = NULL, unset = "", names = NA) 
{
  if (is.null(x)) {
    x <- .Internal(Sys.getenv(character(), ""))
    m <- regexpr("=", x, fixed = TRUE)
    n <- substring(x, 1, m - 1)
    v <- substring(x, m + 1)
    if (isFALSE(names)) 
      v[sort.list(n)]
    else {
      v <- structure(v, names = n)
      structure(class = "Dlist", v[sort.list(n)])
    }
  }
  else {
    v <- .Internal(Sys.getenv(as.character(x), as.character(unset)))
    if (isTRUE(names) || (length(x) > 1 && !isFALSE(names))) 
      structure(v, names = x)
    else v
  }
}, function (x = NULL, unset = "", names = NA) 
{
  if (is.null(x)) {
    x <- .Internal(Sys.getenv(character(), ""))
    m <- regexpr("=", x, fixed = TRUE)
    n <- substring(x, 1, m - 1)
    v <- substring(x, m + 1)
    if (isFALSE(names)) 
      v[sort.list(n)]
    else {
      v <- structure(v, names = n)
      structure(class = "Dlist", v[sort.list(n)])
    }
  }
  else {
    v <- .Internal(Sys.getenv(as.character(x), as.character(unset)))
    if (isTRUE(names) || (length(x) > 1 && !isFALSE(names))) 
      structure(v, names = x)
    else v
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.getlocale
list(`package:base` = function (category = "LC_ALL") 
{
  category <- match(category, .LC.categories)
  if (is.na(category)) 
    stop("invalid 'category' argument")
  .Internal(Sys.getlocale(category))
}, function (category = "LC_ALL") 
{
  category <- match(category, .LC.categories)
  if (is.na(category)) 
    stop("invalid 'category' argument")
  .Internal(Sys.getlocale(category))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.getpid
list(`package:base` = function () 
  .Internal(Sys.getpid()), function () 
    .Internal(Sys.getpid()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.glob
list(`package:base` = function (paths, dirmark = FALSE) 
  .Internal(Sys.glob(path.expand(paths), dirmark)), function (paths, dirmark = FALSE) 
    .Internal(Sys.glob(path.expand(paths), dirmark)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.info
list(`package:base` = function () 
  .Internal(Sys.info()), function () 
    .Internal(Sys.info()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.junction
list(`package:base` = function (from, to) 
{
  if (!(nf <- length(from))) 
    return(logical())
  if (!(nt <- length(to))) 
    stop("no files to link to")
  if (nt == 1 && dir.exists(to)) 
    to <- file.path(to, basename(from))
  else if (nf > nt) 
    stop("more 'from' files than 'to' files")
  else if (nf < nt) 
    stop("fewer 'from' files than 'to' files")
  okay <- rep(FALSE, nf)
  for (i in seq_len(nf)) {
    fr <- paste0("\\??\\", normalizePath(from[i]))
    link <- to[i]
    if (file.exists(link)) {
      warning(gettextf("link '%s' already exists", link), domain = NA)
      next
    }
    if (!dir.create(link, showWarnings = FALSE)) {
      warning(gettextf("failed to create directory for link '%s", link), domain = NA)
      next
    }
    if (.Internal(mkjunction(fr, link))) 
      okay[i] <- TRUE
  }
  okay
}, function (from, to) 
{
  if (!(nf <- length(from))) 
    return(logical())
  if (!(nt <- length(to))) 
    stop("no files to link to")
  if (nt == 1 && dir.exists(to)) 
    to <- file.path(to, basename(from))
  else if (nf > nt) 
    stop("more 'from' files than 'to' files")
  else if (nf < nt) 
    stop("fewer 'from' files than 'to' files")
  okay <- rep(FALSE, nf)
  for (i in seq_len(nf)) {
    fr <- paste0("\\??\\", normalizePath(from[i]))
    link <- to[i]
    if (file.exists(link)) {
      warning(gettextf("link '%s' already exists", link), domain = NA)
      next
    }
    if (!dir.create(link, showWarnings = FALSE)) {
      warning(gettextf("failed to create directory for link '%s", link), domain = NA)
      next
    }
    if (.Internal(mkjunction(fr, link))) 
      okay[i] <- TRUE
  }
  okay
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.load.image
list(`package:base` = function (name, quiet) 
{
  if (file.exists(name)) {
    load(name, envir = .GlobalEnv)
    if (!quiet) 
      message("[Previously saved workspace restored]", "\n")
  }
}, function (name, quiet) 
{
  if (file.exists(name)) {
    load(name, envir = .GlobalEnv)
    if (!quiet) 
      message("[Previously saved workspace restored]", "\n")
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.localeconv
list(`package:base` = function () 
  .Internal(Sys.localeconv()), function () 
    .Internal(Sys.localeconv()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.nframe
list(`package:base` = function () 
  .Internal(sys.nframe()), function () 
    .Internal(sys.nframe()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.on.exit
list(`package:base` = function () 
  .Internal(sys.on.exit()), function () 
    .Internal(sys.on.exit()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.parent
list(`package:base` = function (n = 1) 
  .Internal(sys.parent(n)), function (n = 1) 
    .Internal(sys.parent(n)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.parents
list(`package:base` = function () 
  .Internal(sys.parents()), function () 
    .Internal(sys.parents()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.readlink
list(`package:base` = function (paths) 
  .Internal(Sys.readlink(paths)), function (paths) 
    .Internal(Sys.readlink(paths)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.save.image
list(`package:base` = function (name) 
{
  closeAllConnections()
  save.image(name)
}, function (name) 
{
  closeAllConnections()
  save.image(name)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.setenv
list(`package:base` = function (...) 
{
  x <- list(...)
  nm <- names(x)
  if (is.null(nm) || "" %in% nm) 
    stop("all arguments must be named")
  .Internal(Sys.setenv(nm, as.character(unlist(x))))
}, function (...) 
{
  x <- list(...)
  nm <- names(x)
  if (is.null(nm) || "" %in% nm) 
    stop("all arguments must be named")
  .Internal(Sys.setenv(nm, as.character(unlist(x))))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.setFileTime
list(`package:base` = function (path, time) 
{
  if (!is.character(path)) 
    stop("invalid 'path' argument")
  time <- as.POSIXct(time)
  if (anyNA(time)) 
    stop("invalid 'time' argument")
  .Internal(setFileTime(path, time))
}, function (path, time) 
{
  if (!is.character(path)) 
    stop("invalid 'path' argument")
  time <- as.POSIXct(time)
  if (anyNA(time)) 
    stop("invalid 'time' argument")
  .Internal(setFileTime(path, time))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.setLanguage
list(`package:base` = function (lang, unset = "en") 
{
  stopifnot(is.character(lang), length(lang) == 1, lang == "C" || grepl("^[a-z][a-z]", lang))
  curLang <- Sys.getenv("LANGUAGE", unset = NA)
  if (is.na(curLang) || !nzchar(curLang)) 
    curLang <- unset
  ok <- Sys.setenv(LANGUAGE = lang)
  if (!ok) 
    warning(gettextf("Sys.setenv(LANGUAGE=\"%s\") may have failed", lang), domain = NA)
  ok. <- capabilities("NLS") && isTRUE(bindtextdomain(NULL))
  invisible(structure(curLang, ok = ok && ok.))
}, function (lang, unset = "en") 
{
  stopifnot(is.character(lang), length(lang) == 1, lang == "C" || grepl("^[a-z][a-z]", lang))
  curLang <- Sys.getenv("LANGUAGE", unset = NA)
  if (is.na(curLang) || !nzchar(curLang)) 
    curLang <- unset
  ok <- Sys.setenv(LANGUAGE = lang)
  if (!ok) 
    warning(gettextf("Sys.setenv(LANGUAGE=\"%s\") may have failed", lang), domain = NA)
  ok. <- capabilities("NLS") && isTRUE(bindtextdomain(NULL))
  invisible(structure(curLang, ok = ok && ok.))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.setlocale
list(`package:base` = function (category = "LC_ALL", locale = "") 
{
  category <- match(category, .LC.categories)
  if (is.na(category)) 
    stop("invalid 'category' argument")
  .Internal(Sys.setlocale(category, locale))
}, function (category = "LC_ALL", locale = "") 
{
  category <- match(category, .LC.categories)
  if (is.na(category)) 
    stop("invalid 'category' argument")
  .Internal(Sys.setlocale(category, locale))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.sleep
list(`package:base` = function (time) 
  .Internal(Sys.sleep(time)), function (time) 
    .Internal(Sys.sleep(time)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.source
list(`package:base` = function (file, envir = baseenv(), chdir = FALSE, keep.source = getOption("keep.source.pkgs"), keep.parse.data = getOption("keep.parse.data.pkgs"), toplevel.env = as.environment(envir)) 
{
  if (!(is.character(file) && file.exists(file))) 
    stop(gettextf("'%s' is not an existing file", file))
  keep.source <- as.logical(keep.source)
  keep.parse.data <- as.logical(keep.parse.data)
  oop <- options(keep.source = keep.source, keep.parse.data = keep.parse.data, topLevelEnvironment = toplevel.env)
  on.exit(options(oop))
  if (keep.source) {
    lines <- readLines(file, warn = FALSE)
    srcfile <- srcfilecopy(file, lines, file.mtime(file), isFile = TRUE)
    exprs <- parse(text = lines, srcfile = srcfile, keep.source = TRUE)
  }
  else exprs <- parse(n = -1, file = file, srcfile = NULL, keep.source = FALSE)
  if (length(exprs) == 0) 
    return(invisible())
  if (chdir && (path <- dirname(file)) != ".") {
    owd <- getwd()
    if (is.null(owd)) 
      stop("cannot 'chdir' as current directory is unknown")
    on.exit(setwd(owd), add = TRUE)
    setwd(path)
  }
  for (i in seq_along(exprs)) eval(exprs[i], envir)
  invisible()
}, function (file, envir = baseenv(), chdir = FALSE, keep.source = getOption("keep.source.pkgs"), keep.parse.data = getOption("keep.parse.data.pkgs"), toplevel.env = as.environment(envir)) 
{
  if (!(is.character(file) && file.exists(file))) 
    stop(gettextf("'%s' is not an existing file", file))
  keep.source <- as.logical(keep.source)
  keep.parse.data <- as.logical(keep.parse.data)
  oop <- options(keep.source = keep.source, keep.parse.data = keep.parse.data, topLevelEnvironment = toplevel.env)
  on.exit(options(oop))
  if (keep.source) {
    lines <- readLines(file, warn = FALSE)
    srcfile <- srcfilecopy(file, lines, file.mtime(file), isFile = TRUE)
    exprs <- parse(text = lines, srcfile = srcfile, keep.source = TRUE)
  }
  else exprs <- parse(n = -1, file = file, srcfile = NULL, keep.source = FALSE)
  if (length(exprs) == 0) 
    return(invisible())
  if (chdir && (path <- dirname(file)) != ".") {
    owd <- getwd()
    if (is.null(owd)) 
      stop("cannot 'chdir' as current directory is unknown")
    on.exit(setwd(owd), add = TRUE)
    setwd(path)
  }
  for (i in seq_along(exprs)) eval(exprs[i], envir)
  invisible()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
sys.status
list(`package:base` = function () 
  list(sys.calls = sys.calls(), sys.parents = sys.parents(), sys.frames = sys.frames()), function () 
    list(sys.calls = sys.calls(), sys.parents = sys.parents(), sys.frames = sys.frames()))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.time
list(`package:base` = function () 
  .POSIXct(.Internal(Sys.time())), function () 
    .POSIXct(.Internal(Sys.time())))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.timezone
list(`package:base` = function (location = TRUE) 
{
  if (!location) 
    .Deprecated(msg = "Sys.timezone(location = FALSE) is defunct and ignored")
  if (!is.na(tz <- get0(".sys.timezone", baseenv(), mode = "character", inherits = FALSE, ifnotfound = NA))) 
    return(tz)
  cacheIt <- function(tz) {
    unlockBinding(".sys.timezone", baseenv())
    assign(".sys.timezone", tz, baseenv())
    lockBinding(".sys.timezone", baseenv())
  }
  tz <- Sys.getenv("TZ")
  if (nzchar(tz)) 
    return(tz)
  if (.Platform$OS.type == "windows") 
    return(.Internal(tzone_name()))
  if (!nzchar(Sys.getenv("TZDIR")) && grepl("darwin", R.Version()$os) && dir.exists(zp <- file.path(R.home("share"), "zoneinfo"))) {
    veri <- try(readLines(file.path(zp, "VERSION")), silent = TRUE)
    vers <- try(readLines("/var/db/timezone/zoneinfo/+VERSION"), silent = TRUE)
    if (!inherits(veri, "try-error") && !inherits(vers, "try-error") && vers != veri) {
      yri <- substr(veri, 1, 4)
      sufi <- substr(veri, 5, 5)
      yrs <- substr(vers, 1, 4)
      sufs <- substr(vers, 5, 5)
      if (yrs > yri || (yrs == yri && sufs > sufi)) 
        Sys.setenv(TZDIR = "macOS")
    }
  }
  if (Sys.getenv("TZDIR") == "macOS" && grepl("darwin", R.Version()$os)) 
    Sys.setenv(TZDIR = "/var/db/timezone/zoneinfo")
  tzdir <- Sys.getenv("TZDIR")
  if (nzchar(tzdir) && !dir.exists(tzdir)) 
    tzdir <- ""
  if (!nzchar(tzdir)) {
    if (dir.exists(tzdir <- "/usr/share/zoneinfo") || dir.exists(tzdir <- "/share/zoneinfo") || dir.exists(tzdir <- "/usr/share/lib/zoneinfo") || dir.exists(tzdir <- "/usrlib/zoneinfo") || dir.exists(tzdir <- "/usr/local/etc/zoneinfo") || dir.exists(tzdir <- "/etc/zoneinfo") || dir.exists(tzdir <- "/usr/etc/zoneinfo")) {
    }
    else tzdir <- ""
  }
  if (nzchar(Sys.which("timedatectl"))) {
    inf <- system("timedatectl", intern = TRUE)
    lines <- grep("Time zone: ", inf)
    if (length(lines)) {
      tz <- sub(" .*", "", sub(" *Time zone: ", "", inf[lines[1]]))
      if (nzchar(tzdir)) {
        if (file.exists(file.path(tzdir, tz))) {
          cacheIt(tz)
          return(tz)
        }
        else warning(sprintf("%s indicates the non-existent timezone name %s", sQuote("timedatectl"), sQuote(tz)), call. = FALSE, immediate. = TRUE, domain = NA)
      }
      else {
        cacheIt(tz)
        return(tz)
      }
    }
  }
  if (grepl("linux", R.Version()$platform, ignore.case = TRUE) && file.exists("/etc/timezone")) {
    tz0 <- try(readLines("/etc/timezone"))
    if (!inherits(tz0, "try-error") && length(tz0) == 1) {
      tz <- trimws(tz0)
      if (nzchar(tzdir)) {
        if (file.exists(file.path(tzdir, tz))) {
          cacheIt(tz)
          return(tz)
        }
        else warning(sprintf("%s indicates the non-existent timezone name %s", sQuote("/etc/timezone"), sQuote(tz)), call. = FALSE, immediate. = TRUE, domain = NA)
      }
      else {
        cacheIt(tz)
        return(tz)
      }
    }
  }
  if ((file.exists(lt0 <- "/etc/localtime") || file.exists(lt0 <- "/usr/local/etc/localtime") || file.exists(lt0 <- "/usr/local/etc/zoneinfo/localtime") || file.exists(lt0 <- "/var/db/timezone/localtime")) && !is.na(lt <- Sys.readlink(lt0)) && nzchar(lt)) {
    tz <- NA
    if ((nzchar(tzdir) && grepl(pat <- paste0("^", tzdir, "/"), lt)) || grepl(pat <- "^/usr/share/zoneinfo.default/", lt)) 
      tz <- sub(pat, "", lt)
    else if (grepl(pat <- ".*/zoneinfo/(.*)", lt)) 
      tz <- sub(pat, "\\1", lt)
    if (!is.na(tz)) {
      cacheIt(tz)
      return(tz)
    }
    else message("unable to deduce timezone name from ", sQuote(lt))
  }
  if (nzchar(tzdir) && (is.na(lt <- Sys.readlink(lt0)) || !nzchar(lt))) {
    warning(sprintf("Your system is mis-configured: %s is not a symlink", sQuote(lt0)), call. = FALSE, immediate. = TRUE, domain = NA)
    if (nzchar(Sys.which("cmp"))) {
      known <- dir(tzdir, recursive = TRUE)
      for (tz in known) {
        status <- system2("cmp", c("-s", shQuote(lt0), shQuote(file.path(tzdir, tz))))
        if (status == 0) {
          cacheIt(tz)
          warning(sprintf("It is strongly recommended to set envionment variable TZ to %s (or equivalent)", sQuote(tz)), call. = FALSE, immediate. = TRUE, domain = NA)
          return(tz)
        }
      }
      warning(sprintf("%s is not identical to any known timezone file", sQuote(lt0)), call. = FALSE, immediate. = TRUE, domain = NA)
    }
  }
  NA
}, function (location = TRUE) 
{
  if (!location) 
    .Deprecated(msg = "Sys.timezone(location = FALSE) is defunct and ignored")
  if (!is.na(tz <- get0(".sys.timezone", baseenv(), mode = "character", inherits = FALSE, ifnotfound = NA))) 
    return(tz)
  cacheIt <- function(tz) {
    unlockBinding(".sys.timezone", baseenv())
    assign(".sys.timezone", tz, baseenv())
    lockBinding(".sys.timezone", baseenv())
  }
  tz <- Sys.getenv("TZ")
  if (nzchar(tz)) 
    return(tz)
  if (.Platform$OS.type == "windows") 
    return(.Internal(tzone_name()))
  if (!nzchar(Sys.getenv("TZDIR")) && grepl("darwin", R.Version()$os) && dir.exists(zp <- file.path(R.home("share"), "zoneinfo"))) {
    veri <- try(readLines(file.path(zp, "VERSION")), silent = TRUE)
    vers <- try(readLines("/var/db/timezone/zoneinfo/+VERSION"), silent = TRUE)
    if (!inherits(veri, "try-error") && !inherits(vers, "try-error") && vers != veri) {
      yri <- substr(veri, 1, 4)
      sufi <- substr(veri, 5, 5)
      yrs <- substr(vers, 1, 4)
      sufs <- substr(vers, 5, 5)
      if (yrs > yri || (yrs == yri && sufs > sufi)) 
        Sys.setenv(TZDIR = "macOS")
    }
  }
  if (Sys.getenv("TZDIR") == "macOS" && grepl("darwin", R.Version()$os)) 
    Sys.setenv(TZDIR = "/var/db/timezone/zoneinfo")
  tzdir <- Sys.getenv("TZDIR")
  if (nzchar(tzdir) && !dir.exists(tzdir)) 
    tzdir <- ""
  if (!nzchar(tzdir)) {
    if (dir.exists(tzdir <- "/usr/share/zoneinfo") || dir.exists(tzdir <- "/share/zoneinfo") || dir.exists(tzdir <- "/usr/share/lib/zoneinfo") || dir.exists(tzdir <- "/usrlib/zoneinfo") || dir.exists(tzdir <- "/usr/local/etc/zoneinfo") || dir.exists(tzdir <- "/etc/zoneinfo") || dir.exists(tzdir <- "/usr/etc/zoneinfo")) {
    }
    else tzdir <- ""
  }
  if (nzchar(Sys.which("timedatectl"))) {
    inf <- system("timedatectl", intern = TRUE)
    lines <- grep("Time zone: ", inf)
    if (length(lines)) {
      tz <- sub(" .*", "", sub(" *Time zone: ", "", inf[lines[1]]))
      if (nzchar(tzdir)) {
        if (file.exists(file.path(tzdir, tz))) {
          cacheIt(tz)
          return(tz)
        }
        else warning(sprintf("%s indicates the non-existent timezone name %s", sQuote("timedatectl"), sQuote(tz)), call. = FALSE, immediate. = TRUE, domain = NA)
      }
      else {
        cacheIt(tz)
        return(tz)
      }
    }
  }
  if (grepl("linux", R.Version()$platform, ignore.case = TRUE) && file.exists("/etc/timezone")) {
    tz0 <- try(readLines("/etc/timezone"))
    if (!inherits(tz0, "try-error") && length(tz0) == 1) {
      tz <- trimws(tz0)
      if (nzchar(tzdir)) {
        if (file.exists(file.path(tzdir, tz))) {
          cacheIt(tz)
          return(tz)
        }
        else warning(sprintf("%s indicates the non-existent timezone name %s", sQuote("/etc/timezone"), sQuote(tz)), call. = FALSE, immediate. = TRUE, domain = NA)
      }
      else {
        cacheIt(tz)
        return(tz)
      }
    }
  }
  if ((file.exists(lt0 <- "/etc/localtime") || file.exists(lt0 <- "/usr/local/etc/localtime") || file.exists(lt0 <- "/usr/local/etc/zoneinfo/localtime") || file.exists(lt0 <- "/var/db/timezone/localtime")) && !is.na(lt <- Sys.readlink(lt0)) && nzchar(lt)) {
    tz <- NA
    if ((nzchar(tzdir) && grepl(pat <- paste0("^", tzdir, "/"), lt)) || grepl(pat <- "^/usr/share/zoneinfo.default/", lt)) 
      tz <- sub(pat, "", lt)
    else if (grepl(pat <- ".*/zoneinfo/(.*)", lt)) 
      tz <- sub(pat, "\\1", lt)
    if (!is.na(tz)) {
      cacheIt(tz)
      return(tz)
    }
    else message("unable to deduce timezone name from ", sQuote(lt))
  }
  if (nzchar(tzdir) && (is.na(lt <- Sys.readlink(lt0)) || !nzchar(lt))) {
    warning(sprintf("Your system is mis-configured: %s is not a symlink", sQuote(lt0)), call. = FALSE, immediate. = TRUE, domain = NA)
    if (nzchar(Sys.which("cmp"))) {
      known <- dir(tzdir, recursive = TRUE)
      for (tz in known) {
        status <- system2("cmp", c("-s", shQuote(lt0), shQuote(file.path(tzdir, tz))))
        if (status == 0) {
          cacheIt(tz)
          warning(sprintf("It is strongly recommended to set envionment variable TZ to %s (or equivalent)", sQuote(tz)), call. = FALSE, immediate. = TRUE, domain = NA)
          return(tz)
        }
      }
      warning(sprintf("%s is not identical to any known timezone file", sQuote(lt0)), call. = FALSE, immediate. = TRUE, domain = NA)
    }
  }
  NA
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.umask
list(`package:base` = function (mode = NA) 
  .Internal(Sys.umask(if (is.na(mode)) NA else as.octmode(mode))), function (mode = NA) 
    .Internal(Sys.umask(if (is.na(mode)) NA else as.octmode(mode))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.unsetenv
list(`package:base` = function (x) 
  .Internal(Sys.unsetenv(as.character(x))), function (x) 
    .Internal(Sys.unsetenv(as.character(x))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sys.which
list(`package:base` = function (names) 
  .Internal(Sys.which(as.character(names))), function (names) 
    .Internal(Sys.which(as.character(names))))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
system
list(`package:base` = function (command, intern = FALSE, ignore.stdout = FALSE, ignore.stderr = FALSE, wait = TRUE, input = NULL, show.output.on.console = TRUE, minimized = FALSE, invisible = TRUE, timeout = 0) 
{
  if (!is.logical(intern) || is.na(intern)) 
    stop("'intern' must be TRUE or FALSE")
  if (!is.logical(ignore.stdout) || is.na(ignore.stdout)) 
    stop("'ignore.stdout' must be TRUE or FALSE")
  if (!is.logical(ignore.stderr) || is.na(ignore.stderr)) 
    stop("'ignore.stderr' must be TRUE or FALSE")
  if (!is.logical(wait) || is.na(wait)) 
    stop("'wait' must be TRUE or FALSE")
  if (!is.logical(show.output.on.console) || is.na(show.output.on.console)) 
    stop("'show.output.on.console' must be TRUE or FALSE")
  if (!is.logical(minimized) || is.na(minimized)) 
    stop("'minimized' must be TRUE or FALSE")
  if (!is.logical(invisible) || is.na(invisible)) 
    stop("'invisible' must be TRUE or FALSE")
  stdout <- ifelse(ignore.stdout, FALSE, "")
  stderr <- ifelse(ignore.stderr, FALSE, "")
  f <- ""
  if (!is.null(input)) {
    f <- tempfile()
    on.exit(unlink(f))
    writeLines(input, f)
  }
  internNothing <- FALSE
  if (intern) {
    flag <- 3
    if (stdout == "") 
      stdout <- TRUE
    if (!ignore.stderr && .Platform$GUI == "Rgui") 
      stderr <- TRUE
    if (identical(stdout, FALSE) && (identical(stderr, FALSE) || .Platform$GUI != "Rgui")) {
      flag <- 1
      internNothing <- TRUE
    }
  }
  else {
    flag <- if (wait) {
      if (show.output.on.console && (!ignore.stderr || !ignore.stdout)) 
        2
      else 1
    }
    else 0
  }
  if (invisible) 
    flag <- 20 + flag
  else if (minimized) 
    flag <- 10 + flag
  if (.fixupGFortranStdout()) 
    on.exit(Sys.setenv(GFORTRAN_STDOUT_UNIT = "-1"), add = TRUE)
  if (.fixupGFortranStderr()) 
    on.exit(Sys.setenv(GFORTRAN_STDERR_UNIT = "-1"), add = TRUE)
  rval <- .Internal(system(command, as.integer(flag), f, stdout, stderr, timeout))
  if (!internNothing) 
    rval
  else {
    ans <- character(0)
    if (is.numeric(rval) && length(rval) > 0 && rval != 0) {
      rval <- as.integer(rval)
      attr(ans, "status") <- rval
      warning(gettextf("running command '%s' had status %d", command, rval), domain = NA)
    }
    ans
  }
}, function (command, intern = FALSE, ignore.stdout = FALSE, ignore.stderr = FALSE, wait = TRUE, input = NULL, show.output.on.console = TRUE, minimized = FALSE, invisible = TRUE, timeout = 0) 
{
  if (!is.logical(intern) || is.na(intern)) 
    stop("'intern' must be TRUE or FALSE")
  if (!is.logical(ignore.stdout) || is.na(ignore.stdout)) 
    stop("'ignore.stdout' must be TRUE or FALSE")
  if (!is.logical(ignore.stderr) || is.na(ignore.stderr)) 
    stop("'ignore.stderr' must be TRUE or FALSE")
  if (!is.logical(wait) || is.na(wait)) 
    stop("'wait' must be TRUE or FALSE")
  if (!is.logical(show.output.on.console) || is.na(show.output.on.console)) 
    stop("'show.output.on.console' must be TRUE or FALSE")
  if (!is.logical(minimized) || is.na(minimized)) 
    stop("'minimized' must be TRUE or FALSE")
  if (!is.logical(invisible) || is.na(invisible)) 
    stop("'invisible' must be TRUE or FALSE")
  stdout <- ifelse(ignore.stdout, FALSE, "")
  stderr <- ifelse(ignore.stderr, FALSE, "")
  f <- ""
  if (!is.null(input)) {
    f <- tempfile()
    on.exit(unlink(f))
    writeLines(input, f)
  }
  internNothing <- FALSE
  if (intern) {
    flag <- 3
    if (stdout == "") 
      stdout <- TRUE
    if (!ignore.stderr && .Platform$GUI == "Rgui") 
      stderr <- TRUE
    if (identical(stdout, FALSE) && (identical(stderr, FALSE) || .Platform$GUI != "Rgui")) {
      flag <- 1
      internNothing <- TRUE
    }
  }
  else {
    flag <- if (wait) {
      if (show.output.on.console && (!ignore.stderr || !ignore.stdout)) 
        2
      else 1
    }
    else 0
  }
  if (invisible) 
    flag <- 20 + flag
  else if (minimized) 
    flag <- 10 + flag
  if (.fixupGFortranStdout()) 
    on.exit(Sys.setenv(GFORTRAN_STDOUT_UNIT = "-1"), add = TRUE)
  if (.fixupGFortranStderr()) 
    on.exit(Sys.setenv(GFORTRAN_STDERR_UNIT = "-1"), add = TRUE)
  rval <- .Internal(system(command, as.integer(flag), f, stdout, stderr, timeout))
  if (!internNothing) 
    rval
  else {
    ans <- character(0)
    if (is.numeric(rval) && length(rval) > 0 && rval != 0) {
      rval <- as.integer(rval)
      attr(ans, "status") <- rval
      warning(gettextf("running command '%s' had status %d", command, rval), domain = NA)
    }
    ans
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
system.file
list(`package:base` = function (..., package = "base", lib.loc = NULL, mustWork = FALSE) 
{
  if (nargs() == 0) 
    return(file.path(.Library, "base"))
  if (length(package) != 1) 
    stop("'package' must be of length 1")
  packagePath <- find.package(package, lib.loc, quiet = TRUE)
  ans <- if (length(packagePath)) {
    FILES <- file.path(packagePath, ...)
    present <- file.exists(FILES)
    if (any(present)) 
      FILES[present]
    else ""
  }
  else ""
  if (mustWork && identical(ans, "")) 
    stop("no file found")
  ans
}, function (..., package = "base", lib.loc = NULL, mustWork = FALSE) 
{
  if (nargs() == 0) 
    return(file.path(.Library, "base"))
  if (length(package) != 1) 
    stop("'package' must be of length 1")
  packagePath <- find.package(package, lib.loc, quiet = TRUE)
  ans <- if (length(packagePath)) {
    FILES <- file.path(packagePath, ...)
    present <- file.exists(FILES)
    if (any(present)) 
      FILES[present]
    else ""
  }
  else ""
  if (mustWork && identical(ans, "")) 
    stop("no file found")
  ans
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
system.time
list(`package:base` = function (expr, gcFirst = TRUE) 
{
  ppt <- function(y) {
    if (!is.na(y[4])) 
      y[1] <- y[1] + y[4]
    if (!is.na(y[5])) 
      y[2] <- y[2] + y[5]
    paste(formatC(y[1:3]), collapse = " ")
  }
  if (gcFirst) 
    gc(FALSE)
  time <- proc.time()
  on.exit(message("Timing stopped at: ", ppt(proc.time() - time)))
  expr
  new.time <- proc.time()
  on.exit()
  structure(new.time - time, class = "proc_time")
}, function (expr, gcFirst = TRUE) 
{
  ppt <- function(y) {
    if (!is.na(y[4])) 
      y[1] <- y[1] + y[4]
    if (!is.na(y[5])) 
      y[2] <- y[2] + y[5]
    paste(formatC(y[1:3]), collapse = " ")
  }
  if (gcFirst) 
    gc(FALSE)
  time <- proc.time()
  on.exit(message("Timing stopped at: ", ppt(proc.time() - time)))
  expr
  new.time <- proc.time()
  on.exit()
  structure(new.time - time, class = "proc_time")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
system2
list(`package:base` = function (command, args = character(), stdout = "", stderr = "", stdin = "", input = NULL, env = character(), wait = TRUE, minimized = FALSE, invisible = TRUE, timeout = 0) 
{
  if (!is.logical(wait) || is.na(wait)) 
    stop("'wait' must be TRUE or FALSE")
  if (!is.logical(minimized) || is.na(minimized)) 
    stop("'minimized' must be TRUE or FALSE")
  if (!is.logical(invisible) || is.na(invisible)) 
    stop("'invisible' must be TRUE or FALSE")
  command <- paste(c(shQuote(command), env, args), collapse = " ")
  if (is.null(stdout)) 
    stdout <- FALSE
  if (is.null(stderr)) 
    stderr <- FALSE
  if (length(stdout) != 1) 
    stop("'stdout' must be of length 1")
  if (length(stderr) != 1) 
    stop("'stderr' must be of length 1")
  if (!is.null(input)) {
    f <- tempfile()
    on.exit(unlink(f))
    writeLines(input, f)
  }
  else f <- stdin
  rf <- NULL
  if (.Platform$GUI == "Rgui") {
    if (isTRUE(stdout) && identical(stderr, "")) {
      rf <- tempfile()
      on.exit(unlink(rf), add = TRUE)
      stdout <- rf
      wait <- TRUE
    }
    else if (isTRUE(stderr) && identical(stdout, "")) {
      rf <- tempfile()
      on.exit(unlink(rf), add = TRUE)
      stderr <- rf
      wait <- TRUE
    }
  }
  flag <- if (isTRUE(stdout) || isTRUE(stderr)) 
    3
  else if (wait) 
    ifelse(identical(stdout, "") || identical(stderr, ""), 2, 1)
  else 0
  if (invisible) 
    flag <- 20 + flag
  else if (minimized) 
    flag <- 10 + flag
  if (.fixupGFortranStdout()) 
    on.exit(Sys.setenv(GFORTRAN_STDOUT_UNIT = "-1"), add = TRUE)
  if (.fixupGFortranStderr()) 
    on.exit(Sys.setenv(GFORTRAN_STDERR_UNIT = "-1"), add = TRUE)
  rval <- .Internal(system(command, flag, f, stdout, stderr, timeout))
  if (is.null(rf)) {
    if (is.integer(rval)) 
      invisible(rval)
    else rval
  }
  else {
    ans <- readLines(rf)
    if (is.numeric(rval) && length(rval) > 0 && rval != 0) {
      rval <- as.integer(rval)
      attr(ans, "status") <- rval
      warning(gettextf("running command '%s' had status %d", command, rval), domain = NA)
    }
    ans
  }
}, function (command, args = character(), stdout = "", stderr = "", stdin = "", input = NULL, env = character(), wait = TRUE, minimized = FALSE, invisible = TRUE, timeout = 0) 
{
  if (!is.logical(wait) || is.na(wait)) 
    stop("'wait' must be TRUE or FALSE")
  if (!is.logical(minimized) || is.na(minimized)) 
    stop("'minimized' must be TRUE or FALSE")
  if (!is.logical(invisible) || is.na(invisible)) 
    stop("'invisible' must be TRUE or FALSE")
  command <- paste(c(shQuote(command), env, args), collapse = " ")
  if (is.null(stdout)) 
    stdout <- FALSE
  if (is.null(stderr)) 
    stderr <- FALSE
  if (length(stdout) != 1) 
    stop("'stdout' must be of length 1")
  if (length(stderr) != 1) 
    stop("'stderr' must be of length 1")
  if (!is.null(input)) {
    f <- tempfile()
    on.exit(unlink(f))
    writeLines(input, f)
  }
  else f <- stdin
  rf <- NULL
  if (.Platform$GUI == "Rgui") {
    if (isTRUE(stdout) && identical(stderr, "")) {
      rf <- tempfile()
      on.exit(unlink(rf), add = TRUE)
      stdout <- rf
      wait <- TRUE
    }
    else if (isTRUE(stderr) && identical(stdout, "")) {
      rf <- tempfile()
      on.exit(unlink(rf), add = TRUE)
      stderr <- rf
      wait <- TRUE
    }
  }
  flag <- if (isTRUE(stdout) || isTRUE(stderr)) 
    3
  else if (wait) 
    ifelse(identical(stdout, "") || identical(stderr, ""), 2, 1)
  else 0
  if (invisible) 
    flag <- 20 + flag
  else if (minimized) 
    flag <- 10 + flag
  if (.fixupGFortranStdout()) 
    on.exit(Sys.setenv(GFORTRAN_STDOUT_UNIT = "-1"), add = TRUE)
  if (.fixupGFortranStderr()) 
    on.exit(Sys.setenv(GFORTRAN_STDERR_UNIT = "-1"), add = TRUE)
  rval <- .Internal(system(command, flag, f, stdout, stderr, timeout))
  if (is.null(rf)) {
    if (is.integer(rval)) 
      invisible(rval)
    else rval
  }
  else {
    ans <- readLines(rf)
    if (is.numeric(rval) && length(rval) > 0 && rval != 0) {
      rval <- as.integer(rval)
      attr(ans, "status") <- rval
      warning(gettextf("running command '%s' had status %d", command, rval), domain = NA)
    }
    ans
  }
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
t
list(`package:base` = function (x) 
  UseMethod("t"), new("standardGeneric", .Data = function (x) 
    standardGeneric("t"), generic = "t", package = "base", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x) 
      UseMethod("t"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "t"), skeleton = (new("derivedDefaultMethod", .Data = function (x) 
        UseMethod("t"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "t"))(x)), function (x) 
          UseMethod("t"))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
T
list(`package:base` = TRUE, TRUE)
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
t.data.frame
list(`package:base` = function (x) 
{
  x <- as.matrix(x)
  NextMethod("t")
}, function (x) 
{
  x <- as.matrix(x)
  NextMethod("t")
}, function (x) 
{
  x <- as.matrix(x)
  NextMethod("t")
})
c("package:base", "registered S3 method for t from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
t.default
list(`package:base` = function (x) 
  .Internal(t.default(x)), function (x) 
    .Internal(t.default(x)), function (x) 
      .Internal(t.default(x)))
c("package:base", "registered S3 method for t from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
table
list(`package:base` = function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", "ifany", "always"), dnn = list.names(...), deparse.level = 1) 
{
  list.names <- function(...) {
    l <- as.list(substitute(list(...)))[-1]
    if (length(l) == 1 && is.list(..1) && !is.null(nm <- names(..1))) 
      return(nm)
    nm <- names(l)
    fixup <- if (is.null(nm)) 
      seq_along(l)
    else nm == ""
    dep <- vapply(l[fixup], function(x) switch(deparse.level + 1, "", if (is.symbol(x)) as.character(x) else "", deparse(x, nlines = 1)[1]), "")
    if (is.null(nm)) 
      dep
    else {
      nm[fixup] <- dep
      nm
    }
  }
  miss.use <- missing(useNA)
  miss.exc <- missing(exclude)
  useNA <- if (miss.use && !miss.exc && !match(NA, exclude, nomatch = 0)) 
    "ifany"
  else match.arg(useNA)
  doNA <- useNA != "no"
  if (!miss.use && !miss.exc && doNA && match(NA, exclude, nomatch = 0)) 
    warning("'exclude' containing NA and 'useNA' != \"no\"' are a bit contradicting")
  args <- list(...)
  if (length(args) == 1 && is.list(args[[1]])) {
    args <- args[[1]]
    if (length(dnn) != length(args)) 
      dnn <- paste(dnn[1], seq_along(args), sep = ".")
  }
  if (!length(args)) 
    stop("nothing to tabulate")
  bin <- 0
  lens <- NULL
  dims <- integer()
  pd <- 1
  dn <- NULL
  for (a in args) {
    if (is.null(lens)) 
      lens <- length(a)
    else if (length(a) != lens) 
      stop("all arguments must have the same length")
    fact.a <- is.factor(a)
    if (doNA) 
      aNA <- anyNA(a)
    if (!fact.a) {
      a0 <- a
      op <- options(warn = 2)
      a <- factor(a, exclude = exclude)
      options(op)
    }
    add.na <- doNA
    if (add.na) {
      ifany <- (useNA == "ifany")
      anNAc <- anyNA(a)
      add.na <- if (!ifany || anNAc) {
        ll <- levels(a)
        if (add.ll <- !anyNA(ll)) {
          ll <- c(ll, NA)
          TRUE
        }
        else if (!ifany && !anNAc) 
          FALSE
        else TRUE
      }
      else FALSE
    }
    if (add.na) 
      a <- factor(a, levels = ll, exclude = NULL)
    else ll <- levels(a)
    a <- as.integer(a)
    if (fact.a && !miss.exc) {
      ll <- ll[keep <- which(match(ll, exclude, nomatch = 0) == 0)]
      a <- match(a, keep)
    }
    else if (!fact.a && add.na) {
      if (ifany && !aNA && add.ll) {
        ll <- ll[!is.na(ll)]
        is.na(a) <- match(a0, c(exclude, NA), nomatch = 0) > 0
      }
      else {
        is.na(a) <- match(a0, exclude, nomatch = 0) > 0
      }
    }
    nl <- length(ll)
    dims <- c(dims, nl)
    if (prod(dims) > .Machine$integer.max) 
      stop("attempt to make a table with >= 2^31 elements")
    dn <- c(dn, list(ll))
    bin <- bin + pd * (a - 1)
    pd <- pd * nl
  }
  names(dn) <- dnn
  bin <- bin[!is.na(bin)]
  if (length(bin)) 
    bin <- bin + 1
  y <- array(tabulate(bin, pd), dims, dimnames = dn)
  class(y) <- "table"
  y
}, function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", "ifany", "always"), dnn = list.names(...), deparse.level = 1) 
{
  list.names <- function(...) {
    l <- as.list(substitute(list(...)))[-1]
    if (length(l) == 1 && is.list(..1) && !is.null(nm <- names(..1))) 
      return(nm)
    nm <- names(l)
    fixup <- if (is.null(nm)) 
      seq_along(l)
    else nm == ""
    dep <- vapply(l[fixup], function(x) switch(deparse.level + 1, "", if (is.symbol(x)) as.character(x) else "", deparse(x, nlines = 1)[1]), "")
    if (is.null(nm)) 
      dep
    else {
      nm[fixup] <- dep
      nm
    }
  }
  miss.use <- missing(useNA)
  miss.exc <- missing(exclude)
  useNA <- if (miss.use && !miss.exc && !match(NA, exclude, nomatch = 0)) 
    "ifany"
  else match.arg(useNA)
  doNA <- useNA != "no"
  if (!miss.use && !miss.exc && doNA && match(NA, exclude, nomatch = 0)) 
    warning("'exclude' containing NA and 'useNA' != \"no\"' are a bit contradicting")
  args <- list(...)
  if (length(args) == 1 && is.list(args[[1]])) {
    args <- args[[1]]
    if (length(dnn) != length(args)) 
      dnn <- paste(dnn[1], seq_along(args), sep = ".")
  }
  if (!length(args)) 
    stop("nothing to tabulate")
  bin <- 0
  lens <- NULL
  dims <- integer()
  pd <- 1
  dn <- NULL
  for (a in args) {
    if (is.null(lens)) 
      lens <- length(a)
    else if (length(a) != lens) 
      stop("all arguments must have the same length")
    fact.a <- is.factor(a)
    if (doNA) 
      aNA <- anyNA(a)
    if (!fact.a) {
      a0 <- a
      op <- options(warn = 2)
      a <- factor(a, exclude = exclude)
      options(op)
    }
    add.na <- doNA
    if (add.na) {
      ifany <- (useNA == "ifany")
      anNAc <- anyNA(a)
      add.na <- if (!ifany || anNAc) {
        ll <- levels(a)
        if (add.ll <- !anyNA(ll)) {
          ll <- c(ll, NA)
          TRUE
        }
        else if (!ifany && !anNAc) 
          FALSE
        else TRUE
      }
      else FALSE
    }
    if (add.na) 
      a <- factor(a, levels = ll, exclude = NULL)
    else ll <- levels(a)
    a <- as.integer(a)
    if (fact.a && !miss.exc) {
      ll <- ll[keep <- which(match(ll, exclude, nomatch = 0) == 0)]
      a <- match(a, keep)
    }
    else if (!fact.a && add.na) {
      if (ifany && !aNA && add.ll) {
        ll <- ll[!is.na(ll)]
        is.na(a) <- match(a0, c(exclude, NA), nomatch = 0) > 0
      }
      else {
        is.na(a) <- match(a0, exclude, nomatch = 0) > 0
      }
    }
    nl <- length(ll)
    dims <- c(dims, nl)
    if (prod(dims) > .Machine$integer.max) 
      stop("attempt to make a table with >= 2^31 elements")
    dn <- c(dn, list(ll))
    bin <- bin + pd * (a - 1)
    pd <- pd * nl
  }
  names(dn) <- dnn
  bin <- bin[!is.na(bin)]
  if (length(bin)) 
    bin <- bin + 1
  y <- array(tabulate(bin, pd), dims, dimnames = dn)
  class(y) <- "table"
  y
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tabulate
list(`package:base` = function (bin, nbins = max(1, bin, na.rm = TRUE)) 
{
  if (!is.numeric(bin) && !is.factor(bin)) 
    stop("'bin' must be numeric or a factor")
  if (typeof(bin) != "integer") 
    bin <- as.integer(bin)
  if (nbins > .Machine$integer.max) 
    stop("attempt to make a table with >= 2^31 elements")
  nbins <- as.integer(nbins)
  if (is.na(nbins)) 
    stop(gettextf("invalid value of %s", "'nbins'"), domain = NA)
  .Internal(tabulate(bin, nbins))
}, function (bin, nbins = max(1, bin, na.rm = TRUE)) 
{
  if (!is.numeric(bin) && !is.factor(bin)) 
    stop("'bin' must be numeric or a factor")
  if (typeof(bin) != "integer") 
    bin <- as.integer(bin)
  if (nbins > .Machine$integer.max) 
    stop("attempt to make a table with >= 2^31 elements")
  nbins <- as.integer(nbins)
  if (is.na(nbins)) 
    stop(gettextf("invalid value of %s", "'nbins'"), domain = NA)
  .Internal(tabulate(bin, nbins))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tan
list(`package:base` = .Primitive("tan"), .Primitive("tan"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tanh
list(`package:base` = .Primitive("tanh"), .Primitive("tanh"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tanpi
list(`package:base` = .Primitive("tanpi"), .Primitive("tanpi"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tapply
list(`package:base` = function (X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE) 
{
  FUN <- if (!is.null(FUN)) 
    match.fun(FUN)
  if (!is.list(INDEX)) 
    INDEX <- list(INDEX)
  INDEX <- lapply(INDEX, as.factor)
  nI <- length(INDEX)
  if (!nI) 
    stop("'INDEX' is of length zero")
  if (!all(lengths(INDEX) == length(X))) 
    stop("arguments must have same length")
  namelist <- lapply(INDEX, levels)
  extent <- lengths(namelist, use.names = FALSE)
  cumextent <- cumprod(extent)
  if (cumextent[nI] > .Machine$integer.max) 
    stop("total number of levels >= 2^31")
  storage.mode(cumextent) <- "integer"
  ngroup <- cumextent[nI]
  group <- as.integer(INDEX[[1]])
  if (nI > 1) 
    for (i in 2:nI) group <- group + cumextent[i - 1] * (as.integer(INDEX[[i]]) - 1)
  if (is.null(FUN)) 
    return(group)
  levels(group) <- as.character(seq_len(ngroup))
  class(group) <- "factor"
  ans <- split(X, group)
  names(ans) <- NULL
  index <- as.logical(lengths(ans))
  ans <- lapply(X = ans[index], FUN = FUN, ...)
  ansmat <- array(if (simplify && all(lengths(ans) == 1)) {
    ans <- unlist(ans, recursive = FALSE, use.names = FALSE)
    if (!is.null(ans) && is.na(default) && is.atomic(ans)) 
      vector(typeof(ans))
    else default
  }
  else vector("list", prod(extent)), dim = extent, dimnames = namelist)
  if (length(ans)) {
    ansmat[index] <- ans
  }
  ansmat
}, function (X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE) 
{
  FUN <- if (!is.null(FUN)) 
    match.fun(FUN)
  if (!is.list(INDEX)) 
    INDEX <- list(INDEX)
  INDEX <- lapply(INDEX, as.factor)
  nI <- length(INDEX)
  if (!nI) 
    stop("'INDEX' is of length zero")
  if (!all(lengths(INDEX) == length(X))) 
    stop("arguments must have same length")
  namelist <- lapply(INDEX, levels)
  extent <- lengths(namelist, use.names = FALSE)
  cumextent <- cumprod(extent)
  if (cumextent[nI] > .Machine$integer.max) 
    stop("total number of levels >= 2^31")
  storage.mode(cumextent) <- "integer"
  ngroup <- cumextent[nI]
  group <- as.integer(INDEX[[1]])
  if (nI > 1) 
    for (i in 2:nI) group <- group + cumextent[i - 1] * (as.integer(INDEX[[i]]) - 1)
  if (is.null(FUN)) 
    return(group)
  levels(group) <- as.character(seq_len(ngroup))
  class(group) <- "factor"
  ans <- split(X, group)
  names(ans) <- NULL
  index <- as.logical(lengths(ans))
  ans <- lapply(X = ans[index], FUN = FUN, ...)
  ansmat <- array(if (simplify && all(lengths(ans) == 1)) {
    ans <- unlist(ans, recursive = FALSE, use.names = FALSE)
    if (!is.null(ans) && is.na(default) && is.atomic(ans)) 
      vector(typeof(ans))
    else default
  }
  else vector("list", prod(extent)), dim = extent, dimnames = namelist)
  if (length(ans)) {
    ansmat[index] <- ans
  }
  ansmat
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
taskCallbackManager
list(`package:base` = function (handlers = list(), registered = FALSE, verbose = FALSE) 
{
  suspended <- FALSE
  .verbose <- verbose
  add <- function(f, data = NULL, name = NULL, register = TRUE) {
    if (is.null(name)) 
      name <- as.character(length(handlers) + 1)
    handlers[[name]] <<- list(f = f)
    if (!missing(data)) 
      handlers[[name]][["data"]] <<- data
    if (!registered && register) {
      register()
    }
    name
  }
  remove <- function(which) {
    if (length(which) != 1) 
      stop("'which' must be of length 1")
    if (is.character(which)) {
      tmp <- match(which, names(handlers))
      if (is.na(tmp)) 
        stop(gettextf("no such element '%s'", which), domain = NA)
      which <- tmp
    }
    else if (is.numeric(which)) {
      which <- as.integer(which)
      if (which <= 0 || which > length(handlers)) 
        stop("invalid 'which' argument")
    }
    else stop("'which' must be character or numeric")
    handlers <<- handlers[-which]
    return(TRUE)
  }
  evaluate <- function(expr, value, ok, visible) {
    if (suspended) 
      return(TRUE)
    discard <- character()
    for (i in names(handlers)) {
      h <- handlers[[i]]
      if (length(h) > 1) {
        val <- h[["f"]](expr, value, ok, visible, h[["data"]])
      }
      else {
        val <- h[["f"]](expr, value, ok, visible)
      }
      if (!val) {
        discard <- c(discard, i)
      }
    }
    if (length(discard)) {
      if (.verbose) 
        cat(gettextf("Removing %s", paste(discard, collapse = ", ")), "\n")
      idx <- is.na(match(names(handlers), discard))
      if (length(idx)) 
        handlers <<- handlers[idx]
      else handlers <<- list()
    }
    return(TRUE)
  }
  suspend <- function(status = TRUE) {
    suspended <<- status
  }
  register <- function(name = "R-taskCallbackManager", verbose = .verbose) {
    if (verbose) 
      cat(gettext("Registering 'evaluate' as low-level callback\n"))
    id <- addTaskCallback(evaluate, name = name)
    registered <<- TRUE
    id
  }
  list(add = add, evaluate = evaluate, remove = remove, register = register, suspend = suspend, callbacks = function() handlers)
}, function (handlers = list(), registered = FALSE, verbose = FALSE) 
{
  suspended <- FALSE
  .verbose <- verbose
  add <- function(f, data = NULL, name = NULL, register = TRUE) {
    if (is.null(name)) 
      name <- as.character(length(handlers) + 1)
    handlers[[name]] <<- list(f = f)
    if (!missing(data)) 
      handlers[[name]][["data"]] <<- data
    if (!registered && register) {
      register()
    }
    name
  }
  remove <- function(which) {
    if (length(which) != 1) 
      stop("'which' must be of length 1")
    if (is.character(which)) {
      tmp <- match(which, names(handlers))
      if (is.na(tmp)) 
        stop(gettextf("no such element '%s'", which), domain = NA)
      which <- tmp
    }
    else if (is.numeric(which)) {
      which <- as.integer(which)
      if (which <= 0 || which > length(handlers)) 
        stop("invalid 'which' argument")
    }
    else stop("'which' must be character or numeric")
    handlers <<- handlers[-which]
    return(TRUE)
  }
  evaluate <- function(expr, value, ok, visible) {
    if (suspended) 
      return(TRUE)
    discard <- character()
    for (i in names(handlers)) {
      h <- handlers[[i]]
      if (length(h) > 1) {
        val <- h[["f"]](expr, value, ok, visible, h[["data"]])
      }
      else {
        val <- h[["f"]](expr, value, ok, visible)
      }
      if (!val) {
        discard <- c(discard, i)
      }
    }
    if (length(discard)) {
      if (.verbose) 
        cat(gettextf("Removing %s", paste(discard, collapse = ", ")), "\n")
      idx <- is.na(match(names(handlers), discard))
      if (length(idx)) 
        handlers <<- handlers[idx]
      else handlers <<- list()
    }
    return(TRUE)
  }
  suspend <- function(status = TRUE) {
    suspended <<- status
  }
  register <- function(name = "R-taskCallbackManager", verbose = .verbose) {
    if (verbose) 
      cat(gettext("Registering 'evaluate' as low-level callback\n"))
    id <- addTaskCallback(evaluate, name = name)
    registered <<- TRUE
    id
  }
  list(add = add, evaluate = evaluate, remove = remove, register = register, suspend = suspend, callbacks = function() handlers)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tcrossprod
list(`package:base` = function (x, y = NULL) 
  .Internal(tcrossprod(x, y)), new("standardGeneric", .Data = function (x, y = NULL, ...) 
    standardGeneric("tcrossprod"), generic = "tcrossprod", package = "base", group = list(), valueClass = character(0), signature = c("x", "y"), default = new("derivedDefaultMethod", .Data = function (x, y = NULL, ...) 
      base::tcrossprod(x, y), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "tcrossprod"), skeleton = (new("derivedDefaultMethod", .Data = function (x, y = NULL, ...) 
        base::tcrossprod(x, y), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "tcrossprod"))(x, y, ...)), function (x, y = NULL) 
          .Internal(tcrossprod(x, y)))
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
tempdir
list(`package:base` = function (check = FALSE) 
  .Internal(tempdir(check)), function (check = FALSE) 
    .Internal(tempdir(check)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tempfile
list(`package:base` = function (pattern = "file", tmpdir = tempdir(), fileext = "") 
  .Internal(tempfile(pattern, tmpdir, fileext)), function (pattern = "file", tmpdir = tempdir(), fileext = "") 
    .Internal(tempfile(pattern, tmpdir, fileext)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
textConnection
list(`package:base` = function (object, open = "r", local = FALSE, name = deparse1(substitute(object)), encoding = c("", "bytes", "UTF-8")) 
{
  env <- if (local) 
    parent.frame()
  else .GlobalEnv
  type <- match(match.arg(encoding), c("", "bytes", "UTF-8"))
  if (!(is.character(name) && length(name) == 1)) 
    stop("'name' must be a single character string")
  .Internal(textConnection(name, object, open, env, type))
}, function (object, open = "r", local = FALSE, name = deparse1(substitute(object)), encoding = c("", "bytes", "UTF-8")) 
{
  env <- if (local) 
    parent.frame()
  else .GlobalEnv
  type <- match(match.arg(encoding), c("", "bytes", "UTF-8"))
  if (!(is.character(name) && length(name) == 1)) 
    stop("'name' must be a single character string")
  .Internal(textConnection(name, object, open, env, type))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
textConnectionValue
list(`package:base` = function (con) 
  .Internal(textConnectionValue(con)), function (con) 
    .Internal(textConnectionValue(con)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tolower
list(`package:base` = function (x) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(tolower(x))
}, function (x) 
{
  abort("Please use `to_lower_ascii()`, which works fine in all locales.")
}, function (x) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(tolower(x))
})
c("package:base", "namespace:ggplot2", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
topenv
list(`package:base` = function (envir = parent.frame(), matchThisEnv = getOption("topLevelEnvironment")) 
{
  .Internal(topenv(envir, matchThisEnv))
}, function (envir = parent.frame(), matchThisEnv = getOption("topLevelEnvironment")) 
{
  .Internal(topenv(envir, matchThisEnv))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
toString
list(`package:base` = function (x, ...) 
  UseMethod("toString"), function (x, ...) 
    UseMethod("toString"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
toString.default
list(`package:base` = function (x, width = NULL, ...) 
{
  string <- paste(x, collapse = ", ")
  if (missing(width) || is.null(width) || width == 0) 
    return(string)
  if (width < 0) 
    stop("'width' must be positive")
  if (nchar(string, type = "w") > width) {
    width <- max(6, width)
    string <- paste0(strtrim(string, width - 4), "....")
  }
  string
}, function (x, width = NULL, ...) 
{
  string <- paste(x, collapse = ", ")
  if (missing(width) || is.null(width) || width == 0) 
    return(string)
  if (width < 0) 
    stop("'width' must be positive")
  if (nchar(string, type = "w") > width) {
    width <- max(6, width)
    string <- paste0(strtrim(string, width - 4), "....")
  }
  string
}, function (x, width = NULL, ...) 
{
  string <- paste(x, collapse = ", ")
  if (missing(width) || is.null(width) || width == 0) 
    return(string)
  if (width < 0) 
    stop("'width' must be positive")
  if (nchar(string, type = "w") > width) {
    width <- max(6, width)
    string <- paste0(strtrim(string, width - 4), "....")
  }
  string
})
c("package:base", "registered S3 method for toString from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
toupper
list(`package:base` = function (x) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(toupper(x))
}, function (x) 
{
  abort("Please use `to_upper_ascii()`, which works fine in all locales.")
}, function (x) 
{
  if (!is.character(x)) 
    x <- as.character(x)
  .Internal(toupper(x))
})
c("package:base", "namespace:ggplot2", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
trace
list(`package:base` = function (what, tracer, exit, at, print, signature, where = topenv(parent.frame()), edit = FALSE) 
{
  if (nargs() > 1 && !.isMethodsDispatchOn()) {
    ns <- try(loadNamespace("methods"))
    if (isNamespace(ns)) 
      message("(loaded the methods namespace)", domain = NA)
    else stop("tracing functions requires the 'methods' package, but unable to load the 'methods' namespace")
  }
  else if (nargs() == 1) 
    return(.primTrace(what))
  tState <- tracingState(FALSE)
  on.exit(tracingState(tState))
  call <- sys.call()
  call[[1]] <- quote(methods::.TraceWithMethods)
  call$where <- where
  eval.parent(call)
}, function (what, tracer, exit, at, print, signature, where = topenv(parent.frame()), edit = FALSE) 
{
  if (nargs() > 1 && !.isMethodsDispatchOn()) {
    ns <- try(loadNamespace("methods"))
    if (isNamespace(ns)) 
      message("(loaded the methods namespace)", domain = NA)
    else stop("tracing functions requires the 'methods' package, but unable to load the 'methods' namespace")
  }
  else if (nargs() == 1) 
    return(.primTrace(what))
  tState <- tracingState(FALSE)
  on.exit(tracingState(tState))
  call <- sys.call()
  call[[1]] <- quote(methods::.TraceWithMethods)
  call$where <- where
  eval.parent(call)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
traceback
list(`package:base` = function (x = NULL, max.lines = getOption("traceback.max.lines", getOption("deparse.max.lines", -1))) 
{
  n <- length(x <- .traceback(x, max.lines = max.lines))
  if (n == 0) 
    cat(gettext("No traceback available"), "\n")
  else {
    for (i in 1:n) {
      xi <- x[[i]]
      label <- paste0(n - i + 1, ": ")
      m <- length(xi)
      srcloc <- if (!is.null(srcref <- attr(xi, "srcref"))) {
        srcfile <- attr(srcref, "srcfile")
        paste0(" at ", basename(srcfile$filename), "#", srcref[1])
      }
      if (isTRUE(attr(xi, "truncated"))) {
        xi <- c(xi, " ...")
        m <- length(xi)
      }
      if (!is.null(srcloc)) {
        xi[m] <- paste0(xi[m], srcloc)
      }
      if (m > 1) 
        label <- c(label, rep(substr("          ", 1, nchar(label, type = "w")), m - 1))
      cat(paste0(label, xi), sep = "\n")
    }
  }
  invisible(x)
}, function (x = NULL, max.lines = getOption("traceback.max.lines", getOption("deparse.max.lines", -1))) 
{
  n <- length(x <- .traceback(x, max.lines = max.lines))
  if (n == 0) 
    cat(gettext("No traceback available"), "\n")
  else {
    for (i in 1:n) {
      xi <- x[[i]]
      label <- paste0(n - i + 1, ": ")
      m <- length(xi)
      srcloc <- if (!is.null(srcref <- attr(xi, "srcref"))) {
        srcfile <- attr(srcref, "srcfile")
        paste0(" at ", basename(srcfile$filename), "#", srcref[1])
      }
      if (isTRUE(attr(xi, "truncated"))) {
        xi <- c(xi, " ...")
        m <- length(xi)
      }
      if (!is.null(srcloc)) {
        xi[m] <- paste0(xi[m], srcloc)
      }
      if (m > 1) 
        label <- c(label, rep(substr("          ", 1, nchar(label, type = "w")), m - 1))
      cat(paste0(label, xi), sep = "\n")
    }
  }
  invisible(x)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tracemem
list(`package:base` = .Primitive("tracemem"), .Primitive("tracemem"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tracingState
list(`package:base` = function (on = NULL) 
  .Internal(traceOnOff(on)), function (on = NULL) 
    .Internal(traceOnOff(on)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
transform
list(`package:base` = function (`_data`, ...) 
  UseMethod("transform"), function (`_data`, ...) 
    UseMethod("transform"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
transform.data.frame
list(`package:base` = function (`_data`, ...) 
{
  e <- eval(substitute(list(...)), `_data`, parent.frame())
  tags <- names(e)
  inx <- match(tags, names(`_data`))
  matched <- !is.na(inx)
  if (any(matched)) {
    `_data`[inx[matched]] <- e[matched]
    `_data` <- data.frame(`_data`)
  }
  if (!all(matched)) 
    do.call("data.frame", c(list(`_data`), e[!matched]))
  else `_data`
}, function (`_data`, ...) 
{
  e <- eval(substitute(list(...)), `_data`, parent.frame())
  tags <- names(e)
  inx <- match(tags, names(`_data`))
  matched <- !is.na(inx)
  if (any(matched)) {
    `_data`[inx[matched]] <- e[matched]
    `_data` <- data.frame(`_data`)
  }
  if (!all(matched)) 
    do.call("data.frame", c(list(`_data`), e[!matched]))
  else `_data`
}, function (`_data`, ...) 
{
  e <- eval(substitute(list(...)), `_data`, parent.frame())
  tags <- names(e)
  inx <- match(tags, names(`_data`))
  matched <- !is.na(inx)
  if (any(matched)) {
    `_data`[inx[matched]] <- e[matched]
    `_data` <- data.frame(`_data`)
  }
  if (!all(matched)) 
    do.call("data.frame", c(list(`_data`), e[!matched]))
  else `_data`
})
c("package:base", "registered S3 method for transform from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
transform.default
list(`package:base` = function (`_data`, ...) 
  transform.data.frame(data.frame(`_data`), ...), function (`_data`, ...) 
    transform.data.frame(data.frame(`_data`), ...), function (`_data`, ...) 
      transform.data.frame(data.frame(`_data`), ...))
c("package:base", "registered S3 method for transform from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
trigamma
list(`package:base` = .Primitive("trigamma"), .Primitive("trigamma"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
trimws
list(`package:base` = function (x, which = c("both", "left", "right"), whitespace = "[ \t\r\n]") 
{
  which <- match.arg(which)
  mysub <- function(re, x) sub(re, "", x, perl = TRUE)
  switch(which, left = mysub(paste0("^", whitespace, "+"), x), right = mysub(paste0(whitespace, "+$"), x), both = mysub(paste0(whitespace, "+$"), mysub(paste0("^", whitespace, "+"), x)))
}, function (x, which = c("both", "left", "right"), whitespace = "[ \t\r\n]") 
{
  which <- match.arg(which)
  mysub <- function(re, x) sub(re, "", x, perl = TRUE)
  switch(which, left = mysub(paste0("^", whitespace, "+"), x), right = mysub(paste0(whitespace, "+$"), x), both = mysub(paste0(whitespace, "+$"), mysub(paste0("^", whitespace, "+"), x)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
trunc
list(`package:base` = .Primitive("trunc"), .Primitive("trunc"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
trunc.Date
list(`package:base` = function (x, units = c("secs", "mins", "hours", "days", "months", "years"), ...) 
{
  units <- match.arg(units)
  if (units == "months" || units == "years") 
    as.Date(trunc.POSIXt(x, units, ...))
  else round(x - 0.4999999)
}, function (x, units = c("secs", "mins", "hours", "days", "months", "years"), ...) 
{
  units <- match.arg(units)
  if (units == "months" || units == "years") 
    as.Date(trunc.POSIXt(x, units, ...))
  else round(x - 0.4999999)
}, function (x, units = c("secs", "mins", "hours", "days", "months", "years"), ...) 
{
  units <- match.arg(units)
  if (units == "months" || units == "years") 
    as.Date(trunc.POSIXt(x, units, ...))
  else round(x - 0.4999999)
})
c("package:base", "registered S3 method for trunc from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
trunc.POSIXt
list(`package:base` = function (x, units = c("secs", "mins", "hours", "days", "months", "years"), ...) 
{
  units <- match.arg(units)
  x <- as.POSIXlt(x)
  if (length(x$sec)) 
    switch(units, secs = {
      x$sec <- trunc(x$sec)
    }, mins = {
      x$sec[] <- 0
    }, hours = {
      x$sec[] <- 0
      x$min[] <- 0
    }, days = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$isdst[] <- -1
    }, months = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$mday[] <- 1
      x$isdst[] <- -1
      x <- as.POSIXlt(as.POSIXct(x))
    }, years = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$mday[] <- 1
      x$mon[] <- 0
      x$isdst[] <- -1
      x <- as.POSIXlt(as.POSIXct(x))
    })
  x
}, function (x, units = c("secs", "mins", "hours", "days", "months", "years"), ...) 
{
  units <- match.arg(units)
  x <- as.POSIXlt(x)
  if (length(x$sec)) 
    switch(units, secs = {
      x$sec <- trunc(x$sec)
    }, mins = {
      x$sec[] <- 0
    }, hours = {
      x$sec[] <- 0
      x$min[] <- 0
    }, days = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$isdst[] <- -1
    }, months = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$mday[] <- 1
      x$isdst[] <- -1
      x <- as.POSIXlt(as.POSIXct(x))
    }, years = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$mday[] <- 1
      x$mon[] <- 0
      x$isdst[] <- -1
      x <- as.POSIXlt(as.POSIXct(x))
    })
  x
}, function (x, units = c("secs", "mins", "hours", "days", "months", "years"), ...) 
{
  units <- match.arg(units)
  x <- as.POSIXlt(x)
  if (length(x$sec)) 
    switch(units, secs = {
      x$sec <- trunc(x$sec)
    }, mins = {
      x$sec[] <- 0
    }, hours = {
      x$sec[] <- 0
      x$min[] <- 0
    }, days = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$isdst[] <- -1
    }, months = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$mday[] <- 1
      x$isdst[] <- -1
      x <- as.POSIXlt(as.POSIXct(x))
    }, years = {
      x$sec[] <- 0
      x$min[] <- 0
      x$hour[] <- 0
      x$mday[] <- 1
      x$mon[] <- 0
      x$isdst[] <- -1
      x <- as.POSIXlt(as.POSIXct(x))
    })
  x
})
c("package:base", "registered S3 method for trunc from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
truncate
list(`package:base` = function (con, ...) 
  UseMethod("truncate"), function (con, ...) 
    UseMethod("truncate"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
truncate.connection
list(`package:base` = function (con, ...) 
{
  if (!isOpen(con)) 
    stop("can only truncate an open connection")
  .Internal(truncate(con))
}, function (con, ...) 
{
  if (!isOpen(con)) 
    stop("can only truncate an open connection")
  .Internal(truncate(con))
}, function (con, ...) 
{
  if (!isOpen(con)) 
    stop("can only truncate an open connection")
  .Internal(truncate(con))
})
c("package:base", "registered S3 method for truncate from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
try
list(`package:base` = function (expr, silent = FALSE, outFile = getOption("try.outFile", default = stderr())) 
{
  tryCatch(expr, error = function(e) {
    call <- conditionCall(e)
    if (!is.null(call)) {
      if (identical(call[[1]], quote(doTryCatch))) 
        call <- sys.call(-4)
      dcall <- deparse(call, nlines = 1)
      prefix <- paste("Error in", dcall, ": ")
      LONG <- 75
      sm <- strsplit(conditionMessage(e), "\n")[[1]]
      w <- 14 + nchar(dcall, type = "w") + nchar(sm[1], type = "w")
      if (is.na(w)) 
        w <- 14 + nchar(dcall, type = "b") + nchar(sm[1], type = "b")
      if (w > LONG) 
        prefix <- paste0(prefix, "\n  ")
    }
    else prefix <- "Error : "
    msg <- paste0(prefix, conditionMessage(e), "\n")
    .Internal(seterrmessage(msg[1]))
    if (!silent && isTRUE(getOption("show.error.messages"))) {
      cat(msg, file = outFile)
      .Internal(printDeferredWarnings())
    }
    invisible(structure(msg, class = "try-error", condition = e))
  })
}, function (expr, silent = FALSE, outFile = getOption("try.outFile", default = stderr())) 
{
  tryCatch(expr, error = function(e) {
    call <- conditionCall(e)
    if (!is.null(call)) {
      if (identical(call[[1]], quote(doTryCatch))) 
        call <- sys.call(-4)
      dcall <- deparse(call, nlines = 1)
      prefix <- paste("Error in", dcall, ": ")
      LONG <- 75
      sm <- strsplit(conditionMessage(e), "\n")[[1]]
      w <- 14 + nchar(dcall, type = "w") + nchar(sm[1], type = "w")
      if (is.na(w)) 
        w <- 14 + nchar(dcall, type = "b") + nchar(sm[1], type = "b")
      if (w > LONG) 
        prefix <- paste0(prefix, "\n  ")
    }
    else prefix <- "Error : "
    msg <- paste0(prefix, conditionMessage(e), "\n")
    .Internal(seterrmessage(msg[1]))
    if (!silent && isTRUE(getOption("show.error.messages"))) {
      cat(msg, file = outFile)
      .Internal(printDeferredWarnings())
    }
    invisible(structure(msg, class = "try-error", condition = e))
  })
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tryCatch
list(`package:base` = function (expr, ..., finally) 
{
  tryCatchList <- function(expr, names, parentenv, handlers) {
    nh <- length(names)
    if (nh > 1) 
      tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], parentenv, handlers[[nh]])
    else if (nh == 1) 
      tryCatchOne(expr, names, parentenv, handlers[[1]])
    else expr
  }
  tryCatchOne <- function(expr, name, parentenv, handler) {
    doTryCatch <- function(expr, name, parentenv, handler) {
      .Internal(.addCondHands(name, list(handler), parentenv, environment(), FALSE))
      expr
    }
    value <- doTryCatch(return(expr), name, parentenv, handler)
    if (is.null(value[[1]])) {
      msg <- .Internal(geterrmessage())
      call <- value[[2]]
      cond <- simpleError(msg, call)
    }
    else if (is.character(value[[1]])) {
      msg <- value[[1]]
      call <- value[[2]]
      cond <- simpleError(msg, call)
    }
    else cond <- value[[1]]
    value[[3]](cond)
  }
  if (!missing(finally)) 
    on.exit(finally)
  handlers <- list(...)
  classes <- names(handlers)
  parentenv <- parent.frame()
  if (length(classes) != length(handlers)) 
    stop("condition handlers must be specified with a condition class")
  tryCatchList(expr, classes, parentenv, handlers)
}, function (expr, ..., finally) 
{
  tryCatchList <- function(expr, names, parentenv, handlers) {
    nh <- length(names)
    if (nh > 1) 
      tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], parentenv, handlers[[nh]])
    else if (nh == 1) 
      tryCatchOne(expr, names, parentenv, handlers[[1]])
    else expr
  }
  tryCatchOne <- function(expr, name, parentenv, handler) {
    doTryCatch <- function(expr, name, parentenv, handler) {
      .Internal(.addCondHands(name, list(handler), parentenv, environment(), FALSE))
      expr
    }
    value <- doTryCatch(return(expr), name, parentenv, handler)
    if (is.null(value[[1]])) {
      msg <- .Internal(geterrmessage())
      call <- value[[2]]
      cond <- simpleError(msg, call)
    }
    else if (is.character(value[[1]])) {
      msg <- value[[1]]
      call <- value[[2]]
      cond <- simpleError(msg, call)
    }
    else cond <- value[[1]]
    value[[3]](cond)
  }
  if (!missing(finally)) 
    on.exit(finally)
  handlers <- list(...)
  classes <- names(handlers)
  parentenv <- parent.frame()
  if (length(classes) != length(handlers)) 
    stop("condition handlers must be specified with a condition class")
  tryCatchList(expr, classes, parentenv, handlers)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
tryInvokeRestart
list(`package:base` = function (r, ...) 
{
  if (!isRestart(r)) 
    r <- findRestart(r)
  if (is.null(r)) 
    invisible(NULL)
  else .Internal(.invokeRestart(r, list(...)))
}, function (r, ...) 
{
  if (!isRestart(r)) 
    r <- findRestart(r)
  if (is.null(r)) 
    invisible(NULL)
  else .Internal(.invokeRestart(r, list(...)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
typeof
list(`package:base` = function (x) 
  .Internal(typeof(x)), function (x) 
    .Internal(typeof(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unclass
list(`package:base` = .Primitive("unclass"), .Primitive("unclass"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
undebug
list(`package:base` = function (fun, signature = NULL) 
{
  if (is.null(signature)) 
    .Internal(undebug(fun))
  else if (requireNamespace("methods")) 
    methods::.undebugMethod(fun, signature = signature)
  else stop("failed to load methods package for undebugging by signature")
}, function (fun, signature = NULL) 
{
  if (is.null(signature)) 
    .Internal(undebug(fun))
  else if (requireNamespace("methods")) 
    methods::.undebugMethod(fun, signature = signature)
  else stop("failed to load methods package for undebugging by signature")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
union
list(`package:base` = function (x, y) 
{
  u <- as.vector(x)
  v <- as.vector(y)
  unique(c(u, v))
}, function (x, y, ...) 
  UseMethod("union"), function (x, y) 
  {
    u <- as.vector(x)
    v <- as.vector(y)
    unique(c(u, v))
  })
c("package:base", "namespace:generics", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
unique
list(`package:base` = function (x, incomparables = FALSE, ...) 
  UseMethod("unique"), function (x, incomparables = FALSE, ...) 
    UseMethod("unique"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unique.array
list(`package:base` = function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (length(MARGIN) != 1 || (MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  args <- rep(alist(a = ), ndim)
  names(args) <- NULL
  args[[MARGIN]] <- !duplicated.default(temp, fromLast = fromLast, ...)
  do.call(`[`, c(list(x), args, list(drop = FALSE)))
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (length(MARGIN) != 1 || (MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  args <- rep(alist(a = ), ndim)
  names(args) <- NULL
  args[[MARGIN]] <- !duplicated.default(temp, fromLast = fromLast, ...)
  do.call(`[`, c(list(x), args, list(drop = FALSE)))
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (length(MARGIN) != 1 || (MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  args <- rep(alist(a = ), ndim)
  names(args) <- NULL
  args[[MARGIN]] <- !duplicated.default(temp, fromLast = fromLast, ...)
  do.call(`[`, c(list(x), args, list(drop = FALSE)))
})
c("package:base", "registered S3 method for unique from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
unique.data.frame
list(`package:base` = function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  x[!duplicated(x, fromLast = fromLast, ...), , drop = FALSE]
}, function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  x[!duplicated(x, fromLast = fromLast, ...), , drop = FALSE]
}, function (x, incomparables = FALSE, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  x[!duplicated(x, fromLast = fromLast, ...), , drop = FALSE]
})
c("package:base", "registered S3 method for unique from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
unique.default
list(`package:base` = function (x, incomparables = FALSE, fromLast = FALSE, nmax = NA, ...) 
{
  if (!is.object(x)) 
    return(.Internal(unique(x, incomparables, fromLast, nmax)))
  if (is.factor(x)) {
    z <- .Internal(unique(x, incomparables, fromLast, min(length(x), nlevels(x) + 1)))
    return(factor(z, levels = seq_len(nlevels(x)), labels = levels(x), ordered = is.ordered(x)))
  }
  z <- .Internal(unique(x, incomparables, fromLast, nmax))
  if (inherits(x, "POSIXct")) 
    structure(z, class = class(x), tzone = attr(x, "tzone"))
  else if (inherits(x, "Date")) 
    structure(z, class = class(x))
  else z
}, function (x, incomparables = FALSE, fromLast = FALSE, nmax = NA, ...) 
{
  if (!is.object(x)) 
    return(.Internal(unique(x, incomparables, fromLast, nmax)))
  if (is.factor(x)) {
    z <- .Internal(unique(x, incomparables, fromLast, min(length(x), nlevels(x) + 1)))
    return(factor(z, levels = seq_len(nlevels(x)), labels = levels(x), ordered = is.ordered(x)))
  }
  z <- .Internal(unique(x, incomparables, fromLast, nmax))
  if (inherits(x, "POSIXct")) 
    structure(z, class = class(x), tzone = attr(x, "tzone"))
  else if (inherits(x, "Date")) 
    structure(z, class = class(x))
  else z
}, function (x, incomparables = FALSE, fromLast = FALSE, nmax = NA, ...) 
{
  if (!is.object(x)) 
    return(.Internal(unique(x, incomparables, fromLast, nmax)))
  if (is.factor(x)) {
    z <- .Internal(unique(x, incomparables, fromLast, min(length(x), nlevels(x) + 1)))
    return(factor(z, levels = seq_len(nlevels(x)), labels = levels(x), ordered = is.ordered(x)))
  }
  z <- .Internal(unique(x, incomparables, fromLast, nmax))
  if (inherits(x, "POSIXct")) 
    structure(z, class = class(x), tzone = attr(x, "tzone"))
  else if (inherits(x, "Date")) 
    structure(z, class = class(x))
  else z
})
c("package:base", "registered S3 method for unique from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
unique.matrix
list(`package:base` = function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (length(MARGIN) != 1 || (MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  args <- rep(alist(a = ), ndim)
  names(args) <- NULL
  args[[MARGIN]] <- !duplicated.default(temp, fromLast = fromLast, ...)
  do.call(`[`, c(list(x), args, list(drop = FALSE)))
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (length(MARGIN) != 1 || (MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  args <- rep(alist(a = ), ndim)
  names(args) <- NULL
  args[[MARGIN]] <- !duplicated.default(temp, fromLast = fromLast, ...)
  do.call(`[`, c(list(x), args, list(drop = FALSE)))
}, function (x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...) 
{
  if (!isFALSE(incomparables)) 
    .NotYetUsed("incomparables != FALSE")
  dx <- dim(x)
  ndim <- length(dx)
  if (length(MARGIN) != 1 || (MARGIN > ndim)) 
    stop(gettextf("MARGIN = %s is invalid for dim = %s", paste(MARGIN, collapse = ","), paste(dx, collapse = ",")), domain = NA)
  temp <- if ((ndim > 1) && (prod(dx[-MARGIN]) > 1)) 
    asplit(x, MARGIN)
  else x
  args <- rep(alist(a = ), ndim)
  names(args) <- NULL
  args[[MARGIN]] <- !duplicated.default(temp, fromLast = fromLast, ...)
  do.call(`[`, c(list(x), args, list(drop = FALSE)))
})
c("package:base", "registered S3 method for unique from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
unique.numeric_version
list(`package:base` = function (x, incomparables = FALSE, ...) 
  x[!duplicated(x, incomparables, ...)], function (x, incomparables = FALSE, ...) 
    x[!duplicated(x, incomparables, ...)], function (x, incomparables = FALSE, ...) 
      x[!duplicated(x, incomparables, ...)])
c("package:base", "registered S3 method for unique from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
unique.POSIXlt
list(`package:base` = function (x, incomparables = FALSE, ...) 
  x[!duplicated(x, incomparables, ...)], function (x, incomparables = FALSE, ...) 
    x[!duplicated(x, incomparables, ...)], function (x, incomparables = FALSE, ...) 
      x[!duplicated(x, incomparables, ...)])
c("package:base", "registered S3 method for unique from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
unique.warnings
list(`package:base` = function (x, incomparables = FALSE, ...) 
  x[!duplicated(x, incomparables, ...)], function (x, incomparables = FALSE, ...) 
    x[!duplicated(x, incomparables, ...)], function (x, incomparables = FALSE, ...) 
      x[!duplicated(x, incomparables, ...)])
c("package:base", "registered S3 method for unique from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
units
list(`package:base` = function (x) 
  UseMethod("units"), list(`0` = "npc", `1` = "cm", `2` = "inches", `3` = "lines", `4` = "native", `5` = "null", `6` = "snpc", `7` = "mm", `8` = "points", `9` = "picas", `10` = "bigpts", `11` = "dida", `12` = "cicero", `13` = "scaledpts", `14` = "strwidth", `15` = "strheight", `16` = "strascent", `17` = "strdescent", `18` = "char", `19` = "grobx", `20` = "groby", `21` = "grobwidth", `22` = "grobheight", `23` = "grobascent", `24` = "grobdescent", `103` = "mylines", `104` = "mychar", `105` = "mystrwidth", 
                           `106` = "mystrheight", `201` = "sum", `202` = "min", `203` = "max", `1001` = "centimetre", `1001` = "centimetres", `1001` = "centimeter", `1001` = "centimeters", `1002` = "in", `1002` = "inch", `1003` = "line", `1007` = "millimetre", `1007` = "millimetres", `1007` = "millimeter", `1007` = "millimeters", `1008` = "point", `1008` = "pt"), function (x) 
                             UseMethod("units"))
c("package:base", "namespace:grid", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
units.difftime
list(`package:base` = function (x) 
  attr(x, "units"), function (x) 
    attr(x, "units"), function (x) 
      attr(x, "units"))
c("package:base", "registered S3 method for units from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
units<-
  list(`package:base` = function (x, value) 
    UseMethod("units<-"), function (x, value) 
      UseMethod("units<-"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
units<-.difftime
list(`package:base` = function (x, value) 
{
  from <- units(x)
  if (from == value) 
    return(x)
  if (!(value %in% c("secs", "mins", "hours", "days", "weeks"))) 
    stop("invalid units specified")
  sc <- cumprod(c(secs = 1, mins = 60, hours = 60, days = 24, weeks = 7))
  newx <- unclass(x) * as.vector(sc[from]/sc[value])
  .difftime(newx, value)
}, function (x, value) 
{
  from <- units(x)
  if (from == value) 
    return(x)
  if (!(value %in% c("secs", "mins", "hours", "days", "weeks"))) 
    stop("invalid units specified")
  sc <- cumprod(c(secs = 1, mins = 60, hours = 60, days = 24, weeks = 7))
  newx <- unclass(x) * as.vector(sc[from]/sc[value])
  .difftime(newx, value)
}, function (x, value) 
{
  from <- units(x)
  if (from == value) 
    return(x)
  if (!(value %in% c("secs", "mins", "hours", "days", "weeks"))) 
    stop("invalid units specified")
  sc <- cumprod(c(secs = 1, mins = 60, hours = 60, days = 24, weeks = 7))
  newx <- unclass(x) * as.vector(sc[from]/sc[value])
  .difftime(newx, value)
})
c("package:base", "registered S3 method for units<- from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
unix.time
list(`package:base` = function (...) 
  .Defunct("system.time"), function (...) 
    .Defunct("system.time"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unlink
list(`package:base` = function (x, recursive = FALSE, force = FALSE, expand = TRUE) 
  .Internal(unlink(as.character(x), recursive, force, expand)), function (x, recursive = FALSE, force = FALSE, expand = TRUE) 
    .Internal(unlink(as.character(x), recursive, force, expand)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unlist
list(`package:base` = function (x, recursive = TRUE, use.names = TRUE) 
{
  if (.Internal(islistfactor(x, recursive))) {
    URapply <- if (recursive) 
      function(x, Fn) .Internal(unlist(rapply(x, Fn, how = "list"), recursive, FALSE))
    else function(x, Fn) .Internal(unlist(lapply(x, Fn), recursive, FALSE))
    lv <- unique(URapply(x, levels))
    nm <- if (use.names) 
      names(.Internal(unlist(x, recursive, use.names)))
    res <- match(URapply(x, as.character), lv)
    structure(res, levels = lv, names = nm, class = "factor")
  }
  else .Internal(unlist(x, recursive, use.names))
}, function (x, recursive = TRUE, use.names = TRUE) 
{
  if (.Internal(islistfactor(x, recursive))) {
    URapply <- if (recursive) 
      function(x, Fn) .Internal(unlist(rapply(x, Fn, how = "list"), recursive, FALSE))
    else function(x, Fn) .Internal(unlist(lapply(x, Fn), recursive, FALSE))
    lv <- unique(URapply(x, levels))
    nm <- if (use.names) 
      names(.Internal(unlist(x, recursive, use.names)))
    res <- match(URapply(x, as.character), lv)
    structure(res, levels = lv, names = nm, class = "factor")
  }
  else .Internal(unlist(x, recursive, use.names))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unloadNamespace
list(`package:base` = function (ns) 
{
  if ((is.character(ns) && any(ns == loadedNamespaces())) || (is.environment(ns) && any(getNamespaceName(ns) == loadedNamespaces()))) {
    runHook <- function(hookname, env, ...) {
      if (!is.null(fun <- env[[hookname]])) {
        res <- tryCatch(fun(...), error = identity)
        if (inherits(res, "error")) {
          warning(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", hookname, "unloadNamespace", nsname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
        }
      }
    }
    ns <- asNamespace(ns, base.OK = FALSE)
    nsname <- getNamespaceName(ns)
    pos <- match(paste0("package:", nsname), search())
    if (!is.na(pos)) 
      detach(pos = pos)
    users <- getNamespaceUsers(ns)
    if (length(users)) 
      stop(gettextf("namespace %s is imported by %s so cannot be unloaded", sQuote(getNamespaceName(ns)), paste(sQuote(users), collapse = ", ")), domain = NA)
    nspath <- .getNamespaceInfo(ns, "path")
    hook <- getHook(packageEvent(nsname, "onUnload"))
    for (fun in rev(hook)) try(fun(nsname, nspath))
    runHook(".onUnload", ns, nspath)
    .Internal(unregisterNamespace(nsname))
    if (.isMethodsDispatchOn() && methods:::.hasS4MetaData(ns)) 
      methods::cacheMetaData(ns, FALSE, ns)
    .Internal(lazyLoadDBflush(paste0(nspath, "/R/", nsname, ".rdb")))
  }
  invisible()
}, function (ns) 
{
  if ((is.character(ns) && any(ns == loadedNamespaces())) || (is.environment(ns) && any(getNamespaceName(ns) == loadedNamespaces()))) {
    runHook <- function(hookname, env, ...) {
      if (!is.null(fun <- env[[hookname]])) {
        res <- tryCatch(fun(...), error = identity)
        if (inherits(res, "error")) {
          warning(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", hookname, "unloadNamespace", nsname, deparse(conditionCall(res))[1], conditionMessage(res)), call. = FALSE, domain = NA)
        }
      }
    }
    ns <- asNamespace(ns, base.OK = FALSE)
    nsname <- getNamespaceName(ns)
    pos <- match(paste0("package:", nsname), search())
    if (!is.na(pos)) 
      detach(pos = pos)
    users <- getNamespaceUsers(ns)
    if (length(users)) 
      stop(gettextf("namespace %s is imported by %s so cannot be unloaded", sQuote(getNamespaceName(ns)), paste(sQuote(users), collapse = ", ")), domain = NA)
    nspath <- .getNamespaceInfo(ns, "path")
    hook <- getHook(packageEvent(nsname, "onUnload"))
    for (fun in rev(hook)) try(fun(nsname, nspath))
    runHook(".onUnload", ns, nspath)
    .Internal(unregisterNamespace(nsname))
    if (.isMethodsDispatchOn() && methods:::.hasS4MetaData(ns)) 
      methods::cacheMetaData(ns, FALSE, ns)
    .Internal(lazyLoadDBflush(paste0(nspath, "/R/", nsname, ".rdb")))
  }
  invisible()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unlockBinding
list(`package:base` = function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(unlockBinding(sym, env))
}, function (sym, env) 
{
  if (is.character(sym)) 
    sym <- as.name(sym)
  .Internal(unlockBinding(sym, env))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unname
list(`package:base` = function (obj, force = FALSE) 
{
  if (!is.null(names(obj))) 
    names(obj) <- NULL
  if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) 
    dimnames(obj) <- NULL
  obj
}, new("standardGeneric", .Data = function (obj, force = FALSE) 
  standardGeneric("unname"), generic = "unname", package = "base", group = list(), valueClass = character(0), signature = c("obj", "force"), default = new("derivedDefaultMethod", .Data = function (obj, force = FALSE) 
  {
    if (!is.null(names(obj))) 
      names(obj) <- NULL
    if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) 
      dimnames(obj) <- NULL
    obj
  }, target = new("signature", .Data = "ANY", names = "obj", package = "methods"), defined = new("signature", .Data = "ANY", names = "obj", package = "methods"), generic = "unname"), skeleton = (new("derivedDefaultMethod", .Data = function (obj, force = FALSE) 
  {
    if (!is.null(names(obj))) 
      names(obj) <- NULL
    if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) 
      dimnames(obj) <- NULL
    obj
  }, target = new("signature", .Data = "ANY", names = "obj", package = "methods"), defined = new("signature", .Data = "ANY", names = "obj", package = "methods"), generic = "unname"))(obj, force)), function (obj, force = FALSE) 
  {
    if (!is.null(names(obj))) 
      names(obj) <- NULL
    if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) 
      dimnames(obj) <- NULL
    obj
  })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
unserialize
list(`package:base` = function (connection, refhook = NULL) 
{
  if (typeof(connection) != "raw" && !is.character(connection) && !inherits(connection, "connection")) 
    stop("'connection' must be a connection")
  .Internal(unserialize(connection, refhook))
}, function (connection, refhook = NULL) 
{
  if (typeof(connection) != "raw" && !is.character(connection) && !inherits(connection, "connection")) 
    stop("'connection' must be a connection")
  .Internal(unserialize(connection, refhook))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unsplit
list(`package:base` = function (value, f, drop = FALSE) 
{
  len <- length(if (is.list(f)) f[[1]] else f)
  if (is.data.frame(value[[1]])) {
    x <- value[[1]][rep(NA, len), , drop = FALSE]
    rownames(x) <- unsplit(lapply(value, rownames), f, drop = drop)
  }
  else x <- value[[1]][rep(NA, len)]
  split(x, f, drop = drop) <- value
  x
}, function (value, f, drop = FALSE) 
{
  len <- length(if (is.list(f)) f[[1]] else f)
  if (is.data.frame(value[[1]])) {
    x <- value[[1]][rep(NA, len), , drop = FALSE]
    rownames(x) <- unsplit(lapply(value, rownames), f, drop = drop)
  }
  else x <- value[[1]][rep(NA, len)]
  split(x, f, drop = drop) <- value
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
untrace
list(`package:base` = function (what, signature = NULL, where = topenv(parent.frame())) 
{
  if (!.isMethodsDispatchOn()) 
    return(.primUntrace(what))
  tState <- tracingState(FALSE)
  on.exit(tracingState(tState))
  call <- sys.call()
  call[[1]] <- quote(methods::.TraceWithMethods)
  call$where <- where
  call$untrace <- TRUE
  invisible(eval.parent(call))
}, function (what, signature = NULL, where = topenv(parent.frame())) 
{
  if (!.isMethodsDispatchOn()) 
    return(.primUntrace(what))
  tState <- tracingState(FALSE)
  on.exit(tracingState(tState))
  call <- sys.call()
  call[[1]] <- quote(methods::.TraceWithMethods)
  call$where <- where
  call$untrace <- TRUE
  invisible(eval.parent(call))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
untracemem
list(`package:base` = .Primitive("untracemem"), .Primitive("untracemem"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
unz
list(`package:base` = function (description, filename, open = "", encoding = getOption("encoding")) 
  .Internal(unz(paste(description, filename, sep = ":"), open, encoding)), function (description, filename, open = "", encoding = getOption("encoding")) 
    .Internal(unz(paste(description, filename, sep = ":"), open, encoding)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
upper.tri
list(`package:base` = function (x, diag = FALSE) 
{
  d <- dim(x)
  if (length(d) != 2) 
    d <- dim(as.matrix(x))
  if (diag) 
    .row(d) <= .col(d)
  else .row(d) < .col(d)
}, function (x, diag = FALSE) 
{
  d <- dim(x)
  if (length(d) != 2) 
    d <- dim(as.matrix(x))
  if (diag) 
    .row(d) <= .col(d)
  else .row(d) < .col(d)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
url
list(`package:base` = function (description, open = "", blocking = TRUE, encoding = getOption("encoding"), method = getOption("url.method", "default"), headers = NULL) 
{
  method <- match.arg(method, c("default", "internal", "libcurl", "wininet"))
  if (!is.null(headers)) {
    nh <- names(headers)
    if (length(nh) != length(headers) || any(nh == "") || anyNA(headers) || anyNA(nh)) 
      stop("'headers' must have names and must not be NA")
    headers <- paste0(nh, ": ", headers)
    headers <- list(headers, paste0(headers, "\r\n", collapse = ""))
  }
  .Internal(url(description, open, blocking, encoding, method, headers))
}, function (description, open = "", blocking = TRUE, encoding = getOption("encoding"), method = getOption("url.method", "default"), headers = NULL) 
{
  method <- match.arg(method, c("default", "internal", "libcurl", "wininet"))
  if (!is.null(headers)) {
    nh <- names(headers)
    if (length(nh) != length(headers) || any(nh == "") || anyNA(headers) || anyNA(nh)) 
      stop("'headers' must have names and must not be NA")
    headers <- paste0(nh, ": ", headers)
    headers <- list(headers, paste0(headers, "\r\n", collapse = ""))
  }
  .Internal(url(description, open, blocking, encoding, method, headers))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
UseMethod
list(`package:base` = .Primitive("UseMethod"), .Primitive("UseMethod"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
utf8ToInt
list(`package:base` = function (x) 
  .Internal(utf8ToInt(x)), function (x) 
    .Internal(utf8ToInt(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
validEnc
list(`package:base` = function (x) 
  .Internal(validEnc(x)), function (x) 
    .Internal(validEnc(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
validUTF8
list(`package:base` = function (x) 
  .Internal(validUTF8(x)), function (x) 
    .Internal(validUTF8(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
vapply
list(`package:base` = function (X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE) 
{
  FUN <- match.fun(FUN)
  if (!is.vector(X) || is.object(X)) 
    X <- as.list(X)
  .Internal(vapply(X, FUN, FUN.VALUE, USE.NAMES))
}, function (X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE) 
{
  FUN <- match.fun(FUN)
  if (!is.vector(X) || is.object(X)) 
    X <- as.list(X)
  .Internal(vapply(X, FUN, FUN.VALUE, USE.NAMES))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
vector
list(`package:base` = function (mode = "logical", length = 0) 
  .Internal(vector(mode, length)), function (mode = "logical", length = 0) 
    .Internal(vector(mode, length)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
Vectorize
list(`package:base` = function (FUN, vectorize.args = arg.names, SIMPLIFY = TRUE, USE.NAMES = TRUE) 
{
  arg.names <- as.list(formals(FUN))
  arg.names[["..."]] <- NULL
  arg.names <- names(arg.names)
  vectorize.args <- as.character(vectorize.args)
  if (!length(vectorize.args)) 
    return(FUN)
  if (!all(vectorize.args %in% arg.names)) 
    stop("must specify names of formal arguments for 'vectorize'")
  collisions <- arg.names %in% c("FUN", "SIMPLIFY", "USE.NAMES", "vectorize.args")
  if (any(collisions)) 
    stop(sQuote("FUN"), " may not have argument(s) named ", paste(sQuote(arg.names[collisions]), collapse = ", "))
  rm(arg.names, collisions)
  (function() {
    FUNV <- function() {
      args <- lapply(as.list(match.call())[-1], eval, parent.frame())
      names <- if (is.null(names(args))) 
        character(length(args))
      else names(args)
      dovec <- names %in% vectorize.args
      do.call("mapply", c(FUN = FUN, args[dovec], MoreArgs = list(args[!dovec]), SIMPLIFY = SIMPLIFY, USE.NAMES = USE.NAMES))
    }
    formals(FUNV) <- formals(FUN)
    environment(FUNV) <- parent.env(environment())
    FUNV
  })()
}, function (FUN, vectorize.args = arg.names, SIMPLIFY = TRUE, USE.NAMES = TRUE) 
{
  arg.names <- as.list(formals(FUN))
  arg.names[["..."]] <- NULL
  arg.names <- names(arg.names)
  vectorize.args <- as.character(vectorize.args)
  if (!length(vectorize.args)) 
    return(FUN)
  if (!all(vectorize.args %in% arg.names)) 
    stop("must specify names of formal arguments for 'vectorize'")
  collisions <- arg.names %in% c("FUN", "SIMPLIFY", "USE.NAMES", "vectorize.args")
  if (any(collisions)) 
    stop(sQuote("FUN"), " may not have argument(s) named ", paste(sQuote(arg.names[collisions]), collapse = ", "))
  rm(arg.names, collisions)
  (function() {
    FUNV <- function() {
      args <- lapply(as.list(match.call())[-1], eval, parent.frame())
      names <- if (is.null(names(args))) 
        character(length(args))
      else names(args)
      dovec <- names %in% vectorize.args
      do.call("mapply", c(FUN = FUN, args[dovec], MoreArgs = list(args[!dovec]), SIMPLIFY = SIMPLIFY, USE.NAMES = USE.NAMES))
    }
    formals(FUNV) <- formals(FUN)
    environment(FUNV) <- parent.env(environment())
    FUNV
  })()
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
version
list(`package:base` = list(platform = "x86_64-w64-mingw32", arch = "x86_64", os = "mingw32", crt = "ucrt", system = "x86_64, mingw32", status = "", major = "4", minor = "2.1", year = "2022", month = "06", day = "23", `svn rev` = "82513", language = "R", version.string = "R version 4.2.1 (2022-06-23 ucrt)", nickname = "Funny-Looking Kid"), list(platform = "x86_64-w64-mingw32", arch = "x86_64", os = "mingw32", crt = "ucrt", system = "x86_64, mingw32", status = "", major = "4", minor = "2.1", year = "2022", 
                                                                                                                                                                                                                                                                                                                                                          month = "06", day = "23", `svn rev` = "82513", language = "R", version.string = "R version 4.2.1 (2022-06-23 ucrt)", nickname = "Funny-Looking Kid"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
warning
list(`package:base` = function (..., call. = TRUE, immediate. = FALSE, noBreaks. = FALSE, domain = NULL) 
{
  if (...length() == 1 && inherits(..1, "condition")) {
    cond <- ..1
    if (nargs() > 1) 
      cat(gettext("additional arguments ignored in warning()"), "\n", sep = "", file = stderr())
    message <- conditionMessage(cond)
    call <- conditionCall(cond)
    withRestarts({
      .Internal(.signalCondition(cond, message, call))
      .Internal(.dfltWarn(message, call))
    }, muffleWarning = function() NULL)
    invisible(message)
  }
  else .Internal(warning(call., immediate., noBreaks., .makeMessage(..., domain = domain)))
}, function (..., call. = TRUE, immediate. = FALSE, noBreaks. = FALSE, domain = NULL) 
{
  if (...length() == 1 && inherits(..1, "condition")) {
    cond <- ..1
    if (nargs() > 1) 
      cat(gettext("additional arguments ignored in warning()"), "\n", sep = "", file = stderr())
    message <- conditionMessage(cond)
    call <- conditionCall(cond)
    withRestarts({
      .Internal(.signalCondition(cond, message, call))
      .Internal(.dfltWarn(message, call))
    }, muffleWarning = function() NULL)
    invisible(message)
  }
  else .Internal(warning(call., immediate., noBreaks., .makeMessage(..., domain = domain)))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
warningCondition
list(`package:base` = function (message, ..., class = NULL, call = NULL) 
  structure(list(message = as.character(message), call = call, ...), class = c(class, "warning", "condition")), function (message, ..., class = NULL, call = NULL) 
    structure(list(message = as.character(message), call = call, ...), class = c(class, "warning", "condition")))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
warnings
list(`package:base` = function (...) 
{
  if (length(last.warning <- baseenv()[["last.warning"]])) 
    structure(last.warning, dots = list(...), class = "warnings")
}, function (...) 
{
  if (length(last.warning <- baseenv()[["last.warning"]])) 
    structure(last.warning, dots = list(...), class = "warnings")
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
weekdays
list(`package:base` = function (x, abbreviate) 
  UseMethod("weekdays"), function (x, abbreviate) 
    UseMethod("weekdays"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
weekdays.Date
list(`package:base` = function (x, abbreviate = FALSE) 
  format(x, ifelse(abbreviate, "%a", "%A")), function (x, abbreviate = FALSE) 
    format(x, ifelse(abbreviate, "%a", "%A")), function (x, abbreviate = FALSE) 
      format(x, ifelse(abbreviate, "%a", "%A")))
c("package:base", "registered S3 method for weekdays from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
weekdays.POSIXt
list(`package:base` = function (x, abbreviate = FALSE) 
{
  format(x, ifelse(abbreviate, "%a", "%A"))
}, function (x, abbreviate = FALSE) 
{
  format(x, ifelse(abbreviate, "%a", "%A"))
}, function (x, abbreviate = FALSE) 
{
  format(x, ifelse(abbreviate, "%a", "%A"))
})
c("package:base", "registered S3 method for weekdays from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
which
list(`package:base` = function (x, arr.ind = FALSE, useNames = TRUE) 
{
  wh <- .Internal(which(x))
  if (isTRUE(arr.ind) && !is.null(d <- dim(x))) 
    arrayInd(wh, d, dimnames(x), useNames = useNames)
  else wh
}, new("standardGeneric", .Data = function (x, arr.ind = FALSE, useNames = TRUE) 
  standardGeneric("which"), generic = "which", package = "base", group = list(), valueClass = character(0), signature = c("x", "arr.ind", "useNames"), default = new("derivedDefaultMethod", .Data = function (x, arr.ind = FALSE, useNames = TRUE) 
  {
    wh <- .Internal(which(x))
    if (isTRUE(arr.ind) && !is.null(d <- dim(x))) 
      arrayInd(wh, d, dimnames(x), useNames = useNames)
    else wh
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "which"), skeleton = (new("derivedDefaultMethod", .Data = function (x, arr.ind = FALSE, useNames = TRUE) 
  {
    wh <- .Internal(which(x))
    if (isTRUE(arr.ind) && !is.null(d <- dim(x))) 
      arrayInd(wh, d, dimnames(x), useNames = useNames)
    else wh
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "which"))(x, arr.ind, useNames)), function (x, arr.ind = FALSE, useNames = TRUE) 
  {
    wh <- .Internal(which(x))
    if (isTRUE(arr.ind) && !is.null(d <- dim(x))) 
      arrayInd(wh, d, dimnames(x), useNames = useNames)
    else wh
  })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
which.max
list(`package:base` = function (x) 
  .Internal(which.max(x)), function (x) 
    .Internal(which.max(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
which.min
list(`package:base` = function (x) 
  .Internal(which.min(x)), function (x) 
    .Internal(which.min(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
while
list(`package:base` = .Primitive("while"), .Primitive("while"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
with
list(`package:base` = function (data, expr, ...) 
  UseMethod("with"), function (data, expr, ...) 
    UseMethod("with"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
with.default
list(`package:base` = function (data, expr, ...) 
  eval(substitute(expr), data, enclos = parent.frame()), function (data, expr, ...) 
    eval(substitute(expr), data, enclos = parent.frame()), function (data, expr, ...) 
      eval(substitute(expr), data, enclos = parent.frame()))
c("package:base", "registered S3 method for with from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
withAutoprint
list(`package:base` = function (exprs, evaluated = FALSE, local = parent.frame(), print. = TRUE, echo = TRUE, max.deparse.length = Inf, width.cutoff = max(20, getOption("width")), deparseCtrl = c("keepInteger", "showAttributes", "keepNA"), ...) 
{
  if (!evaluated) {
    exprs <- substitute(exprs)
    if (is.call(exprs)) {
      if (exprs[[1]] == quote(`{`)) 
        exprs <- as.list(exprs[-1])
    }
  }
  source(exprs = exprs, local = local, print.eval = print., echo = echo, max.deparse.length = max.deparse.length, width.cutoff = width.cutoff, deparseCtrl = deparseCtrl, ...)
}, function (exprs, evaluated = FALSE, local = parent.frame(), print. = TRUE, echo = TRUE, max.deparse.length = Inf, width.cutoff = max(20, getOption("width")), deparseCtrl = c("keepInteger", "showAttributes", "keepNA"), ...) 
{
  if (!evaluated) {
    exprs <- substitute(exprs)
    if (is.call(exprs)) {
      if (exprs[[1]] == quote(`{`)) 
        exprs <- as.list(exprs[-1])
    }
  }
  source(exprs = exprs, local = local, print.eval = print., echo = echo, max.deparse.length = max.deparse.length, width.cutoff = width.cutoff, deparseCtrl = deparseCtrl, ...)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
withCallingHandlers
list(`package:base` = function (expr, ...) 
{
  handlers <- list(...)
  classes <- names(handlers)
  parentenv <- parent.frame()
  if (length(classes) != length(handlers)) 
    stop("condition handlers must be specified with a condition class")
  .Internal(.addCondHands(classes, handlers, parentenv, NULL, TRUE))
  expr
}, function (expr, ...) 
{
  handlers <- list(...)
  classes <- names(handlers)
  parentenv <- parent.frame()
  if (length(classes) != length(handlers)) 
    stop("condition handlers must be specified with a condition class")
  .Internal(.addCondHands(classes, handlers, parentenv, NULL, TRUE))
  expr
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
within
list(`package:base` = function (data, expr, ...) 
  UseMethod("within"), function (data, expr, ...) 
    UseMethod("within"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
within.data.frame
list(`package:base` = function (data, expr, ...) 
{
  parent <- parent.frame()
  e <- evalq(environment(), data, parent)
  eval(substitute(expr), e)
  l <- as.list(e, all.names = TRUE)
  l <- l[!vapply(l, is.null, NA, USE.NAMES = FALSE)]
  nl <- names(l)
  del <- setdiff(names(data), nl)
  data[nl] <- l
  data[del] <- NULL
  data
}, function (data, expr, ...) 
{
  parent <- parent.frame()
  e <- evalq(environment(), data, parent)
  eval(substitute(expr), e)
  l <- as.list(e, all.names = TRUE)
  l <- l[!vapply(l, is.null, NA, USE.NAMES = FALSE)]
  nl <- names(l)
  del <- setdiff(names(data), nl)
  data[nl] <- l
  data[del] <- NULL
  data
}, function (data, expr, ...) 
{
  parent <- parent.frame()
  e <- evalq(environment(), data, parent)
  eval(substitute(expr), e)
  l <- as.list(e, all.names = TRUE)
  l <- l[!vapply(l, is.null, NA, USE.NAMES = FALSE)]
  nl <- names(l)
  del <- setdiff(names(data), nl)
  data[nl] <- l
  data[del] <- NULL
  data
})
c("package:base", "registered S3 method for within from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
within.list
list(`package:base` = function (data, expr, keepAttrs = TRUE, ...) 
{
  parent <- parent.frame()
  e <- evalq(environment(), data, parent)
  eval(substitute(expr), e)
  if (keepAttrs) {
    l <- as.list(e, all.names = TRUE)
    nl <- names(l)
    del <- setdiff(names(data), nl)
    data[nl] <- l
    data[del] <- NULL
    data
  }
  else {
    as.list(e, all.names = TRUE)
  }
}, function (data, expr, keepAttrs = TRUE, ...) 
{
  parent <- parent.frame()
  e <- evalq(environment(), data, parent)
  eval(substitute(expr), e)
  if (keepAttrs) {
    l <- as.list(e, all.names = TRUE)
    nl <- names(l)
    del <- setdiff(names(data), nl)
    data[nl] <- l
    data[del] <- NULL
    data
  }
  else {
    as.list(e, all.names = TRUE)
  }
}, function (data, expr, keepAttrs = TRUE, ...) 
{
  parent <- parent.frame()
  e <- evalq(environment(), data, parent)
  eval(substitute(expr), e)
  if (keepAttrs) {
    l <- as.list(e, all.names = TRUE)
    nl <- names(l)
    del <- setdiff(names(data), nl)
    data[nl] <- l
    data[del] <- NULL
    data
  }
  else {
    as.list(e, all.names = TRUE)
  }
})
c("package:base", "registered S3 method for within from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
withRestarts
list(`package:base` = function (expr, ...) 
{
  docall <- function(fun, args) {
    if ((is.character(fun) && length(fun) == 1) || is.name(fun)) 
      fun <- get(as.character(fun), envir = parent.frame(), mode = "function")
    do.call("fun", lapply(args, enquote))
  }
  makeRestart <- function(name = "", handler = function(...) NULL, description = "", test = function(c) TRUE, interactive = NULL) {
    structure(list(name = name, exit = NULL, handler = handler, description = description, test = test, interactive = interactive), class = "restart")
  }
  makeRestartList <- function(...) {
    specs <- list(...)
    names <- names(specs)
    restarts <- vector("list", length(specs))
    for (i in seq_along(specs)) {
      spec <- specs[[i]]
      name <- names[i]
      if (is.function(spec)) 
        restarts[[i]] <- makeRestart(handler = spec)
      else if (is.character(spec)) 
        restarts[[i]] <- makeRestart(description = spec)
      else if (is.list(spec)) 
        restarts[[i]] <- docall("makeRestart", spec)
      else stop("not a valid restart specification")
      restarts[[i]]$name <- name
    }
    restarts
  }
  withOneRestart <- function(expr, restart) {
    doWithOneRestart <- function(expr, restart) {
      restart$exit <- environment()
      .Internal(.addRestart(restart))
      expr
    }
    restartArgs <- doWithOneRestart(return(expr), restart)
    docall(restart$handler, restartArgs)
  }
  withRestartList <- function(expr, restarts) {
    nr <- length(restarts)
    if (nr > 1) 
      withOneRestart(withRestartList(expr, restarts[-nr]), restarts[[nr]])
    else if (nr == 1) 
      withOneRestart(expr, restarts[[1]])
    else expr
  }
  restarts <- makeRestartList(...)
  if (length(restarts) == 0) 
    expr
  else if (length(restarts) == 1) 
    withOneRestart(expr, restarts[[1]])
  else withRestartList(expr, restarts)
}, function (expr, ...) 
{
  docall <- function(fun, args) {
    if ((is.character(fun) && length(fun) == 1) || is.name(fun)) 
      fun <- get(as.character(fun), envir = parent.frame(), mode = "function")
    do.call("fun", lapply(args, enquote))
  }
  makeRestart <- function(name = "", handler = function(...) NULL, description = "", test = function(c) TRUE, interactive = NULL) {
    structure(list(name = name, exit = NULL, handler = handler, description = description, test = test, interactive = interactive), class = "restart")
  }
  makeRestartList <- function(...) {
    specs <- list(...)
    names <- names(specs)
    restarts <- vector("list", length(specs))
    for (i in seq_along(specs)) {
      spec <- specs[[i]]
      name <- names[i]
      if (is.function(spec)) 
        restarts[[i]] <- makeRestart(handler = spec)
      else if (is.character(spec)) 
        restarts[[i]] <- makeRestart(description = spec)
      else if (is.list(spec)) 
        restarts[[i]] <- docall("makeRestart", spec)
      else stop("not a valid restart specification")
      restarts[[i]]$name <- name
    }
    restarts
  }
  withOneRestart <- function(expr, restart) {
    doWithOneRestart <- function(expr, restart) {
      restart$exit <- environment()
      .Internal(.addRestart(restart))
      expr
    }
    restartArgs <- doWithOneRestart(return(expr), restart)
    docall(restart$handler, restartArgs)
  }
  withRestartList <- function(expr, restarts) {
    nr <- length(restarts)
    if (nr > 1) 
      withOneRestart(withRestartList(expr, restarts[-nr]), restarts[[nr]])
    else if (nr == 1) 
      withOneRestart(expr, restarts[[1]])
    else expr
  }
  restarts <- makeRestartList(...)
  if (length(restarts) == 0) 
    expr
  else if (length(restarts) == 1) 
    withOneRestart(expr, restarts[[1]])
  else withRestartList(expr, restarts)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
withVisible
list(`package:base` = function (x) 
  .Internal(withVisible(x)), function (x) 
    .Internal(withVisible(x)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
write
list(`package:base` = function (x, file = "data", ncolumns = if (is.character(x)) 1 else 5, append = FALSE, sep = " ") 
  cat(x, file = file, sep = c(rep.int(sep, ncolumns - 1), "\n"), append = append), function (x, file = "data", ncolumns = if (is.character(x)) 1 else 5, append = FALSE, sep = " ") 
    cat(x, file = file, sep = c(rep.int(sep, ncolumns - 1), "\n"), append = append))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
write.dcf
list(`package:base` = function (x, file = "", append = FALSE, useBytes = FALSE, indent = 0.1 * getOption("width"), width = 0.9 * getOption("width"), keep.white = NULL) 
{
  if (file == "") 
    file <- stdout()
  else if (is.character(file)) {
    file <- file(file, if (append) 
      "a"
      else "w")
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  escape_paragraphs <- function(s) gsub("\n \\.([^\n])", "\n  .\\1", gsub("\n[ \t]*\n", "\n .\n ", s, perl = TRUE, useBytes = TRUE), perl = TRUE, useBytes = TRUE)
  fmt <- function(tag, val, fold = TRUE) {
    s <- if (fold) 
      formatDL(rep.int(tag, length(val)), val, style = "list", width = width, indent = indent)
    else {
      sprintf("%s: %s", tag, gsub("\n([^[:blank:]])", "\n \\1", val))
    }
    escape_paragraphs(s)
  }
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, optional = TRUE, stringsAsFactors = FALSE)
  nmx <- names(x)
  out <- matrix("", nrow(x), ncol(x))
  foldable <- is.na(match(nmx, keep.white))
  for (j in seq_along(x)) {
    xj <- x[[j]]
    if (is.atomic(xj)) {
      i <- !is.na(xj)
      out[i, j] <- fmt(nmx[j], xj[i], foldable[j])
    }
    else {
      nmxj <- nmx[j]
      fold <- foldable[j]
      i <- !vapply(xj, function(s) (length(s) == 1) && is.na(s), NA)
      out[i, j] <- vapply(xj[i], function(s) {
        paste(fmt(nmxj, s, fold), collapse = "\n")
      }, "")
    }
  }
  out <- t(out)
  is_not_empty <- nzchar(out)
  eor <- character(sum(is_not_empty))
  if (length(eor)) {
    eor[which(diff(c(col(out))[is_not_empty]) >= 1)] <- "\n"
  }
  writeLines(paste0(c(out[is_not_empty]), eor), file, useBytes = useBytes)
}, function (x, file = "", append = FALSE, useBytes = FALSE, indent = 0.1 * getOption("width"), width = 0.9 * getOption("width"), keep.white = NULL) 
{
  if (file == "") 
    file <- stdout()
  else if (is.character(file)) {
    file <- file(file, if (append) 
      "a"
      else "w")
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  escape_paragraphs <- function(s) gsub("\n \\.([^\n])", "\n  .\\1", gsub("\n[ \t]*\n", "\n .\n ", s, perl = TRUE, useBytes = TRUE), perl = TRUE, useBytes = TRUE)
  fmt <- function(tag, val, fold = TRUE) {
    s <- if (fold) 
      formatDL(rep.int(tag, length(val)), val, style = "list", width = width, indent = indent)
    else {
      sprintf("%s: %s", tag, gsub("\n([^[:blank:]])", "\n \\1", val))
    }
    escape_paragraphs(s)
  }
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, optional = TRUE, stringsAsFactors = FALSE)
  nmx <- names(x)
  out <- matrix("", nrow(x), ncol(x))
  foldable <- is.na(match(nmx, keep.white))
  for (j in seq_along(x)) {
    xj <- x[[j]]
    if (is.atomic(xj)) {
      i <- !is.na(xj)
      out[i, j] <- fmt(nmx[j], xj[i], foldable[j])
    }
    else {
      nmxj <- nmx[j]
      fold <- foldable[j]
      i <- !vapply(xj, function(s) (length(s) == 1) && is.na(s), NA)
      out[i, j] <- vapply(xj[i], function(s) {
        paste(fmt(nmxj, s, fold), collapse = "\n")
      }, "")
    }
  }
  out <- t(out)
  is_not_empty <- nzchar(out)
  eor <- character(sum(is_not_empty))
  if (length(eor)) {
    eor[which(diff(c(col(out))[is_not_empty]) >= 1)] <- "\n"
  }
  writeLines(paste0(c(out[is_not_empty]), eor), file, useBytes = useBytes)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
writeBin
list(`package:base` = function (object, con, size = NA, endian = .Platform$endian, useBytes = FALSE) 
{
  if (!endian %in% c("big", "little", "swap")) 
    stop("invalid 'endian' argument")
  swap <- endian != .Platform$endian
  if (!is.vector(object) || mode(object) == "list") 
    stop("can only write vector objects")
  if (is.character(con)) {
    con <- file(con, "wb")
    on.exit(close(con))
  }
  .Internal(writeBin(object, con, size, swap, useBytes))
}, function (object, con, size = NA, endian = .Platform$endian, useBytes = FALSE) 
{
  if (!endian %in% c("big", "little", "swap")) 
    stop("invalid 'endian' argument")
  swap <- endian != .Platform$endian
  if (!is.vector(object) || mode(object) == "list") 
    stop("can only write vector objects")
  if (is.character(con)) {
    con <- file(con, "wb")
    on.exit(close(con))
  }
  .Internal(writeBin(object, con, size, swap, useBytes))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
writeChar
list(`package:base` = function (object, con, nchars = nchar(object, type = "chars"), eos = "", useBytes = FALSE) 
{
  if (!is.character(object)) 
    stop("can only write character objects")
  if (is.character(con)) {
    con <- file(con, "wb")
    on.exit(close(con))
  }
  .Internal(writeChar(object, con, as.integer(nchars), eos, useBytes))
}, function (object, con, nchars = nchar(object, type = "chars"), eos = "", useBytes = FALSE) 
{
  if (!is.character(object)) 
    stop("can only write character objects")
  if (is.character(con)) {
    con <- file(con, "wb")
    on.exit(close(con))
  }
  .Internal(writeChar(object, con, as.integer(nchars), eos, useBytes))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
writeLines
list(`package:base` = function (text, con = stdout(), sep = "\n", useBytes = FALSE) 
{
  if (!is.character(text)) 
    stop("can only write character objects")
  if (is.character(con)) {
    con <- file(con, "w")
    on.exit(close(con))
  }
  .Internal(writeLines(text, con, sep, useBytes))
}, function (text, con = stdout(), sep = "\n", useBytes = FALSE) 
{
  if (!is.character(text)) 
    stop("can only write character objects")
  if (is.character(con)) {
    con <- file(con, "w")
    on.exit(close(con))
  }
  .Internal(writeLines(text, con, sep, useBytes))
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
xor
list(`package:base` = function (x, y) 
{
  (x | y) & !(x & y)
}, function (x, y) 
{
  (x | y) & !(x & y)
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
xpdrows.data.frame
list(`package:base` = function (x, old.rows, new.rows) 
{
  nc <- length(x)
  nro <- length(old.rows)
  nrn <- length(new.rows)
  nr <- nro + nrn
  for (i in seq_len(nc)) {
    y <- x[[i]]
    dy <- dim(y)
    cy <- oldClass(y)
    class(y) <- NULL
    if (length(dy) == 2) {
      dny <- dimnames(y)
      if (length(dny[[1]]) > 0) 
        dny[[1]] <- c(dny[[1]], new.rows)
      z <- array(y[1], dim = c(nr, nc), dimnames = dny)
      z[seq_len(nro), ] <- y
      class(z) <- cy
      x[[i]] <- z
    }
    else {
      ay <- attributes(y)
      if (length(names(y)) > 0) 
        ay$names <- c(ay$names, new.rows)
      length(y) <- nr
      attributes(y) <- ay
      class(y) <- cy
      x[[i]] <- y
    }
  }
  nm <- c(old.rows, new.rows)
  if (any(duplicated(nm))) 
    nm <- make.unique(as.character(nm))
  attr(x, "row.names") <- nm
  x
}, function (x, old.rows, new.rows) 
{
  nc <- length(x)
  nro <- length(old.rows)
  nrn <- length(new.rows)
  nr <- nro + nrn
  for (i in seq_len(nc)) {
    y <- x[[i]]
    dy <- dim(y)
    cy <- oldClass(y)
    class(y) <- NULL
    if (length(dy) == 2) {
      dny <- dimnames(y)
      if (length(dny[[1]]) > 0) 
        dny[[1]] <- c(dny[[1]], new.rows)
      z <- array(y[1], dim = c(nr, nc), dimnames = dny)
      z[seq_len(nro), ] <- y
      class(z) <- cy
      x[[i]] <- z
    }
    else {
      ay <- attributes(y)
      if (length(names(y)) > 0) 
        ay$names <- c(ay$names, new.rows)
      length(y) <- nr
      attributes(y) <- ay
      class(y) <- cy
      x[[i]] <- y
    }
  }
  nm <- c(old.rows, new.rows)
  if (any(duplicated(nm))) 
    nm <- make.unique(as.character(nm))
  attr(x, "row.names") <- nm
  x
})
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
xtfrm
list(`package:base` = .Primitive("xtfrm"), .Primitive("xtfrm"))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
xtfrm.AsIs
list(`package:base` = function (x) 
{
  if (length(cl <- class(x)) > 1) 
    oldClass(x) <- cl[-1]
  NextMethod("xtfrm")
}, function (x) 
{
  if (length(cl <- class(x)) > 1) 
    oldClass(x) <- cl[-1]
  NextMethod("xtfrm")
}, function (x) 
{
  if (length(cl <- class(x)) > 1) 
    oldClass(x) <- cl[-1]
  NextMethod("xtfrm")
})
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xtfrm.data.frame
list(`package:base` = function (x) 
{
  if (tolower(Sys.getenv("_R_STOP_ON_XTFRM_DATA_FRAME_")) %in% c("1", "yes", "true")) 
    stop("cannot xtfrm data frames")
  else {
    warning("cannot xtfrm data frames")
    NextMethod("xtfrm")
  }
}, function (x) 
{
  if (tolower(Sys.getenv("_R_STOP_ON_XTFRM_DATA_FRAME_")) %in% c("1", "yes", "true")) 
    stop("cannot xtfrm data frames")
  else {
    warning("cannot xtfrm data frames")
    NextMethod("xtfrm")
  }
}, function (x) 
{
  if (tolower(Sys.getenv("_R_STOP_ON_XTFRM_DATA_FRAME_")) %in% c("1", "yes", "true")) 
    stop("cannot xtfrm data frames")
  else {
    warning("cannot xtfrm data frames")
    NextMethod("xtfrm")
  }
})
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xtfrm.Date
list(`package:base` = function (x) 
  as.numeric(x), function (x) 
    as.numeric(x), function (x) 
      as.numeric(x))
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xtfrm.default
list(`package:base` = function (x) 
{
  y <- if (is.numeric(x)) 
    unclass(x)
  else as.vector(rank(x, ties.method = "min", na.last = "keep"))
  if (!is.numeric(y) || ((length(y) != length(x)) && !inherits(x, "data.frame"))) 
    stop("cannot xtfrm 'x'")
  y
}, function (x) 
{
  y <- if (is.numeric(x)) 
    unclass(x)
  else as.vector(rank(x, ties.method = "min", na.last = "keep"))
  if (!is.numeric(y) || ((length(y) != length(x)) && !inherits(x, "data.frame"))) 
    stop("cannot xtfrm 'x'")
  y
}, function (x) 
{
  y <- if (is.numeric(x)) 
    unclass(x)
  else as.vector(rank(x, ties.method = "min", na.last = "keep"))
  if (!is.numeric(y) || ((length(y) != length(x)) && !inherits(x, "data.frame"))) 
    stop("cannot xtfrm 'x'")
  y
})
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xtfrm.difftime
list(`package:base` = function (x) 
  as.numeric(x), function (x) 
    as.numeric(x), function (x) 
      as.numeric(x))
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xtfrm.factor
list(`package:base` = function (x) 
  as.integer(x), function (x) 
    as.integer(x), function (x) 
      as.integer(x))
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xtfrm.numeric_version
list(`package:base` = function (x) 
{
  x <- .encode_numeric_version(x)
  NextMethod("xtfrm")
}, function (x) 
{
  x <- .encode_numeric_version(x)
  NextMethod("xtfrm")
}, function (x) 
{
  x <- .encode_numeric_version(x)
  NextMethod("xtfrm")
})
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xtfrm.POSIXct
list(`package:base` = function (x) 
  as.numeric(x), function (x) 
    as.numeric(x), function (x) 
      as.numeric(x))
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xtfrm.POSIXlt
list(`package:base` = function (x) 
  as.double(x), function (x) 
    as.double(x), function (x) 
      as.double(x))
c("package:base", "registered S3 method for xtfrm from namespace base", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
xzfile
list(`package:base` = function (description, open = "", encoding = getOption("encoding"), compression = 6) 
  .Internal(xzfile(description, open, encoding, compression)), function (description, open = "", encoding = getOption("encoding"), compression = 6) 
    .Internal(xzfile(description, open, encoding, compression)))
c("package:base", "namespace:base")
c(TRUE, FALSE)
c(FALSE, TRUE)
zapsmall
list(`package:base` = function (x, digits = getOption("digits")) 
{
  if (length(digits) == 0) 
    stop("invalid 'digits'")
  if (all(ina <- is.na(x))) 
    return(x)
  mx <- max(abs(x[!ina]))
  round(x, digits = if (mx > 0) max(0, digits - as.numeric(log10(mx))) else digits)
}, new("standardGeneric", .Data = function (x, digits = getOption("digits")) 
  standardGeneric("zapsmall"), generic = "zapsmall", package = "base", group = list(), valueClass = character(0), signature = c("x", "digits"), default = new("derivedDefaultMethod", .Data = function (x, digits = getOption("digits")) 
  {
    if (length(digits) == 0) 
      stop("invalid 'digits'")
    if (all(ina <- is.na(x))) 
      return(x)
    mx <- max(abs(x[!ina]))
    round(x, digits = if (mx > 0) max(0, digits - as.numeric(log10(mx))) else digits)
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "zapsmall"), skeleton = (new("derivedDefaultMethod", .Data = function (x, digits = getOption("digits")) 
  {
    if (length(digits) == 0) 
      stop("invalid 'digits'")
    if (all(ina <- is.na(x))) 
      return(x)
    mx <- max(abs(x[!ina]))
    round(x, digits = if (mx > 0) max(0, digits - as.numeric(log10(mx))) else digits)
  }, target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "zapsmall"))(x, digits)), function (x, digits = getOption("digits")) 
  {
    if (length(digits) == 0) 
      stop("invalid 'digits'")
    if (all(ina <- is.na(x))) 
      return(x)
    mx <- max(abs(x[!ina]))
    round(x, digits = if (mx > 0) max(0, digits - as.numeric(log10(mx))) else digits)
  })
c("package:base", "namespace:Matrix", "namespace:base")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)

##############################################################################################
library(beepr)   # 2

1)beep
list(`package:beepr` = function (sound = 1, expr = NULL) 
{
  expr
  sounds <- c(ping = "microwave_ping_mono.wav", coin = "smb_coin.wav", fanfare = "victory_fanfare_mono.wav", complete = "work_complete.wav", treasure = "new_item.wav", ready = "ready_master.wav", shotgun = "shotgun.wav", mario = "smb_stage_clear.wav", wilhelm = "wilhelm.wav", facebook = "facebook.wav", sword = "sword.wav")
  sound_path <- NULL
  if (is.na(sounds[sound]) || length(sounds[sound]) != 1) {
    if (is.character(sound)) {
      sound <- str_trim(sound)
      if (file.exists(sound)) {
        sound_path <- sound
      }
      else if (str_detect(sound, "^https://")) {
        warning("Can't currently use https urls, only http.")
      }
      else if (str_detect(sound, "^http://")) {
        temp_file <- tempfile(pattern = "")
        if (download.file(sound, destfile = temp_file, quiet = TRUE) == 0) {
          sound_path <- temp_file
        }
        else {
          warning(paste("Tried but could not download", sound))
        }
      }
      else {
        warning(paste("\"", sound, "\" is not a valid sound nor path, playing a random sound instead.", sep = ""))
      }
    }
  }
  else {
    sound_path <- system.file(paste("sounds/", sounds[sound], sep = ""), package = "beepr")
  }
  if (is.null(sound_path)) {
    sound_path <- system.file(paste("sounds/", sample(sounds, size = 1), sep = ""), package = "beepr")
  }
  tryCatch(play_file(sound_path), error = function(ex) {
    warning("beep() could not play the sound due to the following error:\n", ex)
  })
}, function (sound = 1, expr = NULL) 
{
  expr
  sounds <- c(ping = "microwave_ping_mono.wav", coin = "smb_coin.wav", fanfare = "victory_fanfare_mono.wav", complete = "work_complete.wav", treasure = "new_item.wav", ready = "ready_master.wav", shotgun = "shotgun.wav", mario = "smb_stage_clear.wav", wilhelm = "wilhelm.wav", facebook = "facebook.wav", sword = "sword.wav")
  sound_path <- NULL
  if (is.na(sounds[sound]) || length(sounds[sound]) != 1) {
    if (is.character(sound)) {
      sound <- str_trim(sound)
      if (file.exists(sound)) {
        sound_path <- sound
      }
      else if (str_detect(sound, "^https://")) {
        warning("Can't currently use https urls, only http.")
      }
      else if (str_detect(sound, "^http://")) {
        temp_file <- tempfile(pattern = "")
        if (download.file(sound, destfile = temp_file, quiet = TRUE) == 0) {
          sound_path <- temp_file
        }
        else {
          warning(paste("Tried but could not download", sound))
        }
      }
      else {
        warning(paste("\"", sound, "\" is not a valid sound nor path, playing a random sound instead.", sep = ""))
      }
    }
  }
  else {
    sound_path <- system.file(paste("sounds/", sounds[sound], sep = ""), package = "beepr")
  }
  if (is.null(sound_path)) {
    sound_path <- system.file(paste("sounds/", sample(sounds, size = 1), sep = ""), package = "beepr")
  }
  tryCatch(play_file(sound_path), error = function(ex) {
    warning("beep() could not play the sound due to the following error:\n", ex)
  })
})
c("package:beepr", "namespace:beepr")
c(TRUE, FALSE)
c(FALSE, TRUE)
2)beep_on_error
list(`package:beepr` = function (expr, sound = 1) 
{
  q_expr <- substitute(expr)
  msg <- paste0("An error occurred in ", deparse(q_expr))
  e <- simpleError(msg)
  tryCatch(expr, error = function(e) {
    message(paste0(msg, ": ", e$message))
    beep(sound)
  })
}, function (expr, sound = 1) 
{
  q_expr <- substitute(expr)
  msg <- paste0("An error occurred in ", deparse(q_expr))
  e <- simpleError(msg)
  tryCatch(expr, error = function(e) {
    message(paste0(msg, ": ", e$message))
    beep(sound)
  })
})
c("package:beepr", "namespace:beepr")
c(TRUE, FALSE)
c(FALSE, TRUE)


################################################################################################
library(caret)   # (20 out of 180)
1).Depends
list(`package:caret` = c("ggplot2", "lattice"), `package:lubridate` = "methods")
c("package:caret", "package:lubridate")
c(TRUE, TRUE)
c(FALSE, FALSE)
2)anovaScores
list(`package:caret` = function (x, y) 
{
  if (is.factor(x)) 
    stop("The predictors should be numeric")
  pv <- try(anova(lm(x ~ y), test = "F")[1, "Pr(>F)"], silent = TRUE)
  if (any(class(pv) == "try-error") || is.na(pv) || is.nan(pv)) 
    pv <- 1
  pv
}, function (x, y) 
{
  if (is.factor(x)) 
    stop("The predictors should be numeric")
  pv <- try(anova(lm(x ~ y), test = "F")[1, "Pr(>F)"], silent = TRUE)
  if (any(class(pv) == "try-error") || is.na(pv) || is.nan(pv)) 
    pv <- 1
  pv
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
3)avNNet
list(`package:caret` = function (x, ...) 
  UseMethod("avNNet"), function (x, ...) 
    UseMethod("avNNet"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
4)bag
list(`package:caret` = function (x, ...) 
  UseMethod("bag"), function (x, ...) 
    UseMethod("bag"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
5)bagControl
list(`package:caret` = function (fit = NULL, predict = NULL, aggregate = NULL, downSample = FALSE, oob = TRUE, allowParallel = TRUE) 
{
  list(fit = fit, predict = predict, aggregate = aggregate, downSample = downSample, oob = oob, allowParallel = allowParallel)
}, function (fit = NULL, predict = NULL, aggregate = NULL, downSample = FALSE, oob = TRUE, allowParallel = TRUE) 
{
  list(fit = fit, predict = predict, aggregate = aggregate, downSample = downSample, oob = oob, allowParallel = allowParallel)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
6)bagEarth
list(`package:caret` = function (x, ...) 
  UseMethod("bagEarth"), function (x, ...) 
    UseMethod("bagEarth"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
7)bagEarthStats
list(`package:caret` = function (x) 
  getModelInfo("bagEarth", regex = FALSE)[[1]]$oob(x), function (x) 
    getModelInfo("bagEarth", regex = FALSE)[[1]]$oob(x))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
8)bagFDA
list(`package:caret` = function (x, ...) 
  UseMethod("bagFDA"), function (x, ...) 
    UseMethod("bagFDA"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
9)best
list(`package:caret` = function (x, metric, maximize) 
{
  bestIter <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  bestIter
}, function (x, metric, maximize) 
{
  bestIter <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  bestIter
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
10)BoxCoxTrans
list(`package:caret` = function (y, ...) 
  UseMethod("BoxCoxTrans"), function (y, ...) 
    UseMethod("BoxCoxTrans"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
11)calibration
list(`package:caret` = function (x, ...) 
  UseMethod("calibration"), function (x, ...) 
    UseMethod("calibration"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
12)caretFuncs
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
  train(x, y, ...), pred = function (object, x) 
  {
    tmp <- predict(object, x)
    if (object$modelType == "Classification" & object$control$classProbs) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE), stringsAsFactors = TRUE)
    }
    else out <- tmp
    out
  }, rank = function (object, x, y) 
  {
    vimp <- varImp(object, scale = FALSE)$importance
    if (!is.data.frame(vimp)) 
      vimp <- as.data.frame(vimp, stringsAsFactors = TRUE)
    if (object$modelType == "Regression") {
      vimp <- vimp[order(vimp[, 1], decreasing = TRUE), , drop = FALSE]
    }
    else {
      if (all(levels(y) %in% colnames(vimp)) & !("Overall" %in% colnames(vimp))) {
        avImp <- apply(vimp[, levels(y), drop = TRUE], 1, mean)
        vimp$Overall <- avImp
      }
    }
    vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
    vimp$var <- rownames(vimp)
    vimp
  }, selectSize = function (x, metric, maximize) 
  {
    best <- if (maximize) 
      which.max(x[, metric])
    else which.min(x[, metric])
    min(x[best, "Variables"])
  }, selectVar = function (y, size) 
  {
    finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
    names(finalImp)[2] <- "Overall"
    finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
    as.character(finalImp$var[1:size])
  }), list(summary = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, fit = function (x, y, first, last, ...) 
    train(x, y, ...), pred = function (object, x) 
    {
      tmp <- predict(object, x)
      if (object$modelType == "Classification" & object$control$classProbs) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE), stringsAsFactors = TRUE)
      }
      else out <- tmp
      out
    }, rank = function (object, x, y) 
    {
      vimp <- varImp(object, scale = FALSE)$importance
      if (!is.data.frame(vimp)) 
        vimp <- as.data.frame(vimp, stringsAsFactors = TRUE)
      if (object$modelType == "Regression") {
        vimp <- vimp[order(vimp[, 1], decreasing = TRUE), , drop = FALSE]
      }
      else {
        if (all(levels(y) %in% colnames(vimp)) & !("Overall" %in% colnames(vimp))) {
          avImp <- apply(vimp[, levels(y), drop = TRUE], 1, mean)
          vimp$Overall <- avImp
        }
      }
      vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
      vimp$var <- rownames(vimp)
      vimp
    }, selectSize = function (x, metric, maximize) 
    {
      best <- if (maximize) 
        which.max(x[, metric])
      else which.min(x[, metric])
      min(x[best, "Variables"])
    }, selectVar = function (y, size) 
    {
      finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
      names(finalImp)[2] <- "Overall"
      finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
      as.character(finalImp$var[1:size])
    }))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
13)caretGA
list(`package:caret` = list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
  train(x, y, ...), pred = function (object, x) 
  {
    tmp <- predict(object, x)
    if (object$control$classProbs) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
    out
  }, fitness_intern = function (object, x, y, maximize, p) 
  {
    perf_val <- getTrainPerf(object)
    perf_val <- perf_val[names(perf_val) != "method"]
    perf_val <- unlist(perf_val)
    names(perf_val) <- gsub("Train", "", names(perf_val))
    perf_val
  }, fitness_extern = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, initial = function (vars, popSize, ...) 
  {
    x <- matrix(NA, nrow = popSize, ncol = vars)
    probs <- seq(0.9, 0.1, length = popSize)
    for (i in 1:popSize) {
      x[i, ] <- sample(0:1, replace = TRUE, size = vars, prob = c(probs[i], 1 - probs[i]))
    }
    var_count <- apply(x, 1, sum)
    if (any(var_count == 0)) {
      for (i in which(var_count == 0)) {
        x[i, ] <- sample(0:1, replace = TRUE, size = vars)
      }
    }
    x
  }, selection = function (population, fitness, r = NULL, q = NULL, ...) 
  {
    popSize = nrow(population)
    if (is.null(r)) 
      r <- 2/(popSize * (popSize - 1))
    if (is.null(q)) 
      q <- 2/popSize
    rank <- (popSize + 1) - rank(fitness, ties.method = "random")
    prob <- q - (rank - 1) * r
    sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
    out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
    out
  }, crossover = function (population, fitness, parents, ...) 
  {
    fitness <- fitness[parents]
    parents <- population[parents, , drop = FALSE]
    n <- ncol(parents)
    children <- matrix(as.double(NA), nrow = 2, ncol = n)
    fitnessChildren <- rep(NA, 2)
    crossOverPoint <- sample(0:n, size = 1)
    if (crossOverPoint == 0) {
      children[1:2, ] <- parents[2:1, ]
      fitnessChildren[1:2] <- fitness[2:1]
    }
    else if (crossOverPoint == n) {
      children <- parents
      fitnessChildren <- fitness
    }
    else {
      children[1, ] <- c(parents[1, 1:crossOverPoint], parents[2, (crossOverPoint + 1):n])
      children[2, ] <- c(parents[2, 1:crossOverPoint], parents[1, (crossOverPoint + 1):n])
    }
    out <- list(children = children, fitness = fitnessChildren)
    out
  }, mutation = function (population, parent, ...) 
  {
    mutate <- parent <- as.vector(population[parent, ])
    n <- length(parent)
    j <- sample(1:n, size = 1)
    mutate[j] <- abs(mutate[j] - 1)
    mutate
  }, selectIter = function (x, metric, maximize) 
  {
    bestIter <- if (maximize) 
      which.max(x[, metric])
    else which.min(x[, metric])
    bestIter
  }), list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
    train(x, y, ...), pred = function (object, x) 
    {
      tmp <- predict(object, x)
      if (object$control$classProbs) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
      }
      else out <- tmp
      out
    }, fitness_intern = function (object, x, y, maximize, p) 
    {
      perf_val <- getTrainPerf(object)
      perf_val <- perf_val[names(perf_val) != "method"]
      perf_val <- unlist(perf_val)
      names(perf_val) <- gsub("Train", "", names(perf_val))
      perf_val
    }, fitness_extern = function (data, lev = NULL, model = NULL) 
    {
      if (is.character(data$obs)) 
        data$obs <- factor(data$obs, levels = lev)
      postResample(data[, "pred"], data[, "obs"])
    }, initial = function (vars, popSize, ...) 
    {
      x <- matrix(NA, nrow = popSize, ncol = vars)
      probs <- seq(0.9, 0.1, length = popSize)
      for (i in 1:popSize) {
        x[i, ] <- sample(0:1, replace = TRUE, size = vars, prob = c(probs[i], 1 - probs[i]))
      }
      var_count <- apply(x, 1, sum)
      if (any(var_count == 0)) {
        for (i in which(var_count == 0)) {
          x[i, ] <- sample(0:1, replace = TRUE, size = vars)
        }
      }
      x
    }, selection = function (population, fitness, r = NULL, q = NULL, ...) 
    {
      popSize = nrow(population)
      if (is.null(r)) 
        r <- 2/(popSize * (popSize - 1))
      if (is.null(q)) 
        q <- 2/popSize
      rank <- (popSize + 1) - rank(fitness, ties.method = "random")
      prob <- q - (rank - 1) * r
      sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
      out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
      out
    }, crossover = function (population, fitness, parents, ...) 
    {
      fitness <- fitness[parents]
      parents <- population[parents, , drop = FALSE]
      n <- ncol(parents)
      children <- matrix(as.double(NA), nrow = 2, ncol = n)
      fitnessChildren <- rep(NA, 2)
      crossOverPoint <- sample(0:n, size = 1)
      if (crossOverPoint == 0) {
        children[1:2, ] <- parents[2:1, ]
        fitnessChildren[1:2] <- fitness[2:1]
      }
      else if (crossOverPoint == n) {
        children <- parents
        fitnessChildren <- fitness
      }
      else {
        children[1, ] <- c(parents[1, 1:crossOverPoint], parents[2, (crossOverPoint + 1):n])
        children[2, ] <- c(parents[2, 1:crossOverPoint], parents[1, (crossOverPoint + 1):n])
      }
      out <- list(children = children, fitness = fitnessChildren)
      out
    }, mutation = function (population, parent, ...) 
    {
      mutate <- parent <- as.vector(population[parent, ])
      n <- length(parent)
      j <- sample(1:n, size = 1)
      mutate[j] <- abs(mutate[j] - 1)
      mutate
    }, selectIter = function (x, metric, maximize) 
    {
      bestIter <- if (maximize) 
        which.max(x[, metric])
      else which.min(x[, metric])
      bestIter
    }))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
14)caretSA
list(`package:caret` = list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
  train(x, y, ...), pred = function (object, x) 
  {
    tmp <- predict(object, x)
    if (object$control$classProbs) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
    out
  }, fitness_intern = function (object, x, y, maximize, p) 
  {
    perf_val <- getTrainPerf(object)
    perf_val <- perf_val[names(perf_val) != "method"]
    perf_val <- unlist(perf_val)
    names(perf_val) <- gsub("Train", "", names(perf_val))
    perf_val
  }, fitness_extern = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, initial = function (vars, prob = 0.2, ...) 
  {
    sort(sample.int(vars, size = floor(vars * prob) + 1))
  }, perturb = function (x, vars, number = floor(length(x) * 0.01) + 1) 
  {
    bin <- index2vec(x, vars)
    change <- sample(seq(along = bin), size = number)
    bin[change] <- ifelse(bin[change] == 1, 0, 1)
    sort(which(bin == 1))
  }, prob = function (old, new, iteration = 1) 
  {
    if (new < old) 
      return(1)
    ediff <- as.vector(old - new)
    ediff <- ediff/abs(old)
    exp(ediff * iteration)
  }, selectIter = function (x, metric, maximize) 
  {
    bestIter <- if (maximize) 
      which.max(x[, metric])
    else which.min(x[, metric])
    bestIter
  }), list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
    train(x, y, ...), pred = function (object, x) 
    {
      tmp <- predict(object, x)
      if (object$control$classProbs) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
      }
      else out <- tmp
      out
    }, fitness_intern = function (object, x, y, maximize, p) 
    {
      perf_val <- getTrainPerf(object)
      perf_val <- perf_val[names(perf_val) != "method"]
      perf_val <- unlist(perf_val)
      names(perf_val) <- gsub("Train", "", names(perf_val))
      perf_val
    }, fitness_extern = function (data, lev = NULL, model = NULL) 
    {
      if (is.character(data$obs)) 
        data$obs <- factor(data$obs, levels = lev)
      postResample(data[, "pred"], data[, "obs"])
    }, initial = function (vars, prob = 0.2, ...) 
    {
      sort(sample.int(vars, size = floor(vars * prob) + 1))
    }, perturb = function (x, vars, number = floor(length(x) * 0.01) + 1) 
    {
      bin <- index2vec(x, vars)
      change <- sample(seq(along = bin), size = number)
      bin[change] <- ifelse(bin[change] == 1, 0, 1)
      sort(which(bin == 1))
    }, prob = function (old, new, iteration = 1) 
    {
      if (new < old) 
        return(1)
      ediff <- as.vector(old - new)
      ediff <- ediff/abs(old)
      exp(ediff * iteration)
    }, selectIter = function (x, metric, maximize) 
    {
      bestIter <- if (maximize) 
        which.max(x[, metric])
      else which.min(x[, metric])
      bestIter
    }))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
15)caretSBF
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, ...) 
{
  if (ncol(x) > 0) {
    train(x, y, ...)
  }
  else nullModel(y = y)
}, pred = function (object, x) 
{
  if (class(object) != "nullModel") {
    tmp <- predict(object, x)
    if (object$modelType == "Classification" & !is.null(object$modelInfo$prob)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
  }
  else {
    tmp <- predict(object, x)
    if (!is.null(object$levels)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
  }
  out
}, score = function (x, y) 
{
  if (is.factor(y)) 
    anovaScores(x, y)
  else gamScores(x, y)
}, filter = function (score, x, y) 
  score <= 0.05), list(summary = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, fit = function (x, y, ...) 
  {
    if (ncol(x) > 0) {
      train(x, y, ...)
    }
    else nullModel(y = y)
  }, pred = function (object, x) 
  {
    if (class(object) != "nullModel") {
      tmp <- predict(object, x)
      if (object$modelType == "Classification" & !is.null(object$modelInfo$prob)) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
      }
      else out <- tmp
    }
    else {
      tmp <- predict(object, x)
      if (!is.null(object$levels)) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
      }
      else out <- tmp
    }
    out
  }, score = function (x, y) 
  {
    if (is.factor(y)) 
      anovaScores(x, y)
    else gamScores(x, y)
  }, filter = function (score, x, y) 
    score <= 0.05))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
16)caretTheme
list(`package:caret` = function () 
list(plot.polygon = list(alpha = 1, col = "aliceblue", border = "black", lty = 1, lwd = 1), background = list(col = "transparent"), bar.fill = list(col = "#cce6ff"), box.rectangle = list(col = "black"), box.umbrella = list(col = "black"), dot.line = list(col = "#e8e8e8"), dot.symbol = list(col = "black"), plot.line = list(col = "black"), plot.symbol = list(col = "black"), regions = list(col = c("#FEF8FA", "#FDF6F9", "#FBF5F9", "#FAF3F8", "#F8F2F7", "#F7F0F7", "#F5EEF6", "#F4EDF5", "#F2EBF5", "#F1EAF4", 
"#EFE8F3", "#EDE7F2", "#ECE5F1", "#EAE4F1", "#E8E2F0", "#E6E1EF", "#E4DFEE", "#E2DEED", "#E0DCEC", "#DEDAEB", "#DCD9EA", "#D9D7E9", "#D7D6E8", "#D4D4E7", "#D1D2E6", "#CED1E5", "#CCCFE4", "#C8CEE3", "#C5CCE2", "#C2CAE1", "#BFC9E0", "#BBC7DF", "#B8C5DF", "#B4C4DE", "#B1C2DD", "#ADC0DC", "#A9BFDB", "#A6BDDA", "#A2BBD9", "#9EB9D9", "#9BB8D8", "#97B6D7", "#93B4D6", "#8FB2D5", "#8BB0D4", "#87AFD3", "#83ADD2", "#7FABD1", "#7AA9D0", "#76A7CF", "#71A5CE", "#6CA3CC", "#68A1CB", "#63A0CA", "#5D9EC9", "#589CC8", 
"#539AC6", "#4E98C5", "#4996C4", "#4493C3", "#3F91C1", "#3A8FC0", "#358DBF", "#308BBE", "#2C89BD", "#2887BC", "#2385BB", "#1F83BA", "#1C80B9", "#187EB7", "#157CB6", "#127AB5", "#0F78B3", "#0D76B2", "#0A73B0", "#0971AE", "#076FAC", "#066DAA", "#056AA7", "#0568A5")), strip.shingle = list(col = c("#ff7f00", "#00ff00", "#00ffff", "#ff00ff", "#ff0000", "#ffff00", "#0080ff")), strip.background = list(col = c("#ffe5cc", "#ccffcc", "#ccffff", "#ffccff", "#ffcccc", "#ffffcc", "#cce6ff")), reference.line = list(col = "#e8e8e8"), 
superpose.line = list(col = c("#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black"), lty = rep(1:6, each = 6)), superpose.symbol = list(pch = c(1, 4, 6, 0, 5, 17, 4, 6, 
0, 5, 17, 1, 6, 0, 5, 17, 1, 4, 0, 5, 17, 1, 4, 6, 5, 17, 1, 4, 6, 0, 17, 1, 4, 6, 0, 5), cex = rep(0.7, 6 * 6), col = c("#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", 
"black"))), function () 
list(plot.polygon = list(alpha = 1, col = "aliceblue", border = "black", lty = 1, lwd = 1), background = list(col = "transparent"), bar.fill = list(col = "#cce6ff"), box.rectangle = list(col = "black"), box.umbrella = list(col = "black"), dot.line = list(col = "#e8e8e8"), dot.symbol = list(col = "black"), plot.line = list(col = "black"), plot.symbol = list(col = "black"), regions = list(col = c("#FEF8FA", "#FDF6F9", "#FBF5F9", "#FAF3F8", "#F8F2F7", "#F7F0F7", "#F5EEF6", "#F4EDF5", "#F2EBF5", "#F1EAF4", 
"#EFE8F3", "#EDE7F2", "#ECE5F1", "#EAE4F1", "#E8E2F0", "#E6E1EF", "#E4DFEE", "#E2DEED", "#E0DCEC", "#DEDAEB", "#DCD9EA", "#D9D7E9", "#D7D6E8", "#D4D4E7", "#D1D2E6", "#CED1E5", "#CCCFE4", "#C8CEE3", "#C5CCE2", "#C2CAE1", "#BFC9E0", "#BBC7DF", "#B8C5DF", "#B4C4DE", "#B1C2DD", "#ADC0DC", "#A9BFDB", "#A6BDDA", "#A2BBD9", "#9EB9D9", "#9BB8D8", "#97B6D7", "#93B4D6", "#8FB2D5", "#8BB0D4", "#87AFD3", "#83ADD2", "#7FABD1", "#7AA9D0", "#76A7CF", "#71A5CE", "#6CA3CC", "#68A1CB", "#63A0CA", "#5D9EC9", "#589CC8", 
"#539AC6", "#4E98C5", "#4996C4", "#4493C3", "#3F91C1", "#3A8FC0", "#358DBF", "#308BBE", "#2C89BD", "#2887BC", "#2385BB", "#1F83BA", "#1C80B9", "#187EB7", "#157CB6", "#127AB5", "#0F78B3", "#0D76B2", "#0A73B0", "#0971AE", "#076FAC", "#066DAA", "#056AA7", "#0568A5")), strip.shingle = list(col = c("#ff7f00", "#00ff00", "#00ffff", "#ff00ff", "#ff0000", "#ffff00", "#0080ff")), strip.background = list(col = c("#ffe5cc", "#ccffcc", "#ccffff", "#ffccff", "#ffcccc", "#ffffcc", "#cce6ff")), reference.line = list(col = "#e8e8e8"), 
superpose.line = list(col = c("#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black"), lty = rep(1:6, each = 6)), superpose.symbol = list(pch = c(1, 4, 6, 0, 5, 17, 4, 6, 
0, 5, 17, 1, 6, 0, 5, 17, 1, 4, 0, 5, 17, 1, 4, 6, 5, 17, 1, 4, 6, 0, 17, 1, 4, 6, 0, 5), cex = rep(0.7, 6 * 6), col = c("#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", "black", "#9E0142", "#3288BD", "#F46D43", "#5E4FA2", "#66C2A5", 
"black"))))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
17)cforestStats
list(`package:caret` = function (x) 
  getModelInfo("cforest", regex = FALSE)[[1]]$oob(x), function (x) 
    getModelInfo("cforest", regex = FALSE)[[1]]$oob(x))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
18)checkConditionalX
list(`package:caret` = function (x, y) 
{
  x$.outcome <- y
  unique(unlist(dlply(x, .(.outcome), zeroVar)))
}, function (x, y) 
{
  x$.outcome <- y
  unique(unlist(dlply(x, .(.outcome), zeroVar)))
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
19)checkInstall
list(`package:caret` = function (pkg) 
{
  good <- rep(TRUE, length(pkg))
  for (i in seq(along = pkg)) {
    tested <- try(find.package(pkg[i]), silent = TRUE)
    if (inherits(tested, "try-error")) 
      good[i] <- FALSE
  }
  if (any(!good)) {
    pkList <- paste(pkg[!good], collapse = ", ")
    msg <- paste(sum(!good), ifelse(sum(!good) > 1, " packages are", " package is"), " needed and", ifelse(sum(!good) > 1, " are", " is"), " not installed. (", pkList, "). Would you like to try to install", ifelse(sum(!good) > 1, " them", " it"), " now?", sep = "")
    if (interactive()) {
      cat(msg)
      bioc <- c("affy", "logicFS", "gpls", "vbmp")
      installChoice <- menu(c("yes", "no"))
      if (installChoice == 1) {
        hasBioc <- any(pkg[!good] %in% bioc)
        if (!hasBioc) {
          install.packages(pkg[!good])
        }
        else {
          inst <- pkg[!good]
          instC <- inst[!(inst %in% bioc)]
          instB <- inst[inst %in% bioc]
          if (length(instC) > 0) 
            install.packages(instC)
          biocLite <- NULL
          source("http://bioconductor.org/biocLite.R")
          biocLite(instB)
        }
      }
      else {
        stop("Required packages are missing: ", pkList, call. = FALSE)
      }
    }
    else {
      stop("Required packages are missing: ", pkList, call. = FALSE)
    }
  }
}, function (pkg) 
{
  good <- rep(TRUE, length(pkg))
  for (i in seq(along = pkg)) {
    tested <- try(find.package(pkg[i]), silent = TRUE)
    if (inherits(tested, "try-error")) 
      good[i] <- FALSE
  }
  if (any(!good)) {
    pkList <- paste(pkg[!good], collapse = ", ")
    msg <- paste(sum(!good), ifelse(sum(!good) > 1, " packages are", " package is"), " needed and", ifelse(sum(!good) > 1, " are", " is"), " not installed. (", pkList, "). Would you like to try to install", ifelse(sum(!good) > 1, " them", " it"), " now?", sep = "")
    if (interactive()) {
      cat(msg)
      bioc <- c("affy", "logicFS", "gpls", "vbmp")
      installChoice <- menu(c("yes", "no"))
      if (installChoice == 1) {
        hasBioc <- any(pkg[!good] %in% bioc)
        if (!hasBioc) {
          install.packages(pkg[!good])
        }
        else {
          inst <- pkg[!good]
          instC <- inst[!(inst %in% bioc)]
          instB <- inst[inst %in% bioc]
          if (length(instC) > 0) 
            install.packages(instC)
          biocLite <- NULL
          source("http://bioconductor.org/biocLite.R")
          biocLite(instB)
        }
      }
      else {
        stop("Required packages are missing: ", pkList, call. = FALSE)
      }
    }
    else {
      stop("Required packages are missing: ", pkList, call. = FALSE)
    }
  }
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
20)checkResamples
list(`package:caret` = function (index, x, y) 
{
  if (!is.factor(y)) 
    stop("y must be a factor")
  if (length(levels(y)) < 2) 
    stop("y must have at least 2 levels")
  wrap <- function(index, x, y) checkConditionalX(x[index, , drop = FALSE], y[index])
  unique(unlist(lapply(index, wrap, x = x, y = y)))
}, function (index, x, y) 
{
  if (!is.factor(y)) 
    stop("y must be a factor")
  if (length(levels(y)) < 2) 
    stop("y must have at least 2 levels")
  wrap <- function(index, x, y) checkConditionalX(x[index, , drop = FALSE], y[index])
  unique(unlist(lapply(index, wrap, x = x, y = y)))
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
class2ind
list(`package:caret` = function (x, drop2nd = FALSE) 
{
  if (!is.factor(x)) 
    stop("'x' should be a factor")
  y <- model.matrix(~x - 1)
  colnames(y) <- gsub("^x", "", colnames(y))
  attributes(y)$assign <- NULL
  attributes(y)$contrasts <- NULL
  if (length(levels(x)) == 2 & drop2nd) {
    y <- y[, 1]
  }
  y
}, function (x, drop2nd = FALSE) 
{
  if (!is.factor(x)) 
    stop("'x' should be a factor")
  y <- model.matrix(~x - 1)
  colnames(y) <- gsub("^x", "", colnames(y))
  attributes(y)$assign <- NULL
  attributes(y)$contrasts <- NULL
  if (length(levels(x)) == 2 & drop2nd) {
    y <- y[, 1]
  }
  y
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
classDist
list(`package:caret` = function (x, ...) 
  UseMethod("classDist"), function (x, ...) 
    UseMethod("classDist"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
cluster
list(`package:caret` = function (x, ...) 
  UseMethod("cluster"), function (x) 
    x, function (..., workers = availableWorkers(), envir = parent.frame()) 
    {
      future <- ClusterFuture(..., workers = workers, envir = envir)
      if (!future$lazy) 
        future <- run(future)
      invisible(future)
    }, function (x, ...) 
      UseMethod("cluster"))
c("package:caret", "namespace:survival", "namespace:future", "namespace:caret")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE)
compare_models
list(`package:caret` = function (a, b, metric = a$metric[1]) 
{
  mods <- list(a, b)
  rs <- resamples(mods)
  diffs <- diff(rs, metric = metric[1])
  diffs$statistics[[1]][[1]]
}, function (a, b, metric = a$metric[1]) 
{
  mods <- list(a, b)
  rs <- resamples(mods)
  diffs <- diff(rs, metric = metric[1])
  diffs$statistics[[1]][[1]]
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
confusionMatrix
list(`package:caret` = function (data, ...) 
{
  UseMethod("confusionMatrix")
}, function (actual, predicted, cutoff = 0.5) 
{
  confusionMatrix_(actual, predicted, cutoff)
}, function (data, ...) 
{
  UseMethod("confusionMatrix")
})
c("package:caret", "namespace:ModelMetrics", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
confusionMatrix.train
list(`package:caret` = function (data, norm = "overall", dnn = c("Prediction", "Reference"), ...) 
{
  if (data$control$method %in% c("oob", "LOOCV", "none")) 
    stop("cannot compute confusion matrices for leave-one-out, out-of-bag resampling, or no resampling")
  if (inherits(data, "train")) {
    if (data$modelType == "Regression") 
      stop("confusion matrices are only valid for classification models")
    lev <- levels(data)
    resampledCM <- train_resampledCM(data)
  }
  else {
    lev <- data$obsLevels
    if (inherits(data, "rfe")) 
      resampledCM <- rfe_resampledCM(data)
    if (inherits(data, "sbf")) 
      resampledCM <- sbf_resampledCM(data)
  }
  if (!is.null(data$control$index)) {
    resampleN <- unlist(lapply(data$control$index, length))
    numResamp <- length(resampleN)
    resampText <- resampName(data)
  }
  else {
    resampText <- ""
    numResamp <- 0
  }
  counts <- as.matrix(resampledCM[, grep("^\\.?cell", colnames(resampledCM))])
  norm <- match.arg(norm, c("none", "overall", "average"))
  if (norm == "none") 
    counts <- matrix(apply(counts, 2, sum), nrow = length(lev))
  else counts <- matrix(apply(counts, 2, mean), nrow = length(lev))
  if (norm == "overall") 
    counts <- counts/sum(counts) * 100
  rownames(counts) <- colnames(counts) <- lev
  names(dimnames(counts)) <- dnn
  out <- list(table = as.table(counts), norm = norm, B = length(data$control$index), text = paste(resampText, "Confusion Matrix"))
  class(out) <- paste0("confusionMatrix.", class(data))
  out
}, function (data, norm = "overall", dnn = c("Prediction", "Reference"), ...) 
{
  if (data$control$method %in% c("oob", "LOOCV", "none")) 
    stop("cannot compute confusion matrices for leave-one-out, out-of-bag resampling, or no resampling")
  if (inherits(data, "train")) {
    if (data$modelType == "Regression") 
      stop("confusion matrices are only valid for classification models")
    lev <- levels(data)
    resampledCM <- train_resampledCM(data)
  }
  else {
    lev <- data$obsLevels
    if (inherits(data, "rfe")) 
      resampledCM <- rfe_resampledCM(data)
    if (inherits(data, "sbf")) 
      resampledCM <- sbf_resampledCM(data)
  }
  if (!is.null(data$control$index)) {
    resampleN <- unlist(lapply(data$control$index, length))
    numResamp <- length(resampleN)
    resampText <- resampName(data)
  }
  else {
    resampText <- ""
    numResamp <- 0
  }
  counts <- as.matrix(resampledCM[, grep("^\\.?cell", colnames(resampledCM))])
  norm <- match.arg(norm, c("none", "overall", "average"))
  if (norm == "none") 
    counts <- matrix(apply(counts, 2, sum), nrow = length(lev))
  else counts <- matrix(apply(counts, 2, mean), nrow = length(lev))
  if (norm == "overall") 
    counts <- counts/sum(counts) * 100
  rownames(counts) <- colnames(counts) <- lev
  names(dimnames(counts)) <- dnn
  out <- list(table = as.table(counts), norm = norm, B = length(data$control$index), text = paste(resampText, "Confusion Matrix"))
  class(out) <- paste0("confusionMatrix.", class(data))
  out
}, function (data, norm = "overall", dnn = c("Prediction", "Reference"), ...) 
{
  if (data$control$method %in% c("oob", "LOOCV", "none")) 
    stop("cannot compute confusion matrices for leave-one-out, out-of-bag resampling, or no resampling")
  if (inherits(data, "train")) {
    if (data$modelType == "Regression") 
      stop("confusion matrices are only valid for classification models")
    lev <- levels(data)
    resampledCM <- train_resampledCM(data)
  }
  else {
    lev <- data$obsLevels
    if (inherits(data, "rfe")) 
      resampledCM <- rfe_resampledCM(data)
    if (inherits(data, "sbf")) 
      resampledCM <- sbf_resampledCM(data)
  }
  if (!is.null(data$control$index)) {
    resampleN <- unlist(lapply(data$control$index, length))
    numResamp <- length(resampleN)
    resampText <- resampName(data)
  }
  else {
    resampText <- ""
    numResamp <- 0
  }
  counts <- as.matrix(resampledCM[, grep("^\\.?cell", colnames(resampledCM))])
  norm <- match.arg(norm, c("none", "overall", "average"))
  if (norm == "none") 
    counts <- matrix(apply(counts, 2, sum), nrow = length(lev))
  else counts <- matrix(apply(counts, 2, mean), nrow = length(lev))
  if (norm == "overall") 
    counts <- counts/sum(counts) * 100
  rownames(counts) <- colnames(counts) <- lev
  names(dimnames(counts)) <- dnn
  out <- list(table = as.table(counts), norm = norm, B = length(data$control$index), text = paste(resampText, "Confusion Matrix"))
  class(out) <- paste0("confusionMatrix.", class(data))
  out
})
c("package:caret", "registered S3 method for confusionMatrix from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
contr.dummy
list(`package:caret` = function (n, ...) 
{
  if (is.numeric(n) && length(n) == 1) {
    if (n > 1) 
      levels <- as.character(seq_len(n))
    else stop("not enough degrees of freedom to define contrasts")
  }
  else {
    levels <- as.character(n)
    n <- length(n)
  }
  out <- diag(n)
  rownames(out) <- levels
  colnames(out) <- levels
  out
}, function (n, ...) 
{
  if (is.numeric(n) && length(n) == 1) {
    if (n > 1) 
      levels <- as.character(seq_len(n))
    else stop("not enough degrees of freedom to define contrasts")
  }
  else {
    levels <- as.character(n)
    n <- length(n)
  }
  out <- diag(n)
  rownames(out) <- levels
  colnames(out) <- levels
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
contr.ltfr
list(`package:caret` = function (n, contrasts = TRUE, sparse = FALSE) 
{
  if (is.numeric(n) && length(n) == 1) {
    if (n > 1) 
      levels <- as.character(seq_len(n))
    else stop("not enough degrees of freedom to define contrasts")
  }
  else {
    levels <- as.character(n)
    n <- length(n)
  }
  contr <- .RDiag(levels, sparse = sparse)
  if (contrasts) {
    if (n < 2) 
      stop(gettextf("contrasts not defined for %d degrees of freedom", n - 1), domain = NA)
  }
  contr
}, function (n, contrasts = TRUE, sparse = FALSE) 
{
  if (is.numeric(n) && length(n) == 1) {
    if (n > 1) 
      levels <- as.character(seq_len(n))
    else stop("not enough degrees of freedom to define contrasts")
  }
  else {
    levels <- as.character(n)
    n <- length(n)
  }
  contr <- .RDiag(levels, sparse = sparse)
  if (contrasts) {
    if (n < 2) 
      stop(gettextf("contrasts not defined for %d degrees of freedom", n - 1), domain = NA)
  }
  contr
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
createDataPartition
list(`package:caret` = function (y, times = 1, p = 0.5, list = TRUE, groups = min(5, length(y))) 
{
  if (inherits(y, "Surv")) 
    y <- y[, "time"]
  out <- vector(mode = "list", times)
  if (length(y) < 2) 
    stop("y must have at least 2 data points")
  if (groups < 2) 
    groups <- 2
  if (is.numeric(y)) {
    y <- cut(y, unique(quantile(y, probs = seq(0, 1, length = groups))), include.lowest = TRUE)
  }
  else {
    xtab <- table(y)
    if (any(xtab == 0)) {
      warning(paste("Some classes have no records (", paste(names(xtab)[xtab == 0], sep = "", collapse = ", "), ") and these will be ignored"))
      y <- factor(as.character(y))
    }
    if (any(xtab == 1)) {
      warning(paste("Some classes have a single record (", paste(names(xtab)[xtab == 1], sep = "", collapse = ", "), ") and these will be selected for the sample"))
    }
  }
  subsample <- function(dat, p) {
    if (nrow(dat) == 1) {
      out <- dat$index
    }
    else {
      num <- ceiling(nrow(dat) * p)
      out <- sample(dat$index, size = num)
    }
    out
  }
  for (j in 1:times) {
    tmp <- dlply(data.frame(y = y, index = seq(along = y)), .(y), subsample, p = p)
    tmp <- sort(as.vector(unlist(tmp)))
    out[[j]] <- tmp
  }
  if (!list) {
    out <- matrix(unlist(out), ncol = times)
    colnames(out) <- prettySeq(1:ncol(out))
  }
  else {
    names(out) <- prettySeq(out)
  }
  out
}, function (y, times = 1, p = 0.5, list = TRUE, groups = min(5, length(y))) 
{
  if (inherits(y, "Surv")) 
    y <- y[, "time"]
  out <- vector(mode = "list", times)
  if (length(y) < 2) 
    stop("y must have at least 2 data points")
  if (groups < 2) 
    groups <- 2
  if (is.numeric(y)) {
    y <- cut(y, unique(quantile(y, probs = seq(0, 1, length = groups))), include.lowest = TRUE)
  }
  else {
    xtab <- table(y)
    if (any(xtab == 0)) {
      warning(paste("Some classes have no records (", paste(names(xtab)[xtab == 0], sep = "", collapse = ", "), ") and these will be ignored"))
      y <- factor(as.character(y))
    }
    if (any(xtab == 1)) {
      warning(paste("Some classes have a single record (", paste(names(xtab)[xtab == 1], sep = "", collapse = ", "), ") and these will be selected for the sample"))
    }
  }
  subsample <- function(dat, p) {
    if (nrow(dat) == 1) {
      out <- dat$index
    }
    else {
      num <- ceiling(nrow(dat) * p)
      out <- sample(dat$index, size = num)
    }
    out
  }
  for (j in 1:times) {
    tmp <- dlply(data.frame(y = y, index = seq(along = y)), .(y), subsample, p = p)
    tmp <- sort(as.vector(unlist(tmp)))
    out[[j]] <- tmp
  }
  if (!list) {
    out <- matrix(unlist(out), ncol = times)
    colnames(out) <- prettySeq(1:ncol(out))
  }
  else {
    names(out) <- prettySeq(out)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
createFolds
list(`package:caret` = function (y, k = 10, list = TRUE, returnTrain = FALSE) 
{
  if (inherits(y, "Surv")) 
    y <- y[, "time"]
  if (is.numeric(y)) {
    cuts <- floor(length(y)/k)
    if (cuts < 2) 
      cuts <- 2
    if (cuts > 5) 
      cuts <- 5
    breaks <- unique(quantile(y, probs = seq(0, 1, length = cuts)))
    y <- cut(y, breaks, include.lowest = TRUE)
  }
  if (k < length(y)) {
    y <- factor(as.character(y))
    numInClass <- table(y)
    foldVector <- vector(mode = "integer", length(y))
    for (i in 1:length(numInClass)) {
      min_reps <- numInClass[i]%/%k
      if (min_reps > 0) {
        spares <- numInClass[i]%%k
        seqVector <- rep(1:k, min_reps)
        if (spares > 0) 
          seqVector <- c(seqVector, sample(1:k, spares))
        foldVector[which(y == names(numInClass)[i])] <- sample(seqVector)
      }
      else {
        foldVector[which(y == names(numInClass)[i])] <- sample(1:k, size = numInClass[i])
      }
    }
  }
  else foldVector <- seq(along = y)
  if (list) {
    out <- split(seq(along = y), foldVector)
    names(out) <- paste("Fold", gsub(" ", "0", format(seq(along = out))), sep = "")
    if (returnTrain) 
      out <- lapply(out, function(data, y) y[-data], y = seq(along = y))
  }
  else out <- foldVector
  out
}, function (y, k = 10, list = TRUE, returnTrain = FALSE) 
{
  if (inherits(y, "Surv")) 
    y <- y[, "time"]
  if (is.numeric(y)) {
    cuts <- floor(length(y)/k)
    if (cuts < 2) 
      cuts <- 2
    if (cuts > 5) 
      cuts <- 5
    breaks <- unique(quantile(y, probs = seq(0, 1, length = cuts)))
    y <- cut(y, breaks, include.lowest = TRUE)
  }
  if (k < length(y)) {
    y <- factor(as.character(y))
    numInClass <- table(y)
    foldVector <- vector(mode = "integer", length(y))
    for (i in 1:length(numInClass)) {
      min_reps <- numInClass[i]%/%k
      if (min_reps > 0) {
        spares <- numInClass[i]%%k
        seqVector <- rep(1:k, min_reps)
        if (spares > 0) 
          seqVector <- c(seqVector, sample(1:k, spares))
        foldVector[which(y == names(numInClass)[i])] <- sample(seqVector)
      }
      else {
        foldVector[which(y == names(numInClass)[i])] <- sample(1:k, size = numInClass[i])
      }
    }
  }
  else foldVector <- seq(along = y)
  if (list) {
    out <- split(seq(along = y), foldVector)
    names(out) <- paste("Fold", gsub(" ", "0", format(seq(along = out))), sep = "")
    if (returnTrain) 
      out <- lapply(out, function(data, y) y[-data], y = seq(along = y))
  }
  else out <- foldVector
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
createModel
list(`package:caret` = function (x, y, wts, method, tuneValue, obsLevels, pp = NULL, last = FALSE, sampling = NULL, classProbs, ...) 
{
  if (is.data.frame(x) | is.matrix(x)) 
    rownames(x) <- make.names(rownames(x), unique = TRUE)
  if (!is.null(sampling) && sampling$first) {
    tmp <- sampling$func(x, y)
    x <- tmp$x
    y <- tmp$y
    rm(tmp)
  }
  if (!is.null(pp$options)) {
    pp$method <- pp$options
    pp$options <- NULL
    if ("ica" %in% pp$method) 
      pp$n.comp <- pp$ICAcomp
    pp$ICAcomp <- NULL
    pp$x <- x
    pp$outcome <- y
    ppObj <- do.call("preProcess", pp)
    ppObj$call <- "scrubed"
    x <- predict(ppObj, x)
    rm(pp)
  }
  else ppObj <- NULL
  if (!is.null(sampling) && !sampling$first) {
    tmp <- sampling$func(x, y)
    x <- tmp$x
    y <- tmp$y
    rm(tmp)
  }
  modelFit <- method$fit(x = x, y = y, wts = wts, param = tuneValue, lev = obsLevels, last = last, classProbs = classProbs, ...)
  if (is.null(method$label)) 
    method$label <- ""
  if (!isS4(modelFit) & !(method$label %in% c("Ensemble Partial Least Squares Regression", "Ensemble Partial Least Squares Regression with Feature Selection"))) {
    modelFit$xNames <- colnames(x)
    modelFit$problemType <- if (is.factor(y)) 
      "Classification"
    else "Regression"
    modelFit$tuneValue <- tuneValue
    modelFit$obsLevels <- obsLevels
    modelFit$param <- list(...)
  }
  list(fit = modelFit, preProc = ppObj)
}, function (x, y, wts, method, tuneValue, obsLevels, pp = NULL, last = FALSE, sampling = NULL, classProbs, ...) 
{
  if (is.data.frame(x) | is.matrix(x)) 
    rownames(x) <- make.names(rownames(x), unique = TRUE)
  if (!is.null(sampling) && sampling$first) {
    tmp <- sampling$func(x, y)
    x <- tmp$x
    y <- tmp$y
    rm(tmp)
  }
  if (!is.null(pp$options)) {
    pp$method <- pp$options
    pp$options <- NULL
    if ("ica" %in% pp$method) 
      pp$n.comp <- pp$ICAcomp
    pp$ICAcomp <- NULL
    pp$x <- x
    pp$outcome <- y
    ppObj <- do.call("preProcess", pp)
    ppObj$call <- "scrubed"
    x <- predict(ppObj, x)
    rm(pp)
  }
  else ppObj <- NULL
  if (!is.null(sampling) && !sampling$first) {
    tmp <- sampling$func(x, y)
    x <- tmp$x
    y <- tmp$y
    rm(tmp)
  }
  modelFit <- method$fit(x = x, y = y, wts = wts, param = tuneValue, lev = obsLevels, last = last, classProbs = classProbs, ...)
  if (is.null(method$label)) 
    method$label <- ""
  if (!isS4(modelFit) & !(method$label %in% c("Ensemble Partial Least Squares Regression", "Ensemble Partial Least Squares Regression with Feature Selection"))) {
    modelFit$xNames <- colnames(x)
    modelFit$problemType <- if (is.factor(y)) 
      "Classification"
    else "Regression"
    modelFit$tuneValue <- tuneValue
    modelFit$obsLevels <- obsLevels
    modelFit$param <- list(...)
  }
  list(fit = modelFit, preProc = ppObj)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
createMultiFolds
list(`package:caret` = function (y, k = 10, times = 5) 
{
  if (inherits(y, "Surv")) 
    y <- y[, "time"]
  prettyNums <- paste("Rep", gsub(" ", "0", format(1:times)), sep = "")
  for (i in 1:times) {
    tmp <- createFolds(y, k = k, list = TRUE, returnTrain = TRUE)
    names(tmp) <- paste("Fold", gsub(" ", "0", format(seq(along = tmp))), ".", prettyNums[i], sep = "")
    out <- if (i == 1) 
      tmp
    else c(out, tmp)
  }
  out
}, function (y, k = 10, times = 5) 
{
  if (inherits(y, "Surv")) 
    y <- y[, "time"]
  prettyNums <- paste("Rep", gsub(" ", "0", format(1:times)), sep = "")
  for (i in 1:times) {
    tmp <- createFolds(y, k = k, list = TRUE, returnTrain = TRUE)
    names(tmp) <- paste("Fold", gsub(" ", "0", format(seq(along = tmp))), ".", prettyNums[i], sep = "")
    out <- if (i == 1) 
      tmp
    else c(out, tmp)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
createResample
list(`package:caret` = function (y, times = 10, list = TRUE) 
{
  if (inherits(y, "Surv")) 
    y <- y[, "time"]
  trainIndex <- matrix(0, ncol = times, nrow = length(y))
  out <- apply(trainIndex, 2, function(data) {
    index <- seq(along = data)
    out <- sort(sample(index, size = length(index), replace = TRUE))
    out
  })
  if (list) {
    out <- as.data.frame(out, stringsAsFactors = TRUE)
    attributes(out) <- NULL
    names(out) <- prettySeq(out)
  }
  else {
    colnames(out) <- prettySeq(1:ncol(out))
  }
  out
}, function (y, times = 10, list = TRUE) 
{
  if (inherits(y, "Surv")) 
    y <- y[, "time"]
  trainIndex <- matrix(0, ncol = times, nrow = length(y))
  out <- apply(trainIndex, 2, function(data) {
    index <- seq(along = data)
    out <- sort(sample(index, size = length(index), replace = TRUE))
    out
  })
  if (list) {
    out <- as.data.frame(out, stringsAsFactors = TRUE)
    attributes(out) <- NULL
    names(out) <- prettySeq(out)
  }
  else {
    colnames(out) <- prettySeq(1:ncol(out))
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
createTimeSlices
list(`package:caret` = function (y, initialWindow, horizon = 1, fixedWindow = TRUE, skip = 0) 
{
  stops <- seq(initialWindow, (length(y) - horizon), by = skip + 1)
  if (fixedWindow) {
    starts <- stops - initialWindow + 1
  }
  else {
    starts <- rep(1, length(stops))
  }
  train <- mapply(seq, starts, stops, SIMPLIFY = FALSE)
  test <- mapply(seq, stops + 1, stops + horizon, SIMPLIFY = FALSE)
  nums <- gsub(" ", "0", format(stops))
  names(train) <- paste("Training", nums, sep = "")
  names(test) <- paste("Testing", nums, sep = "")
  out <- list(train = train, test = test)
  out
}, function (y, initialWindow, horizon = 1, fixedWindow = TRUE, skip = 0) 
{
  stops <- seq(initialWindow, (length(y) - horizon), by = skip + 1)
  if (fixedWindow) {
    starts <- stops - initialWindow + 1
  }
  else {
    starts <- rep(1, length(stops))
  }
  train <- mapply(seq, starts, stops, SIMPLIFY = FALSE)
  test <- mapply(seq, stops + 1, stops + horizon, SIMPLIFY = FALSE)
  nums <- gsub(" ", "0", format(stops))
  names(train) <- paste("Training", nums, sep = "")
  names(test) <- paste("Testing", nums, sep = "")
  out <- list(train = train, test = test)
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
ctreeBag
list(`package:caret` = list(fit = function (x, y, ...) 
{
  loadNamespace("party")
  data <- as.data.frame(x, stringsAsFactors = TRUE)
  data$y <- y
  party::ctree(y ~ ., data = data)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  obsLevels <- levels(object@data@get("response")[, 1])
  if (!is.null(obsLevels)) {
    rawProbs <- party::treeresponse(object, x)
    probMatrix <- matrix(unlist(rawProbs), ncol = length(obsLevels), byrow = TRUE)
    out <- data.frame(probMatrix)
    colnames(out) <- obsLevels
    rownames(out) <- NULL
  }
  else out <- unlist(party::treeresponse(object, x))
  out
}, aggregate = function (x, type = "class") 
{
  if (is.matrix(x[[1]]) | is.data.frame(x[[1]])) {
    pooled <- x[[1]] & NA
    classes <- colnames(pooled)
    for (i in 1:ncol(pooled)) {
      tmp <- lapply(x, function(y, col) y[, col], col = i)
      tmp <- do.call("rbind", tmp)
      pooled[, i] <- apply(tmp, 2, median)
    }
    if (type == "class") {
      out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
    }
    else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  }
  else {
    x <- matrix(unlist(x), ncol = length(x))
    out <- apply(x, 1, median)
  }
  out
}), list(fit = function (x, y, ...) 
{
  loadNamespace("party")
  data <- as.data.frame(x, stringsAsFactors = TRUE)
  data$y <- y
  party::ctree(y ~ ., data = data)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  obsLevels <- levels(object@data@get("response")[, 1])
  if (!is.null(obsLevels)) {
    rawProbs <- party::treeresponse(object, x)
    probMatrix <- matrix(unlist(rawProbs), ncol = length(obsLevels), byrow = TRUE)
    out <- data.frame(probMatrix)
    colnames(out) <- obsLevels
    rownames(out) <- NULL
  }
  else out <- unlist(party::treeresponse(object, x))
  out
}, aggregate = function (x, type = "class") 
{
  if (is.matrix(x[[1]]) | is.data.frame(x[[1]])) {
    pooled <- x[[1]] & NA
    classes <- colnames(pooled)
    for (i in 1:ncol(pooled)) {
      tmp <- lapply(x, function(y, col) y[, col], col = i)
      tmp <- do.call("rbind", tmp)
      pooled[, i] <- apply(tmp, 2, median)
    }
    if (type == "class") {
      out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
    }
    else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  }
  else {
    x <- matrix(unlist(x), ncol = length(x))
    out <- apply(x, 1, median)
  }
  out
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
defaultSummary
list(`package:caret` = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
dotPlot
list(`package:caret` = function (x, top = min(20, dim(x$importance)[1]), ...) 
{
  varSubset <- sortImp(x, top)
  plotObj <- stack(varSubset)
  if (dim(varSubset)[2] == 1) {
    plotObj <- varSubset
    names(plotObj) <- "values"
    plotObj$ind <- "Overall"
  }
  else plotObj <- stack(varSubset)
  plotObj$Var <- rep(rownames(varSubset), dim(varSubset)[2])
  plotObj$Var <- factor(plotObj$Var, levels = rev(rownames(varSubset)))
  if (dim(varSubset)[2] < 3) {
    if (dim(varSubset)[2] > 1) 
      plotObj <- plotObj[plotObj$ind == levels(plotObj$ind)[1], ]
    out <- dotplot(Var ~ values, data = plotObj, as.table = TRUE, xlab = "Importance", ...)
  }
  else {
    out <- dotplot(Var ~ values, data = plotObj, groups = plotObj$ind, auto.key = list(columns = min(3, length(levels(plotObj$ind)))), as.table = TRUE, xlab = "Importance", ...)
  }
  out
}, function (x, top = min(20, dim(x$importance)[1]), ...) 
{
  varSubset <- sortImp(x, top)
  plotObj <- stack(varSubset)
  if (dim(varSubset)[2] == 1) {
    plotObj <- varSubset
    names(plotObj) <- "values"
    plotObj$ind <- "Overall"
  }
  else plotObj <- stack(varSubset)
  plotObj$Var <- rep(rownames(varSubset), dim(varSubset)[2])
  plotObj$Var <- factor(plotObj$Var, levels = rev(rownames(varSubset)))
  if (dim(varSubset)[2] < 3) {
    if (dim(varSubset)[2] > 1) 
      plotObj <- plotObj[plotObj$ind == levels(plotObj$ind)[1], ]
    out <- dotplot(Var ~ values, data = plotObj, as.table = TRUE, xlab = "Importance", ...)
  }
  else {
    out <- dotplot(Var ~ values, data = plotObj, groups = plotObj$ind, auto.key = list(columns = min(3, length(levels(plotObj$ind)))), as.table = TRUE, xlab = "Importance", ...)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
downSample
list(`package:caret` = function (x, y, list = FALSE, yname = "Class") 
{
  if (!is.data.frame(x)) {
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  }
  if (!is.factor(y)) {
    warning("Down-sampling requires a factor variable as the response. The original data was returned.")
    return(list(x = x, y = y))
  }
  minClass <- min(table(y))
  x$.outcome <- y
  x <- ddply(x, .(y), function(dat, n) dat[sample(seq(along = dat$.outcome), n), , drop = FALSE], n = minClass)
  y <- x$.outcome
  x <- x[, !(colnames(x) %in% c("y", ".outcome")), drop = FALSE]
  if (list) {
    if (inherits(x, "matrix")) {
      x <- as.matrix(x)
    }
    out <- list(x = x, y = y)
  }
  else {
    out <- cbind(x, y)
    colnames(out)[ncol(out)] <- yname
  }
  out
}, function (x, y, list = FALSE, yname = "Class") 
{
  if (!is.data.frame(x)) {
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  }
  if (!is.factor(y)) {
    warning("Down-sampling requires a factor variable as the response. The original data was returned.")
    return(list(x = x, y = y))
  }
  minClass <- min(table(y))
  x$.outcome <- y
  x <- ddply(x, .(y), function(dat, n) dat[sample(seq(along = dat$.outcome), n), , drop = FALSE], n = minClass)
  y <- x$.outcome
  x <- x[, !(colnames(x) %in% c("y", ".outcome")), drop = FALSE]
  if (list) {
    if (inherits(x, "matrix")) {
      x <- as.matrix(x)
    }
    out <- list(x = x, y = y)
  }
  else {
    out <- cbind(x, y)
    colnames(out)[ncol(out)] <- yname
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
dummyVars
list(`package:caret` = function (formula, ...) 
{
  UseMethod("dummyVars")
}, function (formula, ...) 
{
  UseMethod("dummyVars")
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
expandParameters
list(`package:caret` = function (fixed, seq) 
{
  if (is.null(seq)) 
    return(fixed)
  isSeq <- names(fixed) %in% names(seq)
  out <- fixed
  for (i in 1:nrow(seq)) {
    tmp <- fixed
    tmp[, isSeq] <- seq[i, ]
    out <- rbind(out, tmp)
  }
  out
}, function (fixed, seq) 
{
  if (is.null(seq)) 
    return(fixed)
  isSeq <- names(fixed) %in% names(seq)
  out <- fixed
  for (i in 1:nrow(seq)) {
    tmp <- fixed
    tmp[, isSeq] <- seq[i, ]
    out <- rbind(out, tmp)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
expoTrans
list(`package:caret` = function (y, ...) 
  UseMethod("expoTrans"), function (y, ...) 
    UseMethod("expoTrans"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
extractPrediction
list(`package:caret` = function (models, testX = NULL, testY = NULL, unkX = NULL, unkOnly = !is.null(unkX) & is.null(testX), verbose = FALSE) 
{
  objectNames <- names(models)
  if (is.null(objectNames)) 
    objectNames <- paste("Object", 1:length(models), sep = "")
  if (!unkOnly) {
    trainX <- models[[1]]$trainingData[, !(colnames(models[[1]]$trainingData) %in% ".outcome"), drop = FALSE]
    trainY <- models[[1]]$trainingData$.outcome
  }
  obsLevels <- levels(models[[1]])
  if (verbose) {
    cat("Number of training samples:", length(trainY), "\n")
    cat("Number of test samples:    ", length(testY), "\n\n")
  }
  pred <- obs <- modelName <- dataType <- objName <- NULL
  if (!is.null(testX)) {
    hasNa <- apply(testX, 1, function(data) any(is.na(data)))
    if (verbose) 
      cat("There were ", sum(hasNa), "rows with missing values\n\n")
  }
  for (i in seq(along = models)) {
    if (!unkOnly) {
      tempTrainPred <- predictionFunction(models[[i]]$modelInfo, models[[i]]$finalModel, trainX, models[[i]]$preProcess)
      if (verbose) 
        cat(models[[i]]$method, ":", length(tempTrainPred), "training predictions were added\n")
      if (models[[i]]$modelType == "Classification") {
        pred <- c(pred, as.character(tempTrainPred))
        obs <- c(obs, as.character(trainY))
      }
      else {
        tempTrainPred <- trimPredictions(mod_type = models[[i]]$modelType, bounds = models[[i]]$control$predictionBounds, limits = models[[i]]$yLimit, pred = tempTrainPred)
        pred <- c(pred, tempTrainPred)
        obs <- c(obs, trainY)
      }
      modelName <- c(modelName, rep(models[[i]]$method, length(tempTrainPred)))
      objName <- c(objName, rep(objectNames[[i]], length(tempTrainPred)))
      dataType <- c(dataType, rep("Training", length(tempTrainPred)))
      if (!is.null(testX) & !is.null(testY)) {
        if (any(colnames(testX) == ".outcome")) 
          testX <- testX[, colnames(testX) != ".outcome", drop = FALSE]
        tempTestPred <- predictionFunction(models[[i]]$modelInfo, models[[i]]$finalModel, testX, models[[i]]$preProcess)
        if (verbose) 
          cat(models[[i]]$method, ":", length(tempTestPred), "test predictions were added\n")
        if (models[[i]]$modelType == "Classification") {
          pred <- c(pred, as.character(tempTestPred))
          obs <- c(obs, as.character(testY))
        }
        else {
          tempTestPred <- trimPredictions(mod_type = models[[i]]$modelType, bounds = models[[i]]$control$predictionBounds, limits = models[[i]]$yLimit, pred = tempTestPred)
          pred <- c(pred, tempTestPred)
          obs <- c(obs, testY)
        }
        modelName <- c(modelName, rep(models[[i]]$method, length(tempTestPred)))
        objName <- c(objName, rep(objectNames[[i]], length(tempTestPred)))
        dataType <- c(dataType, rep("Test", length(tempTestPred)))
      }
      if (verbose) 
        cat("\n")
    }
    if (!is.null(unkX)) {
      if (any(colnames(unkX) == ".outcome")) 
        unkX <- unkX[, colnames(unkX) != ".outcome", drop = FALSE]
      tempUnkPred <- predictionFunction(models[[i]]$modelInfo, models[[i]]$finalModel, unkX, models[[i]]$preProcess)
      if (verbose) 
        cat(models[[i]]$method, ":", length(tempUnkPred), "unknown predictions were added\n")
      if (models[[i]]$modelType == "Classification") {
        pred <- c(pred, as.character(tempUnkPred))
        obs <- c(obs, rep("", length(tempUnkPred)))
      }
      else {
        tempUnkPred <- trimPredictions(mod_type = models[[i]]$modelType, bounds = models[[i]]$control$predictionBounds, limits = models[[i]]$yLimit, pred = tempUnkPred)
        pred <- c(pred, tempUnkPred)
        obs <- c(obs, rep(NA, length(tempUnkPred)))
      }
      modelName <- c(modelName, rep(models[[i]]$method, length(tempUnkPred)))
      objName <- c(objName, rep(objectNames[[i]], length(tempUnkPred)))
      dataType <- c(dataType, rep("Unknown", length(tempUnkPred)))
    }
    if (verbose) 
      cat("\n")
  }
  if (models[[1]]$modelType == "Classification") {
    pred <- factor(pred, levels = obsLevels)
    obs <- factor(obs, levels = obsLevels)
  }
  data.frame(obs = obs, pred = pred, model = modelName, dataType = dataType, object = objName)
}, function (models, testX = NULL, testY = NULL, unkX = NULL, unkOnly = !is.null(unkX) & is.null(testX), verbose = FALSE) 
{
  objectNames <- names(models)
  if (is.null(objectNames)) 
    objectNames <- paste("Object", 1:length(models), sep = "")
  if (!unkOnly) {
    trainX <- models[[1]]$trainingData[, !(colnames(models[[1]]$trainingData) %in% ".outcome"), drop = FALSE]
    trainY <- models[[1]]$trainingData$.outcome
  }
  obsLevels <- levels(models[[1]])
  if (verbose) {
    cat("Number of training samples:", length(trainY), "\n")
    cat("Number of test samples:    ", length(testY), "\n\n")
  }
  pred <- obs <- modelName <- dataType <- objName <- NULL
  if (!is.null(testX)) {
    hasNa <- apply(testX, 1, function(data) any(is.na(data)))
    if (verbose) 
      cat("There were ", sum(hasNa), "rows with missing values\n\n")
  }
  for (i in seq(along = models)) {
    if (!unkOnly) {
      tempTrainPred <- predictionFunction(models[[i]]$modelInfo, models[[i]]$finalModel, trainX, models[[i]]$preProcess)
      if (verbose) 
        cat(models[[i]]$method, ":", length(tempTrainPred), "training predictions were added\n")
      if (models[[i]]$modelType == "Classification") {
        pred <- c(pred, as.character(tempTrainPred))
        obs <- c(obs, as.character(trainY))
      }
      else {
        tempTrainPred <- trimPredictions(mod_type = models[[i]]$modelType, bounds = models[[i]]$control$predictionBounds, limits = models[[i]]$yLimit, pred = tempTrainPred)
        pred <- c(pred, tempTrainPred)
        obs <- c(obs, trainY)
      }
      modelName <- c(modelName, rep(models[[i]]$method, length(tempTrainPred)))
      objName <- c(objName, rep(objectNames[[i]], length(tempTrainPred)))
      dataType <- c(dataType, rep("Training", length(tempTrainPred)))
      if (!is.null(testX) & !is.null(testY)) {
        if (any(colnames(testX) == ".outcome")) 
          testX <- testX[, colnames(testX) != ".outcome", drop = FALSE]
        tempTestPred <- predictionFunction(models[[i]]$modelInfo, models[[i]]$finalModel, testX, models[[i]]$preProcess)
        if (verbose) 
          cat(models[[i]]$method, ":", length(tempTestPred), "test predictions were added\n")
        if (models[[i]]$modelType == "Classification") {
          pred <- c(pred, as.character(tempTestPred))
          obs <- c(obs, as.character(testY))
        }
        else {
          tempTestPred <- trimPredictions(mod_type = models[[i]]$modelType, bounds = models[[i]]$control$predictionBounds, limits = models[[i]]$yLimit, pred = tempTestPred)
          pred <- c(pred, tempTestPred)
          obs <- c(obs, testY)
        }
        modelName <- c(modelName, rep(models[[i]]$method, length(tempTestPred)))
        objName <- c(objName, rep(objectNames[[i]], length(tempTestPred)))
        dataType <- c(dataType, rep("Test", length(tempTestPred)))
      }
      if (verbose) 
        cat("\n")
    }
    if (!is.null(unkX)) {
      if (any(colnames(unkX) == ".outcome")) 
        unkX <- unkX[, colnames(unkX) != ".outcome", drop = FALSE]
      tempUnkPred <- predictionFunction(models[[i]]$modelInfo, models[[i]]$finalModel, unkX, models[[i]]$preProcess)
      if (verbose) 
        cat(models[[i]]$method, ":", length(tempUnkPred), "unknown predictions were added\n")
      if (models[[i]]$modelType == "Classification") {
        pred <- c(pred, as.character(tempUnkPred))
        obs <- c(obs, rep("", length(tempUnkPred)))
      }
      else {
        tempUnkPred <- trimPredictions(mod_type = models[[i]]$modelType, bounds = models[[i]]$control$predictionBounds, limits = models[[i]]$yLimit, pred = tempUnkPred)
        pred <- c(pred, tempUnkPred)
        obs <- c(obs, rep(NA, length(tempUnkPred)))
      }
      modelName <- c(modelName, rep(models[[i]]$method, length(tempUnkPred)))
      objName <- c(objName, rep(objectNames[[i]], length(tempUnkPred)))
      dataType <- c(dataType, rep("Unknown", length(tempUnkPred)))
    }
    if (verbose) 
      cat("\n")
  }
  if (models[[1]]$modelType == "Classification") {
    pred <- factor(pred, levels = obsLevels)
    obs <- factor(obs, levels = obsLevels)
  }
  data.frame(obs = obs, pred = pred, model = modelName, dataType = dataType, object = objName)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
extractProb
list(`package:caret` = function (models, testX = NULL, testY = NULL, unkX = NULL, unkOnly = !is.null(unkX) & is.null(testX), verbose = FALSE) 
{
  objectNames <- names(models)
  if (is.null(objectNames)) 
    objectNames <- paste("Object", 1:length(models), sep = "")
  if (any(unlist(lapply(models, function(x) is.null(x$modelInfo$prob))))) 
    stop("only classification models that produce probabilities are allowed")
  obsLevels <- levels(models[[1]])
  if (!unkOnly) {
    trainX <- models[[1]]$trainingData[, !(colnames(models[[1]]$trainingData) %in% ".outcome"), drop = FALSE]
    trainY <- models[[1]]$trainingData$.outcome
  }
  if (verbose) {
    cat("Number of training samples:", length(trainY), "\n")
    cat("Number of test samples:    ", length(testY), "\n\n")
  }
  predProb <- predClass <- obs <- modelName <- dataType <- objName <- NULL
  if (!is.null(testX)) {
    if (!is.data.frame(testX)) 
      testX <- as.data.frame(testX, stringsAsFactors = TRUE)
    hasNa <- apply(testX, 1, function(data) any(is.na(data)))
    if (verbose) 
      cat("There were ", sum(hasNa), "rows with missing values\n\n")
    flush.console()
  }
  for (i in seq(along = models)) {
    if (verbose) 
      cat("starting ", models[[i]]$method, "\n")
    flush.console()
    if (!unkOnly) {
      tempTrainProb <- probFunction(models[[i]]$modelInfo, models[[i]]$finalModel, trainX, models[[i]]$preProcess)
      tempTrainPred <- apply(tempTrainProb, 1, which.max)
      tempTrainPred <- colnames(tempTrainProb)[tempTrainPred]
      tempTrainPred <- factor(tempTrainPred, levels = obsLevels)
      if (verbose) 
        cat(models[[i]]$method, ":", length(tempTrainPred), "training predictions were added\n")
      flush.console()
      predProb <- if (is.null(predProb)) 
        tempTrainProb
      else rbind(predProb, tempTrainProb)
      predClass <- c(predClass, as.character(tempTrainPred))
      obs <- c(obs, as.character(trainY))
      modelName <- c(modelName, rep(models[[i]]$method, length(tempTrainPred)))
      objName <- c(objName, rep(objectNames[[i]], length(tempTrainPred)))
      dataType <- c(dataType, rep("Training", length(tempTrainPred)))
      if (!is.null(testX) & !is.null(testY)) {
        if (!is.data.frame(testX)) 
          testX <- as.data.frame(testX, stringsAsFactors = TRUE)
        tempX <- testX
        tempY <- testY
        tempX$.outcome <- NULL
        tempTestProb <- probFunction(models[[i]]$modelInfo, models[[i]]$finalModel, tempX, models[[i]]$preProcess)
        tempTestPred <- apply(tempTestProb, 1, which.max)
        tempTestPred <- colnames(tempTestProb)[tempTestPred]
        tempTestPred <- factor(tempTestPred, levels = obsLevels)
        if (verbose) 
          cat(models[[i]]$method, ":", length(tempTestPred), "test predictions were added\n")
        predProb <- if (is.null(predProb)) 
          tempTestProb
        else rbind(predProb, tempTestProb)
        predClass <- c(predClass, as.character(tempTestPred))
        obs <- c(obs, as.character(testY))
        modelName <- c(modelName, rep(models[[i]]$method, length(tempTestPred)))
        objName <- c(objName, rep(objectNames[[i]], length(tempTestPred)))
        dataType <- c(dataType, rep("Test", length(tempTestPred)))
      }
    }
    if (!is.null(unkX)) {
      if (!is.data.frame(unkX)) 
        unkX <- as.data.frame(unkX, stringsAsFactors = TRUE)
      tempX <- unkX
      tempX$.outcome <- NULL
      tempUnkProb <- probFunction(models[[i]]$modelInfo, models[[i]]$finalModel, tempX, models[[i]]$preProcess)
      tempUnkPred <- apply(tempUnkProb, 1, which.max)
      tempUnkPred <- colnames(tempUnkProb)[tempUnkPred]
      tempUnkPred <- factor(tempUnkPred, levels = obsLevels)
      if (verbose) 
        cat(models[[i]]$method, ":", length(tempUnkPred), "unknown predictions were added\n")
      predProb <- if (is.null(predProb)) 
        tempUnkProb
      else rbind(predProb, tempUnkProb)
      predClass <- c(predClass, as.character(tempUnkPred))
      obs <- c(obs, rep(NA, length(tempUnkPred)))
      modelName <- c(modelName, rep(models[[i]]$method, length(tempUnkPred)))
      objName <- c(objName, rep(objectNames[[i]], length(tempUnkPred)))
      dataType <- c(dataType, rep("Unknown", length(tempUnkPred)))
    }
    if (verbose) 
      cat("\n")
  }
  predClass <- factor(predClass, levels = obsLevels)
  obs <- factor(obs, levels = obsLevels)
  out <- data.frame(predProb)
  out$obs <- obs
  out$pred <- predClass
  out$model <- modelName
  out$dataType <- dataType
  out$object <- objName
  out
}, function (models, testX = NULL, testY = NULL, unkX = NULL, unkOnly = !is.null(unkX) & is.null(testX), verbose = FALSE) 
{
  objectNames <- names(models)
  if (is.null(objectNames)) 
    objectNames <- paste("Object", 1:length(models), sep = "")
  if (any(unlist(lapply(models, function(x) is.null(x$modelInfo$prob))))) 
    stop("only classification models that produce probabilities are allowed")
  obsLevels <- levels(models[[1]])
  if (!unkOnly) {
    trainX <- models[[1]]$trainingData[, !(colnames(models[[1]]$trainingData) %in% ".outcome"), drop = FALSE]
    trainY <- models[[1]]$trainingData$.outcome
  }
  if (verbose) {
    cat("Number of training samples:", length(trainY), "\n")
    cat("Number of test samples:    ", length(testY), "\n\n")
  }
  predProb <- predClass <- obs <- modelName <- dataType <- objName <- NULL
  if (!is.null(testX)) {
    if (!is.data.frame(testX)) 
      testX <- as.data.frame(testX, stringsAsFactors = TRUE)
    hasNa <- apply(testX, 1, function(data) any(is.na(data)))
    if (verbose) 
      cat("There were ", sum(hasNa), "rows with missing values\n\n")
    flush.console()
  }
  for (i in seq(along = models)) {
    if (verbose) 
      cat("starting ", models[[i]]$method, "\n")
    flush.console()
    if (!unkOnly) {
      tempTrainProb <- probFunction(models[[i]]$modelInfo, models[[i]]$finalModel, trainX, models[[i]]$preProcess)
      tempTrainPred <- apply(tempTrainProb, 1, which.max)
      tempTrainPred <- colnames(tempTrainProb)[tempTrainPred]
      tempTrainPred <- factor(tempTrainPred, levels = obsLevels)
      if (verbose) 
        cat(models[[i]]$method, ":", length(tempTrainPred), "training predictions were added\n")
      flush.console()
      predProb <- if (is.null(predProb)) 
        tempTrainProb
      else rbind(predProb, tempTrainProb)
      predClass <- c(predClass, as.character(tempTrainPred))
      obs <- c(obs, as.character(trainY))
      modelName <- c(modelName, rep(models[[i]]$method, length(tempTrainPred)))
      objName <- c(objName, rep(objectNames[[i]], length(tempTrainPred)))
      dataType <- c(dataType, rep("Training", length(tempTrainPred)))
      if (!is.null(testX) & !is.null(testY)) {
        if (!is.data.frame(testX)) 
          testX <- as.data.frame(testX, stringsAsFactors = TRUE)
        tempX <- testX
        tempY <- testY
        tempX$.outcome <- NULL
        tempTestProb <- probFunction(models[[i]]$modelInfo, models[[i]]$finalModel, tempX, models[[i]]$preProcess)
        tempTestPred <- apply(tempTestProb, 1, which.max)
        tempTestPred <- colnames(tempTestProb)[tempTestPred]
        tempTestPred <- factor(tempTestPred, levels = obsLevels)
        if (verbose) 
          cat(models[[i]]$method, ":", length(tempTestPred), "test predictions were added\n")
        predProb <- if (is.null(predProb)) 
          tempTestProb
        else rbind(predProb, tempTestProb)
        predClass <- c(predClass, as.character(tempTestPred))
        obs <- c(obs, as.character(testY))
        modelName <- c(modelName, rep(models[[i]]$method, length(tempTestPred)))
        objName <- c(objName, rep(objectNames[[i]], length(tempTestPred)))
        dataType <- c(dataType, rep("Test", length(tempTestPred)))
      }
    }
    if (!is.null(unkX)) {
      if (!is.data.frame(unkX)) 
        unkX <- as.data.frame(unkX, stringsAsFactors = TRUE)
      tempX <- unkX
      tempX$.outcome <- NULL
      tempUnkProb <- probFunction(models[[i]]$modelInfo, models[[i]]$finalModel, tempX, models[[i]]$preProcess)
      tempUnkPred <- apply(tempUnkProb, 1, which.max)
      tempUnkPred <- colnames(tempUnkProb)[tempUnkPred]
      tempUnkPred <- factor(tempUnkPred, levels = obsLevels)
      if (verbose) 
        cat(models[[i]]$method, ":", length(tempUnkPred), "unknown predictions were added\n")
      predProb <- if (is.null(predProb)) 
        tempUnkProb
      else rbind(predProb, tempUnkProb)
      predClass <- c(predClass, as.character(tempUnkPred))
      obs <- c(obs, rep(NA, length(tempUnkPred)))
      modelName <- c(modelName, rep(models[[i]]$method, length(tempUnkPred)))
      objName <- c(objName, rep(objectNames[[i]], length(tempUnkPred)))
      dataType <- c(dataType, rep("Unknown", length(tempUnkPred)))
    }
    if (verbose) 
      cat("\n")
  }
  predClass <- factor(predClass, levels = obsLevels)
  obs <- factor(obs, levels = obsLevels)
  out <- data.frame(predProb)
  out$obs <- obs
  out$pred <- predClass
  out$model <- modelName
  out$dataType <- dataType
  out$object <- objName
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
F_meas
list(`package:caret` = function (data, ...) 
  UseMethod("F_meas"), function (data, ...) 
    UseMethod("F_meas"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
featurePlot
list(`package:caret` = function (x, y, plot = if (is.factor(y)) "strip" else "scatter", labels = c("Feature", ""), ...) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  numFeat <- dim(x)[2]
  if (plot != "pairs") {
    stackX <- stack(x)
    stackX$.y <- rep(y, numFeat)
  }
  else {
    if (!is.factor(y)) {
      x <- data.frame(cbind(x, y))
    }
  }
  if (is.factor(y)) {
    featPlot <- switch(tolower(plot), strip = stripplot(values ~ .y | ind, stackX, xlab = labels[1], ylab = labels[2], ...), box = , boxplot = bwplot(values ~ .y | ind, stackX, xlab = labels[1], ylab = labels[2], ...), density = densityplot(~values | ind, stackX, groups = stackX$.y, xlab = labels[1], ylab = labels[2], ...), pairs = splom(~x, groups = y, ...), ellipse = splom(~x, groups = y, panel = function(x, y, groups, subscripts, ...) {
      requireNamespaceQuietStop("ellipse")
      lineInfo <- trellis.par.get("superpose.line")
      pointInfo <- trellis.par.get("superpose.symbol")
      uniqueGroups <- sort(unique(groups))
      for (i in seq(along = uniqueGroups)) {
        id <- which(groups[subscripts] == uniqueGroups[i])
        panel.xyplot(x[id], y[id], pch = pointInfo$pch[i], col = pointInfo$col[i], cex = pointInfo$cex[i], ...)
        groupVar <- var(cbind(x[id], y[id]))
        groupMean <- cbind(mean(x[id]), mean(y[id]))
        groupEllipse <- ellipse::ellipse(groupVar, centre = groupMean, level = 0.95)
        panel.xyplot(groupEllipse[, 1], groupEllipse[, 2], type = "l", col = lineInfo$col[i], lty = lineInfo$lty[i], ...)
      }
    }, ...))
  }
  else {
    featPlot <- switch(tolower(plot), scatter = , xyplot = xyplot(.y ~ values | ind, stackX, scales = list(x = list(relation = "free")), xlab = labels[1], ylab = labels[2], ...), pairs = splom(~x, ...))
  }
  featPlot
}, function (x, y, plot = if (is.factor(y)) "strip" else "scatter", labels = c("Feature", ""), ...) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  numFeat <- dim(x)[2]
  if (plot != "pairs") {
    stackX <- stack(x)
    stackX$.y <- rep(y, numFeat)
  }
  else {
    if (!is.factor(y)) {
      x <- data.frame(cbind(x, y))
    }
  }
  if (is.factor(y)) {
    featPlot <- switch(tolower(plot), strip = stripplot(values ~ .y | ind, stackX, xlab = labels[1], ylab = labels[2], ...), box = , boxplot = bwplot(values ~ .y | ind, stackX, xlab = labels[1], ylab = labels[2], ...), density = densityplot(~values | ind, stackX, groups = stackX$.y, xlab = labels[1], ylab = labels[2], ...), pairs = splom(~x, groups = y, ...), ellipse = splom(~x, groups = y, panel = function(x, y, groups, subscripts, ...) {
      requireNamespaceQuietStop("ellipse")
      lineInfo <- trellis.par.get("superpose.line")
      pointInfo <- trellis.par.get("superpose.symbol")
      uniqueGroups <- sort(unique(groups))
      for (i in seq(along = uniqueGroups)) {
        id <- which(groups[subscripts] == uniqueGroups[i])
        panel.xyplot(x[id], y[id], pch = pointInfo$pch[i], col = pointInfo$col[i], cex = pointInfo$cex[i], ...)
        groupVar <- var(cbind(x[id], y[id]))
        groupMean <- cbind(mean(x[id]), mean(y[id]))
        groupEllipse <- ellipse::ellipse(groupVar, centre = groupMean, level = 0.95)
        panel.xyplot(groupEllipse[, 1], groupEllipse[, 2], type = "l", col = lineInfo$col[i], lty = lineInfo$lty[i], ...)
      }
    }, ...))
  }
  else {
    featPlot <- switch(tolower(plot), scatter = , xyplot = xyplot(.y ~ values | ind, stackX, scales = list(x = list(relation = "free")), xlab = labels[1], ylab = labels[2], ...), pairs = splom(~x, ...))
  }
  featPlot
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
filterVarImp
list(`package:caret` = function (x, y, nonpara = FALSE, ...) 
{
  notNumber <- sapply(x, function(x) !is.numeric(x))
  x = asNumeric(x)
  if (is.factor(y)) {
    classLevels <- levels(y)
    k <- length(classLevels)
    if (k > 2) {
      Combs <- combn(classLevels, 2)
      CombsN <- combn(1:k, 2)
      lStat <- lapply(1:ncol(Combs), FUN = function(cc) {
        yLevs <- as.character(y) %in% Combs[, cc]
        tmpX <- x[yLevs, ]
        tmpY <- as.numeric(y[yLevs] == Combs[, cc][2])
        apply(tmpX, 2, rocPerCol, cls = tmpY)
      })
      Stat = do.call("cbind", lStat)
      loutStat <- lapply(1:k, function(j) {
        apply(Stat[, CombsN[, j]], 1, max)
      })
      outStat = do.call("cbind", loutStat)
    }
    else {
      tmp <- apply(x, 2, rocPerCol, cls = y)
      outStat <- cbind(tmp, tmp)
    }
    outStat <- as.data.frame(outStat, stringsAsFactors = FALSE)
    colnames(outStat) <- classLevels
    rownames(outStat) <- dimnames(x)[[2]]
    outStat <- data.frame(outStat)
  }
  else {
    paraFoo <- function(data, y) abs(coef(summary(lm(y ~ data, na.action = na.omit)))[2, "t value"])
    nonparaFoo <- function(x, y, ...) {
      meanMod <- sum((y - mean(y, rm.na = TRUE))^2)
      nzv <- nearZeroVar(x, saveMetrics = TRUE)
      if (nzv$zeroVar) 
        return(NA)
      if (nzv$percentUnique < 20) {
        regMod <- lm(y ~ x, na.action = na.omit, ...)
      }
      else {
        regMod <- try(loess(y ~ x, na.action = na.omit, ...), silent = TRUE)
        if (inherits(regMod, "try-error") | any(is.nan(regMod$residuals))) 
          try(regMod <- lm(y ~ x, ...))
        if (inherits(regMod, "try-error")) 
          return(NA)
      }
      pR2 <- 1 - (sum(resid(regMod)^2)/meanMod)
      if (pR2 < 0) 
        pR2 <- 0
      pR2
    }
    testFunc <- if (nonpara) 
      nonparaFoo
    else paraFoo
    outStat <- apply(x, 2, testFunc, y = y)
    outStat <- data.frame(Overall = outStat)
  }
  outStat
}, function (x, y, nonpara = FALSE, ...) 
{
  notNumber <- sapply(x, function(x) !is.numeric(x))
  x = asNumeric(x)
  if (is.factor(y)) {
    classLevels <- levels(y)
    k <- length(classLevels)
    if (k > 2) {
      Combs <- combn(classLevels, 2)
      CombsN <- combn(1:k, 2)
      lStat <- lapply(1:ncol(Combs), FUN = function(cc) {
        yLevs <- as.character(y) %in% Combs[, cc]
        tmpX <- x[yLevs, ]
        tmpY <- as.numeric(y[yLevs] == Combs[, cc][2])
        apply(tmpX, 2, rocPerCol, cls = tmpY)
      })
      Stat = do.call("cbind", lStat)
      loutStat <- lapply(1:k, function(j) {
        apply(Stat[, CombsN[, j]], 1, max)
      })
      outStat = do.call("cbind", loutStat)
    }
    else {
      tmp <- apply(x, 2, rocPerCol, cls = y)
      outStat <- cbind(tmp, tmp)
    }
    outStat <- as.data.frame(outStat, stringsAsFactors = FALSE)
    colnames(outStat) <- classLevels
    rownames(outStat) <- dimnames(x)[[2]]
    outStat <- data.frame(outStat)
  }
  else {
    paraFoo <- function(data, y) abs(coef(summary(lm(y ~ data, na.action = na.omit)))[2, "t value"])
    nonparaFoo <- function(x, y, ...) {
      meanMod <- sum((y - mean(y, rm.na = TRUE))^2)
      nzv <- nearZeroVar(x, saveMetrics = TRUE)
      if (nzv$zeroVar) 
        return(NA)
      if (nzv$percentUnique < 20) {
        regMod <- lm(y ~ x, na.action = na.omit, ...)
      }
      else {
        regMod <- try(loess(y ~ x, na.action = na.omit, ...), silent = TRUE)
        if (inherits(regMod, "try-error") | any(is.nan(regMod$residuals))) 
          try(regMod <- lm(y ~ x, ...))
        if (inherits(regMod, "try-error")) 
          return(NA)
      }
      pR2 <- 1 - (sum(resid(regMod)^2)/meanMod)
      if (pR2 < 0) 
        pR2 <- 0
      pR2
    }
    testFunc <- if (nonpara) 
      nonparaFoo
    else paraFoo
    outStat <- apply(x, 2, testFunc, y = y)
    outStat <- data.frame(Overall = outStat)
  }
  outStat
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
findCorrelation
list(`package:caret` = function (x, cutoff = 0.9, verbose = FALSE, names = FALSE, exact = ncol(x) < 100) 
{
  if (names & is.null(colnames(x))) 
    stop("'x' must have column names when `names = TRUE`")
  out <- if (exact) 
    findCorrelation_exact(x = x, cutoff = cutoff, verbose = verbose)
  else findCorrelation_fast(x = x, cutoff = cutoff, verbose = verbose)
  out
  if (names) 
    out <- colnames(x)[out]
  out
}, function (x, cutoff = 0.9, verbose = FALSE, names = FALSE, exact = ncol(x) < 100) 
{
  if (names & is.null(colnames(x))) 
    stop("'x' must have column names when `names = TRUE`")
  out <- if (exact) 
    findCorrelation_exact(x = x, cutoff = cutoff, verbose = verbose)
  else findCorrelation_fast(x = x, cutoff = cutoff, verbose = verbose)
  out
  if (names) 
    out <- colnames(x)[out]
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
findLinearCombos
list(`package:caret` = function (x) 
{
  if (!is.matrix(x)) 
    x <- as.matrix(x)
  lcList <- enumLC(x)
  initialList <- lcList
  badList <- NULL
  if (length(lcList) > 0) {
    continue <- TRUE
    while (continue) {
      tmp <- unlist(lapply(lcList, function(x) x[1]))
      tmp <- unique(tmp[!is.na(tmp)])
      badList <- unique(c(tmp, badList))
      lcList <- enumLC(x[, -badList, drop = FALSE])
      continue <- (length(lcList) > 0)
    }
  }
  else badList <- NULL
  list(linearCombos = initialList, remove = badList)
}, function (x) 
{
  if (!is.matrix(x)) 
    x <- as.matrix(x)
  lcList <- enumLC(x)
  initialList <- lcList
  badList <- NULL
  if (length(lcList) > 0) {
    continue <- TRUE
    while (continue) {
      tmp <- unlist(lapply(lcList, function(x) x[1]))
      tmp <- unique(tmp[!is.na(tmp)])
      badList <- unique(c(tmp, badList))
      lcList <- enumLC(x[, -badList, drop = FALSE])
      continue <- (length(lcList) > 0)
    }
  }
  else badList <- NULL
  list(linearCombos = initialList, remove = badList)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
flatTable
list(`package:caret` = function (pred, obs) 
{
  cells <- as.vector(table(pred, obs))
  if (length(cells) == 0) 
    cells <- rep(NA, length(levels(obs))^2)
  names(cells) <- paste(".cell", seq(along = cells), sep = "")
  cells
}, function (pred, obs) 
{
  cells <- as.vector(table(pred, obs))
  if (length(cells) == 0) 
    cells <- rep(NA, length(levels(obs))^2)
  names(cells) <- paste(".cell", seq(along = cells), sep = "")
  cells
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafs
list(`package:caret` = function (x, ...) 
  UseMethod("gafs"), function (x, ...) 
    UseMethod("gafs"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafs.default
list(`package:caret` = function (x, y, iters = 10, popSize = 50, pcrossover = 0.8, pmutation = 0.1, elite = 0, suggestions = NULL, differences = TRUE, gafsControl = gafsControl(), ...) 
{
  startTime <- proc.time()
  funcCall <- match.call(expand.dots = TRUE)
  if (is.null(gafsControl$metric)) 
    gafsControl$metric <- rep(ifelse(is.factor(y), "Accuracy", "RMSE"), 2)
  if (is.null(gafsControl$maximize)) 
    gafsControl$maximize <- rep(ifelse(gafsControl$metric %in% c("RMSE", "MAE", "logLoss"), FALSE, TRUE), 2)
  if (is.null(names(gafsControl$metric))) 
    names(gafsControl$metric) <- c("internal", "external")
  if (is.null(names(gafsControl$maximize))) 
    names(gafsControl$maximize) <- c("internal", "external")
  if (nrow(x) != length(y)) 
    stop("there should be the same number of samples in x and y")
  numFeat <- ncol(x)
  classLevels <- levels(y)
  if (is.null(gafsControl$index)) 
    gafsControl$index <- switch(tolower(gafsControl$method), cv = createFolds(y, gafsControl$number, returnTrain = TRUE), repeatedcv = createMultiFolds(y, gafsControl$number, gafsControl$repeats), loocv = createFolds(y, length(y), returnTrain = TRUE), boot = , boot632 = createResample(y, gafsControl$number), test = createDataPartition(y, 1, gafsControl$p), lgocv = createDataPartition(y, gafsControl$number, gafsControl$p))
  if (is.null(names(gafsControl$index))) 
    names(gafsControl$index) <- getFromNamespace("prettySeq", "caret")(gafsControl$index)
  if (is.null(gafsControl$indexOut)) {
    gafsControl$indexOut <- lapply(gafsControl$index, function(training, allSamples) allSamples[-unique(training)], allSamples = seq(along = y))
    names(gafsControl$indexOut) <- getFromNamespace("prettySeq", "caret")(gafsControl$indexOut)
  }
  if (!is.null(gafsControl$seeds)) {
    if (length(gafsControl$seeds) < length(gafsControl$index) + 1) 
      stop(paste("There must be at least", length(gafsControl$index) + 1, "random number seeds passed to gafsControl"))
  }
  else {
    gafsControl$seeds <- sample.int(1e+05, length(gafsControl$index) + 1)
  }
  testOutput <- data.frame(pred = sample(y, min(10, length(y))), obs = sample(y, min(10, length(y))))
  if (is.factor(y)) 
    for (i in seq(along = classLevels)) testOutput[, classLevels[i]] <- runif(nrow(testOutput))
  test <- gafsControl$functions$fitness_extern(testOutput, lev = classLevels)
  perfNames <- names(test)
  if (is.null(perfNames)) {
    warning(paste("The external fitness results should be a *named* vector;", "new name(s) are", paste(paste0("external", 1:length(test)), sep = "", collapse = ", ")), immediate. = TRUE)
    perfNames <- paste0("external", 1:length(test))
  }
  if (!(gafsControl$metric["external"] %in% perfNames)) {
    warning(paste("The metric '", gafsControl$metric["external"], "' is not created by the summary function; '", perfNames[1], "' will be used instead", sep = ""))
    gafsControl$metric["external"] <- perfNames[1]
  }
  `%op%` <- getOper(gafsControl$allowParallel && getDoParWorkers() > 1)
  result <- foreach(i = seq(along = gafsControl$index), .combine = "c", .verbose = FALSE, .errorhandling = "stop") %op% {
    ga_select(x[gafsControl$index[[i]], , drop = FALSE], y[gafsControl$index[[i]]], funcs = gafsControl$functions, ga_maximize = gafsControl$maximize, ga_metric = gafsControl$metric, iters = iters, popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite, suggestions = suggestions, ga_verbose = gafsControl$verbose, testX = x[gafsControl$indexOut[[i]], , drop = FALSE], testY = y[gafsControl$indexOut[[i]]], ga_seed = gafsControl$seeds[i], Resample = names(gafsControl$index)[i], 
              holdout = gafsControl$holdout, lvl = classLevels, genParallel = gafsControl$genParallel, ...)
  }
  external <- result[names(result) == "external"]
  external <- do.call("rbind", external)
  rownames(external) <- NULL
  internal <- result[names(result) == "internal"]
  internal <- do.call("rbind", internal)
  rownames(internal) <- NULL
  selected_vars <- result[names(result) == "final"]
  names(selected_vars) <- names(gafsControl$index)
  if (differences) {
    diffs <- try(process_diffs(result[names(result) == "diffs"], colnames(x)), silent = TRUE)
    if (class(diffs)[1] == "try-error") {
      diffs <- NULL
    }
  }
  else diffs <- NULL
  rm(result)
  if (gafsControl$verbose) 
    cat("+ final GA\n")
  if (gafsControl$holdout > 0) {
    in_holdout <- createDataPartition(y, p = gafsControl$holdout, list = FALSE)
    in_model <- seq(along = y)[-unique(in_holdout)]
  }
  else {
    in_model <- seq(along = y)
    in_holdout <- NULL
  }
  final_ga <- ga_select(x[in_model, , drop = FALSE], y[in_model], funcs = gafsControl$functions, ga_maximize = gafsControl$maximize, ga_metric = gafsControl$metric, iters = iters, popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite, suggestions = suggestions, ga_verbose = gafsControl$verbose, testX = if (!is.null(in_holdout)) 
    x[in_holdout, , drop = FALSE]
    else NULL, testY = if (!is.null(in_holdout)) 
      y[in_holdout]
    else NULL, ga_seed = gafsControl$seeds[length(gafsControl$seeds)], lvl = classLevels, genParallel = gafsControl$genParallel, ...)
  averages <- ddply(external, .(Iter), function(x, nms) {
    apply(x[, perfNames, drop = FALSE], 2, mean)
  }, nms = perfNames)
  if (!is.null(gafsControl$functions$selectIter)) {
    best_index <- gafsControl$functions$selectIter(averages, metric = gafsControl$metric["external"], maximize = gafsControl$maximize["external"])
    best_iter <- averages$Iter[best_index]
    best_vars <- colnames(x)[final_ga$subsets[[best_index]]]
  }
  else {
    best_index <- if (gafsControl$maximize["external"]) 
      which.max(averages[, gafsControl$metric["external"]])
    else which.min(averages[, gafsControl$metric["external"]])
    best_iter <- averages$Iter[best_index]
    best_vars <- colnames(x)[final_ga$subsets[[best_index]]]
  }
  if (gafsControl$verbose) 
    cat("+ final model\n")
  fit <- gafsControl$functions$fit(x[, best_vars, drop = FALSE], y, lev = lvls, last = TRUE, ...)
  endTime <- proc.time()
  res <- list(fit = fit, ga = final_ga, ga_param = list(popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite), external = external, internal = internal, resampled_vars = selected_vars, averages = averages, iters = iters, optVariables = best_vars, optIter = best_iter, control = gafsControl, dims = dim(x), differences = diffs, perfNames = perfNames, auto = TRUE, the_dots = list(...), call = funcCall, times = list(everything = endTime - startTime), levels = if (is.factor(y)) classLevels else NULL)
  class(res) <- "gafs"
  res
}, function (x, y, iters = 10, popSize = 50, pcrossover = 0.8, pmutation = 0.1, elite = 0, suggestions = NULL, differences = TRUE, gafsControl = gafsControl(), ...) 
{
  startTime <- proc.time()
  funcCall <- match.call(expand.dots = TRUE)
  if (is.null(gafsControl$metric)) 
    gafsControl$metric <- rep(ifelse(is.factor(y), "Accuracy", "RMSE"), 2)
  if (is.null(gafsControl$maximize)) 
    gafsControl$maximize <- rep(ifelse(gafsControl$metric %in% c("RMSE", "MAE", "logLoss"), FALSE, TRUE), 2)
  if (is.null(names(gafsControl$metric))) 
    names(gafsControl$metric) <- c("internal", "external")
  if (is.null(names(gafsControl$maximize))) 
    names(gafsControl$maximize) <- c("internal", "external")
  if (nrow(x) != length(y)) 
    stop("there should be the same number of samples in x and y")
  numFeat <- ncol(x)
  classLevels <- levels(y)
  if (is.null(gafsControl$index)) 
    gafsControl$index <- switch(tolower(gafsControl$method), cv = createFolds(y, gafsControl$number, returnTrain = TRUE), repeatedcv = createMultiFolds(y, gafsControl$number, gafsControl$repeats), loocv = createFolds(y, length(y), returnTrain = TRUE), boot = , boot632 = createResample(y, gafsControl$number), test = createDataPartition(y, 1, gafsControl$p), lgocv = createDataPartition(y, gafsControl$number, gafsControl$p))
  if (is.null(names(gafsControl$index))) 
    names(gafsControl$index) <- getFromNamespace("prettySeq", "caret")(gafsControl$index)
  if (is.null(gafsControl$indexOut)) {
    gafsControl$indexOut <- lapply(gafsControl$index, function(training, allSamples) allSamples[-unique(training)], allSamples = seq(along = y))
    names(gafsControl$indexOut) <- getFromNamespace("prettySeq", "caret")(gafsControl$indexOut)
  }
  if (!is.null(gafsControl$seeds)) {
    if (length(gafsControl$seeds) < length(gafsControl$index) + 1) 
      stop(paste("There must be at least", length(gafsControl$index) + 1, "random number seeds passed to gafsControl"))
  }
  else {
    gafsControl$seeds <- sample.int(1e+05, length(gafsControl$index) + 1)
  }
  testOutput <- data.frame(pred = sample(y, min(10, length(y))), obs = sample(y, min(10, length(y))))
  if (is.factor(y)) 
    for (i in seq(along = classLevels)) testOutput[, classLevels[i]] <- runif(nrow(testOutput))
  test <- gafsControl$functions$fitness_extern(testOutput, lev = classLevels)
  perfNames <- names(test)
  if (is.null(perfNames)) {
    warning(paste("The external fitness results should be a *named* vector;", "new name(s) are", paste(paste0("external", 1:length(test)), sep = "", collapse = ", ")), immediate. = TRUE)
    perfNames <- paste0("external", 1:length(test))
  }
  if (!(gafsControl$metric["external"] %in% perfNames)) {
    warning(paste("The metric '", gafsControl$metric["external"], "' is not created by the summary function; '", perfNames[1], "' will be used instead", sep = ""))
    gafsControl$metric["external"] <- perfNames[1]
  }
  `%op%` <- getOper(gafsControl$allowParallel && getDoParWorkers() > 1)
  result <- foreach(i = seq(along = gafsControl$index), .combine = "c", .verbose = FALSE, .errorhandling = "stop") %op% {
    ga_select(x[gafsControl$index[[i]], , drop = FALSE], y[gafsControl$index[[i]]], funcs = gafsControl$functions, ga_maximize = gafsControl$maximize, ga_metric = gafsControl$metric, iters = iters, popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite, suggestions = suggestions, ga_verbose = gafsControl$verbose, testX = x[gafsControl$indexOut[[i]], , drop = FALSE], testY = y[gafsControl$indexOut[[i]]], ga_seed = gafsControl$seeds[i], Resample = names(gafsControl$index)[i], 
              holdout = gafsControl$holdout, lvl = classLevels, genParallel = gafsControl$genParallel, ...)
  }
  external <- result[names(result) == "external"]
  external <- do.call("rbind", external)
  rownames(external) <- NULL
  internal <- result[names(result) == "internal"]
  internal <- do.call("rbind", internal)
  rownames(internal) <- NULL
  selected_vars <- result[names(result) == "final"]
  names(selected_vars) <- names(gafsControl$index)
  if (differences) {
    diffs <- try(process_diffs(result[names(result) == "diffs"], colnames(x)), silent = TRUE)
    if (class(diffs)[1] == "try-error") {
      diffs <- NULL
    }
  }
  else diffs <- NULL
  rm(result)
  if (gafsControl$verbose) 
    cat("+ final GA\n")
  if (gafsControl$holdout > 0) {
    in_holdout <- createDataPartition(y, p = gafsControl$holdout, list = FALSE)
    in_model <- seq(along = y)[-unique(in_holdout)]
  }
  else {
    in_model <- seq(along = y)
    in_holdout <- NULL
  }
  final_ga <- ga_select(x[in_model, , drop = FALSE], y[in_model], funcs = gafsControl$functions, ga_maximize = gafsControl$maximize, ga_metric = gafsControl$metric, iters = iters, popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite, suggestions = suggestions, ga_verbose = gafsControl$verbose, testX = if (!is.null(in_holdout)) 
    x[in_holdout, , drop = FALSE]
    else NULL, testY = if (!is.null(in_holdout)) 
      y[in_holdout]
    else NULL, ga_seed = gafsControl$seeds[length(gafsControl$seeds)], lvl = classLevels, genParallel = gafsControl$genParallel, ...)
  averages <- ddply(external, .(Iter), function(x, nms) {
    apply(x[, perfNames, drop = FALSE], 2, mean)
  }, nms = perfNames)
  if (!is.null(gafsControl$functions$selectIter)) {
    best_index <- gafsControl$functions$selectIter(averages, metric = gafsControl$metric["external"], maximize = gafsControl$maximize["external"])
    best_iter <- averages$Iter[best_index]
    best_vars <- colnames(x)[final_ga$subsets[[best_index]]]
  }
  else {
    best_index <- if (gafsControl$maximize["external"]) 
      which.max(averages[, gafsControl$metric["external"]])
    else which.min(averages[, gafsControl$metric["external"]])
    best_iter <- averages$Iter[best_index]
    best_vars <- colnames(x)[final_ga$subsets[[best_index]]]
  }
  if (gafsControl$verbose) 
    cat("+ final model\n")
  fit <- gafsControl$functions$fit(x[, best_vars, drop = FALSE], y, lev = lvls, last = TRUE, ...)
  endTime <- proc.time()
  res <- list(fit = fit, ga = final_ga, ga_param = list(popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite), external = external, internal = internal, resampled_vars = selected_vars, averages = averages, iters = iters, optVariables = best_vars, optIter = best_iter, control = gafsControl, dims = dim(x), differences = diffs, perfNames = perfNames, auto = TRUE, the_dots = list(...), call = funcCall, times = list(everything = endTime - startTime), levels = if (is.factor(y)) classLevels else NULL)
  class(res) <- "gafs"
  res
}, function (x, y, iters = 10, popSize = 50, pcrossover = 0.8, pmutation = 0.1, elite = 0, suggestions = NULL, differences = TRUE, gafsControl = gafsControl(), ...) 
{
  startTime <- proc.time()
  funcCall <- match.call(expand.dots = TRUE)
  if (is.null(gafsControl$metric)) 
    gafsControl$metric <- rep(ifelse(is.factor(y), "Accuracy", "RMSE"), 2)
  if (is.null(gafsControl$maximize)) 
    gafsControl$maximize <- rep(ifelse(gafsControl$metric %in% c("RMSE", "MAE", "logLoss"), FALSE, TRUE), 2)
  if (is.null(names(gafsControl$metric))) 
    names(gafsControl$metric) <- c("internal", "external")
  if (is.null(names(gafsControl$maximize))) 
    names(gafsControl$maximize) <- c("internal", "external")
  if (nrow(x) != length(y)) 
    stop("there should be the same number of samples in x and y")
  numFeat <- ncol(x)
  classLevels <- levels(y)
  if (is.null(gafsControl$index)) 
    gafsControl$index <- switch(tolower(gafsControl$method), cv = createFolds(y, gafsControl$number, returnTrain = TRUE), repeatedcv = createMultiFolds(y, gafsControl$number, gafsControl$repeats), loocv = createFolds(y, length(y), returnTrain = TRUE), boot = , boot632 = createResample(y, gafsControl$number), test = createDataPartition(y, 1, gafsControl$p), lgocv = createDataPartition(y, gafsControl$number, gafsControl$p))
  if (is.null(names(gafsControl$index))) 
    names(gafsControl$index) <- getFromNamespace("prettySeq", "caret")(gafsControl$index)
  if (is.null(gafsControl$indexOut)) {
    gafsControl$indexOut <- lapply(gafsControl$index, function(training, allSamples) allSamples[-unique(training)], allSamples = seq(along = y))
    names(gafsControl$indexOut) <- getFromNamespace("prettySeq", "caret")(gafsControl$indexOut)
  }
  if (!is.null(gafsControl$seeds)) {
    if (length(gafsControl$seeds) < length(gafsControl$index) + 1) 
      stop(paste("There must be at least", length(gafsControl$index) + 1, "random number seeds passed to gafsControl"))
  }
  else {
    gafsControl$seeds <- sample.int(1e+05, length(gafsControl$index) + 1)
  }
  testOutput <- data.frame(pred = sample(y, min(10, length(y))), obs = sample(y, min(10, length(y))))
  if (is.factor(y)) 
    for (i in seq(along = classLevels)) testOutput[, classLevels[i]] <- runif(nrow(testOutput))
  test <- gafsControl$functions$fitness_extern(testOutput, lev = classLevels)
  perfNames <- names(test)
  if (is.null(perfNames)) {
    warning(paste("The external fitness results should be a *named* vector;", "new name(s) are", paste(paste0("external", 1:length(test)), sep = "", collapse = ", ")), immediate. = TRUE)
    perfNames <- paste0("external", 1:length(test))
  }
  if (!(gafsControl$metric["external"] %in% perfNames)) {
    warning(paste("The metric '", gafsControl$metric["external"], "' is not created by the summary function; '", perfNames[1], "' will be used instead", sep = ""))
    gafsControl$metric["external"] <- perfNames[1]
  }
  `%op%` <- getOper(gafsControl$allowParallel && getDoParWorkers() > 1)
  result <- foreach(i = seq(along = gafsControl$index), .combine = "c", .verbose = FALSE, .errorhandling = "stop") %op% {
    ga_select(x[gafsControl$index[[i]], , drop = FALSE], y[gafsControl$index[[i]]], funcs = gafsControl$functions, ga_maximize = gafsControl$maximize, ga_metric = gafsControl$metric, iters = iters, popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite, suggestions = suggestions, ga_verbose = gafsControl$verbose, testX = x[gafsControl$indexOut[[i]], , drop = FALSE], testY = y[gafsControl$indexOut[[i]]], ga_seed = gafsControl$seeds[i], Resample = names(gafsControl$index)[i], 
              holdout = gafsControl$holdout, lvl = classLevels, genParallel = gafsControl$genParallel, ...)
  }
  external <- result[names(result) == "external"]
  external <- do.call("rbind", external)
  rownames(external) <- NULL
  internal <- result[names(result) == "internal"]
  internal <- do.call("rbind", internal)
  rownames(internal) <- NULL
  selected_vars <- result[names(result) == "final"]
  names(selected_vars) <- names(gafsControl$index)
  if (differences) {
    diffs <- try(process_diffs(result[names(result) == "diffs"], colnames(x)), silent = TRUE)
    if (class(diffs)[1] == "try-error") {
      diffs <- NULL
    }
  }
  else diffs <- NULL
  rm(result)
  if (gafsControl$verbose) 
    cat("+ final GA\n")
  if (gafsControl$holdout > 0) {
    in_holdout <- createDataPartition(y, p = gafsControl$holdout, list = FALSE)
    in_model <- seq(along = y)[-unique(in_holdout)]
  }
  else {
    in_model <- seq(along = y)
    in_holdout <- NULL
  }
  final_ga <- ga_select(x[in_model, , drop = FALSE], y[in_model], funcs = gafsControl$functions, ga_maximize = gafsControl$maximize, ga_metric = gafsControl$metric, iters = iters, popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite, suggestions = suggestions, ga_verbose = gafsControl$verbose, testX = if (!is.null(in_holdout)) 
    x[in_holdout, , drop = FALSE]
    else NULL, testY = if (!is.null(in_holdout)) 
      y[in_holdout]
    else NULL, ga_seed = gafsControl$seeds[length(gafsControl$seeds)], lvl = classLevels, genParallel = gafsControl$genParallel, ...)
  averages <- ddply(external, .(Iter), function(x, nms) {
    apply(x[, perfNames, drop = FALSE], 2, mean)
  }, nms = perfNames)
  if (!is.null(gafsControl$functions$selectIter)) {
    best_index <- gafsControl$functions$selectIter(averages, metric = gafsControl$metric["external"], maximize = gafsControl$maximize["external"])
    best_iter <- averages$Iter[best_index]
    best_vars <- colnames(x)[final_ga$subsets[[best_index]]]
  }
  else {
    best_index <- if (gafsControl$maximize["external"]) 
      which.max(averages[, gafsControl$metric["external"]])
    else which.min(averages[, gafsControl$metric["external"]])
    best_iter <- averages$Iter[best_index]
    best_vars <- colnames(x)[final_ga$subsets[[best_index]]]
  }
  if (gafsControl$verbose) 
    cat("+ final model\n")
  fit <- gafsControl$functions$fit(x[, best_vars, drop = FALSE], y, lev = lvls, last = TRUE, ...)
  endTime <- proc.time()
  res <- list(fit = fit, ga = final_ga, ga_param = list(popSize = popSize, pcrossover = pcrossover, pmutation = pmutation, elite = elite), external = external, internal = internal, resampled_vars = selected_vars, averages = averages, iters = iters, optVariables = best_vars, optIter = best_iter, control = gafsControl, dims = dim(x), differences = diffs, perfNames = perfNames, auto = TRUE, the_dots = list(...), call = funcCall, times = list(everything = endTime - startTime), levels = if (is.factor(y)) classLevels else NULL)
  class(res) <- "gafs"
  res
})
c("package:caret", "registered S3 method for gafs from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
gafs_initial
list(`package:caret` = function (vars, popSize, ...) 
{
  x <- matrix(NA, nrow = popSize, ncol = vars)
  probs <- seq(0.9, 0.1, length = popSize)
  for (i in 1:popSize) {
    x[i, ] <- sample(0:1, replace = TRUE, size = vars, prob = c(probs[i], 1 - probs[i]))
  }
  var_count <- apply(x, 1, sum)
  if (any(var_count == 0)) {
    for (i in which(var_count == 0)) {
      x[i, ] <- sample(0:1, replace = TRUE, size = vars)
    }
  }
  x
}, function (vars, popSize, ...) 
{
  x <- matrix(NA, nrow = popSize, ncol = vars)
  probs <- seq(0.9, 0.1, length = popSize)
  for (i in 1:popSize) {
    x[i, ] <- sample(0:1, replace = TRUE, size = vars, prob = c(probs[i], 1 - probs[i]))
  }
  var_count <- apply(x, 1, sum)
  if (any(var_count == 0)) {
    for (i in which(var_count == 0)) {
      x[i, ] <- sample(0:1, replace = TRUE, size = vars)
    }
  }
  x
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafs_lrSelection
list(`package:caret` = function (population, fitness, r = NULL, q = NULL, ...) 
{
  popSize = nrow(population)
  if (is.null(r)) 
    r <- 2/(popSize * (popSize - 1))
  if (is.null(q)) 
    q <- 2/popSize
  rank <- (popSize + 1) - rank(fitness, ties.method = "random")
  prob <- q - (rank - 1) * r
  sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
  out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
  out
}, function (population, fitness, r = NULL, q = NULL, ...) 
{
  popSize = nrow(population)
  if (is.null(r)) 
    r <- 2/(popSize * (popSize - 1))
  if (is.null(q)) 
    q <- 2/popSize
  rank <- (popSize + 1) - rank(fitness, ties.method = "random")
  prob <- q - (rank - 1) * r
  sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
  out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafs_raMutation
list(`package:caret` = function (population, parent, ...) 
{
  mutate <- parent <- as.vector(population[parent, ])
  n <- length(parent)
  j <- sample(1:n, size = 1)
  mutate[j] <- abs(mutate[j] - 1)
  mutate
}, function (population, parent, ...) 
{
  mutate <- parent <- as.vector(population[parent, ])
  n <- length(parent)
  j <- sample(1:n, size = 1)
  mutate[j] <- abs(mutate[j] - 1)
  mutate
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafs_rwSelection
list(`package:caret` = function (population, fitness, ...) 
{
  popSize <- nrow(population)
  prob <- abs(fitness)/sum(abs(fitness))
  sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
  out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
  return(out)
}, function (population, fitness, ...) 
{
  popSize <- nrow(population)
  prob <- abs(fitness)/sum(abs(fitness))
  sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
  out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
  return(out)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafs_spCrossover
list(`package:caret` = function (population, fitness, parents, ...) 
{
  fitness <- fitness[parents]
  parents <- population[parents, , drop = FALSE]
  n <- ncol(parents)
  children <- matrix(as.double(NA), nrow = 2, ncol = n)
  fitnessChildren <- rep(NA, 2)
  crossOverPoint <- sample(0:n, size = 1)
  if (crossOverPoint == 0) {
    children[1:2, ] <- parents[2:1, ]
    fitnessChildren[1:2] <- fitness[2:1]
  }
  else if (crossOverPoint == n) {
    children <- parents
    fitnessChildren <- fitness
  }
  else {
    children[1, ] <- c(parents[1, 1:crossOverPoint], parents[2, (crossOverPoint + 1):n])
    children[2, ] <- c(parents[2, 1:crossOverPoint], parents[1, (crossOverPoint + 1):n])
  }
  out <- list(children = children, fitness = fitnessChildren)
  out
}, function (population, fitness, parents, ...) 
{
  fitness <- fitness[parents]
  parents <- population[parents, , drop = FALSE]
  n <- ncol(parents)
  children <- matrix(as.double(NA), nrow = 2, ncol = n)
  fitnessChildren <- rep(NA, 2)
  crossOverPoint <- sample(0:n, size = 1)
  if (crossOverPoint == 0) {
    children[1:2, ] <- parents[2:1, ]
    fitnessChildren[1:2] <- fitness[2:1]
  }
  else if (crossOverPoint == n) {
    children <- parents
    fitnessChildren <- fitness
  }
  else {
    children[1, ] <- c(parents[1, 1:crossOverPoint], parents[2, (crossOverPoint + 1):n])
    children[2, ] <- c(parents[2, 1:crossOverPoint], parents[1, (crossOverPoint + 1):n])
  }
  out <- list(children = children, fitness = fitnessChildren)
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafs_tourSelection
list(`package:caret` = function (population, fitness, k = 3, ...) 
{
  popSize <- nrow(population)
  sel <- rep(NA, popSize)
  for (i in 1:popSize) {
    s <- sample(1:popSize, size = k)
    sel[i] <- s[which.max(fitness[s])]
  }
  out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
  return(out)
}, function (population, fitness, k = 3, ...) 
{
  popSize <- nrow(population)
  sel <- rep(NA, popSize)
  for (i in 1:popSize) {
    s <- sample(1:popSize, size = k)
    sel[i] <- s[which.max(fitness[s])]
  }
  out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
  return(out)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafs_uCrossover
list(`package:caret` = function (population, parents, ...) 
{
  parents <- population[parents, , drop = FALSE]
  n <- ncol(parents)
  u <- runif(n)
  children <- parents
  children[1:2, u > 0.5] <- children[2:1, u > 0.5]
  out <- list(children = children, fitness = rep(NA, 2))
  return(out)
}, function (population, parents, ...) 
{
  parents <- population[parents, , drop = FALSE]
  n <- ncol(parents)
  u <- runif(n)
  children <- parents
  children[1:2, u > 0.5] <- children[2:1, u > 0.5]
  out <- list(children = children, fitness = rep(NA, 2))
  return(out)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gafsControl
list(`package:caret` = function (functions = NULL, method = "repeatedcv", metric = NULL, maximize = NULL, number = ifelse(grepl("cv", method), 10, 25), repeats = ifelse(grepl("cv", method), 1, 5), verbose = FALSE, returnResamp = "final", p = 0.75, index = NULL, indexOut = NULL, seeds = NULL, holdout = 0, genParallel = FALSE, allowParallel = TRUE) 
{
  if (!(method %in% c("cv", "boot", "repeatedcv", "LGOCV", "LOOCV"))) 
    stop("method should be one of: \"cv\", \"boot\", \"repeatedcv\", \"LGOCV\" or \"LOOCV\"")
  if (holdout < 0 | holdout >= 1) 
    stop("'holdout' should be in [0, 1)")
  if (!is.null(metric)) {
    if (length(metric) != 2) 
      stop("'metric' should be a two-element named vector. See ?gafsControl")
    if (is.null(names(metric)) || any(sort(names(metric)) != c("external", "internal"))) 
      stop("'metric' should have names 'internal' and 'external' See ?gafsControl")
  }
  if (!is.null(maximize)) {
    if (length(maximize) != 2) 
      stop("'maximize' should be a two-element named vector. See ?gafsControl")
    if (is.null(names(maximize)) || any(sort(names(maximize)) != c("external", "internal"))) 
      stop("'maximize' should have names 'internal' and 'external' See ?gafsControl")
  }
  list(functions = if (is.null(functions)) caretFuncs else functions, method = method, metric = metric, maximize = maximize, number = number, repeats = repeats, returnResamp = returnResamp, verbose = verbose, p = p, index = index, indexOut = indexOut, seeds = seeds, holdout = holdout, genParallel = genParallel, allowParallel = allowParallel)
}, function (functions = NULL, method = "repeatedcv", metric = NULL, maximize = NULL, number = ifelse(grepl("cv", method), 10, 25), repeats = ifelse(grepl("cv", method), 1, 5), verbose = FALSE, returnResamp = "final", p = 0.75, index = NULL, indexOut = NULL, seeds = NULL, holdout = 0, genParallel = FALSE, allowParallel = TRUE) 
{
  if (!(method %in% c("cv", "boot", "repeatedcv", "LGOCV", "LOOCV"))) 
    stop("method should be one of: \"cv\", \"boot\", \"repeatedcv\", \"LGOCV\" or \"LOOCV\"")
  if (holdout < 0 | holdout >= 1) 
    stop("'holdout' should be in [0, 1)")
  if (!is.null(metric)) {
    if (length(metric) != 2) 
      stop("'metric' should be a two-element named vector. See ?gafsControl")
    if (is.null(names(metric)) || any(sort(names(metric)) != c("external", "internal"))) 
      stop("'metric' should have names 'internal' and 'external' See ?gafsControl")
  }
  if (!is.null(maximize)) {
    if (length(maximize) != 2) 
      stop("'maximize' should be a two-element named vector. See ?gafsControl")
    if (is.null(names(maximize)) || any(sort(names(maximize)) != c("external", "internal"))) 
      stop("'maximize' should have names 'internal' and 'external' See ?gafsControl")
  }
  list(functions = if (is.null(functions)) caretFuncs else functions, method = method, metric = metric, maximize = maximize, number = number, repeats = repeats, returnResamp = returnResamp, verbose = verbose, p = p, index = index, indexOut = indexOut, seeds = seeds, holdout = holdout, genParallel = genParallel, allowParallel = allowParallel)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gamFormula
list(`package:caret` = function (data, smoother = "s", cut = 8, y = "y") 
{
  nzv <- nearZeroVar(data)
  if (length(nzv) > 0) 
    data <- data[, -nzv, drop = FALSE]
  numValues <- apply(data, 2, function(x) length(unique(x)))
  prefix <- rep("", ncol(data))
  prefix[numValues > cut] <- paste(smoother, "(", sep = "")
  suffix <- rep("", ncol(data))
  suffix[numValues > cut] <- ")"
  rhs <- paste(prefix, names(numValues), suffix, sep = "")
  rhs <- paste(rhs, collapse = "+")
  form <- as.formula(paste(y, "~", rhs, sep = ""))
  form
}, function (data, smoother = "s", cut = 8, y = "y") 
{
  nzv <- nearZeroVar(data)
  if (length(nzv) > 0) 
    data <- data[, -nzv, drop = FALSE]
  numValues <- apply(data, 2, function(x) length(unique(x)))
  prefix <- rep("", ncol(data))
  prefix[numValues > cut] <- paste(smoother, "(", sep = "")
  suffix <- rep("", ncol(data))
  suffix[numValues > cut] <- ")"
  rhs <- paste(prefix, names(numValues), suffix, sep = "")
  rhs <- paste(rhs, collapse = "+")
  form <- as.formula(paste(y, "~", rhs, sep = ""))
  form
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gamFuncs
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loaded <- search()
  gamLoaded <- any(loaded == "package:gam")
  if (gamLoaded) 
    detach(package:gam)
  loadNamespace("mgcv")
  gam <- get("gam", asNamespace("mgcv"))
  dat <- if (is.data.frame(x)) 
    x
  else as.data.frame(x, stringsAsFactors = TRUE)
  dat$y <- y
  args <- list(formula = gamFormula(x, smoother = "s", y = "y"), data = dat, family = if (!is.factor(y)) gaussian else binomial)
  do.call("gam", args)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  loaded <- search()
  gamLoaded <- any(loaded == "package:gam")
  if (gamLoaded) 
    detach(package:gam)
  loadNamespace("mgcv")
  rsp <- predict(object, newdata = x, type = "response")
  if (object$family$family == "binomial") {
    lvl <- levels(object$model$y)
    out <- data.frame(p1 = rsp, p2 = 1 - rsp, pred = factor(ifelse(rsp > 0.5, lvl[2], lvl[1]), levels = lvl))
    colnames(out)[1:2] <- make.names(lvl)
    out
  }
  else out <- data.frame(pred = rsp)
  out
}, rank = function (object, x, y) 
{
  loaded <- search()
  gamLoaded <- any(loaded == "package:gam")
  if (gamLoaded) 
    detach(package:gam)
  loadNamespace("mgcv")
  vimp <- varImp(object)
  vimp$var <- rownames(vimp)
  if (any(!(colnames(x) %in% rownames(vimp)))) {
    missing <- colnames(x)[!(colnames(x) %in% rownames(vimp))]
    tmpdf <- data.frame(var = missing, Overall = rep(0, length(missing)))
    vimp <- rbind(vimp, tmpdf)
  }
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}), list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loaded <- search()
  gamLoaded <- any(loaded == "package:gam")
  if (gamLoaded) 
    detach(package:gam)
  loadNamespace("mgcv")
  gam <- get("gam", asNamespace("mgcv"))
  dat <- if (is.data.frame(x)) 
    x
  else as.data.frame(x, stringsAsFactors = TRUE)
  dat$y <- y
  args <- list(formula = gamFormula(x, smoother = "s", y = "y"), data = dat, family = if (!is.factor(y)) gaussian else binomial)
  do.call("gam", args)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  loaded <- search()
  gamLoaded <- any(loaded == "package:gam")
  if (gamLoaded) 
    detach(package:gam)
  loadNamespace("mgcv")
  rsp <- predict(object, newdata = x, type = "response")
  if (object$family$family == "binomial") {
    lvl <- levels(object$model$y)
    out <- data.frame(p1 = rsp, p2 = 1 - rsp, pred = factor(ifelse(rsp > 0.5, lvl[2], lvl[1]), levels = lvl))
    colnames(out)[1:2] <- make.names(lvl)
    out
  }
  else out <- data.frame(pred = rsp)
  out
}, rank = function (object, x, y) 
{
  loaded <- search()
  gamLoaded <- any(loaded == "package:gam")
  if (gamLoaded) 
    detach(package:gam)
  loadNamespace("mgcv")
  vimp <- varImp(object)
  vimp$var <- rownames(vimp)
  if (any(!(colnames(x) %in% rownames(vimp)))) {
    missing <- colnames(x)[!(colnames(x) %in% rownames(vimp))]
    tmpdf <- data.frame(var = missing, Overall = rep(0, length(missing)))
    vimp <- rbind(vimp, tmpdf)
  }
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
gamScores
list(`package:caret` = function (x, y) 
{
  if (is.factor(x)) 
    stop("The predictors should be numeric")
  requireNamespaceQuietStop("gam")
  pv <- try(anova(gam::gam(y ~ s(x)), test = "F")[2, "Pr(F)"], silent = TRUE)
  if (any(class(pv) == "try-error")) 
    pv <- try(anova(lm(x ~ y), test = "F")[1, "Pr(>F)"], silent = TRUE)
  if (any(class(pv) == "try-error") || is.na(pv) || is.nan(pv)) 
    pv <- 1
  pv
}, function (x, y) 
{
  if (is.factor(x)) 
    stop("The predictors should be numeric")
  requireNamespaceQuietStop("gam")
  pv <- try(anova(gam::gam(y ~ s(x)), test = "F")[2, "Pr(F)"], silent = TRUE)
  if (any(class(pv) == "try-error")) 
    pv <- try(anova(lm(x ~ y), test = "F")[1, "Pr(>F)"], silent = TRUE)
  if (any(class(pv) == "try-error") || is.na(pv) || is.nan(pv)) 
    pv <- 1
  pv
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
getModelInfo
list(`package:caret` = function (model = NULL, regex = TRUE, ...) 
{
  load(system.file("models", "models.RData", package = "caret"))
  if (!is.null(model)) {
    keepers <- if (regex) 
      grepl(model, names(models), ...)
    else which(model == names(models))[1]
    models <- models[keepers]
  }
  if (length(models) == 0) 
    stop("That model is not in caret's built-in library")
  models
}, function (model = NULL, regex = TRUE, ...) 
{
  load(system.file("models", "models.RData", package = "caret"))
  if (!is.null(model)) {
    keepers <- if (regex) 
      grepl(model, names(models), ...)
    else which(model == names(models))[1]
    models <- models[keepers]
  }
  if (length(models) == 0) 
    stop("That model is not in caret's built-in library")
  models
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
getSamplingInfo
list(`package:caret` = function (method = NULL, regex = TRUE, ...) 
{
  load(system.file("models", "sampling.RData", package = "caret"))
  if (!is.null(method)) {
    keepers <- if (regex) 
      grepl(method, names(sampling_methods), ...)
    else which(method == names(sampling_methods))[1]
    sampling_methods <- sampling_methods[keepers]
  }
  if (length(sampling_methods) == 0) 
    stop("That sampling method is not in caret's built-in library", call. = FALSE)
  sampling_methods
}, function (method = NULL, regex = TRUE, ...) 
{
  load(system.file("models", "sampling.RData", package = "caret"))
  if (!is.null(method)) {
    keepers <- if (regex) 
      grepl(method, names(sampling_methods), ...)
    else which(method == names(sampling_methods))[1]
    sampling_methods <- sampling_methods[keepers]
  }
  if (length(sampling_methods) == 0) 
    stop("That sampling method is not in caret's built-in library", call. = FALSE)
  sampling_methods
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
getTrainPerf
list(`package:caret` = function (x) 
{
  bestPerf <- x$bestTune
  colnames(bestPerf) <- gsub("^\\.", "", colnames(bestPerf))
  out <- merge(x$results, bestPerf)
  out <- out[, colnames(out) %in% x$perfNames, drop = FALSE]
  colnames(out) <- paste("Train", colnames(out), sep = "")
  out$method <- x$method
  out
}, function (x) 
{
  bestPerf <- x$bestTune
  colnames(bestPerf) <- gsub("^\\.", "", colnames(bestPerf))
  out <- merge(x$results, bestPerf)
  out <- out[, colnames(out) %in% x$perfNames, drop = FALSE]
  colnames(out) <- paste("Train", colnames(out), sep = "")
  out$method <- x$method
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
ggplot.gafs
list(`package:caret` = function (data = NULL, mapping = NULL, ..., environment = NULL) 
{
  plot.gafs(x = data, ...)
}, function (data = NULL, mapping = NULL, ..., environment = NULL) 
{
  plot.gafs(x = data, ...)
}, function (data = NULL, mapping = NULL, ..., environment = NULL) 
{
  plot.gafs(x = data, ...)
})
c("package:caret", "registered S3 method for ggplot from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
ggplot.safs
list(`package:caret` = function (data = NULL, mapping = NULL, ..., environment = NULL) 
{
  plot.safs(x = data, ...)
}, function (data = NULL, mapping = NULL, ..., environment = NULL) 
{
  plot.safs(x = data, ...)
}, function (data = NULL, mapping = NULL, ..., environment = NULL) 
{
  plot.safs(x = data, ...)
})
c("package:caret", "registered S3 method for ggplot from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
groupKFold
list(`package:caret` = function (group, k = length(unique(group))) 
{
  g_unique <- unique(group)
  m <- length(g_unique)
  if (k > m) {
    stop("`k` should be less than ", m)
  }
  g_folds <- sample(k, size = m, replace = TRUE)
  out <- split(seq_along(group), g_folds[match(group, g_unique)])
  names(out) <- paste0("Fold", gsub(" ", "0", format(seq_along(out))))
  lapply(out, function(z) seq_along(group)[-z])
}, function (group, k = length(unique(group))) 
{
  g_unique <- unique(group)
  m <- length(g_unique)
  if (k > m) {
    stop("`k` should be less than ", m)
  }
  g_folds <- sample(k, size = m, replace = TRUE)
  out <- split(seq_along(group), g_folds[match(group, g_unique)])
  names(out) <- paste0("Fold", gsub(" ", "0", format(seq_along(out))))
  lapply(out, function(z) seq_along(group)[-z])
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
hasTerms
list(`package:caret` = function (x) 
{
  objNames <- c(names(x), slotNames(x))
  "terms" %in% tolower(objNames)
}, function (x) 
{
  objNames <- c(names(x), slotNames(x))
  "terms" %in% tolower(objNames)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
icr
list(`package:caret` = function (x, ...) 
  UseMethod("icr"), function (x, ...) 
    UseMethod("icr"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
index2vec
list(`package:caret` = function (x, vars, sign = FALSE) 
{
  bin <- rep(0, vars)
  bin[x] <- 1
  if (sign) 
    bin <- ifelse(bin == 0, -1, 1)
  bin
}, function (x, vars, sign = FALSE) 
{
  bin <- rep(0, vars)
  bin[x] <- 1
  if (sign) 
    bin <- ifelse(bin == 0, -1, 1)
  bin
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
ipredStats
list(`package:caret` = function (x) 
  getModelInfo("treebag", regex = FALSE)[[1]]$oob(x), function (x) 
    getModelInfo("treebag", regex = FALSE)[[1]]$oob(x))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
knn3
list(`package:caret` = function (x, ...) 
  UseMethod("knn3"), function (x, ...) 
    UseMethod("knn3"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
knn3Train
list(`package:caret` = function (train, test, cl, k = 1, l = 0, prob = TRUE, use.all = TRUE) 
{
  train <- as.matrix(train)
  if (is.null(dim(test))) 
    dim(test) <- c(1, length(test))
  test <- as.matrix(test)
  if (any(is.na(train)) || any(is.na(test)) || any(is.na(cl))) 
    stop("no missing values are allowed")
  p <- ncol(train)
  ntr <- nrow(train)
  if (length(cl) != ntr) 
    stop("'train' and 'class' have different lengths")
  if (ntr < k) {
    warning(gettextf("k = %d exceeds number %d of patterns", k, ntr), domain = NA)
    k <- ntr
  }
  if (k < 1) 
    stop(gettextf("k = %d must be at least 1", k), domain = NA)
  nte <- nrow(test)
  if (ncol(test) != p) 
    stop("dims of 'test' and 'train differ")
  clf <- as.factor(cl)
  nc <- max(unclass(clf))
  Z <- .C("knn3", as.integer(k), as.integer(l), as.integer(ntr), as.integer(nte), as.integer(p), as.double(train), as.integer(unclass(clf)), as.double(test), integer(nc + 1), as.integer(nc), as.integer(FALSE), as.integer(use.all), all_vote = double(as.integer(nte * nc)))
  classProbs <- matrix(Z$all_vote, nrow = nte, ncol = nc, byrow = TRUE)
  colnames(classProbs) <- sort(unique(clf))
  bestClass <- function(x) {
    out <- which(x == max(x))
    if (length(out) > 1) 
      out <- sample(out, 1)
    out
  }
  res <- colnames(classProbs)[apply(classProbs, 1, bestClass)]
  votes <- apply(classProbs * k, 1, max)
  inDoubt <- (votes < l)
  if (any(inDoubt)) 
    res[inDoubt] <- NA
  if (prob) 
    attr(res, "prob") <- classProbs
  res
}, function (train, test, cl, k = 1, l = 0, prob = TRUE, use.all = TRUE) 
{
  train <- as.matrix(train)
  if (is.null(dim(test))) 
    dim(test) <- c(1, length(test))
  test <- as.matrix(test)
  if (any(is.na(train)) || any(is.na(test)) || any(is.na(cl))) 
    stop("no missing values are allowed")
  p <- ncol(train)
  ntr <- nrow(train)
  if (length(cl) != ntr) 
    stop("'train' and 'class' have different lengths")
  if (ntr < k) {
    warning(gettextf("k = %d exceeds number %d of patterns", k, ntr), domain = NA)
    k <- ntr
  }
  if (k < 1) 
    stop(gettextf("k = %d must be at least 1", k), domain = NA)
  nte <- nrow(test)
  if (ncol(test) != p) 
    stop("dims of 'test' and 'train differ")
  clf <- as.factor(cl)
  nc <- max(unclass(clf))
  Z <- .C("knn3", as.integer(k), as.integer(l), as.integer(ntr), as.integer(nte), as.integer(p), as.double(train), as.integer(unclass(clf)), as.double(test), integer(nc + 1), as.integer(nc), as.integer(FALSE), as.integer(use.all), all_vote = double(as.integer(nte * nc)))
  classProbs <- matrix(Z$all_vote, nrow = nte, ncol = nc, byrow = TRUE)
  colnames(classProbs) <- sort(unique(clf))
  bestClass <- function(x) {
    out <- which(x == max(x))
    if (length(out) > 1) 
      out <- sample(out, 1)
    out
  }
  res <- colnames(classProbs)[apply(classProbs, 1, bestClass)]
  votes <- apply(classProbs * k, 1, max)
  inDoubt <- (votes < l)
  if (any(inDoubt)) 
    res[inDoubt] <- NA
  if (prob) 
    attr(res, "prob") <- classProbs
  res
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
knnreg
list(`package:caret` = function (x, ...) 
  UseMethod("knnreg"), function (x, ...) 
    UseMethod("knnreg"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
knnregTrain
list(`package:caret` = function (train, test, y, k = 5, use.all = TRUE) 
{
  train <- as.matrix(train)
  if (is.null(dim(test))) 
    dim(test) <- c(1, length(test))
  test <- as.matrix(test)
  if (any(is.na(train)) || any(is.na(test)) || any(is.na(y))) 
    stop("no missing values are allowed")
  p <- ncol(train)
  ntr <- nrow(train)
  if (length(y) != ntr) 
    stop("'train' and 'class' have different lengths")
  if (ntr < k) {
    warning(gettextf("k = %d exceeds number %d of patterns", k, ntr), domain = NA)
    k <- ntr
  }
  if (k < 1) 
    stop(gettextf("k = %d must be at least 1", k), domain = NA)
  nte <- nrow(test)
  if (ncol(test) != p) 
    stop("dims of 'test' and 'train differ")
  Z <- .C("knn3reg", as.integer(k), as.integer(ntr), as.integer(nte), as.integer(p), as.double(train), as.double(y), as.double(test), double(nte), as.integer(FALSE), as.integer(use.all))
  Z[[8]]
}, function (train, test, y, k = 5, use.all = TRUE) 
{
  train <- as.matrix(train)
  if (is.null(dim(test))) 
    dim(test) <- c(1, length(test))
  test <- as.matrix(test)
  if (any(is.na(train)) || any(is.na(test)) || any(is.na(y))) 
    stop("no missing values are allowed")
  p <- ncol(train)
  ntr <- nrow(train)
  if (length(y) != ntr) 
    stop("'train' and 'class' have different lengths")
  if (ntr < k) {
    warning(gettextf("k = %d exceeds number %d of patterns", k, ntr), domain = NA)
    k <- ntr
  }
  if (k < 1) 
    stop(gettextf("k = %d must be at least 1", k), domain = NA)
  nte <- nrow(test)
  if (ncol(test) != p) 
    stop("dims of 'test' and 'train differ")
  Z <- .C("knn3reg", as.integer(k), as.integer(ntr), as.integer(nte), as.integer(p), as.double(train), as.double(y), as.double(test), double(nte), as.integer(FALSE), as.integer(use.all))
  Z[[8]]
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
ldaBag
list(`package:caret` = list(fit = function (x, y, ...) 
{
  loadNamespace("MASS")
  MASS::lda(x, y, ...)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  predict(object, x)$posterior
}, aggregate = function (x, type = "class") 
{
  pooled <- x[[1]] * NA
  n <- nrow(pooled)
  classes <- colnames(pooled)
  for (i in 1:ncol(pooled)) {
    tmp <- lapply(x, function(y, col) y[, col], col = i)
    tmp <- do.call("rbind", tmp)
    pooled[, i] <- apply(tmp, 2, median)
  }
  pooled <- apply(pooled, 1, function(x) x/sum(x))
  if (n != nrow(pooled)) 
    pooled <- t(pooled)
  if (type == "class") {
    out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
  }
  else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  out
}), list(fit = function (x, y, ...) 
{
  loadNamespace("MASS")
  MASS::lda(x, y, ...)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  predict(object, x)$posterior
}, aggregate = function (x, type = "class") 
{
  pooled <- x[[1]] * NA
  n <- nrow(pooled)
  classes <- colnames(pooled)
  for (i in 1:ncol(pooled)) {
    tmp <- lapply(x, function(y, col) y[, col], col = i)
    tmp <- do.call("rbind", tmp)
    pooled[, i] <- apply(tmp, 2, median)
  }
  pooled <- apply(pooled, 1, function(x) x/sum(x))
  if (n != nrow(pooled)) 
    pooled <- t(pooled)
  if (type == "class") {
    out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
  }
  else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  out
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
ldaFuncs
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loadNamespace("MASS")
  MASS::lda(x, y, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  out <- cbind(data.frame(pred = tmp$class), as.data.frame(tmp$posterior, stringsAsFactors = FALSE), stringsAsFactors = TRUE)
  out
}, rank = function (object, x, y) 
{
  vimp <- filterVarImp(x, y, TRUE)
  vimp$Overall <- apply(vimp, 1, mean)
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), ]
  vimp <- as.data.frame(vimp, stringsAsFactors = TRUE)[, "Overall", drop = FALSE]
  vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}), list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loadNamespace("MASS")
  MASS::lda(x, y, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  out <- cbind(data.frame(pred = tmp$class), as.data.frame(tmp$posterior, stringsAsFactors = FALSE), stringsAsFactors = TRUE)
  out
}, rank = function (object, x, y) 
{
  vimp <- filterVarImp(x, y, TRUE)
  vimp$Overall <- apply(vimp, 1, mean)
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), ]
  vimp <- as.data.frame(vimp, stringsAsFactors = TRUE)[, "Overall", drop = FALSE]
  vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
ldaSBF
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, ...) 
{
  if (ncol(x) > 0) {
    loadNamespace("MASS")
    MASS::lda(x, y, ...)
  }
  else nullModel(y = y)
}, pred = function (object, x) 
{
  if (inherits(object, "nullModel")) {
    tmp <- predict(object, x)
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob")))
  }
  else {
    tmp <- predict(object, x)
    out <- cbind(data.frame(pred = tmp$class), as.data.frame(tmp$posterior, stringsAsFactors = FALSE))
  }
  out
}, score = function (x, y) 
{
  anovaScores(x, y)
}, filter = function (score, x, y) 
  score <= 0.05), list(summary = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, fit = function (x, y, ...) 
  {
    if (ncol(x) > 0) {
      loadNamespace("MASS")
      MASS::lda(x, y, ...)
    }
    else nullModel(y = y)
  }, pred = function (object, x) 
  {
    if (inherits(object, "nullModel")) {
      tmp <- predict(object, x)
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob")))
    }
    else {
      tmp <- predict(object, x)
      out <- cbind(data.frame(pred = tmp$class), as.data.frame(tmp$posterior, stringsAsFactors = FALSE))
    }
    out
  }, score = function (x, y) 
  {
    anovaScores(x, y)
  }, filter = function (score, x, y) 
    score <= 0.05))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
learning_curve_dat
list(`package:caret` = function (dat, outcome = NULL, proportion = (1:10)/10, test_prop = 0, verbose = TRUE, ...) 
{
  if (is.null(outcome)) 
    stop("Please give a character stirng for the outcome column name")
  proportion <- sort(unique(proportion))
  n_size <- length(proportion)
  if (test_prop > 0) {
    for_model <- createDataPartition(dat[, outcome], p = 1 - test_prop, list = FALSE)
  }
  else for_model <- 1:nrow(dat)
  n <- length(for_model)
  resampled <- vector(mode = "list", length = n_size)
  tested <- if (test_prop > 0) 
    resampled
  else NULL
  apparent <- resampled
  for (i in seq(along = proportion)) {
    if (verbose) 
      cat("Training for ", round(proportion[i] * 100, 1), "% (n = ", floor(n * proportion[i]), ")\n", sep = "")
    in_mod <- if (proportion[i] < 1) 
      sample(for_model, size = floor(n * proportion[i]))
    else for_model
    mod <- train(x = dat[in_mod, colnames(dat) != outcome, drop = FALSE], y = dat[in_mod, outcome], ...)
    if (mod$control$method == "none") 
      stop("`learning_curve_dat` uses resampling so please choose a value of ", "`method` that is not 'none'", call. = FALSE)
    if (i == 1) 
      perf_names <- mod$perfNames
    resampled[[i]] <- merge(mod$resample, mod$bestTune)
    resampled[[i]]$Training_Size <- length(in_mod)
    if (test_prop > 0) {
      if (!mod$control$classProbs) {
        test_preds <- extractPrediction(list(model = mod), testX = dat[-for_model, colnames(dat) != outcome, drop = FALSE], testY = dat[-for_model, outcome])
      }
      else {
        test_preds <- extractProb(list(model = mod), testX = dat[-for_model, colnames(dat) != outcome, drop = FALSE], testY = dat[-for_model, outcome])
      }
      test_perf <- mod$control$summaryFunction(test_preds, lev = mod$finalModel$obsLevels)
      test_perf <- as.data.frame(t(test_perf), stringsAsFactors = FALSE)
      test_perf$Training_Size <- length(in_mod)
      tested[[i]] <- test_perf
      try(rm(test_preds, test_perf), silent = TRUE)
    }
    if (!mod$control$classProbs) {
      app_preds <- extractPrediction(list(model = mod), testX = dat[in_mod, colnames(dat) != outcome, drop = FALSE], testY = dat[in_mod, outcome])
    }
    else {
      app_preds <- extractProb(list(model = mod), testX = dat[in_mod, colnames(dat) != outcome, drop = FALSE], testY = dat[in_mod, outcome])
    }
    app_perf <- mod$control$summaryFunction(app_preds, lev = mod$finalModel$obsLevels)
    app_perf <- as.data.frame(t(app_perf), stringsAsFactors = FALSE)
    app_perf$Training_Size <- length(in_mod)
    apparent[[i]] <- app_perf
    try(rm(mod, in_mod, app_preds, app_perf), silent = TRUE)
  }
  resampled <- do.call("rbind", resampled)
  resampled <- resampled[, c(perf_names, "Training_Size")]
  resampled$Data <- "Resampling"
  apparent <- do.call("rbind", apparent)
  apparent <- apparent[, c(perf_names, "Training_Size")]
  apparent$Data <- "Training"
  out <- rbind(resampled, apparent)
  if (test_prop > 0) {
    tested <- do.call("rbind", tested)
    tested <- tested[, c(perf_names, "Training_Size")]
    tested$Data <- "Testing"
    out <- rbind(out, tested)
  }
  out
}, function (dat, outcome = NULL, proportion = (1:10)/10, test_prop = 0, verbose = TRUE, ...) 
{
  if (is.null(outcome)) 
    stop("Please give a character stirng for the outcome column name")
  proportion <- sort(unique(proportion))
  n_size <- length(proportion)
  if (test_prop > 0) {
    for_model <- createDataPartition(dat[, outcome], p = 1 - test_prop, list = FALSE)
  }
  else for_model <- 1:nrow(dat)
  n <- length(for_model)
  resampled <- vector(mode = "list", length = n_size)
  tested <- if (test_prop > 0) 
    resampled
  else NULL
  apparent <- resampled
  for (i in seq(along = proportion)) {
    if (verbose) 
      cat("Training for ", round(proportion[i] * 100, 1), "% (n = ", floor(n * proportion[i]), ")\n", sep = "")
    in_mod <- if (proportion[i] < 1) 
      sample(for_model, size = floor(n * proportion[i]))
    else for_model
    mod <- train(x = dat[in_mod, colnames(dat) != outcome, drop = FALSE], y = dat[in_mod, outcome], ...)
    if (mod$control$method == "none") 
      stop("`learning_curve_dat` uses resampling so please choose a value of ", "`method` that is not 'none'", call. = FALSE)
    if (i == 1) 
      perf_names <- mod$perfNames
    resampled[[i]] <- merge(mod$resample, mod$bestTune)
    resampled[[i]]$Training_Size <- length(in_mod)
    if (test_prop > 0) {
      if (!mod$control$classProbs) {
        test_preds <- extractPrediction(list(model = mod), testX = dat[-for_model, colnames(dat) != outcome, drop = FALSE], testY = dat[-for_model, outcome])
      }
      else {
        test_preds <- extractProb(list(model = mod), testX = dat[-for_model, colnames(dat) != outcome, drop = FALSE], testY = dat[-for_model, outcome])
      }
      test_perf <- mod$control$summaryFunction(test_preds, lev = mod$finalModel$obsLevels)
      test_perf <- as.data.frame(t(test_perf), stringsAsFactors = FALSE)
      test_perf$Training_Size <- length(in_mod)
      tested[[i]] <- test_perf
      try(rm(test_preds, test_perf), silent = TRUE)
    }
    if (!mod$control$classProbs) {
      app_preds <- extractPrediction(list(model = mod), testX = dat[in_mod, colnames(dat) != outcome, drop = FALSE], testY = dat[in_mod, outcome])
    }
    else {
      app_preds <- extractProb(list(model = mod), testX = dat[in_mod, colnames(dat) != outcome, drop = FALSE], testY = dat[in_mod, outcome])
    }
    app_perf <- mod$control$summaryFunction(app_preds, lev = mod$finalModel$obsLevels)
    app_perf <- as.data.frame(t(app_perf), stringsAsFactors = FALSE)
    app_perf$Training_Size <- length(in_mod)
    apparent[[i]] <- app_perf
    try(rm(mod, in_mod, app_preds, app_perf), silent = TRUE)
  }
  resampled <- do.call("rbind", resampled)
  resampled <- resampled[, c(perf_names, "Training_Size")]
  resampled$Data <- "Resampling"
  apparent <- do.call("rbind", apparent)
  apparent <- apparent[, c(perf_names, "Training_Size")]
  apparent$Data <- "Training"
  out <- rbind(resampled, apparent)
  if (test_prop > 0) {
    tested <- do.call("rbind", tested)
    tested <- tested[, c(perf_names, "Training_Size")]
    tested$Data <- "Testing"
    out <- rbind(out, tested)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
lift
list(`package:caret` = function (x, ...) 
  UseMethod("lift"), function (..f, ..., .unnamed = FALSE) 
  {
    force(..f)
    defaults <- list(...)
    function(.x = list(), ...) {
      if (.unnamed) {
        .x <- unname(.x)
      }
      do.call("..f", c(.x, defaults, list(...)))
    }
  }, function (x, ...) 
    UseMethod("lift"))
c("package:caret", "namespace:purrr", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
lmFuncs
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  tmp <- if (is.data.frame(x)) 
    x
  else as.data.frame(x, stringsAsFactors = TRUE)
  tmp$y <- y
  lm(y ~ ., data = tmp)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  predict(object, x)
}, rank = function (object, x, y) 
{
  coefs <- abs(coef(object))
  coefs <- coefs[names(coefs) != "(Intercept)"]
  coefs[is.na(coefs)] <- 0
  vimp <- data.frame(Overall = unname(coefs), var = names(coefs))
  rownames(vimp) <- names(coefs)
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}), list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  tmp <- if (is.data.frame(x)) 
    x
  else as.data.frame(x, stringsAsFactors = TRUE)
  tmp$y <- y
  lm(y ~ ., data = tmp)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  predict(object, x)
}, rank = function (object, x, y) 
{
  coefs <- abs(coef(object))
  coefs <- coefs[names(coefs) != "(Intercept)"]
  coefs[is.na(coefs)] <- 0
  vimp <- data.frame(Overall = unname(coefs), var = names(coefs))
  rownames(vimp) <- names(coefs)
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
lmSBF
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, ...) 
{
  if (ncol(x) > 0) {
    tmp <- as.data.frame(x, stringsAsFactors = TRUE)
    tmp$y <- y
    lm(y ~ ., data = tmp)
  }
  else nullModel(y = y)
}, pred = function (object, x) 
{
  predict(object, x)
}, score = function (x, y) 
{
  anovaScores(y, x)
}, filter = function (score, x, y) 
  score <= 0.05), list(summary = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, fit = function (x, y, ...) 
  {
    if (ncol(x) > 0) {
      tmp <- as.data.frame(x, stringsAsFactors = TRUE)
      tmp$y <- y
      lm(y ~ ., data = tmp)
    }
    else nullModel(y = y)
  }, pred = function (object, x) 
  {
    predict(object, x)
  }, score = function (x, y) 
  {
    anovaScores(y, x)
  }, filter = function (score, x, y) 
    score <= 0.05))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
LPH07_1
list(`package:caret` = function (n = 100, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0, factors = FALSE, class = FALSE) 
{
  dat <- matrix(rbinom(n * 10, size = 1, prob = 0.4), ncol = 10)
  dat <- as.data.frame(dat, stringsAsFactors = TRUE)
  colnames(dat) <- well_numbered("Var", ncol(dat))
  foo <- function(w) 2 * w[1] * w[10] + 4 * w[2] * w[7] + 3 * w[4] * w[5] - 5 * w[6] * w[10] + 3 * w[8] * w[9] + w[1] * w[2] * w[4] - 2 * w[7] * (1 - w[6]) * w[2] * w[9] - 4 * (1 - w[10]) * w[1] * (1 - w[4])
  if (noiseVars > 0 | corrVars > 0) 
    dat <- cbind(dat, make_noise(n = n, noiseVars = noiseVars, corrVars = corrVars, corrType = corrType, corrValue = corrValue, binary = TRUE))
  if (class) {
    dat$y <- apply(dat[, 1:10], 1, foo)
    dat$Class <- runif(nrow(dat)) <= binomial()$linkinv(dat$y)
    dat$Class <- factor(ifelse(dat$Class, "Class1", "Class2"))
    dat$y <- NULL
  }
  else dat$y <- apply(dat[, 1:10], 1, foo) + rnorm(n)
  if (factors) 
    for (i in grep("(^Var)|(^Noise)", names(dat), value = TRUE)) dat[, i] <- factor(paste0("val", dat[, i]))
  dat
}, function (n = 100, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0, factors = FALSE, class = FALSE) 
{
  dat <- matrix(rbinom(n * 10, size = 1, prob = 0.4), ncol = 10)
  dat <- as.data.frame(dat, stringsAsFactors = TRUE)
  colnames(dat) <- well_numbered("Var", ncol(dat))
  foo <- function(w) 2 * w[1] * w[10] + 4 * w[2] * w[7] + 3 * w[4] * w[5] - 5 * w[6] * w[10] + 3 * w[8] * w[9] + w[1] * w[2] * w[4] - 2 * w[7] * (1 - w[6]) * w[2] * w[9] - 4 * (1 - w[10]) * w[1] * (1 - w[4])
  if (noiseVars > 0 | corrVars > 0) 
    dat <- cbind(dat, make_noise(n = n, noiseVars = noiseVars, corrVars = corrVars, corrType = corrType, corrValue = corrValue, binary = TRUE))
  if (class) {
    dat$y <- apply(dat[, 1:10], 1, foo)
    dat$Class <- runif(nrow(dat)) <= binomial()$linkinv(dat$y)
    dat$Class <- factor(ifelse(dat$Class, "Class1", "Class2"))
    dat$y <- NULL
  }
  else dat$y <- apply(dat[, 1:10], 1, foo) + rnorm(n)
  if (factors) 
    for (i in grep("(^Var)|(^Noise)", names(dat), value = TRUE)) dat[, i] <- factor(paste0("val", dat[, i]))
  dat
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
LPH07_2
list(`package:caret` = function (n = 100, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0) 
{
  dat <- matrix(rnorm(n * 20, sd = 4), ncol = 20)
  dat <- as.data.frame(dat, stringsAsFactors = TRUE)
  colnames(dat) <- well_numbered("Var", ncol(dat))
  foo <- function(x) x[1] * x[2] + x[10]^2 - x[3] * x[17] - x[15] * x[4] + x[9] * x[5] + x[19] - x[20]^2 + x[9] * x[8]
  if (noiseVars > 0 | corrVars > 0) 
    dat <- cbind(dat, make_noise(n = n, noiseVars = noiseVars, corrVars = corrVars, corrType = corrType, corrValue = corrValue))
  dat$y <- apply(dat[, 1:20], 1, foo) + rnorm(n, sd = 4)
  dat
}, function (n = 100, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0) 
{
  dat <- matrix(rnorm(n * 20, sd = 4), ncol = 20)
  dat <- as.data.frame(dat, stringsAsFactors = TRUE)
  colnames(dat) <- well_numbered("Var", ncol(dat))
  foo <- function(x) x[1] * x[2] + x[10]^2 - x[3] * x[17] - x[15] * x[4] + x[9] * x[5] + x[19] - x[20]^2 + x[9] * x[8]
  if (noiseVars > 0 | corrVars > 0) 
    dat <- cbind(dat, make_noise(n = n, noiseVars = noiseVars, corrVars = corrVars, corrType = corrType, corrValue = corrValue))
  dat$y <- apply(dat[, 1:20], 1, foo) + rnorm(n, sd = 4)
  dat
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
lrFuncs
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  tmp <- if (is.data.frame(x)) 
    x
  else as.data.frame(x, stringsAsFactors = TRUE)
  tmp$Class <- y
  glm(Class ~ ., data = tmp, family = "binomial")
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  lvl <- levels(object$data$Class)
  tmp <- predict(object, x, type = "response")
  out <- data.frame(1 - tmp, tmp)
  colnames(out) <- lvl
  out$pred <- factor(ifelse(tmp > 0.5, lvl[2], lvl[1]), levels = lvl)
  out
}, rank = function (object, x, y) 
{
  vimp <- varImp(object, scale = FALSE)
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}), list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  tmp <- if (is.data.frame(x)) 
    x
  else as.data.frame(x, stringsAsFactors = TRUE)
  tmp$Class <- y
  glm(Class ~ ., data = tmp, family = "binomial")
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  lvl <- levels(object$data$Class)
  tmp <- predict(object, x, type = "response")
  out <- data.frame(1 - tmp, tmp)
  colnames(out) <- lvl
  out$pred <- factor(ifelse(tmp > 0.5, lvl[2], lvl[1]), levels = lvl)
  out
}, rank = function (object, x, y) 
{
  vimp <- varImp(object, scale = FALSE)
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
MAE
list(`package:caret` = function (pred, obs, na.rm = FALSE) 
  mean(abs(pred - obs), na.rm = na.rm), function (pred, obs, na.rm = FALSE) 
    mean(abs(pred - obs), na.rm = na.rm))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
maxDissim
list(`package:caret` = function (a, b, n = 2, obj = minDiss, useNames = FALSE, randomFrac = 1, verbose = FALSE, ...) 
{
  loadNamespace("proxy")
  if (nrow(b) < 2) 
    stop("there must be at least 2 samples in b")
  if (ncol(a) != ncol(b)) 
    stop("a and b must have the same number of columns")
  if (nrow(b) < n) 
    stop("n must be less than nrow(b)")
  if (randomFrac > 1 | randomFrac <= 0) 
    stop("randomFrac must be in (0, 1]")
  if (useNames) {
    if (is.null(rownames(b))) {
      warning("Cannot use rownames; swithcing to indices")
      free <- 1:nrow(b)
    }
    else free <- rownames(b)
  }
  else free <- 1:nrow(b)
  inSubset <- NULL
  newA <- a
  if (verbose) 
    cat("  adding:")
  for (i in 1:n) {
    pool <- if (randomFrac == 1) 
      free
    else sample(free, max(2, floor(randomFrac * length(free))))
    if (verbose) {
      cat("\nIter", i, "\n")
      cat("Number of candidates:", length(free), "\n")
      cat("Sampling from", length(pool), "samples\n")
    }
    diss <- proxy::dist(newA, b[pool, , drop = FALSE], ...)
    bNames <- colnames(b)[pool]
    tmp <- pool[which.max(apply(diss, 2, obj))]
    if (verbose) 
      cat("new sample:", tmp, "\n")
    inSubset <- c(inSubset, tmp)
    newA <- rbind(newA, b[tmp, , drop = FALSE])
    free <- free[!(free %in% inSubset)]
  }
  inSubset
}, function (a, b, n = 2, obj = minDiss, useNames = FALSE, randomFrac = 1, verbose = FALSE, ...) 
{
  loadNamespace("proxy")
  if (nrow(b) < 2) 
    stop("there must be at least 2 samples in b")
  if (ncol(a) != ncol(b)) 
    stop("a and b must have the same number of columns")
  if (nrow(b) < n) 
    stop("n must be less than nrow(b)")
  if (randomFrac > 1 | randomFrac <= 0) 
    stop("randomFrac must be in (0, 1]")
  if (useNames) {
    if (is.null(rownames(b))) {
      warning("Cannot use rownames; swithcing to indices")
      free <- 1:nrow(b)
    }
    else free <- rownames(b)
  }
  else free <- 1:nrow(b)
  inSubset <- NULL
  newA <- a
  if (verbose) 
    cat("  adding:")
  for (i in 1:n) {
    pool <- if (randomFrac == 1) 
      free
    else sample(free, max(2, floor(randomFrac * length(free))))
    if (verbose) {
      cat("\nIter", i, "\n")
      cat("Number of candidates:", length(free), "\n")
      cat("Sampling from", length(pool), "samples\n")
    }
    diss <- proxy::dist(newA, b[pool, , drop = FALSE], ...)
    bNames <- colnames(b)[pool]
    tmp <- pool[which.max(apply(diss, 2, obj))]
    if (verbose) 
      cat("new sample:", tmp, "\n")
    inSubset <- c(inSubset, tmp)
    newA <- rbind(newA, b[tmp, , drop = FALSE])
    free <- free[!(free %in% inSubset)]
  }
  inSubset
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
MeanSD
list(`package:caret` = function (x, exclude = NULL) 
{
  if (!is.null(exclude)) 
    x <- x[, !(colnames(x) %in% exclude), drop = FALSE]
  out <- c(colMeans(x, na.rm = TRUE), sapply(x, sd, na.rm = TRUE))
  names(out)[-(1:ncol(x))] <- paste(names(out)[-(1:ncol(x))], "SD", sep = "")
  out
}, function (x, exclude = NULL) 
{
  if (!is.null(exclude)) 
    x <- x[, !(colnames(x) %in% exclude), drop = FALSE]
  out <- c(colMeans(x, na.rm = TRUE), sapply(x, sd, na.rm = TRUE))
  names(out)[-(1:ncol(x))] <- paste(names(out)[-(1:ncol(x))], "SD", sep = "")
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
minDiss
list(`package:caret` = function (u) 
  min(u, na.rm = TRUE), function (u) 
    min(u, na.rm = TRUE))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
mnLogLoss
list(`package:caret` = function (data, lev = NULL, model = NULL) 
{
  if (is.null(lev)) 
    stop("'lev' cannot be NULL")
  if (!all(lev %in% colnames(data))) 
    stop("'data' should have columns consistent with 'lev'")
  if (!all(sort(lev) %in% sort(levels(data$obs)))) 
    stop("'data$obs' should have levels consistent with 'lev'")
  dataComplete <- data[complete.cases(data), ]
  probs <- as.matrix(dataComplete[, lev, drop = FALSE])
  logLoss <- ModelMetrics::mlogLoss(dataComplete$obs, probs)
  c(logLoss = logLoss)
}, function (data, lev = NULL, model = NULL) 
{
  if (is.null(lev)) 
    stop("'lev' cannot be NULL")
  if (!all(lev %in% colnames(data))) 
    stop("'data' should have columns consistent with 'lev'")
  if (!all(sort(lev) %in% sort(levels(data$obs)))) 
    stop("'data$obs' should have levels consistent with 'lev'")
  dataComplete <- data[complete.cases(data), ]
  probs <- as.matrix(dataComplete[, lev, drop = FALSE])
  logLoss <- ModelMetrics::mlogLoss(dataComplete$obs, probs)
  c(logLoss = logLoss)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
modelCor
list(`package:caret` = function (x, metric = x$metric[1], ...) 
{
  dat <- x$values[, grep(paste("~", metric[1], sep = ""), names(x$values))]
  colnames(dat) <- gsub(paste("~", metric[1], sep = ""), "", colnames(dat))
  cor(dat, ...)
}, function (x, metric = x$metric[1], ...) 
{
  dat <- x$values[, grep(paste("~", metric[1], sep = ""), names(x$values))]
  colnames(dat) <- gsub(paste("~", metric[1], sep = ""), "", colnames(dat))
  cor(dat, ...)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
modelLookup
list(`package:caret` = function (model = NULL) 
{
  load(system.file("models", "models.RData", package = "caret"))
  if (!is.null(model)) {
    if (!(model %in% names(models))) 
      stop(paste("Model '", method, "' is not in the ", "set of existing models", sep = ""))
    models <- models[model == names(models)]
  }
  out <- lapply(models, function(x) {
    out <- x$parameters[, c("parameter", "label")]
    out$forReg <- "Regression" %in% x$type
    out$forClass <- "Classification" %in% x$type
    out$probModel <- !is.null(x$prob)
    out
  })
  for (i in seq(along = out)) out[[i]]$model <- names(models)[i]
  out <- do.call("rbind", out)
  rownames(out) <- NULL
  out <- out[, c("model", "parameter", "label", "forReg", "forClass", "probModel")]
  out[order(out$model), ]
}, function (model = NULL) 
{
  load(system.file("models", "models.RData", package = "caret"))
  if (!is.null(model)) {
    if (!(model %in% names(models))) 
      stop(paste("Model '", method, "' is not in the ", "set of existing models", sep = ""))
    models <- models[model == names(models)]
  }
  out <- lapply(models, function(x) {
    out <- x$parameters[, c("parameter", "label")]
    out$forReg <- "Regression" %in% x$type
    out$forClass <- "Classification" %in% x$type
    out$probModel <- !is.null(x$prob)
    out
  })
  for (i in seq(along = out)) out[[i]]$model <- names(models)[i]
  out <- do.call("rbind", out)
  rownames(out) <- NULL
  out <- out[, c("model", "parameter", "label", "forReg", "forClass", "probModel")]
  out[order(out$model), ]
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
multiClassSummary
list(`package:caret` = function (data, lev = NULL, model = NULL) 
{
  if (!all(levels(data[, "pred"]) == levels(data[, "obs"]))) 
    stop("levels of observed and predicted data do not match")
  has_class_probs <- all(lev %in% colnames(data))
  if (has_class_probs) {
    lloss <- mnLogLoss(data = data, lev = lev, model = model)
    requireNamespaceQuietStop("pROC")
    requireNamespaceQuietStop("MLmetrics")
    prob_stats <- lapply(levels(data[, "pred"]), function(x) {
      obs <- ifelse(data[, "obs"] == x, 1, 0)
      prob <- data[, x]
      roc_auc <- try(pROC::roc(obs, data[, x], direction = "<", quiet = TRUE), silent = TRUE)
      roc_auc <- if (inherits(roc_auc, "try-error")) 
        NA
      else roc_auc$auc
      pr_auc <- try(MLmetrics::PRAUC(y_pred = data[, x], y_true = obs), silent = TRUE)
      if (inherits(pr_auc, "try-error")) 
        pr_auc <- NA
      res <- c(ROC = roc_auc, AUC = pr_auc)
      return(res)
    })
    prob_stats <- do.call("rbind", prob_stats)
    prob_stats <- colMeans(prob_stats, na.rm = TRUE)
  }
  CM <- confusionMatrix(data[, "pred"], data[, "obs"], mode = "everything")
  if (length(levels(data[, "pred"])) == 2) {
    class_stats <- CM$byClass
  }
  else {
    class_stats <- colMeans(CM$byClass)
    names(class_stats) <- paste("Mean", names(class_stats))
  }
  overall_stats <- if (has_class_probs) 
    c(CM$overall, logLoss = as.numeric(lloss), AUC = unname(prob_stats["ROC"]), prAUC = unname(prob_stats["AUC"]))
  else CM$overall
  stats <- c(overall_stats, class_stats)
  stats <- stats[!names(stats) %in% c("AccuracyNull", "AccuracyLower", "AccuracyUpper", "AccuracyPValue", "McnemarPValue", "Mean Prevalence", "Mean Detection Prevalence")]
  names(stats) <- gsub("[[:blank:]]+", "_", names(stats))
  stat_list <- c("Accuracy", "Kappa", "Mean_F1", "Mean_Sensitivity", "Mean_Specificity", "Mean_Pos_Pred_Value", "Mean_Neg_Pred_Value", "Mean_Precision", "Mean_Recall", "Mean_Detection_Rate", "Mean_Balanced_Accuracy")
  if (has_class_probs) 
    stat_list <- c("logLoss", "AUC", "prAUC", stat_list)
  if (length(levels(data[, "pred"])) == 2) 
    stat_list <- gsub("^Mean_", "", stat_list)
  stats <- stats[c(stat_list)]
  return(stats)
}, function (data, lev = NULL, model = NULL) 
{
  if (!all(levels(data[, "pred"]) == levels(data[, "obs"]))) 
    stop("levels of observed and predicted data do not match")
  has_class_probs <- all(lev %in% colnames(data))
  if (has_class_probs) {
    lloss <- mnLogLoss(data = data, lev = lev, model = model)
    requireNamespaceQuietStop("pROC")
    requireNamespaceQuietStop("MLmetrics")
    prob_stats <- lapply(levels(data[, "pred"]), function(x) {
      obs <- ifelse(data[, "obs"] == x, 1, 0)
      prob <- data[, x]
      roc_auc <- try(pROC::roc(obs, data[, x], direction = "<", quiet = TRUE), silent = TRUE)
      roc_auc <- if (inherits(roc_auc, "try-error")) 
        NA
      else roc_auc$auc
      pr_auc <- try(MLmetrics::PRAUC(y_pred = data[, x], y_true = obs), silent = TRUE)
      if (inherits(pr_auc, "try-error")) 
        pr_auc <- NA
      res <- c(ROC = roc_auc, AUC = pr_auc)
      return(res)
    })
    prob_stats <- do.call("rbind", prob_stats)
    prob_stats <- colMeans(prob_stats, na.rm = TRUE)
  }
  CM <- confusionMatrix(data[, "pred"], data[, "obs"], mode = "everything")
  if (length(levels(data[, "pred"])) == 2) {
    class_stats <- CM$byClass
  }
  else {
    class_stats <- colMeans(CM$byClass)
    names(class_stats) <- paste("Mean", names(class_stats))
  }
  overall_stats <- if (has_class_probs) 
    c(CM$overall, logLoss = as.numeric(lloss), AUC = unname(prob_stats["ROC"]), prAUC = unname(prob_stats["AUC"]))
  else CM$overall
  stats <- c(overall_stats, class_stats)
  stats <- stats[!names(stats) %in% c("AccuracyNull", "AccuracyLower", "AccuracyUpper", "AccuracyPValue", "McnemarPValue", "Mean Prevalence", "Mean Detection Prevalence")]
  names(stats) <- gsub("[[:blank:]]+", "_", names(stats))
  stat_list <- c("Accuracy", "Kappa", "Mean_F1", "Mean_Sensitivity", "Mean_Specificity", "Mean_Pos_Pred_Value", "Mean_Neg_Pred_Value", "Mean_Precision", "Mean_Recall", "Mean_Detection_Rate", "Mean_Balanced_Accuracy")
  if (has_class_probs) 
    stat_list <- c("logLoss", "AUC", "prAUC", stat_list)
  if (length(levels(data[, "pred"])) == 2) 
    stat_list <- gsub("^Mean_", "", stat_list)
  stats <- stats[c(stat_list)]
  return(stats)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
nbBag
list(`package:caret` = list(fit = function (x, y, ...) 
{
  loadNamespace("klaR")
  klaR::NaiveBayes(x, y, usekernel = TRUE, fL = 2, ...)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  as.data.frame(predict(object, x)$posterior, stringsAsFactors = TRUE)
}, aggregate = function (x, type = "class") 
{
  pooled <- x[[1]] * NA
  classes <- colnames(pooled)
  for (i in 1:ncol(pooled)) {
    tmp <- lapply(x, function(y, col) y[, col], col = i)
    tmp <- do.call("rbind", tmp)
    pooled[, i] <- apply(tmp, 2, median)
  }
  if (type == "class") {
    out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
  }
  else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  out
}), list(fit = function (x, y, ...) 
{
  loadNamespace("klaR")
  klaR::NaiveBayes(x, y, usekernel = TRUE, fL = 2, ...)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  as.data.frame(predict(object, x)$posterior, stringsAsFactors = TRUE)
}, aggregate = function (x, type = "class") 
{
  pooled <- x[[1]] * NA
  classes <- colnames(pooled)
  for (i in 1:ncol(pooled)) {
    tmp <- lapply(x, function(y, col) y[, col], col = i)
    tmp <- do.call("rbind", tmp)
    pooled[, i] <- apply(tmp, 2, median)
  }
  if (type == "class") {
    out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
  }
  else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  out
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
nbFuncs
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loadNamespace("klaR")
  klaR::NaiveBayes(x, y, usekernel = TRUE, fL = 2, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  out <- cbind(data.frame(pred = tmp$class), as.data.frame(tmp$posterior, stringsAsFactors = TRUE))
  out
}, rank = function (object, x, y) 
{
  vimp <- filterVarImp(x, y)
  if (is.factor(y)) {
    avImp <- apply(vimp, 1, mean)
    vimp$Overall <- avImp
  }
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}), list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loadNamespace("klaR")
  klaR::NaiveBayes(x, y, usekernel = TRUE, fL = 2, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  out <- cbind(data.frame(pred = tmp$class), as.data.frame(tmp$posterior, stringsAsFactors = TRUE))
  out
}, rank = function (object, x, y) 
{
  vimp <- filterVarImp(x, y)
  if (is.factor(y)) {
    avImp <- apply(vimp, 1, mean)
    vimp$Overall <- avImp
  }
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
nbSBF
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, ...) 
{
  if (ncol(x) > 0) {
    loadNamespace("klaR")
    klaR::NaiveBayes(x, y, usekernel = TRUE, fL = 2, ...)
  }
  else nullModel(y = y)
}, pred = function (object, x) 
{
  if (inherits(object, "nullModel")) {
    tmp <- predict(object, x)
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob")))
  }
  else {
    tmp <- predict(object, x)
    out <- cbind(data.frame(pred = tmp$class), as.data.frame(tmp$posterior, stringsAsFactors = FALSE))
  }
  out
}, pred = function (object, x) 
{
  predict(object, x)$class
}, score = function (x, y) 
{
  anovaScores(x, y)
}, filter = function (score, x, y) 
  score <= 0.05), list(summary = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, fit = function (x, y, ...) 
  {
    if (ncol(x) > 0) {
      loadNamespace("klaR")
      klaR::NaiveBayes(x, y, usekernel = TRUE, fL = 2, ...)
    }
    else nullModel(y = y)
  }, pred = function (object, x) 
  {
    if (inherits(object, "nullModel")) {
      tmp <- predict(object, x)
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob")))
    }
    else {
      tmp <- predict(object, x)
      out <- cbind(data.frame(pred = tmp$class), as.data.frame(tmp$posterior, stringsAsFactors = FALSE))
    }
    out
  }, pred = function (object, x) 
  {
    predict(object, x)$class
  }, score = function (x, y) 
  {
    anovaScores(x, y)
  }, filter = function (score, x, y) 
    score <= 0.05))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
nearZeroVar
list(`package:caret` = function (x, freqCut = 95/5, uniqueCut = 10, saveMetrics = FALSE, names = FALSE, foreach = FALSE, allowParallel = TRUE) 
{
  if (!foreach) 
    return(nzv(x, freqCut = freqCut, uniqueCut = uniqueCut, saveMetrics = saveMetrics, names = names))
  `%op%` <- getOper(foreach && allowParallel && getDoParWorkers() > 1)
  if (saveMetrics) {
    res <- foreach(name = colnames(x), .combine = rbind) %op% {
      r <- nzv(x[[name]], freqCut = freqCut, uniqueCut = uniqueCut, saveMetrics = TRUE)
      r[, "column"] <- name
      r
    }
    res <- res[, c(5, 1, 2, 3, 4)]
    rownames(res) <- as.character(res$column)
    res$column <- NULL
  }
  else {
    res <- foreach(name = colnames(x), .combine = c) %op% {
      r <- nzv(x[[name]], freqCut = freqCut, uniqueCut = uniqueCut, saveMetrics = FALSE)
      if (length(r) > 0 && r == 1) 
        TRUE
      else FALSE
    }
    res <- which(res)
    if (names) {
      res <- colnames(x)[res]
    }
  }
  res
}, function (x, freqCut = 95/5, uniqueCut = 10, saveMetrics = FALSE, names = FALSE, foreach = FALSE, allowParallel = TRUE) 
{
  if (!foreach) 
    return(nzv(x, freqCut = freqCut, uniqueCut = uniqueCut, saveMetrics = saveMetrics, names = names))
  `%op%` <- getOper(foreach && allowParallel && getDoParWorkers() > 1)
  if (saveMetrics) {
    res <- foreach(name = colnames(x), .combine = rbind) %op% {
      r <- nzv(x[[name]], freqCut = freqCut, uniqueCut = uniqueCut, saveMetrics = TRUE)
      r[, "column"] <- name
      r
    }
    res <- res[, c(5, 1, 2, 3, 4)]
    rownames(res) <- as.character(res$column)
    res$column <- NULL
  }
  else {
    res <- foreach(name = colnames(x), .combine = c) %op% {
      r <- nzv(x[[name]], freqCut = freqCut, uniqueCut = uniqueCut, saveMetrics = FALSE)
      if (length(r) > 0 && r == 1) 
        TRUE
      else FALSE
    }
    res <- which(res)
    if (names) {
      res <- colnames(x)[res]
    }
  }
  res
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
negPredValue
list(`package:caret` = function (data, ...) 
{
  UseMethod("negPredValue")
}, function (data, ...) 
{
  UseMethod("negPredValue")
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
nnetBag
list(`package:caret` = list(fit = function (x, y, ...) 
{
  loadNamespace("nnet")
  factorY <- is.factor(y)
  if (factorY) 
    y <- class2ind(y)
  out <- nnet::nnet(x, y, linout = !factorY, trace = FALSE, ...)
  out$classification <- factorY
  out
}, pred = function (object, x) 
{
  out <- predict(object, x, type = "raw")
  if (object$classification) {
    colnames(out) <- colnames(object$fitted.values)
    rownames(out) <- NULL
  }
  else out <- predict(object, x, type = "raw")[, 1]
  out
}, aggregate = function (x, type = "class") 
{
  if (is.matrix(x[[1]]) | is.data.frame(x[[1]])) {
    pooled <- x[[1]] & NA
    classes <- colnames(pooled)
    for (i in 1:ncol(pooled)) {
      tmp <- lapply(x, function(y, col) y[, col], col = i)
      tmp <- do.call("rbind", tmp)
      pooled[, i] <- apply(tmp, 2, median)
    }
    if (type == "class") {
      out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
    }
    else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  }
  else {
    x <- matrix(unlist(x), ncol = length(x))
    out <- apply(x, 1, median)
  }
  out
}), list(fit = function (x, y, ...) 
{
  loadNamespace("nnet")
  factorY <- is.factor(y)
  if (factorY) 
    y <- class2ind(y)
  out <- nnet::nnet(x, y, linout = !factorY, trace = FALSE, ...)
  out$classification <- factorY
  out
}, pred = function (object, x) 
{
  out <- predict(object, x, type = "raw")
  if (object$classification) {
    colnames(out) <- colnames(object$fitted.values)
    rownames(out) <- NULL
  }
  else out <- predict(object, x, type = "raw")[, 1]
  out
}, aggregate = function (x, type = "class") 
{
  if (is.matrix(x[[1]]) | is.data.frame(x[[1]])) {
    pooled <- x[[1]] & NA
    classes <- colnames(pooled)
    for (i in 1:ncol(pooled)) {
      tmp <- lapply(x, function(y, col) y[, col], col = i)
      tmp <- do.call("rbind", tmp)
      pooled[, i] <- apply(tmp, 2, median)
    }
    if (type == "class") {
      out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
    }
    else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  }
  else {
    x <- matrix(unlist(x), ncol = length(x))
    out <- apply(x, 1, median)
  }
  out
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
nullModel
list(`package:caret` = function (x, ...) 
  UseMethod("nullModel"), function (x, ...) 
    UseMethod("nullModel"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
nzv
list(`package:caret` = function (x, freqCut = 95/5, uniqueCut = 10, saveMetrics = FALSE, names = FALSE) 
{
  if (is.null(dim(x))) 
    x <- matrix(x, ncol = 1)
  freqRatio <- apply(x, 2, function(data) {
    t <- table(data[!is.na(data)])
    if (length(t) <= 1) {
      return(0)
    }
    w <- which.max(t)
    return(max(t, na.rm = TRUE)/max(t[-w], na.rm = TRUE))
  })
  lunique <- apply(x, 2, function(data) length(unique(data[!is.na(data)])))
  percentUnique <- 100 * lunique/apply(x, 2, length)
  zeroVar <- (lunique == 1) | apply(x, 2, function(data) all(is.na(data)))
  if (saveMetrics) {
    out <- data.frame(freqRatio = freqRatio, percentUnique = percentUnique, zeroVar = zeroVar, nzv = (freqRatio > freqCut & percentUnique <= uniqueCut) | zeroVar)
  }
  else {
    out <- which((freqRatio > freqCut & percentUnique <= uniqueCut) | zeroVar)
    names(out) <- NULL
    if (names) {
      out <- colnames(x)[out]
    }
  }
  out
}, function (x, wts, freq_cut = 95/5, unique_cut = 10) 
{
  if (is.null(dim(x))) {
    x <- matrix(x, ncol = 1)
  }
  fr_foo <- function(data) {
    t <- weighted_table(data[!is.na(data)], wts = wts)
    if (length(t) <= 1) {
      return(0)
    }
    w <- which.max(t)
    return(max(t, na.rm = TRUE)/max(t[-w], na.rm = TRUE))
  }
  freq_ratio <- vapply(x, fr_foo, c(ratio = 0))
  uni_foo <- function(data) {
    length(unique(data[!is.na(data)]))
  }
  lunique <- vapply(x, uni_foo, c(num = 0))
  pct_unique <- 100 * lunique/vapply(x, length, c(num = 0))
  zero_func <- function(data) {
    all(is.na(data))
  }
  zero_var <- (lunique == 1) | vapply(x, zero_func, c(zv = TRUE))
  out <- which((freq_ratio > freq_cut & pct_unique <= unique_cut) | zero_var)
  names(out) <- NULL
  colnames(x)[out]
}, function (x, freqCut = 95/5, uniqueCut = 10, saveMetrics = FALSE, names = FALSE) 
{
  if (is.null(dim(x))) 
    x <- matrix(x, ncol = 1)
  freqRatio <- apply(x, 2, function(data) {
    t <- table(data[!is.na(data)])
    if (length(t) <= 1) {
      return(0)
    }
    w <- which.max(t)
    return(max(t, na.rm = TRUE)/max(t[-w], na.rm = TRUE))
  })
  lunique <- apply(x, 2, function(data) length(unique(data[!is.na(data)])))
  percentUnique <- 100 * lunique/apply(x, 2, length)
  zeroVar <- (lunique == 1) | apply(x, 2, function(data) all(is.na(data)))
  if (saveMetrics) {
    out <- data.frame(freqRatio = freqRatio, percentUnique = percentUnique, zeroVar = zeroVar, nzv = (freqRatio > freqCut & percentUnique <= uniqueCut) | zeroVar)
  }
  else {
    out <- which((freqRatio > freqCut & percentUnique <= uniqueCut) | zeroVar)
    names(out) <- NULL
    if (names) {
      out <- colnames(x)[out]
    }
  }
  out
})
c("package:caret", "namespace:recipes", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
oneSE
list(`package:caret` = function (x, metric, num, maximize) 
{
  index <- 1:nrow(x)
  if (!maximize) {
    bestIndex <- which.min(x[, metric])
    perf <- x[bestIndex, metric] + (x[bestIndex, paste(metric, "SD", sep = "")])/sqrt(num)
    candidates <- index[x[, metric] <= perf]
    bestIter <- min(candidates)
  }
  else {
    bestIndex <- which.max(x[, metric])
    perf <- x[bestIndex, metric] - (x[bestIndex, paste(metric, "SD", sep = "")])/sqrt(num)
    candidates <- index[x[, metric] >= perf]
    bestIter <- min(candidates)
  }
  bestIter
}, function (x, metric, num, maximize) 
{
  index <- 1:nrow(x)
  if (!maximize) {
    bestIndex <- which.min(x[, metric])
    perf <- x[bestIndex, metric] + (x[bestIndex, paste(metric, "SD", sep = "")])/sqrt(num)
    candidates <- index[x[, metric] <= perf]
    bestIter <- min(candidates)
  }
  else {
    bestIndex <- which.max(x[, metric])
    perf <- x[bestIndex, metric] - (x[bestIndex, paste(metric, "SD", sep = "")])/sqrt(num)
    candidates <- index[x[, metric] >= perf]
    bestIter <- min(candidates)
  }
  bestIter
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
outcome_conversion
list(`package:caret` = function (x, lv) 
{
  if (is.factor(x) | is.character(x)) {
    if (!is.null(attributes(lv)) && any(names(attributes(lv)) == "ordered" && attr(lv, "ordered"))) 
      x <- ordered(as.character(x), levels = lv)
    else x <- factor(as.character(x), levels = lv)
  }
  x
}, function (x, lv) 
{
  if (is.factor(x) | is.character(x)) {
    if (!is.null(attributes(lv)) && any(names(attributes(lv)) == "ordered" && attr(lv, "ordered"))) 
      x <- ordered(as.character(x), levels = lv)
    else x <- factor(as.character(x), levels = lv)
  }
  x
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
panel.calibration
list(`package:caret` = function (...) 
{
  panel.abline(0, 1, col = trellis.par.get("reference.line")$col, lwd = trellis.par.get("reference.line")$lwd, lty = trellis.par.get("reference.line")$lty)
  panel.xyplot(...)
}, function (...) 
{
  panel.abline(0, 1, col = trellis.par.get("reference.line")$col, lwd = trellis.par.get("reference.line")$lwd, lty = trellis.par.get("reference.line")$lty)
  panel.xyplot(...)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
panel.lift
list(`package:caret` = function (x, y, ...) 
{
  panel.xyplot(x, y, ...)
  panel.abline(0, 1, col = "black")
}, function (x, y, ...) 
{
  panel.xyplot(x, y, ...)
  panel.abline(0, 1, col = "black")
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
panel.lift2
list(`package:caret` = function (x, y, pct = 0, values = NULL, ...) 
{
  polyx <- c(0, pct, 100, 0)
  polyy <- c(0, 100, 100, 0)
  regionStyle <- trellis.par.get("reference.line")
  panel.polygon(polyx, polyy, col = regionStyle$col, border = regionStyle$col)
  panel.xyplot(x, y, ...)
  if (!is.null(values)) {
    theDots <- list(...)
    if (any(names(theDots) == "groups")) {
      dat <- data.frame(x = x, y = y, groups = theDots$groups)
      ung <- unique(dat$groups)
      for (i in seq(along = ung)) {
        dat0 <- subset(dat, groups == ung[i])
        plotRef(dat0$x, dat0$y, values, iter = i)
      }
    }
    else plotRef(x, y, values)
  }
}, function (x, y, pct = 0, values = NULL, ...) 
{
  polyx <- c(0, pct, 100, 0)
  polyy <- c(0, 100, 100, 0)
  regionStyle <- trellis.par.get("reference.line")
  panel.polygon(polyx, polyy, col = regionStyle$col, border = regionStyle$col)
  panel.xyplot(x, y, ...)
  if (!is.null(values)) {
    theDots <- list(...)
    if (any(names(theDots) == "groups")) {
      dat <- data.frame(x = x, y = y, groups = theDots$groups)
      ung <- unique(dat$groups)
      for (i in seq(along = ung)) {
        dat0 <- subset(dat, groups == ung[i])
        plotRef(dat0$x, dat0$y, values, iter = i)
      }
    }
    else plotRef(x, y, values)
  }
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
panel.needle
list(`package:caret` = function (x, y, horizontal = TRUE, pch = if (is.null(groups)) dot.symbol$pch else sup.symbol$pch, col = if (is.null(groups)) dot.symbol$col else sup.symbol$col, lty = dot.line$lty, lwd = dot.line$lwd, col.line = dot.line$col, levels.fos = NULL, groups = NULL, ...) 
{
  x <- as.numeric(x)
  y <- as.numeric(y)
  dot.line <- trellis.par.get("dot.line")
  dot.symbol <- trellis.par.get("dot.symbol")
  sup.symbol <- trellis.par.get("superpose.symbol")
  if (horizontal) {
    yscale <- extendrange(y, f = 0.2)
    if (is.null(levels.fos)) 
      levels.fos <- floor(yscale[2]) - ceiling(yscale[1]) + 1
    panel.abline(v = 0, col = 1, lty = 1, lwd = 1)
    pch <- rep(pch, length(x))
    pch <- ifelse(x == 0, NA, pch)
    for (i in seq(along = x)) lsegments(x[i], y[i], 0, y[i])
    if (is.null(groups)) 
      panel.xyplot(x = x, y = y, col = col, pch = pch, ...)
    else panel.superpose(x = x, y = y, groups = groups, col = col, pch = pch, ...)
  }
  else {
    xscale <- extendrange(x, f = 0.2)
    if (is.null(levels.fos)) 
      levels.fos <- floor(xscale[2]) - ceiling(xscale[1]) + 1
    panel.abline(h = 0, col = col.line, lty = lty, lwd = lwd)
    pch <- rep(pch, length(x))
    pch <- ifelse(x == 0, NA, pch)
    if (is.null(groups)) 
      panel.xyplot(x = x, y = y, col = col, pch = pch, ...)
    else panel.superpose(x = x, y = y, groups = groups, col = col, pch = pch, ...)
  }
}, function (x, y, horizontal = TRUE, pch = if (is.null(groups)) dot.symbol$pch else sup.symbol$pch, col = if (is.null(groups)) dot.symbol$col else sup.symbol$col, lty = dot.line$lty, lwd = dot.line$lwd, col.line = dot.line$col, levels.fos = NULL, groups = NULL, ...) 
{
  x <- as.numeric(x)
  y <- as.numeric(y)
  dot.line <- trellis.par.get("dot.line")
  dot.symbol <- trellis.par.get("dot.symbol")
  sup.symbol <- trellis.par.get("superpose.symbol")
  if (horizontal) {
    yscale <- extendrange(y, f = 0.2)
    if (is.null(levels.fos)) 
      levels.fos <- floor(yscale[2]) - ceiling(yscale[1]) + 1
    panel.abline(v = 0, col = 1, lty = 1, lwd = 1)
    pch <- rep(pch, length(x))
    pch <- ifelse(x == 0, NA, pch)
    for (i in seq(along = x)) lsegments(x[i], y[i], 0, y[i])
    if (is.null(groups)) 
      panel.xyplot(x = x, y = y, col = col, pch = pch, ...)
    else panel.superpose(x = x, y = y, groups = groups, col = col, pch = pch, ...)
  }
  else {
    xscale <- extendrange(x, f = 0.2)
    if (is.null(levels.fos)) 
      levels.fos <- floor(xscale[2]) - ceiling(xscale[1]) + 1
    panel.abline(h = 0, col = col.line, lty = lty, lwd = lwd)
    pch <- rep(pch, length(x))
    pch <- ifelse(x == 0, NA, pch)
    if (is.null(groups)) 
      panel.xyplot(x = x, y = y, col = col, pch = pch, ...)
    else panel.superpose(x = x, y = y, groups = groups, col = col, pch = pch, ...)
  }
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
pcaNNet
list(`package:caret` = function (x, ...) 
  UseMethod("pcaNNet"), function (x, ...) 
    UseMethod("pcaNNet"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
pickSizeBest
list(`package:caret` = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
pickSizeTolerance
list(`package:caret` = function (x, metric, tol = 1.5, maximize) 
{
  if (!maximize) {
    best <- min(x[, metric])
    perf <- (x[, metric] - best)/best * 100
    flag <- perf <= tol
  }
  else {
    best <- max(x[, metric])
    perf <- (best - x[, metric])/best * 100
    flag <- perf <= tol
  }
  min(x[flag, "Variables"])
}, function (x, metric, tol = 1.5, maximize) 
{
  if (!maximize) {
    best <- min(x[, metric])
    perf <- (x[, metric] - best)/best * 100
    flag <- perf <= tol
  }
  else {
    best <- max(x[, metric])
    perf <- (best - x[, metric])/best * 100
    flag <- perf <= tol
  }
  min(x[flag, "Variables"])
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
pickVars
list(`package:caret` = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}, function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
plot.gafs
list(`package:caret` = function (x, metric = x$control$metric["external"], estimate = c("internal", "external"), output = "ggplot", ...) 
{
  int_names <- names(x$internal)[!(names(x$internal) %in% ga_internal_names)]
  ext_names <- names(x$external)[!(names(x$external) %in% ga_external_names)]
  common <- intersect(int_names, ext_names)
  both_estimates <- length(estimate) == 2 && all(sort(estimate) == c("external", "internal"))
  if (both_estimates) {
    if (!metric %in% common) 
      stop(paste("'", metric, "' not computed in both estimates"))
    tmp_e <- x$external[, c("Iter", "Resample", common)]
    tmp_e$Estimate <- "External"
    tmp_i <- x$internal[, c("Iter", "Resample", common)]
    tmp_i$Estimate <- "Internal"
    plot_dat <- rbind(tmp_e, tmp_i)
  }
  else {
    if ("internal" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed internally"))
      plot_dat <- x$internal[, c("Iter", "Resample", int_names)]
    }
    if ("external" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed externally"))
      plot_dat <- x$external[, c("Iter", "Resample", ext_names)]
    }
  }
  if (output == "data") 
    out <- plot_dat
  plot_dat <- if (both_estimates) 
    ddply(plot_dat, c("Iter", "Estimate"), function(x) c(Mean = mean(x[, metric])))
  else ddply(plot_dat, c("Iter"), function(x) c(Mean = mean(x[, metric])))
  if (output == "ggplot") {
    out <- if (both_estimates) 
      ggplot(plot_dat, aes(x = Iter, y = Mean, color = Estimate)) + geom_point()
    else ggplot(plot_dat, aes(x = Iter, y = Mean)) + geom_point()
    out <- out + xlab("Generation")
  }
  if (output == "lattice") {
    out <- if (both_estimates) 
      xyplot(Mean ~ Iter, data = plot_dat, groups = Estimate, ...)
    else xyplot(Mean ~ Iter, data = plot_dat, ...)
    out <- update(out, xlab = "Generation")
  }
  out
}, function (x, metric = x$control$metric["external"], estimate = c("internal", "external"), output = "ggplot", ...) 
{
  int_names <- names(x$internal)[!(names(x$internal) %in% ga_internal_names)]
  ext_names <- names(x$external)[!(names(x$external) %in% ga_external_names)]
  common <- intersect(int_names, ext_names)
  both_estimates <- length(estimate) == 2 && all(sort(estimate) == c("external", "internal"))
  if (both_estimates) {
    if (!metric %in% common) 
      stop(paste("'", metric, "' not computed in both estimates"))
    tmp_e <- x$external[, c("Iter", "Resample", common)]
    tmp_e$Estimate <- "External"
    tmp_i <- x$internal[, c("Iter", "Resample", common)]
    tmp_i$Estimate <- "Internal"
    plot_dat <- rbind(tmp_e, tmp_i)
  }
  else {
    if ("internal" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed internally"))
      plot_dat <- x$internal[, c("Iter", "Resample", int_names)]
    }
    if ("external" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed externally"))
      plot_dat <- x$external[, c("Iter", "Resample", ext_names)]
    }
  }
  if (output == "data") 
    out <- plot_dat
  plot_dat <- if (both_estimates) 
    ddply(plot_dat, c("Iter", "Estimate"), function(x) c(Mean = mean(x[, metric])))
  else ddply(plot_dat, c("Iter"), function(x) c(Mean = mean(x[, metric])))
  if (output == "ggplot") {
    out <- if (both_estimates) 
      ggplot(plot_dat, aes(x = Iter, y = Mean, color = Estimate)) + geom_point()
    else ggplot(plot_dat, aes(x = Iter, y = Mean)) + geom_point()
    out <- out + xlab("Generation")
  }
  if (output == "lattice") {
    out <- if (both_estimates) 
      xyplot(Mean ~ Iter, data = plot_dat, groups = Estimate, ...)
    else xyplot(Mean ~ Iter, data = plot_dat, ...)
    out <- update(out, xlab = "Generation")
  }
  out
}, function (x, metric = x$control$metric["external"], estimate = c("internal", "external"), output = "ggplot", ...) 
{
  int_names <- names(x$internal)[!(names(x$internal) %in% ga_internal_names)]
  ext_names <- names(x$external)[!(names(x$external) %in% ga_external_names)]
  common <- intersect(int_names, ext_names)
  both_estimates <- length(estimate) == 2 && all(sort(estimate) == c("external", "internal"))
  if (both_estimates) {
    if (!metric %in% common) 
      stop(paste("'", metric, "' not computed in both estimates"))
    tmp_e <- x$external[, c("Iter", "Resample", common)]
    tmp_e$Estimate <- "External"
    tmp_i <- x$internal[, c("Iter", "Resample", common)]
    tmp_i$Estimate <- "Internal"
    plot_dat <- rbind(tmp_e, tmp_i)
  }
  else {
    if ("internal" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed internally"))
      plot_dat <- x$internal[, c("Iter", "Resample", int_names)]
    }
    if ("external" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed externally"))
      plot_dat <- x$external[, c("Iter", "Resample", ext_names)]
    }
  }
  if (output == "data") 
    out <- plot_dat
  plot_dat <- if (both_estimates) 
    ddply(plot_dat, c("Iter", "Estimate"), function(x) c(Mean = mean(x[, metric])))
  else ddply(plot_dat, c("Iter"), function(x) c(Mean = mean(x[, metric])))
  if (output == "ggplot") {
    out <- if (both_estimates) 
      ggplot(plot_dat, aes(x = Iter, y = Mean, color = Estimate)) + geom_point()
    else ggplot(plot_dat, aes(x = Iter, y = Mean)) + geom_point()
    out <- out + xlab("Generation")
  }
  if (output == "lattice") {
    out <- if (both_estimates) 
      xyplot(Mean ~ Iter, data = plot_dat, groups = Estimate, ...)
    else xyplot(Mean ~ Iter, data = plot_dat, ...)
    out <- update(out, xlab = "Generation")
  }
  out
})
c("package:caret", "registered S3 method for plot from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
plot.rfe
list(`package:caret` = function (x, metric = x$metric, ...) 
{
  x$results$Selected <- ""
  x$results$Selected[x$results$Variables == x$bestSubset] <- "*"
  results <- x$results[, colnames(x$results) %in% c("Variables", "Selected", metric)]
  metric <- metric[which(metric %in% colnames(results))]
  plotForm <- as.formula(paste(metric, "~ Variables"))
  panel.profile <- function(x, y, groups, ...) {
    panel.xyplot(x, y, ...)
    panel.xyplot(x[groups == "*"], y[groups == "*"], pch = 16)
  }
  resampText <- resampName(x, FALSE)
  resampText <- paste(metric, resampText)
  out <- xyplot(plotForm, data = results, groups = Selected, panel = panel.profile, ylab = resampText, ...)
  out
}, function (x, metric = x$metric, ...) 
{
  x$results$Selected <- ""
  x$results$Selected[x$results$Variables == x$bestSubset] <- "*"
  results <- x$results[, colnames(x$results) %in% c("Variables", "Selected", metric)]
  metric <- metric[which(metric %in% colnames(results))]
  plotForm <- as.formula(paste(metric, "~ Variables"))
  panel.profile <- function(x, y, groups, ...) {
    panel.xyplot(x, y, ...)
    panel.xyplot(x[groups == "*"], y[groups == "*"], pch = 16)
  }
  resampText <- resampName(x, FALSE)
  resampText <- paste(metric, resampText)
  out <- xyplot(plotForm, data = results, groups = Selected, panel = panel.profile, ylab = resampText, ...)
  out
}, function (x, metric = x$metric, ...) 
{
  x$results$Selected <- ""
  x$results$Selected[x$results$Variables == x$bestSubset] <- "*"
  results <- x$results[, colnames(x$results) %in% c("Variables", "Selected", metric)]
  metric <- metric[which(metric %in% colnames(results))]
  plotForm <- as.formula(paste(metric, "~ Variables"))
  panel.profile <- function(x, y, groups, ...) {
    panel.xyplot(x, y, ...)
    panel.xyplot(x[groups == "*"], y[groups == "*"], pch = 16)
  }
  resampText <- resampName(x, FALSE)
  resampText <- paste(metric, resampText)
  out <- xyplot(plotForm, data = results, groups = Selected, panel = panel.profile, ylab = resampText, ...)
  out
})
c("package:caret", "registered S3 method for plot from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
plot.safs
list(`package:caret` = function (x, metric = x$control$metric["external"], estimate = c("internal", "external"), output = "ggplot", ...) 
{
  int_names <- names(x$internal)[!(names(x$internal) %in% sa_internal_names)]
  ext_names <- names(x$external)[!(names(x$external) %in% sa_external_names)]
  common <- intersect(int_names, ext_names)
  both_estimates <- length(estimate) == 2 && all(sort(estimate) == c("external", "internal"))
  if (both_estimates) {
    if (!metric %in% common) 
      stop(paste("'", metric, "' not computed in both estimates"))
    tmp_e <- x$external[, c("Iter", "Resample", common)]
    tmp_e$Estimate <- "External"
    tmp_i <- x$internal[, c("Iter", "Resample", common)]
    tmp_i$Estimate <- "Internal"
    plot_dat <- rbind(tmp_e, tmp_i)
  }
  else {
    if ("internal" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed internally"))
      plot_dat <- x$internal[, c("Iter", "Resample", int_names)]
    }
    if ("external" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed externally"))
      plot_dat <- x$external[, c("Iter", "Resample", ext_names)]
    }
  }
  if (output == "data") 
    out <- plot_dat
  plot_dat <- if (both_estimates) 
    ddply(plot_dat, c("Iter", "Estimate"), function(x) c(Mean = mean(x[, metric])))
  else ddply(plot_dat, c("Iter"), function(x) c(Mean = mean(x[, metric])))
  if (output == "ggplot") {
    out <- if (both_estimates) 
      ggplot(plot_dat, aes(x = Iter, y = Mean, color = Estimate)) + geom_point()
    else ggplot(plot_dat, aes(x = Iter, y = Mean)) + geom_point()
    out <- out + xlab("Iteration")
  }
  if (output == "lattice") {
    out <- if (both_estimates) 
      xyplot(Mean ~ Iter, data = plot_dat, groups = Estimate, ...)
    else xyplot(Mean ~ Iter, data = plot_dat, ...)
    out <- update(out, xlab = "Iteration")
  }
  out
}, function (x, metric = x$control$metric["external"], estimate = c("internal", "external"), output = "ggplot", ...) 
{
  int_names <- names(x$internal)[!(names(x$internal) %in% sa_internal_names)]
  ext_names <- names(x$external)[!(names(x$external) %in% sa_external_names)]
  common <- intersect(int_names, ext_names)
  both_estimates <- length(estimate) == 2 && all(sort(estimate) == c("external", "internal"))
  if (both_estimates) {
    if (!metric %in% common) 
      stop(paste("'", metric, "' not computed in both estimates"))
    tmp_e <- x$external[, c("Iter", "Resample", common)]
    tmp_e$Estimate <- "External"
    tmp_i <- x$internal[, c("Iter", "Resample", common)]
    tmp_i$Estimate <- "Internal"
    plot_dat <- rbind(tmp_e, tmp_i)
  }
  else {
    if ("internal" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed internally"))
      plot_dat <- x$internal[, c("Iter", "Resample", int_names)]
    }
    if ("external" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed externally"))
      plot_dat <- x$external[, c("Iter", "Resample", ext_names)]
    }
  }
  if (output == "data") 
    out <- plot_dat
  plot_dat <- if (both_estimates) 
    ddply(plot_dat, c("Iter", "Estimate"), function(x) c(Mean = mean(x[, metric])))
  else ddply(plot_dat, c("Iter"), function(x) c(Mean = mean(x[, metric])))
  if (output == "ggplot") {
    out <- if (both_estimates) 
      ggplot(plot_dat, aes(x = Iter, y = Mean, color = Estimate)) + geom_point()
    else ggplot(plot_dat, aes(x = Iter, y = Mean)) + geom_point()
    out <- out + xlab("Iteration")
  }
  if (output == "lattice") {
    out <- if (both_estimates) 
      xyplot(Mean ~ Iter, data = plot_dat, groups = Estimate, ...)
    else xyplot(Mean ~ Iter, data = plot_dat, ...)
    out <- update(out, xlab = "Iteration")
  }
  out
}, function (x, metric = x$control$metric["external"], estimate = c("internal", "external"), output = "ggplot", ...) 
{
  int_names <- names(x$internal)[!(names(x$internal) %in% sa_internal_names)]
  ext_names <- names(x$external)[!(names(x$external) %in% sa_external_names)]
  common <- intersect(int_names, ext_names)
  both_estimates <- length(estimate) == 2 && all(sort(estimate) == c("external", "internal"))
  if (both_estimates) {
    if (!metric %in% common) 
      stop(paste("'", metric, "' not computed in both estimates"))
    tmp_e <- x$external[, c("Iter", "Resample", common)]
    tmp_e$Estimate <- "External"
    tmp_i <- x$internal[, c("Iter", "Resample", common)]
    tmp_i$Estimate <- "Internal"
    plot_dat <- rbind(tmp_e, tmp_i)
  }
  else {
    if ("internal" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed internally"))
      plot_dat <- x$internal[, c("Iter", "Resample", int_names)]
    }
    if ("external" %in% estimate) {
      if (!metric %in% int_names) 
        stop(paste("'", metric, "' not computed externally"))
      plot_dat <- x$external[, c("Iter", "Resample", ext_names)]
    }
  }
  if (output == "data") 
    out <- plot_dat
  plot_dat <- if (both_estimates) 
    ddply(plot_dat, c("Iter", "Estimate"), function(x) c(Mean = mean(x[, metric])))
  else ddply(plot_dat, c("Iter"), function(x) c(Mean = mean(x[, metric])))
  if (output == "ggplot") {
    out <- if (both_estimates) 
      ggplot(plot_dat, aes(x = Iter, y = Mean, color = Estimate)) + geom_point()
    else ggplot(plot_dat, aes(x = Iter, y = Mean)) + geom_point()
    out <- out + xlab("Iteration")
  }
  if (output == "lattice") {
    out <- if (both_estimates) 
      xyplot(Mean ~ Iter, data = plot_dat, groups = Estimate, ...)
    else xyplot(Mean ~ Iter, data = plot_dat, ...)
    out <- update(out, xlab = "Iteration")
  }
  out
})
c("package:caret", "registered S3 method for plot from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
plot.train
list(`package:caret` = function (x, plotType = "scatter", metric = x$metric[1], digits = getOption("digits") - 3, xTrans = NULL, nameInStrip = FALSE, ...) 
{
  if (!(plotType %in% c("level", "scatter", "line"))) 
    stop("plotType must be either level, scatter or line")
  cutpoints <- c(0, 1.9, 2.9, 3.9, Inf)
  prettyVal <- function(u, dig, Name = NULL) {
    if (is.numeric(u)) {
      if (!is.null(Name)) 
        u <- paste(gsub(".", " ", Name, fixed = TRUE), ": ", format(u, digits = dig), sep = "")
      return(factor(u))
    }
    else return(if (!is.factor(u)) as.factor(u) else u)
  }
  params <- as.character(x$modelInfo$parameters$parameter)
  if (grepl("adapt", x$control$method)) 
    warning("When using adaptive resampling, this plot may not accurately capture the relationship between the tuning parameters and model performance.")
  plotIt <- "yes"
  if (all(params == "parameter")) {
    plotIt <- "There are no tuning parameters for this model."
  }
  else {
    dat <- x$results
    if (x$method == "nb") 
      dat$usekernel <- factor(ifelse(dat$usekernel, "Nonparametric", "Gaussian"))
    if (x$method == "gam") 
      dat$select <- factor(ifelse(dat$select, "Feature Selection", "No Feature Selection"))
    if (x$method == "qrnn") 
      dat$bag <- factor(ifelse(dat$bag, "Bagging", "No Bagging"))
    if (x$method == "C5.0") 
      dat$winnow <- factor(ifelse(dat$winnow, "Winnowing", "No Winnowing"))
    if (x$method == "M5") 
      dat$rules <- factor(ifelse(dat$rules == "Yes", "Rules", "Trees"))
    paramValues <- apply(dat[, params, drop = FALSE], 2, function(x) length(unique(x)))
    if (any(paramValues > 1)) {
      params <- names(paramValues)[paramValues > 1]
    }
    else plotIt <- "There are no tuning parameters with more than 1 value."
  }
  if (plotIt == "yes") {
    p <- length(params)
    dat <- dat[, c(metric, params)]
    if (p > 1) {
      numUnique <- unlist(lapply(dat[, -1], function(x) length(unique(x))))
      numUnique <- sort(numUnique, decreasing = TRUE)
      dat <- dat[, c(metric, names(numUnique))]
      params <- names(numUnique)
    }
    if (!is.null(xTrans) & plotType == "scatter") 
      dat[, 2] <- xTrans(dat[, 2])
    resampText <- resampName(x, FALSE)
    if (plotType %in% c("line", "scatter")) {
      if (plotType == "scatter") {
        if (p >= 2) 
          for (i in 3:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
            params[i - 1]
            else NULL)
      }
      else {
        for (i in 2:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
          params[i - 1]
          else NULL)
      }
      for (i in 2:ncol(dat)) if (is.logical(dat[, i])) 
        dat[, i] <- factor(dat[, i])
      if (p > 2 & nameInStrip) {
        strip_vars <- params[-(1:2)]
        strip_lab <- subset(x$modelInfo$parameters, parameter %in% strip_vars)$label
        for (i in seq_along(strip_vars)) dat[, strip_vars[i]] <- factor(paste(strip_lab[i], dat[, strip_vars[i]], sep = ": "))
      }
      form <- if (p <= 2) {
        as.formula(paste(metric, "~", params[1], sep = ""))
      }
      else as.formula(paste(metric, "~", params[1], "|", paste(params[-(1:2)], collapse = "*"), sep = ""))
      defaultArgs <- list(x = form, data = dat, groups = if (p > 1) dat[, params[2]] else NULL)
      if (length(list(...)) > 0) 
        defaultArgs <- c(defaultArgs, list(...))
      lNames <- names(defaultArgs)
      if (!("ylab" %in% lNames)) 
        defaultArgs$ylab <- paste(metric, resampText)
      if (!("type" %in% lNames) & plotType == "scatter") 
        defaultArgs$type <- c("g", "o")
      if (!("type" %in% lNames) & plotType == "line") 
        defaultArgs$type <- c("g", "o")
      if (p > 1) {
        groupCols <- 4
        if (length(unique(dat[, 3])) < 4) 
          groupCols <- length(unique(dat[, 3]))
        if (length(unique(dat[, 3])) %in% 5:6) 
          groupCols <- 3
        groupCols <- as.numeric(cut(length(unique(dat[, 3])), cutpoints, include.lowest = TRUE))
        if (!(any(c("key", "auto.key") %in% lNames))) 
          defaultArgs$auto.key <- list(columns = groupCols, lines = TRUE, title = as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[2]], cex.title = 1)
      }
      if (!("xlab" %in% lNames)) 
        defaultArgs$xlab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[1]]
      if (plotType == "scatter") {
        out <- do.call("xyplot", defaultArgs)
      }
      else {
        out <- do.call("stripplot", defaultArgs)
      }
    }
    if (plotType == "level") {
      if (p == 1) 
        stop("There must be at least 2 tuning parameters with multiple values")
      for (i in 2:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
        params[i - 1]
        else NULL)
      if (p > 2 & nameInStrip) {
        strip_vars <- params[-(1:2)]
        strip_lab <- subset(x$modelInfo$parameters, parameter %in% strip_vars)$label
        for (i in seq_along(strip_vars)) dat[, strip_vars[i]] <- factor(paste(strip_lab[i], dat[, strip_vars[i]], sep = ": "))
      }
      form <- if (p <= 2) {
        as.formula(paste(metric, "~", params[1], "*", params[2], sep = ""))
      }
      else as.formula(paste(metric, "~", params[1], "*", params[2], "|", paste(params[-(1:2)], collapse = "*"), sep = ""))
      defaultArgs <- list(x = form, data = dat)
      if (length(list(...)) > 0) 
        defaultArgs <- c(defaultArgs, list(...))
      lNames <- names(defaultArgs)
      if (!("sub" %in% lNames)) 
        defaultArgs$sub <- paste(metric, resampText)
      if (!("xlab" %in% lNames)) 
        defaultArgs$xlab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[1]]
      if (!("ylab" %in% lNames)) 
        defaultArgs$ylab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[2]]
      out <- do.call("levelplot", defaultArgs)
    }
  }
  else stop(plotIt)
  out
}, function (x, plotType = "scatter", metric = x$metric[1], digits = getOption("digits") - 3, xTrans = NULL, nameInStrip = FALSE, ...) 
{
  if (!(plotType %in% c("level", "scatter", "line"))) 
    stop("plotType must be either level, scatter or line")
  cutpoints <- c(0, 1.9, 2.9, 3.9, Inf)
  prettyVal <- function(u, dig, Name = NULL) {
    if (is.numeric(u)) {
      if (!is.null(Name)) 
        u <- paste(gsub(".", " ", Name, fixed = TRUE), ": ", format(u, digits = dig), sep = "")
      return(factor(u))
    }
    else return(if (!is.factor(u)) as.factor(u) else u)
  }
  params <- as.character(x$modelInfo$parameters$parameter)
  if (grepl("adapt", x$control$method)) 
    warning("When using adaptive resampling, this plot may not accurately capture the relationship between the tuning parameters and model performance.")
  plotIt <- "yes"
  if (all(params == "parameter")) {
    plotIt <- "There are no tuning parameters for this model."
  }
  else {
    dat <- x$results
    if (x$method == "nb") 
      dat$usekernel <- factor(ifelse(dat$usekernel, "Nonparametric", "Gaussian"))
    if (x$method == "gam") 
      dat$select <- factor(ifelse(dat$select, "Feature Selection", "No Feature Selection"))
    if (x$method == "qrnn") 
      dat$bag <- factor(ifelse(dat$bag, "Bagging", "No Bagging"))
    if (x$method == "C5.0") 
      dat$winnow <- factor(ifelse(dat$winnow, "Winnowing", "No Winnowing"))
    if (x$method == "M5") 
      dat$rules <- factor(ifelse(dat$rules == "Yes", "Rules", "Trees"))
    paramValues <- apply(dat[, params, drop = FALSE], 2, function(x) length(unique(x)))
    if (any(paramValues > 1)) {
      params <- names(paramValues)[paramValues > 1]
    }
    else plotIt <- "There are no tuning parameters with more than 1 value."
  }
  if (plotIt == "yes") {
    p <- length(params)
    dat <- dat[, c(metric, params)]
    if (p > 1) {
      numUnique <- unlist(lapply(dat[, -1], function(x) length(unique(x))))
      numUnique <- sort(numUnique, decreasing = TRUE)
      dat <- dat[, c(metric, names(numUnique))]
      params <- names(numUnique)
    }
    if (!is.null(xTrans) & plotType == "scatter") 
      dat[, 2] <- xTrans(dat[, 2])
    resampText <- resampName(x, FALSE)
    if (plotType %in% c("line", "scatter")) {
      if (plotType == "scatter") {
        if (p >= 2) 
          for (i in 3:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
            params[i - 1]
            else NULL)
      }
      else {
        for (i in 2:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
          params[i - 1]
          else NULL)
      }
      for (i in 2:ncol(dat)) if (is.logical(dat[, i])) 
        dat[, i] <- factor(dat[, i])
      if (p > 2 & nameInStrip) {
        strip_vars <- params[-(1:2)]
        strip_lab <- subset(x$modelInfo$parameters, parameter %in% strip_vars)$label
        for (i in seq_along(strip_vars)) dat[, strip_vars[i]] <- factor(paste(strip_lab[i], dat[, strip_vars[i]], sep = ": "))
      }
      form <- if (p <= 2) {
        as.formula(paste(metric, "~", params[1], sep = ""))
      }
      else as.formula(paste(metric, "~", params[1], "|", paste(params[-(1:2)], collapse = "*"), sep = ""))
      defaultArgs <- list(x = form, data = dat, groups = if (p > 1) dat[, params[2]] else NULL)
      if (length(list(...)) > 0) 
        defaultArgs <- c(defaultArgs, list(...))
      lNames <- names(defaultArgs)
      if (!("ylab" %in% lNames)) 
        defaultArgs$ylab <- paste(metric, resampText)
      if (!("type" %in% lNames) & plotType == "scatter") 
        defaultArgs$type <- c("g", "o")
      if (!("type" %in% lNames) & plotType == "line") 
        defaultArgs$type <- c("g", "o")
      if (p > 1) {
        groupCols <- 4
        if (length(unique(dat[, 3])) < 4) 
          groupCols <- length(unique(dat[, 3]))
        if (length(unique(dat[, 3])) %in% 5:6) 
          groupCols <- 3
        groupCols <- as.numeric(cut(length(unique(dat[, 3])), cutpoints, include.lowest = TRUE))
        if (!(any(c("key", "auto.key") %in% lNames))) 
          defaultArgs$auto.key <- list(columns = groupCols, lines = TRUE, title = as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[2]], cex.title = 1)
      }
      if (!("xlab" %in% lNames)) 
        defaultArgs$xlab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[1]]
      if (plotType == "scatter") {
        out <- do.call("xyplot", defaultArgs)
      }
      else {
        out <- do.call("stripplot", defaultArgs)
      }
    }
    if (plotType == "level") {
      if (p == 1) 
        stop("There must be at least 2 tuning parameters with multiple values")
      for (i in 2:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
        params[i - 1]
        else NULL)
      if (p > 2 & nameInStrip) {
        strip_vars <- params[-(1:2)]
        strip_lab <- subset(x$modelInfo$parameters, parameter %in% strip_vars)$label
        for (i in seq_along(strip_vars)) dat[, strip_vars[i]] <- factor(paste(strip_lab[i], dat[, strip_vars[i]], sep = ": "))
      }
      form <- if (p <= 2) {
        as.formula(paste(metric, "~", params[1], "*", params[2], sep = ""))
      }
      else as.formula(paste(metric, "~", params[1], "*", params[2], "|", paste(params[-(1:2)], collapse = "*"), sep = ""))
      defaultArgs <- list(x = form, data = dat)
      if (length(list(...)) > 0) 
        defaultArgs <- c(defaultArgs, list(...))
      lNames <- names(defaultArgs)
      if (!("sub" %in% lNames)) 
        defaultArgs$sub <- paste(metric, resampText)
      if (!("xlab" %in% lNames)) 
        defaultArgs$xlab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[1]]
      if (!("ylab" %in% lNames)) 
        defaultArgs$ylab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[2]]
      out <- do.call("levelplot", defaultArgs)
    }
  }
  else stop(plotIt)
  out
}, function (x, plotType = "scatter", metric = x$metric[1], digits = getOption("digits") - 3, xTrans = NULL, nameInStrip = FALSE, ...) 
{
  if (!(plotType %in% c("level", "scatter", "line"))) 
    stop("plotType must be either level, scatter or line")
  cutpoints <- c(0, 1.9, 2.9, 3.9, Inf)
  prettyVal <- function(u, dig, Name = NULL) {
    if (is.numeric(u)) {
      if (!is.null(Name)) 
        u <- paste(gsub(".", " ", Name, fixed = TRUE), ": ", format(u, digits = dig), sep = "")
      return(factor(u))
    }
    else return(if (!is.factor(u)) as.factor(u) else u)
  }
  params <- as.character(x$modelInfo$parameters$parameter)
  if (grepl("adapt", x$control$method)) 
    warning("When using adaptive resampling, this plot may not accurately capture the relationship between the tuning parameters and model performance.")
  plotIt <- "yes"
  if (all(params == "parameter")) {
    plotIt <- "There are no tuning parameters for this model."
  }
  else {
    dat <- x$results
    if (x$method == "nb") 
      dat$usekernel <- factor(ifelse(dat$usekernel, "Nonparametric", "Gaussian"))
    if (x$method == "gam") 
      dat$select <- factor(ifelse(dat$select, "Feature Selection", "No Feature Selection"))
    if (x$method == "qrnn") 
      dat$bag <- factor(ifelse(dat$bag, "Bagging", "No Bagging"))
    if (x$method == "C5.0") 
      dat$winnow <- factor(ifelse(dat$winnow, "Winnowing", "No Winnowing"))
    if (x$method == "M5") 
      dat$rules <- factor(ifelse(dat$rules == "Yes", "Rules", "Trees"))
    paramValues <- apply(dat[, params, drop = FALSE], 2, function(x) length(unique(x)))
    if (any(paramValues > 1)) {
      params <- names(paramValues)[paramValues > 1]
    }
    else plotIt <- "There are no tuning parameters with more than 1 value."
  }
  if (plotIt == "yes") {
    p <- length(params)
    dat <- dat[, c(metric, params)]
    if (p > 1) {
      numUnique <- unlist(lapply(dat[, -1], function(x) length(unique(x))))
      numUnique <- sort(numUnique, decreasing = TRUE)
      dat <- dat[, c(metric, names(numUnique))]
      params <- names(numUnique)
    }
    if (!is.null(xTrans) & plotType == "scatter") 
      dat[, 2] <- xTrans(dat[, 2])
    resampText <- resampName(x, FALSE)
    if (plotType %in% c("line", "scatter")) {
      if (plotType == "scatter") {
        if (p >= 2) 
          for (i in 3:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
            params[i - 1]
            else NULL)
      }
      else {
        for (i in 2:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
          params[i - 1]
          else NULL)
      }
      for (i in 2:ncol(dat)) if (is.logical(dat[, i])) 
        dat[, i] <- factor(dat[, i])
      if (p > 2 & nameInStrip) {
        strip_vars <- params[-(1:2)]
        strip_lab <- subset(x$modelInfo$parameters, parameter %in% strip_vars)$label
        for (i in seq_along(strip_vars)) dat[, strip_vars[i]] <- factor(paste(strip_lab[i], dat[, strip_vars[i]], sep = ": "))
      }
      form <- if (p <= 2) {
        as.formula(paste(metric, "~", params[1], sep = ""))
      }
      else as.formula(paste(metric, "~", params[1], "|", paste(params[-(1:2)], collapse = "*"), sep = ""))
      defaultArgs <- list(x = form, data = dat, groups = if (p > 1) dat[, params[2]] else NULL)
      if (length(list(...)) > 0) 
        defaultArgs <- c(defaultArgs, list(...))
      lNames <- names(defaultArgs)
      if (!("ylab" %in% lNames)) 
        defaultArgs$ylab <- paste(metric, resampText)
      if (!("type" %in% lNames) & plotType == "scatter") 
        defaultArgs$type <- c("g", "o")
      if (!("type" %in% lNames) & plotType == "line") 
        defaultArgs$type <- c("g", "o")
      if (p > 1) {
        groupCols <- 4
        if (length(unique(dat[, 3])) < 4) 
          groupCols <- length(unique(dat[, 3]))
        if (length(unique(dat[, 3])) %in% 5:6) 
          groupCols <- 3
        groupCols <- as.numeric(cut(length(unique(dat[, 3])), cutpoints, include.lowest = TRUE))
        if (!(any(c("key", "auto.key") %in% lNames))) 
          defaultArgs$auto.key <- list(columns = groupCols, lines = TRUE, title = as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[2]], cex.title = 1)
      }
      if (!("xlab" %in% lNames)) 
        defaultArgs$xlab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[1]]
      if (plotType == "scatter") {
        out <- do.call("xyplot", defaultArgs)
      }
      else {
        out <- do.call("stripplot", defaultArgs)
      }
    }
    if (plotType == "level") {
      if (p == 1) 
        stop("There must be at least 2 tuning parameters with multiple values")
      for (i in 2:ncol(dat)) dat[, i] <- prettyVal(dat[, i], dig = digits, Name = if (i > 3) 
        params[i - 1]
        else NULL)
      if (p > 2 & nameInStrip) {
        strip_vars <- params[-(1:2)]
        strip_lab <- subset(x$modelInfo$parameters, parameter %in% strip_vars)$label
        for (i in seq_along(strip_vars)) dat[, strip_vars[i]] <- factor(paste(strip_lab[i], dat[, strip_vars[i]], sep = ": "))
      }
      form <- if (p <= 2) {
        as.formula(paste(metric, "~", params[1], "*", params[2], sep = ""))
      }
      else as.formula(paste(metric, "~", params[1], "*", params[2], "|", paste(params[-(1:2)], collapse = "*"), sep = ""))
      defaultArgs <- list(x = form, data = dat)
      if (length(list(...)) > 0) 
        defaultArgs <- c(defaultArgs, list(...))
      lNames <- names(defaultArgs)
      if (!("sub" %in% lNames)) 
        defaultArgs$sub <- paste(metric, resampText)
      if (!("xlab" %in% lNames)) 
        defaultArgs$xlab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[1]]
      if (!("ylab" %in% lNames)) 
        defaultArgs$ylab <- as.character(x$modelInfo$parameter$label)[x$modelInfo$parameter$parameter == params[2]]
      out <- do.call("levelplot", defaultArgs)
    }
  }
  else stop(plotIt)
  out
})
c("package:caret", "registered S3 method for plot from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
plotClassProbs
list(`package:caret` = function (object, plotType = "histogram", useObjects = FALSE, ...) 
{
  obsLevels <- levels(object$obs)
  stackProbs <- melt(object, id.vars = c("obs", "model", "object", "dataType"), measure.vars = if (length(obsLevels) == 2) 
    obsLevels[1]
    else obsLevels)
  names(stackProbs)[names(stackProbs) == "variable"] <- "Class"
  names(stackProbs)[names(stackProbs) == "value"] <- "Probability"
  names(stackProbs)[names(stackProbs) == "obs"] <- "Observed"
  stackProbs$Observed <- paste("Data:", as.character(stackProbs$Observed))
  stackProbs$Class <- paste("Prob:", as.character(stackProbs$Class))
  keepVars <- "Observed"
  if (length(unique(stackProbs$dataType)) > 1) 
    keepVars <- c(keepVars, "dataType")
  if (length(unique(stackProbs$model)) > 1) 
    keepVars <- c(keepVars, "model")
  if (any(names(object) == "object") & useObjects) {
    if (length(unique(stackProbs$object)) > 1) 
      keepVars <- c(keepVars, "object")
  }
  if (plotType == "histogram") {
    form <- if (length(obsLevels) == 2) {
      form <- if (length(keepVars) > 0) 
        paste("~ Probability|", paste(keepVars, collapse = "*"))
      else "~ Probability"
      form <- as.formula(form)
      out <- histogram(form, data = stackProbs, xlab = paste("Probability of", obsLevels[1]), ...)
    }
    else {
      form <- if (length(keepVars) > 0) 
        paste("~ Probability|Class*", paste(keepVars, collapse = "*"))
      else "~ Probability|Class"
      form <- as.formula(form)
      out <- histogram(form, data = stackProbs, ...)
    }
  }
  else {
    keepVars <- keepVars[keepVars != "Observed"]
    form <- if (length(keepVars) > 0) 
      paste("~ Probability|", paste(keepVars, collapse = "*"))
    else "~ Probability"
    form <- as.formula(form)
    out <- densityplot(form, data = stackProbs, groups = Observed, ...)
  }
  out
}, function (object, plotType = "histogram", useObjects = FALSE, ...) 
{
  obsLevels <- levels(object$obs)
  stackProbs <- melt(object, id.vars = c("obs", "model", "object", "dataType"), measure.vars = if (length(obsLevels) == 2) 
    obsLevels[1]
    else obsLevels)
  names(stackProbs)[names(stackProbs) == "variable"] <- "Class"
  names(stackProbs)[names(stackProbs) == "value"] <- "Probability"
  names(stackProbs)[names(stackProbs) == "obs"] <- "Observed"
  stackProbs$Observed <- paste("Data:", as.character(stackProbs$Observed))
  stackProbs$Class <- paste("Prob:", as.character(stackProbs$Class))
  keepVars <- "Observed"
  if (length(unique(stackProbs$dataType)) > 1) 
    keepVars <- c(keepVars, "dataType")
  if (length(unique(stackProbs$model)) > 1) 
    keepVars <- c(keepVars, "model")
  if (any(names(object) == "object") & useObjects) {
    if (length(unique(stackProbs$object)) > 1) 
      keepVars <- c(keepVars, "object")
  }
  if (plotType == "histogram") {
    form <- if (length(obsLevels) == 2) {
      form <- if (length(keepVars) > 0) 
        paste("~ Probability|", paste(keepVars, collapse = "*"))
      else "~ Probability"
      form <- as.formula(form)
      out <- histogram(form, data = stackProbs, xlab = paste("Probability of", obsLevels[1]), ...)
    }
    else {
      form <- if (length(keepVars) > 0) 
        paste("~ Probability|Class*", paste(keepVars, collapse = "*"))
      else "~ Probability|Class"
      form <- as.formula(form)
      out <- histogram(form, data = stackProbs, ...)
    }
  }
  else {
    keepVars <- keepVars[keepVars != "Observed"]
    form <- if (length(keepVars) > 0) 
      paste("~ Probability|", paste(keepVars, collapse = "*"))
    else "~ Probability"
    form <- as.formula(form)
    out <- densityplot(form, data = stackProbs, groups = Observed, ...)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
plotObsVsPred
list(`package:caret` = function (object, equalRanges = TRUE, ...) 
{
  object <- object[object$dataType != "Unknown", ]
  object$dataType <- factor(object$dataType)
  if (is.factor(object$obs)) {
    agreement <- object$obs == object$pred
    accuracyTable <- by(agreement, list(model = object$model, data = object$dataType), mean)
    accuracyDF <- data.frame(unclass(accuracyTable))
    accuracyStacked <- stack(accuracyDF)
    accuracyStacked$model <- rep(dimnames(accuracyDF)[[1]], dim(accuracyDF)[2])
    names(accuracyStacked) <- c("Accuracy", "Data", "Model")
    accuracyStacked$Data <- factor(ifelse(accuracyStacked$Data == "Training", "Training (uncorrected)", as.character(accuracyStacked$Data)))
    out <- dotplot(Model ~ Accuracy, accuracyStacked, groups = accuracyStacked$Data, ...)
  }
  else {
    if (equalRanges) {
      xLimits <- yLimits <- extendrange(c(object$obs, object$pred))
    }
    else {
      xLimits <- extendrange(object$obs)
      yLimits <- extendrange(object$pred)
    }
    out <- xyplot(obs ~ pred | model * dataType, object, xlim = xLimits, ylim = yLimits, panel = function(x, y, groups, subscripts, ...) {
      panel.xyplot(x, y, cex = 0.6)
      panel.abline(0, 1, col = trellis.par.get("superpose.line")$col[1], lty = 2)
      panel.loess(x, y, span = 0.75)
    }, xlab = "Predicted", ylab = "Observed", ...)
  }
  out
}, function (object, equalRanges = TRUE, ...) 
{
  object <- object[object$dataType != "Unknown", ]
  object$dataType <- factor(object$dataType)
  if (is.factor(object$obs)) {
    agreement <- object$obs == object$pred
    accuracyTable <- by(agreement, list(model = object$model, data = object$dataType), mean)
    accuracyDF <- data.frame(unclass(accuracyTable))
    accuracyStacked <- stack(accuracyDF)
    accuracyStacked$model <- rep(dimnames(accuracyDF)[[1]], dim(accuracyDF)[2])
    names(accuracyStacked) <- c("Accuracy", "Data", "Model")
    accuracyStacked$Data <- factor(ifelse(accuracyStacked$Data == "Training", "Training (uncorrected)", as.character(accuracyStacked$Data)))
    out <- dotplot(Model ~ Accuracy, accuracyStacked, groups = accuracyStacked$Data, ...)
  }
  else {
    if (equalRanges) {
      xLimits <- yLimits <- extendrange(c(object$obs, object$pred))
    }
    else {
      xLimits <- extendrange(object$obs)
      yLimits <- extendrange(object$pred)
    }
    out <- xyplot(obs ~ pred | model * dataType, object, xlim = xLimits, ylim = yLimits, panel = function(x, y, groups, subscripts, ...) {
      panel.xyplot(x, y, cex = 0.6)
      panel.abline(0, 1, col = trellis.par.get("superpose.line")$col[1], lty = 2)
      panel.loess(x, y, span = 0.75)
    }, xlab = "Predicted", ylab = "Observed", ...)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
plsBag
list(`package:caret` = list(fit = function (x, y, ...) 
{
  loadNamespace("pls")
  caret::plsda(x, y, ...)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  predict(object, x, type = "prob")[, , ]
}, aggregate = function (x, type = "class") 
{
  pooled <- x[[1]] * NA
  classes <- colnames(pooled)
  for (i in 1:ncol(pooled)) {
    tmp <- lapply(x, function(y, col) y[, col], col = i)
    tmp <- do.call("rbind", tmp)
    pooled[, i] <- apply(tmp, 2, median)
  }
  if (type == "class") {
    out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
  }
  else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  out
}), list(fit = function (x, y, ...) 
{
  loadNamespace("pls")
  caret::plsda(x, y, ...)
}, pred = function (object, x) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  predict(object, x, type = "prob")[, , ]
}, aggregate = function (x, type = "class") 
{
  pooled <- x[[1]] * NA
  classes <- colnames(pooled)
  for (i in 1:ncol(pooled)) {
    tmp <- lapply(x, function(y, col) y[, col], col = i)
    tmp <- do.call("rbind", tmp)
    pooled[, i] <- apply(tmp, 2, median)
  }
  if (type == "class") {
    out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
  }
  else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  out
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
plsda
list(`package:caret` = function (x, ...) 
  UseMethod("plsda"), function (x, ...) 
    UseMethod("plsda"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
posPredValue
list(`package:caret` = function (data, ...) 
{
  UseMethod("posPredValue")
}, function (data, ...) 
{
  UseMethod("posPredValue")
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
postResample
list(`package:caret` = function (pred, obs) 
{
  isNA <- is.na(pred)
  pred <- pred[!isNA]
  obs <- obs[!isNA]
  if (!is.factor(obs) && is.numeric(obs)) {
    if (length(obs) + length(pred) == 0) {
      out <- rep(NA, 3)
    }
    else {
      if (length(unique(pred)) < 2 || length(unique(obs)) < 2) {
        resamplCor <- NA
      }
      else {
        resamplCor <- try(cor(pred, obs, use = "pairwise.complete.obs"), silent = TRUE)
        if (inherits(resamplCor, "try-error")) 
          resamplCor <- NA
      }
      mse <- mean((pred - obs)^2)
      mae <- mean(abs(pred - obs))
      out <- c(sqrt(mse), resamplCor^2, mae)
    }
    names(out) <- c("RMSE", "Rsquared", "MAE")
  }
  else {
    if (length(obs) + length(pred) == 0) {
      out <- rep(NA, 2)
    }
    else {
      pred <- factor(pred, levels = levels(obs))
      requireNamespaceQuietStop("e1071")
      out <- unlist(e1071::classAgreement(table(obs, pred)))[c("diag", "kappa")]
    }
    names(out) <- c("Accuracy", "Kappa")
  }
  if (any(is.nan(out))) 
    out[is.nan(out)] <- NA
  out
}, function (pred, obs) 
{
  isNA <- is.na(pred)
  pred <- pred[!isNA]
  obs <- obs[!isNA]
  if (!is.factor(obs) && is.numeric(obs)) {
    if (length(obs) + length(pred) == 0) {
      out <- rep(NA, 3)
    }
    else {
      if (length(unique(pred)) < 2 || length(unique(obs)) < 2) {
        resamplCor <- NA
      }
      else {
        resamplCor <- try(cor(pred, obs, use = "pairwise.complete.obs"), silent = TRUE)
        if (inherits(resamplCor, "try-error")) 
          resamplCor <- NA
      }
      mse <- mean((pred - obs)^2)
      mae <- mean(abs(pred - obs))
      out <- c(sqrt(mse), resamplCor^2, mae)
    }
    names(out) <- c("RMSE", "Rsquared", "MAE")
  }
  else {
    if (length(obs) + length(pred) == 0) {
      out <- rep(NA, 2)
    }
    else {
      pred <- factor(pred, levels = levels(obs))
      requireNamespaceQuietStop("e1071")
      out <- unlist(e1071::classAgreement(table(obs, pred)))[c("diag", "kappa")]
    }
    names(out) <- c("Accuracy", "Kappa")
  }
  if (any(is.nan(out))) 
    out[is.nan(out)] <- NA
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
precision
list(`package:caret` = function (data, ...) 
  UseMethod("precision"), function (actual, predicted, cutoff = 0.5) 
  {
    ppv_(actual, predicted, cutoff)
  }, function (data, ...) 
    UseMethod("precision"), function (x) 
    {
      x <- unique(x)
      x <- x[is.finite(x)]
      if (length(x) <= 1) {
        return(1)
      }
      smallest_diff <- min(diff(sort(x)))
      if (smallest_diff < sqrt(.Machine$double.eps)) {
        1
      }
      else {
        precision <- 10^(floor(log10(smallest_diff)) - 1)
        if (all(round(x/precision)%%10 == 0)) {
          precision <- precision * 10
        }
        pmin(precision, 1)
      }
    })
c("package:caret", "namespace:ModelMetrics", "namespace:caret", "namespace:scales")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, FALSE)
predict.bagEarth
list(`package:caret` = function (object, newdata = NULL, type = NULL, ...) 
{
  if (is.null(type)) {
    type <- if (all(is.na(object$levels))) 
      "response"
    else "class"
  }
  if (!any(type %in% c("response", "class", "prob"))) 
    stop("type must be either response, class or prob", call. = FALSE)
  requireNamespaceQuietStop("earth")
  getTrainPred <- function(x) {
    oobIndex <- seq(along = x$fitted.values)
    oobIndex <- oobIndex[!(oobIndex %in% unique(x$index))]
    data.frame(pred = x$fitted.values[oobIndex], sample = oobIndex)
  }
  if (is.null(newdata) & !is.null(object$x)) 
    newdata <- object$x
  if (is.null(newdata)) {
    pred <- lapply(object$fit, getTrainPred)
    pred <- rbind.fill(pred)
    out <- ddply(pred, .(sample), function(x) object$summary(x$pred))$V1
  }
  else {
    pred <- lapply(object$fit, function(x, y) {
      if (is.null(x$glm.list)) 
        predict(x, newdata = y)
      else predict(x, newdata = y, type = "response")
    }, y = newdata)
    out <- aggregate_pred(pred, object$levels, object$summary)
  }
  if (type == "class") {
    out <- object$levels[apply(out, 1, which.max)]
    out <- factor(out, levels = object$levels)
  }
  out
}, function (object, newdata = NULL, type = NULL, ...) 
{
  if (is.null(type)) {
    type <- if (all(is.na(object$levels))) 
      "response"
    else "class"
  }
  if (!any(type %in% c("response", "class", "prob"))) 
    stop("type must be either response, class or prob", call. = FALSE)
  requireNamespaceQuietStop("earth")
  getTrainPred <- function(x) {
    oobIndex <- seq(along = x$fitted.values)
    oobIndex <- oobIndex[!(oobIndex %in% unique(x$index))]
    data.frame(pred = x$fitted.values[oobIndex], sample = oobIndex)
  }
  if (is.null(newdata) & !is.null(object$x)) 
    newdata <- object$x
  if (is.null(newdata)) {
    pred <- lapply(object$fit, getTrainPred)
    pred <- rbind.fill(pred)
    out <- ddply(pred, .(sample), function(x) object$summary(x$pred))$V1
  }
  else {
    pred <- lapply(object$fit, function(x, y) {
      if (is.null(x$glm.list)) 
        predict(x, newdata = y)
      else predict(x, newdata = y, type = "response")
    }, y = newdata)
    out <- aggregate_pred(pred, object$levels, object$summary)
  }
  if (type == "class") {
    out <- object$levels[apply(out, 1, which.max)]
    out <- factor(out, levels = object$levels)
  }
  out
}, function (object, newdata = NULL, type = NULL, ...) 
{
  if (is.null(type)) {
    type <- if (all(is.na(object$levels))) 
      "response"
    else "class"
  }
  if (!any(type %in% c("response", "class", "prob"))) 
    stop("type must be either response, class or prob", call. = FALSE)
  requireNamespaceQuietStop("earth")
  getTrainPred <- function(x) {
    oobIndex <- seq(along = x$fitted.values)
    oobIndex <- oobIndex[!(oobIndex %in% unique(x$index))]
    data.frame(pred = x$fitted.values[oobIndex], sample = oobIndex)
  }
  if (is.null(newdata) & !is.null(object$x)) 
    newdata <- object$x
  if (is.null(newdata)) {
    pred <- lapply(object$fit, getTrainPred)
    pred <- rbind.fill(pred)
    out <- ddply(pred, .(sample), function(x) object$summary(x$pred))$V1
  }
  else {
    pred <- lapply(object$fit, function(x, y) {
      if (is.null(x$glm.list)) 
        predict(x, newdata = y)
      else predict(x, newdata = y, type = "response")
    }, y = newdata)
    out <- aggregate_pred(pred, object$levels, object$summary)
  }
  if (type == "class") {
    out <- object$levels[apply(out, 1, which.max)]
    out <- factor(out, levels = object$levels)
  }
  out
})
c("package:caret", "registered S3 method for predict from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
predict.gafs
list(`package:caret` = function (object, newdata, ...) 
{
  if (any(names(object) == "recipe") && !is.null(object$recipe)) {
    newdata <- bake(object$recipe, newdata, all_predictors(), composition = "data.frame")
  }
  else {
    newdata <- newdata[, object$optVariables, drop = FALSE]
  }
  object$control$functions$pred(object$fit, newdata)
}, function (object, newdata, ...) 
{
  if (any(names(object) == "recipe") && !is.null(object$recipe)) {
    newdata <- bake(object$recipe, newdata, all_predictors(), composition = "data.frame")
  }
  else {
    newdata <- newdata[, object$optVariables, drop = FALSE]
  }
  object$control$functions$pred(object$fit, newdata)
}, function (object, newdata, ...) 
{
  if (any(names(object) == "recipe") && !is.null(object$recipe)) {
    newdata <- bake(object$recipe, newdata, all_predictors(), composition = "data.frame")
  }
  else {
    newdata <- newdata[, object$optVariables, drop = FALSE]
  }
  object$control$functions$pred(object$fit, newdata)
})
c("package:caret", "registered S3 method for predict from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
predict.train
list(`package:caret` = function (object, newdata = NULL, type = "raw", na.action = na.omit, ...) 
{
  if (all(names(object) != "modelInfo")) {
    object <- update(object, param = NULL)
  }
  if (!is.null(object$modelInfo$library)) 
    for (i in object$modelInfo$library) do.call("requireNamespaceQuietStop", list(package = i))
  if (!(type %in% c("raw", "prob"))) 
    stop("type must be either \"raw\" or \"prob\"")
  if (type == "prob") {
    if (is.null(object$modelInfo$prob)) 
      stop("only classification models that produce probabilities are allowed")
  }
  if (!is.null(newdata)) {
    if (inherits(object, "train.formula")) {
      newdata <- as.data.frame(newdata, stringsAsFactors = FALSE)
      rn <- row.names(newdata)
      Terms <- delete.response(object$terms)
      m <- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels)
      if (!is.null(cl <- attr(Terms, "dataClasses"))) 
        .checkMFClasses(cl, m)
      keep <- match(row.names(m), rn)
      newdata <- model.matrix(Terms, m, contrasts = object$contrasts)
      xint <- match("(Intercept)", colnames(newdata), nomatch = 0)
      if (xint > 0) 
        newdata <- newdata[, -xint, drop = FALSE]
    }
  }
  else if (object$control$method != "oob") {
    if (!is.null(object$trainingData)) {
      if (object$method == "pam") {
        newdata <- object$finalModel$xData
      }
      else {
        newdata <- object$trainingData
        newdata$.outcome <- NULL
        if ("train.formula" %in% class(object) && any(unlist(lapply(newdata, is.factor)))) {
          newdata <- model.matrix(~., data = newdata)[, -1]
          newdata <- as.data.frame(newdata, stringsAsFactors = FALSE)
        }
      }
    }
    else stop("please specify data via newdata")
  }
  if ("xNames" %in% names(object$finalModel) & is.null(object$preProcess$method$pca) & is.null(object$preProcess$method$ica)) 
    newdata <- newdata[, colnames(newdata) %in% object$finalModel$xNames, drop = FALSE]
  if (type == "prob") {
    out <- probFunction(method = object$modelInfo, modelFit = object$finalModel, newdata = newdata, preProc = object$preProcess)
    obsLevels <- levels(object)
    out <- out[, obsLevels, drop = FALSE]
  }
  else {
    out <- predictionFunction(method = object$modelInfo, modelFit = object$finalModel, newdata = newdata, preProc = object$preProcess)
    if (object$modelType == "Regression") {
      out <- trimPredictions(pred = out, mod_type = object$modelType, bounds = object$control$predictionBounds, limits = object$yLimit)
    }
    else {
      if (!("levels" %in% names(object))) 
        object$levels <- levels(object)
      out <- outcome_conversion(as.character(out), lv = object$levels)
    }
  }
  out
}, function (object, newdata = NULL, type = "raw", na.action = na.omit, ...) 
{
  if (all(names(object) != "modelInfo")) {
    object <- update(object, param = NULL)
  }
  if (!is.null(object$modelInfo$library)) 
    for (i in object$modelInfo$library) do.call("requireNamespaceQuietStop", list(package = i))
  if (!(type %in% c("raw", "prob"))) 
    stop("type must be either \"raw\" or \"prob\"")
  if (type == "prob") {
    if (is.null(object$modelInfo$prob)) 
      stop("only classification models that produce probabilities are allowed")
  }
  if (!is.null(newdata)) {
    if (inherits(object, "train.formula")) {
      newdata <- as.data.frame(newdata, stringsAsFactors = FALSE)
      rn <- row.names(newdata)
      Terms <- delete.response(object$terms)
      m <- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels)
      if (!is.null(cl <- attr(Terms, "dataClasses"))) 
        .checkMFClasses(cl, m)
      keep <- match(row.names(m), rn)
      newdata <- model.matrix(Terms, m, contrasts = object$contrasts)
      xint <- match("(Intercept)", colnames(newdata), nomatch = 0)
      if (xint > 0) 
        newdata <- newdata[, -xint, drop = FALSE]
    }
  }
  else if (object$control$method != "oob") {
    if (!is.null(object$trainingData)) {
      if (object$method == "pam") {
        newdata <- object$finalModel$xData
      }
      else {
        newdata <- object$trainingData
        newdata$.outcome <- NULL
        if ("train.formula" %in% class(object) && any(unlist(lapply(newdata, is.factor)))) {
          newdata <- model.matrix(~., data = newdata)[, -1]
          newdata <- as.data.frame(newdata, stringsAsFactors = FALSE)
        }
      }
    }
    else stop("please specify data via newdata")
  }
  if ("xNames" %in% names(object$finalModel) & is.null(object$preProcess$method$pca) & is.null(object$preProcess$method$ica)) 
    newdata <- newdata[, colnames(newdata) %in% object$finalModel$xNames, drop = FALSE]
  if (type == "prob") {
    out <- probFunction(method = object$modelInfo, modelFit = object$finalModel, newdata = newdata, preProc = object$preProcess)
    obsLevels <- levels(object)
    out <- out[, obsLevels, drop = FALSE]
  }
  else {
    out <- predictionFunction(method = object$modelInfo, modelFit = object$finalModel, newdata = newdata, preProc = object$preProcess)
    if (object$modelType == "Regression") {
      out <- trimPredictions(pred = out, mod_type = object$modelType, bounds = object$control$predictionBounds, limits = object$yLimit)
    }
    else {
      if (!("levels" %in% names(object))) 
        object$levels <- levels(object)
      out <- outcome_conversion(as.character(out), lv = object$levels)
    }
  }
  out
}, function (object, newdata = NULL, type = "raw", na.action = na.omit, ...) 
{
  if (all(names(object) != "modelInfo")) {
    object <- update(object, param = NULL)
  }
  if (!is.null(object$modelInfo$library)) 
    for (i in object$modelInfo$library) do.call("requireNamespaceQuietStop", list(package = i))
  if (!(type %in% c("raw", "prob"))) 
    stop("type must be either \"raw\" or \"prob\"")
  if (type == "prob") {
    if (is.null(object$modelInfo$prob)) 
      stop("only classification models that produce probabilities are allowed")
  }
  if (!is.null(newdata)) {
    if (inherits(object, "train.formula")) {
      newdata <- as.data.frame(newdata, stringsAsFactors = FALSE)
      rn <- row.names(newdata)
      Terms <- delete.response(object$terms)
      m <- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels)
      if (!is.null(cl <- attr(Terms, "dataClasses"))) 
        .checkMFClasses(cl, m)
      keep <- match(row.names(m), rn)
      newdata <- model.matrix(Terms, m, contrasts = object$contrasts)
      xint <- match("(Intercept)", colnames(newdata), nomatch = 0)
      if (xint > 0) 
        newdata <- newdata[, -xint, drop = FALSE]
    }
  }
  else if (object$control$method != "oob") {
    if (!is.null(object$trainingData)) {
      if (object$method == "pam") {
        newdata <- object$finalModel$xData
      }
      else {
        newdata <- object$trainingData
        newdata$.outcome <- NULL
        if ("train.formula" %in% class(object) && any(unlist(lapply(newdata, is.factor)))) {
          newdata <- model.matrix(~., data = newdata)[, -1]
          newdata <- as.data.frame(newdata, stringsAsFactors = FALSE)
        }
      }
    }
    else stop("please specify data via newdata")
  }
  if ("xNames" %in% names(object$finalModel) & is.null(object$preProcess$method$pca) & is.null(object$preProcess$method$ica)) 
    newdata <- newdata[, colnames(newdata) %in% object$finalModel$xNames, drop = FALSE]
  if (type == "prob") {
    out <- probFunction(method = object$modelInfo, modelFit = object$finalModel, newdata = newdata, preProc = object$preProcess)
    obsLevels <- levels(object)
    out <- out[, obsLevels, drop = FALSE]
  }
  else {
    out <- predictionFunction(method = object$modelInfo, modelFit = object$finalModel, newdata = newdata, preProc = object$preProcess)
    if (object$modelType == "Regression") {
      out <- trimPredictions(pred = out, mod_type = object$modelType, bounds = object$control$predictionBounds, limits = object$yLimit)
    }
    else {
      if (!("levels" %in% names(object))) 
        object$levels <- levels(object)
      out <- outcome_conversion(as.character(out), lv = object$levels)
    }
  }
  out
})
c("package:caret", "registered S3 method for predict from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
predictionFunction
list(`package:caret` = function (method, modelFit, newdata, preProc = NULL, param = NULL) 
{
  if (!is.null(newdata) && !is.null(preProc)) 
    newdata <- predict(preProc, newdata)
  out <- method$predict(modelFit = modelFit, newdata = newdata, submodels = param)
  out
}, function (method, modelFit, newdata, preProc = NULL, param = NULL) 
{
  if (!is.null(newdata) && !is.null(preProc)) 
    newdata <- predict(preProc, newdata)
  out <- method$predict(modelFit = modelFit, newdata = newdata, submodels = param)
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
predictors
list(`package:caret` = function (x, ...) 
{
  UseMethod("predictors")
}, function (x, ...) 
{
  UseMethod("predictors")
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
preProcess
list(`package:caret` = function (x, ...) 
  UseMethod("preProcess"), function (x, ...) 
    UseMethod("preProcess"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
print.train
list(`package:caret` = function (x, printCall = FALSE, details = FALSE, selectCol = FALSE, showSD = FALSE, ...) 
{
  if (!is.null(x$modelInfo$label)) 
    cat(x$modelInfo$label, "\n\n")
  if (printCall) 
    printCall(x$call)
  if (!is.null(x$trainingData)) {
    chDim <- dim(x$trainingData)
    chDim[2] <- chDim[2] - 1
    if (x$modelType == "Classification") {
      lev <- levels(x)
      if (is.character(lev)) 
        chDim <- c(chDim, length(lev))
    }
    else lev <- NULL
    chDim <- format(chDim)
    cat(chDim[1], " samples", sep = "")
    if (!is.null(x$control$indexFinal)) 
      cat(",", length(x$control$indexFinal), "used for final model\n")
    else cat("\n")
    cat(chDim[2], " predictor", ifelse(chDim[2] > 1, "s\n", "\n"), sep = "")
    if (is.character(lev)) {
      cat(chDim[3], "classes:", paste("'", lev, "'", sep = "", collapse = ", "), "\n")
    }
    cat("\n")
  }
  if (!is.null(x$preProc)) {
    pp_list(x$preProc$method)
  }
  else {
    if (inherits(x, "train.recipe")) {
      step_names <- function(x) gsub("^step_", "", class(x)[1])
      steps_used <- unlist(lapply(x$recipe$steps, step_names))
      ppText <- paste("Recipe steps:", paste(steps_used, collapse = ", "))
      cat(truncateText(ppText), "\n")
    }
    else cat("No pre-processing\n")
  }
  if (!is.null(x$control$index)) {
    resampleN <- unlist(lapply(x$control$index, length))
    numResamp <- length(resampleN)
    resampText <- resampName(x)
    cat("Resampling:", resampText, "\n")
    if (x$control$method != "none") {
      outLabel <- x$metric
      resampleN <- as.character(resampleN)
      if (numResamp > 5) 
        resampleN <- c(resampleN[1:6], "...")
      cat("Summary of sample sizes:", paste(resampleN, collapse = ", "), "\n")
    }
  }
  if (!is.null(x$control$sampling)) {
    cat("Addtional sampling using ")
    cat(switch(x$control$sampling$name, down = "down-sampling", up = "up-sampling", smote = "SMOTE", rose = "ROSE", custom = "a custom function"))
    if (!is.null(x$preProc)) {
      if (x$control$sampling$first) 
        cat(" prior to pre-processing")
      else cat(" after to pre-processing")
    }
    cat("\n\n")
  }
  if (x$control$method != "none") {
    tuneAcc <- x$results
    tuneAcc <- tuneAcc[, names(tuneAcc) != "parameter"]
    cat("Resampling results")
    if (dim(tuneAcc)[1] > 1) 
      cat(" across tuning parameters")
    if (showSD) 
      cat(" (values below are 'mean (sd)')")
    cat(":\n\n")
    if (dim(tuneAcc)[1] > 1) {
      numParam <- length(x$bestTune)
      finalTune <- x$bestTune
      optValues <- paste(names(finalTune), "=", format(finalTune, ...))
      optString <- paste0("The final ", ifelse(numParam > 1, "values", "value"), " used for the model ", ifelse(numParam > 1, "were ", "was "), stringFunc(optValues), ".")
      finalTune$Selected <- "*"
      if (any(names(tuneAcc) %in% "method")) 
        names(tuneAcc)[names(tuneAcc) %in% "method"] <- ".method"
      if (any(names(finalTune) %in% "method")) 
        names(finalTune)[names(finalTune) %in% "method"] <- ".method"
      tuneAcc <- merge(tuneAcc, finalTune, all.x = TRUE)
      if (any(names(tuneAcc) %in% ".method")) 
        names(tuneAcc)[names(tuneAcc) %in% ".method"] <- "method"
      tuneAcc$Selected[is.na(tuneAcc$Selected)] <- ""
    }
    else optString <- ""
    sdCols <- grep("SD$", colnames(tuneAcc))
    if (showSD) {
      sdCheck <- unlist(lapply(tuneAcc[, sdCols, drop = FALSE], function(u) all(is.na(u))))
      if (any(sdCheck)) {
        rmCols <- names(sdCheck)[sdCheck]
        tuneAcc <- tuneAcc[, !(names(tuneAcc) %in% rmCols)]
      }
    }
    else {
      if (length(sdCols) > 0) 
        tuneAcc <- tuneAcc[, -sdCols, drop = FALSE]
    }
    params <- names(x$bestTune)
    if (!all(params == "parameter")) {
      numVals <- apply(tuneAcc[, params, drop = FALSE], 2, function(x) length(unique(x)))
      if (any(numVals < 2)) {
        constString <- NULL
        for (i in seq(along = numVals)) {
          if (numVals[i] == 1) 
            constString <- c(constString, paste0("Tuning parameter '", names(numVals)[i], "' was held constant at a value of ", stringFunc(tuneAcc[1, names(numVals)[i]])))
        }
        discard <- names(numVals)[which(numVals == 1)]
        tuneAcc <- tuneAcc[, !(names(tuneAcc) %in% discard), drop = FALSE]
      }
      else constString <- NULL
    }
    else constString <- NULL
    tuneAcc <- tuneAcc[, !grepl("Apparent$|Optimism$", names(tuneAcc)), drop = FALSE]
    colnames(tuneAcc)[colnames(tuneAcc) == ".B"] <- "Resamples"
    nms <- names(tuneAcc)[names(tuneAcc) %in% params]
    sort_args <- vector(mode = "list", length = length(nms))
    for (i in seq(along = nms)) {
      sort_args[[i]] <- tuneAcc[, nms[i]]
    }
    tune_ord <- do.call("order", sort_args)
    if (!is.null(tune_ord)) 
      tuneAcc <- tuneAcc[tune_ord, , drop = FALSE]
    theDots <- list(...)
    theDots$x <- tuneAcc
    printMat <- do.call("format.data.frame", theDots)
    printMat <- as.matrix(printMat)
    rownames(printMat) <- rep("", dim(printMat)[1])
    if (showSD) {
      sdCols <- grep("SD$", colnames(printMat), value = TRUE)
      sd_dat <- printMat[, sdCols, drop = FALSE]
      printMat <- printMat[, !(colnames(printMat) %in% sdCols), drop = FALSE]
      for (col_name in sdCols) {
        not_sd <- gsub("SD$", "", col_name)
        if (any(colnames(printMat) == not_sd)) {
          printMat[, not_sd] <- paste0(printMat[, not_sd], " (", sd_dat[, col_name], ")")
        }
      }
    }
    if (!selectCol) 
      printMat <- printMat[, colnames(printMat) != "Selected", drop = FALSE]
    print(printMat, quote = FALSE, print.gap = 2)
    cat("\n")
    if (!is.null(constString)) {
      cat(truncateText(paste(constString, collapse = "\n")))
      cat("\n")
    }
    if (dim(tuneAcc)[1] > 1) {
      if (is.null(x$update)) {
        met <- paste(x$metric, "was used to select the optimal model using")
        if (is.function(x$control$selectionFunction)) {
          met <- paste(met, " a custom selection rule.\n")
        }
        else {
          met <- paste(met, switch(x$control$selectionFunction, best = paste("the", ifelse(x$maximize, "largest", "smallest"), "value.\n"), oneSE = " the one SE rule.\n", tolerance = " a tolerance rule.\n"))
        }
      }
      else {
        met <- paste("The tuning", ifelse(ncol(x$bestTune) > 1, "parameters", "parameter"), "was set manually.\n")
      }
      cat(truncateText(met))
    }
    cat(truncateText(optString))
    if (nzchar(optString)) 
      cat("\n")
  }
  else printMat <- NULL
  if (details) {
    if (!(x$method %in% c("gbm", "treebag", "nb", "lvq", "knn"))) {
      cat("\n----------------------------------------------------------\n")
      cat("\nThe final model:\n\n")
      switch(x$method, lm = , nnet = , multinom = , pls = , earth = , lmStepAIC = , bagEarth = , bagFDA = print(summary(x$finalModel)), rpart = , ctree = , ctree2 = , cforest = , glmboost = , gamboost = , blackboost = , ada = , randomForest = , pcaNNet = , svmradial = , svmpoly = , svmRadial = , svmPoly = , rvmRadial = , rvmPoly = , lssvmRadial = , lssvmPoly = , gaussprRadial = , gaussprPoly = , enet = , lasso = , LMT = , JRip = , lda = , rda = , pamr = , gpls = , J48 = , ppr = print(x$finalModel), 
             fda = {
               print(x$finalModel)
               cat("\n Summary of Terms\n\n")
               print(x$finalModel$fit)
             })
    }
  }
  invisible(printMat)
}, function (x, printCall = FALSE, details = FALSE, selectCol = FALSE, showSD = FALSE, ...) 
{
  if (!is.null(x$modelInfo$label)) 
    cat(x$modelInfo$label, "\n\n")
  if (printCall) 
    printCall(x$call)
  if (!is.null(x$trainingData)) {
    chDim <- dim(x$trainingData)
    chDim[2] <- chDim[2] - 1
    if (x$modelType == "Classification") {
      lev <- levels(x)
      if (is.character(lev)) 
        chDim <- c(chDim, length(lev))
    }
    else lev <- NULL
    chDim <- format(chDim)
    cat(chDim[1], " samples", sep = "")
    if (!is.null(x$control$indexFinal)) 
      cat(",", length(x$control$indexFinal), "used for final model\n")
    else cat("\n")
    cat(chDim[2], " predictor", ifelse(chDim[2] > 1, "s\n", "\n"), sep = "")
    if (is.character(lev)) {
      cat(chDim[3], "classes:", paste("'", lev, "'", sep = "", collapse = ", "), "\n")
    }
    cat("\n")
  }
  if (!is.null(x$preProc)) {
    pp_list(x$preProc$method)
  }
  else {
    if (inherits(x, "train.recipe")) {
      step_names <- function(x) gsub("^step_", "", class(x)[1])
      steps_used <- unlist(lapply(x$recipe$steps, step_names))
      ppText <- paste("Recipe steps:", paste(steps_used, collapse = ", "))
      cat(truncateText(ppText), "\n")
    }
    else cat("No pre-processing\n")
  }
  if (!is.null(x$control$index)) {
    resampleN <- unlist(lapply(x$control$index, length))
    numResamp <- length(resampleN)
    resampText <- resampName(x)
    cat("Resampling:", resampText, "\n")
    if (x$control$method != "none") {
      outLabel <- x$metric
      resampleN <- as.character(resampleN)
      if (numResamp > 5) 
        resampleN <- c(resampleN[1:6], "...")
      cat("Summary of sample sizes:", paste(resampleN, collapse = ", "), "\n")
    }
  }
  if (!is.null(x$control$sampling)) {
    cat("Addtional sampling using ")
    cat(switch(x$control$sampling$name, down = "down-sampling", up = "up-sampling", smote = "SMOTE", rose = "ROSE", custom = "a custom function"))
    if (!is.null(x$preProc)) {
      if (x$control$sampling$first) 
        cat(" prior to pre-processing")
      else cat(" after to pre-processing")
    }
    cat("\n\n")
  }
  if (x$control$method != "none") {
    tuneAcc <- x$results
    tuneAcc <- tuneAcc[, names(tuneAcc) != "parameter"]
    cat("Resampling results")
    if (dim(tuneAcc)[1] > 1) 
      cat(" across tuning parameters")
    if (showSD) 
      cat(" (values below are 'mean (sd)')")
    cat(":\n\n")
    if (dim(tuneAcc)[1] > 1) {
      numParam <- length(x$bestTune)
      finalTune <- x$bestTune
      optValues <- paste(names(finalTune), "=", format(finalTune, ...))
      optString <- paste0("The final ", ifelse(numParam > 1, "values", "value"), " used for the model ", ifelse(numParam > 1, "were ", "was "), stringFunc(optValues), ".")
      finalTune$Selected <- "*"
      if (any(names(tuneAcc) %in% "method")) 
        names(tuneAcc)[names(tuneAcc) %in% "method"] <- ".method"
      if (any(names(finalTune) %in% "method")) 
        names(finalTune)[names(finalTune) %in% "method"] <- ".method"
      tuneAcc <- merge(tuneAcc, finalTune, all.x = TRUE)
      if (any(names(tuneAcc) %in% ".method")) 
        names(tuneAcc)[names(tuneAcc) %in% ".method"] <- "method"
      tuneAcc$Selected[is.na(tuneAcc$Selected)] <- ""
    }
    else optString <- ""
    sdCols <- grep("SD$", colnames(tuneAcc))
    if (showSD) {
      sdCheck <- unlist(lapply(tuneAcc[, sdCols, drop = FALSE], function(u) all(is.na(u))))
      if (any(sdCheck)) {
        rmCols <- names(sdCheck)[sdCheck]
        tuneAcc <- tuneAcc[, !(names(tuneAcc) %in% rmCols)]
      }
    }
    else {
      if (length(sdCols) > 0) 
        tuneAcc <- tuneAcc[, -sdCols, drop = FALSE]
    }
    params <- names(x$bestTune)
    if (!all(params == "parameter")) {
      numVals <- apply(tuneAcc[, params, drop = FALSE], 2, function(x) length(unique(x)))
      if (any(numVals < 2)) {
        constString <- NULL
        for (i in seq(along = numVals)) {
          if (numVals[i] == 1) 
            constString <- c(constString, paste0("Tuning parameter '", names(numVals)[i], "' was held constant at a value of ", stringFunc(tuneAcc[1, names(numVals)[i]])))
        }
        discard <- names(numVals)[which(numVals == 1)]
        tuneAcc <- tuneAcc[, !(names(tuneAcc) %in% discard), drop = FALSE]
      }
      else constString <- NULL
    }
    else constString <- NULL
    tuneAcc <- tuneAcc[, !grepl("Apparent$|Optimism$", names(tuneAcc)), drop = FALSE]
    colnames(tuneAcc)[colnames(tuneAcc) == ".B"] <- "Resamples"
    nms <- names(tuneAcc)[names(tuneAcc) %in% params]
    sort_args <- vector(mode = "list", length = length(nms))
    for (i in seq(along = nms)) {
      sort_args[[i]] <- tuneAcc[, nms[i]]
    }
    tune_ord <- do.call("order", sort_args)
    if (!is.null(tune_ord)) 
      tuneAcc <- tuneAcc[tune_ord, , drop = FALSE]
    theDots <- list(...)
    theDots$x <- tuneAcc
    printMat <- do.call("format.data.frame", theDots)
    printMat <- as.matrix(printMat)
    rownames(printMat) <- rep("", dim(printMat)[1])
    if (showSD) {
      sdCols <- grep("SD$", colnames(printMat), value = TRUE)
      sd_dat <- printMat[, sdCols, drop = FALSE]
      printMat <- printMat[, !(colnames(printMat) %in% sdCols), drop = FALSE]
      for (col_name in sdCols) {
        not_sd <- gsub("SD$", "", col_name)
        if (any(colnames(printMat) == not_sd)) {
          printMat[, not_sd] <- paste0(printMat[, not_sd], " (", sd_dat[, col_name], ")")
        }
      }
    }
    if (!selectCol) 
      printMat <- printMat[, colnames(printMat) != "Selected", drop = FALSE]
    print(printMat, quote = FALSE, print.gap = 2)
    cat("\n")
    if (!is.null(constString)) {
      cat(truncateText(paste(constString, collapse = "\n")))
      cat("\n")
    }
    if (dim(tuneAcc)[1] > 1) {
      if (is.null(x$update)) {
        met <- paste(x$metric, "was used to select the optimal model using")
        if (is.function(x$control$selectionFunction)) {
          met <- paste(met, " a custom selection rule.\n")
        }
        else {
          met <- paste(met, switch(x$control$selectionFunction, best = paste("the", ifelse(x$maximize, "largest", "smallest"), "value.\n"), oneSE = " the one SE rule.\n", tolerance = " a tolerance rule.\n"))
        }
      }
      else {
        met <- paste("The tuning", ifelse(ncol(x$bestTune) > 1, "parameters", "parameter"), "was set manually.\n")
      }
      cat(truncateText(met))
    }
    cat(truncateText(optString))
    if (nzchar(optString)) 
      cat("\n")
  }
  else printMat <- NULL
  if (details) {
    if (!(x$method %in% c("gbm", "treebag", "nb", "lvq", "knn"))) {
      cat("\n----------------------------------------------------------\n")
      cat("\nThe final model:\n\n")
      switch(x$method, lm = , nnet = , multinom = , pls = , earth = , lmStepAIC = , bagEarth = , bagFDA = print(summary(x$finalModel)), rpart = , ctree = , ctree2 = , cforest = , glmboost = , gamboost = , blackboost = , ada = , randomForest = , pcaNNet = , svmradial = , svmpoly = , svmRadial = , svmPoly = , rvmRadial = , rvmPoly = , lssvmRadial = , lssvmPoly = , gaussprRadial = , gaussprPoly = , enet = , lasso = , LMT = , JRip = , lda = , rda = , pamr = , gpls = , J48 = , ppr = print(x$finalModel), 
             fda = {
               print(x$finalModel)
               cat("\n Summary of Terms\n\n")
               print(x$finalModel$fit)
             })
    }
  }
  invisible(printMat)
}, function (x, printCall = FALSE, details = FALSE, selectCol = FALSE, showSD = FALSE, ...) 
{
  if (!is.null(x$modelInfo$label)) 
    cat(x$modelInfo$label, "\n\n")
  if (printCall) 
    printCall(x$call)
  if (!is.null(x$trainingData)) {
    chDim <- dim(x$trainingData)
    chDim[2] <- chDim[2] - 1
    if (x$modelType == "Classification") {
      lev <- levels(x)
      if (is.character(lev)) 
        chDim <- c(chDim, length(lev))
    }
    else lev <- NULL
    chDim <- format(chDim)
    cat(chDim[1], " samples", sep = "")
    if (!is.null(x$control$indexFinal)) 
      cat(",", length(x$control$indexFinal), "used for final model\n")
    else cat("\n")
    cat(chDim[2], " predictor", ifelse(chDim[2] > 1, "s\n", "\n"), sep = "")
    if (is.character(lev)) {
      cat(chDim[3], "classes:", paste("'", lev, "'", sep = "", collapse = ", "), "\n")
    }
    cat("\n")
  }
  if (!is.null(x$preProc)) {
    pp_list(x$preProc$method)
  }
  else {
    if (inherits(x, "train.recipe")) {
      step_names <- function(x) gsub("^step_", "", class(x)[1])
      steps_used <- unlist(lapply(x$recipe$steps, step_names))
      ppText <- paste("Recipe steps:", paste(steps_used, collapse = ", "))
      cat(truncateText(ppText), "\n")
    }
    else cat("No pre-processing\n")
  }
  if (!is.null(x$control$index)) {
    resampleN <- unlist(lapply(x$control$index, length))
    numResamp <- length(resampleN)
    resampText <- resampName(x)
    cat("Resampling:", resampText, "\n")
    if (x$control$method != "none") {
      outLabel <- x$metric
      resampleN <- as.character(resampleN)
      if (numResamp > 5) 
        resampleN <- c(resampleN[1:6], "...")
      cat("Summary of sample sizes:", paste(resampleN, collapse = ", "), "\n")
    }
  }
  if (!is.null(x$control$sampling)) {
    cat("Addtional sampling using ")
    cat(switch(x$control$sampling$name, down = "down-sampling", up = "up-sampling", smote = "SMOTE", rose = "ROSE", custom = "a custom function"))
    if (!is.null(x$preProc)) {
      if (x$control$sampling$first) 
        cat(" prior to pre-processing")
      else cat(" after to pre-processing")
    }
    cat("\n\n")
  }
  if (x$control$method != "none") {
    tuneAcc <- x$results
    tuneAcc <- tuneAcc[, names(tuneAcc) != "parameter"]
    cat("Resampling results")
    if (dim(tuneAcc)[1] > 1) 
      cat(" across tuning parameters")
    if (showSD) 
      cat(" (values below are 'mean (sd)')")
    cat(":\n\n")
    if (dim(tuneAcc)[1] > 1) {
      numParam <- length(x$bestTune)
      finalTune <- x$bestTune
      optValues <- paste(names(finalTune), "=", format(finalTune, ...))
      optString <- paste0("The final ", ifelse(numParam > 1, "values", "value"), " used for the model ", ifelse(numParam > 1, "were ", "was "), stringFunc(optValues), ".")
      finalTune$Selected <- "*"
      if (any(names(tuneAcc) %in% "method")) 
        names(tuneAcc)[names(tuneAcc) %in% "method"] <- ".method"
      if (any(names(finalTune) %in% "method")) 
        names(finalTune)[names(finalTune) %in% "method"] <- ".method"
      tuneAcc <- merge(tuneAcc, finalTune, all.x = TRUE)
      if (any(names(tuneAcc) %in% ".method")) 
        names(tuneAcc)[names(tuneAcc) %in% ".method"] <- "method"
      tuneAcc$Selected[is.na(tuneAcc$Selected)] <- ""
    }
    else optString <- ""
    sdCols <- grep("SD$", colnames(tuneAcc))
    if (showSD) {
      sdCheck <- unlist(lapply(tuneAcc[, sdCols, drop = FALSE], function(u) all(is.na(u))))
      if (any(sdCheck)) {
        rmCols <- names(sdCheck)[sdCheck]
        tuneAcc <- tuneAcc[, !(names(tuneAcc) %in% rmCols)]
      }
    }
    else {
      if (length(sdCols) > 0) 
        tuneAcc <- tuneAcc[, -sdCols, drop = FALSE]
    }
    params <- names(x$bestTune)
    if (!all(params == "parameter")) {
      numVals <- apply(tuneAcc[, params, drop = FALSE], 2, function(x) length(unique(x)))
      if (any(numVals < 2)) {
        constString <- NULL
        for (i in seq(along = numVals)) {
          if (numVals[i] == 1) 
            constString <- c(constString, paste0("Tuning parameter '", names(numVals)[i], "' was held constant at a value of ", stringFunc(tuneAcc[1, names(numVals)[i]])))
        }
        discard <- names(numVals)[which(numVals == 1)]
        tuneAcc <- tuneAcc[, !(names(tuneAcc) %in% discard), drop = FALSE]
      }
      else constString <- NULL
    }
    else constString <- NULL
    tuneAcc <- tuneAcc[, !grepl("Apparent$|Optimism$", names(tuneAcc)), drop = FALSE]
    colnames(tuneAcc)[colnames(tuneAcc) == ".B"] <- "Resamples"
    nms <- names(tuneAcc)[names(tuneAcc) %in% params]
    sort_args <- vector(mode = "list", length = length(nms))
    for (i in seq(along = nms)) {
      sort_args[[i]] <- tuneAcc[, nms[i]]
    }
    tune_ord <- do.call("order", sort_args)
    if (!is.null(tune_ord)) 
      tuneAcc <- tuneAcc[tune_ord, , drop = FALSE]
    theDots <- list(...)
    theDots$x <- tuneAcc
    printMat <- do.call("format.data.frame", theDots)
    printMat <- as.matrix(printMat)
    rownames(printMat) <- rep("", dim(printMat)[1])
    if (showSD) {
      sdCols <- grep("SD$", colnames(printMat), value = TRUE)
      sd_dat <- printMat[, sdCols, drop = FALSE]
      printMat <- printMat[, !(colnames(printMat) %in% sdCols), drop = FALSE]
      for (col_name in sdCols) {
        not_sd <- gsub("SD$", "", col_name)
        if (any(colnames(printMat) == not_sd)) {
          printMat[, not_sd] <- paste0(printMat[, not_sd], " (", sd_dat[, col_name], ")")
        }
      }
    }
    if (!selectCol) 
      printMat <- printMat[, colnames(printMat) != "Selected", drop = FALSE]
    print(printMat, quote = FALSE, print.gap = 2)
    cat("\n")
    if (!is.null(constString)) {
      cat(truncateText(paste(constString, collapse = "\n")))
      cat("\n")
    }
    if (dim(tuneAcc)[1] > 1) {
      if (is.null(x$update)) {
        met <- paste(x$metric, "was used to select the optimal model using")
        if (is.function(x$control$selectionFunction)) {
          met <- paste(met, " a custom selection rule.\n")
        }
        else {
          met <- paste(met, switch(x$control$selectionFunction, best = paste("the", ifelse(x$maximize, "largest", "smallest"), "value.\n"), oneSE = " the one SE rule.\n", tolerance = " a tolerance rule.\n"))
        }
      }
      else {
        met <- paste("The tuning", ifelse(ncol(x$bestTune) > 1, "parameters", "parameter"), "was set manually.\n")
      }
      cat(truncateText(met))
    }
    cat(truncateText(optString))
    if (nzchar(optString)) 
      cat("\n")
  }
  else printMat <- NULL
  if (details) {
    if (!(x$method %in% c("gbm", "treebag", "nb", "lvq", "knn"))) {
      cat("\n----------------------------------------------------------\n")
      cat("\nThe final model:\n\n")
      switch(x$method, lm = , nnet = , multinom = , pls = , earth = , lmStepAIC = , bagEarth = , bagFDA = print(summary(x$finalModel)), rpart = , ctree = , ctree2 = , cforest = , glmboost = , gamboost = , blackboost = , ada = , randomForest = , pcaNNet = , svmradial = , svmpoly = , svmRadial = , svmPoly = , rvmRadial = , rvmPoly = , lssvmRadial = , lssvmPoly = , gaussprRadial = , gaussprPoly = , enet = , lasso = , LMT = , JRip = , lda = , rda = , pamr = , gpls = , J48 = , ppr = print(x$finalModel), 
             fda = {
               print(x$finalModel)
               cat("\n Summary of Terms\n\n")
               print(x$finalModel$fit)
             })
    }
  }
  invisible(printMat)
})
c("package:caret", "registered S3 method for print from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
probFunction
list(`package:caret` = function (method, modelFit, newdata = NULL, preProc = NULL, param = NULL) 
{
  if (!is.null(newdata) && !is.null(preProc)) 
    newdata <- predict(preProc, newdata)
  obsLevels <- levels(modelFit)
  classProb <- method$prob(modelFit = modelFit, newdata = newdata, submodels = param)
  if (!is.data.frame(classProb) & is.null(param)) {
    classProb <- as.data.frame(classProb, stringsAsFactors = TRUE)
    if (!is.null(obsLevels)) 
      classprob <- classProb[, obsLevels]
  }
  classProb
}, function (method, modelFit, newdata = NULL, preProc = NULL, param = NULL) 
{
  if (!is.null(newdata) && !is.null(preProc)) 
    newdata <- predict(preProc, newdata)
  obsLevels <- levels(modelFit)
  classProb <- method$prob(modelFit = modelFit, newdata = newdata, submodels = param)
  if (!is.data.frame(classProb) & is.null(param)) {
    classProb <- as.data.frame(classProb, stringsAsFactors = TRUE)
    if (!is.null(obsLevels)) 
      classprob <- classProb[, obsLevels]
  }
  classProb
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
progress
list(`package:caret` = function (x, names, iter, start = TRUE) 
{
  text <- paste(ifelse(start, "+ ", "- "), names[iter], ": ", paste(colnames(x), x, sep = "=", collapse = ", "), sep = "")
  cat(text, "\n")
}, function (x, names, iter, start = TRUE) 
{
  text <- paste(ifelse(start, "+ ", "- "), names[iter], ": ", paste(colnames(x), x, sep = "=", collapse = ", "), sep = "")
  cat(text, "\n")
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
prSummary
list(`package:caret` = function (data, lev = NULL, model = NULL) 
{
  requireNamespaceQuietStop("MLmetrics")
  if (length(levels(data$obs)) > 2) 
    stop(paste("Your outcome has", length(levels(data$obs)), "levels. `prSummary`` function isn't appropriate.", call. = FALSE))
  if (!all(levels(data[, "pred"]) == levels(data[, "obs"]))) 
    stop("Levels of observed and predicted data do not match.", call. = FALSE)
  pr_auc <- try(MLmetrics::PRAUC(y_pred = data[, lev[1]], y_true = ifelse(data$obs == lev[1], 1, 0)), silent = TRUE)
  if (inherits(pr_auc, "try-error")) 
    pr_auc <- NA
  c(AUC = pr_auc, Precision = precision.default(data = data$pred, reference = data$obs, relevant = lev[1]), Recall = recall.default(data = data$pred, reference = data$obs, relevant = lev[1]), F = F_meas.default(data = data$pred, reference = data$obs, relevant = lev[1]))
}, function (data, lev = NULL, model = NULL) 
{
  requireNamespaceQuietStop("MLmetrics")
  if (length(levels(data$obs)) > 2) 
    stop(paste("Your outcome has", length(levels(data$obs)), "levels. `prSummary`` function isn't appropriate.", call. = FALSE))
  if (!all(levels(data[, "pred"]) == levels(data[, "obs"]))) 
    stop("Levels of observed and predicted data do not match.", call. = FALSE)
  pr_auc <- try(MLmetrics::PRAUC(y_pred = data[, lev[1]], y_true = ifelse(data$obs == lev[1], 1, 0)), silent = TRUE)
  if (inherits(pr_auc, "try-error")) 
    pr_auc <- NA
  c(AUC = pr_auc, Precision = precision.default(data = data$pred, reference = data$obs, relevant = lev[1]), Recall = recall.default(data = data$pred, reference = data$obs, relevant = lev[1]), F = F_meas.default(data = data$pred, reference = data$obs, relevant = lev[1]))
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
R2
list(`package:caret` = function (pred, obs, formula = "corr", na.rm = FALSE) 
{
  n <- sum(complete.cases(pred))
  switch(formula, corr = cor(obs, pred, use = ifelse(na.rm, "complete.obs", "everything"))^2, traditional = 1 - (sum((obs - pred)^2, na.rm = na.rm)/((n - 1) * var(obs, na.rm = na.rm))))
}, function (pred, obs, formula = "corr", na.rm = FALSE) 
{
  n <- sum(complete.cases(pred))
  switch(formula, corr = cor(obs, pred, use = ifelse(na.rm, "complete.obs", "everything"))^2, traditional = 1 - (sum((obs - pred)^2, na.rm = na.rm)/((n - 1) * var(obs, na.rm = na.rm))))
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
recall
list(`package:caret` = function (data, ...) 
  UseMethod("recall"), function (actual, predicted, cutoff = 0.5) 
  {
    recall_(actual, predicted, cutoff)
  }, function (data, ...) 
    UseMethod("recall"))
c("package:caret", "namespace:ModelMetrics", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
resampleHist
list(`package:caret` = function (object, type = "density", ...) 
{
  if (object$control$method == "oob") 
    stop("out-of-bag error rate was selected. This plot cannot be created")
  if (is.null(object$resample)) 
    stop("No resample values were found. This plot cannot be created")
  resample <- object$resample
  tuneNames <- as.character(object$modelInfo$parameter$parameter)
  if (any(names(resample) %in% tuneNames)) {
    bestTune <- object$bestTune
    colnames(bestTune) <- gsub("^\\.", "", colnames(bestTune))
    resample <- merge(bestTune, resample)
    resample <- resample[, !(names(resample) %in% tuneNames), drop = FALSE]
  }
  results <- melt(resample, id.vars = "Resample")
  if (type == "density") {
    out <- densityplot(~value | variable, data = results, scales = list(relation = "free"), xlab = "", as.table = TRUE, ...)
  }
  else {
    out <- histogram(~value | variable, data = results, scales = list(relation = "free"), as.table = TRUE, xlab = "", ...)
  }
  out
}, function (object, type = "density", ...) 
{
  if (object$control$method == "oob") 
    stop("out-of-bag error rate was selected. This plot cannot be created")
  if (is.null(object$resample)) 
    stop("No resample values were found. This plot cannot be created")
  resample <- object$resample
  tuneNames <- as.character(object$modelInfo$parameter$parameter)
  if (any(names(resample) %in% tuneNames)) {
    bestTune <- object$bestTune
    colnames(bestTune) <- gsub("^\\.", "", colnames(bestTune))
    resample <- merge(bestTune, resample)
    resample <- resample[, !(names(resample) %in% tuneNames), drop = FALSE]
  }
  results <- melt(resample, id.vars = "Resample")
  if (type == "density") {
    out <- densityplot(~value | variable, data = results, scales = list(relation = "free"), xlab = "", as.table = TRUE, ...)
  }
  else {
    out <- histogram(~value | variable, data = results, scales = list(relation = "free"), as.table = TRUE, xlab = "", ...)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
resamples
list(`package:caret` = function (x, ...) 
  UseMethod("resamples"), function (x, ...) 
    UseMethod("resamples"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
resampleSummary
list(`package:caret` = function (obs, resampled, index = NULL, keepData = TRUE) 
{
  numPred <- apply(resampled, 2, function(u) sum(!is.na(u)))
  if (all(numPred >= 2)) {
    performanceStats <- apply(resampled, 2, postResample, obs = obs)
    out <- c(apply(performanceStats, 1, mean, na.rm = TRUE), apply(performanceStats, 1, sd, na.rm = TRUE))
    if (keepData) {
      if (is.factor(obs)) {
        outResample <- data.frame(obs = rep(obs, dim(resampled)[2]), pred = factor(unlist(lapply(resampled, as.character)), levels = levels(obs)), group = paste("Resample", rep(1:dim(resampled)[2], each = dim(resampled)[1], sep = "")))
      }
      else {
        outResample <- data.frame(obs = rep(obs, dim(resampled)[2]), pred = unlist(lapply(resampled, I)), group = paste("Resample", rep(1:dim(resampled)[2], each = dim(resampled)[1], sep = "")))
      }
    }
    else outResample <- NULL
  }
  else {
    pred <- apply(resampled, 2, function(u) u[!is.na(u)])
    if (is.factor(obs)) 
      pred <- factor(as.character(pred), levels = levels(obs))
    tmp <- postResample(pred, obs)
    tmp2 <- tmp * 0
    out <- c(tmp, tmp * 0)
    outResample <- data.frame(obs = obs, pred = pred, group = "Resample1")
  }
  if (keepData) 
    outResample <- outResample[!is.na(outResample$pred), ]
  list(metrics = out, data = outResample)
}, function (obs, resampled, index = NULL, keepData = TRUE) 
{
  numPred <- apply(resampled, 2, function(u) sum(!is.na(u)))
  if (all(numPred >= 2)) {
    performanceStats <- apply(resampled, 2, postResample, obs = obs)
    out <- c(apply(performanceStats, 1, mean, na.rm = TRUE), apply(performanceStats, 1, sd, na.rm = TRUE))
    if (keepData) {
      if (is.factor(obs)) {
        outResample <- data.frame(obs = rep(obs, dim(resampled)[2]), pred = factor(unlist(lapply(resampled, as.character)), levels = levels(obs)), group = paste("Resample", rep(1:dim(resampled)[2], each = dim(resampled)[1], sep = "")))
      }
      else {
        outResample <- data.frame(obs = rep(obs, dim(resampled)[2]), pred = unlist(lapply(resampled, I)), group = paste("Resample", rep(1:dim(resampled)[2], each = dim(resampled)[1], sep = "")))
      }
    }
    else outResample <- NULL
  }
  else {
    pred <- apply(resampled, 2, function(u) u[!is.na(u)])
    if (is.factor(obs)) 
      pred <- factor(as.character(pred), levels = levels(obs))
    tmp <- postResample(pred, obs)
    tmp2 <- tmp * 0
    out <- c(tmp, tmp * 0)
    outResample <- data.frame(obs = obs, pred = pred, group = "Resample1")
  }
  if (keepData) 
    outResample <- outResample[!is.na(outResample$pred), ]
  list(metrics = out, data = outResample)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
resampleWrapper
list(`package:caret` = function (x, ind) 
{
  out <- rep(NA, dim(x$data)[1])
  trainData <- x$data
  x$data <- x$data[ind, ]
  tmpModelFit <- do.call(createModel, x)
  outBagData <- trainData[-ind, ]
  outBagData$.outcome <- NULL
  out[-ind] <- if (is.factor(x$data$.outcome)) {
    as.character(predictionFunction(x$method, tmpModelFit, outBagData))
  }
  else {
    predictionFunction(x$method, tmpModelFit, outBagData)
  }
  out
}, function (x, ind) 
{
  out <- rep(NA, dim(x$data)[1])
  trainData <- x$data
  x$data <- x$data[ind, ]
  tmpModelFit <- do.call(createModel, x)
  outBagData <- trainData[-ind, ]
  outBagData$.outcome <- NULL
  out[-ind] <- if (is.factor(x$data$.outcome)) {
    as.character(predictionFunction(x$method, tmpModelFit, outBagData))
  }
  else {
    predictionFunction(x$method, tmpModelFit, outBagData)
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
rfe
list(`package:caret` = function (x, ...) 
  UseMethod("rfe"), function (x, ...) 
    UseMethod("rfe"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
rfeControl
list(`package:caret` = function (functions = NULL, rerank = FALSE, method = "boot", saveDetails = FALSE, number = ifelse(method %in% c("cv", "repeatedcv"), 10, 25), repeats = ifelse(method %in% c("cv", "repeatedcv"), 1, number), verbose = FALSE, returnResamp = "final", p = 0.75, index = NULL, indexOut = NULL, timingSamps = 0, seeds = NA, allowParallel = TRUE) 
{
  list(functions = if (is.null(functions)) caretFuncs else functions, rerank = rerank, method = method, saveDetails = saveDetails, number = number, repeats = repeats, returnResamp = returnResamp, verbose = verbose, p = p, index = index, indexOut = indexOut, timingSamps = timingSamps, seeds = seeds, allowParallel = allowParallel)
}, function (functions = NULL, rerank = FALSE, method = "boot", saveDetails = FALSE, number = ifelse(method %in% c("cv", "repeatedcv"), 10, 25), repeats = ifelse(method %in% c("cv", "repeatedcv"), 1, number), verbose = FALSE, returnResamp = "final", p = 0.75, index = NULL, indexOut = NULL, timingSamps = 0, seeds = NA, allowParallel = TRUE) 
{
  list(functions = if (is.null(functions)) caretFuncs else functions, rerank = rerank, method = method, saveDetails = saveDetails, number = number, repeats = repeats, returnResamp = returnResamp, verbose = verbose, p = p, index = index, indexOut = indexOut, timingSamps = timingSamps, seeds = seeds, allowParallel = allowParallel)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
rfeIter
list(`package:caret` = function (x, y, testX, testY, sizes, rfeControl = rfeControl(), label = "", seeds = NA, ...) 
{
  if (is.null(colnames(x))) 
    stop("x must have column names")
  if (is.null(testX) | is.null(testY)) 
    stop("a test set must be specified")
  if (is.null(sizes)) 
    stop("please specify the number of features")
  predictionMatrix <- matrix(NA, nrow = length(testY), ncol = length(sizes))
  p <- ncol(x)
  retained <- colnames(x)
  sizeValues <- sort(unique(c(sizes, ncol(x))), decreasing = TRUE)
  sizeText <- format(sizeValues)
  finalVariables <- vector(length(sizeValues), mode = "list")
  for (k in seq(along = sizeValues)) {
    if (!any(is.na(seeds))) 
      set.seed(seeds[k])
    if (rfeControl$verbose) {
      cat("+(rfe) fit", ifelse(label != "", label, ""), "size:", sizeText[k], "\n")
    }
    flush.console()
    fitObject <- rfeControl$functions$fit(x[, retained, drop = FALSE], y, first = p == ncol(x[, retained, drop = FALSE]), last = FALSE, ...)
    if (rfeControl$verbose) {
      cat("-(rfe) fit", ifelse(label != "", label, ""), "size:", sizeText[k], "\n")
    }
    modelPred <- rfeControl$functions$pred(fitObject, testX[, retained, drop = FALSE])
    if (is.data.frame(modelPred) | is.matrix(modelPred)) {
      if (is.matrix(modelPred)) {
        modelPred <- as.data.frame(modelPred, stringsAsFactors = TRUE)
        if (ncol(modelPred) == 1) 
          names(modelPred) <- "pred"
      }
      modelPred$obs <- testY
      modelPred$Variables <- sizeValues[k]
    }
    else modelPred <- data.frame(pred = modelPred, obs = testY, Variables = sizeValues[k])
    rfePred <- if (k == 1) 
      modelPred
    else rbind(rfePred, modelPred)
    if (!exists("modImp")) {
      if (rfeControl$verbose) {
        cat("+(rfe) imp", ifelse(label != "", label, ""), "\n")
      }
      modImp <- rfeControl$functions$rank(fitObject, x[, retained, drop = FALSE], y)
      if (rfeControl$verbose) {
        cat("-(rfe) imp", ifelse(label != "", label, ""), "\n")
      }
    }
    else {
      if (rfeControl$rerank) {
        if (rfeControl$verbose) {
          cat("+(rfe) imp", ifelse(label != "", label, ""), "size:", sizeText[k], "\n")
        }
        modImp <- rfeControl$functions$rank(fitObject, x[, retained, drop = FALSE], y)
        if (rfeControl$verbose) {
          cat("-(rfe) imp", ifelse(label != "", label, ""), "size:", sizeText[k], "\n")
        }
      }
    }
    if (nrow(modImp) < sizeValues[k]) {
      msg1 <- paste0("rfe is expecting ", sizeValues[k], " importance values but only has ", nrow(modImp), ". ", "This may be caused by having zero-variance predictors, ", "excessively-correlated predictors, factor predictors ", "that were expanded into dummy variables or you may have ", "failed to drop one of your dummy variables.")
      warning(msg1, call. = FALSE)
      modImp <- repair_rank(modImp, colnames(x))
    }
    if (any(!complete.cases(modImp))) {
      warning(paste("There were missing importance values.", "There may be linear dependencies in your predictor variables"), call. = FALSE)
    }
    if (!any(names(modImp) == "var")) {
      stop("The importance score data should include a column named `var`.")
    }
    finalVariables[[k]] <- subset(modImp, var %in% retained)
    finalVariables[[k]]$Variables <- sizeValues[[k]]
    if (k < length(sizeValues)) 
      retained <- as.character(modImp$var)[1:sizeValues[k + 1]]
  }
  list(finalVariables = finalVariables, pred = rfePred)
}, function (x, y, testX, testY, sizes, rfeControl = rfeControl(), label = "", seeds = NA, ...) 
{
  if (is.null(colnames(x))) 
    stop("x must have column names")
  if (is.null(testX) | is.null(testY)) 
    stop("a test set must be specified")
  if (is.null(sizes)) 
    stop("please specify the number of features")
  predictionMatrix <- matrix(NA, nrow = length(testY), ncol = length(sizes))
  p <- ncol(x)
  retained <- colnames(x)
  sizeValues <- sort(unique(c(sizes, ncol(x))), decreasing = TRUE)
  sizeText <- format(sizeValues)
  finalVariables <- vector(length(sizeValues), mode = "list")
  for (k in seq(along = sizeValues)) {
    if (!any(is.na(seeds))) 
      set.seed(seeds[k])
    if (rfeControl$verbose) {
      cat("+(rfe) fit", ifelse(label != "", label, ""), "size:", sizeText[k], "\n")
    }
    flush.console()
    fitObject <- rfeControl$functions$fit(x[, retained, drop = FALSE], y, first = p == ncol(x[, retained, drop = FALSE]), last = FALSE, ...)
    if (rfeControl$verbose) {
      cat("-(rfe) fit", ifelse(label != "", label, ""), "size:", sizeText[k], "\n")
    }
    modelPred <- rfeControl$functions$pred(fitObject, testX[, retained, drop = FALSE])
    if (is.data.frame(modelPred) | is.matrix(modelPred)) {
      if (is.matrix(modelPred)) {
        modelPred <- as.data.frame(modelPred, stringsAsFactors = TRUE)
        if (ncol(modelPred) == 1) 
          names(modelPred) <- "pred"
      }
      modelPred$obs <- testY
      modelPred$Variables <- sizeValues[k]
    }
    else modelPred <- data.frame(pred = modelPred, obs = testY, Variables = sizeValues[k])
    rfePred <- if (k == 1) 
      modelPred
    else rbind(rfePred, modelPred)
    if (!exists("modImp")) {
      if (rfeControl$verbose) {
        cat("+(rfe) imp", ifelse(label != "", label, ""), "\n")
      }
      modImp <- rfeControl$functions$rank(fitObject, x[, retained, drop = FALSE], y)
      if (rfeControl$verbose) {
        cat("-(rfe) imp", ifelse(label != "", label, ""), "\n")
      }
    }
    else {
      if (rfeControl$rerank) {
        if (rfeControl$verbose) {
          cat("+(rfe) imp", ifelse(label != "", label, ""), "size:", sizeText[k], "\n")
        }
        modImp <- rfeControl$functions$rank(fitObject, x[, retained, drop = FALSE], y)
        if (rfeControl$verbose) {
          cat("-(rfe) imp", ifelse(label != "", label, ""), "size:", sizeText[k], "\n")
        }
      }
    }
    if (nrow(modImp) < sizeValues[k]) {
      msg1 <- paste0("rfe is expecting ", sizeValues[k], " importance values but only has ", nrow(modImp), ". ", "This may be caused by having zero-variance predictors, ", "excessively-correlated predictors, factor predictors ", "that were expanded into dummy variables or you may have ", "failed to drop one of your dummy variables.")
      warning(msg1, call. = FALSE)
      modImp <- repair_rank(modImp, colnames(x))
    }
    if (any(!complete.cases(modImp))) {
      warning(paste("There were missing importance values.", "There may be linear dependencies in your predictor variables"), call. = FALSE)
    }
    if (!any(names(modImp) == "var")) {
      stop("The importance score data should include a column named `var`.")
    }
    finalVariables[[k]] <- subset(modImp, var %in% retained)
    finalVariables[[k]]$Variables <- sizeValues[[k]]
    if (k < length(sizeValues)) 
      retained <- as.character(modImp$var)[1:sizeValues[k + 1]]
  }
  list(finalVariables = finalVariables, pred = rfePred)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
rfFuncs
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loadNamespace("randomForest")
  randomForest::randomForest(x, y, importance = TRUE, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  if (is.factor(object$y)) {
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
  }
  else out <- tmp
  out
}, rank = function (object, x, y) 
{
  vimp <- varImp(object)
  if (is.factor(y)) {
    if (all(levels(y) %in% colnames(vimp))) {
      avImp <- apply(vimp[, levels(y), drop = TRUE], 1, mean)
      vimp$Overall <- avImp
    }
  }
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  if (ncol(x) == 1) {
    vimp$var <- colnames(x)
  }
  else vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}), list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loadNamespace("randomForest")
  randomForest::randomForest(x, y, importance = TRUE, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  if (is.factor(object$y)) {
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
  }
  else out <- tmp
  out
}, rank = function (object, x, y) 
{
  vimp <- varImp(object)
  if (is.factor(y)) {
    if (all(levels(y) %in% colnames(vimp))) {
      avImp <- apply(vimp[, levels(y), drop = TRUE], 1, mean)
      vimp$Overall <- avImp
    }
  }
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  if (ncol(x) == 1) {
    vimp$var <- colnames(x)
  }
  else vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
rfGA
list(`package:caret` = list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
{
  loadNamespace("randomForest")
  randomForest::randomForest(x, y, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  if (is.factor(object$y)) {
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
  }
  else out <- tmp
  out
}, fitness_intern = function (object, x, y, maximize, p) 
  rfStats(object), fitness_extern = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, initial = function (vars, popSize, ...) 
  {
    x <- matrix(NA, nrow = popSize, ncol = vars)
    probs <- seq(0.9, 0.1, length = popSize)
    for (i in 1:popSize) {
      x[i, ] <- sample(0:1, replace = TRUE, size = vars, prob = c(probs[i], 1 - probs[i]))
    }
    var_count <- apply(x, 1, sum)
    if (any(var_count == 0)) {
      for (i in which(var_count == 0)) {
        x[i, ] <- sample(0:1, replace = TRUE, size = vars)
      }
    }
    x
  }, selection = function (population, fitness, r = NULL, q = NULL, ...) 
  {
    popSize = nrow(population)
    if (is.null(r)) 
      r <- 2/(popSize * (popSize - 1))
    if (is.null(q)) 
      q <- 2/popSize
    rank <- (popSize + 1) - rank(fitness, ties.method = "random")
    prob <- q - (rank - 1) * r
    sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
    out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
    out
  }, crossover = function (population, fitness, parents, ...) 
  {
    fitness <- fitness[parents]
    parents <- population[parents, , drop = FALSE]
    n <- ncol(parents)
    children <- matrix(as.double(NA), nrow = 2, ncol = n)
    fitnessChildren <- rep(NA, 2)
    crossOverPoint <- sample(0:n, size = 1)
    if (crossOverPoint == 0) {
      children[1:2, ] <- parents[2:1, ]
      fitnessChildren[1:2] <- fitness[2:1]
    }
    else if (crossOverPoint == n) {
      children <- parents
      fitnessChildren <- fitness
    }
    else {
      children[1, ] <- c(parents[1, 1:crossOverPoint], parents[2, (crossOverPoint + 1):n])
      children[2, ] <- c(parents[2, 1:crossOverPoint], parents[1, (crossOverPoint + 1):n])
    }
    out <- list(children = children, fitness = fitnessChildren)
    out
  }, mutation = function (population, parent, ...) 
  {
    mutate <- parent <- as.vector(population[parent, ])
    n <- length(parent)
    j <- sample(1:n, size = 1)
    mutate[j] <- abs(mutate[j] - 1)
    mutate
  }, selectIter = function (x, metric, maximize) 
  {
    bestIter <- if (maximize) 
      which.max(x[, metric])
    else which.min(x[, metric])
    bestIter
  }), list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
  {
    loadNamespace("randomForest")
    randomForest::randomForest(x, y, ...)
  }, pred = function (object, x) 
  {
    tmp <- predict(object, x)
    if (is.factor(object$y)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
    out
  }, fitness_intern = function (object, x, y, maximize, p) 
    rfStats(object), fitness_extern = function (data, lev = NULL, model = NULL) 
    {
      if (is.character(data$obs)) 
        data$obs <- factor(data$obs, levels = lev)
      postResample(data[, "pred"], data[, "obs"])
    }, initial = function (vars, popSize, ...) 
    {
      x <- matrix(NA, nrow = popSize, ncol = vars)
      probs <- seq(0.9, 0.1, length = popSize)
      for (i in 1:popSize) {
        x[i, ] <- sample(0:1, replace = TRUE, size = vars, prob = c(probs[i], 1 - probs[i]))
      }
      var_count <- apply(x, 1, sum)
      if (any(var_count == 0)) {
        for (i in which(var_count == 0)) {
          x[i, ] <- sample(0:1, replace = TRUE, size = vars)
        }
      }
      x
    }, selection = function (population, fitness, r = NULL, q = NULL, ...) 
    {
      popSize = nrow(population)
      if (is.null(r)) 
        r <- 2/(popSize * (popSize - 1))
      if (is.null(q)) 
        q <- 2/popSize
      rank <- (popSize + 1) - rank(fitness, ties.method = "random")
      prob <- q - (rank - 1) * r
      sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
      out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
      out
    }, crossover = function (population, fitness, parents, ...) 
    {
      fitness <- fitness[parents]
      parents <- population[parents, , drop = FALSE]
      n <- ncol(parents)
      children <- matrix(as.double(NA), nrow = 2, ncol = n)
      fitnessChildren <- rep(NA, 2)
      crossOverPoint <- sample(0:n, size = 1)
      if (crossOverPoint == 0) {
        children[1:2, ] <- parents[2:1, ]
        fitnessChildren[1:2] <- fitness[2:1]
      }
      else if (crossOverPoint == n) {
        children <- parents
        fitnessChildren <- fitness
      }
      else {
        children[1, ] <- c(parents[1, 1:crossOverPoint], parents[2, (crossOverPoint + 1):n])
        children[2, ] <- c(parents[2, 1:crossOverPoint], parents[1, (crossOverPoint + 1):n])
      }
      out <- list(children = children, fitness = fitnessChildren)
      out
    }, mutation = function (population, parent, ...) 
    {
      mutate <- parent <- as.vector(population[parent, ])
      n <- length(parent)
      j <- sample(1:n, size = 1)
      mutate[j] <- abs(mutate[j] - 1)
      mutate
    }, selectIter = function (x, metric, maximize) 
    {
      bestIter <- if (maximize) 
        which.max(x[, metric])
      else which.min(x[, metric])
      bestIter
    }))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
rfSA
list(`package:caret` = list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
{
  loadNamespace("randomForest")
  randomForest::randomForest(x, y, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  if (is.factor(object$y)) {
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
  }
  else out <- tmp
  out
}, fitness_intern = function (object, x, y, maximize, p) 
  rfStats(object), fitness_extern = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, initial = function (vars, prob = 0.2, ...) 
  {
    sort(sample.int(vars, size = floor(vars * prob) + 1))
  }, perturb = function (x, vars, number = floor(length(x) * 0.01) + 1) 
  {
    bin <- index2vec(x, vars)
    change <- sample(seq(along = bin), size = number)
    bin[change] <- ifelse(bin[change] == 1, 0, 1)
    sort(which(bin == 1))
  }, prob = function (old, new, iteration = 1) 
  {
    if (new < old) 
      return(1)
    ediff <- as.vector(old - new)
    ediff <- ediff/abs(old)
    exp(ediff * iteration)
  }, selectIter = function (x, metric, maximize) 
  {
    bestIter <- if (maximize) 
      which.max(x[, metric])
    else which.min(x[, metric])
    bestIter
  }), list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
  {
    loadNamespace("randomForest")
    randomForest::randomForest(x, y, ...)
  }, pred = function (object, x) 
  {
    tmp <- predict(object, x)
    if (is.factor(object$y)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
    out
  }, fitness_intern = function (object, x, y, maximize, p) 
    rfStats(object), fitness_extern = function (data, lev = NULL, model = NULL) 
    {
      if (is.character(data$obs)) 
        data$obs <- factor(data$obs, levels = lev)
      postResample(data[, "pred"], data[, "obs"])
    }, initial = function (vars, prob = 0.2, ...) 
    {
      sort(sample.int(vars, size = floor(vars * prob) + 1))
    }, perturb = function (x, vars, number = floor(length(x) * 0.01) + 1) 
    {
      bin <- index2vec(x, vars)
      change <- sample(seq(along = bin), size = number)
      bin[change] <- ifelse(bin[change] == 1, 0, 1)
      sort(which(bin == 1))
    }, prob = function (old, new, iteration = 1) 
    {
      if (new < old) 
        return(1)
      ediff <- as.vector(old - new)
      ediff <- ediff/abs(old)
      exp(ediff * iteration)
    }, selectIter = function (x, metric, maximize) 
    {
      bestIter <- if (maximize) 
        which.max(x[, metric])
      else which.min(x[, metric])
      bestIter
    }))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
rfSBF
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, ...) 
{
  if (ncol(x) > 0) {
    loadNamespace("randomForest")
    randomForest::randomForest(x, y, ...)
  }
  else nullModel(y = y)
}, pred = function (object, x) 
{
  if (inherits(object, "nullModel")) {
    tmp <- predict(object, x)
    if (!is.null(object$levels)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
  }
  else {
    tmp <- predict(object, x)
    if (is.factor(object$y)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
  }
  out
}, score = function (x, y) 
{
  if (is.factor(y)) 
    anovaScores(x, y)
  else gamScores(x, y)
}, filter = function (score, x, y) 
  score <= 0.05), list(summary = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, fit = function (x, y, ...) 
  {
    if (ncol(x) > 0) {
      loadNamespace("randomForest")
      randomForest::randomForest(x, y, ...)
    }
    else nullModel(y = y)
  }, pred = function (object, x) 
  {
    if (inherits(object, "nullModel")) {
      tmp <- predict(object, x)
      if (!is.null(object$levels)) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
      }
      else out <- tmp
    }
    else {
      tmp <- predict(object, x)
      if (is.factor(object$y)) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
      }
      else out <- tmp
    }
    out
  }, score = function (x, y) 
  {
    if (is.factor(y)) 
      anovaScores(x, y)
    else gamScores(x, y)
  }, filter = function (score, x, y) 
    score <= 0.05))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
rfStats
list(`package:caret` = function (x) 
  getModelInfo("rf", regex = FALSE)[[1]]$oob(x), function (x) 
    getModelInfo("rf", regex = FALSE)[[1]]$oob(x))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
RMSE
list(`package:caret` = function (pred, obs, na.rm = FALSE) 
  sqrt(mean((pred - obs)^2, na.rm = na.rm)), function (pred, obs, na.rm = FALSE) 
    sqrt(mean((pred - obs)^2, na.rm = na.rm)))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
safs
list(`package:caret` = function (x, ...) 
  UseMethod("safs"), function (x, ...) 
    UseMethod("safs"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
safs_initial
list(`package:caret` = function (vars, prob = 0.2, ...) 
{
  sort(sample.int(vars, size = floor(vars * prob) + 1))
}, function (vars, prob = 0.2, ...) 
{
  sort(sample.int(vars, size = floor(vars * prob) + 1))
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
safs_perturb
list(`package:caret` = function (x, vars, number = floor(length(x) * 0.01) + 1) 
{
  bin <- index2vec(x, vars)
  change <- sample(seq(along = bin), size = number)
  bin[change] <- ifelse(bin[change] == 1, 0, 1)
  sort(which(bin == 1))
}, function (x, vars, number = floor(length(x) * 0.01) + 1) 
{
  bin <- index2vec(x, vars)
  change <- sample(seq(along = bin), size = number)
  bin[change] <- ifelse(bin[change] == 1, 0, 1)
  sort(which(bin == 1))
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
safs_prob
list(`package:caret` = function (old, new, iteration = 1) 
{
  if (new < old) 
    return(1)
  ediff <- as.vector(old - new)
  ediff <- ediff/abs(old)
  exp(ediff * iteration)
}, function (old, new, iteration = 1) 
{
  if (new < old) 
    return(1)
  ediff <- as.vector(old - new)
  ediff <- ediff/abs(old)
  exp(ediff * iteration)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
safsControl
list(`package:caret` = function (functions = NULL, method = "repeatedcv", metric = NULL, maximize = NULL, number = ifelse(grepl("cv", method), 10, 25), repeats = ifelse(grepl("cv", method), 1, 5), verbose = FALSE, returnResamp = "final", p = 0.75, index = NULL, indexOut = NULL, seeds = NULL, holdout = 0, improve = Inf, allowParallel = TRUE) 
{
  if (!(method %in% c("cv", "boot", "repeatedcv", "LGOCV", "LOOCV"))) 
    stop("method should be one of: \"cv\", \"boot\", \"repeatedcv\", \"LGOCV\" or \"LOOCV\"")
  if (holdout < 0 | holdout >= 1) 
    stop("'holdout' should be in [0, 1)")
  if (improve < 2) 
    stop("'improve' should be >= 2")
  if (!is.null(metric)) {
    if (length(metric) != 2) 
      stop("'metric' should be a two-element named vector. See ?safsControl")
    if (is.null(names(metric)) || any(sort(names(metric)) != c("external", "internal"))) 
      stop("'metric' should have names 'internal' and 'external' See ?safsControl")
  }
  if (!is.null(maximize)) {
    if (length(maximize) != 2) 
      stop("'maximize' should be a two-element named vector. See ?safsControl")
    if (is.null(names(maximize)) || any(sort(names(maximize)) != c("external", "internal"))) 
      stop("'maximize' should have names 'internal' and 'external' See ?safsControl")
  }
  list(functions = if (is.null(functions)) caretFuncs else functions, method = method, metric = metric, maximize = maximize, number = number, repeats = repeats, returnResamp = returnResamp, verbose = verbose, p = p, index = index, indexOut = indexOut, seeds = seeds, holdout = holdout, improve = improve, allowParallel = allowParallel)
}, function (functions = NULL, method = "repeatedcv", metric = NULL, maximize = NULL, number = ifelse(grepl("cv", method), 10, 25), repeats = ifelse(grepl("cv", method), 1, 5), verbose = FALSE, returnResamp = "final", p = 0.75, index = NULL, indexOut = NULL, seeds = NULL, holdout = 0, improve = Inf, allowParallel = TRUE) 
{
  if (!(method %in% c("cv", "boot", "repeatedcv", "LGOCV", "LOOCV"))) 
    stop("method should be one of: \"cv\", \"boot\", \"repeatedcv\", \"LGOCV\" or \"LOOCV\"")
  if (holdout < 0 | holdout >= 1) 
    stop("'holdout' should be in [0, 1)")
  if (improve < 2) 
    stop("'improve' should be >= 2")
  if (!is.null(metric)) {
    if (length(metric) != 2) 
      stop("'metric' should be a two-element named vector. See ?safsControl")
    if (is.null(names(metric)) || any(sort(names(metric)) != c("external", "internal"))) 
      stop("'metric' should have names 'internal' and 'external' See ?safsControl")
  }
  if (!is.null(maximize)) {
    if (length(maximize) != 2) 
      stop("'maximize' should be a two-element named vector. See ?safsControl")
    if (is.null(names(maximize)) || any(sort(names(maximize)) != c("external", "internal"))) 
      stop("'maximize' should have names 'internal' and 'external' See ?safsControl")
  }
  list(functions = if (is.null(functions)) caretFuncs else functions, method = method, metric = metric, maximize = maximize, number = number, repeats = repeats, returnResamp = returnResamp, verbose = verbose, p = p, index = index, indexOut = indexOut, seeds = seeds, holdout = holdout, improve = improve, allowParallel = allowParallel)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
sbf
list(`package:caret` = function (x, ...) 
  UseMethod("sbf"), function (x, ...) 
    UseMethod("sbf"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
sbfControl
list(`package:caret` = function (functions = NULL, method = "boot", saveDetails = FALSE, number = ifelse(method %in% c("cv", "repeatedcv"), 10, 25), repeats = ifelse(method %in% c("cv", "repeatedcv"), 1, number), verbose = FALSE, returnResamp = "final", p = 0.75, index = NULL, indexOut = NULL, timingSamps = 0, seeds = NA, allowParallel = TRUE, multivariate = FALSE) 
{
  list(functions = if (is.null(functions)) caretSBF else functions, method = method, saveDetails = saveDetails, number = number, repeats = repeats, returnResamp = returnResamp, verbose = verbose, p = p, index = index, indexOut = indexOut, timingSamps = timingSamps, seeds = seeds, allowParallel = allowParallel, multivariate = multivariate)
}, function (functions = NULL, method = "boot", saveDetails = FALSE, number = ifelse(method %in% c("cv", "repeatedcv"), 10, 25), repeats = ifelse(method %in% c("cv", "repeatedcv"), 1, number), verbose = FALSE, returnResamp = "final", p = 0.75, index = NULL, indexOut = NULL, timingSamps = 0, seeds = NA, allowParallel = TRUE, multivariate = FALSE) 
{
  list(functions = if (is.null(functions)) caretSBF else functions, method = method, saveDetails = saveDetails, number = number, repeats = repeats, returnResamp = returnResamp, verbose = verbose, p = p, index = index, indexOut = indexOut, timingSamps = timingSamps, seeds = seeds, allowParallel = allowParallel, multivariate = multivariate)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
sbfIter
list(`package:caret` = function (x, y, testX, testY, testPerf = NULL, sbfControl = sbfControl(), ...) 
{
  if (is.null(colnames(x))) 
    stop("x must have column names")
  if (is.null(testX) | is.null(testY)) 
    stop("a test set must be specified")
  if (sbfControl$multivariate) {
    scores <- sbfControl$functions$score(x, y)
    if (length(scores) != ncol(x)) 
      stop(paste("when control$multivariate == TRUE, 'scores'", "should return a vector with", ncol(x), "numeric values"))
  }
  else {
    scores <- vapply(x, sbfControl$functions$score, double(1), y = y)
  }
  retained <- sbfControl$functions$filter(scores, x, y)
  testX <- testX[, which(retained), drop = FALSE]
  fitObject <- sbfControl$functions$fit(x = x[, which(retained), drop = FALSE], y = y, ...)
  modelPred <- sbfControl$functions$pred(fitObject, testX)
  if (is.data.frame(modelPred) | is.matrix(modelPred)) {
    if (is.matrix(modelPred)) 
      modelPred <- as.data.frame(modelPred, stringsAsFactors = TRUE)
    modelPred$obs <- testY
  }
  else modelPred <- data.frame(pred = modelPred, obs = testY)
  if (!is.null(testPerf)) 
    modelPred <- cbind(modelPred, testPerf)
  list(variables = names(retained)[which(retained)], pred = modelPred)
}, function (x, y, testX, testY, testPerf = NULL, sbfControl = sbfControl(), ...) 
{
  if (is.null(colnames(x))) 
    stop("x must have column names")
  if (is.null(testX) | is.null(testY)) 
    stop("a test set must be specified")
  if (sbfControl$multivariate) {
    scores <- sbfControl$functions$score(x, y)
    if (length(scores) != ncol(x)) 
      stop(paste("when control$multivariate == TRUE, 'scores'", "should return a vector with", ncol(x), "numeric values"))
  }
  else {
    scores <- vapply(x, sbfControl$functions$score, double(1), y = y)
  }
  retained <- sbfControl$functions$filter(scores, x, y)
  testX <- testX[, which(retained), drop = FALSE]
  fitObject <- sbfControl$functions$fit(x = x[, which(retained), drop = FALSE], y = y, ...)
  modelPred <- sbfControl$functions$pred(fitObject, testX)
  if (is.data.frame(modelPred) | is.matrix(modelPred)) {
    if (is.matrix(modelPred)) 
      modelPred <- as.data.frame(modelPred, stringsAsFactors = TRUE)
    modelPred$obs <- testY
  }
  else modelPred <- data.frame(pred = modelPred, obs = testY)
  if (!is.null(testPerf)) 
    modelPred <- cbind(modelPred, testPerf)
  list(variables = names(retained)[which(retained)], pred = modelPred)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
sensitivity
list(`package:caret` = function (data, ...) 
{
  UseMethod("sensitivity")
}, function (actual, predicted, cutoff = 0.5) 
{
  recall_(actual, predicted, cutoff)
}, function (data, ...) 
{
  UseMethod("sensitivity")
})
c("package:caret", "namespace:ModelMetrics", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
SLC14_1
list(`package:caret` = function (n = 100, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0) 
{
  dat <- matrix(rnorm(n * 20, sd = 3), ncol = 20)
  foo <- function(x) x[1] + sin(x[2]) + log(abs(x[3])) + x[4]^2 + x[5] * x[6] + ifelse(x[7] * x[8] * x[9] < 0, 1, 0) + ifelse(x[10] > 0, 1, 0) + x[11] * ifelse(x[11] > 0, 1, 0) + sqrt(abs(x[12])) + cos(x[13]) + 2 * x[14] + abs(x[15]) + ifelse(x[16] < -1, 1, 0) + x[17] * ifelse(x[17] < -1, 1, 0) - 2 * x[18] - x[19] * x[20]
  dat <- as.data.frame(dat, stringsAsFactors = TRUE)
  colnames(dat) <- well_numbered("Var", ncol(dat))
  if (noiseVars > 0 | corrVars > 0) 
    dat <- cbind(dat, make_noise(n = n, noiseVars = noiseVars, corrVars = corrVars, corrType = corrType, corrValue = corrValue))
  dat$y <- apply(dat[, 1:20], 1, foo) + rnorm(n, sd = 3)
  dat
}, function (n = 100, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0) 
{
  dat <- matrix(rnorm(n * 20, sd = 3), ncol = 20)
  foo <- function(x) x[1] + sin(x[2]) + log(abs(x[3])) + x[4]^2 + x[5] * x[6] + ifelse(x[7] * x[8] * x[9] < 0, 1, 0) + ifelse(x[10] > 0, 1, 0) + x[11] * ifelse(x[11] > 0, 1, 0) + sqrt(abs(x[12])) + cos(x[13]) + 2 * x[14] + abs(x[15]) + ifelse(x[16] < -1, 1, 0) + x[17] * ifelse(x[17] < -1, 1, 0) - 2 * x[18] - x[19] * x[20]
  dat <- as.data.frame(dat, stringsAsFactors = TRUE)
  colnames(dat) <- well_numbered("Var", ncol(dat))
  if (noiseVars > 0 | corrVars > 0) 
    dat <- cbind(dat, make_noise(n = n, noiseVars = noiseVars, corrVars = corrVars, corrType = corrType, corrValue = corrValue))
  dat$y <- apply(dat[, 1:20], 1, foo) + rnorm(n, sd = 3)
  dat
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
SLC14_2
list(`package:caret` = function (n = 100, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0) 
{
  dat <- matrix(rnorm(n * 200, sd = 4), ncol = 200)
  dat <- as.data.frame(dat, stringsAsFactors = TRUE)
  colnames(dat) <- well_numbered("Var", ncol(dat))
  if (noiseVars > 0 | corrVars > 0) 
    dat <- cbind(dat, make_noise(n = n, noiseVars = noiseVars, corrVars = corrVars, corrType = corrType, corrValue = corrValue))
  dat$y <- apply(dat[, 1:200], 1, function(x) sum(log(abs(x)))) + rnorm(n, sd = 5) - 1
  dat
}, function (n = 100, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0) 
{
  dat <- matrix(rnorm(n * 200, sd = 4), ncol = 200)
  dat <- as.data.frame(dat, stringsAsFactors = TRUE)
  colnames(dat) <- well_numbered("Var", ncol(dat))
  if (noiseVars > 0 | corrVars > 0) 
    dat <- cbind(dat, make_noise(n = n, noiseVars = noiseVars, corrVars = corrVars, corrType = corrType, corrValue = corrValue))
  dat$y <- apply(dat[, 1:200], 1, function(x) sum(log(abs(x)))) + rnorm(n, sd = 5) - 1
  dat
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
sortImp
list(`package:caret` = function (object, top) 
{
  if (object$calledFrom == "varImp") {
    best <- switch(object$model, pam = "maxabs", "max")
  }
  else {
    best <- "max"
  }
  featureRank <- switch(best, max = rank(-apply(object$importance, 1, max, na.rm = TRUE)), min = rank(apply(object$importance, 1, min, na.rm = TRUE)), maxabs = rank(-apply(abs(object$importance), 1, max, na.rm = TRUE)))
  tiedRanks <- as.numeric(names(table(featureRank)[table(featureRank) > 1]))
  if (length(tiedRanks) > 0) {
    for (i in seq(along = tiedRanks)) {
      tmp <- featureRank[featureRank == tiedRanks[i]]
      featureRank[featureRank == tiedRanks[i]] <- tmp + runif(length(tmp), min = 0.001, max = 0.999)
    }
  }
  featureOrder <- order(featureRank)
  out <- object$importance[featureOrder, , drop = FALSE]
  out <- out[1:top, , drop = FALSE]
  out
}, function (object, top) 
{
  if (object$calledFrom == "varImp") {
    best <- switch(object$model, pam = "maxabs", "max")
  }
  else {
    best <- "max"
  }
  featureRank <- switch(best, max = rank(-apply(object$importance, 1, max, na.rm = TRUE)), min = rank(apply(object$importance, 1, min, na.rm = TRUE)), maxabs = rank(-apply(abs(object$importance), 1, max, na.rm = TRUE)))
  tiedRanks <- as.numeric(names(table(featureRank)[table(featureRank) > 1]))
  if (length(tiedRanks) > 0) {
    for (i in seq(along = tiedRanks)) {
      tmp <- featureRank[featureRank == tiedRanks[i]]
      featureRank[featureRank == tiedRanks[i]] <- tmp + runif(length(tmp), min = 0.001, max = 0.999)
    }
  }
  featureOrder <- order(featureRank)
  out <- object$importance[featureOrder, , drop = FALSE]
  out <- out[1:top, , drop = FALSE]
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
spatialSign
list(`package:caret` = function (x, ...) 
  UseMethod("spatialSign"), function (x, ...) 
    UseMethod("spatialSign"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
specificity
list(`package:caret` = function (data, ...) 
{
  UseMethod("specificity")
}, function (actual, predicted, cutoff = 0.5) 
{
  tnr_(actual, predicted, cutoff)
}, function (data, ...) 
{
  UseMethod("specificity")
})
c("package:caret", "namespace:ModelMetrics", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
splsda
list(`package:caret` = function (x, ...) 
  UseMethod("splsda"), function (x, ...) 
    UseMethod("splsda"))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
sumDiss
list(`package:caret` = function (u) 
  sum(u, na.rm = TRUE), function (u) 
    sum(u, na.rm = TRUE))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
summary.bagEarth
list(`package:caret` = function (object, ...) 
{
  requireNamespaceQuietStop("earth")
  oobStat <- apply(object$oob, 2, function(x) quantile(x, probs = c(0, 0.025, 0.25, 0.5, 0.75, 0.975, 1)))
  numTerms <- unlist(lapply(object$fit, function(x) length(x$selected.terms)))
  numVar <- unlist(lapply(object$fit, function(x) {
    imp <- rownames(earth::evimp(x, trim = FALSE))
    imp <- imp[!grepl("-unused", imp)]
    length(imp)
  }))
  modelInfo <- cbind(numTerms, numVar)
  colnames(modelInfo) <- c("Num Terms", "Num Variables")
  out <- list(modelInfo = modelInfo, oobStat = oobStat, bagEarthCall = object$call)
  class(out) <- "summary.bagEarth"
  out
}, function (object, ...) 
{
  requireNamespaceQuietStop("earth")
  oobStat <- apply(object$oob, 2, function(x) quantile(x, probs = c(0, 0.025, 0.25, 0.5, 0.75, 0.975, 1)))
  numTerms <- unlist(lapply(object$fit, function(x) length(x$selected.terms)))
  numVar <- unlist(lapply(object$fit, function(x) {
    imp <- rownames(earth::evimp(x, trim = FALSE))
    imp <- imp[!grepl("-unused", imp)]
    length(imp)
  }))
  modelInfo <- cbind(numTerms, numVar)
  colnames(modelInfo) <- c("Num Terms", "Num Variables")
  out <- list(modelInfo = modelInfo, oobStat = oobStat, bagEarthCall = object$call)
  class(out) <- "summary.bagEarth"
  out
}, function (object, ...) 
{
  requireNamespaceQuietStop("earth")
  oobStat <- apply(object$oob, 2, function(x) quantile(x, probs = c(0, 0.025, 0.25, 0.5, 0.75, 0.975, 1)))
  numTerms <- unlist(lapply(object$fit, function(x) length(x$selected.terms)))
  numVar <- unlist(lapply(object$fit, function(x) {
    imp <- rownames(earth::evimp(x, trim = FALSE))
    imp <- imp[!grepl("-unused", imp)]
    length(imp)
  }))
  modelInfo <- cbind(numTerms, numVar)
  colnames(modelInfo) <- c("Num Terms", "Num Variables")
  out <- list(modelInfo = modelInfo, oobStat = oobStat, bagEarthCall = object$call)
  class(out) <- "summary.bagEarth"
  out
})
c("package:caret", "registered S3 method for summary from namespace caret", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
svmBag
list(`package:caret` = list(fit = function (x, y, ...) 
{
  loadNamespace("kernlab")
  out <- kernlab::ksvm(as.matrix(x), y, prob.model = is.factor(y), ...)
  out
}, pred = function (object, x) 
{
  if (is.character(lev(object))) {
    out <- predict(object, as.matrix(x), type = "probabilities")
    colnames(out) <- lev(object)
    rownames(out) <- NULL
  }
  else out <- predict(object, as.matrix(x))[, 1]
  out
}, aggregate = function (x, type = "class") 
{
  if (is.matrix(x[[1]]) | is.data.frame(x[[1]])) {
    pooled <- x[[1]] & NA
    classes <- colnames(pooled)
    for (i in 1:ncol(pooled)) {
      tmp <- lapply(x, function(y, col) y[, col], col = i)
      tmp <- do.call("rbind", tmp)
      pooled[, i] <- apply(tmp, 2, median)
    }
    if (type == "class") {
      out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
    }
    else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  }
  else {
    x <- matrix(unlist(x), ncol = length(x))
    out <- apply(x, 1, median)
  }
  out
}), list(fit = function (x, y, ...) 
{
  loadNamespace("kernlab")
  out <- kernlab::ksvm(as.matrix(x), y, prob.model = is.factor(y), ...)
  out
}, pred = function (object, x) 
{
  if (is.character(lev(object))) {
    out <- predict(object, as.matrix(x), type = "probabilities")
    colnames(out) <- lev(object)
    rownames(out) <- NULL
  }
  else out <- predict(object, as.matrix(x))[, 1]
  out
}, aggregate = function (x, type = "class") 
{
  if (is.matrix(x[[1]]) | is.data.frame(x[[1]])) {
    pooled <- x[[1]] & NA
    classes <- colnames(pooled)
    for (i in 1:ncol(pooled)) {
      tmp <- lapply(x, function(y, col) y[, col], col = i)
      tmp <- do.call("rbind", tmp)
      pooled[, i] <- apply(tmp, 2, median)
    }
    if (type == "class") {
      out <- factor(classes[apply(pooled, 1, which.max)], levels = classes)
    }
    else out <- as.data.frame(pooled, stringsAsFactors = TRUE)
  }
  else {
    x <- matrix(unlist(x), ncol = length(x))
    out <- apply(x, 1, median)
  }
  out
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
thresholder
list(`package:caret` = function (x, threshold, final = TRUE, statistics = "all") 
{
  if (!inherits(x, "train")) 
    stop("`x` should be an object of class 'train'", call. = FALSE)
  if (!x$control$classProbs) 
    stop("`classProbs` must be TRUE in `trainControl`", call. = FALSE)
  if (is.null(threshold)) 
    stop("Please supply probability threshold values.", call. = FALSE)
  if (any(threshold > 1 | threshold < 0)) 
    stop("`threshold` should be on [0,1]", call. = FALSE)
  if (is.logical(x$control$savePredictions)) {
    if (!x$control$savePredictions) 
      stop("`savePredictions` should be TRUE, 'all', or 'final'")
  }
  else {
    if (x$control$savePredictions == "none") 
      stop("`savePredictions` should be TRUE, 'all', or 'final'")
  }
  if (length(levels(x$pred$obs)) > 2) 
    stop("For two class problems only", call. = TRUE)
  stat_names <- c("Sensitivity", "Specificity", "Pos Pred Value", "Neg Pred Value", "Precision", "Recall", "F1", "Prevalence", "Detection Rate", "Detection Prevalence", "Balanced Accuracy", "Accuracy", "Kappa", "J", "Dist")
  if (!any(statistics %in% c("all", stat_names)) || ("all" %in% statistics && length(statistics) > 1)) 
    stop("`statistics` should be either 'all', or one or more of '", paste0(stat_names, collapse = "', '"), "'.")
  if (length(statistics) == 1 && statistics == "all") 
    statistics <- stat_names
  disc <- c("pred", "rowIndex", x$levels[-1])
  pred_dat <- expand_preds(if (final) 
    merge(x$pred, x$bestTune)
    else x$pred, threshold, disc)
  param <- c("Resample", names(x$bestTune), "prob_threshold")
  pred_dat <- ddply(pred_dat, .variables = param, recode)
  pred_stats <- ddply(pred_dat, .variables = param, stats)
  pred_resamp <- ddply(pred_stats, .variables = param[-1], summ_stats, statistics)
  pred_resamp
}, function (x, threshold, final = TRUE, statistics = "all") 
{
  if (!inherits(x, "train")) 
    stop("`x` should be an object of class 'train'", call. = FALSE)
  if (!x$control$classProbs) 
    stop("`classProbs` must be TRUE in `trainControl`", call. = FALSE)
  if (is.null(threshold)) 
    stop("Please supply probability threshold values.", call. = FALSE)
  if (any(threshold > 1 | threshold < 0)) 
    stop("`threshold` should be on [0,1]", call. = FALSE)
  if (is.logical(x$control$savePredictions)) {
    if (!x$control$savePredictions) 
      stop("`savePredictions` should be TRUE, 'all', or 'final'")
  }
  else {
    if (x$control$savePredictions == "none") 
      stop("`savePredictions` should be TRUE, 'all', or 'final'")
  }
  if (length(levels(x$pred$obs)) > 2) 
    stop("For two class problems only", call. = TRUE)
  stat_names <- c("Sensitivity", "Specificity", "Pos Pred Value", "Neg Pred Value", "Precision", "Recall", "F1", "Prevalence", "Detection Rate", "Detection Prevalence", "Balanced Accuracy", "Accuracy", "Kappa", "J", "Dist")
  if (!any(statistics %in% c("all", stat_names)) || ("all" %in% statistics && length(statistics) > 1)) 
    stop("`statistics` should be either 'all', or one or more of '", paste0(stat_names, collapse = "', '"), "'.")
  if (length(statistics) == 1 && statistics == "all") 
    statistics <- stat_names
  disc <- c("pred", "rowIndex", x$levels[-1])
  pred_dat <- expand_preds(if (final) 
    merge(x$pred, x$bestTune)
    else x$pred, threshold, disc)
  param <- c("Resample", names(x$bestTune), "prob_threshold")
  pred_dat <- ddply(pred_dat, .variables = param, recode)
  pred_stats <- ddply(pred_dat, .variables = param, stats)
  pred_resamp <- ddply(pred_stats, .variables = param[-1], summ_stats, statistics)
  pred_resamp
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
tolerance
list(`package:caret` = function (x, metric, tol = 1.5, maximize) 
{
  index <- 1:nrow(x)
  if (!maximize) {
    best <- min(x[, metric])
    perf <- (x[, metric] - best)/best * 100
    candidates <- index[perf < tol]
    bestIter <- min(candidates)
  }
  else {
    best <- max(x[, metric])
    perf <- (x[, metric] - best)/best * -100
    candidates <- index[perf < tol]
    bestIter <- min(candidates)
  }
  bestIter
}, 1.49011611938477e-08, function (x, metric, tol = 1.5, maximize) 
{
  index <- 1:nrow(x)
  if (!maximize) {
    best <- min(x[, metric])
    perf <- (x[, metric] - best)/best * 100
    candidates <- index[perf < tol]
    bestIter <- min(candidates)
  }
  else {
    best <- max(x[, metric])
    perf <- (x[, metric] - best)/best * -100
    candidates <- index[perf < tol]
    bestIter <- min(candidates)
  }
  bestIter
})
c("package:caret", "namespace:vctrs", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
train
list(`package:caret` = function (x, ...) 
{
  UseMethod("train")
}, function (x, ...) 
{
  UseMethod("train")
}, function (x, ...) 
{
  UseMethod("train")
})
c("package:caret", "namespace:generics", "namespace:caret")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
trainControl
list(`package:caret` = function (method = "boot", number = ifelse(grepl("cv", method), 10, 25), repeats = ifelse(grepl("[d_]cv$", method), 1, NA), p = 0.75, search = "grid", initialWindow = NULL, horizon = 1, fixedWindow = TRUE, skip = 0, verboseIter = FALSE, returnData = TRUE, returnResamp = "final", savePredictions = FALSE, classProbs = FALSE, summaryFunction = defaultSummary, selectionFunction = "best", preProcOptions = list(thresh = 0.95, ICAcomp = 3, k = 5, freqCut = 95/5, uniqueCut = 10, cutoff = 0.9), 
                                 sampling = NULL, index = NULL, indexOut = NULL, indexFinal = NULL, timingSamps = 0, predictionBounds = rep(FALSE, 2), seeds = NA, adaptive = list(min = 5, alpha = 0.05, method = "gls", complete = TRUE), trim = FALSE, allowParallel = TRUE) 
{
  if (is.null(selectionFunction)) 
    stop("null selectionFunction values not allowed")
  if (!(returnResamp %in% c("all", "final", "none"))) 
    stop("incorrect value of returnResamp")
  if (length(predictionBounds) > 0 && length(predictionBounds) != 2) 
    stop("'predictionBounds' should be a logical or numeric vector of length 2")
  if (any(names(preProcOptions) == "method")) 
    stop("'method' cannot be specified here")
  if (any(names(preProcOptions) == "x")) 
    stop("'x' cannot be specified here")
  if (!is.na(repeats) & !(method %in% c("repeatedcv", "adaptive_cv"))) 
    warning("`repeats` has no meaning for this resampling method.", call. = FALSE)
  if (!(adaptive$method %in% c("gls", "BT"))) 
    stop("incorrect value of adaptive$method")
  if (adaptive$alpha < 1e-07 | adaptive$alpha > 1) 
    stop("incorrect value of adaptive$alpha")
  if (grepl("adapt", method)) {
    num <- if (method == "adaptive_cv") 
      number * repeats
    else number
    if (adaptive$min >= num) 
      stop(paste("adaptive$min should be less than", num))
    if (adaptive$min <= 1) 
      stop("adaptive$min should be greater than 1")
  }
  if (!(search %in% c("grid", "random"))) 
    stop("`search` should be either 'grid' or 'random'")
  if (method == "oob" & any(names(match.call()) == "summaryFunction")) {
    warning("Custom summary measures cannot be computed for out-of-bag resampling. ", "This value of `summaryFunction` will be ignored.", call. = FALSE)
  }
  list(method = method, number = number, repeats = repeats, search = search, p = p, initialWindow = initialWindow, horizon = horizon, fixedWindow = fixedWindow, skip = skip, verboseIter = verboseIter, returnData = returnData, returnResamp = returnResamp, savePredictions = savePredictions, classProbs = classProbs, summaryFunction = summaryFunction, selectionFunction = selectionFunction, preProcOptions = preProcOptions, sampling = sampling, index = index, indexOut = indexOut, indexFinal = indexFinal, 
       timingSamps = timingSamps, predictionBounds = predictionBounds, seeds = seeds, adaptive = adaptive, trim = trim, allowParallel = allowParallel)
}, function (method = "boot", number = ifelse(grepl("cv", method), 10, 25), repeats = ifelse(grepl("[d_]cv$", method), 1, NA), p = 0.75, search = "grid", initialWindow = NULL, horizon = 1, fixedWindow = TRUE, skip = 0, verboseIter = FALSE, returnData = TRUE, returnResamp = "final", savePredictions = FALSE, classProbs = FALSE, summaryFunction = defaultSummary, selectionFunction = "best", preProcOptions = list(thresh = 0.95, ICAcomp = 3, k = 5, freqCut = 95/5, uniqueCut = 10, cutoff = 0.9), sampling = NULL, 
             index = NULL, indexOut = NULL, indexFinal = NULL, timingSamps = 0, predictionBounds = rep(FALSE, 2), seeds = NA, adaptive = list(min = 5, alpha = 0.05, method = "gls", complete = TRUE), trim = FALSE, allowParallel = TRUE) 
{
  if (is.null(selectionFunction)) 
    stop("null selectionFunction values not allowed")
  if (!(returnResamp %in% c("all", "final", "none"))) 
    stop("incorrect value of returnResamp")
  if (length(predictionBounds) > 0 && length(predictionBounds) != 2) 
    stop("'predictionBounds' should be a logical or numeric vector of length 2")
  if (any(names(preProcOptions) == "method")) 
    stop("'method' cannot be specified here")
  if (any(names(preProcOptions) == "x")) 
    stop("'x' cannot be specified here")
  if (!is.na(repeats) & !(method %in% c("repeatedcv", "adaptive_cv"))) 
    warning("`repeats` has no meaning for this resampling method.", call. = FALSE)
  if (!(adaptive$method %in% c("gls", "BT"))) 
    stop("incorrect value of adaptive$method")
  if (adaptive$alpha < 1e-07 | adaptive$alpha > 1) 
    stop("incorrect value of adaptive$alpha")
  if (grepl("adapt", method)) {
    num <- if (method == "adaptive_cv") 
      number * repeats
    else number
    if (adaptive$min >= num) 
      stop(paste("adaptive$min should be less than", num))
    if (adaptive$min <= 1) 
      stop("adaptive$min should be greater than 1")
  }
  if (!(search %in% c("grid", "random"))) 
    stop("`search` should be either 'grid' or 'random'")
  if (method == "oob" & any(names(match.call()) == "summaryFunction")) {
    warning("Custom summary measures cannot be computed for out-of-bag resampling. ", "This value of `summaryFunction` will be ignored.", call. = FALSE)
  }
  list(method = method, number = number, repeats = repeats, search = search, p = p, initialWindow = initialWindow, horizon = horizon, fixedWindow = fixedWindow, skip = skip, verboseIter = verboseIter, returnData = returnData, returnResamp = returnResamp, savePredictions = savePredictions, classProbs = classProbs, summaryFunction = summaryFunction, selectionFunction = selectionFunction, preProcOptions = preProcOptions, sampling = sampling, index = index, indexOut = indexOut, indexFinal = indexFinal, 
       timingSamps = timingSamps, predictionBounds = predictionBounds, seeds = seeds, adaptive = adaptive, trim = trim, allowParallel = allowParallel)
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
treebagFuncs
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loadNamespace("ipred")
  ipred::ipredbagg(y, x, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  if (is.factor(object$y)) {
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE), stringsAsFactors = TRUE)
  }
  else out <- tmp
  out
}, rank = function (object, x, y) 
{
  vimp <- varImp(object)
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}), list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, first, last, ...) 
{
  loadNamespace("ipred")
  ipred::ipredbagg(y, x, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  if (is.factor(object$y)) {
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE), stringsAsFactors = TRUE)
  }
  else out <- tmp
  out
}, rank = function (object, x, y) 
{
  vimp <- varImp(object)
  vimp <- vimp[order(vimp$Overall, decreasing = TRUE), , drop = FALSE]
  vimp$var <- rownames(vimp)
  vimp
}, selectSize = function (x, metric, maximize) 
{
  best <- if (maximize) 
    which.max(x[, metric])
  else which.min(x[, metric])
  min(x[best, "Variables"])
}, selectVar = function (y, size) 
{
  finalImp <- ddply(y[, c("Overall", "var")], .(var), function(x) mean(x$Overall, na.rm = TRUE))
  names(finalImp)[2] <- "Overall"
  finalImp <- finalImp[order(finalImp$Overall, decreasing = TRUE), ]
  as.character(finalImp$var[1:size])
}))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
treebagGA
list(`package:caret` = list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
{
  loadNamespace("ipred")
  ipred::ipredbagg(y, x, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  if (is.factor(object$y)) {
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
  }
  else out <- tmp
  out
}, fitness_intern = function (object, x, y, maximize, p) 
  ipredStats(object)[1:2], fitness_extern = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, initial = function (vars, popSize, ...) 
  {
    x <- matrix(NA, nrow = popSize, ncol = vars)
    probs <- seq(0.9, 0.1, length = popSize)
    for (i in 1:popSize) {
      x[i, ] <- sample(0:1, replace = TRUE, size = vars, prob = c(probs[i], 1 - probs[i]))
    }
    var_count <- apply(x, 1, sum)
    if (any(var_count == 0)) {
      for (i in which(var_count == 0)) {
        x[i, ] <- sample(0:1, replace = TRUE, size = vars)
      }
    }
    x
  }, selection = function (population, fitness, r = NULL, q = NULL, ...) 
  {
    popSize = nrow(population)
    if (is.null(r)) 
      r <- 2/(popSize * (popSize - 1))
    if (is.null(q)) 
      q <- 2/popSize
    rank <- (popSize + 1) - rank(fitness, ties.method = "random")
    prob <- q - (rank - 1) * r
    sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
    out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
    out
  }, crossover = function (population, fitness, parents, ...) 
  {
    fitness <- fitness[parents]
    parents <- population[parents, , drop = FALSE]
    n <- ncol(parents)
    children <- matrix(as.double(NA), nrow = 2, ncol = n)
    fitnessChildren <- rep(NA, 2)
    crossOverPoint <- sample(0:n, size = 1)
    if (crossOverPoint == 0) {
      children[1:2, ] <- parents[2:1, ]
      fitnessChildren[1:2] <- fitness[2:1]
    }
    else if (crossOverPoint == n) {
      children <- parents
      fitnessChildren <- fitness
    }
    else {
      children[1, ] <- c(parents[1, 1:crossOverPoint], parents[2, (crossOverPoint + 1):n])
      children[2, ] <- c(parents[2, 1:crossOverPoint], parents[1, (crossOverPoint + 1):n])
    }
    out <- list(children = children, fitness = fitnessChildren)
    out
  }, mutation = function (population, parent, ...) 
  {
    mutate <- parent <- as.vector(population[parent, ])
    n <- length(parent)
    j <- sample(1:n, size = 1)
    mutate[j] <- abs(mutate[j] - 1)
    mutate
  }, selectIter = function (x, metric, maximize) 
  {
    bestIter <- if (maximize) 
      which.max(x[, metric])
    else which.min(x[, metric])
    bestIter
  }), list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
  {
    loadNamespace("ipred")
    ipred::ipredbagg(y, x, ...)
  }, pred = function (object, x) 
  {
    tmp <- predict(object, x)
    if (is.factor(object$y)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
    out
  }, fitness_intern = function (object, x, y, maximize, p) 
    ipredStats(object)[1:2], fitness_extern = function (data, lev = NULL, model = NULL) 
    {
      if (is.character(data$obs)) 
        data$obs <- factor(data$obs, levels = lev)
      postResample(data[, "pred"], data[, "obs"])
    }, initial = function (vars, popSize, ...) 
    {
      x <- matrix(NA, nrow = popSize, ncol = vars)
      probs <- seq(0.9, 0.1, length = popSize)
      for (i in 1:popSize) {
        x[i, ] <- sample(0:1, replace = TRUE, size = vars, prob = c(probs[i], 1 - probs[i]))
      }
      var_count <- apply(x, 1, sum)
      if (any(var_count == 0)) {
        for (i in which(var_count == 0)) {
          x[i, ] <- sample(0:1, replace = TRUE, size = vars)
        }
      }
      x
    }, selection = function (population, fitness, r = NULL, q = NULL, ...) 
    {
      popSize = nrow(population)
      if (is.null(r)) 
        r <- 2/(popSize * (popSize - 1))
      if (is.null(q)) 
        q <- 2/popSize
      rank <- (popSize + 1) - rank(fitness, ties.method = "random")
      prob <- q - (rank - 1) * r
      sel <- sample(1:popSize, size = popSize, prob = pmin(pmax(0, prob), 1, na.rm = TRUE), replace = TRUE)
      out <- list(population = population[sel, , drop = FALSE], fitness = fitness[sel])
      out
    }, crossover = function (population, fitness, parents, ...) 
    {
      fitness <- fitness[parents]
      parents <- population[parents, , drop = FALSE]
      n <- ncol(parents)
      children <- matrix(as.double(NA), nrow = 2, ncol = n)
      fitnessChildren <- rep(NA, 2)
      crossOverPoint <- sample(0:n, size = 1)
      if (crossOverPoint == 0) {
        children[1:2, ] <- parents[2:1, ]
        fitnessChildren[1:2] <- fitness[2:1]
      }
      else if (crossOverPoint == n) {
        children <- parents
        fitnessChildren <- fitness
      }
      else {
        children[1, ] <- c(parents[1, 1:crossOverPoint], parents[2, (crossOverPoint + 1):n])
        children[2, ] <- c(parents[2, 1:crossOverPoint], parents[1, (crossOverPoint + 1):n])
      }
      out <- list(children = children, fitness = fitnessChildren)
      out
    }, mutation = function (population, parent, ...) 
    {
      mutate <- parent <- as.vector(population[parent, ])
      n <- length(parent)
      j <- sample(1:n, size = 1)
      mutate[j] <- abs(mutate[j] - 1)
      mutate
    }, selectIter = function (x, metric, maximize) 
    {
      bestIter <- if (maximize) 
        which.max(x[, metric])
      else which.min(x[, metric])
      bestIter
    }))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
treebagSA
list(`package:caret` = list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
{
  loadNamespace("ipred")
  ipred::ipredbagg(y, x, ...)
}, pred = function (object, x) 
{
  tmp <- predict(object, x)
  if (is.factor(object$y)) {
    out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
  }
  else out <- tmp
  out
}, fitness_intern = function (object, x, y, maximize, p) 
  ipredStats(object)[1:2], fitness_extern = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, initial = function (vars, prob = 0.2, ...) 
  {
    sort(sample.int(vars, size = floor(vars * prob) + 1))
  }, perturb = function (x, vars, number = floor(length(x) * 0.01) + 1) 
  {
    bin <- index2vec(x, vars)
    change <- sample(seq(along = bin), size = number)
    bin[change] <- ifelse(bin[change] == 1, 0, 1)
    sort(which(bin == 1))
  }, prob = function (old, new, iteration = 1) 
  {
    if (new < old) 
      return(1)
    ediff <- as.vector(old - new)
    ediff <- ediff/abs(old)
    exp(ediff * iteration)
  }, selectIter = function (x, metric, maximize) 
  {
    bestIter <- if (maximize) 
      which.max(x[, metric])
    else which.min(x[, metric])
    bestIter
  }), list(fit = function (x, y, lev = NULL, last = FALSE, ...) 
  {
    loadNamespace("ipred")
    ipred::ipredbagg(y, x, ...)
  }, pred = function (object, x) 
  {
    tmp <- predict(object, x)
    if (is.factor(object$y)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
    out
  }, fitness_intern = function (object, x, y, maximize, p) 
    ipredStats(object)[1:2], fitness_extern = function (data, lev = NULL, model = NULL) 
    {
      if (is.character(data$obs)) 
        data$obs <- factor(data$obs, levels = lev)
      postResample(data[, "pred"], data[, "obs"])
    }, initial = function (vars, prob = 0.2, ...) 
    {
      sort(sample.int(vars, size = floor(vars * prob) + 1))
    }, perturb = function (x, vars, number = floor(length(x) * 0.01) + 1) 
    {
      bin <- index2vec(x, vars)
      change <- sample(seq(along = bin), size = number)
      bin[change] <- ifelse(bin[change] == 1, 0, 1)
      sort(which(bin == 1))
    }, prob = function (old, new, iteration = 1) 
    {
      if (new < old) 
        return(1)
      ediff <- as.vector(old - new)
      ediff <- ediff/abs(old)
      exp(ediff * iteration)
    }, selectIter = function (x, metric, maximize) 
    {
      bestIter <- if (maximize) 
        which.max(x[, metric])
      else which.min(x[, metric])
      bestIter
    }))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
treebagSBF
list(`package:caret` = list(summary = function (data, lev = NULL, model = NULL) 
{
  if (is.character(data$obs)) 
    data$obs <- factor(data$obs, levels = lev)
  postResample(data[, "pred"], data[, "obs"])
}, fit = function (x, y, ...) 
{
  if (ncol(x) > 0) {
    loadNamespace("ipred")
    ipred::ipredbagg(y, x, ...)
  }
  else nullModel(y = y)
}, pred = function (object, x) 
{
  if (inherits(object, "nullModel")) {
    tmp <- predict(object, x)
    if (!is.null(object$levels)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
  }
  else {
    tmp <- predict(object, x)
    if (is.factor(object$y)) {
      out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
    }
    else out <- tmp
  }
  out
}, score = function (x, y) 
{
  anovaScores(x, y)
}, filter = function (score, x, y) 
  score <= 0.05), list(summary = function (data, lev = NULL, model = NULL) 
  {
    if (is.character(data$obs)) 
      data$obs <- factor(data$obs, levels = lev)
    postResample(data[, "pred"], data[, "obs"])
  }, fit = function (x, y, ...) 
  {
    if (ncol(x) > 0) {
      loadNamespace("ipred")
      ipred::ipredbagg(y, x, ...)
    }
    else nullModel(y = y)
  }, pred = function (object, x) 
  {
    if (inherits(object, "nullModel")) {
      tmp <- predict(object, x)
      if (!is.null(object$levels)) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
      }
      else out <- tmp
    }
    else {
      tmp <- predict(object, x)
      if (is.factor(object$y)) {
        out <- cbind(data.frame(pred = tmp), as.data.frame(predict(object, x, type = "prob"), stringsAsFactors = TRUE))
      }
      else out <- tmp
    }
    out
  }, score = function (x, y) 
  {
    anovaScores(x, y)
  }, filter = function (score, x, y) 
    score <= 0.05))
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
twoClassSim
list(`package:caret` = function (n = 100, intercept = -5, linearVars = 10, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0, mislabel = 0, ordinal = FALSE) 
{
  requireNamespaceQuietStop("MASS")
  sigma <- matrix(c(2, 1.3, 1.3, 2), 2, 2)
  tmpData <- data.frame(MASS::mvrnorm(n = n, c(0, 0), sigma))
  names(tmpData) <- paste("TwoFactor", 1:2, sep = "")
  if (linearVars > 0) {
    tmpData <- cbind(tmpData, matrix(rnorm(n * linearVars), ncol = linearVars))
    colnames(tmpData)[(1:linearVars) + 2] <- paste("Linear", gsub(" ", "0", format(1:linearVars)), sep = "")
  }
  tmpData$Nonlinear1 <- runif(n, min = -1)
  tmpData <- cbind(tmpData, matrix(runif(n * 2), ncol = 2))
  colnames(tmpData)[(ncol(tmpData) - 1):ncol(tmpData)] <- paste("Nonlinear", 2:3, sep = "")
  tmpData <- as.data.frame(tmpData, stringsAsFactors = FALSE)
  p <- ncol(tmpData)
  if (noiseVars > 0) {
    tmpData <- cbind(tmpData, matrix(rnorm(n * noiseVars), ncol = noiseVars))
    colnames(tmpData)[(p + 1):ncol(tmpData)] <- paste("Noise", gsub(" ", "0", format(1:noiseVars)), sep = "")
  }
  if (corrVars > 0) {
    p <- ncol(tmpData)
    loadNamespace("MASS")
    if (corrType == "exch") {
      vc <- matrix(corrValue, ncol = corrVars, nrow = corrVars)
      diag(vc) <- 1
    }
    if (corrType == "AR1") {
      vcValues <- corrValue^(seq(0, corrVars - 1, by = 1))
      vc <- toeplitz(vcValues)
    }
    tmpData <- cbind(tmpData, MASS::mvrnorm(n, mu = rep(0, corrVars), Sigma = vc))
    colnames(tmpData)[(p + 1):ncol(tmpData)] <- paste("Corr", gsub(" ", "0", format(1:corrVars)), sep = "")
  }
  lp <- intercept - 4 * tmpData$TwoFactor1 + 4 * tmpData$TwoFactor2 + 2 * tmpData$TwoFactor1 * tmpData$TwoFactor2 + (tmpData$Nonlinear1^3) + 2 * exp(-6 * (tmpData$Nonlinear1 - 0.3)^2) + 2 * sin(pi * tmpData$Nonlinear2 * tmpData$Nonlinear3)
  if (linearVars > 0) {
    lin <- seq(10, 1, length = linearVars)/4
    lin <- lin * rep(c(-1, 1), floor(linearVars) + 1)[1:linearVars]
    for (i in seq(along = lin)) lp <- lp + tmpData[, i + 3] * lin[i]
  }
  if (ordinal) {
    prob <- binomial()$linkinv(lp + rnorm(n, sd = 2))
    tmpData$Class <- cut(prob, breaks = c(0, 0.2, 0.75, 1), include.lowest = TRUE, labels = c("low", "med", "high"), ordered_result = TRUE)
  }
  else {
    prob <- binomial()$linkinv(lp)
    if (mislabel > 0 & mislabel < 1) {
      shuffle <- sample(1:nrow(tmpData), floor(nrow(tmpData) * mislabel))
      prob[shuffle] <- 1 - prob[shuffle]
    }
    tmpData$Class <- ifelse(prob <= runif(n), "Class1", "Class2")
    tmpData$Class <- factor(tmpData$Class, levels = c("Class1", "Class2"))
  }
  tmpData
}, function (n = 100, intercept = -5, linearVars = 10, noiseVars = 0, corrVars = 0, corrType = "AR1", corrValue = 0, mislabel = 0, ordinal = FALSE) 
{
  requireNamespaceQuietStop("MASS")
  sigma <- matrix(c(2, 1.3, 1.3, 2), 2, 2)
  tmpData <- data.frame(MASS::mvrnorm(n = n, c(0, 0), sigma))
  names(tmpData) <- paste("TwoFactor", 1:2, sep = "")
  if (linearVars > 0) {
    tmpData <- cbind(tmpData, matrix(rnorm(n * linearVars), ncol = linearVars))
    colnames(tmpData)[(1:linearVars) + 2] <- paste("Linear", gsub(" ", "0", format(1:linearVars)), sep = "")
  }
  tmpData$Nonlinear1 <- runif(n, min = -1)
  tmpData <- cbind(tmpData, matrix(runif(n * 2), ncol = 2))
  colnames(tmpData)[(ncol(tmpData) - 1):ncol(tmpData)] <- paste("Nonlinear", 2:3, sep = "")
  tmpData <- as.data.frame(tmpData, stringsAsFactors = FALSE)
  p <- ncol(tmpData)
  if (noiseVars > 0) {
    tmpData <- cbind(tmpData, matrix(rnorm(n * noiseVars), ncol = noiseVars))
    colnames(tmpData)[(p + 1):ncol(tmpData)] <- paste("Noise", gsub(" ", "0", format(1:noiseVars)), sep = "")
  }
  if (corrVars > 0) {
    p <- ncol(tmpData)
    loadNamespace("MASS")
    if (corrType == "exch") {
      vc <- matrix(corrValue, ncol = corrVars, nrow = corrVars)
      diag(vc) <- 1
    }
    if (corrType == "AR1") {
      vcValues <- corrValue^(seq(0, corrVars - 1, by = 1))
      vc <- toeplitz(vcValues)
    }
    tmpData <- cbind(tmpData, MASS::mvrnorm(n, mu = rep(0, corrVars), Sigma = vc))
    colnames(tmpData)[(p + 1):ncol(tmpData)] <- paste("Corr", gsub(" ", "0", format(1:corrVars)), sep = "")
  }
  lp <- intercept - 4 * tmpData$TwoFactor1 + 4 * tmpData$TwoFactor2 + 2 * tmpData$TwoFactor1 * tmpData$TwoFactor2 + (tmpData$Nonlinear1^3) + 2 * exp(-6 * (tmpData$Nonlinear1 - 0.3)^2) + 2 * sin(pi * tmpData$Nonlinear2 * tmpData$Nonlinear3)
  if (linearVars > 0) {
    lin <- seq(10, 1, length = linearVars)/4
    lin <- lin * rep(c(-1, 1), floor(linearVars) + 1)[1:linearVars]
    for (i in seq(along = lin)) lp <- lp + tmpData[, i + 3] * lin[i]
  }
  if (ordinal) {
    prob <- binomial()$linkinv(lp + rnorm(n, sd = 2))
    tmpData$Class <- cut(prob, breaks = c(0, 0.2, 0.75, 1), include.lowest = TRUE, labels = c("low", "med", "high"), ordered_result = TRUE)
  }
  else {
    prob <- binomial()$linkinv(lp)
    if (mislabel > 0 & mislabel < 1) {
      shuffle <- sample(1:nrow(tmpData), floor(nrow(tmpData) * mislabel))
      prob[shuffle] <- 1 - prob[shuffle]
    }
    tmpData$Class <- ifelse(prob <= runif(n), "Class1", "Class2")
    tmpData$Class <- factor(tmpData$Class, levels = c("Class1", "Class2"))
  }
  tmpData
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
twoClassSummary
list(`package:caret` = function (data, lev = NULL, model = NULL) 
{
  if (length(lev) > 2) {
    stop(paste("Your outcome has", length(lev), "levels. The twoClassSummary() function isn't appropriate."))
  }
  requireNamespaceQuietStop("pROC")
  if (!all(levels(data[, "pred"]) == lev)) {
    stop("levels of observed and predicted data do not match")
  }
  rocObject <- try(pROC::roc(data$obs, data[, lev[1]], direction = ">", quiet = TRUE), silent = TRUE)
  rocAUC <- if (inherits(rocObject, "try-error")) 
    NA
  else rocObject$auc
  out <- c(rocAUC, sensitivity(data[, "pred"], data[, "obs"], lev[1]), specificity(data[, "pred"], data[, "obs"], lev[2]))
  names(out) <- c("ROC", "Sens", "Spec")
  out
}, function (data, lev = NULL, model = NULL) 
{
  if (length(lev) > 2) {
    stop(paste("Your outcome has", length(lev), "levels. The twoClassSummary() function isn't appropriate."))
  }
  requireNamespaceQuietStop("pROC")
  if (!all(levels(data[, "pred"]) == lev)) {
    stop("levels of observed and predicted data do not match")
  }
  rocObject <- try(pROC::roc(data$obs, data[, lev[1]], direction = ">", quiet = TRUE), silent = TRUE)
  rocAUC <- if (inherits(rocObject, "try-error")) 
    NA
  else rocObject$auc
  out <- c(rocAUC, sensitivity(data[, "pred"], data[, "obs"], lev[1]), specificity(data[, "pred"], data[, "obs"], lev[2]))
  names(out) <- c("ROC", "Sens", "Spec")
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
upSample
list(`package:caret` = function (x, y, list = FALSE, yname = "Class") 
{
  if (!is.data.frame(x)) {
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  }
  if (!is.factor(y)) {
    warning("Up-sampling requires a factor variable as the response. The original data was returned.")
    return(list(x = x, y = y))
  }
  maxClass <- max(table(y))
  x$.outcome <- y
  x <- ddply(x, .(y), function(x, top = maxClass) {
    if (nrow(x) < top) {
      ind <- sample(1:nrow(x), size = top - nrow(x), replace = TRUE)
      ind <- c(1:nrow(x), ind)
      x <- x[ind, , drop = FALSE]
    }
    x
  })
  y <- x$.outcome
  x <- x[, !(colnames(x) %in% c("y", ".outcome")), drop = FALSE]
  if (list) {
    if (inherits(x, "matrix")) {
      x <- as.matrix(x)
    }
    out <- list(x = x, y = y)
  }
  else {
    out <- cbind(x, y)
    colnames(out)[ncol(out)] <- yname
  }
  out
}, function (x, y, list = FALSE, yname = "Class") 
{
  if (!is.data.frame(x)) {
    x <- as.data.frame(x, stringsAsFactors = TRUE)
  }
  if (!is.factor(y)) {
    warning("Up-sampling requires a factor variable as the response. The original data was returned.")
    return(list(x = x, y = y))
  }
  maxClass <- max(table(y))
  x$.outcome <- y
  x <- ddply(x, .(y), function(x, top = maxClass) {
    if (nrow(x) < top) {
      ind <- sample(1:nrow(x), size = top - nrow(x), replace = TRUE)
      ind <- c(1:nrow(x), ind)
      x <- x[ind, , drop = FALSE]
    }
    x
  })
  y <- x$.outcome
  x <- x[, !(colnames(x) %in% c("y", ".outcome")), drop = FALSE]
  if (list) {
    if (inherits(x, "matrix")) {
      x <- as.matrix(x)
    }
    out <- list(x = x, y = y)
  }
  else {
    out <- cbind(x, y)
    colnames(out)[ncol(out)] <- yname
  }
  out
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
var_seq
list(`package:caret` = function (p, classification = FALSE, len = 3) 
{
  if (len == 1) {
    tuneSeq <- if (!classification) 
      max(floor(p/3), 1)
    else floor(sqrt(p))
  }
  else {
    if (p <= len) {
      tuneSeq <- floor(seq(2, to = p, length = p))
    }
    else {
      if (p < 500) 
        tuneSeq <- floor(seq(2, to = p, length = len))
      else tuneSeq <- floor(2^seq(1, to = log(p, base = 2), length = len))
    }
  }
  if (any(table(tuneSeq) > 1)) {
    tuneSeq <- unique(tuneSeq)
    cat("note: only", length(tuneSeq), "unique complexity parameters in default grid.", "Truncating the grid to", length(tuneSeq), ".\n\n")
  }
  tuneSeq
}, function (p, classification = FALSE, len = 3) 
{
  if (len == 1) {
    tuneSeq <- if (!classification) 
      max(floor(p/3), 1)
    else floor(sqrt(p))
  }
  else {
    if (p <= len) {
      tuneSeq <- floor(seq(2, to = p, length = p))
    }
    else {
      if (p < 500) 
        tuneSeq <- floor(seq(2, to = p, length = len))
      else tuneSeq <- floor(2^seq(1, to = log(p, base = 2), length = len))
    }
  }
  if (any(table(tuneSeq) > 1)) {
    tuneSeq <- unique(tuneSeq)
    cat("note: only", length(tuneSeq), "unique complexity parameters in default grid.", "Truncating the grid to", length(tuneSeq), ".\n\n")
  }
  tuneSeq
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
varImp
list(`package:caret` = function (object, ...) 
{
  UseMethod("varImp")
}, function (object, ...) 
{
  UseMethod("varImp")
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)
well_numbered
list(`package:caret` = function (prefix, items) 
{
  paste0(prefix, gsub(" ", "0", format(1:items)))
}, function (prefix, items) 
{
  paste0(prefix, gsub(" ", "0", format(1:items)))
})
c("package:caret", "namespace:caret")
c(TRUE, FALSE)
c(FALSE, TRUE)



###################################################################################################
library(checkmate)
1)%??%
  list(`package:checkmate` = function (lhs, rhs) 
  {
    if (missing(lhs) || is.null(lhs)) 
      rhs
    else lhs
  }, function (lhs, rhs) 
  {
    if (missing(lhs) || is.null(lhs)) 
      rhs
    else lhs
  })
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
2)allMissing
list(`package:checkmate` = function (x) 
{
  .Call(c_all_missing, x)
}, function (x) 
{
  .Call(c_all_missing, x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
3)anyInfinite
list(`package:checkmate` = function (x) 
{
  .Call(c_any_infinite, x)
}, function (x) 
{
  .Call(c_any_infinite, x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
4)anyMissing
list(`package:checkmate` = function (x) 
{
  .Call(c_any_missing, x)
}, function (args) 
{
  for (i in 1:length(args)) {
    a <- args[[i]]
    if (missing(a)) 
      return(TRUE)
  }
  return(FALSE)
}, function (x) 
{
  .Call(c_any_missing, x)
})
c("package:checkmate", "namespace:codetools", "namespace:checkmate")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
5)anyNaN
list(`package:checkmate` = function (x) 
{
  .Call(c_any_nan, x)
}, function (x) 
{
  .Call(c_any_nan, x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
6)asCount
list(`package:checkmate` = function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), .var.name = vname(x)) 
{
  assertCount(x, na.ok, positive, tol, .var.name = .var.name)
  storage.mode(x) = "integer"
  x
}, function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), .var.name = vname(x)) 
{
  assertCount(x, na.ok, positive, tol, .var.name = .var.name)
  storage.mode(x) = "integer"
  x
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
7)asInt
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), .var.name = vname(x)) 
{
  assertInt(x, na.ok, lower, upper, tol, .var.name = .var.name)
  storage.mode(x) = "integer"
  x
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), .var.name = vname(x)) 
{
  assertInt(x, na.ok, lower, upper, tol, .var.name = .var.name)
  storage.mode(x) = "integer"
  x
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
8)asInteger
list(`package:checkmate` = function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, .var.name = vname(x)) 
{
  assertIntegerish(x, tol = tol, lower = lower, upper = upper, any.missing = any.missing, all.missing = all.missing, len = len, min.len = min.len, max.len = max.len, unique = unique, sorted = sorted, names = names, null.ok = FALSE, .var.name = .var.name)
  storage.mode(x) = "integer"
  x
}, function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, .var.name = vname(x)) 
{
  assertIntegerish(x, tol = tol, lower = lower, upper = upper, any.missing = any.missing, all.missing = all.missing, len = len, min.len = min.len, max.len = max.len, unique = unique, sorted = sorted, names = names, null.ok = FALSE, .var.name = .var.name)
  storage.mode(x) = "integer"
  x
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
9)assert
list(`package:checkmate` = function (..., combine = "or", .var.name = NULL, add = NULL) 
{
  assertChoice(combine, c("or", "and"))
  assertClass(add, "AssertCollection", .var.name = "add", null.ok = TRUE)
  dots = match.call(expand.dots = FALSE)$...
  assertCharacter(.var.name, null.ok = TRUE, min.len = 1, max.len = length(dots))
  env = parent.frame()
  if (combine == "or") {
    msgs = character(length(dots))
    for (i in seq_along(dots)) {
      val = eval(dots[[i]], envir = env)
      if (isTRUE(val)) 
        return(invisible(TRUE))
      msgs[i] = as.character(val)
    }
    if (is.null(.var.name)) 
      .var.name = vapply(dots, function(x) as.character(x)[2], FUN.VALUE = NA)
    if (length(msgs) > 1) {
      msgs = sprintf("%s(%s): %s", vapply(dots, function(x) as.character(x)[1], FUN.VALUE = NA), .var.name, msgs)
      msgs = paste0(c("One of the following must apply:", strwrap(msgs, prefix = " * ")), collapse = "\n")
    }
    mstopOrPush(res = msgs, v_name = .var.name, collection = add)
  }
  else {
    for (i in seq_along(dots)) {
      val = eval(dots[[i]], envir = env)
      if (!isTRUE(val)) {
        if (is.null(.var.name)) 
          .var.name = as.character(dots[[i]])[2]
        mstopOrPush(res = val, v_name = .var.name, collection = add)
      }
    }
  }
  invisible(TRUE)
}, function (..., combine = "or", .var.name = NULL, add = NULL) 
{
  assertChoice(combine, c("or", "and"))
  assertClass(add, "AssertCollection", .var.name = "add", null.ok = TRUE)
  dots = match.call(expand.dots = FALSE)$...
  assertCharacter(.var.name, null.ok = TRUE, min.len = 1, max.len = length(dots))
  env = parent.frame()
  if (combine == "or") {
    msgs = character(length(dots))
    for (i in seq_along(dots)) {
      val = eval(dots[[i]], envir = env)
      if (isTRUE(val)) 
        return(invisible(TRUE))
      msgs[i] = as.character(val)
    }
    if (is.null(.var.name)) 
      .var.name = vapply(dots, function(x) as.character(x)[2], FUN.VALUE = NA)
    if (length(msgs) > 1) {
      msgs = sprintf("%s(%s): %s", vapply(dots, function(x) as.character(x)[1], FUN.VALUE = NA), .var.name, msgs)
      msgs = paste0(c("One of the following must apply:", strwrap(msgs, prefix = " * ")), collapse = "\n")
    }
    mstopOrPush(res = msgs, v_name = .var.name, collection = add)
  }
  else {
    for (i in seq_along(dots)) {
      val = eval(dots[[i]], envir = env)
      if (!isTRUE(val)) {
        if (is.null(.var.name)) 
          .var.name = as.character(dots[[i]])[2]
        mstopOrPush(res = val, v_name = .var.name, collection = add)
      }
    }
  }
  invisible(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
10)assert_access
list(`package:checkmate` = function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkAccess(x, access)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkAccess(x, access)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
11)assert_array
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
12)assert_atomic
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeAssertion(x, res, .var.name, add)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
13)assert_atomic_vector
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeAssertion(x, res, .var.name, add)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
14)assert_character
list(`package:checkmate` = function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
15)assert_choice
list(`package:checkmate` = function (x, choices, null.ok = FALSE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkChoice(x, choices, null.ok, fmatch)
  makeAssertion(x, res, .var.name, add)
}, function (x, choices, null.ok = FALSE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkChoice(x, choices, null.ok, fmatch)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
16)assert_class
list(`package:checkmate` = function (x, classes, ordered = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkClass(x, classes, ordered, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, classes, ordered = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkClass(x, classes, ordered, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
17)assert_complex
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
18)assert_count
list(`package:checkmate` = function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_count, x, na.ok, positive, tol, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
}, function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_count, x, na.ok, positive, tol, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
19)assert_data_frame
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
20)assert_data_table
list(`package:checkmate` = function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
21) assert_date
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
22) assert_directory
list(`package:checkmate` = function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDirectoryExists(x, access)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDirectoryExists(x, access)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
23) assert_directory_exists
list(`package:checkmate` = function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDirectoryExists(x, access)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDirectoryExists(x, access)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
24) assert_disjunct
list(`package:checkmate` = function (x, y, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDisjunct(x, y, fmatch)
  makeAssertion(x, res, .var.name, add)
}, function (x, y, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDisjunct(x, y, fmatch)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
25) assert_double
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
26) assert_environment
list(`package:checkmate` = function (x, contains = character(0), null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkEnvironment(x, contains, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, contains = character(0), null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkEnvironment(x, contains, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
27) assert_factor
list(`package:checkmate` = function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
28) assert_false
list(`package:checkmate` = function (x, na.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFALSE(x, na.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFALSE(x, na.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
29) assert_file
list(`package:checkmate` = function (x, access = "", extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFileExists(x, access, extension)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFileExists(x, access, extension)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
30) assert_file_exists
list(`package:checkmate` = function (x, access = "", extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFileExists(x, access, extension)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFileExists(x, access, extension)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
31) assert_flag
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_flag, x, na.ok, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_flag, x, na.ok, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
32) assert_formula
list(`package:checkmate` = function (x, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFormula(x, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFormula(x, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
33) assert_function
list(`package:checkmate` = function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFunction(x, args, ordered, nargs, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFunction(x, args, ordered, nargs, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
34) assert_int
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
35) assert_integer
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
36) assert_integerish
list(`package:checkmate` = function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
}, function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
37) assert_list
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
38) assert_logical
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
39) assert_matrix
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
40) assert_multi_class
list(`package:checkmate` = function (x, classes, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkMultiClass(x, classes, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, classes, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkMultiClass(x, classes, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_named
list(`package:checkmate` = function (x, type = "named", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_named, x, type)
  makeAssertion(x, res, .var.name, add)
}, function (x, type = "named", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_named, x, type)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_names
list(`package:checkmate` = function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
  makeAssertion(x, res, .var.name, add)
}, function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_null
list(`package:checkmate` = function (x, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkNull(x)
  makeAssertion(x, res, .var.name, add)
}, function (x, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkNull(x)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_number
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_numeric
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_os
list(`package:checkmate` = function (os, add = NULL, .var.name = NULL) 
{
  res = checkOS(os)
  makeAssertion(os, res, .var.name %??% "Operating System", add)
}, function (os, add = NULL, .var.name = NULL) 
{
  res = checkOS(os)
  makeAssertion(os, res, .var.name %??% "Operating System", add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_path_for_output
list(`package:checkmate` = function (x, overwrite = FALSE, extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkPathForOutput(x, overwrite, extension)
  makeAssertion(x, res, .var.name, add)
}, function (x, overwrite = FALSE, extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkPathForOutput(x, overwrite, extension)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_posixct
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_r6
list(`package:checkmate` = function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkR6(x, classes, ordered, cloneable, public, private, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkR6(x, classes, ordered, cloneable, public, private, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_raw
list(`package:checkmate` = function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_scalar
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_scalar, x, na.ok, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_scalar, x, na.ok, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_scalar_na
list(`package:checkmate` = function (x, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkScalarNA(x, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkScalarNA(x, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_set_equal
list(`package:checkmate` = function (x, y, ordered = FALSE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkSetEqual(x, y, ordered, fmatch)
  makeAssertion(x, res, .var.name, add)
}, function (x, y, ordered = FALSE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkSetEqual(x, y, ordered, fmatch)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_string
list(`package:checkmate` = function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_subset
list(`package:checkmate` = function (x, choices, empty.ok = TRUE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkSubset(x, choices, empty.ok, fmatch)
  makeAssertion(x, res, .var.name, add)
}, function (x, choices, empty.ok = TRUE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkSubset(x, choices, empty.ok, fmatch)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_tibble
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_true
list(`package:checkmate` = function (x, na.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkTRUE(x, na.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkTRUE(x, na.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assert_vector
list(`package:checkmate` = function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertAccess
list(`package:checkmate` = function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkAccess(x, access)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkAccess(x, access)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertArray
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertAtomic
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeAssertion(x, res, .var.name, add)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertAtomicVector
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeAssertion(x, res, .var.name, add)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertCharacter
list(`package:checkmate` = function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertChoice
list(`package:checkmate` = function (x, choices, null.ok = FALSE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkChoice(x, choices, null.ok, fmatch)
  makeAssertion(x, res, .var.name, add)
}, function (x, choices, null.ok = FALSE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkChoice(x, choices, null.ok, fmatch)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertClass
list(`package:checkmate` = function (x, classes, ordered = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkClass(x, classes, ordered, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, classes, ordered = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkClass(x, classes, ordered, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertComplex
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertCount
list(`package:checkmate` = function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_count, x, na.ok, positive, tol, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
}, function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_count, x, na.ok, positive, tol, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertDataFrame
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertDataTable
list(`package:checkmate` = function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertDate
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertDirectory
list(`package:checkmate` = function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDirectoryExists(x, access)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDirectoryExists(x, access)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertDirectoryExists
list(`package:checkmate` = function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDirectoryExists(x, access)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDirectoryExists(x, access)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertDisjunct
list(`package:checkmate` = function (x, y, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDisjunct(x, y, fmatch)
  makeAssertion(x, res, .var.name, add)
}, function (x, y, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkDisjunct(x, y, fmatch)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertDouble
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertEnvironment
list(`package:checkmate` = function (x, contains = character(0), null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkEnvironment(x, contains, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, contains = character(0), null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkEnvironment(x, contains, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertFactor
list(`package:checkmate` = function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertFALSE
list(`package:checkmate` = function (x, na.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFALSE(x, na.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFALSE(x, na.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertFile
list(`package:checkmate` = function (x, access = "", extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFileExists(x, access, extension)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFileExists(x, access, extension)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertFileExists
list(`package:checkmate` = function (x, access = "", extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFileExists(x, access, extension)
  makeAssertion(x, res, .var.name, add)
}, function (x, access = "", extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFileExists(x, access, extension)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertFlag
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_flag, x, na.ok, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_flag, x, na.ok, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertFormula
list(`package:checkmate` = function (x, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFormula(x, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFormula(x, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertFunction
list(`package:checkmate` = function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFunction(x, args, ordered, nargs, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkFunction(x, args, ordered, nargs, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertInt
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertInteger
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertIntegerish
list(`package:checkmate` = function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
}, function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, coerce = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
  if (isTRUE(coerce) && is.double(x)) 
    x = setNames(as.integer(round(x, 0)), names(x))
  invisible(x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertList
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertLogical
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertMatrix
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertMultiClass
list(`package:checkmate` = function (x, classes, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkMultiClass(x, classes, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, classes, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkMultiClass(x, classes, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertNamed
list(`package:checkmate` = function (x, type = "named", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_named, x, type)
  makeAssertion(x, res, .var.name, add)
}, function (x, type = "named", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_named, x, type)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertNames
list(`package:checkmate` = function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
  makeAssertion(x, res, .var.name, add)
}, function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names", .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertNull
list(`package:checkmate` = function (x, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkNull(x)
  makeAssertion(x, res, .var.name, add)
}, function (x, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkNull(x)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertNumber
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertNumeric
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertOS
list(`package:checkmate` = function (os, add = NULL, .var.name = NULL) 
{
  res = checkOS(os)
  makeAssertion(os, res, .var.name %??% "Operating System", add)
}, function (os, add = NULL, .var.name = NULL) 
{
  res = checkOS(os)
  makeAssertion(os, res, .var.name %??% "Operating System", add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertPathForOutput
list(`package:checkmate` = function (x, overwrite = FALSE, extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkPathForOutput(x, overwrite, extension)
  makeAssertion(x, res, .var.name, add)
}, function (x, overwrite = FALSE, extension = NULL, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkPathForOutput(x, overwrite, extension)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertPOSIXct
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertR6
list(`package:checkmate` = function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkR6(x, classes, ordered, cloneable, public, private, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkR6(x, classes, ordered, cloneable, public, private, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertRaw
list(`package:checkmate` = function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertScalar
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_scalar, x, na.ok, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_scalar, x, na.ok, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertScalarNA
list(`package:checkmate` = function (x, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkScalarNA(x, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkScalarNA(x, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertSetEqual
list(`package:checkmate` = function (x, y, ordered = FALSE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkSetEqual(x, y, ordered, fmatch)
  makeAssertion(x, res, .var.name, add)
}, function (x, y, ordered = FALSE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkSetEqual(x, y, ordered, fmatch)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertString
list(`package:checkmate` = function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertSubset
list(`package:checkmate` = function (x, choices, empty.ok = TRUE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkSubset(x, choices, empty.ok, fmatch)
  makeAssertion(x, res, .var.name, add)
}, function (x, choices, empty.ok = TRUE, fmatch = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkSubset(x, choices, empty.ok, fmatch)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertTibble
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertTRUE
list(`package:checkmate` = function (x, na.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkTRUE(x, na.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, na.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = checkTRUE(x, na.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
assertVector
list(`package:checkmate` = function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
}, function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  if (missing(x)) 
    stop(sprintf("argument \"%s\" is missing, with no default", .var.name))
  res = .Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeAssertion(x, res, .var.name, add)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_access
list(`package:checkmate` = function (x, access = "") 
{
  qassert(access, "S1")
  if (nzchar(access)) {
    access = strsplit(access, "")[[1]]
    if (anyDuplicated(access) > 0 || !all(access %in% c("r", "w", "x"))) 
      stop("Access pattern invalid, allowed are 'r', 'w' and 'x'")
    is.win = .Platform$OS.type == "windows"
    is.root = (!is.win && Sys.info()["user"] == "root")
    if ("r" %in% access || is.root) {
      w = wf(file.access(x, 4) != 0)
      if (length(w) > 0) 
        return(sprintf("'%s' not readable", x[w]))
    }
    if (!is.win) {
      if ("w" %in% access || is.root) {
        w = wf(file.access(x, 2) != 0)
        if (length(w) > 0) 
          return(sprintf("'%s' not writeable", x[w]))
      }
      if ("x" %in% access) {
        w = wf(file.access(x, 1) != 0)
        if (length(w) > 0) 
          return(sprintf("'%s' not executable", x[w]))
      }
    }
  }
  return(TRUE)
}, function (x, access = "") 
{
  qassert(access, "S1")
  if (nzchar(access)) {
    access = strsplit(access, "")[[1]]
    if (anyDuplicated(access) > 0 || !all(access %in% c("r", "w", "x"))) 
      stop("Access pattern invalid, allowed are 'r', 'w' and 'x'")
    is.win = .Platform$OS.type == "windows"
    is.root = (!is.win && Sys.info()["user"] == "root")
    if ("r" %in% access || is.root) {
      w = wf(file.access(x, 4) != 0)
      if (length(w) > 0) 
        return(sprintf("'%s' not readable", x[w]))
    }
    if (!is.win) {
      if ("w" %in% access || is.root) {
        w = wf(file.access(x, 2) != 0)
        if (length(w) > 0) 
          return(sprintf("'%s' not writeable", x[w]))
      }
      if ("x" %in% access) {
        w = wf(file.access(x, 1) != 0)
        if (length(w) > 0) 
          return(sprintf("'%s' not executable", x[w]))
      }
    }
  }
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_array
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE) 
{
  .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
}, function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE) 
{
  .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_atomic
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_atomic_vector
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_character
list(`package:checkmate` = function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_character, x, n.chars, min.chars, max.chars, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok) %and% checkCharacterPattern(x, pattern, fixed, ignore.case)
}, function (x, ..., what = "a character vector", arg = caller_arg(x), call = caller_env()) 
{
  if (!is_character(x)) {
    stop_input_type(x, what, ..., arg = arg, call = call)
  }
}, function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_character, x, n.chars, min.chars, max.chars, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok) %and% checkCharacterPattern(x, pattern, fixed, ignore.case)
})
c("package:checkmate", "namespace:rlang", "namespace:checkmate")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
check_choice
list(`package:checkmate` = function (x, choices, null.ok = FALSE, fmatch = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    qassert(choices, "a")
    return(sprintf("Must be a subset of %s, not 'NULL'", set_collapse(choices)))
  }
  qassert(choices, "a")
  if (!qtest(x, "a1")) 
    return(sprintf("Must be element of set %s, but is not atomic scalar", set_collapse(choices)))
  if (!isSameType(x, choices) && !allMissing(x)) 
    return(sprintf("Must be element of set %s, but types do not match (%s != %s)", set_collapse(choices), class(x)[1], class(choices)[1]))
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  if (match(x, choices, 0) == 0) 
    return(sprintf("Must be element of set %s, but is '%s'", set_collapse(choices), x))
  return(TRUE)
}, function (x, choices, null.ok = FALSE, fmatch = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    qassert(choices, "a")
    return(sprintf("Must be a subset of %s, not 'NULL'", set_collapse(choices)))
  }
  qassert(choices, "a")
  if (!qtest(x, "a1")) 
    return(sprintf("Must be element of set %s, but is not atomic scalar", set_collapse(choices)))
  if (!isSameType(x, choices) && !allMissing(x)) 
    return(sprintf("Must be element of set %s, but types do not match (%s != %s)", set_collapse(choices), class(x)[1], class(choices)[1]))
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  if (match(x, choices, 0) == 0) 
    return(sprintf("Must be element of set %s, but is '%s'", set_collapse(choices), x))
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_class
list(`package:checkmate` = function (x, classes, ordered = FALSE, null.ok = FALSE) 
{
  qassert(classes, "S+")
  qassert(ordered, "B1")
  qassert(null.ok, "B1")
  if (is.null(x) && null.ok) 
    return(TRUE)
  ord = inherits(x, classes, TRUE)
  w = wf(ord == 0)
  if (length(w) > 0) {
    cl = class(x)
    return(sprintf("Must inherit from class '%s', but has class%s '%s'", classes[w], if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
  }
  if (ordered) {
    w = wf(ord != seq_along(ord))
    if (length(w) > 0) {
      cl = class(x)
      return(sprintf("Must have class '%s' in position %i, but has class%s '%s'", classes[w], w, if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
    }
  }
  return(TRUE)
}, function (x, template, header, error_call = caller_env()) 
{
  if (!is.object(x)) {
    return()
  }
  if (identical(class(x), class(template))) {
    return()
  }
  exp_classes <- fmt_classes(template)
  out_classes <- fmt_classes(x)
  msg <- glue("{header} must have class `{exp_classes}`, not class `{out_classes}`.")
  abort(msg, call = error_call)
}, function (x, classes, ordered = FALSE, null.ok = FALSE) 
{
  qassert(classes, "S+")
  qassert(ordered, "B1")
  qassert(null.ok, "B1")
  if (is.null(x) && null.ok) 
    return(TRUE)
  ord = inherits(x, classes, TRUE)
  w = wf(ord == 0)
  if (length(w) > 0) {
    cl = class(x)
    return(sprintf("Must inherit from class '%s', but has class%s '%s'", classes[w], if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
  }
  if (ordered) {
    w = wf(ord != seq_along(ord))
    if (length(w) > 0) {
      cl = class(x)
      return(sprintf("Must have class '%s' in position %i, but has class%s '%s'", classes[w], w, if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
    }
  }
  return(TRUE)
})
c("package:checkmate", "namespace:dplyr", "namespace:checkmate")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
check_complex
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_count
list(`package:checkmate` = function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  .Call(c_check_count, x, na.ok, positive, tol, null.ok)
}, function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  .Call(c_check_count, x, na.ok, positive, tol, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_data_frame
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  .Call(c_check_dataframe, x, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok) %and% checkListTypes(x, types)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  .Call(c_check_dataframe, x, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok) %and% checkListTypes(x, types)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_data_table
list(`package:checkmate` = function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("data.table", quietly = TRUE)) 
    stop("Install package 'data.table' to perform checks of data tables")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a data.table, not 'NULL'")
  }
  if (!data.table::is.data.table(x)) {
    return(paste0("Must be a data.table", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  }
  checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok = FALSE) %and% checkDataTableProps(x, key, index)
}, function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("data.table", quietly = TRUE)) 
    stop("Install package 'data.table' to perform checks of data tables")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a data.table, not 'NULL'")
  }
  if (!data.table::is.data.table(x)) {
    return(paste0("Must be a data.table", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  }
  checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok = FALSE) %and% checkDataTableProps(x, key, index)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_date
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be of class 'Date', not 'NULL'")
  }
  if (!inherits(x, "Date")) 
    return(sprintf("Must be of class 'Date'%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  checkInteger(as.integer(x), any.missing = any.missing, all.missing = all.missing, len = len, min.len = min.len, max.len = max.len, unique = unique) %and% checkDateBounds(x, lower, upper)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be of class 'Date', not 'NULL'")
  }
  if (!inherits(x, "Date")) 
    return(sprintf("Must be of class 'Date'%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  checkInteger(as.integer(x), any.missing = any.missing, all.missing = all.missing, len = len, min.len = min.len, max.len = max.len, unique = unique) %and% checkDateBounds(x, lower, upper)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_directory_exists
list(`package:checkmate` = function (x, access = "") 
{
  if (!qtest(x, "S+")) 
    return("No directory provided")
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory '%s' does not exist", x[w]))
  w = wf(!dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory expected, but file in place: '%s'", x[w]))
  checkAccess(x, access)
}, function (x, access = "") 
{
  if (!qtest(x, "S+")) 
    return("No directory provided")
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory '%s' does not exist", x[w]))
  w = wf(!dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory expected, but file in place: '%s'", x[w]))
  checkAccess(x, access)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_disjunct
list(`package:checkmate` = function (x, y, fmatch = FALSE) 
{
  qassert(x, "a")
  qassert(y, "a")
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_disjunct_internal(x, y, match)
}, function (x, y, fmatch = FALSE) 
{
  qassert(x, "a")
  qassert(y, "a")
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_disjunct_internal(x, y, match)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_double
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_environment
list(`package:checkmate` = function (x, contains = character(0), null.ok = FALSE) 
{
  qassert(contains, "S")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be an environment, not 'NULL'")
  }
  if (!is.environment(x)) 
    return(sprintf("Must be an environment%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  if (length(contains) > 0) {
    w = wf(contains %nin% ls(x, all.names = TRUE))
    if (length(w) > 0) 
      return(sprintf("Must contain an object with name '%s'", contains[w]))
  }
  return(TRUE)
}, function (x, ..., what = "an environment", arg = caller_arg(x), call = caller_env()) 
{
  if (!is_environment(x)) {
    stop_input_type(x, what, ..., arg = arg, call = call)
  }
}, function (x, contains = character(0), null.ok = FALSE) 
{
  qassert(contains, "S")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be an environment, not 'NULL'")
  }
  if (!is.environment(x)) 
    return(sprintf("Must be an environment%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  if (length(contains) > 0) {
    w = wf(contains %nin% ls(x, all.names = TRUE))
    if (length(w) > 0) 
      return(sprintf("Must contain an object with name '%s'", contains[w]))
  }
  return(TRUE)
})
c("package:checkmate", "namespace:rlang", "namespace:checkmate")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
check_factor
list(`package:checkmate` = function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_factor, x, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok) %and% checkFactorLevels(x, levels, ordered, empty.levels.ok, n.levels, min.levels, max.levels)
}, function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_factor, x, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok) %and% checkFactorLevels(x, levels, ordered, empty.levels.ok, n.levels, min.levels, max.levels)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_false
list(`package:checkmate` = function (x, na.ok = FALSE) 
{
  qassert(na.ok, "B1")
  if (isFALSE(x) || (na.ok && length(x) == 1 && is.na(x))) 
    return(TRUE)
  return("Must be FALSE")
}, function (x, na.ok = FALSE) 
{
  qassert(na.ok, "B1")
  if (isFALSE(x) || (na.ok && length(x) == 1 && is.na(x))) 
    return(TRUE)
  return("Must be FALSE")
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_file_exists
list(`package:checkmate` = function (x, access = "", extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No file provided")
  w = wf(dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("File expected, but directory in place: '%s'", x[w]))
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("File does not exist: '%s'", x[w]))
  checkAccess(x, access) %and% checkFileExtension(x, extension)
}, function (x, access = "", extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No file provided")
  w = wf(dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("File expected, but directory in place: '%s'", x[w]))
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("File does not exist: '%s'", x[w]))
  checkAccess(x, access) %and% checkFileExtension(x, extension)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_flag
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE) 
{
  .Call(c_check_flag, x, na.ok, null.ok)
}, function (x, na.ok = FALSE, null.ok = FALSE) 
{
  .Call(c_check_flag, x, na.ok, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_formula
list(`package:checkmate` = function (x, null.ok = FALSE) 
{
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a formula, not 'NULL'")
  }
  if (!inherits(x, "formula")) 
    return(sprintf("Must be a formula%s, not %s", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  return(TRUE)
}, function (x, ..., what = "a formula", arg = caller_arg(x), call = caller_env()) 
{
  if (!is_formula(x)) {
    stop_input_type(x, what, ..., arg = arg, call = call)
  }
}, function (x, null.ok = FALSE) 
{
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a formula, not 'NULL'")
  }
  if (!inherits(x, "formula")) 
    return(sprintf("Must be a formula%s, not %s", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  return(TRUE)
}, function (formula, varnames, valnames) 
{
  if (is.character(formula)) 
    formula = as.formula(formula)
  if (!inherits(formula, "formula") || length(formula) != 3) 
    stop("Invalid formula. Cast formula should be of the form LHS ~ RHS, for e.g., a + b ~ c.")
  vars = all.vars(formula)
  vars = vars[!vars %chin% c(".", "...")]
  allvars = c(vars, valnames)
  if (any(allvars %chin% varnames[duplicated(varnames)])) 
    stop("data.table to cast must have unique column names")
  deparse_formula(as.list(formula)[-1], varnames, allvars)
})
c("package:checkmate", "namespace:rlang", "namespace:checkmate", "namespace:data.table")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, FALSE)
check_function
list(`package:checkmate` = function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a function, not 'NULL'")
  }
  if (!is.function(x)) 
    return(sprintf("Must be a function%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  if (!is.null(args)) {
    qassert(args, "S")
    fargs = names(formals(args(x))) %??% character()
    if (length(args) == 0) {
      if (length(fargs) > 0) 
        return("May not have any arguments")
      return(TRUE)
    }
    qassert(ordered, "B1")
    if (ordered) {
      if (length(fargs) < length(args) || any(args != head(fargs, length(args)))) {
        return(sprintf("Must have first formal arguments (ordered): %s", paste0(args, collapse = ",")))
      }
    }
    else {
      tmp = setdiff(args, fargs)
      if (length(tmp)) 
        return(sprintf("Must have formal arguments: %s", paste0(tmp, collapse = ",")))
    }
  }
  if (!is.null(nargs)) {
    nargs = asCount(nargs)
    fnargs = length(setdiff(names(formals(args(x))) %??% character(0), "..."))
    if (nargs != fnargs) 
      return(sprintf("Must have exactly %i formal arguments, but has %i", nargs, fnargs))
  }
  return(TRUE)
}, function (x, ..., what = "a function", arg = caller_arg(x), call = caller_env()) 
{
  if (!is_function(x)) {
    stop_input_type(x, what, ..., arg = arg, call = call)
  }
}, function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a function, not 'NULL'")
  }
  if (!is.function(x)) 
    return(sprintf("Must be a function%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  if (!is.null(args)) {
    qassert(args, "S")
    fargs = names(formals(args(x))) %??% character()
    if (length(args) == 0) {
      if (length(fargs) > 0) 
        return("May not have any arguments")
      return(TRUE)
    }
    qassert(ordered, "B1")
    if (ordered) {
      if (length(fargs) < length(args) || any(args != head(fargs, length(args)))) {
        return(sprintf("Must have first formal arguments (ordered): %s", paste0(args, collapse = ",")))
      }
    }
    else {
      tmp = setdiff(args, fargs)
      if (length(tmp)) 
        return(sprintf("Must have formal arguments: %s", paste0(tmp, collapse = ",")))
    }
  }
  if (!is.null(nargs)) {
    nargs = asCount(nargs)
    fnargs = length(setdiff(names(formals(args(x))) %??% character(0), "..."))
    if (nargs != fnargs) 
      return(sprintf("Must have exactly %i formal arguments, but has %i", nargs, fnargs))
  }
  return(TRUE)
})
c("package:checkmate", "namespace:rlang", "namespace:checkmate")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
check_int
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_integer
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
}, function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_integerish
list(`package:checkmate` = function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
}, function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_list
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_list, x, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok) %and% checkListTypes(x, types)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_list, x, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok) %and% checkListTypes(x, types)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_logical
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_matrix
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
}, function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_multi_class
list(`package:checkmate` = function (x, classes, null.ok = FALSE) 
{
  qassert(classes, "S+")
  qassert(null.ok, "B1")
  if (is.null(x) && null.ok) 
    return(TRUE)
  if (!inherits(x, classes)) {
    cl = class(x)
    return(sprintf("Must inherit from class '%s', but has class%s '%s'", paste0(classes, collapse = "'/'"), if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
  }
  return(TRUE)
}, function (x, classes, null.ok = FALSE) 
{
  qassert(classes, "S+")
  qassert(null.ok, "B1")
  if (is.null(x) && null.ok) 
    return(TRUE)
  if (!inherits(x, classes)) {
    cl = class(x)
    return(sprintf("Must inherit from class '%s', but has class%s '%s'", paste0(classes, collapse = "'/'"), if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
  }
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_named
list(`package:checkmate` = function (x, type = "named") 
{
  .Deprecated(new = "checkNames", old = "checkNamed", package = "checkmate")
  .Call(c_check_named, x, type)
}, function (x, type = "named") 
{
  .Deprecated(new = "checkNames", old = "checkNamed", package = "checkmate")
  .Call(c_check_named, x, type)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_names
list(`package:checkmate` = function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names") 
{
  .Call(c_check_names, x, type, what) %and% checkNamesCmp(x, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
}, function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names") 
{
  .Call(c_check_names, x, type, what) %and% checkNamesCmp(x, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_null
list(`package:checkmate` = function (x) 
{
  if (!is.null(x)) 
    return("Must be NULL")
  return(TRUE)
}, function (x) 
{
  if (!is.null(x)) 
    return("Must be NULL")
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_number
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE) 
{
  .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
}, function (x, ..., what = "a round number", arg = caller_arg(x), call = caller_env()) 
{
  if (!is_number(x)) {
    stop_input_type(x, what, ..., arg = arg, call = call)
  }
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE) 
{
  .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
})
c("package:checkmate", "namespace:rlang", "namespace:checkmate")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
check_numeric
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_os
list(`package:checkmate` = function (os) 
{
  ok = match.arg(os, c("windows", "mac", "linux", "solaris"), several.ok = TRUE)
  if (checkmate$os %nin% ok) 
    return(sprintf("OS must be %s", paste0(ok, collapse = " or ")))
  return(TRUE)
}, function (os) 
{
  ok = match.arg(os, c("windows", "mac", "linux", "solaris"), several.ok = TRUE)
  if (checkmate$os %nin% ok) 
    return(sprintf("OS must be %s", paste0(ok, collapse = " or ")))
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_path_for_output
list(`package:checkmate` = function (x, overwrite = FALSE, extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No path provided")
  qassert(overwrite, "B1")
  x = normalizePath(x, mustWork = FALSE)
  dn = dirname(x)
  w = wf(!dir.exists(dn))
  if (length(w) > 0) 
    return(sprintf("Path to file (dirname) does not exist: '%s' of '%s'", dn[w], x[w]))
  w = which(file.exists(x))
  if (length(w) > 0) {
    if (overwrite) 
      return(checkAccess(dn, "w") %and% checkAccess(x[w], "rw"))
    return(sprintf("File at path already exists: '%s'", x[w]))
  }
  if (!is.null(extension)) {
    qassert(extension, "S1")
    if (!endsWith(x, paste0(".", extension))) 
      return(sprintf("File must have extension '.%s'", extension))
  }
  return(checkAccess(dn, "w"))
}, function (x, overwrite = FALSE, extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No path provided")
  qassert(overwrite, "B1")
  x = normalizePath(x, mustWork = FALSE)
  dn = dirname(x)
  w = wf(!dir.exists(dn))
  if (length(w) > 0) 
    return(sprintf("Path to file (dirname) does not exist: '%s' of '%s'", dn[w], x[w]))
  w = which(file.exists(x))
  if (length(w) > 0) {
    if (overwrite) 
      return(checkAccess(dn, "w") %and% checkAccess(x[w], "rw"))
    return(sprintf("File at path already exists: '%s'", x[w]))
  }
  if (!is.null(extension)) {
    qassert(extension, "S1")
    if (!endsWith(x, paste0(".", extension))) 
      return(sprintf("File must have extension '.%s'", extension))
  }
  return(checkAccess(dn, "w"))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_posixct
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE) 
{
  .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE) 
{
  .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_r6
list(`package:checkmate` = function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("R6", quietly = TRUE)) 
    stop("Install package 'R6' to perform checks of R6 classes")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be an R6 class, not 'NULL'")
  }
  if (!R6::is.R6(x)) 
    return(paste0("Must be an R6 class", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  checkClass(x, c(classes, "R6"), ordered) %and% checkR6Props(x, cloneable, public, private)
}, function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("R6", quietly = TRUE)) 
    stop("Install package 'R6' to perform checks of R6 classes")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be an R6 class, not 'NULL'")
  }
  if (!R6::is.R6(x)) 
    return(paste0("Must be an R6 class", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  checkClass(x, c(classes, "R6"), ordered) %and% checkR6Props(x, cloneable, public, private)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_raw
list(`package:checkmate` = function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
}, function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_scalar
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE) 
{
  .Call(c_check_scalar, x, na.ok, null.ok)
}, function (x, na.ok = FALSE, null.ok = FALSE) 
{
  .Call(c_check_scalar, x, na.ok, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_scalar_na
list(`package:checkmate` = function (x, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a scalar missing value, not 'NULL'")
  }
  if (length(x) != 1 || !is.na(x)) 
    return(paste0("Must be a scalar missing value", if (null.ok) " (or 'NULL')" else ""))
  return(TRUE)
}, function (x, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a scalar missing value, not 'NULL'")
  }
  if (length(x) != 1 || !is.na(x)) 
    return(paste0("Must be a scalar missing value", if (null.ok) " (or 'NULL')" else ""))
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_set_equal
list(`package:checkmate` = function (x, y, ordered = FALSE, fmatch = FALSE) 
{
  qassert(x, "a")
  qassert(y, "a")
  qassert(ordered, "B1")
  if (ordered) {
    if (!isSameType(x, y) || length(x) != length(y) || any(xor(is.na(x), is.na(y)) | x != y, na.rm = TRUE)) 
      return(sprintf("Must be equal to %s, but is %s", array_collapse(y), array_collapse(x)))
    return(TRUE)
  }
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_set_equal_internal(x, y, match)
}, function (x, y, ordered = FALSE, fmatch = FALSE) 
{
  qassert(x, "a")
  qassert(y, "a")
  qassert(ordered, "B1")
  if (ordered) {
    if (!isSameType(x, y) || length(x) != length(y) || any(xor(is.na(x), is.na(y)) | x != y, na.rm = TRUE)) 
      return(sprintf("Must be equal to %s, but is %s", array_collapse(y), array_collapse(x)))
    return(TRUE)
  }
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_set_equal_internal(x, y, match)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_string
list(`package:checkmate` = function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE) 
{
  .Call(c_check_string, x, na.ok, n.chars, min.chars, max.chars, null.ok) %and% checkCharacterPattern(x, pattern, fixed, ignore.case)
}, function (x, ..., what = "a single string", arg = caller_arg(x), call = caller_env()) 
{
  if (!is_string(x)) {
    stop_input_type(x, what, ..., arg = arg, call = call)
  }
}, function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE) 
{
  .Call(c_check_string, x, na.ok, n.chars, min.chars, max.chars, null.ok) %and% checkCharacterPattern(x, pattern, fixed, ignore.case)
}, function (x) 
{
  stopifnot(is_string(x))
})
c("package:checkmate", "namespace:rlang", "namespace:checkmate", "namespace:crayon")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, FALSE)
check_subset
list(`package:checkmate` = function (x, choices, empty.ok = TRUE, fmatch = FALSE) 
{
  qassert(empty.ok, "B1")
  if (length(x) == 0) {
    if (!empty.ok) 
      return(sprintf("Must be a subset of %s, not empty", set_collapse(choices)))
    return(TRUE)
  }
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_subset_internal(x, choices, match)
}, function (x, choices, empty.ok = TRUE, fmatch = FALSE) 
{
  qassert(empty.ok, "B1")
  if (length(x) == 0) {
    if (!empty.ok) 
      return(sprintf("Must be a subset of %s, not empty", set_collapse(choices)))
    return(TRUE)
  }
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_subset_internal(x, choices, match)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_tibble
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("tibble", quietly = TRUE)) 
    stop("Install package 'tibble' to perform checks of tibbles")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a tibble, not 'NULL'")
  }
  if (!tibble::is_tibble(x)) 
    return(paste0("Must be a tibble", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("tibble", quietly = TRUE)) 
    stop("Install package 'tibble' to perform checks of tibbles")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a tibble, not 'NULL'")
  }
  if (!tibble::is_tibble(x)) 
    return(paste0("Must be a tibble", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
}, function () 
{
  if (!is_installed("tibble")) {
    abort("The tibble package must be installed")
  }
})
c("package:checkmate", "namespace:checkmate", "namespace:purrr")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
check_true
list(`package:checkmate` = function (x, na.ok = FALSE) 
{
  qassert(na.ok, "B1")
  if (isTRUE(x) || (na.ok && length(x) == 1 && is.na(x))) 
    return(TRUE)
  return("Must be TRUE")
}, function (x, na.ok = FALSE) 
{
  qassert(na.ok, "B1")
  if (isTRUE(x) || (na.ok && length(x) == 1 && is.na(x))) 
    return(TRUE)
  return("Must be TRUE")
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
check_vector
list(`package:checkmate` = function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
}, function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkAccess
list(`package:checkmate` = function (x, access = "") 
{
  qassert(access, "S1")
  if (nzchar(access)) {
    access = strsplit(access, "")[[1]]
    if (anyDuplicated(access) > 0 || !all(access %in% c("r", "w", "x"))) 
      stop("Access pattern invalid, allowed are 'r', 'w' and 'x'")
    is.win = .Platform$OS.type == "windows"
    is.root = (!is.win && Sys.info()["user"] == "root")
    if ("r" %in% access || is.root) {
      w = wf(file.access(x, 4) != 0)
      if (length(w) > 0) 
        return(sprintf("'%s' not readable", x[w]))
    }
    if (!is.win) {
      if ("w" %in% access || is.root) {
        w = wf(file.access(x, 2) != 0)
        if (length(w) > 0) 
          return(sprintf("'%s' not writeable", x[w]))
      }
      if ("x" %in% access) {
        w = wf(file.access(x, 1) != 0)
        if (length(w) > 0) 
          return(sprintf("'%s' not executable", x[w]))
      }
    }
  }
  return(TRUE)
}, function (x, access = "") 
{
  qassert(access, "S1")
  if (nzchar(access)) {
    access = strsplit(access, "")[[1]]
    if (anyDuplicated(access) > 0 || !all(access %in% c("r", "w", "x"))) 
      stop("Access pattern invalid, allowed are 'r', 'w' and 'x'")
    is.win = .Platform$OS.type == "windows"
    is.root = (!is.win && Sys.info()["user"] == "root")
    if ("r" %in% access || is.root) {
      w = wf(file.access(x, 4) != 0)
      if (length(w) > 0) 
        return(sprintf("'%s' not readable", x[w]))
    }
    if (!is.win) {
      if ("w" %in% access || is.root) {
        w = wf(file.access(x, 2) != 0)
        if (length(w) > 0) 
          return(sprintf("'%s' not writeable", x[w]))
      }
      if ("x" %in% access) {
        w = wf(file.access(x, 1) != 0)
        if (length(w) > 0) 
          return(sprintf("'%s' not executable", x[w]))
      }
    }
  }
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkArray
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE) 
{
  .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
}, function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE) 
{
  .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkAtomic
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkAtomicVector
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkCharacter
list(`package:checkmate` = function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_character, x, n.chars, min.chars, max.chars, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok) %and% checkCharacterPattern(x, pattern, fixed, ignore.case)
}, function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_character, x, n.chars, min.chars, max.chars, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok) %and% checkCharacterPattern(x, pattern, fixed, ignore.case)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkChoice
list(`package:checkmate` = function (x, choices, null.ok = FALSE, fmatch = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    qassert(choices, "a")
    return(sprintf("Must be a subset of %s, not 'NULL'", set_collapse(choices)))
  }
  qassert(choices, "a")
  if (!qtest(x, "a1")) 
    return(sprintf("Must be element of set %s, but is not atomic scalar", set_collapse(choices)))
  if (!isSameType(x, choices) && !allMissing(x)) 
    return(sprintf("Must be element of set %s, but types do not match (%s != %s)", set_collapse(choices), class(x)[1], class(choices)[1]))
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  if (match(x, choices, 0) == 0) 
    return(sprintf("Must be element of set %s, but is '%s'", set_collapse(choices), x))
  return(TRUE)
}, function (x, choices, null.ok = FALSE, fmatch = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    qassert(choices, "a")
    return(sprintf("Must be a subset of %s, not 'NULL'", set_collapse(choices)))
  }
  qassert(choices, "a")
  if (!qtest(x, "a1")) 
    return(sprintf("Must be element of set %s, but is not atomic scalar", set_collapse(choices)))
  if (!isSameType(x, choices) && !allMissing(x)) 
    return(sprintf("Must be element of set %s, but types do not match (%s != %s)", set_collapse(choices), class(x)[1], class(choices)[1]))
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  if (match(x, choices, 0) == 0) 
    return(sprintf("Must be element of set %s, but is '%s'", set_collapse(choices), x))
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkClass
list(`package:checkmate` = function (x, classes, ordered = FALSE, null.ok = FALSE) 
{
  qassert(classes, "S+")
  qassert(ordered, "B1")
  qassert(null.ok, "B1")
  if (is.null(x) && null.ok) 
    return(TRUE)
  ord = inherits(x, classes, TRUE)
  w = wf(ord == 0)
  if (length(w) > 0) {
    cl = class(x)
    return(sprintf("Must inherit from class '%s', but has class%s '%s'", classes[w], if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
  }
  if (ordered) {
    w = wf(ord != seq_along(ord))
    if (length(w) > 0) {
      cl = class(x)
      return(sprintf("Must have class '%s' in position %i, but has class%s '%s'", classes[w], w, if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
    }
  }
  return(TRUE)
}, function (x, classes, ordered = FALSE, null.ok = FALSE) 
{
  qassert(classes, "S+")
  qassert(ordered, "B1")
  qassert(null.ok, "B1")
  if (is.null(x) && null.ok) 
    return(TRUE)
  ord = inherits(x, classes, TRUE)
  w = wf(ord == 0)
  if (length(w) > 0) {
    cl = class(x)
    return(sprintf("Must inherit from class '%s', but has class%s '%s'", classes[w], if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
  }
  if (ordered) {
    w = wf(ord != seq_along(ord))
    if (length(w) > 0) {
      cl = class(x)
      return(sprintf("Must have class '%s' in position %i, but has class%s '%s'", classes[w], w, if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
    }
  }
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkComplex
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkCount
list(`package:checkmate` = function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  .Call(c_check_count, x, na.ok, positive, tol, null.ok)
}, function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  .Call(c_check_count, x, na.ok, positive, tol, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkDataFrame
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  .Call(c_check_dataframe, x, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok) %and% checkListTypes(x, types)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  .Call(c_check_dataframe, x, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok) %and% checkListTypes(x, types)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkDataTable
list(`package:checkmate` = function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("data.table", quietly = TRUE)) 
    stop("Install package 'data.table' to perform checks of data tables")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a data.table, not 'NULL'")
  }
  if (!data.table::is.data.table(x)) {
    return(paste0("Must be a data.table", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  }
  checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok = FALSE) %and% checkDataTableProps(x, key, index)
}, function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("data.table", quietly = TRUE)) 
    stop("Install package 'data.table' to perform checks of data tables")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a data.table, not 'NULL'")
  }
  if (!data.table::is.data.table(x)) {
    return(paste0("Must be a data.table", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  }
  checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok = FALSE) %and% checkDataTableProps(x, key, index)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkDate
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be of class 'Date', not 'NULL'")
  }
  if (!inherits(x, "Date")) 
    return(sprintf("Must be of class 'Date'%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  checkInteger(as.integer(x), any.missing = any.missing, all.missing = all.missing, len = len, min.len = min.len, max.len = max.len, unique = unique) %and% checkDateBounds(x, lower, upper)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be of class 'Date', not 'NULL'")
  }
  if (!inherits(x, "Date")) 
    return(sprintf("Must be of class 'Date'%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  checkInteger(as.integer(x), any.missing = any.missing, all.missing = all.missing, len = len, min.len = min.len, max.len = max.len, unique = unique) %and% checkDateBounds(x, lower, upper)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkDirectory
list(`package:checkmate` = function (x, access = "") 
{
  if (!qtest(x, "S+")) 
    return("No directory provided")
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory '%s' does not exist", x[w]))
  w = wf(!dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory expected, but file in place: '%s'", x[w]))
  checkAccess(x, access)
}, function (x, access = "") 
{
  if (!qtest(x, "S+")) 
    return("No directory provided")
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory '%s' does not exist", x[w]))
  w = wf(!dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory expected, but file in place: '%s'", x[w]))
  checkAccess(x, access)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkDirectoryExists
list(`package:checkmate` = function (x, access = "") 
{
  if (!qtest(x, "S+")) 
    return("No directory provided")
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory '%s' does not exist", x[w]))
  w = wf(!dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory expected, but file in place: '%s'", x[w]))
  checkAccess(x, access)
}, function (x, access = "") 
{
  if (!qtest(x, "S+")) 
    return("No directory provided")
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory '%s' does not exist", x[w]))
  w = wf(!dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("Directory expected, but file in place: '%s'", x[w]))
  checkAccess(x, access)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkDisjunct
list(`package:checkmate` = function (x, y, fmatch = FALSE) 
{
  qassert(x, "a")
  qassert(y, "a")
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_disjunct_internal(x, y, match)
}, function (x, y, fmatch = FALSE) 
{
  qassert(x, "a")
  qassert(y, "a")
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_disjunct_internal(x, y, match)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkDouble
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkEnvironment
list(`package:checkmate` = function (x, contains = character(0), null.ok = FALSE) 
{
  qassert(contains, "S")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be an environment, not 'NULL'")
  }
  if (!is.environment(x)) 
    return(sprintf("Must be an environment%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  if (length(contains) > 0) {
    w = wf(contains %nin% ls(x, all.names = TRUE))
    if (length(w) > 0) 
      return(sprintf("Must contain an object with name '%s'", contains[w]))
  }
  return(TRUE)
}, function (x, contains = character(0), null.ok = FALSE) 
{
  qassert(contains, "S")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be an environment, not 'NULL'")
  }
  if (!is.environment(x)) 
    return(sprintf("Must be an environment%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  if (length(contains) > 0) {
    w = wf(contains %nin% ls(x, all.names = TRUE))
    if (length(w) > 0) 
      return(sprintf("Must contain an object with name '%s'", contains[w]))
  }
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkFactor
list(`package:checkmate` = function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_factor, x, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok) %and% checkFactorLevels(x, levels, ordered, empty.levels.ok, n.levels, min.levels, max.levels)
}, function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_factor, x, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok) %and% checkFactorLevels(x, levels, ordered, empty.levels.ok, n.levels, min.levels, max.levels)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkFALSE
list(`package:checkmate` = function (x, na.ok = FALSE) 
{
  qassert(na.ok, "B1")
  if (isFALSE(x) || (na.ok && length(x) == 1 && is.na(x))) 
    return(TRUE)
  return("Must be FALSE")
}, function (x, na.ok = FALSE) 
{
  qassert(na.ok, "B1")
  if (isFALSE(x) || (na.ok && length(x) == 1 && is.na(x))) 
    return(TRUE)
  return("Must be FALSE")
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkFile
list(`package:checkmate` = function (x, access = "", extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No file provided")
  w = wf(dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("File expected, but directory in place: '%s'", x[w]))
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("File does not exist: '%s'", x[w]))
  checkAccess(x, access) %and% checkFileExtension(x, extension)
}, function (x, access = "", extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No file provided")
  w = wf(dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("File expected, but directory in place: '%s'", x[w]))
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("File does not exist: '%s'", x[w]))
  checkAccess(x, access) %and% checkFileExtension(x, extension)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkFileExists
list(`package:checkmate` = function (x, access = "", extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No file provided")
  w = wf(dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("File expected, but directory in place: '%s'", x[w]))
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("File does not exist: '%s'", x[w]))
  checkAccess(x, access) %and% checkFileExtension(x, extension)
}, function (x, access = "", extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No file provided")
  w = wf(dir.exists(x))
  if (length(w) > 0) 
    return(sprintf("File expected, but directory in place: '%s'", x[w]))
  w = wf(!file.exists(x))
  if (length(w) > 0) 
    return(sprintf("File does not exist: '%s'", x[w]))
  checkAccess(x, access) %and% checkFileExtension(x, extension)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkFlag
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE) 
{
  .Call(c_check_flag, x, na.ok, null.ok)
}, function (x, na.ok = FALSE, null.ok = FALSE) 
{
  .Call(c_check_flag, x, na.ok, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkFormula
list(`package:checkmate` = function (x, null.ok = FALSE) 
{
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a formula, not 'NULL'")
  }
  if (!inherits(x, "formula")) 
    return(sprintf("Must be a formula%s, not %s", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  return(TRUE)
}, function (x, null.ok = FALSE) 
{
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a formula, not 'NULL'")
  }
  if (!inherits(x, "formula")) 
    return(sprintf("Must be a formula%s, not %s", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkFunction
list(`package:checkmate` = function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a function, not 'NULL'")
  }
  if (!is.function(x)) 
    return(sprintf("Must be a function%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  if (!is.null(args)) {
    qassert(args, "S")
    fargs = names(formals(args(x))) %??% character()
    if (length(args) == 0) {
      if (length(fargs) > 0) 
        return("May not have any arguments")
      return(TRUE)
    }
    qassert(ordered, "B1")
    if (ordered) {
      if (length(fargs) < length(args) || any(args != head(fargs, length(args)))) {
        return(sprintf("Must have first formal arguments (ordered): %s", paste0(args, collapse = ",")))
      }
    }
    else {
      tmp = setdiff(args, fargs)
      if (length(tmp)) 
        return(sprintf("Must have formal arguments: %s", paste0(tmp, collapse = ",")))
    }
  }
  if (!is.null(nargs)) {
    nargs = asCount(nargs)
    fnargs = length(setdiff(names(formals(args(x))) %??% character(0), "..."))
    if (nargs != fnargs) 
      return(sprintf("Must have exactly %i formal arguments, but has %i", nargs, fnargs))
  }
  return(TRUE)
}, function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a function, not 'NULL'")
  }
  if (!is.function(x)) 
    return(sprintf("Must be a function%s, not '%s'", if (null.ok) " (or 'NULL')" else "", guessType(x)))
  if (!is.null(args)) {
    qassert(args, "S")
    fargs = names(formals(args(x))) %??% character()
    if (length(args) == 0) {
      if (length(fargs) > 0) 
        return("May not have any arguments")
      return(TRUE)
    }
    qassert(ordered, "B1")
    if (ordered) {
      if (length(fargs) < length(args) || any(args != head(fargs, length(args)))) {
        return(sprintf("Must have first formal arguments (ordered): %s", paste0(args, collapse = ",")))
      }
    }
    else {
      tmp = setdiff(args, fargs)
      if (length(tmp)) 
        return(sprintf("Must have formal arguments: %s", paste0(tmp, collapse = ",")))
    }
  }
  if (!is.null(nargs)) {
    nargs = asCount(nargs)
    fnargs = length(setdiff(names(formals(args(x))) %??% character(0), "..."))
    if (nargs != fnargs) 
      return(sprintf("Must have exactly %i formal arguments, but has %i", nargs, fnargs))
  }
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkInt
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkInteger
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
}, function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkIntegerish
list(`package:checkmate` = function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
}, function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkList
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_list, x, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok) %and% checkListTypes(x, types)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_list, x, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok) %and% checkListTypes(x, types)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkLogical
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkMatrix
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
}, function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkMultiClass
list(`package:checkmate` = function (x, classes, null.ok = FALSE) 
{
  qassert(classes, "S+")
  qassert(null.ok, "B1")
  if (is.null(x) && null.ok) 
    return(TRUE)
  if (!inherits(x, classes)) {
    cl = class(x)
    return(sprintf("Must inherit from class '%s', but has class%s '%s'", paste0(classes, collapse = "'/'"), if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
  }
  return(TRUE)
}, function (x, classes, null.ok = FALSE) 
{
  qassert(classes, "S+")
  qassert(null.ok, "B1")
  if (is.null(x) && null.ok) 
    return(TRUE)
  if (!inherits(x, classes)) {
    cl = class(x)
    return(sprintf("Must inherit from class '%s', but has class%s '%s'", paste0(classes, collapse = "'/'"), if (length(cl) > 1) "es" else "", paste0(cl, collapse = "','")))
  }
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkNamed
list(`package:checkmate` = function (x, type = "named") 
{
  .Deprecated(new = "checkNames", old = "checkNamed", package = "checkmate")
  .Call(c_check_named, x, type)
}, function (x, type = "named") 
{
  .Deprecated(new = "checkNames", old = "checkNamed", package = "checkmate")
  .Call(c_check_named, x, type)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkNames
list(`package:checkmate` = function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names") 
{
  .Call(c_check_names, x, type, what) %and% checkNamesCmp(x, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
}, function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names") 
{
  .Call(c_check_names, x, type, what) %and% checkNamesCmp(x, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkNull
list(`package:checkmate` = function (x) 
{
  if (!is.null(x)) 
    return("Must be NULL")
  return(TRUE)
}, function (x) 
{
  if (!is.null(x)) 
    return("Must be NULL")
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkNumber
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE) 
{
  .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE) 
{
  .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkNumeric
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkOS
list(`package:checkmate` = function (os) 
{
  ok = match.arg(os, c("windows", "mac", "linux", "solaris"), several.ok = TRUE)
  if (checkmate$os %nin% ok) 
    return(sprintf("OS must be %s", paste0(ok, collapse = " or ")))
  return(TRUE)
}, function (os) 
{
  ok = match.arg(os, c("windows", "mac", "linux", "solaris"), several.ok = TRUE)
  if (checkmate$os %nin% ok) 
    return(sprintf("OS must be %s", paste0(ok, collapse = " or ")))
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkPathForOutput
list(`package:checkmate` = function (x, overwrite = FALSE, extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No path provided")
  qassert(overwrite, "B1")
  x = normalizePath(x, mustWork = FALSE)
  dn = dirname(x)
  w = wf(!dir.exists(dn))
  if (length(w) > 0) 
    return(sprintf("Path to file (dirname) does not exist: '%s' of '%s'", dn[w], x[w]))
  w = which(file.exists(x))
  if (length(w) > 0) {
    if (overwrite) 
      return(checkAccess(dn, "w") %and% checkAccess(x[w], "rw"))
    return(sprintf("File at path already exists: '%s'", x[w]))
  }
  if (!is.null(extension)) {
    qassert(extension, "S1")
    if (!endsWith(x, paste0(".", extension))) 
      return(sprintf("File must have extension '.%s'", extension))
  }
  return(checkAccess(dn, "w"))
}, function (x, overwrite = FALSE, extension = NULL) 
{
  if (!qtest(x, "S+")) 
    return("No path provided")
  qassert(overwrite, "B1")
  x = normalizePath(x, mustWork = FALSE)
  dn = dirname(x)
  w = wf(!dir.exists(dn))
  if (length(w) > 0) 
    return(sprintf("Path to file (dirname) does not exist: '%s' of '%s'", dn[w], x[w]))
  w = which(file.exists(x))
  if (length(w) > 0) {
    if (overwrite) 
      return(checkAccess(dn, "w") %and% checkAccess(x[w], "rw"))
    return(sprintf("File at path already exists: '%s'", x[w]))
  }
  if (!is.null(extension)) {
    qassert(extension, "S1")
    if (!endsWith(x, paste0(".", extension))) 
      return(sprintf("File must have extension '.%s'", extension))
  }
  return(checkAccess(dn, "w"))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkPOSIXct
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE) 
{
  .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE) 
{
  .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkR6
list(`package:checkmate` = function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("R6", quietly = TRUE)) 
    stop("Install package 'R6' to perform checks of R6 classes")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be an R6 class, not 'NULL'")
  }
  if (!R6::is.R6(x)) 
    return(paste0("Must be an R6 class", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  checkClass(x, c(classes, "R6"), ordered) %and% checkR6Props(x, cloneable, public, private)
}, function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("R6", quietly = TRUE)) 
    stop("Install package 'R6' to perform checks of R6 classes")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be an R6 class, not 'NULL'")
  }
  if (!R6::is.R6(x)) 
    return(paste0("Must be an R6 class", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  checkClass(x, c(classes, "R6"), ordered) %and% checkR6Props(x, cloneable, public, private)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkRaw
list(`package:checkmate` = function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
}, function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkScalar
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE) 
{
  .Call(c_check_scalar, x, na.ok, null.ok)
}, function (x, na.ok = FALSE, null.ok = FALSE) 
{
  .Call(c_check_scalar, x, na.ok, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkScalarNA
list(`package:checkmate` = function (x, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a scalar missing value, not 'NULL'")
  }
  if (length(x) != 1 || !is.na(x)) 
    return(paste0("Must be a scalar missing value", if (null.ok) " (or 'NULL')" else ""))
  return(TRUE)
}, function (x, null.ok = FALSE) 
{
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a scalar missing value, not 'NULL'")
  }
  if (length(x) != 1 || !is.na(x)) 
    return(paste0("Must be a scalar missing value", if (null.ok) " (or 'NULL')" else ""))
  return(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkSetEqual
list(`package:checkmate` = function (x, y, ordered = FALSE, fmatch = FALSE) 
{
  qassert(x, "a")
  qassert(y, "a")
  qassert(ordered, "B1")
  if (ordered) {
    if (!isSameType(x, y) || length(x) != length(y) || any(xor(is.na(x), is.na(y)) | x != y, na.rm = TRUE)) 
      return(sprintf("Must be equal to %s, but is %s", array_collapse(y), array_collapse(x)))
    return(TRUE)
  }
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_set_equal_internal(x, y, match)
}, function (x, y, ordered = FALSE, fmatch = FALSE) 
{
  qassert(x, "a")
  qassert(y, "a")
  qassert(ordered, "B1")
  if (ordered) {
    if (!isSameType(x, y) || length(x) != length(y) || any(xor(is.na(x), is.na(y)) | x != y, na.rm = TRUE)) 
      return(sprintf("Must be equal to %s, but is %s", array_collapse(y), array_collapse(x)))
    return(TRUE)
  }
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_set_equal_internal(x, y, match)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkString
list(`package:checkmate` = function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE) 
{
  .Call(c_check_string, x, na.ok, n.chars, min.chars, max.chars, null.ok) %and% checkCharacterPattern(x, pattern, fixed, ignore.case)
}, function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE) 
{
  .Call(c_check_string, x, na.ok, n.chars, min.chars, max.chars, null.ok) %and% checkCharacterPattern(x, pattern, fixed, ignore.case)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkSubset
list(`package:checkmate` = function (x, choices, empty.ok = TRUE, fmatch = FALSE) 
{
  qassert(empty.ok, "B1")
  if (length(x) == 0) {
    if (!empty.ok) 
      return(sprintf("Must be a subset of %s, not empty", set_collapse(choices)))
    return(TRUE)
  }
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_subset_internal(x, choices, match)
}, function (x, choices, empty.ok = TRUE, fmatch = FALSE) 
{
  qassert(empty.ok, "B1")
  if (length(x) == 0) {
    if (!empty.ok) 
      return(sprintf("Must be a subset of %s, not empty", set_collapse(choices)))
    return(TRUE)
  }
  if (isTRUE(fmatch) && requireNamespace("fastmatch", quietly = TRUE)) 
    match = fastmatch::fmatch
  check_subset_internal(x, choices, match)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkTibble
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("tibble", quietly = TRUE)) 
    stop("Install package 'tibble' to perform checks of tibbles")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a tibble, not 'NULL'")
  }
  if (!tibble::is_tibble(x)) 
    return(paste0("Must be a tibble", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  if (!requireNamespace("tibble", quietly = TRUE)) 
    stop("Install package 'tibble' to perform checks of tibbles")
  qassert(null.ok, "B1")
  if (is.null(x)) {
    if (null.ok) 
      return(TRUE)
    return("Must be a tibble, not 'NULL'")
  }
  if (!tibble::is_tibble(x)) 
    return(paste0("Must be a tibble", if (null.ok) " (or 'NULL')" else "", sprintf(", not %s", guessType(x))))
  checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkTRUE
list(`package:checkmate` = function (x, na.ok = FALSE) 
{
  qassert(na.ok, "B1")
  if (isTRUE(x) || (na.ok && length(x) == 1 && is.na(x))) 
    return(TRUE)
  return("Must be TRUE")
}, function (x, na.ok = FALSE) 
{
  qassert(na.ok, "B1")
  if (isTRUE(x) || (na.ok && length(x) == 1 && is.na(x))) 
    return(TRUE)
  return("Must be TRUE")
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkVector
list(`package:checkmate` = function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
}, function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  .Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_access
list(`package:checkmate` = function (x, access = "", info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkAccess(x, access)
  makeExpectation(x, res, info, label)
}, function (x, access = "", info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkAccess(x, access)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_array
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_atomic
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeExpectation(x, res, info, label)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_atomic_vector
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeExpectation(x, res, info, label)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_character
list(`package:checkmate` = function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_choice
list(`package:checkmate` = function (x, choices, null.ok = FALSE, fmatch = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkChoice(x, choices, null.ok, fmatch)
  makeExpectation(x, res, info, label)
}, function (x, choices, null.ok = FALSE, fmatch = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkChoice(x, choices, null.ok, fmatch)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_class
list(`package:checkmate` = function (x, classes, ordered = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkClass(x, classes, ordered, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, classes, ordered = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkClass(x, classes, ordered, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_complex
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_count
list(`package:checkmate` = function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_count, x, na.ok, positive, tol, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_count, x, na.ok, positive, tol, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_data_frame
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_data_table
list(`package:checkmate` = function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_date
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_directory
list(`package:checkmate` = function (x, access = "", info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDirectoryExists(x, access)
  makeExpectation(x, res, info, label)
}, function (x, access = "", info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDirectoryExists(x, access)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_directory_exists
list(`package:checkmate` = function (x, access = "", info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDirectoryExists(x, access)
  makeExpectation(x, res, info, label)
}, function (x, access = "", info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDirectoryExists(x, access)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_disjunct
list(`package:checkmate` = function (x, y, fmatch = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDisjunct(x, y, fmatch)
  makeExpectation(x, res, info, label)
}, function (x, y, fmatch = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkDisjunct(x, y, fmatch)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_double
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_environment
list(`package:checkmate` = function (x, contains = character(0), null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkEnvironment(x, contains, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, contains = character(0), null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkEnvironment(x, contains, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_factor
list(`package:checkmate` = function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_file
list(`package:checkmate` = function (x, access = "", extension = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFileExists(x, access, extension)
  makeExpectation(x, res, info, label)
}, function (x, access = "", extension = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFileExists(x, access, extension)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_file_exists
list(`package:checkmate` = function (x, access = "", extension = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFileExists(x, access, extension)
  makeExpectation(x, res, info, label)
}, function (x, access = "", extension = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFileExists(x, access, extension)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_flag
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_flag, x, na.ok, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, na.ok = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_flag, x, na.ok, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_formula
list(`package:checkmate` = function (x, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFormula(x, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFormula(x, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_function
list(`package:checkmate` = function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFunction(x, args, ordered, nargs, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkFunction(x, args, ordered, nargs, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_int
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_int, x, na.ok, lower, upper, tol, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_integer
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_integerish
list(`package:checkmate` = function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_list
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_logical
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_matrix
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_multi_class
list(`package:checkmate` = function (x, classes, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkMultiClass(x, classes, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, classes, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkMultiClass(x, classes, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_names
list(`package:checkmate` = function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names", info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
  makeExpectation(x, res, info, label)
}, function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names", info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_number
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_number, x, na.ok, lower, upper, finite, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_numeric
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_os
list(`package:checkmate` = function (os, info = NULL, label = NULL) 
{
  res = checkOS(os)
  makeExpectation(checkmate$os, res, info, label = label %??% "Operating System")
}, function (os, info = NULL, label = NULL) 
{
  res = checkOS(os)
  makeExpectation(checkmate$os, res, info, label = label %??% "Operating System")
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_path_for_output
list(`package:checkmate` = function (x, overwrite = FALSE, extension = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkPathForOutput(x, overwrite, extension)
  makeExpectation(x, res, info, label)
}, function (x, overwrite = FALSE, extension = NULL, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkPathForOutput(x, overwrite, extension)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_posixct
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_r6
list(`package:checkmate` = function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkR6(x, classes, ordered, cloneable, public, private, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkR6(x, classes, ordered, cloneable, public, private, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_raw
list(`package:checkmate` = function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_raw, x, len, min.len, max.len, names, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_scalar
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_scalar, x, na.ok, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, na.ok = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = .Call(c_check_scalar, x, na.ok, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_scalar_na
list(`package:checkmate` = function (x, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkScalarNA(x, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkScalarNA(x, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_set_equal
list(`package:checkmate` = function (x, y, ordered = FALSE, fmatch = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkSetEqual(x, y, ordered, fmatch)
  makeExpectation(x, res, info, label)
}, function (x, y, ordered = FALSE, fmatch = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkSetEqual(x, y, ordered, fmatch)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_string
list(`package:checkmate` = function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_subset
list(`package:checkmate` = function (x, choices, empty.ok = TRUE, fmatch = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkSubset(x, choices, empty.ok, fmatch)
  makeExpectation(x, res, info, label)
}, function (x, choices, empty.ok = TRUE, fmatch = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkSubset(x, choices, empty.ok, fmatch)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
expect_tibble
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeExpectation(x, res, info, label)
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE, info = NULL, label = vname(x)) 
{
  if (missing(x)) 
    stop(sprintf("Argument '%s' is missing", label))
  res = checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok)
  makeExpectation(x, res, info, label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeAssertCollection
list(`package:checkmate` = function () 
{
  msgs = character(0)
  x = list(push = function(msg) msgs <<- c(msgs, msg), getMessages = function() msgs, isEmpty = function() length(msgs) == 0)
  class(x) = "AssertCollection"
  x
}, function () 
{
  msgs = character(0)
  x = list(push = function(msg) msgs <<- c(msgs, msg), getMessages = function() msgs, isEmpty = function() length(msgs) == 0)
  class(x) = "AssertCollection"
  x
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeAssertion
list(`package:checkmate` = function (x, res, var.name, collection) 
{
  if (!isTRUE(res)) {
    assertString(var.name, .var.name = ".var.name")
    if (is.null(collection)) {
      mstop("Assertion on '%s' failed: %s.", var.name, res, call. = sys.call(-2))
    }
    assertClass(collection, "AssertCollection", .var.name = "add")
    collection$push(sprintf("Variable '%s': %s.", var.name, res))
  }
  return(invisible(x))
}, function (x, res, var.name, collection) 
{
  if (!isTRUE(res)) {
    assertString(var.name, .var.name = ".var.name")
    if (is.null(collection)) {
      mstop("Assertion on '%s' failed: %s.", var.name, res, call. = sys.call(-2))
    }
    assertClass(collection, "AssertCollection", .var.name = "add")
    collection$push(sprintf("Variable '%s': %s.", var.name, res))
  }
  return(invisible(x))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeAssertionFunction
list(`package:checkmate` = function (check.fun, c.fun = NULL, use.namespace = TRUE, coerce = FALSE, env = parent.frame()) 
{
  fun.name = if (is.character(check.fun)) 
    check.fun
  else deparse(substitute(check.fun))
  check.fun = match.fun(check.fun)
  check.args = fun.args = formals(args(check.fun))
  x.name = names(fun.args[1])
  new.fun = function() TRUE
  body = sprintf("if (missing(%s)) stop(sprintf(\"argument \\\"%%s\\\" is missing, with no default\", .var.name))", x.name)
  if (is.null(c.fun)) {
    body = paste0(body, sprintf("; res = %s(%s)", fun.name, paste0(names(check.args), collapse = ", ")))
  }
  else {
    body = paste0(body, sprintf("; res = .Call(%s)", paste0(c(c.fun, names(check.args)), collapse = ", ")))
  }
  if (coerce) {
    fun.args = c(fun.args, alist(coerce = FALSE))
  }
  if (use.namespace) {
    fun.args = c(fun.args, list(.var.name = bquote(checkmate::vname(.(as.name(x.name)))), add = NULL))
    body = paste0(body, "; checkmate::makeAssertion")
  }
  else {
    fun.args = c(fun.args, list(.var.name = bquote(vname(.(as.name(x.name)))), add = NULL))
    body = paste0(body, "; makeAssertion")
  }
  body = paste0(body, sprintf("(%s, res, .var.name, add)", x.name))
  if (coerce) {
    body = paste0(body, "; if (isTRUE(coerce) && is.double(x)) x = setNames(as.integer(round(x, 0L)), names(x)); invisible(x)")
  }
  formals(new.fun) = fun.args
  body(new.fun) = parse(text = paste("{", body, "}"))
  environment(new.fun) = env
  return(new.fun)
}, function (check.fun, c.fun = NULL, use.namespace = TRUE, coerce = FALSE, env = parent.frame()) 
{
  fun.name = if (is.character(check.fun)) 
    check.fun
  else deparse(substitute(check.fun))
  check.fun = match.fun(check.fun)
  check.args = fun.args = formals(args(check.fun))
  x.name = names(fun.args[1])
  new.fun = function() TRUE
  body = sprintf("if (missing(%s)) stop(sprintf(\"argument \\\"%%s\\\" is missing, with no default\", .var.name))", x.name)
  if (is.null(c.fun)) {
    body = paste0(body, sprintf("; res = %s(%s)", fun.name, paste0(names(check.args), collapse = ", ")))
  }
  else {
    body = paste0(body, sprintf("; res = .Call(%s)", paste0(c(c.fun, names(check.args)), collapse = ", ")))
  }
  if (coerce) {
    fun.args = c(fun.args, alist(coerce = FALSE))
  }
  if (use.namespace) {
    fun.args = c(fun.args, list(.var.name = bquote(checkmate::vname(.(as.name(x.name)))), add = NULL))
    body = paste0(body, "; checkmate::makeAssertion")
  }
  else {
    fun.args = c(fun.args, list(.var.name = bquote(vname(.(as.name(x.name)))), add = NULL))
    body = paste0(body, "; makeAssertion")
  }
  body = paste0(body, sprintf("(%s, res, .var.name, add)", x.name))
  if (coerce) {
    body = paste0(body, "; if (isTRUE(coerce) && is.double(x)) x = setNames(as.integer(round(x, 0L)), names(x)); invisible(x)")
  }
  formals(new.fun) = fun.args
  body(new.fun) = parse(text = paste("{", body, "}"))
  environment(new.fun) = env
  return(new.fun)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeExpectation
list(`package:checkmate` = function (x, res, info, label) 
{
  backend = get_test_backend()
  if (backend == "testthat") {
    if (!requireNamespace("testthat", quietly = TRUE)) 
      stop("Package 'testthat' is required for checkmate's 'expect_*' extensions with backend 'testthat'")
    if (!is.null(info)) {
      info = sprintf("Additional info: %s", info)
    }
    if (isTRUE(res)) {
      testthat::succeed(info = info)
    }
    else {
      testthat::fail(sprintf("Check on '%s' failed: %s", label, res), info = info)
    }
    invisible(x)
  }
  else {
    if (!requireNamespace("tinytest", quietly = TRUE)) 
      stop("Package 'tinytest' is required for checkmate's 'expect_*' extensions with backend 'tinytest'")
    call = sys.call(sys.parent(1))
    if (isTRUE(res)) {
      tinytest::tinytest(TRUE, call = call)
    }
    else {
      tinytest::tinytest(FALSE, call = call, diff = if (is.character(res)) 
        res
        else "", info = if (is.null(info)) 
          NA
        else info, short = "data")
    }
  }
}, function (x, res, info, label) 
{
  backend = get_test_backend()
  if (backend == "testthat") {
    if (!requireNamespace("testthat", quietly = TRUE)) 
      stop("Package 'testthat' is required for checkmate's 'expect_*' extensions with backend 'testthat'")
    if (!is.null(info)) {
      info = sprintf("Additional info: %s", info)
    }
    if (isTRUE(res)) {
      testthat::succeed(info = info)
    }
    else {
      testthat::fail(sprintf("Check on '%s' failed: %s", label, res), info = info)
    }
    invisible(x)
  }
  else {
    if (!requireNamespace("tinytest", quietly = TRUE)) 
      stop("Package 'tinytest' is required for checkmate's 'expect_*' extensions with backend 'tinytest'")
    call = sys.call(sys.parent(1))
    if (isTRUE(res)) {
      tinytest::tinytest(TRUE, call = call)
    }
    else {
      tinytest::tinytest(FALSE, call = call, diff = if (is.character(res)) 
        res
        else "", info = if (is.null(info)) 
          NA
        else info, short = "data")
    }
  }
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeExpectationFunction
list(`package:checkmate` = function (check.fun, c.fun = NULL, use.namespace = FALSE, env = parent.frame()) 
{
  fun.name = if (!is.character(check.fun)) 
    deparse(substitute(check.fun))
  else check.fun
  check.fun = match.fun(check.fun)
  check.args = fun.args = formals(args(check.fun))
  x.name = names(fun.args[1])
  x = NULL
  new.fun = function() TRUE
  body = sprintf("if (missing(%s)) stop(sprintf(\"Argument '%%s' is missing\", label))", x.name)
  if (is.null(c.fun)) {
    body = paste0(body, sprintf("; res = %s(%s)", fun.name, paste0(names(check.args), collapse = ", ")))
  }
  else {
    body = paste0(body, sprintf("; res = .Call(%s)", paste0(c(c.fun, names(check.args)), collapse = ", ")))
  }
  if (use.namespace) {
    formals(new.fun) = c(fun.args, alist(info = NULL, label = checkmate::vname(x)))
    body = paste0(body, "; checkmate::makeExpectation")
  }
  else {
    formals(new.fun) = c(fun.args, alist(info = NULL, label = vname(x)))
    body = paste0(body, "; makeExpectation")
  }
  body = paste0(body, sprintf("(%s, res, info, label)", x.name))
  body(new.fun) = parse(text = paste("{", body, "}"))
  environment(new.fun) = env
  return(new.fun)
}, function (check.fun, c.fun = NULL, use.namespace = FALSE, env = parent.frame()) 
{
  fun.name = if (!is.character(check.fun)) 
    deparse(substitute(check.fun))
  else check.fun
  check.fun = match.fun(check.fun)
  check.args = fun.args = formals(args(check.fun))
  x.name = names(fun.args[1])
  x = NULL
  new.fun = function() TRUE
  body = sprintf("if (missing(%s)) stop(sprintf(\"Argument '%%s' is missing\", label))", x.name)
  if (is.null(c.fun)) {
    body = paste0(body, sprintf("; res = %s(%s)", fun.name, paste0(names(check.args), collapse = ", ")))
  }
  else {
    body = paste0(body, sprintf("; res = .Call(%s)", paste0(c(c.fun, names(check.args)), collapse = ", ")))
  }
  if (use.namespace) {
    formals(new.fun) = c(fun.args, alist(info = NULL, label = checkmate::vname(x)))
    body = paste0(body, "; checkmate::makeExpectation")
  }
  else {
    formals(new.fun) = c(fun.args, alist(info = NULL, label = vname(x)))
    body = paste0(body, "; makeExpectation")
  }
  body = paste0(body, sprintf("(%s, res, info, label)", x.name))
  body(new.fun) = parse(text = paste("{", body, "}"))
  environment(new.fun) = env
  return(new.fun)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeTest
list(`package:checkmate` = function (res) 
{
  isTRUE(res)
}, function (res) 
{
  isTRUE(res)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeTestFunction
list(`package:checkmate` = function (check.fun, c.fun = NULL, env = parent.frame()) 
{
  fun.name = if (is.character(check.fun)) 
    check.fun
  else deparse(substitute(check.fun))
  check.fun = match.fun(check.fun)
  fun.args = formals(args(check.fun))
  new.fun = function() TRUE
  formals(new.fun) = fun.args
  if (is.null(c.fun)) {
    body = paste0("isTRUE(", fun.name, "(", paste0(names(fun.args), collapse = ", "), "))")
  }
  else {
    body = paste0("isTRUE(.Call(", paste0(c(c.fun, names(fun.args)), collapse = ", "), "))")
  }
  body(new.fun) = parse(text = paste("{", body, "}"))
  environment(new.fun) = env
  return(new.fun)
}, function (check.fun, c.fun = NULL, env = parent.frame()) 
{
  fun.name = if (is.character(check.fun)) 
    check.fun
  else deparse(substitute(check.fun))
  check.fun = match.fun(check.fun)
  fun.args = formals(args(check.fun))
  new.fun = function() TRUE
  formals(new.fun) = fun.args
  if (is.null(c.fun)) {
    body = paste0("isTRUE(", fun.name, "(", paste0(names(fun.args), collapse = ", "), "))")
  }
  else {
    body = paste0("isTRUE(.Call(", paste0(c(c.fun, names(fun.args)), collapse = ", "), "))")
  }
  body(new.fun) = parse(text = paste("{", body, "}"))
  environment(new.fun) = env
  return(new.fun)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
matchArg
list(`package:checkmate` = function (x, choices, several.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  assertCharacter(choices, min.len = 1)
  assertFlag(several.ok)
  if (several.ok) {
    if (identical(x, choices)) 
      return(x)
    assertCharacter(x, min.len = 1, .var.name = .var.name, add = add)
    x = choices[pmatch(x, choices, nomatch = 0, duplicates.ok = TRUE)]
    assertSubset(x, choices, empty.ok = FALSE, .var.name = .var.name, add = add)
  }
  else {
    if (identical(x, choices)) 
      return(x[1])
    assertCharacter(x, len = 1, .var.name = .var.name, add = add)
    x = choices[pmatch(x, choices, nomatch = 0, duplicates.ok = FALSE)]
    assertChoice(x, choices, .var.name = .var.name, add = add)
  }
  x
}, function (x, choices, several.ok = FALSE, .var.name = vname(x), add = NULL) 
{
  assertCharacter(choices, min.len = 1)
  assertFlag(several.ok)
  if (several.ok) {
    if (identical(x, choices)) 
      return(x)
    assertCharacter(x, min.len = 1, .var.name = .var.name, add = add)
    x = choices[pmatch(x, choices, nomatch = 0, duplicates.ok = TRUE)]
    assertSubset(x, choices, empty.ok = FALSE, .var.name = .var.name, add = add)
  }
  else {
    if (identical(x, choices)) 
      return(x[1])
    assertCharacter(x, len = 1, .var.name = .var.name, add = add)
    x = choices[pmatch(x, choices, nomatch = 0, duplicates.ok = FALSE)]
    assertChoice(x, choices, .var.name = .var.name, add = add)
  }
  x
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
qassert
list(`package:checkmate` = function (x, rules, .var.name = vname(x)) 
{
  res = .Call(c_qassert, x, rules, FALSE)
  if (!isTRUE(res)) 
    mstop(qmsg(res, .var.name), call. = sys.call(-1))
  invisible(x)
}, function (x, rules, .var.name = vname(x)) 
{
  res = .Call(c_qassert, x, rules, FALSE)
  if (!isTRUE(res)) 
    mstop(qmsg(res, .var.name), call. = sys.call(-1))
  invisible(x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
qassertr
list(`package:checkmate` = function (x, rules, .var.name = vname(x)) 
{
  res = .Call(c_qassert, x, rules, TRUE)
  if (!isTRUE(res)) 
    mstop(qrmsg(x, res, .var.name), call. = sys.call(-1))
  invisible(x)
}, function (x, rules, .var.name = vname(x)) 
{
  res = .Call(c_qassert, x, rules, TRUE)
  if (!isTRUE(res)) 
    mstop(qrmsg(x, res, .var.name), call. = sys.call(-1))
  invisible(x)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
qexpect
list(`package:checkmate` = function (x, rules, info = NULL, label = vname(x)) 
{
  res = .Call(c_qassert, x, rules, FALSE)
  if (!isTRUE(res)) 
    res = qmsg(res, label)
  makeExpectation(x, res, info = info, label = label)
}, function (x, rules, info = NULL, label = vname(x)) 
{
  res = .Call(c_qassert, x, rules, FALSE)
  if (!isTRUE(res)) 
    res = qmsg(res, label)
  makeExpectation(x, res, info = info, label = label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
qexpectr
list(`package:checkmate` = function (x, rules, info = NULL, label = vname(x)) 
{
  res = .Call(c_qassert, x, rules, TRUE)
  if (!isTRUE(res)) 
    res = qrmsg(x, res, label)
  makeExpectation(x, res, info = info, label = label)
}, function (x, rules, info = NULL, label = vname(x)) 
{
  res = .Call(c_qassert, x, rules, TRUE)
  if (!isTRUE(res)) 
    res = qrmsg(x, res, label)
  makeExpectation(x, res, info = info, label = label)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
qtest
list(`package:checkmate` = function (x, rules) 
{
  .Call(c_qtest, x, rules, FALSE, 1)
}, function (x, rules) 
{
  .Call(c_qtest, x, rules, FALSE, 1)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
qtestr
list(`package:checkmate` = function (x, rules, depth = 1) 
{
  .Call(c_qtest, x, rules, TRUE, depth)
}, function (x, rules, depth = 1) 
{
  .Call(c_qtest, x, rules, TRUE, depth)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
register_test_backend
list(`package:checkmate` = function (name) 
{
  name = match.arg(name, c("testthat", "tinytest"))
  if (name == "testthat") {
    requireNamespace("testthat")
    test_backend$name = "testthat"
  }
  else {
    requireNamespace("tinytest")
    test_backend$name = "tinytest"
  }
  invisible(NULL)
}, function (name) 
{
  name = match.arg(name, c("testthat", "tinytest"))
  if (name == "testthat") {
    requireNamespace("testthat")
    test_backend$name = "testthat"
  }
  else {
    requireNamespace("tinytest")
    test_backend$name = "tinytest"
  }
  invisible(NULL)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
reportAssertions
list(`package:checkmate` = function (collection) 
{
  assertClass(collection, "AssertCollection")
  if (!collection$isEmpty()) {
    msgs = collection$getMessages()
    context = "%i assertions failed:"
    err = c(sprintf(context, length(msgs)), strwrap(msgs, prefix = " * "))
    stop(simpleError(paste0(err, collapse = "\n"), call = sys.call(1)))
  }
  invisible(TRUE)
}, function (collection) 
{
  assertClass(collection, "AssertCollection")
  if (!collection$isEmpty()) {
    msgs = collection$getMessages()
    context = "%i assertions failed:"
    err = c(sprintf(context, length(msgs)), strwrap(msgs, prefix = " * "))
    stop(simpleError(paste0(err, collapse = "\n"), call = sys.call(1)))
  }
  invisible(TRUE)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_access
list(`package:checkmate` = function (x, access = "") 
{
  isTRUE(checkAccess(x, access))
}, function (x, access = "") 
{
  isTRUE(checkAccess(x, access))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_array
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok))
}, function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_atomic
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  isTRUE(.Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names))
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  isTRUE(.Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_atomic_vector
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  isTRUE(.Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names))
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  isTRUE(.Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_character
list(`package:checkmate` = function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_choice
list(`package:checkmate` = function (x, choices, null.ok = FALSE, fmatch = FALSE) 
{
  isTRUE(checkChoice(x, choices, null.ok, fmatch))
}, function (x, choices, null.ok = FALSE, fmatch = FALSE) 
{
  isTRUE(checkChoice(x, choices, null.ok, fmatch))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_class
list(`package:checkmate` = function (x, classes, ordered = FALSE, null.ok = FALSE) 
{
  isTRUE(checkClass(x, classes, ordered, null.ok))
}, function (x, classes, ordered = FALSE, null.ok = FALSE) 
{
  isTRUE(checkClass(x, classes, ordered, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_complex
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok))
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_count
list(`package:checkmate` = function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  isTRUE(.Call(c_check_count, x, na.ok, positive, tol, null.ok))
}, function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  isTRUE(.Call(c_check_count, x, na.ok, positive, tol, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_data_frame
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_data_table
list(`package:checkmate` = function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
}, function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_date
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE) 
{
  isTRUE(checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok))
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE) 
{
  isTRUE(checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_directory
list(`package:checkmate` = function (x, access = "") 
{
  isTRUE(checkDirectoryExists(x, access))
}, function (x, access = "") 
{
  isTRUE(checkDirectoryExists(x, access))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_directory_exists
list(`package:checkmate` = function (x, access = "") 
{
  isTRUE(checkDirectoryExists(x, access))
}, function (x, access = "") 
{
  isTRUE(checkDirectoryExists(x, access))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_disjunct
list(`package:checkmate` = function (x, y, fmatch = FALSE) 
{
  isTRUE(checkDisjunct(x, y, fmatch))
}, function (x, y, fmatch = FALSE) 
{
  isTRUE(checkDisjunct(x, y, fmatch))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_double
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_environment
list(`package:checkmate` = function (x, contains = character(0), null.ok = FALSE) 
{
  isTRUE(checkEnvironment(x, contains, null.ok))
}, function (x, contains = character(0), null.ok = FALSE) 
{
  isTRUE(checkEnvironment(x, contains, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_factor
list(`package:checkmate` = function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok))
}, function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_false
list(`package:checkmate` = function (x, na.ok = FALSE) 
{
  isTRUE(checkFALSE(x, na.ok))
}, function (x, na.ok = FALSE) 
{
  isTRUE(checkFALSE(x, na.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_file_exists
list(`package:checkmate` = function (x, access = "", extension = NULL) 
{
  isTRUE(checkFileExists(x, access, extension))
}, function (x, access = "", extension = NULL) 
{
  isTRUE(checkFileExists(x, access, extension))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_flag
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_flag, x, na.ok, null.ok))
}, function (x, na.ok = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_flag, x, na.ok, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_formula
list(`package:checkmate` = function (x, null.ok = FALSE) 
{
  isTRUE(checkFormula(x, null.ok))
}, function (x, null.ok = FALSE) 
{
  isTRUE(checkFormula(x, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_function
list(`package:checkmate` = function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE) 
{
  isTRUE(checkFunction(x, args, ordered, nargs, null.ok))
}, function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE) 
{
  isTRUE(checkFunction(x, args, ordered, nargs, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_int
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  isTRUE(.Call(c_check_int, x, na.ok, lower, upper, tol, null.ok))
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  isTRUE(.Call(c_check_int, x, na.ok, lower, upper, tol, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_integer
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_integerish
list(`package:checkmate` = function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_list
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok))
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_logical
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok))
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_matrix
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
}, function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_multi_class
list(`package:checkmate` = function (x, classes, null.ok = FALSE) 
{
  isTRUE(checkMultiClass(x, classes, null.ok))
}, function (x, classes, null.ok = FALSE) 
{
  isTRUE(checkMultiClass(x, classes, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_named
list(`package:checkmate` = function (x, type = "named") 
{
  isTRUE(.Call(c_check_named, x, type))
}, function (x, type = "named") 
{
  isTRUE(.Call(c_check_named, x, type))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_names
list(`package:checkmate` = function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names") 
{
  isTRUE(checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what))
}, function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names") 
{
  isTRUE(checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_null
list(`package:checkmate` = function (x) 
{
  isTRUE(checkNull(x))
}, function (x) 
{
  isTRUE(checkNull(x))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_number
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_number, x, na.ok, lower, upper, finite, null.ok))
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_number, x, na.ok, lower, upper, finite, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_numeric
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_os
list(`package:checkmate` = function (os) 
{
  isTRUE(checkOS(os))
}, function (os) 
{
  isTRUE(checkOS(os))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_path_for_output
list(`package:checkmate` = function (x, overwrite = FALSE, extension = NULL) 
{
  isTRUE(checkPathForOutput(x, overwrite, extension))
}, function (x, overwrite = FALSE, extension = NULL) 
{
  isTRUE(checkPathForOutput(x, overwrite, extension))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_posixct
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok))
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_r6
list(`package:checkmate` = function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE) 
{
  isTRUE(checkR6(x, classes, ordered, cloneable, public, private, null.ok))
}, function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE) 
{
  isTRUE(checkR6(x, classes, ordered, cloneable, public, private, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_raw
list(`package:checkmate` = function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_raw, x, len, min.len, max.len, names, null.ok))
}, function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_raw, x, len, min.len, max.len, names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_scalar
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_scalar, x, na.ok, null.ok))
}, function (x, na.ok = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_scalar, x, na.ok, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_scalar_na
list(`package:checkmate` = function (x, null.ok = FALSE) 
{
  isTRUE(checkScalarNA(x, null.ok))
}, function (x, null.ok = FALSE) 
{
  isTRUE(checkScalarNA(x, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_set_equal
list(`package:checkmate` = function (x, y, ordered = FALSE, fmatch = FALSE) 
{
  isTRUE(checkSetEqual(x, y, ordered, fmatch))
}, function (x, y, ordered = FALSE, fmatch = FALSE) 
{
  isTRUE(checkSetEqual(x, y, ordered, fmatch))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_string
list(`package:checkmate` = function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE) 
{
  isTRUE(checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok))
}, function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE) 
{
  isTRUE(checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_subset
list(`package:checkmate` = function (x, choices, empty.ok = TRUE, fmatch = FALSE) 
{
  isTRUE(checkSubset(x, choices, empty.ok, fmatch))
}, function (x, choices, empty.ok = TRUE, fmatch = FALSE) 
{
  isTRUE(checkSubset(x, choices, empty.ok, fmatch))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_tibble
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_true
list(`package:checkmate` = function (x, na.ok = FALSE) 
{
  isTRUE(checkTRUE(x, na.ok))
}, function (x, na.ok = FALSE) 
{
  isTRUE(checkTRUE(x, na.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
test_vector
list(`package:checkmate` = function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok))
}, function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testAccess
list(`package:checkmate` = function (x, access = "") 
{
  isTRUE(checkAccess(x, access))
}, function (x, access = "") 
{
  isTRUE(checkAccess(x, access))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testArray
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok))
}, function (x, mode = NULL, any.missing = TRUE, d = NULL, min.d = NULL, max.d = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_array, x, mode, any.missing, d, min.d, max.d, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testAtomic
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  isTRUE(.Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names))
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  isTRUE(.Call(c_check_atomic, x, any.missing, all.missing, len, min.len, max.len, unique, names))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testAtomicVector
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  isTRUE(.Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names))
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL) 
{
  isTRUE(.Call(c_check_atomic_vector, x, any.missing, all.missing, len, min.len, max.len, unique, names))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testCharacter
list(`package:checkmate` = function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(checkCharacter(x, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testChoice
list(`package:checkmate` = function (x, choices, null.ok = FALSE, fmatch = FALSE) 
{
  isTRUE(checkChoice(x, choices, null.ok, fmatch))
}, function (x, choices, null.ok = FALSE, fmatch = FALSE) 
{
  isTRUE(checkChoice(x, choices, null.ok, fmatch))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testClass
list(`package:checkmate` = function (x, classes, ordered = FALSE, null.ok = FALSE) 
{
  isTRUE(checkClass(x, classes, ordered, null.ok))
}, function (x, classes, ordered = FALSE, null.ok = FALSE) 
{
  isTRUE(checkClass(x, classes, ordered, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testComplex
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok))
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_complex, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testCount
list(`package:checkmate` = function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  isTRUE(.Call(c_check_count, x, na.ok, positive, tol, null.ok))
}, function (x, na.ok = FALSE, positive = FALSE, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  isTRUE(.Call(c_check_count, x, na.ok, positive, tol, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testDataFrame
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkDataFrame(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testDataTable
list(`package:checkmate` = function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
}, function (x, key = NULL, index = NULL, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkDataTable(x, key, index, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testDate
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE) 
{
  isTRUE(checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok))
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, null.ok = FALSE) 
{
  isTRUE(checkDate(x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testDirectory
list(`package:checkmate` = function (x, access = "") 
{
  isTRUE(checkDirectoryExists(x, access))
}, function (x, access = "") 
{
  isTRUE(checkDirectoryExists(x, access))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testDirectoryExists
list(`package:checkmate` = function (x, access = "") 
{
  isTRUE(checkDirectoryExists(x, access))
}, function (x, access = "") 
{
  isTRUE(checkDirectoryExists(x, access))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testDisjunct
list(`package:checkmate` = function (x, y, fmatch = FALSE) 
{
  isTRUE(checkDisjunct(x, y, fmatch))
}, function (x, y, fmatch = FALSE) 
{
  isTRUE(checkDisjunct(x, y, fmatch))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testDouble
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_double, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testEnvironment
list(`package:checkmate` = function (x, contains = character(0), null.ok = FALSE) 
{
  isTRUE(checkEnvironment(x, contains, null.ok))
}, function (x, contains = character(0), null.ok = FALSE) 
{
  isTRUE(checkEnvironment(x, contains, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testFactor
list(`package:checkmate` = function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok))
}, function (x, levels = NULL, ordered = NA, empty.levels.ok = TRUE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, n.levels = NULL, min.levels = NULL, max.levels = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(checkFactor(x, levels, ordered, empty.levels.ok, any.missing, all.missing, len, min.len, max.len, n.levels, min.levels, max.levels, unique, names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testFALSE
list(`package:checkmate` = function (x, na.ok = FALSE) 
{
  isTRUE(checkFALSE(x, na.ok))
}, function (x, na.ok = FALSE) 
{
  isTRUE(checkFALSE(x, na.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testFile
list(`package:checkmate` = function (x, access = "", extension = NULL) 
{
  isTRUE(checkFileExists(x, access, extension))
}, function (x, access = "", extension = NULL) 
{
  isTRUE(checkFileExists(x, access, extension))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testFileExists
list(`package:checkmate` = function (x, access = "", extension = NULL) 
{
  isTRUE(checkFileExists(x, access, extension))
}, function (x, access = "", extension = NULL) 
{
  isTRUE(checkFileExists(x, access, extension))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testFlag
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_flag, x, na.ok, null.ok))
}, function (x, na.ok = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_flag, x, na.ok, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testFormula
list(`package:checkmate` = function (x, null.ok = FALSE) 
{
  isTRUE(checkFormula(x, null.ok))
}, function (x, null.ok = FALSE) 
{
  isTRUE(checkFormula(x, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testFunction
list(`package:checkmate` = function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE) 
{
  isTRUE(checkFunction(x, args, ordered, nargs, null.ok))
}, function (x, args = NULL, ordered = FALSE, nargs = NULL, null.ok = FALSE) 
{
  isTRUE(checkFunction(x, args, ordered, nargs, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testInt
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  isTRUE(.Call(c_check_int, x, na.ok, lower, upper, tol, null.ok))
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps), null.ok = FALSE) 
{
  isTRUE(.Call(c_check_int, x, na.ok, lower, upper, tol, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testInteger
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_integer, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testIntegerish
list(`package:checkmate` = function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, tol = sqrt(.Machine$double.eps), lower = -Inf, upper = Inf, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_integerish, x, tol, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testList
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok))
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(checkList(x, types, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testLogical
list(`package:checkmate` = function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok))
}, function (x, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_logical, x, any.missing, all.missing, len, min.len, max.len, unique, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testMatrix
list(`package:checkmate` = function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
}, function (x, mode = NULL, any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_matrix, x, mode, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testMultiClass
list(`package:checkmate` = function (x, classes, null.ok = FALSE) 
{
  isTRUE(checkMultiClass(x, classes, null.ok))
}, function (x, classes, null.ok = FALSE) 
{
  isTRUE(checkMultiClass(x, classes, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testNamed
list(`package:checkmate` = function (x, type = "named") 
{
  isTRUE(.Call(c_check_named, x, type))
}, function (x, type = "named") 
{
  isTRUE(.Call(c_check_named, x, type))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testNames
list(`package:checkmate` = function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names") 
{
  isTRUE(checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what))
}, function (x, type = "named", subset.of = NULL, must.include = NULL, permutation.of = NULL, identical.to = NULL, disjunct.from = NULL, what = "names") 
{
  isTRUE(checkNames(x, type, subset.of, must.include, permutation.of, identical.to, disjunct.from, what))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testNull
list(`package:checkmate` = function (x) 
{
  isTRUE(checkNull(x))
}, function (x) 
{
  isTRUE(checkNull(x))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testNumber
list(`package:checkmate` = function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_number, x, na.ok, lower, upper, finite, null.ok))
}, function (x, na.ok = FALSE, lower = -Inf, upper = Inf, finite = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_number, x, na.ok, lower, upper, finite, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testNumeric
list(`package:checkmate` = function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
}, function (x, lower = -Inf, upper = Inf, finite = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, names = NULL, typed.missing = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_numeric, x, lower, upper, finite, any.missing, all.missing, len, min.len, max.len, unique, sorted, names, typed.missing, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testOS
list(`package:checkmate` = function (os) 
{
  isTRUE(checkOS(os))
}, function (os) 
{
  isTRUE(checkOS(os))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testPathForOutput
list(`package:checkmate` = function (x, overwrite = FALSE, extension = NULL) 
{
  isTRUE(checkPathForOutput(x, overwrite, extension))
}, function (x, overwrite = FALSE, extension = NULL) 
{
  isTRUE(checkPathForOutput(x, overwrite, extension))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testPOSIXct
list(`package:checkmate` = function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok))
}, function (x, lower = NULL, upper = NULL, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, sorted = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_posixct, x, lower, upper, any.missing, all.missing, len, min.len, max.len, unique, sorted, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testR6
list(`package:checkmate` = function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE) 
{
  isTRUE(checkR6(x, classes, ordered, cloneable, public, private, null.ok))
}, function (x, classes = NULL, ordered = FALSE, cloneable = NULL, public = NULL, private = NULL, null.ok = FALSE) 
{
  isTRUE(checkR6(x, classes, ordered, cloneable, public, private, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testRaw
list(`package:checkmate` = function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_raw, x, len, min.len, max.len, names, null.ok))
}, function (x, len = NULL, min.len = NULL, max.len = NULL, names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_raw, x, len, min.len, max.len, names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testScalar
list(`package:checkmate` = function (x, na.ok = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_scalar, x, na.ok, null.ok))
}, function (x, na.ok = FALSE, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_scalar, x, na.ok, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testScalarNA
list(`package:checkmate` = function (x, null.ok = FALSE) 
{
  isTRUE(checkScalarNA(x, null.ok))
}, function (x, null.ok = FALSE) 
{
  isTRUE(checkScalarNA(x, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testSetEqual
list(`package:checkmate` = function (x, y, ordered = FALSE, fmatch = FALSE) 
{
  isTRUE(checkSetEqual(x, y, ordered, fmatch))
}, function (x, y, ordered = FALSE, fmatch = FALSE) 
{
  isTRUE(checkSetEqual(x, y, ordered, fmatch))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testString
list(`package:checkmate` = function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE) 
{
  isTRUE(checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok))
}, function (x, na.ok = FALSE, n.chars = NULL, min.chars = NULL, max.chars = NULL, pattern = NULL, fixed = NULL, ignore.case = FALSE, null.ok = FALSE) 
{
  isTRUE(checkString(x, na.ok, n.chars, min.chars, max.chars, pattern, fixed, ignore.case, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testSubset
list(`package:checkmate` = function (x, choices, empty.ok = TRUE, fmatch = FALSE) 
{
  isTRUE(checkSubset(x, choices, empty.ok, fmatch))
}, function (x, choices, empty.ok = TRUE, fmatch = FALSE) 
{
  isTRUE(checkSubset(x, choices, empty.ok, fmatch))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testTibble
list(`package:checkmate` = function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
}, function (x, types = character(0), any.missing = TRUE, all.missing = TRUE, min.rows = NULL, max.rows = NULL, min.cols = NULL, max.cols = NULL, nrows = NULL, ncols = NULL, row.names = NULL, col.names = NULL, null.ok = FALSE) 
{
  isTRUE(checkTibble(x, types, any.missing, all.missing, min.rows, max.rows, min.cols, max.cols, nrows, ncols, row.names, col.names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testTRUE
list(`package:checkmate` = function (x, na.ok = FALSE) 
{
  isTRUE(checkTRUE(x, na.ok))
}, function (x, na.ok = FALSE) 
{
  isTRUE(checkTRUE(x, na.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
testVector
list(`package:checkmate` = function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok))
}, function (x, strict = FALSE, any.missing = TRUE, all.missing = TRUE, len = NULL, min.len = NULL, max.len = NULL, unique = FALSE, names = NULL, null.ok = FALSE) 
{
  isTRUE(.Call(c_check_vector, x, strict, any.missing, all.missing, len, min.len, max.len, unique, names, null.ok))
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
vname
list(`package:checkmate` = function (x) 
{
  paste0(deparse(eval.parent(substitute(substitute(x))), width.cutoff = 500), collapse = "\n")
}, function (x) 
{
  paste0(deparse(eval.parent(substitute(substitute(x))), width.cutoff = 500), collapse = "\n")
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
wf
list(`package:checkmate` = function (x, use.names = TRUE) 
{
  .Call(c_which_first, x, use.names)
}, function (x, use.names = TRUE) 
{
  .Call(c_which_first, x, use.names)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)
wl
list(`package:checkmate` = function (x, use.names = TRUE) 
{
  .Call(c_which_last, x, use.names)
}, function (x, use.names = TRUE) 
{
  .Call(c_which_last, x, use.names)
})
c("package:checkmate", "namespace:checkmate")
c(TRUE, FALSE)
c(FALSE, TRUE)


#################################################################################################
library(chron)
1) .Holidays
list(`package:chron` = c(`New Year's Day` = 8035, `Memorial Day` = 8180, `Independence Day` = 8220, `Labor Day` = 8285, Thanksgiving = 8365, Christmas = 8394), c(`New Year's Day` = 8035, `Memorial Day` = 8180, `Independence Day` = 8220, `Labor Day` = 8285, Thanksgiving = 8365, Christmas = 8394))
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
2) as.chron
list(`package:chron` = function (x, ...) 
  UseMethod("as.chron"), function (x, ...) 
    UseMethod("as.chron"))
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
3) as.dates
list(`package:chron` = function (x, ...) 
  UseMethod("as.dates"), function (x, ...) 
    UseMethod("as.dates"))
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
4) as.times
list(`package:chron` = function (x, ...) 
  UseMethod("as.times"), function (x, ...) 
    UseMethod("as.times"))
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
5) chron
list(`package:chron` = function (dates. = NULL, times. = NULL, format = c(dates = "m/d/y", times = "h:m:s"), out.format, origin.) 
{
  if (is.null(format)) 
    format <- c(dates = "m/d/y", times = "h:m:s")
  if (missing(out.format)) {
    if (is.character(format)) 
      out.format <- format
    else stop("must specify the \"out.format\" argument")
  }
  given <- c(dates = !missing(dates.), times = !missing(times.))
  if (is.null(default.origin <- getOption("chron.origin"))) 
    default.origin <- c(month = 1, day = 1, year = 1970)
  if (all(!given)) 
    return(structure(numeric(0), format = format, origin = default.origin, class = c("chron", "dates", "times")))
  if (inherits(dates., "dates")) {
    if (missing(origin.)) 
      origin. <- origin(dates.)
    else origin(dates.) <- origin.
  }
  else if (missing(origin.)) 
    origin. <- default.origin
  if (given["dates"] && !given["times"]) {
    if (missing(format) && inherits(dates., "dates")) 
      format <- attr(dates., "format")
    fmt <- switch(mode(format), character = , list = format[[1]], name = , `function` = format, `NULL` = c(dates = "m/d/y"), stop("unrecognized format"))
    dts <- convert.dates(dates., format = fmt, origin. = origin.)
    tms <- dts - floor(dts)
    if (!all(is.na(tms)) && any(tms[!is.na(tms)] != 0)) 
      return(chron(dates. = floor(dts), times. = tms, format = format, out.format = out.format, origin. = origin.))
    ofmt <- switch(mode(out.format), character = , list = out.format[[1]], name = , `function` = out.format, `NULL` = c(dates = "m/d/y"), stop("invalid output format"))
    attr(dts, "format") <- ofmt
    attr(dts, "origin") <- origin.
    class(dts) <- c("dates", "times")
    names(dts) <- names(dates.)
    return(dts)
  }
  if (given["times"] && !given["dates"]) {
    if (missing(format) && inherits(times., "times")) {
      format <- attr(times., "format")
      if (!is.name(format)) 
        format <- rev(format)[[1]]
    }
    fmt <- switch(mode(format), character = , list = rev(format)[[1]], name = , `function` = format, `NULL` = c(times = "h:m:s"), stop("invalid times input format"))
    tms <- convert.times(times., fmt)
    ofmt <- switch(mode(out.format), character = , list = rev(out.format)[[1]], name = , `function` = out.format, `NULL` = c(dates = "m/d/y"), stop("invalid times output format"))
    attr(tms, "format") <- ofmt
    class(tms) <- "times"
    names(tms) <- names(times.)
    return(tms)
  }
  if (length(times.) != length(dates.)) {
    if (length(times.) == 1) 
      times. <- rep.int(times., length(dates.))
    else if (length(dates.) == 1) 
      dates. <- rep.int(dates., length(times.))
    else stop(paste(deparse(substitute(dates.)), "and", deparse(substitute(times.)), "must have equal lengths"))
  }
  if (missing(format)) {
    if (is.null(fmt.d <- attr(dates., "format"))) 
      fmt.d <- format[1]
    if (is.null(fmt.t <- attr(times., "format"))) 
      fmt.t <- format[2]
    if (mode(fmt.d) == "character" && mode(fmt.t) == "character") 
      format <- structure(c(fmt.d, fmt.t), names = c("dates", "times"))
    else {
      fmt.d <- if (is.name(fmt.d)) 
        fmt.d
      else fmt.d[[1]]
      fmt.t <- if (is.name(fmt.t)) 
        fmt.t
      else rev(fmt.t)[[1]]
      format <- list(dates = fmt.d, times = fmt.t)
    }
  }
  if (any(length(format) != 2, length(out.format) != 2)) 
    stop("misspecified chron format(s) length")
  if (all(mode(format) != c("character", "list"))) 
    stop("misspecified input format(s)")
  if (all(mode(out.format) != c("list", "character"))) 
    stop("misspecified output format(s)")
  dts <- convert.dates(dates., format = format[[1]], origin. = origin.)
  tms <- convert.times(times., format = format[[2]])
  x <- unclass(dts) + unclass(tms)
  attr(x, "format") <- out.format
  attr(x, "origin") <- origin.
  class(x) <- c("chron", "dates", "times")
  nms <- paste(names(dates.), names(times.))
  if (length(nms) && any(nms != "")) 
    names(x) <- nms
  return(x)
}, function (dates. = NULL, times. = NULL, format = c(dates = "m/d/y", times = "h:m:s"), out.format, origin.) 
{
  if (is.null(format)) 
    format <- c(dates = "m/d/y", times = "h:m:s")
  if (missing(out.format)) {
    if (is.character(format)) 
      out.format <- format
    else stop("must specify the \"out.format\" argument")
  }
  given <- c(dates = !missing(dates.), times = !missing(times.))
  if (is.null(default.origin <- getOption("chron.origin"))) 
    default.origin <- c(month = 1, day = 1, year = 1970)
  if (all(!given)) 
    return(structure(numeric(0), format = format, origin = default.origin, class = c("chron", "dates", "times")))
  if (inherits(dates., "dates")) {
    if (missing(origin.)) 
      origin. <- origin(dates.)
    else origin(dates.) <- origin.
  }
  else if (missing(origin.)) 
    origin. <- default.origin
  if (given["dates"] && !given["times"]) {
    if (missing(format) && inherits(dates., "dates")) 
      format <- attr(dates., "format")
    fmt <- switch(mode(format), character = , list = format[[1]], name = , `function` = format, `NULL` = c(dates = "m/d/y"), stop("unrecognized format"))
    dts <- convert.dates(dates., format = fmt, origin. = origin.)
    tms <- dts - floor(dts)
    if (!all(is.na(tms)) && any(tms[!is.na(tms)] != 0)) 
      return(chron(dates. = floor(dts), times. = tms, format = format, out.format = out.format, origin. = origin.))
    ofmt <- switch(mode(out.format), character = , list = out.format[[1]], name = , `function` = out.format, `NULL` = c(dates = "m/d/y"), stop("invalid output format"))
    attr(dts, "format") <- ofmt
    attr(dts, "origin") <- origin.
    class(dts) <- c("dates", "times")
    names(dts) <- names(dates.)
    return(dts)
  }
  if (given["times"] && !given["dates"]) {
    if (missing(format) && inherits(times., "times")) {
      format <- attr(times., "format")
      if (!is.name(format)) 
        format <- rev(format)[[1]]
    }
    fmt <- switch(mode(format), character = , list = rev(format)[[1]], name = , `function` = format, `NULL` = c(times = "h:m:s"), stop("invalid times input format"))
    tms <- convert.times(times., fmt)
    ofmt <- switch(mode(out.format), character = , list = rev(out.format)[[1]], name = , `function` = out.format, `NULL` = c(dates = "m/d/y"), stop("invalid times output format"))
    attr(tms, "format") <- ofmt
    class(tms) <- "times"
    names(tms) <- names(times.)
    return(tms)
  }
  if (length(times.) != length(dates.)) {
    if (length(times.) == 1) 
      times. <- rep.int(times., length(dates.))
    else if (length(dates.) == 1) 
      dates. <- rep.int(dates., length(times.))
    else stop(paste(deparse(substitute(dates.)), "and", deparse(substitute(times.)), "must have equal lengths"))
  }
  if (missing(format)) {
    if (is.null(fmt.d <- attr(dates., "format"))) 
      fmt.d <- format[1]
    if (is.null(fmt.t <- attr(times., "format"))) 
      fmt.t <- format[2]
    if (mode(fmt.d) == "character" && mode(fmt.t) == "character") 
      format <- structure(c(fmt.d, fmt.t), names = c("dates", "times"))
    else {
      fmt.d <- if (is.name(fmt.d)) 
        fmt.d
      else fmt.d[[1]]
      fmt.t <- if (is.name(fmt.t)) 
        fmt.t
      else rev(fmt.t)[[1]]
      format <- list(dates = fmt.d, times = fmt.t)
    }
  }
  if (any(length(format) != 2, length(out.format) != 2)) 
    stop("misspecified chron format(s) length")
  if (all(mode(format) != c("character", "list"))) 
    stop("misspecified input format(s)")
  if (all(mode(out.format) != c("list", "character"))) 
    stop("misspecified output format(s)")
  dts <- convert.dates(dates., format = format[[1]], origin. = origin.)
  tms <- convert.times(times., format = format[[2]])
  x <- unclass(dts) + unclass(tms)
  attr(x, "format") <- out.format
  attr(x, "origin") <- origin.
  class(x) <- c("chron", "dates", "times")
  nms <- paste(names(dates.), names(times.))
  if (length(nms) && any(nms != "")) 
    names(x) <- nms
  return(x)
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
6) chron_trans
list(`package:chron` = function (format = "%Y-%m-%d", n = 5) 
{
  breaks. <- function(x) chron((scales::pretty_breaks(n))(x))
  format. <- function(x) format(as.POSIXct(x, tz = "GMT"), format = format)
  scales::trans_new("chron", transform = as.numeric, inverse = chron, breaks = breaks., format = format.)
}, function (format = "%Y-%m-%d", n = 5) 
{
  breaks. <- function(x) chron((scales::pretty_breaks(n))(x))
  format. <- function(x) format(as.POSIXct(x, tz = "GMT"), format = format)
  scales::trans_new("chron", transform = as.numeric, inverse = chron, breaks = breaks., format = format.)
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
7) dates
list(`package:chron` = function (x, ...) 
{
  fmt <- attr(x, "format")
  x <- chron(dates. = x, ...)
  cl <- oldClass(x)
  out <- floor(unclass(x))
  class(out) <- cl[!as.logical(match(cl, "chron", 0))]
  cl <- oldClass(x)
  attr(out, "format") <- fmt
  out
}, function (x, ...) 
{
  fmt <- attr(x, "format")
  x <- chron(dates. = x, ...)
  cl <- oldClass(x)
  out <- floor(unclass(x))
  class(out) <- cl[!as.logical(match(cl, "chron", 0))]
  cl <- oldClass(x)
  attr(out, "format") <- fmt
  out
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
8) day.of.week
list(`package:chron` = function (month, day, year) 
{
  ix <- year + trunc((month - 14)/12)
  jx <- (trunc((13 * (month + 10 - (month + 10)%/%13 * 12) - 1)/5) + day + 77 + (5 * (ix - (ix%/%100) * 100))%/%4 + ix%/%400 - (ix%/%100) * 2)
  jx%%7
}, function (month, day, year) 
{
  ix <- year + trunc((month - 14)/12)
  jx <- (trunc((13 * (month + 10 - (month + 10)%/%13 * 12) - 1)/5) + day + 77 + (5 * (ix - (ix%/%100) * 100))%/%4 + ix%/%400 - (ix%/%100) * 2)
  jx%%7
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
9) days
list(`package:chron` = function (x) 
{
  if (!inherits(x, "dates")) 
    x <- as.chron(x)
  d <- month.day.year(floor(as.numeric(x)), origin. = origin(x))$day
  d <- ordered(paste(d), paste(1:31))
  d
}, function (x) 
{
  if (!inherits(x, "dates")) 
    x <- as.chron(x)
  d <- month.day.year(floor(as.numeric(x)), origin. = origin(x))$day
  d <- ordered(paste(d), paste(1:31))
  d
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
10) hours
list(`package:chron` = function (x) 
{
  if (!inherits(x, "times")) 
    x <- as.chron(x)
  x <- as.numeric(x)
  sec <- round(24 * 3600 * abs(x - floor(x)))
  hh <- sec%/%3600
  hh
}, function (x) 
{
  if (!inherits(x, "times")) 
    x <- as.chron(x)
  x <- as.numeric(x)
  sec <- round(24 * 3600 * abs(x - floor(x)))
  hh <- sec%/%3600
  hh
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
11) is.chron
list(`package:chron` = function (x) 
  inherits(x, "chron"), function (x) 
    inherits(x, "chron"))
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
12) is.holiday
list(`package:chron` = function (x, holidays) 
{
  if (!inherits(x, "dates")) 
    x <- as.chron(x)
  if (missing(holidays)) {
    if (exists(".Holidays")) 
      holidays <- .Holidays
    else holidays <- NULL
  }
  else if (length(holidays) == 0) 
    holidays <- NULL
  if (is.null(holidays)) 
    return(rep(FALSE, length(x)))
  orig.x <- origin(x)
  if (!is.null(orig.h <- origin(holidays)) && any(orig.x != orig.h)) 
    origin(holidays) <- orig.x
  out <- match(floor(x), floor(holidays), 0)
  as.logical(out)
}, function (x, holidays) 
{
  if (!inherits(x, "dates")) 
    x <- as.chron(x)
  if (missing(holidays)) {
    if (exists(".Holidays")) 
      holidays <- .Holidays
    else holidays <- NULL
  }
  else if (length(holidays) == 0) 
    holidays <- NULL
  if (is.null(holidays)) 
    return(rep(FALSE, length(x)))
  orig.x <- origin(x)
  if (!is.null(orig.h <- origin(holidays)) && any(orig.x != orig.h)) 
    origin(holidays) <- orig.x
  out <- match(floor(x), floor(holidays), 0)
  as.logical(out)
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
13) is.weekend
list(`package:chron` = function (x) 
{
  if (!inherits(x, "dates")) 
    x <- as.chron(x)
  v <- month.day.year(as.numeric(x), origin. = origin(x))
  out <- day.of.week(v$month, v$day, v$year) + 1
  out == 1 | out == 7
}, function (x) 
{
  if (!inherits(x, "dates")) 
    x <- as.chron(x)
  v <- month.day.year(as.numeric(x), origin. = origin(x))
  out <- day.of.week(v$month, v$day, v$year) + 1
  out == 1 | out == 7
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
14) leap.year
list(`package:chron` = function (y) 
{
  if (inherits(y, "dates")) 
    y <- month.day.year(as.numeric(y), origin. = origin(y))$year
  y%%4 == 0 & (y%%100 != 0 | y%%400 == 0)
}, function (y) 
{
  if (inherits(y, "dates")) 
    y <- month.day.year(as.numeric(y), origin. = origin(y))$year
  y%%4 == 0 & (y%%100 != 0 | y%%400 == 0)
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
15) minutes
list(`package:chron` = function (x) 
{
  if (!inherits(x, "times")) 
    x <- as.chron(x)
  x <- as.numeric(x)
  sec <- round(24 * 3600 * abs(x - floor(x)))
  hh <- sec%/%3600
  mm <- (sec - hh * 3600)%/%60
  mm
}, function (x) 
{
  if (!inherits(x, "times")) 
    x <- as.chron(x)
  x <- as.numeric(x)
  sec <- round(24 * 3600 * abs(x - floor(x)))
  hh <- sec%/%3600
  mm <- (sec - hh * 3600)%/%60
  mm
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
16) month.day.year
list(`package:chron` = function (jul, origin.) 
{
  if (!inherits(jul, "dates")) 
    jul <- as.chron(jul)
  if (missing(origin.) || is.null(origin.)) 
    if (is.null(origin. <- getOption("chron.origin"))) 
      origin. <- c(month = 1, day = 1, year = 1970)
  if (all(origin. == 0)) 
    shift <- 0
  else shift <- julian(origin. = origin.)
  j <- as.integer(floor(jul)) + as.integer(shift)
  j <- j - 1721119
  y <- (4 * j - 1)%/%146097
  j <- 4 * j - 1 - 146097 * y
  d <- j%/%4
  j <- (4 * d + 3)%/%1461
  d <- 4 * d + 3 - 1461 * j
  d <- (d + 4)%/%4
  m <- (5 * d - 3)%/%153
  d <- 5 * d - 3 - 153 * m
  d <- (d + 5)%/%5
  y <- 100 * y + j
  y <- y + ifelse(m < 10, 0, 1)
  m <- m + ifelse(m < 10, 3, -9)
  list(month = m, day = d, year = y)
}, function (jul, origin.) 
{
  if (!inherits(jul, "dates")) 
    jul <- as.chron(jul)
  if (missing(origin.) || is.null(origin.)) 
    if (is.null(origin. <- getOption("chron.origin"))) 
      origin. <- c(month = 1, day = 1, year = 1970)
  if (all(origin. == 0)) 
    shift <- 0
  else shift <- julian(origin. = origin.)
  j <- as.integer(floor(jul)) + as.integer(shift)
  j <- j - 1721119
  y <- (4 * j - 1)%/%146097
  j <- 4 * j - 1 - 146097 * y
  d <- j%/%4
  j <- (4 * d + 3)%/%1461
  d <- 4 * d + 3 - 1461 * j
  d <- (d + 4)%/%4
  m <- (5 * d - 3)%/%153
  d <- 5 * d - 3 - 153 * m
  d <- (d + 5)%/%5
  y <- 100 * y + j
  y <- y + ifelse(m < 10, 0, 1)
  m <- m + ifelse(m < 10, 3, -9)
  list(month = m, day = d, year = y)
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
17) origin
list(`package:chron` = function (x) 
  attr(x, "origin"), function (x) 
    attr(x, "origin"))
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
18) origin<-
  list(`package:chron` = function (x, value) 
  {
    if (length(value) != 3 || any(is.na(value))) 
      stop("origin must be a month, day, year vector")
    if (value[1] < 1 || value[1] > 12) 
      stop("month out of range in origin")
    n <- month.length[value[1]] + as.numeric(value[1] == 2 && leap.year(value[3]))
    if (value[2] < 1 || value[2] > n) 
      stop("day out of range in origin")
    cl <- class(x)
    class(x) <- NULL
    jval <- julian(value[1], value[2], value[3], origin. = c(0, 0, 0))
    if (!is.null(ox <- attr(x, "origin"))) 
      x <- x - jval + julian(ox[1], ox[2], ox[3], origin. = c(0, 0, 0))
    new.origin <- unlist(month.day.year(jval, origin. = c(0, 0, 0)))
    attr(x, "origin") <- structure(new.origin, names = c("month", "day", "year"))
    class(x) <- cl
    x
  }, function (x, value) 
  {
    if (length(value) != 3 || any(is.na(value))) 
      stop("origin must be a month, day, year vector")
    if (value[1] < 1 || value[1] > 12) 
      stop("month out of range in origin")
    n <- month.length[value[1]] + as.numeric(value[1] == 2 && leap.year(value[3]))
    if (value[2] < 1 || value[2] > n) 
      stop("day out of range in origin")
    cl <- class(x)
    class(x) <- NULL
    jval <- julian(value[1], value[2], value[3], origin. = c(0, 0, 0))
    if (!is.null(ox <- attr(x, "origin"))) 
      x <- x - jval + julian(ox[1], ox[2], ox[3], origin. = c(0, 0, 0))
    new.origin <- unlist(month.day.year(jval, origin. = c(0, 0, 0)))
    attr(x, "origin") <- structure(new.origin, names = c("month", "day", "year"))
    class(x) <- cl
    x
  })
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
19) scale_x_chron
list(`package:chron` = function (..., format = "%Y-%m-%d", n = 5) 
{
  ggplot2::scale_x_continuous(..., trans = chron_trans(format, n))
}, function (..., format = "%Y-%m-%d", n = 5) 
{
  ggplot2::scale_x_continuous(..., trans = chron_trans(format, n))
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
20) scale_y_chron
list(`package:chron` = function (..., format = "%Y-%m-%d", n = 5) 
{
  ggplot2::scale_y_continuous(..., trans = chron_trans(format, n))
}, function (..., format = "%Y-%m-%d", n = 5) 
{
  ggplot2::scale_y_continuous(..., trans = chron_trans(format, n))
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
21) seconds
list(`package:chron` = function (x) 
{
  if (!inherits(x, "times")) 
    x <- as.chron(x)
  x <- as.numeric(x)
  sec <- round(24 * 3600 * abs(x - floor(x)))
  hh <- sec%/%3600
  mm <- (sec - hh * 3600)%/%60
  ss <- trunc(sec - hh * 3600 - 60 * mm)
  ss
}, function (x) 
{
  if (!inherits(x, "times")) 
    x <- as.chron(x)
  x <- as.numeric(x)
  sec <- round(24 * 3600 * abs(x - floor(x)))
  hh <- sec%/%3600
  mm <- (sec - hh * 3600)%/%60
  ss <- trunc(sec - hh * 3600 - 60 * mm)
  ss
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
22) seq.dates
list(`package:chron` = function (from, to, by = "days", length., ...) 
{
  if (missing(from)) 
    stop("argument \"from\" must be specified")
  if (!inherits(from, "dates")) 
    from <- chron(from[1])
  fmt <- attr(from, "format")
  org <- origin(from)
  if (is.numeric(by)) {
    cl <- class(from)
    from <- as.numeric(from)
    if (!missing(to)) {
      if (!inherits(to, "dates")) 
        to <- chron(to[1])
      if (!is.null(to.org <- origin(to)) && any(to.org != org)) 
        origin(to) <- org
      to <- as.numeric(to)
    }
    x <- seq.int(from, to, by)
    if (all(cl != "chron")) 
      x <- round(x, 0)
    return(chron(x, format = fmt, origin. = org))
  }
  if (!is.character(by) || length(by) != 1) 
    stop("\"by\" must be a number or string (days, weeks, months, or years)")
  valid <- c("days", "weeks", "months", "years")
  if (!as.logical(i <- pmatch(by, valid, 0))) 
    stop("\"by\" must be one of days, weeks, months, or years")
  by <- valid[i]
  if (missing(to)) {
    if (missing(length.)) 
      stop("must specify \"length\" when \"to\" is missing")
    to <- from + (length. - 1) * c(1, 7, 31, 366)[i]
  }
  else {
    if (!missing(by) && !missing(length.)) 
      stop("Too many arguments")
    if (!inherits(to, "dates")) 
      to <- chron(to)
    if (!missing(length.)) 
      by <- if (from < to) 
        as.numeric(to - from)/(length. - 1)
    else 0
  }
  if (!is.null(to.org <- origin(to)) && any(to.org != org)) 
    origin(to) <- org
  if (from > to) 
    stop("\"from\" must be a date before \"to\"")
  frm <- as.numeric(from)
  t0 <- as.numeric(to)
  frm.mdy <- month.day.year(frm, origin. = org)
  x <- seq.int(from = frm, to = t0)
  if (by == "weeks") {
    mdy <- month.day.year(x, origin. = org)
    mdy.dow <- day.of.week(mdy$month, mdy$day, mdy$year)
    frm.dow <- day.of.week(frm.mdy$month, frm.mdy$day, frm.mdy$year)
    x <- x[mdy.dow == frm.dow]
  }
  else if (by == "months") {
    nxt.day <- month.day.year(as.numeric(from + 1))$month
    end.of.the.month <- frm.mdy$month != nxt.day
    if (end.of.the.month) 
      x <- c(x, x[length(x)] + 1)
    mdy <- month.day.year(x, origin. = org)
    dys <- mdy$day
    if (frm.mdy$day <= 28) 
      x <- x[dys == frm.mdy$day]
    else if (end.of.the.month) 
      x <- x[dys == 1] - 1
    else {
      x1 <- x[dys == frm.mdy$day]
      x2 <- x[mdy$month == 3 & dys == 1] - 1
      x <- sort(unique(c(x1, x2)))
    }
    if (!missing(length.)) 
      x <- x[seq_len(length.)]
  }
  else if (by == "years") {
    mdy <- month.day.year(x, org)
    if (leap.year(frm.mdy$year) && frm.mdy$day == 29) 
      x <- x[mdy$day == 1 & mdy$month == 3] - 1
    else x <- x[mdy$day == frm.mdy$day & mdy$month == frm.mdy$month]
    if (!missing(length.)) 
      x <- x[seq_len(length.)]
  }
  if (inherits(from, "chron")) 
    chron(floor(x), x - floor(x), format = fmt, origin. = org)
  else return(chron(x, format = fmt, origin. = org))
}, function (from, to, by = "days", length., ...) 
{
  if (missing(from)) 
    stop("argument \"from\" must be specified")
  if (!inherits(from, "dates")) 
    from <- chron(from[1])
  fmt <- attr(from, "format")
  org <- origin(from)
  if (is.numeric(by)) {
    cl <- class(from)
    from <- as.numeric(from)
    if (!missing(to)) {
      if (!inherits(to, "dates")) 
        to <- chron(to[1])
      if (!is.null(to.org <- origin(to)) && any(to.org != org)) 
        origin(to) <- org
      to <- as.numeric(to)
    }
    x <- seq.int(from, to, by)
    if (all(cl != "chron")) 
      x <- round(x, 0)
    return(chron(x, format = fmt, origin. = org))
  }
  if (!is.character(by) || length(by) != 1) 
    stop("\"by\" must be a number or string (days, weeks, months, or years)")
  valid <- c("days", "weeks", "months", "years")
  if (!as.logical(i <- pmatch(by, valid, 0))) 
    stop("\"by\" must be one of days, weeks, months, or years")
  by <- valid[i]
  if (missing(to)) {
    if (missing(length.)) 
      stop("must specify \"length\" when \"to\" is missing")
    to <- from + (length. - 1) * c(1, 7, 31, 366)[i]
  }
  else {
    if (!missing(by) && !missing(length.)) 
      stop("Too many arguments")
    if (!inherits(to, "dates")) 
      to <- chron(to)
    if (!missing(length.)) 
      by <- if (from < to) 
        as.numeric(to - from)/(length. - 1)
    else 0
  }
  if (!is.null(to.org <- origin(to)) && any(to.org != org)) 
    origin(to) <- org
  if (from > to) 
    stop("\"from\" must be a date before \"to\"")
  frm <- as.numeric(from)
  t0 <- as.numeric(to)
  frm.mdy <- month.day.year(frm, origin. = org)
  x <- seq.int(from = frm, to = t0)
  if (by == "weeks") {
    mdy <- month.day.year(x, origin. = org)
    mdy.dow <- day.of.week(mdy$month, mdy$day, mdy$year)
    frm.dow <- day.of.week(frm.mdy$month, frm.mdy$day, frm.mdy$year)
    x <- x[mdy.dow == frm.dow]
  }
  else if (by == "months") {
    nxt.day <- month.day.year(as.numeric(from + 1))$month
    end.of.the.month <- frm.mdy$month != nxt.day
    if (end.of.the.month) 
      x <- c(x, x[length(x)] + 1)
    mdy <- month.day.year(x, origin. = org)
    dys <- mdy$day
    if (frm.mdy$day <= 28) 
      x <- x[dys == frm.mdy$day]
    else if (end.of.the.month) 
      x <- x[dys == 1] - 1
    else {
      x1 <- x[dys == frm.mdy$day]
      x2 <- x[mdy$month == 3 & dys == 1] - 1
      x <- sort(unique(c(x1, x2)))
    }
    if (!missing(length.)) 
      x <- x[seq_len(length.)]
  }
  else if (by == "years") {
    mdy <- month.day.year(x, org)
    if (leap.year(frm.mdy$year) && frm.mdy$day == 29) 
      x <- x[mdy$day == 1 & mdy$month == 3] - 1
    else x <- x[mdy$day == frm.mdy$day & mdy$month == frm.mdy$month]
    if (!missing(length.)) 
      x <- x[seq_len(length.)]
  }
  if (inherits(from, "chron")) 
    chron(floor(x), x - floor(x), format = fmt, origin. = org)
  else return(chron(x, format = fmt, origin. = org))
}, function (from, to, by = "days", length., ...) 
{
  if (missing(from)) 
    stop("argument \"from\" must be specified")
  if (!inherits(from, "dates")) 
    from <- chron(from[1])
  fmt <- attr(from, "format")
  org <- origin(from)
  if (is.numeric(by)) {
    cl <- class(from)
    from <- as.numeric(from)
    if (!missing(to)) {
      if (!inherits(to, "dates")) 
        to <- chron(to[1])
      if (!is.null(to.org <- origin(to)) && any(to.org != org)) 
        origin(to) <- org
      to <- as.numeric(to)
    }
    x <- seq.int(from, to, by)
    if (all(cl != "chron")) 
      x <- round(x, 0)
    return(chron(x, format = fmt, origin. = org))
  }
  if (!is.character(by) || length(by) != 1) 
    stop("\"by\" must be a number or string (days, weeks, months, or years)")
  valid <- c("days", "weeks", "months", "years")
  if (!as.logical(i <- pmatch(by, valid, 0))) 
    stop("\"by\" must be one of days, weeks, months, or years")
  by <- valid[i]
  if (missing(to)) {
    if (missing(length.)) 
      stop("must specify \"length\" when \"to\" is missing")
    to <- from + (length. - 1) * c(1, 7, 31, 366)[i]
  }
  else {
    if (!missing(by) && !missing(length.)) 
      stop("Too many arguments")
    if (!inherits(to, "dates")) 
      to <- chron(to)
    if (!missing(length.)) 
      by <- if (from < to) 
        as.numeric(to - from)/(length. - 1)
    else 0
  }
  if (!is.null(to.org <- origin(to)) && any(to.org != org)) 
    origin(to) <- org
  if (from > to) 
    stop("\"from\" must be a date before \"to\"")
  frm <- as.numeric(from)
  t0 <- as.numeric(to)
  frm.mdy <- month.day.year(frm, origin. = org)
  x <- seq.int(from = frm, to = t0)
  if (by == "weeks") {
    mdy <- month.day.year(x, origin. = org)
    mdy.dow <- day.of.week(mdy$month, mdy$day, mdy$year)
    frm.dow <- day.of.week(frm.mdy$month, frm.mdy$day, frm.mdy$year)
    x <- x[mdy.dow == frm.dow]
  }
  else if (by == "months") {
    nxt.day <- month.day.year(as.numeric(from + 1))$month
    end.of.the.month <- frm.mdy$month != nxt.day
    if (end.of.the.month) 
      x <- c(x, x[length(x)] + 1)
    mdy <- month.day.year(x, origin. = org)
    dys <- mdy$day
    if (frm.mdy$day <= 28) 
      x <- x[dys == frm.mdy$day]
    else if (end.of.the.month) 
      x <- x[dys == 1] - 1
    else {
      x1 <- x[dys == frm.mdy$day]
      x2 <- x[mdy$month == 3 & dys == 1] - 1
      x <- sort(unique(c(x1, x2)))
    }
    if (!missing(length.)) 
      x <- x[seq_len(length.)]
  }
  else if (by == "years") {
    mdy <- month.day.year(x, org)
    if (leap.year(frm.mdy$year) && frm.mdy$day == 29) 
      x <- x[mdy$day == 1 & mdy$month == 3] - 1
    else x <- x[mdy$day == frm.mdy$day & mdy$month == frm.mdy$month]
    if (!missing(length.)) 
      x <- x[seq_len(length.)]
  }
  if (inherits(from, "chron")) 
    chron(floor(x), x - floor(x), format = fmt, origin. = org)
  else return(chron(x, format = fmt, origin. = org))
})
c("package:chron", "registered S3 method for seq from namespace chron", "namespace:chron")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
23) times
list(`package:chron` = function (x, ...) 
  chron(times. = x, ...), function (x, ...) 
    chron(times. = x, ...))
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
24) year.expand
list(`package:chron` = function (y, cut.off = 69, century = c(1900, 2000), ...) 
{
  if (!is.numeric(y)) 
    stop("must be a numeric year specification")
  i <- (!is.na(y) & (y >= 0) & (y <= 99))
  if (any(i)) 
    y[i] <- ifelse(y[i] < cut.off, y[i] + century[2], y[i] + century[1])
  y
}, function (y, cut.off = 69, century = c(1900, 2000), ...) 
{
  if (!is.numeric(y)) 
    stop("must be a numeric year specification")
  i <- (!is.na(y) & (y >= 0) & (y <= 99))
  if (any(i)) 
    y[i] <- ifelse(y[i] < cut.off, y[i] + century[2], y[i] + century[1])
  y
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
25) year.strict
list(`package:chron` = function (...) 
  stop("you must expand 2-digit year abbreviations"), function (...) 
    stop("you must expand 2-digit year abbreviations"))
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)
26) years
list(`package:chron` = function (x) 
{
  if (!inherits(x, "dates")) 
    x <- as.chron(x)
  y <- month.day.year(as.numeric(x), origin. = origin(x))$year
  y <- ordered(y)
  y
}, function (x) 
{
  if (!inherits(x, "dates")) 
    x <- as.chron(x)
  y <- month.day.year(as.numeric(x), origin. = origin(x))$year
  y <- ordered(y)
  y
})
c("package:chron", "namespace:chron")
c(TRUE, FALSE)
c(FALSE, TRUE)


#################################################################################################
library(cowsay)
1) animals
list(`package:cowsay` = c(cow = "\n ----- \n%s \n ------ \n    \\   ^__^ \n     \\  (oo)\\ ________ \n        (__)\\         )\\ /\\ \n             ||------w|\n             ||      ||", chicken = "\n ----- \n%s \n ------ \n    \\   \n     \\\n         _\n       _/ }\n      `>' \\\n      `|   \\\n       |   /'-.     .-.\n        \\'     ';`--' .'\n         \\'.    `'-./\n          '.`-..-;`\n            `;-..'\n            _| _|\n            /` /` [nosig]\n  ", chuck = "\n ----- \n%s \n ------ \n    \\   \n     \\\n                      @@@@@@@@@@@@@@                       \n                   @@@@@@@@@@@@@@@@@@@@@@                  \n                  @@@@@@@@@@@@@@@@@@@@@@@@@                \n                  @@@@@@@@@@@@@@@@@@@@@@@@@@               \n                  @@@@@@@@@@@@@@@@@@@@@@@@@@               \n                 @@@@@@@@@@@@@@@@@@@@@@@@@@@               \n                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@              \n                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@              \n                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     \n               @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  \n @             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n  @@           @@@@@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@\n    @@@@@@@@@@@@@@@@    @@ @@@@         @@  @@@@@@@@@@@@@@@\n       @@@@@@@@@@@@@      @@@@          @@@@@@@@@@@@@@@@@@@\n          @@@@@@ @@@@@    @@@   @       @@@@@@@@@@ @@@@@@@ \n              @@     @ @                @@ @@@@@@@@   @@@  \n                                              @@@@@@@  @   \n                @     @@                   @ @@@@@@@@@     \n                             @               @@@@@@@@ @@   \n                     @@@@@@@@@@          @  @@@@@          \n                  @@@@@@@@@@ @@           @@@@@  @         \n                 @@@@        @@ @          @@@  @          \n                  @@@           @          @@@             \n                   @@@@@@@   @@ @          @@@@@           \n                    @@@@@@@@@@            @@@@             \n                     @@@@@@ @     @     @@@@@@@@           \n                  @@ @ @@@@@@@@@ @@@@@@@@@@@@@@@@@         \n                @@@  @@@@@   @@@@@@@@@@@@@@@@@@@@@         \n      @@@@@@  @@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   \n@@    @@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [nosig]\n  ", 
                          clippy = "\n\n ----- \n%s \n ------ \n    \\   \n     \\   __\n   / \\\n   | |\n   @ @\n  || ||\n  || ||\n  |\\_/|\n  \\___/ GB\n", poop = "\n ----- \n%s \n ------ \n    \\   \n     \\\n     (   )\n  (   ) (\n   ) _   )\n    ( \\_\n  _(_\\ \\)__\n (____\\ ___)) [nosig]", bigcat = "\n ----- \n%s \n ------ \n    \\   \n     \\\n                \\`*-.\n                 )  _`-.\n                .  : `. .\n                : _   '  \\\n                ; *` _.   `*-._\n                `-.-'          `-.\n                  ;       `       `.\n                  :.       .       \\\n                  .\\  .   :   .-'   .\n                  '  `+.;  ;  '      :\n                  :  '  |    ;       ;-.\n                  ; '   : :`-:     _.`* ;\n               .*' /  .*' ; .*`- +'  `*'\n     [bug]     `*-*   `*-*  `*-*'\n    ", 
                          ant = "\n ----- \n%s \n ------ \n    \\   \n     \\\n       '\\__\n      (o )     ___\n      <>(_)(_)(___)\n        < < > >\n        ' ' ` `  [nosig]\n  ", pumpkin = "\n ----- \n%s \n ------ \n    \\   \n     \\\n                  ___\n               ___)__|_\n          .-*'          '*-,\n         /      /|   |\\     \\\n        ;      /_|   |_\\     ;\n        ;   |\\           /|  ;\n        ;   | ''--...--'' |  ;\n         \\  ''---.....--''  /\n          ''*-.,_______,.-*'  [nosig]\n  ", ghost = "\n ----- \n%s \n ------ \n    \\   \n     \\\n     .-.\n    (o o)\n    | O \\\n     \\   \\\n      `~~~' [nosig]\n  ", 
                          spider = "\n ----- \n%s \n ------ \n    \\   \n     \\\n              |\n              |\n              |\n             __\n          | /  \\ |\n         \\_\\\\  //_/\n          .'/()\\'.\n           \\\\  //  [nosig]\n  ", rabbit = "\n ----- \n%s \n ------ \n    \\   \n     \\\n      ( )_( )\n      (='.'=)\n      (^)_(^) [nosig]\n  ", pig = "\n ----- \n%s \n ------ \n    \\   \n     \\\n       _//| .-~~~-.\n     _/oo  }       }-@\n    ('')_  }       |\n     `--'| { }--{  }\n          //_/  /_/ [nosig]\n  ", 
                          snowman = "\n ----- \n%s \n ------ \n    \\   \n     \\\n     _[_]_\n      (\")\n  >--( : )--<\n    (__:__) [nosig]\n  ", frog = "\n ----- \n%s \n ------ \n    \\   \n     \\\n        (.)_(.)\n     _ (   _   ) _\n    / \\/`-----'\\/ \\\n  __\\ ( (     ) ) /__\n  )   /\\ \\._./ /\\   (\n   )_/ /|\\   /|\\ \\_(  [nosig]\n  ", hypnotoad = "\n ----- \n%s \n ------\n    \\          ,'``.._   ,'``.\n     \\        :,--._:)\\,:,._,.:\n      \\       :`--,''   :`...';\\\n               `,'       `---'  `.\n               /                 :\n              /                   \\\n            ,'                     :\\.___,-.\n           `...,---'``````-..._    |:       \\\n             (                 )   ;:    )   \\  _,-.\n              `.              (   //          `'    \\\n               :               `.//  )      )     , ;\n             ,-|`.            _,'/       )    ) ,' ,'\n            (  :`.`-..____..=:.-':     .     _,' ,'\n             `,'\\ ``--....-)='    `._,  \\  ,') _ '``._\n          _.-/ _ `.       (_)      /     )' ; / \\ \\`-.'\n         `--(   `-:`.     `' ___..'  _,-'   |/   `.)\n             `-. `.`.``-----``--,  .'\n               |/`.\\`'        ,','); SSt\n                   `         (/  (/\n  ", 
                          shortcat = "\n ----- \n%s \n ------ \n    \\   \n     \\\n    .ﾊ,,ﾊ\n    ( ﾟωﾟ)\n    |つ  つ\n    U \" U\n        [BoingBoing]\n    ", longcat = "\n ----- \n%s \n ------ \n    \\   \n     \\\n    .ﾊ,,ﾊ\n    ( ﾟωﾟ)\n    |つ  つ\n%s\n    U \"  U\n        [BoingBoing]\n    ", fish = "\n ----- \n%s \n ------ \n    \\   \n     \\\n  ><((((º>  ><((((º>  ><((((º>  ><((((º>  ><((((º>\n      Kiyoko Gotanda\n    ", signbunny = "\n -------------- \n%s \n --------------\n(\\__/) ||\n(•ㅅ•) ||\n/   づ\n          [nosig]\n    ", 
                          facecat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n         /\\ /\\\n         (O o)\n        =(:^:)=\n           U      [nosig]\n  ", behindcat = "\n -------------- \n%s \n --------------\n      \\\n        \\\n          \\\n            |\\___/|\n            )     (\n           =\\     /=\n             )===(\n            /     \\\n            |     |\n           /       \\\n           \\       /\n      jgs   \\__  _/\n              ( (\n               ) )\n              (_(\n  ", 
                          stretchycat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n                        ,/|         _.--‛‛^``-...___.._.,;\n                      /, \\‛.     _-‛          ,--,,,--‛‛‛\n                     {  \\    `_-‛‛       ‛    /}‛\nJill                    `;;‛             ;   ; ;\n                  ._.--‛‛     ._,,, _..‛  .;.‛\n                  (,_....----‛‛‛     (,..--‛‛\n  ", anxiouscat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n        /\\_/\\         _\n       /``   \\       / )\n       |n n   |__   ( (\n      =(Y =.‛`   `\\  \\ \\\n      {`\"`        \\  ) )\n      {       /    |/ /\n       \\\\   ,(     / /\n        ) ) /-‛\\  ,_.‛\n  jgs  (,(,/ ((,,/\n  ", 
                          longtailcat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n     /\\-/\\\n    /a a  \\                                 _\n   =\\ Y  =/-~~~~~~-,_______________________/ )\n     ‛^--‛          ________________________/\n       \\           /\n       ||  |---‛\\  \\\n  jgs  (_(__|   ((__|\n  ", cat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n            |\\___/|\n          ==) ^Y^ (==\n            \\  ^  /\n             )=*=(\n            /     \\\n            |     |\n           /| | | |\\\n           \\| | |_|/\\\n      jgs  //_// ___/\n               \\_)\n  ", 
                          trilobite = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n          _____\n       .'` ,-. `'.\n      /   ([ ])   \\\n     /.-\"\"`(`)`\"\"-.\\\n      <'```(.)```'>\n      <'```(.)```'>\n       <'``(.)``'>\n   sk   <``\\_/``>\n         `'---'`\n  ", shark = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n              /\"\"-._\n              .       '-,\n               :          '',\n                ;      *     '.\n                 ' *         () '.\n                   \\               \\\n                    \\      _.---.._ '.\n                    :  .' _.--''-''  \\ ,'\n        .._           '/.'             . ;\n        ; `-.          ,                \\'\n         ;   `,         ;              ._\\\n          ;    \\     _,-'                ''--._\n          :    \\_,-'                          '-._\n          \\ ,-'                       .          '-._\n          .'         __.-'';            \\...,__       '.\n        .'      _,-'        \\              \\   ''--.,__  '\\\n        /    _,--' ;         \\              ;           \\^.}\n        ;_,-' )     \\  )\\      )            ;\n             /       \\/  \\_.,-'             ;\n            /                              ;\n         ,-'  _,-'''-.    ,-.,            ;      PFA\n      ,-' _.-'        \\  /    |/'-._...--'\n     :--``             )/\n  '\n  ", 
                          buffalo = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n                   _.-````'-,_\n         _,.,_ ,-'`           `'-.,_\n       /)     (                   '``-.\n      ((      ) )                      `\\\n        \\)    (_/                        )\\\n        |       /)           '    ,'    / \\\n        `\\    ^'            '     (    /  ))\n          |      _/\\ ,     /    ,,`\\   (  \"`\n          \\Y,   |   \\  \\  | ````| / \\_ \\\n            `)_/      \\  \\  )    ( >  ( >\n                       \\( \\(     |/   |/\n          mic & dwb  /_(/_(    /_(  /_(\n    ", 
                          grumpycat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n      ﾊ _ ﾊ\n      ಠ X ಠ\n  ", smallcat = "\n -------------- \n%s \n --------------\n    \\\n     \\\n      \\\n         /\\_/\\\n        ( o.o )\n         > ^ <      [nosig]\n\n", yoda = "\n ----- \n%s \n ------ \n    \\   \n     \\\n                   ____\n                _.' :  `._\n            .-.'`.  ;   .'`.-.\n   __      / : ___\\ ;  /___ ; \\      __\n  ,'_ \"\"--.:__;\".-.\";: :\".-.\":__;.--\"\" _`,\n  :' `.t\"\"--.. '<@.`;_  ',@>` ..--\"\"j.' `;\n       `:-.._J '-.-'L__ `-- ' L_..-;'\n          \"-.__ ;  .-\"  \"-.  : __.-\"\n             L ' /.------.\\ ' J\n             \"-.   \"--\"   .-\"\n             __.l\"-:_JL_;-\";.__\n         .-j/'.;  ;\"\"\"\"  / .'\\\"-.\n         .' /:`. \"-.:     .-\" .';  `.\n      .-\"  / ;  \"-. \"-..-\" .-\"  :    \"-.\n  .+\"-.  : :      \"-.__.-\"      ;-._   \\\n  ; \\  `.; ;                    : : \"+. ;\n  :  ;   ; ;                    : ;  : \\:\n  ;  :   ; :                    ;:   ;  :\n  : \\  ;  :  ;                  : ;  /  ::\n  ;  ; :   ; :                  ;   :   ;:\n  :  :  ;  :  ;                : :  ;  : ;\n  ;\\    :   ; :                ; ;     ; ;\n  : `.\"-;   :  ;              :  ;    /  ;\n ;    -:   ; :              ;  : .-\"   :\n  :\\     \\  :  ;            : \\.-\"      :\n  ;`.    \\  ; :            ;.'_..--  / ;\n  :  \"-.  \"-:  ;          :/.\"      .'  :\n   \\         \\ :          ;/  __        :\n    \\       .-`.\\        /t-\"\"  \":-+.   :\n     `.  .-\"    `l    __/ /`. :  ; ; \\  ;\n       \\   .-\" .-\"-.-\"  .' .'j \\  /   ;/\n        \\ / .-\"   /.     .'.' ;_:'    ;\n  :-\"\"-.`./-.'     /    `.___.'\n               \\ `t  ._  /  bug\n                \"-.t-._:'\n  ", 
                          mushroom = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n                ________\n           __--´      ° `--__\n       __-´     °      °     `-__\n     (´    °    °          °     `)\n     (° °|    |°         ° |    | )\n      `'''''''''`|'''''|´''''''''´\n                 |     |\n                 |:::::|\n               /:|:::::|:\\\n              /::|:::::|::\\\n                 |     |\n                 |^   ^|\n                 |  _  | [FK]\n                 |_____|\n", 
                          endlesshorse = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n       ,\n    _,,)\\.~,,._\n     (()`  ``)\\))),,_\n      |     \\ ''((\\)))),,_          ____\n      |6`   |   ''((\\())) \"-.____.-\"    `-.-,\n      |    .'\\    ''))))'                  \\)))\n      |   |   `.     ''                     ((((\n      \\, _)     \\/                          |))))\n       `'        |                          (((((\n                 \\                  |       ))))))\n                  `|    |           ,\\     /((((((\n                   |   / `-.______.<  \\   |  )))))\n                   |   |  /         `. \\  \\  ((((\n                   |  / \\ |           `.\\  | (((\n                   \\  | | |             )| |  ))\n                    | | | |             || |  '   [endless.horse]\n                    | | | |             || |", 
                          bat = "\n ------------- \n%s \n -------------- \n              \\   \n               \\  \n                \\\n        __.--'\\     \\.__./     /'--.__\n    _.-'       '.__.'    '.__.'       '-._\n  .'                                      '.\n /                                          \\\n|                                            |\n|                                            |\n \\         .---.              .---.         /\n  '._    .'     '.''.    .''.'     '.    _.'\n     '-./            \\  /           \\.-'\n                      ''mrf\n", 
                          bat2 = "\n ------------- \n%s \n -------------- \n              \\   \n               \\  \n                \\\n_____________________                              _____________________\n`-._                 \\           |\\__/|           /                 _.-'\n    \\                 \\          |    |          /                 /\n     \\                 `-_______/      \\_______-'                 /\n      |                                                          |\n      |                                                          |\n      |                                                          |\n      /                                                          \\\n     /_____________                                  _____________\\\n                   `----._                    _.----'\n                          `--.            .--'\n                              `-.      .-'\n                                 \\    / :F_P:\n                                  \\  /\n                                   \\/\n", 
                          turkey = "\n ------------- \n%s \n -------------- \n              \\   \n               \\  \n                \\\n               .--.\n              /} p \\             /}\n             `~)-) /           /` }\n              ( / /          /`}.' }\n               / / .-'\"\"-.  / ' }-'}\n              / (.'       \\/ '.'}_.}\n             |            `}   .}._}\n             |     .-=-';   } ' }_.}\n             \\    `.-=-;'  } '.}.-}\n              '.   -=-'    ;,}._.}\n                `-,_  __.'` '-._}\n              jgs   `|||\n                   .=='=,\n", 
                          monkey = "\n ------------- \n%s \n -------------- \n              \\   \n               \\  \n                \\\n\n                  .=\"=.\n                _/.-.-.\\_     _\n               ( ( o o ) )    ))\n                |/  \"  \\|    //\n                 \\'---'/    //\n           jgs   /`\"\"\"`\\\\  ((\n                / /_,_\\ \\\\  \\\\\n                \\_\\_'__/  \\  ))\n                /`  /`~\\   |//\n               /   /    \\  /\n          ,--`,--'\\/\\    /\n          '-- \"--'  '--'\n", 
                          daemon = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n            ,        ,\n           /(        )`\n           \\ \\___   / |\n            /- _  `-/  '\n           (/\\/ \\ \\   /\\\n           / /   | `    \n           O O   ) /    |\n           `-^--'`<     '\n          (_.)  _  )   /\n           `.___/`    /\n             `-----' /\n<----.     __ / __   \\\n<----|====O)))==) \\) /====\n<----'    `--' `.__,' \\\n             |        |\n              \\       /\n        ______( (_  / \\______\n      ,'  ,-----'   |        \\\n      `--{__________)        \\/ [nosig]\n", 
                          egret = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n       \\   _,\n      -==<' `\n          ) /\n         / (_.\n        |  ,-,`\\\n         \\\\   \\ \\\n          `\\,  \\ \\\n           ||\\  \\`|,\n jgs      _|| `=`-'\n         ~~`~`\n", duckling = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n       \\\n\n        >o  .\n         ===    [ab]\n                 \n", duck = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n         __\n        /o \\\n      <=   |         ==\n        |__|        /===\n        |   \\______/  =\n        \\     ====   /\n         \\__________/     [ab]\n", 
                          owl = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n       /\\___/\\\n       {o}{o}|\n       \\ v  /|\n       |    \\ \\\n        \\___/_/       [ab] \n          | | \n", squirrel = "             ------ \n          %s \n             ------ \n                 \\   \n                  \\  \n                   \\\n                      . .     \n                      |\\|\\_   \n                      /  ^ \\  \n                     /  _-_/° \n   \\\\\\\\\\\\\\\\\\       /   / \\    \n  ////////////   /  \\ / ||    \n \\\\\\\\\\\\\\\\\\\\\\\\\\\\ /   /\\\\ \\\\    \n////////////////   /  \\\\ \\\\   \n \\\\\\\\\\\\\\\\\\\\\\\\\\/   /  / `` ``  \n     /////////   \\  /  \\      \n ML     \\\\\\\\\\\\___/_/___/      \n", 
                          squirrel2 = "             ------ \n          %s \n             ------ \n                 \\   \n                  \\  \n                   \\\n                      . .     \n                      |\\|\\_   \n                      /  @ \\  \n                     /  _-_/° \n   \\\\\\\\\\\\\\\\\\       /   / \\    \n  ////////////   /  \\ / ||    \n \\\\\\\\\\\\\\\\\\\\\\\\\\\\ /   /\\\\ \\\\    \n////////////////   /  \\\\ \\\\   \n \\\\\\\\\\\\\\\\\\\\\\\\\\/   /  / `` ``  \n     /////////   \\  /  \\      \n ML     \\\\\\\\\\\\___/_/___/      \n"
), c(cow = "\n ----- \n%s \n ------ \n    \\   ^__^ \n     \\  (oo)\\ ________ \n        (__)\\         )\\ /\\ \n             ||------w|\n             ||      ||", chicken = "\n ----- \n%s \n ------ \n    \\   \n     \\\n         _\n       _/ }\n      `>' \\\n      `|   \\\n       |   /'-.     .-.\n        \\'     ';`--' .'\n         \\'.    `'-./\n          '.`-..-;`\n            `;-..'\n            _| _|\n            /` /` [nosig]\n  ", chuck = "\n ----- \n%s \n ------ \n    \\   \n     \\\n                      @@@@@@@@@@@@@@                       \n                   @@@@@@@@@@@@@@@@@@@@@@                  \n                  @@@@@@@@@@@@@@@@@@@@@@@@@                \n                  @@@@@@@@@@@@@@@@@@@@@@@@@@               \n                  @@@@@@@@@@@@@@@@@@@@@@@@@@               \n                 @@@@@@@@@@@@@@@@@@@@@@@@@@@               \n                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@              \n                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@              \n                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     \n               @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  \n @             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n  @@           @@@@@@@@@@@@@@@@@@     @@@@@@@@@@@@@@@@@@@@@\n    @@@@@@@@@@@@@@@@    @@ @@@@         @@  @@@@@@@@@@@@@@@\n       @@@@@@@@@@@@@      @@@@          @@@@@@@@@@@@@@@@@@@\n          @@@@@@ @@@@@    @@@   @       @@@@@@@@@@ @@@@@@@ \n              @@     @ @                @@ @@@@@@@@   @@@  \n                                              @@@@@@@  @   \n                @     @@                   @ @@@@@@@@@     \n                             @               @@@@@@@@ @@   \n                     @@@@@@@@@@          @  @@@@@          \n                  @@@@@@@@@@ @@           @@@@@  @         \n                 @@@@        @@ @          @@@  @          \n                  @@@           @          @@@             \n                   @@@@@@@   @@ @          @@@@@           \n                    @@@@@@@@@@            @@@@             \n                     @@@@@@ @     @     @@@@@@@@           \n                  @@ @ @@@@@@@@@ @@@@@@@@@@@@@@@@@         \n                @@@  @@@@@   @@@@@@@@@@@@@@@@@@@@@         \n      @@@@@@  @@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   \n@@    @@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [nosig]\n  ", 
     clippy = "\n\n ----- \n%s \n ------ \n    \\   \n     \\   __\n   / \\\n   | |\n   @ @\n  || ||\n  || ||\n  |\\_/|\n  \\___/ GB\n", poop = "\n ----- \n%s \n ------ \n    \\   \n     \\\n     (   )\n  (   ) (\n   ) _   )\n    ( \\_\n  _(_\\ \\)__\n (____\\ ___)) [nosig]", bigcat = "\n ----- \n%s \n ------ \n    \\   \n     \\\n                \\`*-.\n                 )  _`-.\n                .  : `. .\n                : _   '  \\\n                ; *` _.   `*-._\n                `-.-'          `-.\n                  ;       `       `.\n                  :.       .       \\\n                  .\\  .   :   .-'   .\n                  '  `+.;  ;  '      :\n                  :  '  |    ;       ;-.\n                  ; '   : :`-:     _.`* ;\n               .*' /  .*' ; .*`- +'  `*'\n     [bug]     `*-*   `*-*  `*-*'\n    ", 
     ant = "\n ----- \n%s \n ------ \n    \\   \n     \\\n       '\\__\n      (o )     ___\n      <>(_)(_)(___)\n        < < > >\n        ' ' ` `  [nosig]\n  ", pumpkin = "\n ----- \n%s \n ------ \n    \\   \n     \\\n                  ___\n               ___)__|_\n          .-*'          '*-,\n         /      /|   |\\     \\\n        ;      /_|   |_\\     ;\n        ;   |\\           /|  ;\n        ;   | ''--...--'' |  ;\n         \\  ''---.....--''  /\n          ''*-.,_______,.-*'  [nosig]\n  ", ghost = "\n ----- \n%s \n ------ \n    \\   \n     \\\n     .-.\n    (o o)\n    | O \\\n     \\   \\\n      `~~~' [nosig]\n  ", 
     spider = "\n ----- \n%s \n ------ \n    \\   \n     \\\n              |\n              |\n              |\n             __\n          | /  \\ |\n         \\_\\\\  //_/\n          .'/()\\'.\n           \\\\  //  [nosig]\n  ", rabbit = "\n ----- \n%s \n ------ \n    \\   \n     \\\n      ( )_( )\n      (='.'=)\n      (^)_(^) [nosig]\n  ", pig = "\n ----- \n%s \n ------ \n    \\   \n     \\\n       _//| .-~~~-.\n     _/oo  }       }-@\n    ('')_  }       |\n     `--'| { }--{  }\n          //_/  /_/ [nosig]\n  ", 
     snowman = "\n ----- \n%s \n ------ \n    \\   \n     \\\n     _[_]_\n      (\")\n  >--( : )--<\n    (__:__) [nosig]\n  ", frog = "\n ----- \n%s \n ------ \n    \\   \n     \\\n        (.)_(.)\n     _ (   _   ) _\n    / \\/`-----'\\/ \\\n  __\\ ( (     ) ) /__\n  )   /\\ \\._./ /\\   (\n   )_/ /|\\   /|\\ \\_(  [nosig]\n  ", hypnotoad = "\n ----- \n%s \n ------\n    \\          ,'``.._   ,'``.\n     \\        :,--._:)\\,:,._,.:\n      \\       :`--,''   :`...';\\\n               `,'       `---'  `.\n               /                 :\n              /                   \\\n            ,'                     :\\.___,-.\n           `...,---'``````-..._    |:       \\\n             (                 )   ;:    )   \\  _,-.\n              `.              (   //          `'    \\\n               :               `.//  )      )     , ;\n             ,-|`.            _,'/       )    ) ,' ,'\n            (  :`.`-..____..=:.-':     .     _,' ,'\n             `,'\\ ``--....-)='    `._,  \\  ,') _ '``._\n          _.-/ _ `.       (_)      /     )' ; / \\ \\`-.'\n         `--(   `-:`.     `' ___..'  _,-'   |/   `.)\n             `-. `.`.``-----``--,  .'\n               |/`.\\`'        ,','); SSt\n                   `         (/  (/\n  ", 
     shortcat = "\n ----- \n%s \n ------ \n    \\   \n     \\\n    .ﾊ,,ﾊ\n    ( ﾟωﾟ)\n    |つ  つ\n    U \" U\n        [BoingBoing]\n    ", longcat = "\n ----- \n%s \n ------ \n    \\   \n     \\\n    .ﾊ,,ﾊ\n    ( ﾟωﾟ)\n    |つ  つ\n%s\n    U \"  U\n        [BoingBoing]\n    ", fish = "\n ----- \n%s \n ------ \n    \\   \n     \\\n  ><((((º>  ><((((º>  ><((((º>  ><((((º>  ><((((º>\n      Kiyoko Gotanda\n    ", signbunny = "\n -------------- \n%s \n --------------\n(\\__/) ||\n(•ㅅ•) ||\n/   づ\n          [nosig]\n    ", 
     facecat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n         /\\ /\\\n         (O o)\n        =(:^:)=\n           U      [nosig]\n  ", behindcat = "\n -------------- \n%s \n --------------\n      \\\n        \\\n          \\\n            |\\___/|\n            )     (\n           =\\     /=\n             )===(\n            /     \\\n            |     |\n           /       \\\n           \\       /\n      jgs   \\__  _/\n              ( (\n               ) )\n              (_(\n  ", 
     stretchycat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n                        ,/|         _.--‛‛^``-...___.._.,;\n                      /, \\‛.     _-‛          ,--,,,--‛‛‛\n                     {  \\    `_-‛‛       ‛    /}‛\nJill                    `;;‛             ;   ; ;\n                  ._.--‛‛     ._,,, _..‛  .;.‛\n                  (,_....----‛‛‛     (,..--‛‛\n  ", anxiouscat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n        /\\_/\\         _\n       /``   \\       / )\n       |n n   |__   ( (\n      =(Y =.‛`   `\\  \\ \\\n      {`\"`        \\  ) )\n      {       /    |/ /\n       \\\\   ,(     / /\n        ) ) /-‛\\  ,_.‛\n  jgs  (,(,/ ((,,/\n  ", 
     longtailcat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n     /\\-/\\\n    /a a  \\                                 _\n   =\\ Y  =/-~~~~~~-,_______________________/ )\n     ‛^--‛          ________________________/\n       \\           /\n       ||  |---‛\\  \\\n  jgs  (_(__|   ((__|\n  ", cat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n            |\\___/|\n          ==) ^Y^ (==\n            \\  ^  /\n             )=*=(\n            /     \\\n            |     |\n           /| | | |\\\n           \\| | |_|/\\\n      jgs  //_// ___/\n               \\_)\n  ", 
     trilobite = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n          _____\n       .'` ,-. `'.\n      /   ([ ])   \\\n     /.-\"\"`(`)`\"\"-.\\\n      <'```(.)```'>\n      <'```(.)```'>\n       <'``(.)``'>\n   sk   <``\\_/``>\n         `'---'`\n  ", shark = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n              /\"\"-._\n              .       '-,\n               :          '',\n                ;      *     '.\n                 ' *         () '.\n                   \\               \\\n                    \\      _.---.._ '.\n                    :  .' _.--''-''  \\ ,'\n        .._           '/.'             . ;\n        ; `-.          ,                \\'\n         ;   `,         ;              ._\\\n          ;    \\     _,-'                ''--._\n          :    \\_,-'                          '-._\n          \\ ,-'                       .          '-._\n          .'         __.-'';            \\...,__       '.\n        .'      _,-'        \\              \\   ''--.,__  '\\\n        /    _,--' ;         \\              ;           \\^.}\n        ;_,-' )     \\  )\\      )            ;\n             /       \\/  \\_.,-'             ;\n            /                              ;\n         ,-'  _,-'''-.    ,-.,            ;      PFA\n      ,-' _.-'        \\  /    |/'-._...--'\n     :--``             )/\n  '\n  ", 
     buffalo = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n                   _.-````'-,_\n         _,.,_ ,-'`           `'-.,_\n       /)     (                   '``-.\n      ((      ) )                      `\\\n        \\)    (_/                        )\\\n        |       /)           '    ,'    / \\\n        `\\    ^'            '     (    /  ))\n          |      _/\\ ,     /    ,,`\\   (  \"`\n          \\Y,   |   \\  \\  | ````| / \\_ \\\n            `)_/      \\  \\  )    ( >  ( >\n                       \\( \\(     |/   |/\n          mic & dwb  /_(/_(    /_(  /_(\n    ", 
     grumpycat = "\n -------------- \n%s \n --------------\n    \\\n      \\\n        \\\n      ﾊ _ ﾊ\n      ಠ X ಠ\n  ", smallcat = "\n -------------- \n%s \n --------------\n    \\\n     \\\n      \\\n         /\\_/\\\n        ( o.o )\n         > ^ <      [nosig]\n\n", yoda = "\n ----- \n%s \n ------ \n    \\   \n     \\\n                   ____\n                _.' :  `._\n            .-.'`.  ;   .'`.-.\n   __      / : ___\\ ;  /___ ; \\      __\n  ,'_ \"\"--.:__;\".-.\";: :\".-.\":__;.--\"\" _`,\n  :' `.t\"\"--.. '<@.`;_  ',@>` ..--\"\"j.' `;\n       `:-.._J '-.-'L__ `-- ' L_..-;'\n          \"-.__ ;  .-\"  \"-.  : __.-\"\n             L ' /.------.\\ ' J\n             \"-.   \"--\"   .-\"\n             __.l\"-:_JL_;-\";.__\n         .-j/'.;  ;\"\"\"\"  / .'\\\"-.\n         .' /:`. \"-.:     .-\" .';  `.\n      .-\"  / ;  \"-. \"-..-\" .-\"  :    \"-.\n  .+\"-.  : :      \"-.__.-\"      ;-._   \\\n  ; \\  `.; ;                    : : \"+. ;\n  :  ;   ; ;                    : ;  : \\:\n  ;  :   ; :                    ;:   ;  :\n  : \\  ;  :  ;                  : ;  /  ::\n  ;  ; :   ; :                  ;   :   ;:\n  :  :  ;  :  ;                : :  ;  : ;\n  ;\\    :   ; :                ; ;     ; ;\n  : `.\"-;   :  ;              :  ;    /  ;\n ;    -:   ; :              ;  : .-\"   :\n  :\\     \\  :  ;            : \\.-\"      :\n  ;`.    \\  ; :            ;.'_..--  / ;\n  :  \"-.  \"-:  ;          :/.\"      .'  :\n   \\         \\ :          ;/  __        :\n    \\       .-`.\\        /t-\"\"  \":-+.   :\n     `.  .-\"    `l    __/ /`. :  ; ; \\  ;\n       \\   .-\" .-\"-.-\"  .' .'j \\  /   ;/\n        \\ / .-\"   /.     .'.' ;_:'    ;\n  :-\"\"-.`./-.'     /    `.___.'\n               \\ `t  ._  /  bug\n                \"-.t-._:'\n  ", 
     mushroom = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n                ________\n           __--´      ° `--__\n       __-´     °      °     `-__\n     (´    °    °          °     `)\n     (° °|    |°         ° |    | )\n      `'''''''''`|'''''|´''''''''´\n                 |     |\n                 |:::::|\n               /:|:::::|:\\\n              /::|:::::|::\\\n                 |     |\n                 |^   ^|\n                 |  _  | [FK]\n                 |_____|\n", 
     endlesshorse = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n       ,\n    _,,)\\.~,,._\n     (()`  ``)\\))),,_\n      |     \\ ''((\\)))),,_          ____\n      |6`   |   ''((\\())) \"-.____.-\"    `-.-,\n      |    .'\\    ''))))'                  \\)))\n      |   |   `.     ''                     ((((\n      \\, _)     \\/                          |))))\n       `'        |                          (((((\n                 \\                  |       ))))))\n                  `|    |           ,\\     /((((((\n                   |   / `-.______.<  \\   |  )))))\n                   |   |  /         `. \\  \\  ((((\n                   |  / \\ |           `.\\  | (((\n                   \\  | | |             )| |  ))\n                    | | | |             || |  '   [endless.horse]\n                    | | | |             || |", 
     bat = "\n ------------- \n%s \n -------------- \n              \\   \n               \\  \n                \\\n        __.--'\\     \\.__./     /'--.__\n    _.-'       '.__.'    '.__.'       '-._\n  .'                                      '.\n /                                          \\\n|                                            |\n|                                            |\n \\         .---.              .---.         /\n  '._    .'     '.''.    .''.'     '.    _.'\n     '-./            \\  /           \\.-'\n                      ''mrf\n", 
     bat2 = "\n ------------- \n%s \n -------------- \n              \\   \n               \\  \n                \\\n_____________________                              _____________________\n`-._                 \\           |\\__/|           /                 _.-'\n    \\                 \\          |    |          /                 /\n     \\                 `-_______/      \\_______-'                 /\n      |                                                          |\n      |                                                          |\n      |                                                          |\n      /                                                          \\\n     /_____________                                  _____________\\\n                   `----._                    _.----'\n                          `--.            .--'\n                              `-.      .-'\n                                 \\    / :F_P:\n                                  \\  /\n                                   \\/\n", 
     turkey = "\n ------------- \n%s \n -------------- \n              \\   \n               \\  \n                \\\n               .--.\n              /} p \\             /}\n             `~)-) /           /` }\n              ( / /          /`}.' }\n               / / .-'\"\"-.  / ' }-'}\n              / (.'       \\/ '.'}_.}\n             |            `}   .}._}\n             |     .-=-';   } ' }_.}\n             \\    `.-=-;'  } '.}.-}\n              '.   -=-'    ;,}._.}\n                `-,_  __.'` '-._}\n              jgs   `|||\n                   .=='=,\n", 
     monkey = "\n ------------- \n%s \n -------------- \n              \\   \n               \\  \n                \\\n\n                  .=\"=.\n                _/.-.-.\\_     _\n               ( ( o o ) )    ))\n                |/  \"  \\|    //\n                 \\'---'/    //\n           jgs   /`\"\"\"`\\\\  ((\n                / /_,_\\ \\\\  \\\\\n                \\_\\_'__/  \\  ))\n                /`  /`~\\   |//\n               /   /    \\  /\n          ,--`,--'\\/\\    /\n          '-- \"--'  '--'\n", 
     daemon = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n            ,        ,\n           /(        )`\n           \\ \\___   / |\n            /- _  `-/  '\n           (/\\/ \\ \\   /\\\n           / /   | `    \n           O O   ) /    |\n           `-^--'`<     '\n          (_.)  _  )   /\n           `.___/`    /\n             `-----' /\n<----.     __ / __   \\\n<----|====O)))==) \\) /====\n<----'    `--' `.__,' \\\n             |        |\n              \\       /\n        ______( (_  / \\______\n      ,'  ,-----'   |        \\\n      `--{__________)        \\/ [nosig]\n", 
     egret = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n       \\   _,\n      -==<' `\n          ) /\n         / (_.\n        |  ,-,`\\\n         \\\\   \\ \\\n          `\\,  \\ \\\n           ||\\  \\`|,\n jgs      _|| `=`-'\n         ~~`~`\n", duckling = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n       \\\n\n        >o  .\n         ===    [ab]\n                 \n", duck = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n         __\n        /o \\\n      <=   |         ==\n        |__|        /===\n        |   \\______/  =\n        \\     ====   /\n         \\__________/     [ab]\n", 
     owl = "\n ----- \n%s \n ------ \n    \\   \n     \\  \n      \\\n       /\\___/\\\n       {o}{o}|\n       \\ v  /|\n       |    \\ \\\n        \\___/_/       [ab] \n          | | \n", squirrel = "             ------ \n          %s \n             ------ \n                 \\   \n                  \\  \n                   \\\n                      . .     \n                      |\\|\\_   \n                      /  ^ \\  \n                     /  _-_/° \n   \\\\\\\\\\\\\\\\\\       /   / \\    \n  ////////////   /  \\ / ||    \n \\\\\\\\\\\\\\\\\\\\\\\\\\\\ /   /\\\\ \\\\    \n////////////////   /  \\\\ \\\\   \n \\\\\\\\\\\\\\\\\\\\\\\\\\/   /  / `` ``  \n     /////////   \\  /  \\      \n ML     \\\\\\\\\\\\___/_/___/      \n", 
     squirrel2 = "             ------ \n          %s \n             ------ \n                 \\   \n                  \\  \n                   \\\n                      . .     \n                      |\\|\\_   \n                      /  @ \\  \n                     /  _-_/° \n   \\\\\\\\\\\\\\\\\\       /   / \\    \n  ////////////   /  \\ / ||    \n \\\\\\\\\\\\\\\\\\\\\\\\\\\\ /   /\\\\ \\\\    \n////////////////   /  \\\\ \\\\   \n \\\\\\\\\\\\\\\\\\\\\\\\\\/   /  / `` ``  \n     /////////   \\  /  \\      \n ML     \\\\\\\\\\\\___/_/___/      \n"
))
c("package:cowsay", "namespace:cowsay")
c(TRUE, FALSE)
c(FALSE, TRUE)
2) endless_horse
list(`package:cowsay` = function (what = "Hello world!", endless = TRUE, wait = 0.5, what_color = NULL, horse_color = NULL) 
{
  if (!is.null(what_color) & !(inherits(what_color, c("crayon", "character")))) {
    stop("what_color must be of class character or crayon", call. = FALSE)
  }
  if (!is.null(horse_color) & !(inherits(horse_color, c("crayon", "character")))) {
    stop("by_color must be of class character or crayon", call. = FALSE)
  }
  if (!is.null(what_color) & is.character(what_color)) {
    what_color <- crayon::make_style(what_color)
  }
  else if (!is.null(what_color) & is.function(what_color)) {
    what_color <- what_color
  }
  else {
    what_color <- function(x) x
  }
  if (!is.null(horse_color) & is.character(horse_color)) {
    horse_color <- crayon::make_style(horse_color)
  }
  else if (!is.null(horse_color) & is.function(horse_color)) {
    horse_color <- horse_color
  }
  else {
    horse_color <- function(x) x
  }
  horse <- get_who("endlesshorse", NULL)
  what_pos_start <- regexpr("%s", horse)[1] - 1
  what_pos_end <- what_pos_start + 3
  horse <- paste0(horse_color(substr(horse, 1, what_pos_start)), what_color(what), horse_color(substr(horse, what_pos_end, nchar(horse))))
  message(horse)
  while (endless) {
    tryCatch(interrupt = function(e) {
      endless <<- FALSE
    }, {
      Sys.sleep(wait)
      message(horse_color("                    | | | |             || |"))
      wait <- wait * 1.1
    })
  }
}, function (what = "Hello world!", endless = TRUE, wait = 0.5, what_color = NULL, horse_color = NULL) 
{
  if (!is.null(what_color) & !(inherits(what_color, c("crayon", "character")))) {
    stop("what_color must be of class character or crayon", call. = FALSE)
  }
  if (!is.null(horse_color) & !(inherits(horse_color, c("crayon", "character")))) {
    stop("by_color must be of class character or crayon", call. = FALSE)
  }
  if (!is.null(what_color) & is.character(what_color)) {
    what_color <- crayon::make_style(what_color)
  }
  else if (!is.null(what_color) & is.function(what_color)) {
    what_color <- what_color
  }
  else {
    what_color <- function(x) x
  }
  if (!is.null(horse_color) & is.character(horse_color)) {
    horse_color <- crayon::make_style(horse_color)
  }
  else if (!is.null(horse_color) & is.function(horse_color)) {
    horse_color <- horse_color
  }
  else {
    horse_color <- function(x) x
  }
  horse <- get_who("endlesshorse", NULL)
  what_pos_start <- regexpr("%s", horse)[1] - 1
  what_pos_end <- what_pos_start + 3
  horse <- paste0(horse_color(substr(horse, 1, what_pos_start)), what_color(what), horse_color(substr(horse, what_pos_end, nchar(horse))))
  message(horse)
  while (endless) {
    tryCatch(interrupt = function(e) {
      endless <<- FALSE
    }, {
      Sys.sleep(wait)
      message(horse_color("                    | | | |             || |"))
      wait <- wait * 1.1
    })
  }
})
c("package:cowsay", "namespace:cowsay")
c(TRUE, FALSE)
c(FALSE, TRUE)
3) say
list(`package:cowsay` = function (what = "Hello world!", by = "cat", type = NULL, what_color = NULL, by_color = NULL, length = 18, fortune = NULL, ...) 
{
  if (length(what) > 1) {
    stop("what has to be of length 1", call. = FALSE)
  }
  if (crayon::has_color() == FALSE && (!is.null(what_color) || !is.null(by_color))) {
    message("Colors cannot be applied in this environment :( Try using a terminal or RStudio.")
    what_color <- NULL
    by_color <- NULL
  }
  else {
    what_color <- check_color(what_color)
    by_color <- check_color(by_color)
  }
  if (is.null(type)) {
    if (interactive()) {
      type <- "message"
    }
    else {
      type <- "print"
    }
  }
  if (what == "catfact") {
    check4pkg("jsonlite")
    what <- jsonlite::fromJSON("https://catfact.ninja/fact")$fact
    by <- "cat"
  }
  who <- get_who(by, length = length)
  if (!is.null(fortune)) 
    what <- "fortune"
  if (what == "time") 
    what <- as.character(Sys.time())
  if (what == "fortune") {
    if (is.null(fortune)) 
      fortune <- sample(1:360, 1)
    what <- fortune(which = fortune, ...)
    what <- what[!is.na(what)]
    what <- gsub("<x>", "\n", paste(as.character(what), collapse = "\n "))
  }
  if (by == "hypnotoad" && what == "Hello world!") {
    what <- "All Glory to the HYPNO TOAD!"
  }
  if (what == "rms") {
    what <- rmsfact::rmsfact()
  }
  if (what %in% c("arresteddevelopment", "doctorwho", "dexter", "futurama", "holygrail", "simpsons", "starwars", "loremipsum")) {
    stop("sorry, fillerama API is down", call. = FALSE)
  }
  what_pos_start <- regexpr("%s", who)[1] - 1
  what_pos_end <- what_pos_start + 3
  color_text <- function(txt, c) {
    if (is.null(c)) {
      out <- txt
    }
    else if (!is.null(c) && inherits(c, "crayon")) {
      out <- c(txt)
    }
    else if (!is.null(c) && is.character(c)) {
      if (length(c) <= 1) {
        c <- crayon::make_style(c)
        out <- c(txt)
      }
      else if (length(c) >= 1) {
        out <- multicolor::multi_color(txt, c, type = "string")
      }
    }
    return(out)
  }
  out <- paste0(color_text(substr(who, 1, what_pos_start), by_color), color_text(what, what_color), color_text(substr(who, what_pos_end, nchar(who)), by_color))
  if (type == "warning") {
    if (nchar(out) < 100) {
      wl <- 100
    }
    else if (nchar(out) > 8170) {
      wl <- 8170
    }
    else {
      wl <- nchar(out) + 1
    }
    warn_op <- options(warning.length = wl)
    on.exit(options(warn_op))
  }
  switch(type, message = message(out), warning = warning(out), print = cat(out), string = out)
}, function (what = "Hello world!", by = "cat", type = NULL, what_color = NULL, by_color = NULL, length = 18, fortune = NULL, ...) 
{
  if (length(what) > 1) {
    stop("what has to be of length 1", call. = FALSE)
  }
  if (crayon::has_color() == FALSE && (!is.null(what_color) || !is.null(by_color))) {
    message("Colors cannot be applied in this environment :( Try using a terminal or RStudio.")
    what_color <- NULL
    by_color <- NULL
  }
  else {
    what_color <- check_color(what_color)
    by_color <- check_color(by_color)
  }
  if (is.null(type)) {
    if (interactive()) {
      type <- "message"
    }
    else {
      type <- "print"
    }
  }
  if (what == "catfact") {
    check4pkg("jsonlite")
    what <- jsonlite::fromJSON("https://catfact.ninja/fact")$fact
    by <- "cat"
  }
  who <- get_who(by, length = length)
  if (!is.null(fortune)) 
    what <- "fortune"
  if (what == "time") 
    what <- as.character(Sys.time())
  if (what == "fortune") {
    if (is.null(fortune)) 
      fortune <- sample(1:360, 1)
    what <- fortune(which = fortune, ...)
    what <- what[!is.na(what)]
    what <- gsub("<x>", "\n", paste(as.character(what), collapse = "\n "))
  }
  if (by == "hypnotoad" && what == "Hello world!") {
    what <- "All Glory to the HYPNO TOAD!"
  }
  if (what == "rms") {
    what <- rmsfact::rmsfact()
  }
  if (what %in% c("arresteddevelopment", "doctorwho", "dexter", "futurama", "holygrail", "simpsons", "starwars", "loremipsum")) {
    stop("sorry, fillerama API is down", call. = FALSE)
  }
  what_pos_start <- regexpr("%s", who)[1] - 1
  what_pos_end <- what_pos_start + 3
  color_text <- function(txt, c) {
    if (is.null(c)) {
      out <- txt
    }
    else if (!is.null(c) && inherits(c, "crayon")) {
      out <- c(txt)
    }
    else if (!is.null(c) && is.character(c)) {
      if (length(c) <= 1) {
        c <- crayon::make_style(c)
        out <- c(txt)
      }
      else if (length(c) >= 1) {
        out <- multicolor::multi_color(txt, c, type = "string")
      }
    }
    return(out)
  }
  out <- paste0(color_text(substr(who, 1, what_pos_start), by_color), color_text(what, what_color), color_text(substr(who, what_pos_end, nchar(who)), by_color))
  if (type == "warning") {
    if (nchar(out) < 100) {
      wl <- 100
    }
    else if (nchar(out) > 8170) {
      wl <- 8170
    }
    else {
      wl <- nchar(out) + 1
    }
    warn_op <- options(warning.length = wl)
    on.exit(options(warn_op))
  }
  switch(type, message = message(out), warning = warning(out), print = cat(out), string = out)
})
c("package:cowsay", "namespace:cowsay")
c(TRUE, FALSE)
c(FALSE, TRUE)


