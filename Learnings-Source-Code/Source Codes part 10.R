library(stats)
library(stringr)
library(stringi)
library(utils)
library(wikifacts)

library(stats)
.checkMFClasses
list(`package:stats` = function (cl, m, ordNotOK = FALSE) 
{
  new <- vapply(m, .MFclass, "")
  new <- new[names(new) %in% names(cl)]
  if (length(new) == 0) 
    return(invisible())
  old <- cl[names(new)]
  if (!ordNotOK) {
    old[old == "ordered"] <- "factor"
    new[new == "ordered"] <- "factor"
  }
  new[new == "ordered" & old == "factor"] <- "factor"
  new[new == "factor" & old == "character"] <- "character"
  if (!identical(old, new)) {
    wrong <- old != new
    if (sum(wrong) == 1) 
      stop(gettextf("variable '%s' was fitted with type \"%s\" but type \"%s\" was supplied", names(old)[wrong], old[wrong], new[wrong]), call. = FALSE, domain = NA)
    else stop(gettextf("variables %s were specified with different types from the fit", paste(sQuote(names(old)[wrong]), collapse = ", ")), call. = FALSE, domain = NA)
  }
  else invisible()
}, function (cl, m, ordNotOK = FALSE) 
{
  new <- vapply(m, .MFclass, "")
  new <- new[names(new) %in% names(cl)]
  if (length(new) == 0) 
    return(invisible())
  old <- cl[names(new)]
  if (!ordNotOK) {
    old[old == "ordered"] <- "factor"
    new[new == "ordered"] <- "factor"
  }
  new[new == "ordered" & old == "factor"] <- "factor"
  new[new == "factor" & old == "character"] <- "character"
  if (!identical(old, new)) {
    wrong <- old != new
    if (sum(wrong) == 1) 
      stop(gettextf("variable '%s' was fitted with type \"%s\" but type \"%s\" was supplied", names(old)[wrong], old[wrong], new[wrong]), call. = FALSE, domain = NA)
    else stop(gettextf("variables %s were specified with different types from the fit", paste(sQuote(names(old)[wrong]), collapse = ", ")), call. = FALSE, domain = NA)
  }
  else invisible()
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
.getXlevels
list(`package:stats` = function (Terms, m) 
{
  xvars <- vapply(attr(Terms, "variables"), deparse2, "")[-1]
  if ((yvar <- attr(Terms, "response")) > 0) 
    xvars <- xvars[-yvar]
  if (length(xvars)) {
    xlev <- lapply(m[xvars], function(x) if (is.factor(x)) 
      levels(x)
      else if (is.character(x)) 
        levels(as.factor(x)))
    xlev[!vapply(xlev, is.null, NA)]
  }
}, function (Terms, m) 
{
  xvars <- vapply(attr(Terms, "variables"), deparse2, "")[-1]
  if ((yvar <- attr(Terms, "response")) > 0) 
    xvars <- xvars[-yvar]
  if (length(xvars)) {
    xlev <- lapply(m[xvars], function(x) if (is.factor(x)) 
      levels(x)
      else if (is.character(x)) 
        levels(as.factor(x)))
    xlev[!vapply(xlev, is.null, NA)]
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
.lm.fit
list(`package:stats` = function (x, y, tol = 1e-07) 
  .Call(C_Cdqrls, x, y, tol, check = TRUE), function (x, y, tol = 1e-07) 
    .Call(C_Cdqrls, x, y, tol, check = TRUE))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
.MFclass
list(`package:stats` = function (x) 
{
  if (is.logical(x)) 
    return("logical")
  if (is.ordered(x)) 
    return("ordered")
  if (is.factor(x)) 
    return("factor")
  if (is.character(x)) 
    return("character")
  if (is.matrix(x) && is.numeric(x)) 
    return(paste0("nmatrix.", ncol(x)))
  if (is.numeric(x)) 
    return("numeric")
  return("other")
}, function (x) 
{
  if (is.logical(x)) 
    return("logical")
  if (is.ordered(x)) 
    return("ordered")
  if (is.factor(x)) 
    return("factor")
  if (is.character(x)) 
    return("character")
  if (is.matrix(x) && is.numeric(x)) 
    return(paste0("nmatrix.", ncol(x)))
  if (is.numeric(x)) 
    return("numeric")
  return("other")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
.nknots.smspl
list(`package:stats` = function (n) 
{
  if (n < 50) 
    n
  else trunc({
    a1 <- log2(50)
    a2 <- log2(100)
    a3 <- log2(140)
    a4 <- log2(200)
    if (n < 200) 2^(a1 + (a2 - a1) * (n - 50)/150) else if (n < 800) 2^(a2 + (a3 - a2) * (n - 200)/600) else if (n < 3200) 2^(a3 + (a4 - a3) * (n - 800)/2400) else 200 + (n - 3200)^0.2
  })
}, function (n) 
{
  if (n < 50) 
    n
  else trunc({
    a1 <- log2(50)
    a2 <- log2(100)
    a3 <- log2(140)
    a4 <- log2(200)
    if (n < 200) 2^(a1 + (a2 - a1) * (n - 50)/150) else if (n < 800) 2^(a2 + (a3 - a2) * (n - 200)/600) else if (n < 3200) 2^(a3 + (a4 - a3) * (n - 800)/2400) else 200 + (n - 3200)^0.2
  })
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
.preformat.ts
list(`package:stats` = function (x, calendar, ...) 
{
  fr.x <- frequency(x)
  if (missing(calendar)) 
    calendar <- any(fr.x == c(4, 12)) && length(start(x)) == 2
  Tsp <- tsp(x)
  if (is.null(Tsp)) 
    stop("series is corrupt, with no 'tsp' attribute")
  nn <- 1 + round((Tsp[2] - Tsp[1]) * Tsp[3])
  if (NROW(x) != nn) {
    warning(gettextf("series is corrupt: length %d with 'tsp' implying %d", NROW(x), nn), domain = NA, call. = FALSE)
    calendar <- FALSE
  }
  if (NCOL(x) == 1) {
    if (calendar) {
      if (fr.x > 1) {
        dn2 <- if (fr.x == 12) 
          month.abb
        else if (fr.x == 4) {
          c("Qtr1", "Qtr2", "Qtr3", "Qtr4")
        }
        else paste0("p", 1:fr.x)
        if (NROW(x) <= fr.x && start(x)[1] == end(x)[1]) {
          dn1 <- start(x)[1]
          dn2 <- dn2[1 + (start(x)[2] - 2 + seq_along(x))%%fr.x]
          x <- matrix(format(x, ...), nrow = 1, byrow = TRUE, dimnames = list(dn1, dn2))
        }
        else {
          start.pad <- start(x)[2] - 1
          end.pad <- fr.x - end(x)[2]
          dn1 <- start(x)[1]:end(x)[1]
          x <- matrix(c(rep.int("", start.pad), format(x, ...), rep.int("", end.pad)), ncol = fr.x, byrow = TRUE, dimnames = list(dn1, dn2))
        }
      }
      else {
        tx <- time(x)
        attributes(x) <- NULL
        names(x) <- tx
      }
    }
    else {
      attr(x, "class") <- attr(x, "tsp") <- attr(x, "na.action") <- NULL
    }
  }
  else {
    rownames(x) <- if (calendar && fr.x > 1) {
      tm <- time(x)
      t2 <- 1 + round(fr.x * ((tm + 0.001)%%1))
      p1 <- format(floor(zapsmall(tm, digits = 7)))
      if (fr.x == 12) 
        paste(month.abb[t2], p1)
      else paste(p1, if (fr.x == 4) 
        c("Q1", "Q2", "Q3", "Q4")[t2]
        else format(t2))
    }
    else format(time(x))
    attr(x, "class") <- attr(x, "tsp") <- attr(x, "na.action") <- NULL
  }
  x
}, function (x, calendar, ...) 
{
  fr.x <- frequency(x)
  if (missing(calendar)) 
    calendar <- any(fr.x == c(4, 12)) && length(start(x)) == 2
  Tsp <- tsp(x)
  if (is.null(Tsp)) 
    stop("series is corrupt, with no 'tsp' attribute")
  nn <- 1 + round((Tsp[2] - Tsp[1]) * Tsp[3])
  if (NROW(x) != nn) {
    warning(gettextf("series is corrupt: length %d with 'tsp' implying %d", NROW(x), nn), domain = NA, call. = FALSE)
    calendar <- FALSE
  }
  if (NCOL(x) == 1) {
    if (calendar) {
      if (fr.x > 1) {
        dn2 <- if (fr.x == 12) 
          month.abb
        else if (fr.x == 4) {
          c("Qtr1", "Qtr2", "Qtr3", "Qtr4")
        }
        else paste0("p", 1:fr.x)
        if (NROW(x) <= fr.x && start(x)[1] == end(x)[1]) {
          dn1 <- start(x)[1]
          dn2 <- dn2[1 + (start(x)[2] - 2 + seq_along(x))%%fr.x]
          x <- matrix(format(x, ...), nrow = 1, byrow = TRUE, dimnames = list(dn1, dn2))
        }
        else {
          start.pad <- start(x)[2] - 1
          end.pad <- fr.x - end(x)[2]
          dn1 <- start(x)[1]:end(x)[1]
          x <- matrix(c(rep.int("", start.pad), format(x, ...), rep.int("", end.pad)), ncol = fr.x, byrow = TRUE, dimnames = list(dn1, dn2))
        }
      }
      else {
        tx <- time(x)
        attributes(x) <- NULL
        names(x) <- tx
      }
    }
    else {
      attr(x, "class") <- attr(x, "tsp") <- attr(x, "na.action") <- NULL
    }
  }
  else {
    rownames(x) <- if (calendar && fr.x > 1) {
      tm <- time(x)
      t2 <- 1 + round(fr.x * ((tm + 0.001)%%1))
      p1 <- format(floor(zapsmall(tm, digits = 7)))
      if (fr.x == 12) 
        paste(month.abb[t2], p1)
      else paste(p1, if (fr.x == 4) 
        c("Q1", "Q2", "Q3", "Q4")[t2]
        else format(t2))
    }
    else format(time(x))
    attr(x, "class") <- attr(x, "tsp") <- attr(x, "na.action") <- NULL
  }
  x
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
.vcov.aliased
list(`package:stats` = function (aliased, vc, complete = TRUE) 
{
  if (complete && NROW(vc) < (P <- length(aliased)) && any(aliased)) {
    cn <- names(aliased)
    VC <- matrix(NA, P, P, dimnames = list(cn, cn))
    j <- which(!aliased)
    VC[j, j] <- vc
    VC
  }
  else vc
}, function (aliased, vc, complete = TRUE) 
{
  if (complete && NROW(vc) < (P <- length(aliased)) && any(aliased)) {
    cn <- names(aliased)
    VC <- matrix(NA, P, P, dimnames = list(cn, cn))
    j <- which(!aliased)
    VC[j, j] <- vc
    VC
  }
  else vc
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
acf
list(`package:stats` = function (x, lag.max = NULL, type = c("correlation", "covariance", "partial"), plot = TRUE, na.action = na.fail, demean = TRUE, ...) 
{
  type <- match.arg(type)
  if (type == "partial") {
    m <- match.call()
    m[[1]] <- quote(stats::pacf)
    m$type <- NULL
    return(eval(m, parent.frame()))
  }
  series <- deparse1(substitute(x))
  x <- na.action(as.ts(x))
  x.freq <- frequency(x)
  x <- as.matrix(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  sampleT <- as.integer(nrow(x))
  nser <- as.integer(ncol(x))
  if (is.na(sampleT) || is.na(nser)) 
    stop("'sampleT' and 'nser' must be integer")
  if (is.null(lag.max)) 
    lag.max <- floor(10 * (log10(sampleT) - log10(nser)))
  lag.max <- as.integer(min(lag.max, sampleT - 1))
  if (is.na(lag.max) || lag.max < 0) 
    stop("'lag.max' must be at least 0")
  if (demean) 
    x <- sweep(x, 2, colMeans(x, na.rm = TRUE), check.margin = FALSE)
  lag <- matrix(1, nser, nser)
  lag[lower.tri(lag)] <- -1
  acf <- .Call(C_acf, x, lag.max, type == "correlation")
  lag <- outer(0:lag.max, lag/x.freq)
  acf.out <- structure(list(acf = acf, type = type, n.used = sampleT, lag = lag, series = series, snames = colnames(x)), class = "acf")
  if (plot) {
    plot.acf(acf.out, ...)
    invisible(acf.out)
  }
  else acf.out
}, function (x, lag.max = NULL, type = c("correlation", "covariance", "partial"), plot = TRUE, na.action = na.fail, demean = TRUE, ...) 
{
  type <- match.arg(type)
  if (type == "partial") {
    m <- match.call()
    m[[1]] <- quote(stats::pacf)
    m$type <- NULL
    return(eval(m, parent.frame()))
  }
  series <- deparse1(substitute(x))
  x <- na.action(as.ts(x))
  x.freq <- frequency(x)
  x <- as.matrix(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  sampleT <- as.integer(nrow(x))
  nser <- as.integer(ncol(x))
  if (is.na(sampleT) || is.na(nser)) 
    stop("'sampleT' and 'nser' must be integer")
  if (is.null(lag.max)) 
    lag.max <- floor(10 * (log10(sampleT) - log10(nser)))
  lag.max <- as.integer(min(lag.max, sampleT - 1))
  if (is.na(lag.max) || lag.max < 0) 
    stop("'lag.max' must be at least 0")
  if (demean) 
    x <- sweep(x, 2, colMeans(x, na.rm = TRUE), check.margin = FALSE)
  lag <- matrix(1, nser, nser)
  lag[lower.tri(lag)] <- -1
  acf <- .Call(C_acf, x, lag.max, type == "correlation")
  lag <- outer(0:lag.max, lag/x.freq)
  acf.out <- structure(list(acf = acf, type = type, n.used = sampleT, lag = lag, series = series, snames = colnames(x)), class = "acf")
  if (plot) {
    plot.acf(acf.out, ...)
    invisible(acf.out)
  }
  else acf.out
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
acf2AR
list(`package:stats` = function (acf) 
{
  r <- as.double(drop(acf))
  order.max <- length(r) - 1
  if (order.max <= 0) 
    stop("'acf' must be of length two or more")
  z <- .Fortran(C_eureka, as.integer(order.max), r, r, coefs = double(order.max^2), vars = double(order.max), double(order.max))
  nm <- paste0("ar(", 1:order.max, ")")
  matrix(z$coefs, order.max, order.max, dimnames = list(nm, 1:order.max))
}, function (acf) 
{
  r <- as.double(drop(acf))
  order.max <- length(r) - 1
  if (order.max <= 0) 
    stop("'acf' must be of length two or more")
  z <- .Fortran(C_eureka, as.integer(order.max), r, r, coefs = double(order.max^2), vars = double(order.max), double(order.max))
  nm <- paste0("ar(", 1:order.max, ")")
  matrix(z$coefs, order.max, order.max, dimnames = list(nm, 1:order.max))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
add.scope
list(`package:stats` = function (terms1, terms2) 
{
  terms1 <- terms(terms1)
  terms2 <- terms(terms2)
  factor.scope(attr(terms1, "factors"), list(add = attr(terms2, "factors")))$add
}, function (terms1, terms2) 
{
  terms1 <- terms(terms1)
  terms2 <- terms(terms2)
  factor.scope(attr(terms1, "factors"), list(add = attr(terms2, "factors")))$add
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
add1
list(`package:stats` = function (object, scope, ...) 
  UseMethod("add1"), function (object, scope, ...) 
    UseMethod("add1"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
addmargins
list(`package:stats` = function (A, margin = seq_along(dim(A)), FUN = sum, quiet = FALSE) 
{
  if (is.null(dim(A))) 
    stop("'A' must be an array or table")
  n.sid <- length(margin)
  miss.FUN <- missing(FUN)
  if (length(FUN) == 1 && !is.list(FUN)) {
    fname <- if (!miss.FUN) 
      deparse1(substitute(FUN))
    else "Sum"
    FUN <- setNames(list(FUN), fname)
  }
  if (!miss.FUN) {
    add.names <- function(thelist) {
      n <- names(thelist) %||% rep("", length(thelist))
      for (i in seq_along(thelist)[-1]) {
        if (!is.call(thelist[[i]])) {
          if (n[i] == "") 
            n[i] <- as.character(thelist[[i]])
        }
        else if (as.character(thelist[[i]][[1]]) == "list") 
          thelist[[i]] <- add.names(thelist[[i]])
      }
      names(thelist) <- n
      thelist
    }
    if (mode(substitute(FUN)) == "call") 
      FUN <- eval.parent(add.names(substitute(FUN)))
    if (is.null(names(FUN))) 
      names(FUN) <- rep("", length(FUN))
  }
  if (length(FUN) != n.sid) {
    if (length(FUN) == 1) 
      FUN <- rep(FUN, n.sid)
    else stop(gettextf("length of FUN, %d,\n does not match the length of the margins, %d", length(FUN), n.sid), domain = NA)
  }
  fnames <- vector("list", n.sid)
  for (i in seq_along(FUN)) {
    fnames[[i]] <- names(FUN)[i]
    if (is.list(FUN[[i]])) {
      topname <- fnames[[i]]
      fnames[[i]] <- names(FUN[[i]])
      blank <- fnames[[i]] == ""
      fnames[[i]][blank] <- seq_along(blank)[blank]
      if (topname == "") {
        fnames[[i]][blank] <- paste0("Margin ", margin[i], ".", fnames[[i]][blank])
      }
      else {
        fnames[[i]] <- paste0(topname, ".", fnames[[i]])
      }
    }
    else if (fnames[[i]] == "") 
      fnames[[i]] <- paste("Margin", margin[i])
  }
  expand.one <- function(A, margin, FUN, fnames) {
    if (!inherits(FUN, "list")) 
      FUN <- list(FUN)
    d <- dim(A)
    n.dim <- length(d)
    n.mar <- length(FUN)
    newdim <- d
    newdim[margin] <- newdim[margin] + n.mar
    dnA <- dimnames(A) %||% vector("list", n.dim)
    dnA[[margin]] <- c(if (is.null(dnA[[margin]])) rep("", d[[margin]]) else dnA[[margin]], fnames)
    n.new <- prod(newdim)
    skip <- prod(d[1:margin])
    runl <- skip/d[margin]
    apos <- rep(c(rep_len(TRUE, skip), rep_len(FALSE, n.mar * runl)), n.new/(skip + n.mar * runl))
    values <- double(length(apos))
    values[apos] <- as.vector(A)
    for (i in 1:n.mar) {
      mtab <- if (n.dim > 1) 
        apply(A, (1:n.dim)[-margin], FUN[[i]])
      else FUN[[i]](A)
      select <- rep_len(FALSE, n.mar)
      select[i] <- TRUE
      mpos <- rep(c(rep_len(FALSE, skip), rep(select, each = runl)), prod(dim(A))/skip)
      values[mpos] <- as.vector(mtab)
    }
    array(values, dim = newdim, dimnames = dnA)
  }
  new.A <- A
  for (i in 1:n.sid) new.A <- expand.one(A = new.A, margin = margin[i], FUN = FUN[[i]], fnames = fnames[[i]])
  if (inherits(A, "table")) 
    class(new.A) <- c("table", class(new.A))
  if (!quiet && !miss.FUN && n.sid > 1) {
    cat("Margins computed over dimensions\nin the following order:\n")
    for (i in seq_len(n.sid)) cat(paste(i), ": ", names(dimnames(A))[margin[i]], "\n", sep = "")
  }
  new.A
}, function (A, margin = seq_along(dim(A)), FUN = sum, quiet = FALSE) 
{
  if (is.null(dim(A))) 
    stop("'A' must be an array or table")
  n.sid <- length(margin)
  miss.FUN <- missing(FUN)
  if (length(FUN) == 1 && !is.list(FUN)) {
    fname <- if (!miss.FUN) 
      deparse1(substitute(FUN))
    else "Sum"
    FUN <- setNames(list(FUN), fname)
  }
  if (!miss.FUN) {
    add.names <- function(thelist) {
      n <- names(thelist) %||% rep("", length(thelist))
      for (i in seq_along(thelist)[-1]) {
        if (!is.call(thelist[[i]])) {
          if (n[i] == "") 
            n[i] <- as.character(thelist[[i]])
        }
        else if (as.character(thelist[[i]][[1]]) == "list") 
          thelist[[i]] <- add.names(thelist[[i]])
      }
      names(thelist) <- n
      thelist
    }
    if (mode(substitute(FUN)) == "call") 
      FUN <- eval.parent(add.names(substitute(FUN)))
    if (is.null(names(FUN))) 
      names(FUN) <- rep("", length(FUN))
  }
  if (length(FUN) != n.sid) {
    if (length(FUN) == 1) 
      FUN <- rep(FUN, n.sid)
    else stop(gettextf("length of FUN, %d,\n does not match the length of the margins, %d", length(FUN), n.sid), domain = NA)
  }
  fnames <- vector("list", n.sid)
  for (i in seq_along(FUN)) {
    fnames[[i]] <- names(FUN)[i]
    if (is.list(FUN[[i]])) {
      topname <- fnames[[i]]
      fnames[[i]] <- names(FUN[[i]])
      blank <- fnames[[i]] == ""
      fnames[[i]][blank] <- seq_along(blank)[blank]
      if (topname == "") {
        fnames[[i]][blank] <- paste0("Margin ", margin[i], ".", fnames[[i]][blank])
      }
      else {
        fnames[[i]] <- paste0(topname, ".", fnames[[i]])
      }
    }
    else if (fnames[[i]] == "") 
      fnames[[i]] <- paste("Margin", margin[i])
  }
  expand.one <- function(A, margin, FUN, fnames) {
    if (!inherits(FUN, "list")) 
      FUN <- list(FUN)
    d <- dim(A)
    n.dim <- length(d)
    n.mar <- length(FUN)
    newdim <- d
    newdim[margin] <- newdim[margin] + n.mar
    dnA <- dimnames(A) %||% vector("list", n.dim)
    dnA[[margin]] <- c(if (is.null(dnA[[margin]])) rep("", d[[margin]]) else dnA[[margin]], fnames)
    n.new <- prod(newdim)
    skip <- prod(d[1:margin])
    runl <- skip/d[margin]
    apos <- rep(c(rep_len(TRUE, skip), rep_len(FALSE, n.mar * runl)), n.new/(skip + n.mar * runl))
    values <- double(length(apos))
    values[apos] <- as.vector(A)
    for (i in 1:n.mar) {
      mtab <- if (n.dim > 1) 
        apply(A, (1:n.dim)[-margin], FUN[[i]])
      else FUN[[i]](A)
      select <- rep_len(FALSE, n.mar)
      select[i] <- TRUE
      mpos <- rep(c(rep_len(FALSE, skip), rep(select, each = runl)), prod(dim(A))/skip)
      values[mpos] <- as.vector(mtab)
    }
    array(values, dim = newdim, dimnames = dnA)
  }
  new.A <- A
  for (i in 1:n.sid) new.A <- expand.one(A = new.A, margin = margin[i], FUN = FUN[[i]], fnames = fnames[[i]])
  if (inherits(A, "table")) 
    class(new.A) <- c("table", class(new.A))
  if (!quiet && !miss.FUN && n.sid > 1) {
    cat("Margins computed over dimensions\nin the following order:\n")
    for (i in seq_len(n.sid)) cat(paste(i), ": ", names(dimnames(A))[margin[i]], "\n", sep = "")
  }
  new.A
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
aggregate
list(`package:stats` = function (x, ...) 
  UseMethod("aggregate"), function (x, ...) 
    UseMethod("aggregate"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
aggregate.data.frame
list(`package:stats` = function (x, by, FUN, ..., simplify = TRUE, drop = TRUE) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x)
  FUN <- match.fun(FUN)
  if (inherits(by, "formula")) {
    return(aggregate.formula(x = by, data = x, FUN = FUN, ...))
  }
  if (NROW(x) == 0) 
    stop("no rows to aggregate")
  if (NCOL(x) == 0) {
    x <- data.frame(x = rep(1, NROW(x)))
    return(aggregate.data.frame(x, by, function(x) 0)[seq_along(by)])
  }
  if (!is.list(by)) 
    stop("'by' must be a list")
  if (is.null(names(by)) && length(by)) 
    names(by) <- paste0("Group.", seq_along(by))
  else {
    nam <- names(by)
    ind <- which(!nzchar(nam))
    names(by)[ind] <- paste0("Group.", ind)
  }
  if (any(lengths(by) != NROW(x))) 
    stop("arguments must have same length")
  y <- as.data.frame(by, stringsAsFactors = FALSE)
  keep <- complete.cases(by)
  y <- y[keep, , drop = FALSE]
  x <- x[keep, , drop = FALSE]
  nrx <- NROW(x)
  ident <- function(x) {
    y <- as.factor(x)
    l <- length(levels(y))
    s <- as.character(seq_len(l))
    n <- nchar(s)
    levels(y) <- paste0(strrep("0", n[l] - n), s)
    y
  }
  grp <- lapply(y, ident)
  multi.y <- !drop && ncol(y)
  if (multi.y) {
    lev <- lapply(grp, levels)
    y <- as.list(y)
    for (i in seq_along(y)) {
      z <- y[[i]][match(lev[[i]], grp[[i]])]
      if (is.factor(z) && any(keep <- is.na(z))) 
        z[keep] <- levels(z)[keep]
      y[[i]] <- z
    }
    eGrid <- function(L) expand.grid(L, KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
    y <- eGrid(y)
  }
  grp <- if (ncol(y)) {
    names(grp) <- NULL
    do.call(paste, c(rev(grp), list(sep = ".")))
  }
  else integer(nrx)
  if (multi.y) {
    lev <- as.list(eGrid(lev))
    names(lev) <- NULL
    lev <- do.call(paste, c(rev(lev), list(sep = ".")))
  }
  else y <- y[match(sort(unique(grp)), grp, 0), , drop = FALSE]
  z <- lapply(x, function(e) {
    ans <- lapply(X = unname(split(e, grp)), FUN = FUN, ...)
    if (simplify && length(len <- unique(lengths(ans))) == 1) {
      if (len == 1) {
        cl <- lapply(ans, oldClass)
        cl1 <- cl[[1]]
        ans <- if (!is.null(cl1) && all(vapply(cl, identical, NA, y = cl1))) 
          do.call(c, ans)
        else unlist(ans, recursive = FALSE, use.names = FALSE)
      }
      else if (len > 1) 
        ans <- matrix(unlist(ans, recursive = FALSE, use.names = FALSE), ncol = len, byrow = TRUE, dimnames = if (!is.null(nms <- names(ans[[1]]))) 
          list(NULL, nms))
    }
    ans
  })
  len <- length(y)
  if (multi.y) {
    keep <- match(lev, sort(unique(grp)))
    for (i in seq_along(z)) y[[len + i]] <- if (is.matrix(z[[i]])) 
      z[[i]][keep, , drop = FALSE]
    else z[[i]][keep]
  }
  else for (i in seq_along(z)) y[[len + i]] <- z[[i]]
  names(y) <- c(names(by), names(x))
  row.names(y) <- NULL
  y
}, function (x, by, FUN, ..., simplify = TRUE, drop = TRUE) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x)
  FUN <- match.fun(FUN)
  if (inherits(by, "formula")) {
    return(aggregate.formula(x = by, data = x, FUN = FUN, ...))
  }
  if (NROW(x) == 0) 
    stop("no rows to aggregate")
  if (NCOL(x) == 0) {
    x <- data.frame(x = rep(1, NROW(x)))
    return(aggregate.data.frame(x, by, function(x) 0)[seq_along(by)])
  }
  if (!is.list(by)) 
    stop("'by' must be a list")
  if (is.null(names(by)) && length(by)) 
    names(by) <- paste0("Group.", seq_along(by))
  else {
    nam <- names(by)
    ind <- which(!nzchar(nam))
    names(by)[ind] <- paste0("Group.", ind)
  }
  if (any(lengths(by) != NROW(x))) 
    stop("arguments must have same length")
  y <- as.data.frame(by, stringsAsFactors = FALSE)
  keep <- complete.cases(by)
  y <- y[keep, , drop = FALSE]
  x <- x[keep, , drop = FALSE]
  nrx <- NROW(x)
  ident <- function(x) {
    y <- as.factor(x)
    l <- length(levels(y))
    s <- as.character(seq_len(l))
    n <- nchar(s)
    levels(y) <- paste0(strrep("0", n[l] - n), s)
    y
  }
  grp <- lapply(y, ident)
  multi.y <- !drop && ncol(y)
  if (multi.y) {
    lev <- lapply(grp, levels)
    y <- as.list(y)
    for (i in seq_along(y)) {
      z <- y[[i]][match(lev[[i]], grp[[i]])]
      if (is.factor(z) && any(keep <- is.na(z))) 
        z[keep] <- levels(z)[keep]
      y[[i]] <- z
    }
    eGrid <- function(L) expand.grid(L, KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
    y <- eGrid(y)
  }
  grp <- if (ncol(y)) {
    names(grp) <- NULL
    do.call(paste, c(rev(grp), list(sep = ".")))
  }
  else integer(nrx)
  if (multi.y) {
    lev <- as.list(eGrid(lev))
    names(lev) <- NULL
    lev <- do.call(paste, c(rev(lev), list(sep = ".")))
  }
  else y <- y[match(sort(unique(grp)), grp, 0), , drop = FALSE]
  z <- lapply(x, function(e) {
    ans <- lapply(X = unname(split(e, grp)), FUN = FUN, ...)
    if (simplify && length(len <- unique(lengths(ans))) == 1) {
      if (len == 1) {
        cl <- lapply(ans, oldClass)
        cl1 <- cl[[1]]
        ans <- if (!is.null(cl1) && all(vapply(cl, identical, NA, y = cl1))) 
          do.call(c, ans)
        else unlist(ans, recursive = FALSE, use.names = FALSE)
      }
      else if (len > 1) 
        ans <- matrix(unlist(ans, recursive = FALSE, use.names = FALSE), ncol = len, byrow = TRUE, dimnames = if (!is.null(nms <- names(ans[[1]]))) 
          list(NULL, nms))
    }
    ans
  })
  len <- length(y)
  if (multi.y) {
    keep <- match(lev, sort(unique(grp)))
    for (i in seq_along(z)) y[[len + i]] <- if (is.matrix(z[[i]])) 
      z[[i]][keep, , drop = FALSE]
    else z[[i]][keep]
  }
  else for (i in seq_along(z)) y[[len + i]] <- z[[i]]
  names(y) <- c(names(by), names(x))
  row.names(y) <- NULL
  y
}, function (x, by, FUN, ..., simplify = TRUE, drop = TRUE) 
{
  if (!is.data.frame(x)) 
    x <- as.data.frame(x)
  FUN <- match.fun(FUN)
  if (inherits(by, "formula")) {
    return(aggregate.formula(x = by, data = x, FUN = FUN, ...))
  }
  if (NROW(x) == 0) 
    stop("no rows to aggregate")
  if (NCOL(x) == 0) {
    x <- data.frame(x = rep(1, NROW(x)))
    return(aggregate.data.frame(x, by, function(x) 0)[seq_along(by)])
  }
  if (!is.list(by)) 
    stop("'by' must be a list")
  if (is.null(names(by)) && length(by)) 
    names(by) <- paste0("Group.", seq_along(by))
  else {
    nam <- names(by)
    ind <- which(!nzchar(nam))
    names(by)[ind] <- paste0("Group.", ind)
  }
  if (any(lengths(by) != NROW(x))) 
    stop("arguments must have same length")
  y <- as.data.frame(by, stringsAsFactors = FALSE)
  keep <- complete.cases(by)
  y <- y[keep, , drop = FALSE]
  x <- x[keep, , drop = FALSE]
  nrx <- NROW(x)
  ident <- function(x) {
    y <- as.factor(x)
    l <- length(levels(y))
    s <- as.character(seq_len(l))
    n <- nchar(s)
    levels(y) <- paste0(strrep("0", n[l] - n), s)
    y
  }
  grp <- lapply(y, ident)
  multi.y <- !drop && ncol(y)
  if (multi.y) {
    lev <- lapply(grp, levels)
    y <- as.list(y)
    for (i in seq_along(y)) {
      z <- y[[i]][match(lev[[i]], grp[[i]])]
      if (is.factor(z) && any(keep <- is.na(z))) 
        z[keep] <- levels(z)[keep]
      y[[i]] <- z
    }
    eGrid <- function(L) expand.grid(L, KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
    y <- eGrid(y)
  }
  grp <- if (ncol(y)) {
    names(grp) <- NULL
    do.call(paste, c(rev(grp), list(sep = ".")))
  }
  else integer(nrx)
  if (multi.y) {
    lev <- as.list(eGrid(lev))
    names(lev) <- NULL
    lev <- do.call(paste, c(rev(lev), list(sep = ".")))
  }
  else y <- y[match(sort(unique(grp)), grp, 0), , drop = FALSE]
  z <- lapply(x, function(e) {
    ans <- lapply(X = unname(split(e, grp)), FUN = FUN, ...)
    if (simplify && length(len <- unique(lengths(ans))) == 1) {
      if (len == 1) {
        cl <- lapply(ans, oldClass)
        cl1 <- cl[[1]]
        ans <- if (!is.null(cl1) && all(vapply(cl, identical, NA, y = cl1))) 
          do.call(c, ans)
        else unlist(ans, recursive = FALSE, use.names = FALSE)
      }
      else if (len > 1) 
        ans <- matrix(unlist(ans, recursive = FALSE, use.names = FALSE), ncol = len, byrow = TRUE, dimnames = if (!is.null(nms <- names(ans[[1]]))) 
          list(NULL, nms))
    }
    ans
  })
  len <- length(y)
  if (multi.y) {
    keep <- match(lev, sort(unique(grp)))
    for (i in seq_along(z)) y[[len + i]] <- if (is.matrix(z[[i]])) 
      z[[i]][keep, , drop = FALSE]
    else z[[i]][keep]
  }
  else for (i in seq_along(z)) y[[len + i]] <- z[[i]]
  names(y) <- c(names(by), names(x))
  row.names(y) <- NULL
  y
})
c("package:stats", "registered S3 method for aggregate from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
aggregate.ts
list(`package:stats` = function (x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption("ts.eps"), ...) 
{
  x <- as.ts(x)
  ofrequency <- tsp(x)[3]
  FUN <- match.fun(FUN)
  if (missing(nfrequency)) 
    nfrequency <- 1/ndeltat
  if ((nfrequency > 1) && (abs(nfrequency - round(nfrequency)) < ts.eps)) 
    nfrequency <- round(nfrequency)
  if (nfrequency == ofrequency) 
    return(x)
  ratio <- ofrequency/nfrequency
  if (abs(ratio - round(ratio)) > ts.eps) 
    stop(gettextf("cannot change frequency from %g to %g", ofrequency, nfrequency), domain = NA)
  len <- trunc((ofrequency/nfrequency) + ts.eps)
  mat <- is.matrix(x)
  if (mat) 
    cn <- colnames(x)
  nstart <- tsp(x)[1]
  x <- as.matrix(x)
  nend <- floor(nrow(x)/len) * len
  x <- apply(array(c(x[1:nend, ]), dim = c(len, nend/len, ncol(x))), MARGIN = c(2, 3), FUN = FUN, ...)
  if (!mat) 
    x <- as.vector(x)
  else colnames(x) <- cn
  ts(x, start = nstart, frequency = nfrequency)
}, function (x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption("ts.eps"), ...) 
{
  x <- as.ts(x)
  ofrequency <- tsp(x)[3]
  FUN <- match.fun(FUN)
  if (missing(nfrequency)) 
    nfrequency <- 1/ndeltat
  if ((nfrequency > 1) && (abs(nfrequency - round(nfrequency)) < ts.eps)) 
    nfrequency <- round(nfrequency)
  if (nfrequency == ofrequency) 
    return(x)
  ratio <- ofrequency/nfrequency
  if (abs(ratio - round(ratio)) > ts.eps) 
    stop(gettextf("cannot change frequency from %g to %g", ofrequency, nfrequency), domain = NA)
  len <- trunc((ofrequency/nfrequency) + ts.eps)
  mat <- is.matrix(x)
  if (mat) 
    cn <- colnames(x)
  nstart <- tsp(x)[1]
  x <- as.matrix(x)
  nend <- floor(nrow(x)/len) * len
  x <- apply(array(c(x[1:nend, ]), dim = c(len, nend/len, ncol(x))), MARGIN = c(2, 3), FUN = FUN, ...)
  if (!mat) 
    x <- as.vector(x)
  else colnames(x) <- cn
  ts(x, start = nstart, frequency = nfrequency)
}, function (x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption("ts.eps"), ...) 
{
  x <- as.ts(x)
  ofrequency <- tsp(x)[3]
  FUN <- match.fun(FUN)
  if (missing(nfrequency)) 
    nfrequency <- 1/ndeltat
  if ((nfrequency > 1) && (abs(nfrequency - round(nfrequency)) < ts.eps)) 
    nfrequency <- round(nfrequency)
  if (nfrequency == ofrequency) 
    return(x)
  ratio <- ofrequency/nfrequency
  if (abs(ratio - round(ratio)) > ts.eps) 
    stop(gettextf("cannot change frequency from %g to %g", ofrequency, nfrequency), domain = NA)
  len <- trunc((ofrequency/nfrequency) + ts.eps)
  mat <- is.matrix(x)
  if (mat) 
    cn <- colnames(x)
  nstart <- tsp(x)[1]
  x <- as.matrix(x)
  nend <- floor(nrow(x)/len) * len
  x <- apply(array(c(x[1:nend, ]), dim = c(len, nend/len, ncol(x))), MARGIN = c(2, 3), FUN = FUN, ...)
  if (!mat) 
    x <- as.vector(x)
  else colnames(x) <- cn
  ts(x, start = nstart, frequency = nfrequency)
})
c("package:stats", "registered S3 method for aggregate from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
AIC
list(`package:stats` = function (object, ..., k = 2) 
  UseMethod("AIC"), function (object, ..., k = 2) 
    UseMethod("AIC"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
alias
list(`package:stats` = function (object, ...) 
  UseMethod("alias"), function (object, ...) 
    UseMethod("alias"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
anova
list(`package:stats` = function (object, ...) 
  UseMethod("anova"), function (object, ...) 
    UseMethod("anova"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ansari.test
list(`package:stats` = function (x, ...) 
  UseMethod("ansari.test"), function (x, ...) 
    UseMethod("ansari.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
aov
list(`package:stats` = function (formula, data = NULL, projections = FALSE, qr = TRUE, contrasts = NULL, ...) 
{
  Terms <- if (missing(data)) 
    terms(formula, "Error")
  else terms(formula, "Error", data = data)
  indError <- attr(Terms, "specials")$Error
  if (length(indError) > 1) 
    stop(sprintf(ngettext(length(indError), "there are %d Error terms: only 1 is allowed", "there are %d Error terms: only 1 is allowed"), length(indError)), domain = NA)
  lmcall <- Call <- match.call()
  lmcall[[1]] <- quote(stats::lm)
  lmcall$singular.ok <- TRUE
  if (projections) 
    qr <- lmcall$qr <- TRUE
  lmcall$projections <- NULL
  if (is.null(indError)) {
    fit <- eval(lmcall, parent.frame())
    fit$call <- Call
    structure(fit, class = c(if (inherits(fit, "mlm")) "maov", "aov", oldClass(fit)), projections = if (projections) 
      proj(fit))
  }
  else {
    if (pmatch("weights", names(Call), 0)) 
      stop("weights are not supported in a multistratum aov() fit")
    deparseb <- function(expr) deparse1(expr, backtick = TRUE)
    opcons <- options("contrasts")
    options(contrasts = c("contr.helmert", "contr.poly"))
    on.exit(options(opcons))
    allTerms <- Terms
    errorterm <- attr(Terms, "variables")[[1 + indError]]
    intercept <- attr(Terms, "intercept")
    ecall <- lmcall
    ecall$formula <- as.formula(paste(deparseb(formula[[2]]), "~", deparseb(errorterm[[2]]), if (!intercept) 
      "- 1"), env = environment(formula))
    ecall$method <- "qr"
    ecall$qr <- TRUE
    ecall$contrasts <- NULL
    er.fit <- eval(ecall, parent.frame())
    options(opcons)
    nmstrata <- attr(terms(er.fit), "term.labels")
    nmstrata <- sub("^`(.*)`$", "\\1", nmstrata)
    nmstrata <- c("(Intercept)", nmstrata)
    qr.e <- er.fit$qr
    rank.e <- er.fit$rank
    if (rank.e < NROW(er.fit$coefficients)) 
      warning("Error() model is singular")
    qty <- er.fit$residuals
    maov <- is.matrix(qty)
    asgn.e <- er.fit$assign[qr.e$pivot[1:rank.e]]
    maxasgn <- length(nmstrata) - 1
    nobs <- NROW(qty)
    len <- if (nobs > rank.e) {
      asgn.e[(rank.e + 1):nobs] <- maxasgn + 1
      nmstrata <- c(nmstrata, "Within")
      maxasgn + 2
    }
    else maxasgn + 1
    result <- setNames(vector("list", len), nmstrata)
    lmcall$formula <- form <- update(formula, paste(". ~ .-", deparseb(errorterm)))
    Terms <- terms(form)
    lmcall$method <- "model.frame"
    mf <- eval(lmcall, parent.frame())
    xlev <- .getXlevels(Terms, mf)
    resp <- model.response(mf)
    qtx <- model.matrix(Terms, mf, contrasts)
    cons <- attr(qtx, "contrasts")
    dnx <- colnames(qtx)
    asgn.t <- attr(qtx, "assign")
    if (length(wts <- model.weights(mf))) {
      wts <- sqrt(wts)
      resp <- resp * wts
      qtx <- qtx * wts
    }
    qty <- as.matrix(qr.qty(qr.e, resp))
    if ((nc <- ncol(qty)) > 1) {
      dny <- colnames(resp) %||% paste0("Y", 1:nc)
      dimnames(qty) <- list(seq(nrow(qty)), dny)
    }
    else dimnames(qty) <- list(seq(nrow(qty)), NULL)
    qtx <- qr.qty(qr.e, qtx)
    dimnames(qtx) <- list(seq(nrow(qtx)), dnx)
    for (i in seq_along(nmstrata)) {
      select <- asgn.e == (i - 1)
      ni <- sum(select)
      if (!ni) 
        next
      xi <- qtx[select, , drop = FALSE]
      cols <- colSums(xi^2) > 1e-05
      if (any(cols)) {
        xi <- xi[, cols, drop = FALSE]
        attr(xi, "assign") <- asgn.t[cols]
        fiti <- lm.fit(xi, qty[select, , drop = FALSE])
        fiti$terms <- Terms
      }
      else {
        y <- qty[select, , drop = FALSE]
        fiti <- list(coefficients = numeric(), residuals = y, fitted.values = 0 * y, weights = wts, rank = 0, df.residual = NROW(y))
      }
      if (projections) 
        fiti$projections <- proj(fiti)
      class(fiti) <- c(if (maov) "maov", "aov", oldClass(er.fit))
      result[[i]] <- fiti
    }
    structure(class = c("aovlist", "listof"), result[!vapply(result, is.null, NA)], error.qr = if (qr) 
      qr.e, call = Call, weights = if (length(wts)) 
        wts, terms = allTerms, contrasts = cons, xlevels = xlev)
  }
}, function (formula, data = NULL, projections = FALSE, qr = TRUE, contrasts = NULL, ...) 
{
  Terms <- if (missing(data)) 
    terms(formula, "Error")
  else terms(formula, "Error", data = data)
  indError <- attr(Terms, "specials")$Error
  if (length(indError) > 1) 
    stop(sprintf(ngettext(length(indError), "there are %d Error terms: only 1 is allowed", "there are %d Error terms: only 1 is allowed"), length(indError)), domain = NA)
  lmcall <- Call <- match.call()
  lmcall[[1]] <- quote(stats::lm)
  lmcall$singular.ok <- TRUE
  if (projections) 
    qr <- lmcall$qr <- TRUE
  lmcall$projections <- NULL
  if (is.null(indError)) {
    fit <- eval(lmcall, parent.frame())
    fit$call <- Call
    structure(fit, class = c(if (inherits(fit, "mlm")) "maov", "aov", oldClass(fit)), projections = if (projections) 
      proj(fit))
  }
  else {
    if (pmatch("weights", names(Call), 0)) 
      stop("weights are not supported in a multistratum aov() fit")
    deparseb <- function(expr) deparse1(expr, backtick = TRUE)
    opcons <- options("contrasts")
    options(contrasts = c("contr.helmert", "contr.poly"))
    on.exit(options(opcons))
    allTerms <- Terms
    errorterm <- attr(Terms, "variables")[[1 + indError]]
    intercept <- attr(Terms, "intercept")
    ecall <- lmcall
    ecall$formula <- as.formula(paste(deparseb(formula[[2]]), "~", deparseb(errorterm[[2]]), if (!intercept) 
      "- 1"), env = environment(formula))
    ecall$method <- "qr"
    ecall$qr <- TRUE
    ecall$contrasts <- NULL
    er.fit <- eval(ecall, parent.frame())
    options(opcons)
    nmstrata <- attr(terms(er.fit), "term.labels")
    nmstrata <- sub("^`(.*)`$", "\\1", nmstrata)
    nmstrata <- c("(Intercept)", nmstrata)
    qr.e <- er.fit$qr
    rank.e <- er.fit$rank
    if (rank.e < NROW(er.fit$coefficients)) 
      warning("Error() model is singular")
    qty <- er.fit$residuals
    maov <- is.matrix(qty)
    asgn.e <- er.fit$assign[qr.e$pivot[1:rank.e]]
    maxasgn <- length(nmstrata) - 1
    nobs <- NROW(qty)
    len <- if (nobs > rank.e) {
      asgn.e[(rank.e + 1):nobs] <- maxasgn + 1
      nmstrata <- c(nmstrata, "Within")
      maxasgn + 2
    }
    else maxasgn + 1
    result <- setNames(vector("list", len), nmstrata)
    lmcall$formula <- form <- update(formula, paste(". ~ .-", deparseb(errorterm)))
    Terms <- terms(form)
    lmcall$method <- "model.frame"
    mf <- eval(lmcall, parent.frame())
    xlev <- .getXlevels(Terms, mf)
    resp <- model.response(mf)
    qtx <- model.matrix(Terms, mf, contrasts)
    cons <- attr(qtx, "contrasts")
    dnx <- colnames(qtx)
    asgn.t <- attr(qtx, "assign")
    if (length(wts <- model.weights(mf))) {
      wts <- sqrt(wts)
      resp <- resp * wts
      qtx <- qtx * wts
    }
    qty <- as.matrix(qr.qty(qr.e, resp))
    if ((nc <- ncol(qty)) > 1) {
      dny <- colnames(resp) %||% paste0("Y", 1:nc)
      dimnames(qty) <- list(seq(nrow(qty)), dny)
    }
    else dimnames(qty) <- list(seq(nrow(qty)), NULL)
    qtx <- qr.qty(qr.e, qtx)
    dimnames(qtx) <- list(seq(nrow(qtx)), dnx)
    for (i in seq_along(nmstrata)) {
      select <- asgn.e == (i - 1)
      ni <- sum(select)
      if (!ni) 
        next
      xi <- qtx[select, , drop = FALSE]
      cols <- colSums(xi^2) > 1e-05
      if (any(cols)) {
        xi <- xi[, cols, drop = FALSE]
        attr(xi, "assign") <- asgn.t[cols]
        fiti <- lm.fit(xi, qty[select, , drop = FALSE])
        fiti$terms <- Terms
      }
      else {
        y <- qty[select, , drop = FALSE]
        fiti <- list(coefficients = numeric(), residuals = y, fitted.values = 0 * y, weights = wts, rank = 0, df.residual = NROW(y))
      }
      if (projections) 
        fiti$projections <- proj(fiti)
      class(fiti) <- c(if (maov) "maov", "aov", oldClass(er.fit))
      result[[i]] <- fiti
    }
    structure(class = c("aovlist", "listof"), result[!vapply(result, is.null, NA)], error.qr = if (qr) 
      qr.e, call = Call, weights = if (length(wts)) 
        wts, terms = allTerms, contrasts = cons, xlevels = xlev)
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
approx
list(`package:stats` = function (x, y = NULL, xout, method = "linear", n = 50, yleft, yright, rule = 1, f = 0, ties = mean, na.rm = TRUE) 
{
  method <- pmatch(method, c("linear", "constant"))
  if (is.na(method)) 
    stop("invalid interpolation method")
  stopifnot(is.numeric(rule), (lenR <- length(rule)) >= 1, lenR <= 2)
  if (lenR == 1) 
    rule <- rule[c(1, 1)]
  r <- regularize.values(x, y, ties, missing(ties), na.rm = na.rm)
  y <- r$y
  x <- r$x
  noNA <- na.rm || !r$keptNA
  nx <- if (noNA) 
    length(x)
  else sum(r$notNA)
  if (is.na(nx)) 
    stop("invalid length(x)")
  if (nx <= 1) {
    if (method == 1) 
      stop("need at least two non-NA values to interpolate")
    if (nx == 0) 
      stop("zero non-NA points")
  }
  if (missing(yleft)) 
    yleft <- if (rule[1] == 1) 
      NA
  else y[1]
  if (missing(yright)) 
    yright <- if (rule[2] == 1) 
      NA
  else y[length(y)]
  stopifnot(length(yleft) == 1, length(yright) == 1, length(f) == 1)
  if (missing(xout)) {
    if (n <= 0) 
      stop("'approx' requires n >= 1")
    xout <- if (noNA) 
      seq.int(x[1], x[nx], length.out = n)
    else {
      xout <- x[r$notNA]
      seq.int(xout[1], xout[length(xout)], length.out = n)
    }
  }
  x <- as.double(x)
  y <- as.double(y)
  .Call(C_ApproxTest, x, y, method, f, na.rm)
  yout <- .Call(C_Approx, x, y, xout, method, yleft, yright, f, na.rm)
  list(x = xout, y = yout)
}, function (x, y = NULL, xout, method = "linear", n = 50, yleft, yright, rule = 1, f = 0, ties = mean, na.rm = TRUE) 
{
  method <- pmatch(method, c("linear", "constant"))
  if (is.na(method)) 
    stop("invalid interpolation method")
  stopifnot(is.numeric(rule), (lenR <- length(rule)) >= 1, lenR <= 2)
  if (lenR == 1) 
    rule <- rule[c(1, 1)]
  r <- regularize.values(x, y, ties, missing(ties), na.rm = na.rm)
  y <- r$y
  x <- r$x
  noNA <- na.rm || !r$keptNA
  nx <- if (noNA) 
    length(x)
  else sum(r$notNA)
  if (is.na(nx)) 
    stop("invalid length(x)")
  if (nx <= 1) {
    if (method == 1) 
      stop("need at least two non-NA values to interpolate")
    if (nx == 0) 
      stop("zero non-NA points")
  }
  if (missing(yleft)) 
    yleft <- if (rule[1] == 1) 
      NA
  else y[1]
  if (missing(yright)) 
    yright <- if (rule[2] == 1) 
      NA
  else y[length(y)]
  stopifnot(length(yleft) == 1, length(yright) == 1, length(f) == 1)
  if (missing(xout)) {
    if (n <= 0) 
      stop("'approx' requires n >= 1")
    xout <- if (noNA) 
      seq.int(x[1], x[nx], length.out = n)
    else {
      xout <- x[r$notNA]
      seq.int(xout[1], xout[length(xout)], length.out = n)
    }
  }
  x <- as.double(x)
  y <- as.double(y)
  .Call(C_ApproxTest, x, y, method, f, na.rm)
  yout <- .Call(C_Approx, x, y, xout, method, yleft, yright, f, na.rm)
  list(x = xout, y = yout)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
approxfun
list(`package:stats` = function (x, y = NULL, method = "linear", yleft, yright, rule = 1, f = 0, ties = mean, na.rm = TRUE) 
{
  method <- pmatch(method, c("linear", "constant"))
  if (is.na(method)) 
    stop("invalid interpolation method")
  stopifnot(is.numeric(rule), (lenR <- length(rule)) >= 1, lenR <= 2)
  if (lenR == 1) 
    rule <- rule[c(1, 1)]
  x <- regularize.values(x, y, ties, missing(ties), na.rm = na.rm)
  nx <- if (na.rm || !x$keptNA) 
    length(x$x)
  else sum(x$notNA)
  if (is.na(nx)) 
    stop("invalid length(x)")
  if (nx <= 1) {
    if (method == 1) 
      stop("need at least two non-NA values to interpolate")
    if (nx == 0) 
      stop("zero non-NA points")
  }
  y <- x$y
  if (missing(yleft)) 
    yleft <- if (rule[1] == 1) 
      NA
  else y[1]
  if (missing(yright)) 
    yright <- if (rule[2] == 1) 
      NA
  else y[length(y)]
  stopifnot(length(yleft) == 1, length(yright) == 1, length(f) == 1)
  rm(rule, ties, lenR, nx)
  x <- as.double(x$x)
  y <- as.double(y)
  .Call(C_ApproxTest, x, y, method, f, na.rm)
  function(v) .approxfun(x, y, v, method, yleft, yright, f, na.rm)
}, function (x, y = NULL, method = "linear", yleft, yright, rule = 1, f = 0, ties = mean, na.rm = TRUE) 
{
  method <- pmatch(method, c("linear", "constant"))
  if (is.na(method)) 
    stop("invalid interpolation method")
  stopifnot(is.numeric(rule), (lenR <- length(rule)) >= 1, lenR <= 2)
  if (lenR == 1) 
    rule <- rule[c(1, 1)]
  x <- regularize.values(x, y, ties, missing(ties), na.rm = na.rm)
  nx <- if (na.rm || !x$keptNA) 
    length(x$x)
  else sum(x$notNA)
  if (is.na(nx)) 
    stop("invalid length(x)")
  if (nx <= 1) {
    if (method == 1) 
      stop("need at least two non-NA values to interpolate")
    if (nx == 0) 
      stop("zero non-NA points")
  }
  y <- x$y
  if (missing(yleft)) 
    yleft <- if (rule[1] == 1) 
      NA
  else y[1]
  if (missing(yright)) 
    yright <- if (rule[2] == 1) 
      NA
  else y[length(y)]
  stopifnot(length(yleft) == 1, length(yright) == 1, length(f) == 1)
  rm(rule, ties, lenR, nx)
  x <- as.double(x$x)
  y <- as.double(y)
  .Call(C_ApproxTest, x, y, method, f, na.rm)
  function(v) .approxfun(x, y, v, method, yleft, yright, f, na.rm)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ar
list(`package:stats` = function (x, aic = TRUE, order.max = NULL, method = c("yule-walker", "burg", "ols", "mle", "yw"), na.action = na.fail, series = deparse1(substitute(x)), ...) 
{
  res <- switch(match.arg(method), yw = , `yule-walker` = ar.yw(x, aic = aic, order.max = order.max, na.action = na.action, series = series, ...), burg = ar.burg(x, aic = aic, order.max = order.max, na.action = na.action, series = series, ...), ols = ar.ols(x, aic = aic, order.max = order.max, na.action = na.action, series = series, ...), mle = ar.mle(x, aic = aic, order.max = order.max, na.action = na.action, series = series, ...))
  res$call <- match.call()
  res
}, function (x, aic = TRUE, order.max = NULL, method = c("yule-walker", "burg", "ols", "mle", "yw"), na.action = na.fail, series = deparse1(substitute(x)), ...) 
{
  res <- switch(match.arg(method), yw = , `yule-walker` = ar.yw(x, aic = aic, order.max = order.max, na.action = na.action, series = series, ...), burg = ar.burg(x, aic = aic, order.max = order.max, na.action = na.action, series = series, ...), ols = ar.ols(x, aic = aic, order.max = order.max, na.action = na.action, series = series, ...), mle = ar.mle(x, aic = aic, order.max = order.max, na.action = na.action, series = series, ...))
  res$call <- match.call()
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ar.burg
list(`package:stats` = function (x, ...) 
  UseMethod("ar.burg"), function (x, ...) 
    UseMethod("ar.burg"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ar.mle
list(`package:stats` = function (x, aic = TRUE, order.max = NULL, na.action = na.fail, demean = TRUE, series = NULL, ...) 
{
  if (is.null(series)) 
    series <- deparse1(substitute(x))
  ists <- is.ts(x)
  if (!is.null(dim(x))) 
    stop("MLE only implemented for univariate series")
  x <- na.action(as.ts(x))
  if (anyNA(x)) 
    stop("NAs in 'x'")
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (ists) 
    xtsp <- tsp(x)
  xfreq <- frequency(x)
  x <- as.vector(x)
  n.used <- length(x)
  order.max <- if (is.null(order.max)) 
    min(n.used - 1, 12, floor(10 * log10(n.used)))
  else round(order.max)
  if (order.max < 0) 
    stop("'order.max' must be >= 0")
  else if (order.max >= n.used) 
    stop("'order.max' must be < 'n.used'")
  if (aic) {
    coefs <- matrix(NA, order.max + 1, order.max + 1)
    var.pred <- numeric(order.max + 1)
    xaic <- numeric(order.max + 1)
    xm <- if (demean) 
      mean(x)
    else 0
    coefs[1, 1] <- xm
    var0 <- sum((x - xm)^2)/n.used
    var.pred[1] <- var0
    xaic[1] <- n.used * log(var0) + 2 * demean + 2 + n.used + n.used * log(2 * pi)
    for (i in seq_len(order.max)) {
      fit <- arima0(x, order = c(i, 0, 0), include.mean = demean)
      coefs[i + 1, seq_len(i + demean)] <- fit$coef[seq_len(i + demean)]
      xaic[i + 1] <- fit$aic
      var.pred[i + 1] <- fit$sigma2
    }
    xaic <- setNames(xaic - min(xaic), 0:order.max)
    order <- (0:order.max)[xaic == 0]
    ar <- coefs[order + 1, seq_len(order)]
    x.mean <- coefs[order + 1, order + 1]
    var.pred <- var.pred[order + 1]
  }
  else {
    order <- order.max
    fit <- arima0(x, order = c(order, 0, 0), include.mean = demean)
    coefs <- fit$coef
    if (demean) {
      ar <- coefs[-length(coefs)]
      x.mean <- coefs[length(coefs)]
    }
    else {
      ar <- coefs
      x.mean <- 0
    }
    var.pred <- fit$sigma2
    xaic <- structure(0, names = order)
  }
  resid <- if (order) 
    c(rep(NA, order), embed(x - x.mean, order + 1) %*% c(1, -ar))
  else x - x.mean
  if (ists) {
    attr(resid, "tsp") <- xtsp
    attr(resid, "class") <- "ts"
  }
  res <- list(order = order, ar = ar, var.pred = var.pred, x.mean = x.mean, aic = xaic, n.used = n.used, n.obs = n.used, order.max = order.max, partialacf = NULL, resid = resid, method = "MLE", series = series, frequency = xfreq, call = match.call())
  if (order) {
    xacf <- acf(x, type = "covariance", lag.max = order, plot = FALSE)$acf
    res$asy.var.coef <- var.pred/n.used * solve(toeplitz(drop(xacf)[seq_len(order)]))
  }
  class(res) <- "ar"
  res
}, function (x, aic = TRUE, order.max = NULL, na.action = na.fail, demean = TRUE, series = NULL, ...) 
{
  if (is.null(series)) 
    series <- deparse1(substitute(x))
  ists <- is.ts(x)
  if (!is.null(dim(x))) 
    stop("MLE only implemented for univariate series")
  x <- na.action(as.ts(x))
  if (anyNA(x)) 
    stop("NAs in 'x'")
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  if (ists) 
    xtsp <- tsp(x)
  xfreq <- frequency(x)
  x <- as.vector(x)
  n.used <- length(x)
  order.max <- if (is.null(order.max)) 
    min(n.used - 1, 12, floor(10 * log10(n.used)))
  else round(order.max)
  if (order.max < 0) 
    stop("'order.max' must be >= 0")
  else if (order.max >= n.used) 
    stop("'order.max' must be < 'n.used'")
  if (aic) {
    coefs <- matrix(NA, order.max + 1, order.max + 1)
    var.pred <- numeric(order.max + 1)
    xaic <- numeric(order.max + 1)
    xm <- if (demean) 
      mean(x)
    else 0
    coefs[1, 1] <- xm
    var0 <- sum((x - xm)^2)/n.used
    var.pred[1] <- var0
    xaic[1] <- n.used * log(var0) + 2 * demean + 2 + n.used + n.used * log(2 * pi)
    for (i in seq_len(order.max)) {
      fit <- arima0(x, order = c(i, 0, 0), include.mean = demean)
      coefs[i + 1, seq_len(i + demean)] <- fit$coef[seq_len(i + demean)]
      xaic[i + 1] <- fit$aic
      var.pred[i + 1] <- fit$sigma2
    }
    xaic <- setNames(xaic - min(xaic), 0:order.max)
    order <- (0:order.max)[xaic == 0]
    ar <- coefs[order + 1, seq_len(order)]
    x.mean <- coefs[order + 1, order + 1]
    var.pred <- var.pred[order + 1]
  }
  else {
    order <- order.max
    fit <- arima0(x, order = c(order, 0, 0), include.mean = demean)
    coefs <- fit$coef
    if (demean) {
      ar <- coefs[-length(coefs)]
      x.mean <- coefs[length(coefs)]
    }
    else {
      ar <- coefs
      x.mean <- 0
    }
    var.pred <- fit$sigma2
    xaic <- structure(0, names = order)
  }
  resid <- if (order) 
    c(rep(NA, order), embed(x - x.mean, order + 1) %*% c(1, -ar))
  else x - x.mean
  if (ists) {
    attr(resid, "tsp") <- xtsp
    attr(resid, "class") <- "ts"
  }
  res <- list(order = order, ar = ar, var.pred = var.pred, x.mean = x.mean, aic = xaic, n.used = n.used, n.obs = n.used, order.max = order.max, partialacf = NULL, resid = resid, method = "MLE", series = series, frequency = xfreq, call = match.call())
  if (order) {
    xacf <- acf(x, type = "covariance", lag.max = order, plot = FALSE)$acf
    res$asy.var.coef <- var.pred/n.used * solve(toeplitz(drop(xacf)[seq_len(order)]))
  }
  class(res) <- "ar"
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ar.ols
list(`package:stats` = function (x, aic = TRUE, order.max = NULL, na.action = na.fail, demean = TRUE, intercept = demean, series = NULL, ...) 
{
  if (is.null(series)) 
    series <- deparse1(substitute(x))
  rescale <- TRUE
  ists <- is.ts(x)
  x <- na.action(as.ts(x))
  if (anyNA(x)) 
    stop("NAs in 'x'")
  if (ists) 
    xtsp <- tsp(x)
  xfreq <- frequency(x)
  x <- as.matrix(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  n.used <- nrow(x)
  nser <- ncol(x)
  iser <- seq_len(nser)
  if (rescale) {
    sc <- sqrt(drop(apply(x, 2, var)))
    sc[sc == 0] <- 1
    x <- x/rep.int(sc, rep.int(n.used, nser))
  }
  else sc <- rep.int(1, nser)
  order.max <- if (is.null(order.max)) 
    min(n.used - 1, floor(10 * log10(n.used)))
  else round(order.max)
  if (order.max < 0) 
    stop("'order.max' must be >= 0")
  if (order.max >= n.used) 
    stop("'order.max' must be < 'n.used'")
  order.min <- if (aic) 
    0
  else order.max
  varE <- seA <- A <- vector("list", order.max - order.min + 1)
  xaic <- rep.int(Inf, order.max - order.min + 1)
  det <- function(x) max(0, prod(diag(qr(x)$qr)) * (-1)^(ncol(x) - 1))
  if (demean) {
    xm <- colMeans(x)
    x <- sweep(x, 2, xm, check.margin = FALSE)
  }
  else xm <- rep.int(0, nser)
  for (m in order.min:order.max) {
    y <- embed(x, m + 1)
    X <- if (intercept) {
      if (m) 
        cbind(rep.int(1, nrow(y)), y[, (nser + 1):ncol(y)])
      else as.matrix(rep.int(1, nrow(y)))
    }
    else {
      if (m) 
        y[, (nser + 1):ncol(y)]
      else matrix(0, nrow(y), 0)
    }
    Y <- t(y[, iser])
    N <- ncol(Y)
    XX <- t(X) %*% X
    rank <- qr(XX)$rank
    if (rank != nrow(XX)) {
      warning(paste("model order: ", m, "singularities in the computation of the projection matrix", "results are only valid up to model order", m - 1), domain = NA)
      break
    }
    P <- if (ncol(XX) > 0) 
      solve(XX)
    else XX
    A[[m - order.min + 1]] <- Y %*% X %*% P
    YH <- A[[m - order.min + 1]] %*% t(X)
    E <- (Y - YH)
    varE[[m - order.min + 1]] <- tcrossprod(E)/N
    varA <- P %x% (varE[[m - order.min + 1]])
    seA[[m - order.min + 1]] <- if (ncol(varA) > 0) 
      sqrt(diag(varA))
    else numeric()
    xaic[m - order.min + 1] <- n.used * log(det(varE[[m - order.min + 1]])) + 2 * nser * (nser * m + intercept)
  }
  m <- if (aic) 
    which.max(xaic == min(xaic)) + order.min - 1
  else order.max
  y <- embed(x, m + 1)
  AA <- A[[m - order.min + 1]]
  if (intercept) {
    xint <- AA[, 1]
    ar <- AA[, -1]
    X <- if (m) 
      cbind(rep.int(1, nrow(y)), y[, (nser + 1):ncol(y)])
    else as.matrix(rep.int(1, nrow(y)))
  }
  else {
    X <- if (m) 
      y[, (nser + 1):ncol(y)]
    else matrix(0, nrow(y), 0)
    xint <- NULL
    ar <- AA
  }
  Y <- t(y[, iser, drop = FALSE])
  YH <- AA %*% t(X)
  E <- drop(rbind(matrix(NA, m, nser), t(Y - YH)))
  maic <- min(aic)
  xaic <- setNames(if (is.finite(maic)) 
    xaic - min(xaic)
    else ifelse(xaic == maic, 0, Inf), order.min:order.max)
  dim(ar) <- c(nser, nser, m)
  ar <- aperm(ar, c(3, 1, 2))
  ses <- seA[[m - order.min + 1]]
  if (intercept) {
    sem <- ses[iser]
    ses <- ses[-iser]
  }
  else sem <- rep.int(0, nser)
  dim(ses) <- c(nser, nser, m)
  ses <- aperm(ses, c(3, 1, 2))
  var.pred <- varE[[m - order.min + 1]]
  if (nser > 1) {
    snames <- colnames(x)
    dimnames(ses) <- dimnames(ar) <- list(seq_len(m), snames, snames)
    dimnames(var.pred) <- list(snames, snames)
    names(sem) <- colnames(E) <- snames
  }
  else {
    var.pred <- drop(var.pred)
  }
  if (ists) {
    attr(E, "tsp") <- xtsp
    attr(E, "class") <- "ts"
  }
  if (rescale) {
    xm <- xm * sc
    if (!is.null(xint)) 
      xint <- xint * sc
    aa <- outer(sc, 1/sc)
    if (nser > 1 && m) 
      for (i in seq_len(m)) ar[i, , ] <- ar[i, , ] * aa
    var.pred <- var.pred * drop(outer(sc, sc))
    E <- E * rep.int(sc, rep.int(NROW(E), nser))
    sem <- sem * sc
    if (m) 
      for (i in seq_len(m)) ses[i, , ] <- ses[i, , ] * aa
  }
  res <- list(order = m, ar = ar, var.pred = var.pred, x.mean = xm, x.intercept = xint, aic = xaic, n.used = n.used, n.obs = n.used, order.max = order.max, partialacf = NULL, resid = E, method = "Unconstrained LS", series = series, frequency = xfreq, call = match.call(), asy.se.coef = list(x.mean = sem, ar = drop(ses)))
  class(res) <- "ar"
  res
}, function (x, aic = TRUE, order.max = NULL, na.action = na.fail, demean = TRUE, intercept = demean, series = NULL, ...) 
{
  if (is.null(series)) 
    series <- deparse1(substitute(x))
  rescale <- TRUE
  ists <- is.ts(x)
  x <- na.action(as.ts(x))
  if (anyNA(x)) 
    stop("NAs in 'x'")
  if (ists) 
    xtsp <- tsp(x)
  xfreq <- frequency(x)
  x <- as.matrix(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  n.used <- nrow(x)
  nser <- ncol(x)
  iser <- seq_len(nser)
  if (rescale) {
    sc <- sqrt(drop(apply(x, 2, var)))
    sc[sc == 0] <- 1
    x <- x/rep.int(sc, rep.int(n.used, nser))
  }
  else sc <- rep.int(1, nser)
  order.max <- if (is.null(order.max)) 
    min(n.used - 1, floor(10 * log10(n.used)))
  else round(order.max)
  if (order.max < 0) 
    stop("'order.max' must be >= 0")
  if (order.max >= n.used) 
    stop("'order.max' must be < 'n.used'")
  order.min <- if (aic) 
    0
  else order.max
  varE <- seA <- A <- vector("list", order.max - order.min + 1)
  xaic <- rep.int(Inf, order.max - order.min + 1)
  det <- function(x) max(0, prod(diag(qr(x)$qr)) * (-1)^(ncol(x) - 1))
  if (demean) {
    xm <- colMeans(x)
    x <- sweep(x, 2, xm, check.margin = FALSE)
  }
  else xm <- rep.int(0, nser)
  for (m in order.min:order.max) {
    y <- embed(x, m + 1)
    X <- if (intercept) {
      if (m) 
        cbind(rep.int(1, nrow(y)), y[, (nser + 1):ncol(y)])
      else as.matrix(rep.int(1, nrow(y)))
    }
    else {
      if (m) 
        y[, (nser + 1):ncol(y)]
      else matrix(0, nrow(y), 0)
    }
    Y <- t(y[, iser])
    N <- ncol(Y)
    XX <- t(X) %*% X
    rank <- qr(XX)$rank
    if (rank != nrow(XX)) {
      warning(paste("model order: ", m, "singularities in the computation of the projection matrix", "results are only valid up to model order", m - 1), domain = NA)
      break
    }
    P <- if (ncol(XX) > 0) 
      solve(XX)
    else XX
    A[[m - order.min + 1]] <- Y %*% X %*% P
    YH <- A[[m - order.min + 1]] %*% t(X)
    E <- (Y - YH)
    varE[[m - order.min + 1]] <- tcrossprod(E)/N
    varA <- P %x% (varE[[m - order.min + 1]])
    seA[[m - order.min + 1]] <- if (ncol(varA) > 0) 
      sqrt(diag(varA))
    else numeric()
    xaic[m - order.min + 1] <- n.used * log(det(varE[[m - order.min + 1]])) + 2 * nser * (nser * m + intercept)
  }
  m <- if (aic) 
    which.max(xaic == min(xaic)) + order.min - 1
  else order.max
  y <- embed(x, m + 1)
  AA <- A[[m - order.min + 1]]
  if (intercept) {
    xint <- AA[, 1]
    ar <- AA[, -1]
    X <- if (m) 
      cbind(rep.int(1, nrow(y)), y[, (nser + 1):ncol(y)])
    else as.matrix(rep.int(1, nrow(y)))
  }
  else {
    X <- if (m) 
      y[, (nser + 1):ncol(y)]
    else matrix(0, nrow(y), 0)
    xint <- NULL
    ar <- AA
  }
  Y <- t(y[, iser, drop = FALSE])
  YH <- AA %*% t(X)
  E <- drop(rbind(matrix(NA, m, nser), t(Y - YH)))
  maic <- min(aic)
  xaic <- setNames(if (is.finite(maic)) 
    xaic - min(xaic)
    else ifelse(xaic == maic, 0, Inf), order.min:order.max)
  dim(ar) <- c(nser, nser, m)
  ar <- aperm(ar, c(3, 1, 2))
  ses <- seA[[m - order.min + 1]]
  if (intercept) {
    sem <- ses[iser]
    ses <- ses[-iser]
  }
  else sem <- rep.int(0, nser)
  dim(ses) <- c(nser, nser, m)
  ses <- aperm(ses, c(3, 1, 2))
  var.pred <- varE[[m - order.min + 1]]
  if (nser > 1) {
    snames <- colnames(x)
    dimnames(ses) <- dimnames(ar) <- list(seq_len(m), snames, snames)
    dimnames(var.pred) <- list(snames, snames)
    names(sem) <- colnames(E) <- snames
  }
  else {
    var.pred <- drop(var.pred)
  }
  if (ists) {
    attr(E, "tsp") <- xtsp
    attr(E, "class") <- "ts"
  }
  if (rescale) {
    xm <- xm * sc
    if (!is.null(xint)) 
      xint <- xint * sc
    aa <- outer(sc, 1/sc)
    if (nser > 1 && m) 
      for (i in seq_len(m)) ar[i, , ] <- ar[i, , ] * aa
    var.pred <- var.pred * drop(outer(sc, sc))
    E <- E * rep.int(sc, rep.int(NROW(E), nser))
    sem <- sem * sc
    if (m) 
      for (i in seq_len(m)) ses[i, , ] <- ses[i, , ] * aa
  }
  res <- list(order = m, ar = ar, var.pred = var.pred, x.mean = xm, x.intercept = xint, aic = xaic, n.used = n.used, n.obs = n.used, order.max = order.max, partialacf = NULL, resid = E, method = "Unconstrained LS", series = series, frequency = xfreq, call = match.call(), asy.se.coef = list(x.mean = sem, ar = drop(ses)))
  class(res) <- "ar"
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ar.yw
list(`package:stats` = function (x, ...) 
  UseMethod("ar.yw"), function (x, ...) 
    UseMethod("ar.yw"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
arima
list(`package:stats` = function (x, order = c(0, 0, 0), seasonal = list(order = c(0, 0, 0), period = NA), xreg = NULL, include.mean = TRUE, transform.pars = TRUE, fixed = NULL, init = NULL, method = c("CSS-ML", "ML", "CSS"), n.cond, SSinit = c("Gardner1980", "Rossignol2011"), optim.method = "BFGS", optim.control = list(), kappa = 1e+06) 
{
  "%+%" <- function(a, b) .Call(C_TSconv, a, b)
  SSinit <- match.arg(SSinit)
  SS.G <- SSinit == "Gardner1980"
  upARIMA <- function(mod, phi, theta) {
    p <- length(phi)
    q <- length(theta)
    mod$phi <- phi
    mod$theta <- theta
    r <- max(p, q + 1)
    if (p > 0) 
      mod$T[1:p, 1] <- phi
    if (r > 1) 
      mod$Pn[1:r, 1:r] <- if (SS.G) 
        .Call(C_getQ0, phi, theta)
    else .Call(C_getQ0bis, phi, theta, tol = 0)
    else mod$Pn[1, 1] <- if (p > 0) 
      1/(1 - phi^2)
    else 1
    mod$a[] <- 0
    mod
  }
  arimaSS <- function(y, mod) {
    .Call(C_ARIMA_Like, y, mod, 0, TRUE)
  }
  armafn <- function(p, trans) {
    par <- coef
    par[mask] <- p
    trarma <- .Call(C_ARIMA_transPars, par, arma, trans)
    if (is.null(Z <- tryCatch(upARIMA(mod, trarma[[1]], trarma[[2]]), error = function(e) NULL))) 
      return(.Machine$double.xmax)
    if (ncxreg > 0) 
      x <- x - xreg %*% par[narma + (1:ncxreg)]
    res <- .Call(C_ARIMA_Like, x, Z, 0, FALSE)
    s2 <- res[1]/res[3]
    0.5 * (log(s2) + res[2]/res[3])
  }
  armaCSS <- function(p) {
    par <- as.double(fixed)
    par[mask] <- p
    trarma <- .Call(C_ARIMA_transPars, par, arma, FALSE)
    if (ncxreg > 0) 
      x <- x - xreg %*% par[narma + (1:ncxreg)]
    res <- .Call(C_ARIMA_CSS, x, arma, trarma[[1]], trarma[[2]], as.integer(ncond), FALSE)
    0.5 * log(res)
  }
  arCheck <- function(ar) {
    p <- max(which(c(1, -ar) != 0)) - 1
    if (!p) 
      return(TRUE)
    all(Mod(polyroot(c(1, -ar[1:p]))) > 1)
  }
  maInvert <- function(ma) {
    q <- length(ma)
    q0 <- max(which(c(1, ma) != 0)) - 1
    if (!q0) 
      return(ma)
    roots <- polyroot(c(1, ma[1:q0]))
    ind <- Mod(roots) < 1
    if (all(!ind)) 
      return(ma)
    if (q0 == 1) 
      return(c(1/ma[1], rep.int(0, q - q0)))
    roots[ind] <- 1/roots[ind]
    x <- 1
    for (r in roots) x <- c(x, 0) - c(0, x)/r
    c(Re(x[-1]), rep.int(0, q - q0))
  }
  series <- deparse1(substitute(x))
  if (NCOL(x) > 1) 
    stop("only implemented for univariate time series")
  method <- match.arg(method)
  x <- as.ts(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  storage.mode(x) <- "double"
  dim(x) <- NULL
  n <- length(x)
  if (!missing(order)) 
    if (!is.numeric(order) || length(order) != 3 || any(order < 0)) 
      stop("'order' must be a non-negative numeric vector of length 3")
  if (!missing(seasonal)) 
    if (is.list(seasonal)) {
      if (is.null(seasonal$order)) 
        stop("'seasonal' must be a list with component 'order'")
      if (!is.numeric(seasonal$order) || length(seasonal$order) != 3 || any(seasonal$order < 0)) 
        stop("'seasonal$order' must be a non-negative numeric vector of length 3")
    }
  else if (is.numeric(order)) {
    if (length(order) == 3) 
      seasonal <- list(order = seasonal)
    else ("'seasonal' is of the wrong length")
  }
  else stop("'seasonal' must be a list with component 'order'")
  if (is.null(seasonal$period) || is.na(seasonal$period) || seasonal$period == 0) 
    seasonal$period <- frequency(x)
  arma <- as.integer(c(order[-2], seasonal$order[-2], seasonal$period, order[2], seasonal$order[2]))
  narma <- sum(arma[1:4])
  xtsp <- tsp(x)
  tsp(x) <- NULL
  Delta <- 1
  for (i in seq_len(order[2])) Delta <- Delta %+% c(1, -1)
  for (i in seq_len(seasonal$order[2])) Delta <- Delta %+% c(1, rep.int(0, seasonal$period - 1), -1)
  Delta <- -Delta[-1]
  nd <- order[2] + seasonal$order[2]
  n.used <- sum(!is.na(x)) - length(Delta)
  if (is.null(xreg)) {
    ncxreg <- 0
  }
  else {
    nmxreg <- deparse1(substitute(xreg))
    if (NROW(xreg) != n) 
      stop("lengths of 'x' and 'xreg' do not match")
    ncxreg <- NCOL(xreg)
    xreg <- as.matrix(xreg)
    storage.mode(xreg) <- "double"
  }
  class(xreg) <- NULL
  if (ncxreg > 0 && is.null(colnames(xreg))) 
    colnames(xreg) <- if (ncxreg == 1) 
      nmxreg
  else paste0(nmxreg, 1:ncxreg)
  if (include.mean && (nd == 0)) {
    xreg <- cbind(intercept = rep(1, n), xreg = xreg)
    ncxreg <- ncxreg + 1
  }
  if (method == "CSS-ML") {
    anyna <- anyNA(x)
    if (ncxreg) 
      anyna <- anyna || anyNA(xreg)
    if (anyna) 
      method <- "ML"
  }
  if (method == "CSS" || method == "CSS-ML") {
    ncond <- order[2] + seasonal$order[2] * seasonal$period
    ncond1 <- order[1] + seasonal$period * seasonal$order[1]
    ncond <- ncond + if (!missing(n.cond)) 
      max(n.cond, ncond1)
    else ncond1
  }
  else ncond <- 0
  if (is.null(fixed)) 
    fixed <- rep(NA, narma + ncxreg)
  else if (length(fixed) != narma + ncxreg) 
    stop("wrong length for 'fixed'")
  mask <- is.na(fixed)
  no.optim <- !any(mask)
  if (no.optim) 
    transform.pars <- FALSE
  if (transform.pars) {
    ind <- arma[1] + arma[2] + seq_len(arma[3])
    if (any(!mask[seq_len(arma[1])]) || any(!mask[ind])) {
      warning("some AR parameters were fixed: setting transform.pars = FALSE")
      transform.pars <- FALSE
    }
  }
  init0 <- rep.int(0, narma)
  parscale <- rep(1, narma)
  if (ncxreg) {
    cn <- colnames(xreg)
    orig.xreg <- (ncxreg == 1) || any(!mask[narma + 1:ncxreg])
    if (!orig.xreg) {
      S <- svd(na.omit(xreg))
      xreg <- xreg %*% S$v
    }
    dx <- x
    dxreg <- xreg
    if (order[2] > 0) {
      dx <- diff(dx, 1, order[2])
      dxreg <- diff(dxreg, 1, order[2])
    }
    if (seasonal$period > 1 && seasonal$order[2] > 0) {
      dx <- diff(dx, seasonal$period, seasonal$order[2])
      dxreg <- diff(dxreg, seasonal$period, seasonal$order[2])
    }
    fit <- if (length(dx) > ncol(dxreg)) 
      lm(dx ~ dxreg - 1, na.action = na.omit)
    else list(rank = 0)
    if (fit$rank == 0) {
      fit <- lm(x ~ xreg - 1, na.action = na.omit)
    }
    isna <- is.na(x) | apply(xreg, 1, anyNA)
    n.used <- sum(!isna) - length(Delta)
    init0 <- c(init0, coef(fit))
    ses <- summary(fit)$coefficients[, 2]
    parscale <- c(parscale, 10 * ses)
  }
  if (n.used <= 0) 
    stop("too few non-missing observations")
  if (!is.null(init)) {
    if (length(init) != length(init0)) 
      stop("'init' is of the wrong length")
    if (any(ind <- is.na(init))) 
      init[ind] <- init0[ind]
    if (method == "ML") {
      if (arma[1] > 0) 
        if (!arCheck(init[1:arma[1]])) 
          stop("non-stationary AR part")
      if (arma[3] > 0) 
        if (!arCheck(init[sum(arma[1:2]) + 1:arma[3]])) 
          stop("non-stationary seasonal AR part")
      if (transform.pars) 
        init <- .Call(C_ARIMA_Invtrans, as.double(init), arma)
    }
  }
  else init <- init0
  coef <- as.double(fixed)
  if (!("parscale" %in% names(optim.control))) 
    optim.control$parscale <- parscale[mask]
  if (method == "CSS") {
    res <- if (no.optim) 
      list(convergence = 0, par = numeric(), value = armaCSS(numeric()))
    else optim(init[mask], armaCSS, method = optim.method, hessian = TRUE, control = optim.control)
    if (res$convergence > 0) 
      warning(gettextf("possible convergence problem: optim gave code = %d", res$convergence), domain = NA)
    coef[mask] <- res$par
    trarma <- .Call(C_ARIMA_transPars, coef, arma, FALSE)
    mod <- makeARIMA(trarma[[1]], trarma[[2]], Delta, kappa, SSinit)
    if (ncxreg > 0) 
      x <- x - xreg %*% coef[narma + (1:ncxreg)]
    arimaSS(x, mod)
    val <- .Call(C_ARIMA_CSS, x, arma, trarma[[1]], trarma[[2]], as.integer(ncond), TRUE)
    sigma2 <- val[[1]]
    var <- if (no.optim) 
      numeric()
    else solve(res$hessian * n.used)
  }
  else {
    if (method == "CSS-ML") {
      res <- if (no.optim) 
        list(convergence = 0, par = numeric(), value = armaCSS(numeric()))
      else optim(init[mask], armaCSS, method = optim.method, hessian = FALSE, control = optim.control)
      if (res$convergence == 0) 
        init[mask] <- res$par
      if (arma[1] > 0) 
        if (!arCheck(init[1:arma[1]])) 
          stop("non-stationary AR part from CSS")
      if (arma[3] > 0) 
        if (!arCheck(init[sum(arma[1:2]) + 1:arma[3]])) 
          stop("non-stationary seasonal AR part from CSS")
      ncond <- 0
    }
    if (transform.pars) {
      init <- .Call(C_ARIMA_Invtrans, init, arma)
      if (arma[2] > 0) {
        ind <- arma[1] + 1:arma[2]
        init[ind] <- maInvert(init[ind])
      }
      if (arma[4] > 0) {
        ind <- sum(arma[1:3]) + 1:arma[4]
        init[ind] <- maInvert(init[ind])
      }
    }
    trarma <- .Call(C_ARIMA_transPars, init, arma, transform.pars)
    mod <- makeARIMA(trarma[[1]], trarma[[2]], Delta, kappa, SSinit)
    res <- if (no.optim) 
      list(convergence = 0, par = numeric(), value = armafn(numeric(), as.logical(transform.pars)))
    else optim(init[mask], armafn, method = optim.method, hessian = TRUE, control = optim.control, trans = as.logical(transform.pars))
    if (res$convergence > 0) 
      warning(gettextf("possible convergence problem: optim gave code = %d", res$convergence), domain = NA)
    coef[mask] <- res$par
    if (transform.pars) {
      if (arma[2] > 0) {
        ind <- arma[1] + 1:arma[2]
        if (all(mask[ind])) 
          coef[ind] <- maInvert(coef[ind])
      }
      if (arma[4] > 0) {
        ind <- sum(arma[1:3]) + 1:arma[4]
        if (all(mask[ind])) 
          coef[ind] <- maInvert(coef[ind])
      }
      if (any(coef[mask] != res$par)) {
        oldcode <- res$convergence
        res <- optim(coef[mask], armafn, method = optim.method, hessian = TRUE, control = list(maxit = 0, parscale = optim.control$parscale), trans = TRUE)
        res$convergence <- oldcode
        coef[mask] <- res$par
      }
      A <- .Call(C_ARIMA_Gradtrans, as.double(coef), arma)
      A <- A[mask, mask]
      var <- crossprod(A, solve(res$hessian * n.used, A))
      coef <- .Call(C_ARIMA_undoPars, coef, arma)
    }
    else var <- if (no.optim) 
      numeric()
    else solve(res$hessian * n.used)
    trarma <- .Call(C_ARIMA_transPars, coef, arma, FALSE)
    mod <- makeARIMA(trarma[[1]], trarma[[2]], Delta, kappa, SSinit)
    val <- if (ncxreg > 0) 
      arimaSS(x - xreg %*% coef[narma + (1:ncxreg)], mod)
    else arimaSS(x, mod)
    sigma2 <- val[[1]][1]/n.used
  }
  value <- 2 * n.used * res$value + n.used + n.used * log(2 * pi)
  aic <- if (method != "CSS") 
    value + 2 * sum(mask) + 2
  else NA
  nm <- NULL
  if (arma[1] > 0) 
    nm <- c(nm, paste0("ar", 1:arma[1]))
  if (arma[2] > 0) 
    nm <- c(nm, paste0("ma", 1:arma[2]))
  if (arma[3] > 0) 
    nm <- c(nm, paste0("sar", 1:arma[3]))
  if (arma[4] > 0) 
    nm <- c(nm, paste0("sma", 1:arma[4]))
  if (ncxreg > 0) {
    nm <- c(nm, cn)
    if (!orig.xreg) {
      ind <- narma + 1:ncxreg
      coef[ind] <- S$v %*% coef[ind]
      A <- diag(narma + ncxreg)
      A[ind, ind] <- S$v
      A <- A[mask, mask]
      var <- A %*% var %*% t(A)
    }
  }
  names(coef) <- nm
  if (!no.optim) 
    dimnames(var) <- list(nm[mask], nm[mask])
  resid <- val[[2]]
  tsp(resid) <- xtsp
  class(resid) <- "ts"
  structure(list(coef = coef, sigma2 = sigma2, var.coef = var, mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, residuals = resid, call = match.call(), series = series, code = res$convergence, n.cond = ncond, nobs = n.used, model = mod), class = "Arima")
}, function (x, order = c(0, 0, 0), seasonal = list(order = c(0, 0, 0), period = NA), xreg = NULL, include.mean = TRUE, transform.pars = TRUE, fixed = NULL, init = NULL, method = c("CSS-ML", "ML", "CSS"), n.cond, SSinit = c("Gardner1980", "Rossignol2011"), optim.method = "BFGS", optim.control = list(), kappa = 1e+06) 
{
  "%+%" <- function(a, b) .Call(C_TSconv, a, b)
  SSinit <- match.arg(SSinit)
  SS.G <- SSinit == "Gardner1980"
  upARIMA <- function(mod, phi, theta) {
    p <- length(phi)
    q <- length(theta)
    mod$phi <- phi
    mod$theta <- theta
    r <- max(p, q + 1)
    if (p > 0) 
      mod$T[1:p, 1] <- phi
    if (r > 1) 
      mod$Pn[1:r, 1:r] <- if (SS.G) 
        .Call(C_getQ0, phi, theta)
    else .Call(C_getQ0bis, phi, theta, tol = 0)
    else mod$Pn[1, 1] <- if (p > 0) 
      1/(1 - phi^2)
    else 1
    mod$a[] <- 0
    mod
  }
  arimaSS <- function(y, mod) {
    .Call(C_ARIMA_Like, y, mod, 0, TRUE)
  }
  armafn <- function(p, trans) {
    par <- coef
    par[mask] <- p
    trarma <- .Call(C_ARIMA_transPars, par, arma, trans)
    if (is.null(Z <- tryCatch(upARIMA(mod, trarma[[1]], trarma[[2]]), error = function(e) NULL))) 
      return(.Machine$double.xmax)
    if (ncxreg > 0) 
      x <- x - xreg %*% par[narma + (1:ncxreg)]
    res <- .Call(C_ARIMA_Like, x, Z, 0, FALSE)
    s2 <- res[1]/res[3]
    0.5 * (log(s2) + res[2]/res[3])
  }
  armaCSS <- function(p) {
    par <- as.double(fixed)
    par[mask] <- p
    trarma <- .Call(C_ARIMA_transPars, par, arma, FALSE)
    if (ncxreg > 0) 
      x <- x - xreg %*% par[narma + (1:ncxreg)]
    res <- .Call(C_ARIMA_CSS, x, arma, trarma[[1]], trarma[[2]], as.integer(ncond), FALSE)
    0.5 * log(res)
  }
  arCheck <- function(ar) {
    p <- max(which(c(1, -ar) != 0)) - 1
    if (!p) 
      return(TRUE)
    all(Mod(polyroot(c(1, -ar[1:p]))) > 1)
  }
  maInvert <- function(ma) {
    q <- length(ma)
    q0 <- max(which(c(1, ma) != 0)) - 1
    if (!q0) 
      return(ma)
    roots <- polyroot(c(1, ma[1:q0]))
    ind <- Mod(roots) < 1
    if (all(!ind)) 
      return(ma)
    if (q0 == 1) 
      return(c(1/ma[1], rep.int(0, q - q0)))
    roots[ind] <- 1/roots[ind]
    x <- 1
    for (r in roots) x <- c(x, 0) - c(0, x)/r
    c(Re(x[-1]), rep.int(0, q - q0))
  }
  series <- deparse1(substitute(x))
  if (NCOL(x) > 1) 
    stop("only implemented for univariate time series")
  method <- match.arg(method)
  x <- as.ts(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  storage.mode(x) <- "double"
  dim(x) <- NULL
  n <- length(x)
  if (!missing(order)) 
    if (!is.numeric(order) || length(order) != 3 || any(order < 0)) 
      stop("'order' must be a non-negative numeric vector of length 3")
  if (!missing(seasonal)) 
    if (is.list(seasonal)) {
      if (is.null(seasonal$order)) 
        stop("'seasonal' must be a list with component 'order'")
      if (!is.numeric(seasonal$order) || length(seasonal$order) != 3 || any(seasonal$order < 0)) 
        stop("'seasonal$order' must be a non-negative numeric vector of length 3")
    }
  else if (is.numeric(order)) {
    if (length(order) == 3) 
      seasonal <- list(order = seasonal)
    else ("'seasonal' is of the wrong length")
  }
  else stop("'seasonal' must be a list with component 'order'")
  if (is.null(seasonal$period) || is.na(seasonal$period) || seasonal$period == 0) 
    seasonal$period <- frequency(x)
  arma <- as.integer(c(order[-2], seasonal$order[-2], seasonal$period, order[2], seasonal$order[2]))
  narma <- sum(arma[1:4])
  xtsp <- tsp(x)
  tsp(x) <- NULL
  Delta <- 1
  for (i in seq_len(order[2])) Delta <- Delta %+% c(1, -1)
  for (i in seq_len(seasonal$order[2])) Delta <- Delta %+% c(1, rep.int(0, seasonal$period - 1), -1)
  Delta <- -Delta[-1]
  nd <- order[2] + seasonal$order[2]
  n.used <- sum(!is.na(x)) - length(Delta)
  if (is.null(xreg)) {
    ncxreg <- 0
  }
  else {
    nmxreg <- deparse1(substitute(xreg))
    if (NROW(xreg) != n) 
      stop("lengths of 'x' and 'xreg' do not match")
    ncxreg <- NCOL(xreg)
    xreg <- as.matrix(xreg)
    storage.mode(xreg) <- "double"
  }
  class(xreg) <- NULL
  if (ncxreg > 0 && is.null(colnames(xreg))) 
    colnames(xreg) <- if (ncxreg == 1) 
      nmxreg
  else paste0(nmxreg, 1:ncxreg)
  if (include.mean && (nd == 0)) {
    xreg <- cbind(intercept = rep(1, n), xreg = xreg)
    ncxreg <- ncxreg + 1
  }
  if (method == "CSS-ML") {
    anyna <- anyNA(x)
    if (ncxreg) 
      anyna <- anyna || anyNA(xreg)
    if (anyna) 
      method <- "ML"
  }
  if (method == "CSS" || method == "CSS-ML") {
    ncond <- order[2] + seasonal$order[2] * seasonal$period
    ncond1 <- order[1] + seasonal$period * seasonal$order[1]
    ncond <- ncond + if (!missing(n.cond)) 
      max(n.cond, ncond1)
    else ncond1
  }
  else ncond <- 0
  if (is.null(fixed)) 
    fixed <- rep(NA, narma + ncxreg)
  else if (length(fixed) != narma + ncxreg) 
    stop("wrong length for 'fixed'")
  mask <- is.na(fixed)
  no.optim <- !any(mask)
  if (no.optim) 
    transform.pars <- FALSE
  if (transform.pars) {
    ind <- arma[1] + arma[2] + seq_len(arma[3])
    if (any(!mask[seq_len(arma[1])]) || any(!mask[ind])) {
      warning("some AR parameters were fixed: setting transform.pars = FALSE")
      transform.pars <- FALSE
    }
  }
  init0 <- rep.int(0, narma)
  parscale <- rep(1, narma)
  if (ncxreg) {
    cn <- colnames(xreg)
    orig.xreg <- (ncxreg == 1) || any(!mask[narma + 1:ncxreg])
    if (!orig.xreg) {
      S <- svd(na.omit(xreg))
      xreg <- xreg %*% S$v
    }
    dx <- x
    dxreg <- xreg
    if (order[2] > 0) {
      dx <- diff(dx, 1, order[2])
      dxreg <- diff(dxreg, 1, order[2])
    }
    if (seasonal$period > 1 && seasonal$order[2] > 0) {
      dx <- diff(dx, seasonal$period, seasonal$order[2])
      dxreg <- diff(dxreg, seasonal$period, seasonal$order[2])
    }
    fit <- if (length(dx) > ncol(dxreg)) 
      lm(dx ~ dxreg - 1, na.action = na.omit)
    else list(rank = 0)
    if (fit$rank == 0) {
      fit <- lm(x ~ xreg - 1, na.action = na.omit)
    }
    isna <- is.na(x) | apply(xreg, 1, anyNA)
    n.used <- sum(!isna) - length(Delta)
    init0 <- c(init0, coef(fit))
    ses <- summary(fit)$coefficients[, 2]
    parscale <- c(parscale, 10 * ses)
  }
  if (n.used <= 0) 
    stop("too few non-missing observations")
  if (!is.null(init)) {
    if (length(init) != length(init0)) 
      stop("'init' is of the wrong length")
    if (any(ind <- is.na(init))) 
      init[ind] <- init0[ind]
    if (method == "ML") {
      if (arma[1] > 0) 
        if (!arCheck(init[1:arma[1]])) 
          stop("non-stationary AR part")
      if (arma[3] > 0) 
        if (!arCheck(init[sum(arma[1:2]) + 1:arma[3]])) 
          stop("non-stationary seasonal AR part")
      if (transform.pars) 
        init <- .Call(C_ARIMA_Invtrans, as.double(init), arma)
    }
  }
  else init <- init0
  coef <- as.double(fixed)
  if (!("parscale" %in% names(optim.control))) 
    optim.control$parscale <- parscale[mask]
  if (method == "CSS") {
    res <- if (no.optim) 
      list(convergence = 0, par = numeric(), value = armaCSS(numeric()))
    else optim(init[mask], armaCSS, method = optim.method, hessian = TRUE, control = optim.control)
    if (res$convergence > 0) 
      warning(gettextf("possible convergence problem: optim gave code = %d", res$convergence), domain = NA)
    coef[mask] <- res$par
    trarma <- .Call(C_ARIMA_transPars, coef, arma, FALSE)
    mod <- makeARIMA(trarma[[1]], trarma[[2]], Delta, kappa, SSinit)
    if (ncxreg > 0) 
      x <- x - xreg %*% coef[narma + (1:ncxreg)]
    arimaSS(x, mod)
    val <- .Call(C_ARIMA_CSS, x, arma, trarma[[1]], trarma[[2]], as.integer(ncond), TRUE)
    sigma2 <- val[[1]]
    var <- if (no.optim) 
      numeric()
    else solve(res$hessian * n.used)
  }
  else {
    if (method == "CSS-ML") {
      res <- if (no.optim) 
        list(convergence = 0, par = numeric(), value = armaCSS(numeric()))
      else optim(init[mask], armaCSS, method = optim.method, hessian = FALSE, control = optim.control)
      if (res$convergence == 0) 
        init[mask] <- res$par
      if (arma[1] > 0) 
        if (!arCheck(init[1:arma[1]])) 
          stop("non-stationary AR part from CSS")
      if (arma[3] > 0) 
        if (!arCheck(init[sum(arma[1:2]) + 1:arma[3]])) 
          stop("non-stationary seasonal AR part from CSS")
      ncond <- 0
    }
    if (transform.pars) {
      init <- .Call(C_ARIMA_Invtrans, init, arma)
      if (arma[2] > 0) {
        ind <- arma[1] + 1:arma[2]
        init[ind] <- maInvert(init[ind])
      }
      if (arma[4] > 0) {
        ind <- sum(arma[1:3]) + 1:arma[4]
        init[ind] <- maInvert(init[ind])
      }
    }
    trarma <- .Call(C_ARIMA_transPars, init, arma, transform.pars)
    mod <- makeARIMA(trarma[[1]], trarma[[2]], Delta, kappa, SSinit)
    res <- if (no.optim) 
      list(convergence = 0, par = numeric(), value = armafn(numeric(), as.logical(transform.pars)))
    else optim(init[mask], armafn, method = optim.method, hessian = TRUE, control = optim.control, trans = as.logical(transform.pars))
    if (res$convergence > 0) 
      warning(gettextf("possible convergence problem: optim gave code = %d", res$convergence), domain = NA)
    coef[mask] <- res$par
    if (transform.pars) {
      if (arma[2] > 0) {
        ind <- arma[1] + 1:arma[2]
        if (all(mask[ind])) 
          coef[ind] <- maInvert(coef[ind])
      }
      if (arma[4] > 0) {
        ind <- sum(arma[1:3]) + 1:arma[4]
        if (all(mask[ind])) 
          coef[ind] <- maInvert(coef[ind])
      }
      if (any(coef[mask] != res$par)) {
        oldcode <- res$convergence
        res <- optim(coef[mask], armafn, method = optim.method, hessian = TRUE, control = list(maxit = 0, parscale = optim.control$parscale), trans = TRUE)
        res$convergence <- oldcode
        coef[mask] <- res$par
      }
      A <- .Call(C_ARIMA_Gradtrans, as.double(coef), arma)
      A <- A[mask, mask]
      var <- crossprod(A, solve(res$hessian * n.used, A))
      coef <- .Call(C_ARIMA_undoPars, coef, arma)
    }
    else var <- if (no.optim) 
      numeric()
    else solve(res$hessian * n.used)
    trarma <- .Call(C_ARIMA_transPars, coef, arma, FALSE)
    mod <- makeARIMA(trarma[[1]], trarma[[2]], Delta, kappa, SSinit)
    val <- if (ncxreg > 0) 
      arimaSS(x - xreg %*% coef[narma + (1:ncxreg)], mod)
    else arimaSS(x, mod)
    sigma2 <- val[[1]][1]/n.used
  }
  value <- 2 * n.used * res$value + n.used + n.used * log(2 * pi)
  aic <- if (method != "CSS") 
    value + 2 * sum(mask) + 2
  else NA
  nm <- NULL
  if (arma[1] > 0) 
    nm <- c(nm, paste0("ar", 1:arma[1]))
  if (arma[2] > 0) 
    nm <- c(nm, paste0("ma", 1:arma[2]))
  if (arma[3] > 0) 
    nm <- c(nm, paste0("sar", 1:arma[3]))
  if (arma[4] > 0) 
    nm <- c(nm, paste0("sma", 1:arma[4]))
  if (ncxreg > 0) {
    nm <- c(nm, cn)
    if (!orig.xreg) {
      ind <- narma + 1:ncxreg
      coef[ind] <- S$v %*% coef[ind]
      A <- diag(narma + ncxreg)
      A[ind, ind] <- S$v
      A <- A[mask, mask]
      var <- A %*% var %*% t(A)
    }
  }
  names(coef) <- nm
  if (!no.optim) 
    dimnames(var) <- list(nm[mask], nm[mask])
  resid <- val[[2]]
  tsp(resid) <- xtsp
  class(resid) <- "ts"
  structure(list(coef = coef, sigma2 = sigma2, var.coef = var, mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, residuals = resid, call = match.call(), series = series, code = res$convergence, n.cond = ncond, nobs = n.used, model = mod), class = "Arima")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
arima.sim
list(`package:stats` = function (model, n, rand.gen = rnorm, innov = rand.gen(n, ...), n.start = NA, start.innov = rand.gen(n.start, ...), ...) 
{
  if (!is.list(model)) 
    stop("'model' must be list")
  if (n <= 0) 
    stop("'n' must be strictly positive")
  p <- length(model$ar)
  if (p) {
    minroots <- min(Mod(polyroot(c(1, -model$ar))))
    if (minroots <= 1) 
      stop("'ar' part of model is not stationary")
  }
  q <- length(model$ma)
  if (is.na(n.start)) 
    n.start <- p + q + ifelse(p > 0, ceiling(6/log(minroots)), 0)
  if (n.start < p + q) 
    stop("burn-in 'n.start' must be as long as 'ar + ma'")
  d <- 0
  if (!is.null(ord <- model$order)) {
    if (length(ord) != 3) 
      stop("'model$order' must be of length 3")
    if (p != ord[1]) 
      stop("inconsistent specification of 'ar' order")
    if (q != ord[3]) 
      stop("inconsistent specification of 'ma' order")
    d <- ord[2]
    if (d != round(d) || d < 0) 
      stop("number of differences must be a positive integer")
  }
  if (!missing(start.innov) && length(start.innov) < n.start) 
    stop(sprintf(ngettext(n.start, "'start.innov' is too short: need %d point", "'start.innov' is too short: need %d points"), n.start), domain = NA)
  x <- ts(c(start.innov[seq_len(n.start)], innov[1:n]), start = 1 - n.start)
  if (length(model$ma)) {
    x <- filter(x, c(1, model$ma), sides = 1)
    x[seq_along(model$ma)] <- 0
  }
  if (length(model$ar)) 
    x <- filter(x, model$ar, method = "recursive")
  if (n.start > 0) 
    x <- x[-(seq_len(n.start))]
  if (d > 0) 
    x <- diffinv(x, differences = d)
  as.ts(x)
}, function (model, n, rand.gen = rnorm, innov = rand.gen(n, ...), n.start = NA, start.innov = rand.gen(n.start, ...), ...) 
{
  if (!is.list(model)) 
    stop("'model' must be list")
  if (n <= 0) 
    stop("'n' must be strictly positive")
  p <- length(model$ar)
  if (p) {
    minroots <- min(Mod(polyroot(c(1, -model$ar))))
    if (minroots <= 1) 
      stop("'ar' part of model is not stationary")
  }
  q <- length(model$ma)
  if (is.na(n.start)) 
    n.start <- p + q + ifelse(p > 0, ceiling(6/log(minroots)), 0)
  if (n.start < p + q) 
    stop("burn-in 'n.start' must be as long as 'ar + ma'")
  d <- 0
  if (!is.null(ord <- model$order)) {
    if (length(ord) != 3) 
      stop("'model$order' must be of length 3")
    if (p != ord[1]) 
      stop("inconsistent specification of 'ar' order")
    if (q != ord[3]) 
      stop("inconsistent specification of 'ma' order")
    d <- ord[2]
    if (d != round(d) || d < 0) 
      stop("number of differences must be a positive integer")
  }
  if (!missing(start.innov) && length(start.innov) < n.start) 
    stop(sprintf(ngettext(n.start, "'start.innov' is too short: need %d point", "'start.innov' is too short: need %d points"), n.start), domain = NA)
  x <- ts(c(start.innov[seq_len(n.start)], innov[1:n]), start = 1 - n.start)
  if (length(model$ma)) {
    x <- filter(x, c(1, model$ma), sides = 1)
    x[seq_along(model$ma)] <- 0
  }
  if (length(model$ar)) 
    x <- filter(x, model$ar, method = "recursive")
  if (n.start > 0) 
    x <- x[-(seq_len(n.start))]
  if (d > 0) 
    x <- diffinv(x, differences = d)
  as.ts(x)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
arima0
list(`package:stats` = function (x, order = c(0, 0, 0), seasonal = list(order = c(0, 0, 0), period = NA), xreg = NULL, include.mean = TRUE, delta = 0.01, transform.pars = TRUE, fixed = NULL, init = NULL, method = c("ML", "CSS"), n.cond, optim.control = list()) 
{
  arma0f <- function(p) {
    par <- as.double(fixed)
    par[mask] <- p
    .Call(C_arma0fa, G, par)
  }
  arCheck <- function(ar) {
    p <- max(which(c(1, -ar) != 0)) - 1
    if (!p) 
      return(TRUE)
    all(Mod(polyroot(c(1, -ar[1:p]))) > 1)
  }
  maInvert <- function(ma) {
    q <- length(ma)
    q0 <- max(which(c(1, ma) != 0)) - 1
    if (!q0) 
      return(ma)
    roots <- polyroot(c(1, ma[1:q0]))
    ind <- Mod(roots) < 1
    if (all(!ind)) 
      return(ma)
    warning("converting non-invertible initial MA values")
    if (q0 == 1) 
      return(c(1/ma[1], rep(0, q - q0)))
    roots[ind] <- 1/roots[ind]
    x <- 1
    for (r in roots) x <- c(x, 0) - c(0, x)/r
    c(Re(x[-1]), rep(0, q - q0))
  }
  series <- deparse1(substitute(x))
  if (NCOL(x) > 1) 
    stop("only implemented for univariate time series")
  method <- match.arg(method)
  x <- as.ts(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  dim(x) <- NULL
  n <- length(x)
  if (!missing(order)) 
    if (!is.numeric(order) || length(order) != 3 || any(order < 0)) 
      stop("'order' must be a non-negative numeric vector of length 3")
  if (!missing(seasonal)) 
    if (is.list(seasonal)) {
      if (is.null(seasonal$order)) 
        stop("'seasonal' must be a list with component 'order'")
      if (!is.numeric(seasonal$order) || length(seasonal$order) != 3 || any(seasonal$order < 0)) 
        stop("'seasonal$order' must be a non-negative numeric vector of length 3")
    }
  else if (is.numeric(order)) {
    if (length(order) == 3) 
      seasonal <- list(order = seasonal)
    else ("'seasonal' is of the wrong length")
  }
  else stop("'seasonal' must be a list with component 'order'")
  if (is.null(seasonal$period) || is.na(seasonal$period) || seasonal$period == 0) 
    seasonal$period <- frequency(x)
  arma <- c(order[-2], seasonal$order[-2], seasonal$period, order[2], seasonal$order[2])
  narma <- sum(arma[1:4])
  if (d <- order[2]) 
    x <- diff(x, 1, d)
  if (d <- seasonal$order[2]) 
    x <- diff(x, seasonal$period, d)
  xtsp <- tsp(x)
  tsp(x) <- NULL
  nd <- order[2] + seasonal$order[2]
  n.used <- length(x)
  ncond <- n - n.used
  if (method == "CSS") {
    ncond1 <- order[1] + seasonal$period * seasonal$order[1]
    ncond <- if (!missing(n.cond)) 
      ncond + max(n.cond, ncond1)
    else ncond + ncond1
  }
  if (is.null(xreg)) {
    ncxreg <- 0
  }
  else {
    if (NROW(xreg) != n) 
      stop("lengths of 'x' and 'xreg' do not match")
    ncxreg <- NCOL(xreg)
  }
  class(xreg) <- NULL
  if (include.mean && (nd == 0)) {
    if (is.matrix(xreg) && is.null(colnames(xreg))) 
      colnames(xreg) <- paste0("xreg", 1:ncxreg)
    xreg <- cbind(intercept = rep_len(1, n), xreg = xreg)
    ncxreg <- ncxreg + 1
  }
  if (is.null(fixed)) 
    fixed <- rep_len(NA, narma + ncxreg)
  else if (length(fixed) != narma + ncxreg) 
    stop("wrong length for 'fixed'")
  mask <- is.na(fixed)
  if (!any(mask)) 
    stop("all parameters were fixed")
  if (transform.pars && any(!mask[1:narma])) {
    warning("some ARMA parameters were fixed: setting transform.pars = FALSE")
    transform.pars <- FALSE
  }
  if (ncxreg) {
    if (d <- order[2]) 
      xreg <- diff(xreg, 1, d)
    if (d <- seasonal$order[2]) 
      xreg <- diff(xreg, seasonal$period, d)
    xreg <- as.matrix(xreg)
    if (qr(na.omit(xreg))$rank < ncol(xreg)) 
      stop("'xreg' is collinear")
    if (is.null(cn <- colnames(xreg))) 
      cn <- paste0("xreg", 1:ncxreg)
  }
  if (anyNA(x) || (ncxreg && anyNA(xreg))) 
    if (method == "ML" && delta >= 0) {
      warning("NAs present: setting 'delta' to -1")
      delta <- -1
    }
  init0 <- rep_len(0, narma)
  parscale <- rep_len(1, narma)
  if (ncxreg) {
    orig.xreg <- (ncxreg == 1) || any(!mask[narma + 1:ncxreg])
    if (!orig.xreg) {
      S <- svd(na.omit(xreg))
      xreg <- xreg %*% S$v
    }
    fit <- lm(x ~ xreg - 1, na.action = na.omit)
    init0 <- c(init0, coef(fit))
    ses <- summary(fit)$coefficients[, 2]
    parscale <- c(parscale, ses)
  }
  storage.mode(x) <- storage.mode(xreg) <- "double"
  if (method == "CSS") 
    transform.pars <- 0
  G <- .Call(C_setup_starma, as.integer(arma), x, n.used, xreg, ncxreg, delta, transform.pars > 0, ncond - (n - n.used))
  on.exit(.Call(C_free_starma, G))
  if (!is.null(init)) {
    if (length(init) != length(init0)) 
      stop("'init' is of the wrong length")
    if (any(ind <- is.na(init))) 
      init[ind] <- init0[ind]
    if (transform.pars) {
      if (any(!mask[1:narma])) 
        warning("transformed ARMA parameters were fixed")
      if (arma[1] > 0) 
        if (!arCheck(init[1:arma[1]])) 
          stop("non-stationary AR part")
      if (arma[3] > 0) 
        if (!arCheck(init[sum(arma[1:2]) + 1:arma[3]])) 
          stop("non-stationary seasonal AR part")
      if (arma[2] > 0) {
        ind <- arma[1] + 1:arma[2]
        init[ind] <- maInvert(init[ind])
      }
      if (arma[4] > 0) {
        ind <- sum(arma[1:3]) + 1:arma[4]
        init[ind] <- maInvert(init[ind])
      }
      init <- .Call(C_Invtrans, G, as.double(init))
    }
  }
  else init <- init0
  .Call(C_Starma_method, G, method == "CSS")
  if (!("parscale" %in% names(optim.control))) 
    optim.control$parscale <- parscale[mask]
  res <- optim(init[mask], arma0f, method = "BFGS", hessian = TRUE, control = optim.control)
  if ((code <- res$convergence) > 0) 
    warning(gettextf("possible convergence problem: optim gave code = %d", code), domain = NA)
  coef <- res$par
  if (transform.pars) {
    cf <- fixed
    cf[mask] <- coef
    A <- .Call(C_Gradtrans, G, as.double(cf))[mask, mask]
    var <- t(A) %*% solve(res$hessian * length(x)) %*% A
    coef <- .Call(C_Dotrans, G, as.double(cf))[mask]
    .Call(C_set_trans, G, 0)
  }
  else var <- solve(res$hessian * length(x))
  arma0f(coef)
  sigma2 <- .Call(C_get_s2, G)
  resid <- .Call(C_get_resid, G)
  tsp(resid) <- xtsp
  class(resid) <- "ts"
  n.used <- sum(!is.na(resid))
  nm <- NULL
  if (arma[1] > 0) 
    nm <- c(nm, paste0("ar", 1:arma[1]))
  if (arma[2] > 0) 
    nm <- c(nm, paste0("ma", 1:arma[2]))
  if (arma[3] > 0) 
    nm <- c(nm, paste0("sar", 1:arma[3]))
  if (arma[4] > 0) 
    nm <- c(nm, paste0("sma", 1:arma[4]))
  fixed[mask] <- coef
  if (ncxreg > 0) {
    nm <- c(nm, cn)
    if (!orig.xreg) {
      ind <- narma + 1:ncxreg
      fixed[ind] <- S$v %*% fixed[ind]
      A <- diag(narma + ncxreg)
      A[ind, ind] <- S$v
      A <- A[mask, mask]
      var <- A %*% var %*% t(A)
    }
  }
  names(fixed) <- nm
  names(arma) <- c("ar", "ma", "sar", "sma", "period", "diff", "sdiff")
  dimnames(var) <- list(nm[mask], nm[mask])
  value <- 2 * n.used * res$value + n.used + n.used * log(2 * pi)
  aic <- if (method != "CSS") 
    value + 2 * length(coef) + 2
  else NA
  res <- list(coef = fixed, sigma2 = sigma2, var.coef = var, mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, residuals = resid, call = match.call(), series = series, code = code, n.cond = ncond)
  class(res) <- "arima0"
  res
}, function (x, order = c(0, 0, 0), seasonal = list(order = c(0, 0, 0), period = NA), xreg = NULL, include.mean = TRUE, delta = 0.01, transform.pars = TRUE, fixed = NULL, init = NULL, method = c("ML", "CSS"), n.cond, optim.control = list()) 
{
  arma0f <- function(p) {
    par <- as.double(fixed)
    par[mask] <- p
    .Call(C_arma0fa, G, par)
  }
  arCheck <- function(ar) {
    p <- max(which(c(1, -ar) != 0)) - 1
    if (!p) 
      return(TRUE)
    all(Mod(polyroot(c(1, -ar[1:p]))) > 1)
  }
  maInvert <- function(ma) {
    q <- length(ma)
    q0 <- max(which(c(1, ma) != 0)) - 1
    if (!q0) 
      return(ma)
    roots <- polyroot(c(1, ma[1:q0]))
    ind <- Mod(roots) < 1
    if (all(!ind)) 
      return(ma)
    warning("converting non-invertible initial MA values")
    if (q0 == 1) 
      return(c(1/ma[1], rep(0, q - q0)))
    roots[ind] <- 1/roots[ind]
    x <- 1
    for (r in roots) x <- c(x, 0) - c(0, x)/r
    c(Re(x[-1]), rep(0, q - q0))
  }
  series <- deparse1(substitute(x))
  if (NCOL(x) > 1) 
    stop("only implemented for univariate time series")
  method <- match.arg(method)
  x <- as.ts(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  dim(x) <- NULL
  n <- length(x)
  if (!missing(order)) 
    if (!is.numeric(order) || length(order) != 3 || any(order < 0)) 
      stop("'order' must be a non-negative numeric vector of length 3")
  if (!missing(seasonal)) 
    if (is.list(seasonal)) {
      if (is.null(seasonal$order)) 
        stop("'seasonal' must be a list with component 'order'")
      if (!is.numeric(seasonal$order) || length(seasonal$order) != 3 || any(seasonal$order < 0)) 
        stop("'seasonal$order' must be a non-negative numeric vector of length 3")
    }
  else if (is.numeric(order)) {
    if (length(order) == 3) 
      seasonal <- list(order = seasonal)
    else ("'seasonal' is of the wrong length")
  }
  else stop("'seasonal' must be a list with component 'order'")
  if (is.null(seasonal$period) || is.na(seasonal$period) || seasonal$period == 0) 
    seasonal$period <- frequency(x)
  arma <- c(order[-2], seasonal$order[-2], seasonal$period, order[2], seasonal$order[2])
  narma <- sum(arma[1:4])
  if (d <- order[2]) 
    x <- diff(x, 1, d)
  if (d <- seasonal$order[2]) 
    x <- diff(x, seasonal$period, d)
  xtsp <- tsp(x)
  tsp(x) <- NULL
  nd <- order[2] + seasonal$order[2]
  n.used <- length(x)
  ncond <- n - n.used
  if (method == "CSS") {
    ncond1 <- order[1] + seasonal$period * seasonal$order[1]
    ncond <- if (!missing(n.cond)) 
      ncond + max(n.cond, ncond1)
    else ncond + ncond1
  }
  if (is.null(xreg)) {
    ncxreg <- 0
  }
  else {
    if (NROW(xreg) != n) 
      stop("lengths of 'x' and 'xreg' do not match")
    ncxreg <- NCOL(xreg)
  }
  class(xreg) <- NULL
  if (include.mean && (nd == 0)) {
    if (is.matrix(xreg) && is.null(colnames(xreg))) 
      colnames(xreg) <- paste0("xreg", 1:ncxreg)
    xreg <- cbind(intercept = rep_len(1, n), xreg = xreg)
    ncxreg <- ncxreg + 1
  }
  if (is.null(fixed)) 
    fixed <- rep_len(NA, narma + ncxreg)
  else if (length(fixed) != narma + ncxreg) 
    stop("wrong length for 'fixed'")
  mask <- is.na(fixed)
  if (!any(mask)) 
    stop("all parameters were fixed")
  if (transform.pars && any(!mask[1:narma])) {
    warning("some ARMA parameters were fixed: setting transform.pars = FALSE")
    transform.pars <- FALSE
  }
  if (ncxreg) {
    if (d <- order[2]) 
      xreg <- diff(xreg, 1, d)
    if (d <- seasonal$order[2]) 
      xreg <- diff(xreg, seasonal$period, d)
    xreg <- as.matrix(xreg)
    if (qr(na.omit(xreg))$rank < ncol(xreg)) 
      stop("'xreg' is collinear")
    if (is.null(cn <- colnames(xreg))) 
      cn <- paste0("xreg", 1:ncxreg)
  }
  if (anyNA(x) || (ncxreg && anyNA(xreg))) 
    if (method == "ML" && delta >= 0) {
      warning("NAs present: setting 'delta' to -1")
      delta <- -1
    }
  init0 <- rep_len(0, narma)
  parscale <- rep_len(1, narma)
  if (ncxreg) {
    orig.xreg <- (ncxreg == 1) || any(!mask[narma + 1:ncxreg])
    if (!orig.xreg) {
      S <- svd(na.omit(xreg))
      xreg <- xreg %*% S$v
    }
    fit <- lm(x ~ xreg - 1, na.action = na.omit)
    init0 <- c(init0, coef(fit))
    ses <- summary(fit)$coefficients[, 2]
    parscale <- c(parscale, ses)
  }
  storage.mode(x) <- storage.mode(xreg) <- "double"
  if (method == "CSS") 
    transform.pars <- 0
  G <- .Call(C_setup_starma, as.integer(arma), x, n.used, xreg, ncxreg, delta, transform.pars > 0, ncond - (n - n.used))
  on.exit(.Call(C_free_starma, G))
  if (!is.null(init)) {
    if (length(init) != length(init0)) 
      stop("'init' is of the wrong length")
    if (any(ind <- is.na(init))) 
      init[ind] <- init0[ind]
    if (transform.pars) {
      if (any(!mask[1:narma])) 
        warning("transformed ARMA parameters were fixed")
      if (arma[1] > 0) 
        if (!arCheck(init[1:arma[1]])) 
          stop("non-stationary AR part")
      if (arma[3] > 0) 
        if (!arCheck(init[sum(arma[1:2]) + 1:arma[3]])) 
          stop("non-stationary seasonal AR part")
      if (arma[2] > 0) {
        ind <- arma[1] + 1:arma[2]
        init[ind] <- maInvert(init[ind])
      }
      if (arma[4] > 0) {
        ind <- sum(arma[1:3]) + 1:arma[4]
        init[ind] <- maInvert(init[ind])
      }
      init <- .Call(C_Invtrans, G, as.double(init))
    }
  }
  else init <- init0
  .Call(C_Starma_method, G, method == "CSS")
  if (!("parscale" %in% names(optim.control))) 
    optim.control$parscale <- parscale[mask]
  res <- optim(init[mask], arma0f, method = "BFGS", hessian = TRUE, control = optim.control)
  if ((code <- res$convergence) > 0) 
    warning(gettextf("possible convergence problem: optim gave code = %d", code), domain = NA)
  coef <- res$par
  if (transform.pars) {
    cf <- fixed
    cf[mask] <- coef
    A <- .Call(C_Gradtrans, G, as.double(cf))[mask, mask]
    var <- t(A) %*% solve(res$hessian * length(x)) %*% A
    coef <- .Call(C_Dotrans, G, as.double(cf))[mask]
    .Call(C_set_trans, G, 0)
  }
  else var <- solve(res$hessian * length(x))
  arma0f(coef)
  sigma2 <- .Call(C_get_s2, G)
  resid <- .Call(C_get_resid, G)
  tsp(resid) <- xtsp
  class(resid) <- "ts"
  n.used <- sum(!is.na(resid))
  nm <- NULL
  if (arma[1] > 0) 
    nm <- c(nm, paste0("ar", 1:arma[1]))
  if (arma[2] > 0) 
    nm <- c(nm, paste0("ma", 1:arma[2]))
  if (arma[3] > 0) 
    nm <- c(nm, paste0("sar", 1:arma[3]))
  if (arma[4] > 0) 
    nm <- c(nm, paste0("sma", 1:arma[4]))
  fixed[mask] <- coef
  if (ncxreg > 0) {
    nm <- c(nm, cn)
    if (!orig.xreg) {
      ind <- narma + 1:ncxreg
      fixed[ind] <- S$v %*% fixed[ind]
      A <- diag(narma + ncxreg)
      A[ind, ind] <- S$v
      A <- A[mask, mask]
      var <- A %*% var %*% t(A)
    }
  }
  names(fixed) <- nm
  names(arma) <- c("ar", "ma", "sar", "sma", "period", "diff", "sdiff")
  dimnames(var) <- list(nm[mask], nm[mask])
  value <- 2 * n.used * res$value + n.used + n.used * log(2 * pi)
  aic <- if (method != "CSS") 
    value + 2 * length(coef) + 2
  else NA
  res <- list(coef = fixed, sigma2 = sigma2, var.coef = var, mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, residuals = resid, call = match.call(), series = series, code = code, n.cond = ncond)
  class(res) <- "arima0"
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
arima0.diag
list(`package:stats` = function (...) 
  .Defunct(), function (...) 
    .Defunct())
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ARMAacf
list(`package:stats` = function (ar = numeric(), ma = numeric(), lag.max = r, pacf = FALSE) 
{
  p <- length(ar)
  q <- length(ma)
  if (!p && !q) 
    stop("empty model supplied")
  r <- max(p, q + 1)
  if (p > 0) {
    if (r > 1) {
      if (r > p) {
        ar <- c(ar, rep(0, r - p))
        p <- r
      }
      p1 <- p + 1
      p2.1 <- p + p1
      A <- matrix(0, p1, p2.1)
      ind <- seq_len(p1)
      ind <- as.matrix(expand.grid(ind, ind))[, 2:1]
      ind[, 2] <- ind[, 1] + ind[, 2] - 1
      A[ind] <- c(1, -ar)
      A[, 1:p] <- A[, 1:p] + A[, p2.1:(p + 2)]
      rhs <- c(1, rep(0, p))
      if (q > 0) {
        psi <- c(1, ARMAtoMA(ar, ma, q))
        theta <- c(1, ma, rep(0, q + 1))
        for (k in 1 + 0:q) rhs[k] <- sum(psi * theta[k + 0:q])
      }
      ind <- p1:1
      Acf <- solve(A[ind, ind], rhs)
      Acf <- Acf[-1]/Acf[1]
    }
    else Acf <- ar
    if (lag.max > p) {
      xx <- rep(0, lag.max - p)
      Acf <- c(Acf, filter(xx, ar, "recursive", init = rev(Acf)))
    }
    Acf <- c(1, Acf[1:lag.max])
  }
  else if (q > 0) {
    x <- c(1, ma)
    Acf <- filter(c(x, rep(0, q)), rev(x), sides = 1)[-(1:q)]
    if (lag.max > q) 
      Acf <- c(Acf, rep(0, lag.max - q))
    Acf <- Acf/Acf[1]
  }
  names(Acf) <- 0:lag.max
  if (pacf) 
    drop(.Call(C_pacf1, Acf, lag.max))
  else Acf
}, function (ar = numeric(), ma = numeric(), lag.max = r, pacf = FALSE) 
{
  p <- length(ar)
  q <- length(ma)
  if (!p && !q) 
    stop("empty model supplied")
  r <- max(p, q + 1)
  if (p > 0) {
    if (r > 1) {
      if (r > p) {
        ar <- c(ar, rep(0, r - p))
        p <- r
      }
      p1 <- p + 1
      p2.1 <- p + p1
      A <- matrix(0, p1, p2.1)
      ind <- seq_len(p1)
      ind <- as.matrix(expand.grid(ind, ind))[, 2:1]
      ind[, 2] <- ind[, 1] + ind[, 2] - 1
      A[ind] <- c(1, -ar)
      A[, 1:p] <- A[, 1:p] + A[, p2.1:(p + 2)]
      rhs <- c(1, rep(0, p))
      if (q > 0) {
        psi <- c(1, ARMAtoMA(ar, ma, q))
        theta <- c(1, ma, rep(0, q + 1))
        for (k in 1 + 0:q) rhs[k] <- sum(psi * theta[k + 0:q])
      }
      ind <- p1:1
      Acf <- solve(A[ind, ind], rhs)
      Acf <- Acf[-1]/Acf[1]
    }
    else Acf <- ar
    if (lag.max > p) {
      xx <- rep(0, lag.max - p)
      Acf <- c(Acf, filter(xx, ar, "recursive", init = rev(Acf)))
    }
    Acf <- c(1, Acf[1:lag.max])
  }
  else if (q > 0) {
    x <- c(1, ma)
    Acf <- filter(c(x, rep(0, q)), rev(x), sides = 1)[-(1:q)]
    if (lag.max > q) 
      Acf <- c(Acf, rep(0, lag.max - q))
    Acf <- Acf/Acf[1]
  }
  names(Acf) <- 0:lag.max
  if (pacf) 
    drop(.Call(C_pacf1, Acf, lag.max))
  else Acf
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ARMAtoMA
list(`package:stats` = function (ar = numeric(), ma = numeric(), lag.max) 
  .Call(C_ARMAtoMA, as.double(ar), as.double(ma), as.integer(lag.max)), function (ar = numeric(), ma = numeric(), lag.max) 
    .Call(C_ARMAtoMA, as.double(ar), as.double(ma), as.integer(lag.max)))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.dendrogram
list(`package:stats` = function (object, ...) 
  UseMethod("as.dendrogram"), function (object, ...) 
    UseMethod("as.dendrogram"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.dist
list(`package:stats` = function (m, diag = FALSE, upper = FALSE) 
  UseMethod("as.dist"), function (m, diag = FALSE, upper = FALSE) 
    UseMethod("as.dist"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.formula
list(`package:stats` = function (object, env = parent.frame()) 
{
  if (inherits(object, "formula")) 
    object
  else {
    rval <- formula(object, env = baseenv())
    if (identical(environment(rval), baseenv()) || !missing(env)) 
      environment(rval) <- env
    rval
  }
}, function (object, env = parent.frame()) 
{
  if (inherits(object, "formula")) 
    object
  else {
    rval <- formula(object, env = baseenv())
    if (identical(environment(rval), baseenv()) || !missing(env)) 
      environment(rval) <- env
    rval
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.hclust
list(`package:stats` = function (x, ...) 
  UseMethod("as.hclust"), function (x, ...) 
    UseMethod("as.hclust"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.stepfun
list(`package:stats` = function (x, ...) 
  UseMethod("as.stepfun"), function (x, ...) 
    UseMethod("as.stepfun"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.ts
list(`package:stats` = function (x, ...) 
  UseMethod("as.ts"), function (x, ...) 
    UseMethod("as.ts"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
asOneSidedFormula
list(`package:stats` = function (object) 
{
  if ((mode(object) == "call") && (object[[1]] == "~") && !inherits(object, "formula")) {
    object <- eval(object)
    environment(object) <- .GlobalEnv
  }
  if (inherits(object, "formula")) {
    if (length(object) != 2) {
      stop(gettextf("formula '%s' must be of the form '~expr'", deparse1(object)), domain = NA)
    }
    return(object)
  }
  ff <- call("~", switch(mode(object), name = , numeric = , call = object, character = as.name(object), expression = object[[1]], stop(gettextf("'%s' cannot be of mode '%s'", substitute(object), mode(object)), domain = NA)))
  class(ff) <- "formula"
  environment(ff) <- .GlobalEnv
  ff
}, function (object) 
{
  if ((mode(object) == "call") && (object[[1]] == "~") && !inherits(object, "formula")) {
    object <- eval(object)
    environment(object) <- .GlobalEnv
  }
  if (inherits(object, "formula")) {
    if (length(object) != 2) {
      stop(gettextf("formula '%s' must be of the form '~expr'", deparse1(object)), domain = NA)
    }
    return(object)
  }
  ff <- call("~", switch(mode(object), name = , numeric = , call = object, character = as.name(object), expression = object[[1]], stop(gettextf("'%s' cannot be of mode '%s'", substitute(object), mode(object)), domain = NA)))
  class(ff) <- "formula"
  environment(ff) <- .GlobalEnv
  ff
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ave
list(`package:stats` = function (x, ..., FUN = mean) 
{
  if (missing(...)) 
    x[] <- FUN(x)
  else {
    g <- interaction(...)
    split(x, g) <- lapply(split(x, g), FUN)
  }
  x
}, function (x, ..., FUN = mean) 
{
  if (missing(...)) 
    x[] <- FUN(x)
  else {
    g <- interaction(...)
    split(x, g) <- lapply(split(x, g), FUN)
  }
  x
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
bandwidth.kernel
list(`package:stats` = function (k) 
{
  i <- -k$m:k$m
  sqrt(sum((1/12 + i^2) * k[i]))
}, function (k) 
{
  i <- -k$m:k$m
  sqrt(sum((1/12 + i^2) * k[i]))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
bartlett.test
list(`package:stats` = function (x, ...) 
  UseMethod("bartlett.test"), function (x, ...) 
    UseMethod("bartlett.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
BIC
list(`package:stats` = function (object, ...) 
  UseMethod("BIC"), function (object, ...) 
    UseMethod("BIC"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
binom.test
list(`package:stats` = function (x, n, p = 0.5, alternative = c("two.sided", "less", "greater"), conf.level = 0.95) 
{
  DNAME <- deparse1(substitute(x))
  xr <- round(x)
  if (any(is.na(x) | (x < 0)) || max(abs(x - xr)) > 1e-07) 
    stop("'x' must be nonnegative and integer")
  x <- xr
  if (length(x) == 2) {
    n <- sum(x)
    x <- x[1]
  }
  else if (length(x) == 1) {
    nr <- round(n)
    if ((length(n) > 1) || is.na(n) || (n < 1) || abs(n - nr) > 1e-07 || (x > nr)) 
      stop("'n' must be a positive integer >= 'x'")
    DNAME <- paste(DNAME, "and", deparse1(substitute(n)))
    n <- nr
  }
  else stop("incorrect length of 'x'")
  if (!missing(p) && (length(p) > 1 || is.na(p) || p < 0 || p > 1)) 
    stop("'p' must be a single number between 0 and 1")
  alternative <- match.arg(alternative)
  if (!((length(conf.level) == 1) && is.finite(conf.level) && (conf.level > 0) && (conf.level < 1))) 
    stop("'conf.level' must be a single number between 0 and 1")
  PVAL <- switch(alternative, less = pbinom(x, n, p), greater = pbinom(x - 1, n, p, lower.tail = FALSE), two.sided = {
    if (p == 0) (x == 0) else if (p == 1) (x == n) else {
      relErr <- 1 + 1e-07
      d <- dbinom(x, n, p)
      m <- n * p
      if (x == m) 1 else if (x < m) {
        i <- seq.int(from = ceiling(m), to = n)
        y <- sum(dbinom(i, n, p) <= d * relErr)
        pbinom(x, n, p) + pbinom(n - y, n, p, lower.tail = FALSE)
      } else {
        i <- seq.int(from = 0, to = floor(m))
        y <- sum(dbinom(i, n, p) <= d * relErr)
        pbinom(y - 1, n, p) + pbinom(x - 1, n, p, lower.tail = FALSE)
      }
    }
  })
  p.L <- function(x, alpha) {
    if (x == 0) 
      0
    else qbeta(alpha, x, n - x + 1)
  }
  p.U <- function(x, alpha) {
    if (x == n) 
      1
    else qbeta(1 - alpha, x + 1, n - x)
  }
  CINT <- switch(alternative, less = c(0, p.U(x, 1 - conf.level)), greater = c(p.L(x, 1 - conf.level), 1), two.sided = {
    alpha <- (1 - conf.level)/2
    c(p.L(x, alpha), p.U(x, alpha))
  })
  attr(CINT, "conf.level") <- conf.level
  ESTIMATE <- x/n
  names(x) <- "number of successes"
  names(n) <- "number of trials"
  names(ESTIMATE) <- names(p) <- "probability of success"
  structure(list(statistic = x, parameter = n, p.value = PVAL, conf.int = CINT, estimate = ESTIMATE, null.value = p, alternative = alternative, method = "Exact binomial test", data.name = DNAME), class = "htest")
}, function (x, n, p = 0.5, alternative = c("two.sided", "less", "greater"), conf.level = 0.95) 
{
  DNAME <- deparse1(substitute(x))
  xr <- round(x)
  if (any(is.na(x) | (x < 0)) || max(abs(x - xr)) > 1e-07) 
    stop("'x' must be nonnegative and integer")
  x <- xr
  if (length(x) == 2) {
    n <- sum(x)
    x <- x[1]
  }
  else if (length(x) == 1) {
    nr <- round(n)
    if ((length(n) > 1) || is.na(n) || (n < 1) || abs(n - nr) > 1e-07 || (x > nr)) 
      stop("'n' must be a positive integer >= 'x'")
    DNAME <- paste(DNAME, "and", deparse1(substitute(n)))
    n <- nr
  }
  else stop("incorrect length of 'x'")
  if (!missing(p) && (length(p) > 1 || is.na(p) || p < 0 || p > 1)) 
    stop("'p' must be a single number between 0 and 1")
  alternative <- match.arg(alternative)
  if (!((length(conf.level) == 1) && is.finite(conf.level) && (conf.level > 0) && (conf.level < 1))) 
    stop("'conf.level' must be a single number between 0 and 1")
  PVAL <- switch(alternative, less = pbinom(x, n, p), greater = pbinom(x - 1, n, p, lower.tail = FALSE), two.sided = {
    if (p == 0) (x == 0) else if (p == 1) (x == n) else {
      relErr <- 1 + 1e-07
      d <- dbinom(x, n, p)
      m <- n * p
      if (x == m) 1 else if (x < m) {
        i <- seq.int(from = ceiling(m), to = n)
        y <- sum(dbinom(i, n, p) <= d * relErr)
        pbinom(x, n, p) + pbinom(n - y, n, p, lower.tail = FALSE)
      } else {
        i <- seq.int(from = 0, to = floor(m))
        y <- sum(dbinom(i, n, p) <= d * relErr)
        pbinom(y - 1, n, p) + pbinom(x - 1, n, p, lower.tail = FALSE)
      }
    }
  })
  p.L <- function(x, alpha) {
    if (x == 0) 
      0
    else qbeta(alpha, x, n - x + 1)
  }
  p.U <- function(x, alpha) {
    if (x == n) 
      1
    else qbeta(1 - alpha, x + 1, n - x)
  }
  CINT <- switch(alternative, less = c(0, p.U(x, 1 - conf.level)), greater = c(p.L(x, 1 - conf.level), 1), two.sided = {
    alpha <- (1 - conf.level)/2
    c(p.L(x, alpha), p.U(x, alpha))
  })
  attr(CINT, "conf.level") <- conf.level
  ESTIMATE <- x/n
  names(x) <- "number of successes"
  names(n) <- "number of trials"
  names(ESTIMATE) <- names(p) <- "probability of success"
  structure(list(statistic = x, parameter = n, p.value = PVAL, conf.int = CINT, estimate = ESTIMATE, null.value = p, alternative = alternative, method = "Exact binomial test", data.name = DNAME), class = "htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
binomial
list(`package:stats` = function (link = "logit") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("logit", "probit", "cloglog", "cauchit", "log")
  family <- "binomial"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu * (1 - mu)
  validmu <- function(mu) all(is.finite(mu)) && all(mu > 0 & mu < 1)
  dev.resids <- function(y, mu, wt) .Call(C_binomial_dev_resids, y, mu, wt)
  aic <- function(y, n, mu, wt, dev) {
    m <- if (any(n > 1)) 
      n
    else wt
    -2 * sum(ifelse(m > 0, (wt/m), 0) * dbinom(round(m * y), round(m), mu, log = TRUE))
  }
  simfun <- function(object, nsim) {
    ftd <- fitted(object)
    n <- length(ftd)
    ntot <- n * nsim
    wts <- object$prior.weights
    if (any(wts%%1 != 0)) 
      stop("cannot simulate from non-integer prior.weights")
    if (!is.null(m <- object$model)) {
      y <- model.response(m)
      if (is.factor(y)) {
        yy <- factor(1 + rbinom(ntot, size = 1, prob = ftd), labels = levels(y))
        split(yy, rep(seq_len(nsim), each = n))
      }
      else if (is.matrix(y) && ncol(y) == 2) {
        yy <- vector("list", nsim)
        for (i in seq_len(nsim)) {
          Y <- rbinom(n, size = wts, prob = ftd)
          YY <- cbind(Y, wts - Y)
          colnames(YY) <- colnames(y)
          yy[[i]] <- YY
        }
        yy
      }
      else rbinom(ntot, size = wts, prob = ftd)/wts
    }
    else rbinom(ntot, size = wts, prob = ftd)/wts
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = binomInitialize(family), validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
}, function (link = "logit") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("logit", "probit", "cloglog", "cauchit", "log")
  family <- "binomial"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu * (1 - mu)
  validmu <- function(mu) all(is.finite(mu)) && all(mu > 0 & mu < 1)
  dev.resids <- function(y, mu, wt) .Call(C_binomial_dev_resids, y, mu, wt)
  aic <- function(y, n, mu, wt, dev) {
    m <- if (any(n > 1)) 
      n
    else wt
    -2 * sum(ifelse(m > 0, (wt/m), 0) * dbinom(round(m * y), round(m), mu, log = TRUE))
  }
  simfun <- function(object, nsim) {
    ftd <- fitted(object)
    n <- length(ftd)
    ntot <- n * nsim
    wts <- object$prior.weights
    if (any(wts%%1 != 0)) 
      stop("cannot simulate from non-integer prior.weights")
    if (!is.null(m <- object$model)) {
      y <- model.response(m)
      if (is.factor(y)) {
        yy <- factor(1 + rbinom(ntot, size = 1, prob = ftd), labels = levels(y))
        split(yy, rep(seq_len(nsim), each = n))
      }
      else if (is.matrix(y) && ncol(y) == 2) {
        yy <- vector("list", nsim)
        for (i in seq_len(nsim)) {
          Y <- rbinom(n, size = wts, prob = ftd)
          YY <- cbind(Y, wts - Y)
          colnames(YY) <- colnames(y)
          yy[[i]] <- YY
        }
        yy
      }
      else rbinom(ntot, size = wts, prob = ftd)/wts
    }
    else rbinom(ntot, size = wts, prob = ftd)/wts
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = binomInitialize(family), validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
biplot
list(`package:stats` = function (x, ...) 
  UseMethod("biplot"), function (x, ...) 
    UseMethod("biplot"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
Box.test
list(`package:stats` = function (x, lag = 1, type = c("Box-Pierce", "Ljung-Box"), fitdf = 0) 
{
  if (NCOL(x) > 1) 
    stop("x is not a vector or univariate time series")
  DNAME <- deparse1(substitute(x))
  type <- match.arg(type)
  cor <- acf(x, lag.max = lag, plot = FALSE, na.action = na.pass)
  n <- sum(!is.na(x))
  PARAMETER <- c(df = lag - fitdf)
  obs <- cor$acf[2:(lag + 1)]
  if (type == "Box-Pierce") {
    METHOD <- "Box-Pierce test"
    STATISTIC <- n * sum(obs^2)
    PVAL <- 1 - pchisq(STATISTIC, lag - fitdf)
  }
  else {
    METHOD <- "Box-Ljung test"
    STATISTIC <- n * (n + 2) * sum(1/seq.int(n - 1, n - lag) * obs^2)
    PVAL <- 1 - pchisq(STATISTIC, lag - fitdf)
  }
  names(STATISTIC) <- "X-squared"
  structure(list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME), class = "htest")
}, function (x, lag = 1, type = c("Box-Pierce", "Ljung-Box"), fitdf = 0) 
{
  if (NCOL(x) > 1) 
    stop("x is not a vector or univariate time series")
  DNAME <- deparse1(substitute(x))
  type <- match.arg(type)
  cor <- acf(x, lag.max = lag, plot = FALSE, na.action = na.pass)
  n <- sum(!is.na(x))
  PARAMETER <- c(df = lag - fitdf)
  obs <- cor$acf[2:(lag + 1)]
  if (type == "Box-Pierce") {
    METHOD <- "Box-Pierce test"
    STATISTIC <- n * sum(obs^2)
    PVAL <- 1 - pchisq(STATISTIC, lag - fitdf)
  }
  else {
    METHOD <- "Box-Ljung test"
    STATISTIC <- n * (n + 2) * sum(1/seq.int(n - 1, n - lag) * obs^2)
    PVAL <- 1 - pchisq(STATISTIC, lag - fitdf)
  }
  names(STATISTIC) <- "X-squared"
  structure(list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME), class = "htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
bw.bcv
list(`package:stats` = function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax, tol = 0.1 * lower) 
{
  if ((n <- length(x)) < 2) 
    stop("need at least 2 data points")
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid length(x)")
  if (!is.numeric(x)) 
    stop("invalid 'x'")
  nb <- as.integer(nb)
  if (is.na(nb) || nb <= 0) 
    stop("invalid 'nb'")
  storage.mode(x) <- "double"
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5)
  Z <- bw_pair_cnts(x, nb, n > nb/2)
  d <- Z[[1]]
  cnt <- Z[[2]]
  fbcv <- function(h) .Call(C_bw_bcv, n, d, cnt, h)
  h <- optimize(fbcv, c(lower, upper), tol = tol)$minimum
  if (h < lower + tol || h > upper - tol) 
    warning("minimum occurred at one end of the range")
  h
}, function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax, tol = 0.1 * lower) 
{
  if ((n <- length(x)) < 2) 
    stop("need at least 2 data points")
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid length(x)")
  if (!is.numeric(x)) 
    stop("invalid 'x'")
  nb <- as.integer(nb)
  if (is.na(nb) || nb <= 0) 
    stop("invalid 'nb'")
  storage.mode(x) <- "double"
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5)
  Z <- bw_pair_cnts(x, nb, n > nb/2)
  d <- Z[[1]]
  cnt <- Z[[2]]
  fbcv <- function(h) .Call(C_bw_bcv, n, d, cnt, h)
  h <- optimize(fbcv, c(lower, upper), tol = tol)$minimum
  if (h < lower + tol || h > upper - tol) 
    warning("minimum occurred at one end of the range")
  h
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
bw.nrd
list(`package:stats` = function (x) 
{
  if (length(x) < 2) 
    stop("need at least 2 data points")
  r <- quantile(x, c(0.25, 0.75))
  h <- (r[2] - r[1])/1.34
  1.06 * min(sqrt(var(x)), h) * length(x)^(-1/5)
}, function (x) 
{
  if (length(x) < 2) 
    stop("need at least 2 data points")
  r <- quantile(x, c(0.25, 0.75))
  h <- (r[2] - r[1])/1.34
  1.06 * min(sqrt(var(x)), h) * length(x)^(-1/5)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
bw.nrd0
list(`package:stats` = function (x) 
{
  if (length(x) < 2) 
    stop("need at least 2 data points")
  hi <- sd(x)
  if (!(lo <- min(hi, IQR(x)/1.34))) 
    (lo <- hi) || (lo <- abs(x[1])) || (lo <- 1)
  0.9 * lo * length(x)^(-0.2)
}, function (x) 
{
  if (length(x) < 2) 
    stop("need at least 2 data points")
  hi <- sd(x)
  if (!(lo <- min(hi, IQR(x)/1.34))) 
    (lo <- hi) || (lo <- abs(x[1])) || (lo <- 1)
  0.9 * lo * length(x)^(-0.2)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
bw.SJ
list(`package:stats` = function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax, method = c("ste", "dpi"), tol = 0.1 * lower) 
{
  if ((n <- length(x)) < 2) 
    stop("need at least 2 data points")
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid length(x)")
  if (!is.numeric(x)) 
    stop("invalid 'x'")
  nb <- as.integer(nb)
  if (is.na(nb) || nb <= 0) 
    stop("invalid 'nb'")
  storage.mode(x) <- "double"
  method <- match.arg(method)
  SDh <- function(h) .Call(C_bw_phi4, n, d, cnt, h)
  TDh <- function(h) .Call(C_bw_phi6, n, d, cnt, h)
  Z <- bw_pair_cnts(x, nb, n > nb/2)
  d <- Z[[1]]
  cnt <- Z[[2]]
  scale <- min(sd(x), IQR(x)/1.349)
  a <- 1.24 * scale * n^(-1/7)
  b <- 1.23 * scale * n^(-1/9)
  c1 <- 1/(2 * sqrt(pi) * n)
  TD <- -TDh(b)
  if (!is.finite(TD) || TD <= 0) 
    stop("sample is too sparse to find TD", domain = NA)
  if (method == "dpi") 
    res <- (c1/SDh((2.394/(n * TD))^(1/7)))^(1/5)
  else {
    if (bnd.Miss <- missing(lower) || missing(upper)) {
      hmax <- 1.144 * scale * n^(-1/5)
    }
    alph2 <- 1.357 * (SDh(a)/TD)^(1/7)
    if (!is.finite(alph2)) 
      stop("sample is too sparse to find alph2", domain = NA)
    itry <- 1
    fSD <- function(h) (c1/SDh(alph2 * h^(5/7)))^(1/5) - h
    while (fSD(lower) * fSD(upper) > 0) {
      if (itry > 99 || !bnd.Miss) 
        stop("no solution in the specified range of bandwidths")
      if (itry%%2) 
        upper <- upper * 1.2
      else lower <- lower/1.2
      if (getOption("verbose")) 
        message(gettextf("increasing bw.SJ() search interval (%d) to [%.4g,%.4g]", itry, lower, upper), domain = NA)
      itry <- itry + 1
    }
    res <- uniroot(fSD, c(lower, upper), tol = tol)$root
  }
  res
}, function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax, method = c("ste", "dpi"), tol = 0.1 * lower) 
{
  if ((n <- length(x)) < 2) 
    stop("need at least 2 data points")
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid length(x)")
  if (!is.numeric(x)) 
    stop("invalid 'x'")
  nb <- as.integer(nb)
  if (is.na(nb) || nb <= 0) 
    stop("invalid 'nb'")
  storage.mode(x) <- "double"
  method <- match.arg(method)
  SDh <- function(h) .Call(C_bw_phi4, n, d, cnt, h)
  TDh <- function(h) .Call(C_bw_phi6, n, d, cnt, h)
  Z <- bw_pair_cnts(x, nb, n > nb/2)
  d <- Z[[1]]
  cnt <- Z[[2]]
  scale <- min(sd(x), IQR(x)/1.349)
  a <- 1.24 * scale * n^(-1/7)
  b <- 1.23 * scale * n^(-1/9)
  c1 <- 1/(2 * sqrt(pi) * n)
  TD <- -TDh(b)
  if (!is.finite(TD) || TD <= 0) 
    stop("sample is too sparse to find TD", domain = NA)
  if (method == "dpi") 
    res <- (c1/SDh((2.394/(n * TD))^(1/7)))^(1/5)
  else {
    if (bnd.Miss <- missing(lower) || missing(upper)) {
      hmax <- 1.144 * scale * n^(-1/5)
    }
    alph2 <- 1.357 * (SDh(a)/TD)^(1/7)
    if (!is.finite(alph2)) 
      stop("sample is too sparse to find alph2", domain = NA)
    itry <- 1
    fSD <- function(h) (c1/SDh(alph2 * h^(5/7)))^(1/5) - h
    while (fSD(lower) * fSD(upper) > 0) {
      if (itry > 99 || !bnd.Miss) 
        stop("no solution in the specified range of bandwidths")
      if (itry%%2) 
        upper <- upper * 1.2
      else lower <- lower/1.2
      if (getOption("verbose")) 
        message(gettextf("increasing bw.SJ() search interval (%d) to [%.4g,%.4g]", itry, lower, upper), domain = NA)
      itry <- itry + 1
    }
    res <- uniroot(fSD, c(lower, upper), tol = tol)$root
  }
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
bw.ucv
list(`package:stats` = function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax, tol = 0.1 * lower) 
{
  if ((n <- length(x)) < 2) 
    stop("need at least 2 data points")
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid length(x)")
  if (!is.numeric(x)) 
    stop("invalid 'x'")
  nb <- as.integer(nb)
  if (is.na(nb) || nb <= 0) 
    stop("invalid 'nb'")
  storage.mode(x) <- "double"
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5)
  Z <- bw_pair_cnts(x, nb, n > nb/2)
  d <- Z[[1]]
  cnt <- Z[[2]]
  fucv <- function(h) .Call(C_bw_ucv, n, d, cnt, h)
  h <- optimize(fucv, c(lower, upper), tol = tol)$minimum
  if (h < lower + tol || h > upper - tol) 
    warning("minimum occurred at one end of the range")
  h
}, function (x, nb = 1000, lower = 0.1 * hmax, upper = hmax, tol = 0.1 * lower) 
{
  if ((n <- length(x)) < 2) 
    stop("need at least 2 data points")
  n <- as.integer(n)
  if (is.na(n)) 
    stop("invalid length(x)")
  if (!is.numeric(x)) 
    stop("invalid 'x'")
  nb <- as.integer(nb)
  if (is.na(nb) || nb <= 0) 
    stop("invalid 'nb'")
  storage.mode(x) <- "double"
  hmax <- 1.144 * sqrt(var(x)) * n^(-1/5)
  Z <- bw_pair_cnts(x, nb, n > nb/2)
  d <- Z[[1]]
  cnt <- Z[[2]]
  fucv <- function(h) .Call(C_bw_ucv, n, d, cnt, h)
  h <- optimize(fucv, c(lower, upper), tol = tol)$minimum
  if (h < lower + tol || h > upper - tol) 
    warning("minimum occurred at one end of the range")
  h
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
C
list(`package:stats` = function (object, contr, how.many, ...) 
{
  if (isFALSE(as.logical(Sys.getenv("_R_OPTIONS_STRINGS_AS_FACTORS_")))) 
    object <- as.factor(object)
  if (!nlevels(object)) 
    stop("object not interpretable as a factor")
  if (!missing(contr) && is.name(Xcontr <- substitute(contr))) 
    contr <- switch(as.character(Xcontr), poly = "contr.poly", helmert = "contr.helmert", sum = "contr.sum", treatment = "contr.treatment", SAS = "contr.SAS", contr)
  if (missing(contr)) {
    oc <- getOption("contrasts")
    contr <- if (length(oc) < 2) 
      if (is.ordered(object)) 
        contr.poly
    else contr.treatment
    else oc[1 + is.ordered(object)]
  }
  if (missing(how.many) && missing(...)) 
    contrasts(object) <- contr
  else {
    if (is.character(contr)) 
      contr <- get(contr, mode = "function")
    if (is.function(contr)) 
      contr <- contr(nlevels(object), ...)
    contrasts(object, how.many) <- contr
  }
  object
}, function (object, contr, how.many, ...) 
{
  if (isFALSE(as.logical(Sys.getenv("_R_OPTIONS_STRINGS_AS_FACTORS_")))) 
    object <- as.factor(object)
  if (!nlevels(object)) 
    stop("object not interpretable as a factor")
  if (!missing(contr) && is.name(Xcontr <- substitute(contr))) 
    contr <- switch(as.character(Xcontr), poly = "contr.poly", helmert = "contr.helmert", sum = "contr.sum", treatment = "contr.treatment", SAS = "contr.SAS", contr)
  if (missing(contr)) {
    oc <- getOption("contrasts")
    contr <- if (length(oc) < 2) 
      if (is.ordered(object)) 
        contr.poly
    else contr.treatment
    else oc[1 + is.ordered(object)]
  }
  if (missing(how.many) && missing(...)) 
    contrasts(object) <- contr
  else {
    if (is.character(contr)) 
      contr <- get(contr, mode = "function")
    if (is.function(contr)) 
      contr <- contr(nlevels(object), ...)
    contrasts(object, how.many) <- contr
  }
  object
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cancor
list(`package:stats` = function (x, y, xcenter = TRUE, ycenter = TRUE) 
{
  x <- as.matrix(x)
  y <- as.matrix(y)
  if ((nr <- nrow(x)) != nrow(y)) 
    stop("unequal number of rows in 'cancor'")
  ncx <- ncol(x)
  ncy <- ncol(y)
  if (!nr || !ncx || !ncy) 
    stop("dimension 0 in 'x' or 'y'")
  if (is.logical(xcenter)) {
    if (xcenter) {
      xcenter <- colMeans(x, )
      x <- x - rep(xcenter, rep.int(nr, ncx))
    }
    else xcenter <- rep.int(0, ncx)
  }
  else {
    xcenter <- rep_len(xcenter, ncx)
    x <- x - rep(xcenter, rep.int(nr, ncx))
  }
  if (is.logical(ycenter)) {
    if (ycenter) {
      ycenter <- colMeans(y)
      y <- y - rep(ycenter, rep.int(nr, ncy))
    }
    else ycenter <- rep.int(0, ncy)
  }
  else {
    ycenter <- rep_len(ycenter, ncy)
    y <- y - rep(ycenter, rep.int(nr, ncy))
  }
  qx <- qr(x)
  qy <- qr(y)
  dx <- qx$rank
  if (!dx) 
    stop("'x' has rank 0")
  dy <- qy$rank
  if (!dy) 
    stop("'y' has rank 0")
  z <- svd(qr.qty(qx, qr.qy(qy, diag(1, nr, dy)))[1:dx, , drop = FALSE], dx, dy)
  xcoef <- backsolve((qx$qr)[1:dx, 1:dx, drop = FALSE], z$u)
  rownames(xcoef) <- colnames(x)[qx$pivot][1:dx]
  ycoef <- backsolve((qy$qr)[1:dy, 1:dy, drop = FALSE], z$v)
  rownames(ycoef) <- colnames(y)[qy$pivot][1:dy]
  list(cor = z$d, xcoef = xcoef, ycoef = ycoef, xcenter = xcenter, ycenter = ycenter)
}, function (x, y, xcenter = TRUE, ycenter = TRUE) 
{
  x <- as.matrix(x)
  y <- as.matrix(y)
  if ((nr <- nrow(x)) != nrow(y)) 
    stop("unequal number of rows in 'cancor'")
  ncx <- ncol(x)
  ncy <- ncol(y)
  if (!nr || !ncx || !ncy) 
    stop("dimension 0 in 'x' or 'y'")
  if (is.logical(xcenter)) {
    if (xcenter) {
      xcenter <- colMeans(x, )
      x <- x - rep(xcenter, rep.int(nr, ncx))
    }
    else xcenter <- rep.int(0, ncx)
  }
  else {
    xcenter <- rep_len(xcenter, ncx)
    x <- x - rep(xcenter, rep.int(nr, ncx))
  }
  if (is.logical(ycenter)) {
    if (ycenter) {
      ycenter <- colMeans(y)
      y <- y - rep(ycenter, rep.int(nr, ncy))
    }
    else ycenter <- rep.int(0, ncy)
  }
  else {
    ycenter <- rep_len(ycenter, ncy)
    y <- y - rep(ycenter, rep.int(nr, ncy))
  }
  qx <- qr(x)
  qy <- qr(y)
  dx <- qx$rank
  if (!dx) 
    stop("'x' has rank 0")
  dy <- qy$rank
  if (!dy) 
    stop("'y' has rank 0")
  z <- svd(qr.qty(qx, qr.qy(qy, diag(1, nr, dy)))[1:dx, , drop = FALSE], dx, dy)
  xcoef <- backsolve((qx$qr)[1:dx, 1:dx, drop = FALSE], z$u)
  rownames(xcoef) <- colnames(x)[qx$pivot][1:dx]
  ycoef <- backsolve((qy$qr)[1:dy, 1:dy, drop = FALSE], z$v)
  rownames(ycoef) <- colnames(y)[qy$pivot][1:dy]
  list(cor = z$d, xcoef = xcoef, ycoef = ycoef, xcenter = xcenter, ycenter = ycenter)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
case.names
list(`package:stats` = function (object, ...) 
  UseMethod("case.names"), function (object, ...) 
    UseMethod("case.names"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ccf
list(`package:stats` = function (x, y, lag.max = NULL, type = c("correlation", "covariance"), plot = TRUE, na.action = na.fail, ...) 
{
  type <- match.arg(type)
  if (is.matrix(x) || is.matrix(y)) 
    stop("univariate time series only")
  X <- ts.intersect(as.ts(x), as.ts(y))
  colnames(X) <- c(deparse(substitute(x))[1], deparse(substitute(y))[1])
  acf.out <- acf(X, lag.max = lag.max, plot = FALSE, type = type, na.action = na.action)
  lag <- c(rev(acf.out$lag[-1, 2, 1]), acf.out$lag[, 1, 2])
  y <- c(rev(acf.out$acf[-1, 2, 1]), acf.out$acf[, 1, 2])
  acf.out$acf <- array(y, dim = c(length(y), 1, 1))
  acf.out$lag <- array(lag, dim = c(length(y), 1, 1))
  acf.out$snames <- paste(acf.out$snames, collapse = " & ")
  if (plot) {
    plot(acf.out, ...)
    return(invisible(acf.out))
  }
  else return(acf.out)
}, function (x, y, lag.max = NULL, type = c("correlation", "covariance"), plot = TRUE, na.action = na.fail, ...) 
{
  type <- match.arg(type)
  if (is.matrix(x) || is.matrix(y)) 
    stop("univariate time series only")
  X <- ts.intersect(as.ts(x), as.ts(y))
  colnames(X) <- c(deparse(substitute(x))[1], deparse(substitute(y))[1])
  acf.out <- acf(X, lag.max = lag.max, plot = FALSE, type = type, na.action = na.action)
  lag <- c(rev(acf.out$lag[-1, 2, 1]), acf.out$lag[, 1, 2])
  y <- c(rev(acf.out$acf[-1, 2, 1]), acf.out$acf[, 1, 2])
  acf.out$acf <- array(y, dim = c(length(y), 1, 1))
  acf.out$lag <- array(lag, dim = c(length(y), 1, 1))
  acf.out$snames <- paste(acf.out$snames, collapse = " & ")
  if (plot) {
    plot(acf.out, ...)
    return(invisible(acf.out))
  }
  else return(acf.out)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
chisq.test
list(`package:stats` = function (x, y = NULL, correct = TRUE, p = rep(1/length(x), length(x)), rescale.p = FALSE, simulate.p.value = FALSE, B = 2000) 
{
  DNAME <- deparse(substitute(x))
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (is.matrix(x)) {
    if (min(dim(x)) == 1) 
      x <- as.vector(x)
  }
  if (!is.matrix(x) && !is.null(y)) {
    if (length(x) != length(y)) 
      stop("'x' and 'y' must have the same length")
    DNAME2 <- deparse(substitute(y))
    xname <- if (length(DNAME) > 1 || nchar(DNAME, "w") > 30) 
      ""
    else DNAME
    yname <- if (length(DNAME2) > 1 || nchar(DNAME2, "w") > 30) 
      ""
    else DNAME2
    OK <- complete.cases(x, y)
    x <- factor(x[OK])
    y <- factor(y[OK])
    if ((nlevels(x) < 2) || (nlevels(y) < 2)) 
      stop("'x' and 'y' must have at least 2 levels")
    x <- table(x, y)
    names(dimnames(x)) <- c(xname, yname)
    DNAME <- paste(paste(DNAME, collapse = "\n"), "and", paste(DNAME2, collapse = "\n"))
  }
  if (any(x < 0) || anyNA(x)) 
    stop("all entries of 'x' must be nonnegative and finite")
  if ((n <- sum(x)) == 0) 
    stop("at least one entry of 'x' must be positive")
  if (simulate.p.value) {
    setMETH <- function() METHOD <<- paste(METHOD, "with simulated p-value\n\t (based on", B, "replicates)")
    almost.1 <- 1 - 64 * .Machine$double.eps
  }
  if (is.matrix(x)) {
    METHOD <- "Pearson's Chi-squared test"
    nr <- as.integer(nrow(x))
    nc <- as.integer(ncol(x))
    if (is.na(nr) || is.na(nc) || is.na(nr * nc)) 
      stop("invalid nrow(x) or ncol(x)", domain = NA)
    sr <- rowSums(x)
    sc <- colSums(x)
    E <- outer(sr, sc)/n
    v <- function(r, c, n) c * r * (n - r) * (n - c)/n^3
    V <- outer(sr, sc, v, n)
    dimnames(E) <- dimnames(x)
    if (simulate.p.value && all(sr > 0) && all(sc > 0)) {
      setMETH()
      tmp <- .Call(C_chisq_sim, sr, sc, B, E)
      STATISTIC <- sum(sort((x - E)^2/E, decreasing = TRUE))
      PARAMETER <- NA
      PVAL <- (1 + sum(tmp >= almost.1 * STATISTIC))/(B + 1)
    }
    else {
      if (simulate.p.value) 
        warning("cannot compute simulated p-value with zero marginals")
      if (correct && nrow(x) == 2 && ncol(x) == 2) {
        YATES <- min(0.5, abs(x - E))
        if (YATES > 0) 
          METHOD <- paste(METHOD, "with Yates' continuity correction")
      }
      else YATES <- 0
      STATISTIC <- sum((abs(x - E) - YATES)^2/E)
      PARAMETER <- (nr - 1) * (nc - 1)
      PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    }
  }
  else {
    if (length(dim(x)) > 2) 
      stop("invalid 'x'")
    if (length(x) == 1) 
      stop("'x' must at least have 2 elements")
    if (length(x) != length(p)) 
      stop("'x' and 'p' must have the same number of elements")
    if (any(p < 0)) 
      stop("probabilities must be non-negative.")
    if (abs(sum(p) - 1) > sqrt(.Machine$double.eps)) {
      if (rescale.p) 
        p <- p/sum(p)
      else stop("probabilities must sum to 1.")
    }
    METHOD <- "Chi-squared test for given probabilities"
    E <- n * p
    V <- n * p * (1 - p)
    STATISTIC <- sum((x - E)^2/E)
    names(E) <- names(x)
    if (simulate.p.value) {
      setMETH()
      nx <- length(x)
      sm <- matrix(sample.int(nx, B * n, TRUE, prob = p), nrow = n)
      ss <- apply(sm, 2, function(x, E, k) {
        sum((table(factor(x, levels = 1:k)) - E)^2/E)
      }, E = E, k = nx)
      PARAMETER <- NA
      PVAL <- (1 + sum(ss >= almost.1 * STATISTIC))/(B + 1)
    }
    else {
      PARAMETER <- length(x) - 1
      PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    }
  }
  names(STATISTIC) <- "X-squared"
  names(PARAMETER) <- "df"
  if (any(E < 5) && is.finite(PARAMETER)) 
    warning("Chi-squared approximation may be incorrect")
  structure(list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME, observed = x, expected = E, residuals = (x - E)/sqrt(E), stdres = (x - E)/sqrt(V)), class = "htest")
}, function (x, y = NULL, correct = TRUE, p = rep(1/length(x), length(x)), rescale.p = FALSE, simulate.p.value = FALSE, B = 2000) 
{
  DNAME <- deparse(substitute(x))
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (is.matrix(x)) {
    if (min(dim(x)) == 1) 
      x <- as.vector(x)
  }
  if (!is.matrix(x) && !is.null(y)) {
    if (length(x) != length(y)) 
      stop("'x' and 'y' must have the same length")
    DNAME2 <- deparse(substitute(y))
    xname <- if (length(DNAME) > 1 || nchar(DNAME, "w") > 30) 
      ""
    else DNAME
    yname <- if (length(DNAME2) > 1 || nchar(DNAME2, "w") > 30) 
      ""
    else DNAME2
    OK <- complete.cases(x, y)
    x <- factor(x[OK])
    y <- factor(y[OK])
    if ((nlevels(x) < 2) || (nlevels(y) < 2)) 
      stop("'x' and 'y' must have at least 2 levels")
    x <- table(x, y)
    names(dimnames(x)) <- c(xname, yname)
    DNAME <- paste(paste(DNAME, collapse = "\n"), "and", paste(DNAME2, collapse = "\n"))
  }
  if (any(x < 0) || anyNA(x)) 
    stop("all entries of 'x' must be nonnegative and finite")
  if ((n <- sum(x)) == 0) 
    stop("at least one entry of 'x' must be positive")
  if (simulate.p.value) {
    setMETH <- function() METHOD <<- paste(METHOD, "with simulated p-value\n\t (based on", B, "replicates)")
    almost.1 <- 1 - 64 * .Machine$double.eps
  }
  if (is.matrix(x)) {
    METHOD <- "Pearson's Chi-squared test"
    nr <- as.integer(nrow(x))
    nc <- as.integer(ncol(x))
    if (is.na(nr) || is.na(nc) || is.na(nr * nc)) 
      stop("invalid nrow(x) or ncol(x)", domain = NA)
    sr <- rowSums(x)
    sc <- colSums(x)
    E <- outer(sr, sc)/n
    v <- function(r, c, n) c * r * (n - r) * (n - c)/n^3
    V <- outer(sr, sc, v, n)
    dimnames(E) <- dimnames(x)
    if (simulate.p.value && all(sr > 0) && all(sc > 0)) {
      setMETH()
      tmp <- .Call(C_chisq_sim, sr, sc, B, E)
      STATISTIC <- sum(sort((x - E)^2/E, decreasing = TRUE))
      PARAMETER <- NA
      PVAL <- (1 + sum(tmp >= almost.1 * STATISTIC))/(B + 1)
    }
    else {
      if (simulate.p.value) 
        warning("cannot compute simulated p-value with zero marginals")
      if (correct && nrow(x) == 2 && ncol(x) == 2) {
        YATES <- min(0.5, abs(x - E))
        if (YATES > 0) 
          METHOD <- paste(METHOD, "with Yates' continuity correction")
      }
      else YATES <- 0
      STATISTIC <- sum((abs(x - E) - YATES)^2/E)
      PARAMETER <- (nr - 1) * (nc - 1)
      PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    }
  }
  else {
    if (length(dim(x)) > 2) 
      stop("invalid 'x'")
    if (length(x) == 1) 
      stop("'x' must at least have 2 elements")
    if (length(x) != length(p)) 
      stop("'x' and 'p' must have the same number of elements")
    if (any(p < 0)) 
      stop("probabilities must be non-negative.")
    if (abs(sum(p) - 1) > sqrt(.Machine$double.eps)) {
      if (rescale.p) 
        p <- p/sum(p)
      else stop("probabilities must sum to 1.")
    }
    METHOD <- "Chi-squared test for given probabilities"
    E <- n * p
    V <- n * p * (1 - p)
    STATISTIC <- sum((x - E)^2/E)
    names(E) <- names(x)
    if (simulate.p.value) {
      setMETH()
      nx <- length(x)
      sm <- matrix(sample.int(nx, B * n, TRUE, prob = p), nrow = n)
      ss <- apply(sm, 2, function(x, E, k) {
        sum((table(factor(x, levels = 1:k)) - E)^2/E)
      }, E = E, k = nx)
      PARAMETER <- NA
      PVAL <- (1 + sum(ss >= almost.1 * STATISTIC))/(B + 1)
    }
    else {
      PARAMETER <- length(x) - 1
      PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    }
  }
  names(STATISTIC) <- "X-squared"
  names(PARAMETER) <- "df"
  if (any(E < 5) && is.finite(PARAMETER)) 
    warning("Chi-squared approximation may be incorrect")
  structure(list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME, observed = x, expected = E, residuals = (x - E)/sqrt(E), stdres = (x - E)/sqrt(V)), class = "htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cmdscale
list(`package:stats` = function (d, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE, list. = eig || add || x.ret) 
{
  if (anyNA(d)) 
    stop("NA values not allowed in 'd'")
  if (!list.) {
    if (eig) 
      warning("eig=TRUE is disregarded when list.=FALSE")
    if (x.ret) 
      warning("x.ret=TRUE is disregarded when list.=FALSE")
  }
  if (is.null(n <- attr(d, "Size"))) {
    if (add) 
      d <- as.matrix(d)
    x <- as.matrix(d^2)
    storage.mode(x) <- "double"
    if ((n <- nrow(x)) != ncol(x)) 
      stop("distances must be result of 'dist' or a square matrix")
    rn <- rownames(x)
  }
  else {
    rn <- attr(d, "Labels")
    x <- matrix(0, n, n)
    if (add) 
      d0 <- x
    x[row(x) > col(x)] <- d^2
    x <- x + t(x)
    if (add) {
      d0[row(x) > col(x)] <- d
      d <- d0 + t(d0)
    }
  }
  n <- as.integer(n)
  if (is.na(n) || n > 46340) 
    stop(gettextf("invalid value of %s", "'n'"), domain = NA)
  if ((k <- as.integer(k)) > n - 1 || k < 1) 
    stop("'k' must be in {1, 2, ..  n - 1}")
  x <- .Call(C_DoubleCentre, x)
  if (add) {
    i2 <- n + (i <- 1:n)
    Z <- matrix(0, 2 * n, 2 * n)
    Z[cbind(i2, i)] <- -1
    Z[i, i2] <- -x
    Z[i2, i2] <- .Call(C_DoubleCentre, 2 * d)
    e <- eigen(Z, symmetric = FALSE, only.values = TRUE)$values
    add.c <- max(Re(e))
    x <- matrix(double(n * n), n, n)
    non.diag <- row(d) != col(d)
    x[non.diag] <- (d[non.diag] + add.c)^2
    x <- .Call(C_DoubleCentre, x)
  }
  e <- eigen(-x/2, symmetric = TRUE)
  ev <- e$values[seq_len(k)]
  evec <- e$vectors[, seq_len(k), drop = FALSE]
  k1 <- sum(ev > 0)
  if (k1 < k) {
    warning(gettextf("only %d of the first %d eigenvalues are > 0", k1, k), domain = NA)
    evec <- evec[, ev > 0, drop = FALSE]
    ev <- ev[ev > 0]
  }
  points <- evec * rep(sqrt(ev), each = n)
  dimnames(points) <- list(rn, NULL)
  if (list.) {
    evalus <- e$values
    list(points = points, eig = if (eig) evalus, x = if (x.ret) x, ac = if (add) add.c else 0, GOF = sum(ev)/c(sum(abs(evalus)), sum(pmax(evalus, 0))))
  }
  else points
}, function (d, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE, list. = eig || add || x.ret) 
{
  if (anyNA(d)) 
    stop("NA values not allowed in 'd'")
  if (!list.) {
    if (eig) 
      warning("eig=TRUE is disregarded when list.=FALSE")
    if (x.ret) 
      warning("x.ret=TRUE is disregarded when list.=FALSE")
  }
  if (is.null(n <- attr(d, "Size"))) {
    if (add) 
      d <- as.matrix(d)
    x <- as.matrix(d^2)
    storage.mode(x) <- "double"
    if ((n <- nrow(x)) != ncol(x)) 
      stop("distances must be result of 'dist' or a square matrix")
    rn <- rownames(x)
  }
  else {
    rn <- attr(d, "Labels")
    x <- matrix(0, n, n)
    if (add) 
      d0 <- x
    x[row(x) > col(x)] <- d^2
    x <- x + t(x)
    if (add) {
      d0[row(x) > col(x)] <- d
      d <- d0 + t(d0)
    }
  }
  n <- as.integer(n)
  if (is.na(n) || n > 46340) 
    stop(gettextf("invalid value of %s", "'n'"), domain = NA)
  if ((k <- as.integer(k)) > n - 1 || k < 1) 
    stop("'k' must be in {1, 2, ..  n - 1}")
  x <- .Call(C_DoubleCentre, x)
  if (add) {
    i2 <- n + (i <- 1:n)
    Z <- matrix(0, 2 * n, 2 * n)
    Z[cbind(i2, i)] <- -1
    Z[i, i2] <- -x
    Z[i2, i2] <- .Call(C_DoubleCentre, 2 * d)
    e <- eigen(Z, symmetric = FALSE, only.values = TRUE)$values
    add.c <- max(Re(e))
    x <- matrix(double(n * n), n, n)
    non.diag <- row(d) != col(d)
    x[non.diag] <- (d[non.diag] + add.c)^2
    x <- .Call(C_DoubleCentre, x)
  }
  e <- eigen(-x/2, symmetric = TRUE)
  ev <- e$values[seq_len(k)]
  evec <- e$vectors[, seq_len(k), drop = FALSE]
  k1 <- sum(ev > 0)
  if (k1 < k) {
    warning(gettextf("only %d of the first %d eigenvalues are > 0", k1, k), domain = NA)
    evec <- evec[, ev > 0, drop = FALSE]
    ev <- ev[ev > 0]
  }
  points <- evec * rep(sqrt(ev), each = n)
  dimnames(points) <- list(rn, NULL)
  if (list.) {
    evalus <- e$values
    list(points = points, eig = if (eig) evalus, x = if (x.ret) x, ac = if (add) add.c else 0, GOF = sum(ev)/c(sum(abs(evalus)), sum(pmax(evalus, 0))))
  }
  else points
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
coef
list(`package:stats` = function (object, ...) 
  UseMethod("coef"), function (object, ...) 
    UseMethod("coef"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
coefficients
list(`package:stats` = function (object, ...) 
  UseMethod("coef"), function (object, ...) 
    UseMethod("coef"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
complete.cases
list(`package:stats` = function (...) 
  .External(C_compcases, ...), function (...) 
    .External(C_compcases, ...))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
confint
list(`package:stats` = function (object, parm, level = 0.95, ...) 
  UseMethod("confint"), function (object, parm, level = 0.95, ...) 
    UseMethod("confint"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
confint.default
list(`package:stats` = function (object, parm, level = 0.95, ...) 
{
  cf <- coef(object)
  pnames <- names(cf)
  if (missing(parm)) 
    parm <- pnames
  else if (is.numeric(parm)) 
    parm <- pnames[parm]
  a <- (1 - level)/2
  a <- c(a, 1 - a)
  pct <- format.perc(a, 3)
  fac <- qnorm(a)
  ci <- array(NA, dim = c(length(parm), 2), dimnames = list(parm, pct))
  ses <- sqrt(diag(vcov(object)))[parm]
  ci[] <- cf[parm] + ses %o% fac
  ci
}, function (object, parm, level = 0.95, ...) 
{
  cf <- coef(object)
  pnames <- names(cf)
  if (missing(parm)) 
    parm <- pnames
  else if (is.numeric(parm)) 
    parm <- pnames[parm]
  a <- (1 - level)/2
  a <- c(a, 1 - a)
  pct <- format.perc(a, 3)
  fac <- qnorm(a)
  ci <- array(NA, dim = c(length(parm), 2), dimnames = list(parm, pct))
  ses <- sqrt(diag(vcov(object)))[parm]
  ci[] <- cf[parm] + ses %o% fac
  ci
}, function (object, parm, level = 0.95, ...) 
{
  cf <- coef(object)
  pnames <- names(cf)
  if (missing(parm)) 
    parm <- pnames
  else if (is.numeric(parm)) 
    parm <- pnames[parm]
  a <- (1 - level)/2
  a <- c(a, 1 - a)
  pct <- format.perc(a, 3)
  fac <- qnorm(a)
  ci <- array(NA, dim = c(length(parm), 2), dimnames = list(parm, pct))
  ses <- sqrt(diag(vcov(object)))[parm]
  ci[] <- cf[parm] + ses %o% fac
  ci
})
c("package:stats", "registered S3 method for confint from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
confint.lm
list(`package:stats` = function (object, parm, level = 0.95, ...) 
{
  cf <- coef(object)
  ses <- sqrt(diag(vcov(object)))
  pnames <- names(ses)
  if (is.matrix(cf)) 
    cf <- setNames(as.vector(cf), pnames)
  if (missing(parm)) 
    parm <- pnames
  else if (is.numeric(parm)) 
    parm <- pnames[parm]
  a <- (1 - level)/2
  a <- c(a, 1 - a)
  fac <- qt(a, object$df.residual)
  pct <- format.perc(a, 3)
  ci <- array(NA, dim = c(length(parm), 2), dimnames = list(parm, pct))
  ci[] <- cf[parm] + ses[parm] %o% fac
  ci
}, function (object, parm, level = 0.95, ...) 
{
  cf <- coef(object)
  ses <- sqrt(diag(vcov(object)))
  pnames <- names(ses)
  if (is.matrix(cf)) 
    cf <- setNames(as.vector(cf), pnames)
  if (missing(parm)) 
    parm <- pnames
  else if (is.numeric(parm)) 
    parm <- pnames[parm]
  a <- (1 - level)/2
  a <- c(a, 1 - a)
  fac <- qt(a, object$df.residual)
  pct <- format.perc(a, 3)
  ci <- array(NA, dim = c(length(parm), 2), dimnames = list(parm, pct))
  ci[] <- cf[parm] + ses[parm] %o% fac
  ci
}, function (object, parm, level = 0.95, ...) 
{
  cf <- coef(object)
  ses <- sqrt(diag(vcov(object)))
  pnames <- names(ses)
  if (is.matrix(cf)) 
    cf <- setNames(as.vector(cf), pnames)
  if (missing(parm)) 
    parm <- pnames
  else if (is.numeric(parm)) 
    parm <- pnames[parm]
  a <- (1 - level)/2
  a <- c(a, 1 - a)
  fac <- qt(a, object$df.residual)
  pct <- format.perc(a, 3)
  ci <- array(NA, dim = c(length(parm), 2), dimnames = list(parm, pct))
  ci[] <- cf[parm] + ses[parm] %o% fac
  ci
})
c("package:stats", "registered S3 method for confint from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
constrOptim
list(`package:stats` = function (theta, f, grad, ui, ci, mu = 1e-04, control = list(), method = if (is.null(grad)) "Nelder-Mead" else "BFGS", outer.iterations = 100, outer.eps = 1e-05, ..., hessian = FALSE) 
{
  if (!is.null(control$fnscale) && control$fnscale < 0) 
    mu <- -mu
  R <- function(theta, theta.old, ...) {
    ui.theta <- ui %*% theta
    gi <- ui.theta - ci
    if (any(gi < 0)) 
      return(NaN)
    gi.old <- ui %*% theta.old - ci
    bar <- sum(gi.old * log(gi) - ui.theta)
    if (!is.finite(bar)) 
      bar <- -Inf
    f(theta, ...) - mu * bar
  }
  dR <- function(theta, theta.old, ...) {
    ui.theta <- ui %*% theta
    gi <- drop(ui.theta - ci)
    gi.old <- drop(ui %*% theta.old - ci)
    dbar <- colSums(ui * gi.old/gi - ui)
    grad(theta, ...) - mu * dbar
  }
  if (any(ui %*% theta - ci <= 0)) 
    stop("initial value is not in the interior of the feasible region")
  obj <- f(theta, ...)
  r <- R(theta, theta, ...)
  fun <- function(theta, ...) R(theta, theta.old, ...)
  gradient <- if (method == "SANN") {
    if (missing(grad)) 
      NULL
    else grad
  }
  else function(theta, ...) dR(theta, theta.old, ...)
  totCounts <- 0
  s.mu <- sign(mu)
  for (i in seq_len(outer.iterations)) {
    obj.old <- obj
    r.old <- r
    theta.old <- theta
    a <- optim(theta.old, fun, gradient, control = control, method = method, hessian = hessian, ...)
    r <- a$value
    if (is.finite(r) && is.finite(r.old) && abs(r - r.old) < (0.001 + abs(r)) * outer.eps) 
      break
    theta <- a$par
    totCounts <- totCounts + a$counts
    obj <- f(theta, ...)
    if (s.mu * obj > s.mu * obj.old) 
      break
  }
  if (i == outer.iterations) {
    a$convergence <- 7
    a$message <- gettext("Barrier algorithm ran out of iterations and did not converge")
  }
  if (mu > 0 && obj > obj.old) {
    a$convergence <- 11
    a$message <- gettextf("Objective function increased at outer iteration %d", i)
  }
  if (mu < 0 && obj < obj.old) {
    a$convergence <- 11
    a$message <- gettextf("Objective function decreased at outer iteration %d", i)
  }
  a$outer.iterations <- i
  a$counts <- totCounts
  a$barrier.value <- a$value
  a$value <- f(a$par, ...)
  a$barrier.value <- a$barrier.value - a$value
  a
}, function (theta, f, grad, ui, ci, mu = 1e-04, control = list(), method = if (is.null(grad)) "Nelder-Mead" else "BFGS", outer.iterations = 100, outer.eps = 1e-05, ..., hessian = FALSE) 
{
  if (!is.null(control$fnscale) && control$fnscale < 0) 
    mu <- -mu
  R <- function(theta, theta.old, ...) {
    ui.theta <- ui %*% theta
    gi <- ui.theta - ci
    if (any(gi < 0)) 
      return(NaN)
    gi.old <- ui %*% theta.old - ci
    bar <- sum(gi.old * log(gi) - ui.theta)
    if (!is.finite(bar)) 
      bar <- -Inf
    f(theta, ...) - mu * bar
  }
  dR <- function(theta, theta.old, ...) {
    ui.theta <- ui %*% theta
    gi <- drop(ui.theta - ci)
    gi.old <- drop(ui %*% theta.old - ci)
    dbar <- colSums(ui * gi.old/gi - ui)
    grad(theta, ...) - mu * dbar
  }
  if (any(ui %*% theta - ci <= 0)) 
    stop("initial value is not in the interior of the feasible region")
  obj <- f(theta, ...)
  r <- R(theta, theta, ...)
  fun <- function(theta, ...) R(theta, theta.old, ...)
  gradient <- if (method == "SANN") {
    if (missing(grad)) 
      NULL
    else grad
  }
  else function(theta, ...) dR(theta, theta.old, ...)
  totCounts <- 0
  s.mu <- sign(mu)
  for (i in seq_len(outer.iterations)) {
    obj.old <- obj
    r.old <- r
    theta.old <- theta
    a <- optim(theta.old, fun, gradient, control = control, method = method, hessian = hessian, ...)
    r <- a$value
    if (is.finite(r) && is.finite(r.old) && abs(r - r.old) < (0.001 + abs(r)) * outer.eps) 
      break
    theta <- a$par
    totCounts <- totCounts + a$counts
    obj <- f(theta, ...)
    if (s.mu * obj > s.mu * obj.old) 
      break
  }
  if (i == outer.iterations) {
    a$convergence <- 7
    a$message <- gettext("Barrier algorithm ran out of iterations and did not converge")
  }
  if (mu > 0 && obj > obj.old) {
    a$convergence <- 11
    a$message <- gettextf("Objective function increased at outer iteration %d", i)
  }
  if (mu < 0 && obj < obj.old) {
    a$convergence <- 11
    a$message <- gettextf("Objective function decreased at outer iteration %d", i)
  }
  a$outer.iterations <- i
  a$counts <- totCounts
  a$barrier.value <- a$value
  a$value <- f(a$par, ...)
  a$barrier.value <- a$barrier.value - a$value
  a
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
contr.helmert
list(`package:stats` = function (n, contrasts = TRUE, sparse = FALSE) 
{
  if (length(n) <= 1) {
    if (is.numeric(n) && length(n) == 1 && n > 1) 
      levels <- seq_len(n)
    else stop("not enough degrees of freedom to define contrasts")
  }
  else levels <- n
  levels <- as.character(levels)
  if (contrasts) {
    n <- length(levels)
    cont <- array(-1, c(n, n - 1), list(levels, NULL))
    cont[col(cont) <= row(cont) - 2] <- 0
    cont[col(cont) == row(cont) - 1] <- seq_len(n - 1)
    colnames(cont) <- NULL
    if (sparse) 
      .asSparse(cont)
    else cont
  }
  else .Diag(levels, sparse = sparse)
}, function (n, contrasts = TRUE, sparse = FALSE) 
{
  if (length(n) <= 1) {
    if (is.numeric(n) && length(n) == 1 && n > 1) 
      levels <- seq_len(n)
    else stop("not enough degrees of freedom to define contrasts")
  }
  else levels <- n
  levels <- as.character(levels)
  if (contrasts) {
    n <- length(levels)
    cont <- array(-1, c(n, n - 1), list(levels, NULL))
    cont[col(cont) <= row(cont) - 2] <- 0
    cont[col(cont) == row(cont) - 1] <- seq_len(n - 1)
    colnames(cont) <- NULL
    if (sparse) 
      .asSparse(cont)
    else cont
  }
  else .Diag(levels, sparse = sparse)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
contr.poly
list(`package:stats` = function (n, scores = 1:n, contrasts = TRUE, sparse = FALSE) 
{
  make.poly <- function(n, scores) {
    y <- scores - mean(scores)
    X <- outer(y, seq_len(n) - 1, `^`)
    QR <- qr(X)
    z <- QR$qr
    z <- z * (row(z) == col(z))
    raw <- qr.qy(QR, z)
    Z <- sweep(raw, 2, apply(raw, 2, function(x) sqrt(sum(x^2))), `/`, check.margin = FALSE)
    colnames(Z) <- paste0("^", 1:n - 1)
    Z
  }
  if (is.numeric(n) && length(n) == 1) 
    levs <- seq_len(n)
  else {
    levs <- n
    n <- length(levs)
  }
  if (n < 2) 
    stop(gettextf("contrasts not defined for %d degrees of freedom", n - 1), domain = NA)
  if (n > 95) 
    stop(gettextf("orthogonal polynomials cannot be represented accurately enough for %d degrees of freedom", n - 1), domain = NA)
  if (length(scores) != n) 
    stop("'scores' argument is of the wrong length")
  if (!is.numeric(scores) || anyDuplicated(scores)) 
    stop("'scores' must all be different numbers")
  contr <- make.poly(n, scores)
  if (sparse) 
    contr <- .asSparse(contr)
  if (contrasts) {
    dn <- colnames(contr)
    dn[2:min(4, n)] <- c(".L", ".Q", ".C")[1:min(3, n - 1)]
    colnames(contr) <- dn
    contr[, -1, drop = FALSE]
  }
  else {
    contr[, 1] <- 1
    contr
  }
}, function (n, scores = 1:n, contrasts = TRUE, sparse = FALSE) 
{
  make.poly <- function(n, scores) {
    y <- scores - mean(scores)
    X <- outer(y, seq_len(n) - 1, `^`)
    QR <- qr(X)
    z <- QR$qr
    z <- z * (row(z) == col(z))
    raw <- qr.qy(QR, z)
    Z <- sweep(raw, 2, apply(raw, 2, function(x) sqrt(sum(x^2))), `/`, check.margin = FALSE)
    colnames(Z) <- paste0("^", 1:n - 1)
    Z
  }
  if (is.numeric(n) && length(n) == 1) 
    levs <- seq_len(n)
  else {
    levs <- n
    n <- length(levs)
  }
  if (n < 2) 
    stop(gettextf("contrasts not defined for %d degrees of freedom", n - 1), domain = NA)
  if (n > 95) 
    stop(gettextf("orthogonal polynomials cannot be represented accurately enough for %d degrees of freedom", n - 1), domain = NA)
  if (length(scores) != n) 
    stop("'scores' argument is of the wrong length")
  if (!is.numeric(scores) || anyDuplicated(scores)) 
    stop("'scores' must all be different numbers")
  contr <- make.poly(n, scores)
  if (sparse) 
    contr <- .asSparse(contr)
  if (contrasts) {
    dn <- colnames(contr)
    dn[2:min(4, n)] <- c(".L", ".Q", ".C")[1:min(3, n - 1)]
    colnames(contr) <- dn
    contr[, -1, drop = FALSE]
  }
  else {
    contr[, 1] <- 1
    contr
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
contr.SAS
list(`package:stats` = function (n, contrasts = TRUE, sparse = FALSE) 
{
  contr.treatment(n, base = if (is.numeric(n) && length(n) == 1) 
    n
    else length(n), contrasts = contrasts, sparse = sparse)
}, function (n, contrasts = TRUE, sparse = FALSE) 
{
  contr.treatment(n, base = if (is.numeric(n) && length(n) == 1) 
    n
    else length(n), contrasts = contrasts, sparse = sparse)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
contr.sum
list(`package:stats` = function (n, contrasts = TRUE, sparse = FALSE) 
{
  if (length(n) <= 1) {
    if (is.numeric(n) && length(n) == 1 && n > 1) 
      levels <- seq_len(n)
    else stop("not enough degrees of freedom to define contrasts")
  }
  else levels <- n
  levels <- as.character(levels)
  cont <- .Diag(levels, sparse = sparse)
  if (contrasts) {
    cont <- cont[, -length(levels), drop = FALSE]
    cont[length(levels), ] <- -1
    colnames(cont) <- NULL
  }
  cont
}, function (n, contrasts = TRUE, sparse = FALSE) 
{
  if (length(n) <= 1) {
    if (is.numeric(n) && length(n) == 1 && n > 1) 
      levels <- seq_len(n)
    else stop("not enough degrees of freedom to define contrasts")
  }
  else levels <- n
  levels <- as.character(levels)
  cont <- .Diag(levels, sparse = sparse)
  if (contrasts) {
    cont <- cont[, -length(levels), drop = FALSE]
    cont[length(levels), ] <- -1
    colnames(cont) <- NULL
  }
  cont
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
contr.treatment
list(`package:stats` = function (n, base = 1, contrasts = TRUE, sparse = FALSE) 
{
  if (is.numeric(n) && length(n) == 1) {
    if (n > 1) 
      levels <- as.character(seq_len(n))
    else stop("not enough degrees of freedom to define contrasts")
  }
  else {
    levels <- as.character(n)
    n <- length(n)
  }
  contr <- .Diag(levels, sparse = sparse)
  if (contrasts) {
    if (n < 2) 
      stop(gettextf("contrasts not defined for %d degrees of freedom", n - 1), domain = NA)
    if (base < 1 || base > n) 
      stop("baseline group number out of range")
    contr <- contr[, -base, drop = FALSE]
  }
  contr
}, function (n, base = 1, contrasts = TRUE, sparse = FALSE) 
{
  if (is.numeric(n) && length(n) == 1) {
    if (n > 1) 
      levels <- as.character(seq_len(n))
    else stop("not enough degrees of freedom to define contrasts")
  }
  else {
    levels <- as.character(n)
    n <- length(n)
  }
  contr <- .Diag(levels, sparse = sparse)
  if (contrasts) {
    if (n < 2) 
      stop(gettextf("contrasts not defined for %d degrees of freedom", n - 1), domain = NA)
    if (base < 1 || base > n) 
      stop("baseline group number out of range")
    contr <- contr[, -base, drop = FALSE]
  }
  contr
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
contrasts
list(`package:stats` = function (x, contrasts = TRUE, sparse = FALSE) 
{
  if (is.logical(x)) 
    x <- factor(x, levels = c(FALSE, TRUE))
  if (!is.factor(x)) 
    stop("contrasts apply only to factors")
  if (!contrasts) 
    return(.Diag(levels(x), sparse = sparse))
  ctr <- attr(x, "contrasts")
  if ((NL <- is.null(ctr)) || is.character(ctr)) {
    if (NL) 
      ctr <- getOption("contrasts")[[if (is.ordered(x)) 
        2
        else 1]]
    ctrfn <- get(ctr, mode = "function", envir = parent.frame())
    if (useSparse <- isTRUE(sparse)) {
      if (!(useSparse <- any("sparse" == names(formals(ctrfn))))) 
        warning(sprintf("contrast function '%s' does not support 'sparse = TRUE'", ctr), domain = NA)
    }
    ctr <- if (useSparse) 
      ctrfn(levels(x), contrasts = contrasts, sparse = sparse)
    else ctrfn(levels(x), contrasts = contrasts)
  }
  ctr
}, function (x, contrasts = TRUE, sparse = FALSE) 
{
  if (is.logical(x)) 
    x <- factor(x, levels = c(FALSE, TRUE))
  if (!is.factor(x)) 
    stop("contrasts apply only to factors")
  if (!contrasts) 
    return(.Diag(levels(x), sparse = sparse))
  ctr <- attr(x, "contrasts")
  if ((NL <- is.null(ctr)) || is.character(ctr)) {
    if (NL) 
      ctr <- getOption("contrasts")[[if (is.ordered(x)) 
        2
        else 1]]
    ctrfn <- get(ctr, mode = "function", envir = parent.frame())
    if (useSparse <- isTRUE(sparse)) {
      if (!(useSparse <- any("sparse" == names(formals(ctrfn))))) 
        warning(sprintf("contrast function '%s' does not support 'sparse = TRUE'", ctr), domain = NA)
    }
    ctr <- if (useSparse) 
      ctrfn(levels(x), contrasts = contrasts, sparse = sparse)
    else ctrfn(levels(x), contrasts = contrasts)
  }
  ctr
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
contrasts<-
  list(`package:stats` = function (x, how.many = NULL, value) 
  {
    if (is.logical(x)) 
      x <- factor(x, levels = c(FALSE, TRUE))
    if (!is.factor(x)) 
      stop("contrasts apply only to factors")
    if (nlevels(x) < 2) 
      stop("contrasts can be applied only to factors with 2 or more levels")
    if (is.function(value)) 
      value <- value(nlevels(x))
    if ((is.n <- is.numeric(value)) || (isS4(value) && methods::is(value, "Matrix"))) {
      if (is.n) 
        value <- as.matrix(value)
      nlevs <- nlevels(x)
      if (nrow(value) != nlevs) 
        stop("wrong number of contrast matrix rows")
      n1 <- if (missing(how.many) || is.null(how.many)) 
        nlevs - 1
      else how.many
      nc <- ncol(value)
      rownames(value) <- levels(x)
      if (nc < n1) {
        if (!is.n) 
          value <- as.matrix(value)
        cm <- qr(cbind(1, value))
        if (cm$rank != nc + 1) 
          stop("singular contrast matrix")
        cm <- qr.qy(cm, diag(nlevs))[, 2:nlevs]
        cm[, 1:nc] <- value
        dimnames(cm) <- list(levels(x), NULL)
        if (!is.null(nmcol <- dimnames(value)[[2]])) 
          dimnames(cm)[[2]] <- c(nmcol, rep.int("", n1 - nc))
      }
      else cm <- value[, 1:n1, drop = FALSE]
    }
    else if (is.character(value)) 
      cm <- value
    else if (is.null(value)) 
      cm <- NULL
    else stop("numeric contrasts or contrast name expected")
    attr(x, "contrasts") <- cm
    x
  }, function (x, how.many = NULL, value) 
  {
    if (is.logical(x)) 
      x <- factor(x, levels = c(FALSE, TRUE))
    if (!is.factor(x)) 
      stop("contrasts apply only to factors")
    if (nlevels(x) < 2) 
      stop("contrasts can be applied only to factors with 2 or more levels")
    if (is.function(value)) 
      value <- value(nlevels(x))
    if ((is.n <- is.numeric(value)) || (isS4(value) && methods::is(value, "Matrix"))) {
      if (is.n) 
        value <- as.matrix(value)
      nlevs <- nlevels(x)
      if (nrow(value) != nlevs) 
        stop("wrong number of contrast matrix rows")
      n1 <- if (missing(how.many) || is.null(how.many)) 
        nlevs - 1
      else how.many
      nc <- ncol(value)
      rownames(value) <- levels(x)
      if (nc < n1) {
        if (!is.n) 
          value <- as.matrix(value)
        cm <- qr(cbind(1, value))
        if (cm$rank != nc + 1) 
          stop("singular contrast matrix")
        cm <- qr.qy(cm, diag(nlevs))[, 2:nlevs]
        cm[, 1:nc] <- value
        dimnames(cm) <- list(levels(x), NULL)
        if (!is.null(nmcol <- dimnames(value)[[2]])) 
          dimnames(cm)[[2]] <- c(nmcol, rep.int("", n1 - nc))
      }
      else cm <- value[, 1:n1, drop = FALSE]
    }
    else if (is.character(value)) 
      cm <- value
    else if (is.null(value)) 
      cm <- NULL
    else stop("numeric contrasts or contrast name expected")
    attr(x, "contrasts") <- cm
    x
  })
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
convolve
list(`package:stats` = function (x, y, conj = TRUE, type = c("circular", "open", "filter")) 
{
  type <- match.arg(type)
  n <- length(x)
  ny <- length(y)
  Real <- is.numeric(x) && is.numeric(y)
  if (type == "circular") {
    if (ny != n) 
      stop("length mismatch in convolution")
  }
  else {
    n1 <- ny - 1
    x <- c(rep.int(0, n1), x)
    n <- length(y <- c(y, rep.int(0, n - 1)))
  }
  x <- fft(fft(x) * (if (conj) 
    Conj(fft(y))
    else fft(y)), inverse = TRUE)
  if (type == "filter") 
    (if (Real) 
      Re(x)
     else x)[-c(1:n1, (n - n1 + 1):n)]/n
  else (if (Real) 
    Re(x)
    else x)/n
}, function (x, y, conj = TRUE, type = c("circular", "open", "filter")) 
{
  type <- match.arg(type)
  n <- length(x)
  ny <- length(y)
  Real <- is.numeric(x) && is.numeric(y)
  if (type == "circular") {
    if (ny != n) 
      stop("length mismatch in convolution")
  }
  else {
    n1 <- ny - 1
    x <- c(rep.int(0, n1), x)
    n <- length(y <- c(y, rep.int(0, n - 1)))
  }
  x <- fft(fft(x) * (if (conj) 
    Conj(fft(y))
    else fft(y)), inverse = TRUE)
  if (type == "filter") 
    (if (Real) 
      Re(x)
     else x)[-c(1:n1, (n - n1 + 1):n)]/n
  else (if (Real) 
    Re(x)
    else x)/n
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cooks.distance
list(`package:stats` = function (model, ...) 
  UseMethod("cooks.distance"), function (model, ...) 
    UseMethod("cooks.distance"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cophenetic
list(`package:stats` = function (x) 
  UseMethod("cophenetic"), function (x) 
    UseMethod("cophenetic"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cor
list(`package:stats` = function (x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman")) 
{
  na.method <- pmatch(use, c("all.obs", "complete.obs", "pairwise.complete.obs", "everything", "na.or.complete"))
  if (is.na(na.method)) 
    stop("invalid 'use' argument")
  method <- match.arg(method)
  if (is.data.frame(y)) 
    y <- as.matrix(y)
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (!is.matrix(x) && is.null(y)) 
    stop("supply both 'x' and 'y' or a matrix-like 'x'")
  if (!(is.numeric(x) || is.logical(x))) 
    stop("'x' must be numeric")
  stopifnot(is.atomic(x))
  if (!is.null(y)) {
    if (!(is.numeric(y) || is.logical(y))) 
      stop("'y' must be numeric")
    stopifnot(is.atomic(y))
  }
  Rank <- function(u) {
    if (length(u) == 0) 
      u
    else if (is.matrix(u)) {
      if (nrow(u) > 1) 
        apply(u, 2, rank, na.last = "keep")
      else row(u)
    }
    else rank(u, na.last = "keep")
  }
  if (method == "pearson") 
    .Call(C_cor, x, y, na.method, FALSE)
  else if (na.method %in% c(2, 5)) {
    if (is.null(y)) {
      .Call(C_cor, Rank(na.omit(x)), NULL, na.method, method == "kendall")
    }
    else {
      nas <- attr(na.omit(cbind(x, y)), "na.action")
      dropNA <- function(x, nas) {
        if (length(nas)) {
          if (is.matrix(x)) 
            x[-nas, , drop = FALSE]
          else x[-nas]
        }
        else x
      }
      .Call(C_cor, Rank(dropNA(x, nas)), Rank(dropNA(y, nas)), na.method, method == "kendall")
    }
  }
  else if (na.method != 3) {
    x <- Rank(x)
    if (!is.null(y)) 
      y <- Rank(y)
    .Call(C_cor, x, y, na.method, method == "kendall")
  }
  else {
    if (is.null(y)) {
      ncy <- ncx <- ncol(x)
      if (ncx == 0) 
        stop("'x' is empty")
      r <- matrix(0, nrow = ncx, ncol = ncy)
      for (i in seq_len(ncx)) {
        for (j in seq_len(i)) {
          x2 <- x[, i]
          y2 <- x[, j]
          ok <- complete.cases(x2, y2)
          x2 <- rank(x2[ok])
          y2 <- rank(y2[ok])
          r[i, j] <- if (any(ok)) 
            .Call(C_cor, x2, y2, 1, method == "kendall")
          else NA
        }
      }
      r <- r + t(r) - diag(diag(r))
      rownames(r) <- colnames(x)
      colnames(r) <- colnames(x)
      r
    }
    else {
      if (length(x) == 0 || length(y) == 0) 
        stop("both 'x' and 'y' must be non-empty")
      matrix_result <- is.matrix(x) || is.matrix(y)
      if (!is.matrix(x)) 
        x <- matrix(x, ncol = 1)
      if (!is.matrix(y)) 
        y <- matrix(y, ncol = 1)
      ncx <- ncol(x)
      ncy <- ncol(y)
      r <- matrix(0, nrow = ncx, ncol = ncy)
      for (i in seq_len(ncx)) {
        for (j in seq_len(ncy)) {
          x2 <- x[, i]
          y2 <- y[, j]
          ok <- complete.cases(x2, y2)
          x2 <- rank(x2[ok])
          y2 <- rank(y2[ok])
          r[i, j] <- if (any(ok)) 
            .Call(C_cor, x2, y2, 1, method == "kendall")
          else NA
        }
      }
      rownames(r) <- colnames(x)
      colnames(r) <- colnames(y)
      if (matrix_result) 
        r
      else drop(r)
    }
  }
}, function (x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman")) 
{
  na.method <- pmatch(use, c("all.obs", "complete.obs", "pairwise.complete.obs", "everything", "na.or.complete"))
  if (is.na(na.method)) 
    stop("invalid 'use' argument")
  method <- match.arg(method)
  if (is.data.frame(y)) 
    y <- as.matrix(y)
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (!is.matrix(x) && is.null(y)) 
    stop("supply both 'x' and 'y' or a matrix-like 'x'")
  if (!(is.numeric(x) || is.logical(x))) 
    stop("'x' must be numeric")
  stopifnot(is.atomic(x))
  if (!is.null(y)) {
    if (!(is.numeric(y) || is.logical(y))) 
      stop("'y' must be numeric")
    stopifnot(is.atomic(y))
  }
  Rank <- function(u) {
    if (length(u) == 0) 
      u
    else if (is.matrix(u)) {
      if (nrow(u) > 1) 
        apply(u, 2, rank, na.last = "keep")
      else row(u)
    }
    else rank(u, na.last = "keep")
  }
  if (method == "pearson") 
    .Call(C_cor, x, y, na.method, FALSE)
  else if (na.method %in% c(2, 5)) {
    if (is.null(y)) {
      .Call(C_cor, Rank(na.omit(x)), NULL, na.method, method == "kendall")
    }
    else {
      nas <- attr(na.omit(cbind(x, y)), "na.action")
      dropNA <- function(x, nas) {
        if (length(nas)) {
          if (is.matrix(x)) 
            x[-nas, , drop = FALSE]
          else x[-nas]
        }
        else x
      }
      .Call(C_cor, Rank(dropNA(x, nas)), Rank(dropNA(y, nas)), na.method, method == "kendall")
    }
  }
  else if (na.method != 3) {
    x <- Rank(x)
    if (!is.null(y)) 
      y <- Rank(y)
    .Call(C_cor, x, y, na.method, method == "kendall")
  }
  else {
    if (is.null(y)) {
      ncy <- ncx <- ncol(x)
      if (ncx == 0) 
        stop("'x' is empty")
      r <- matrix(0, nrow = ncx, ncol = ncy)
      for (i in seq_len(ncx)) {
        for (j in seq_len(i)) {
          x2 <- x[, i]
          y2 <- x[, j]
          ok <- complete.cases(x2, y2)
          x2 <- rank(x2[ok])
          y2 <- rank(y2[ok])
          r[i, j] <- if (any(ok)) 
            .Call(C_cor, x2, y2, 1, method == "kendall")
          else NA
        }
      }
      r <- r + t(r) - diag(diag(r))
      rownames(r) <- colnames(x)
      colnames(r) <- colnames(x)
      r
    }
    else {
      if (length(x) == 0 || length(y) == 0) 
        stop("both 'x' and 'y' must be non-empty")
      matrix_result <- is.matrix(x) || is.matrix(y)
      if (!is.matrix(x)) 
        x <- matrix(x, ncol = 1)
      if (!is.matrix(y)) 
        y <- matrix(y, ncol = 1)
      ncx <- ncol(x)
      ncy <- ncol(y)
      r <- matrix(0, nrow = ncx, ncol = ncy)
      for (i in seq_len(ncx)) {
        for (j in seq_len(ncy)) {
          x2 <- x[, i]
          y2 <- y[, j]
          ok <- complete.cases(x2, y2)
          x2 <- rank(x2[ok])
          y2 <- rank(y2[ok])
          r[i, j] <- if (any(ok)) 
            .Call(C_cor, x2, y2, 1, method == "kendall")
          else NA
        }
      }
      rownames(r) <- colnames(x)
      colnames(r) <- colnames(y)
      if (matrix_result) 
        r
      else drop(r)
    }
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cor.test
list(`package:stats` = function (x, ...) 
  UseMethod("cor.test"), function (x, ...) 
    UseMethod("cor.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cov
list(`package:stats` = function (x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman")) 
{
  na.method <- pmatch(use, c("all.obs", "complete.obs", "pairwise.complete.obs", "everything", "na.or.complete"))
  if (is.na(na.method)) 
    stop("invalid 'use' argument")
  method <- match.arg(method)
  if (is.data.frame(y)) 
    y <- as.matrix(y)
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (!is.matrix(x) && is.null(y)) 
    stop("supply both 'x' and 'y' or a matrix-like 'x'")
  stopifnot(is.numeric(x) || is.logical(x), is.atomic(x))
  if (!is.null(y)) 
    stopifnot(is.numeric(y) || is.logical(y), is.atomic(y))
  Rank <- function(u) {
    if (length(u) == 0) 
      u
    else if (is.matrix(u)) {
      if (nrow(u) > 1) 
        apply(u, 2, rank, na.last = "keep")
      else row(u)
    }
    else rank(u, na.last = "keep")
  }
  if (method == "pearson") 
    .Call(C_cov, x, y, na.method, method == "kendall")
  else if (na.method %in% c(2, 5)) {
    if (is.null(y)) {
      .Call(C_cov, Rank(na.omit(x)), NULL, na.method, method == "kendall")
    }
    else {
      nas <- attr(na.omit(cbind(x, y)), "na.action")
      dropNA <- function(x, nas) {
        if (length(nas)) {
          if (is.matrix(x)) 
            x[-nas, , drop = FALSE]
          else x[-nas]
        }
        else x
      }
      .Call(C_cov, Rank(dropNA(x, nas)), Rank(dropNA(y, nas)), na.method, method == "kendall")
    }
  }
  else if (na.method != 3) {
    x <- Rank(x)
    if (!is.null(y)) 
      y <- Rank(y)
    .Call(C_cov, x, y, na.method, method == "kendall")
  }
  else stop("cannot handle 'pairwise.complete.obs'")
}, function (x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman")) 
{
  na.method <- pmatch(use, c("all.obs", "complete.obs", "pairwise.complete.obs", "everything", "na.or.complete"))
  if (is.na(na.method)) 
    stop("invalid 'use' argument")
  method <- match.arg(method)
  if (is.data.frame(y)) 
    y <- as.matrix(y)
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (!is.matrix(x) && is.null(y)) 
    stop("supply both 'x' and 'y' or a matrix-like 'x'")
  stopifnot(is.numeric(x) || is.logical(x), is.atomic(x))
  if (!is.null(y)) 
    stopifnot(is.numeric(y) || is.logical(y), is.atomic(y))
  Rank <- function(u) {
    if (length(u) == 0) 
      u
    else if (is.matrix(u)) {
      if (nrow(u) > 1) 
        apply(u, 2, rank, na.last = "keep")
      else row(u)
    }
    else rank(u, na.last = "keep")
  }
  if (method == "pearson") 
    .Call(C_cov, x, y, na.method, method == "kendall")
  else if (na.method %in% c(2, 5)) {
    if (is.null(y)) {
      .Call(C_cov, Rank(na.omit(x)), NULL, na.method, method == "kendall")
    }
    else {
      nas <- attr(na.omit(cbind(x, y)), "na.action")
      dropNA <- function(x, nas) {
        if (length(nas)) {
          if (is.matrix(x)) 
            x[-nas, , drop = FALSE]
          else x[-nas]
        }
        else x
      }
      .Call(C_cov, Rank(dropNA(x, nas)), Rank(dropNA(y, nas)), na.method, method == "kendall")
    }
  }
  else if (na.method != 3) {
    x <- Rank(x)
    if (!is.null(y)) 
      y <- Rank(y)
    .Call(C_cov, x, y, na.method, method == "kendall")
  }
  else stop("cannot handle 'pairwise.complete.obs'")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cov.wt
list(`package:stats` = function (x, wt = rep(1/nrow(x), nrow(x)), cor = FALSE, center = TRUE, method = c("unbiased", "ML")) 
{
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  else if (!is.matrix(x)) 
    stop("'x' must be a matrix or a data frame")
  if (!all(is.finite(x))) 
    stop("'x' must contain finite values only")
  n <- nrow(x)
  if (with.wt <- !missing(wt)) {
    if (length(wt) != n) 
      stop("length of 'wt' must equal the number of rows in 'x'")
    if (any(wt < 0) || (s <- sum(wt)) == 0) 
      stop("weights must be non-negative and not all zero")
    wt <- wt/s
  }
  if (is.logical(center)) {
    center <- if (center) 
      colSums(wt * x)
    else 0
  }
  else {
    if (length(center) != ncol(x)) 
      stop("length of 'center' must equal the number of columns in 'x'")
  }
  x <- sqrt(wt) * sweep(x, 2, center, check.margin = FALSE)
  cov <- switch(match.arg(method), unbiased = crossprod(x)/(1 - sum(wt^2)), ML = crossprod(x))
  y <- list(cov = cov, center = center, n.obs = n)
  if (with.wt) 
    y$wt <- wt
  if (cor) {
    Is <- 1/sqrt(diag(cov))
    R <- cov
    R[] <- Is * cov * rep(Is, each = nrow(cov))
    y$cor <- R
  }
  y
}, function (x, wt = rep(1/nrow(x), nrow(x)), cor = FALSE, center = TRUE, method = c("unbiased", "ML")) 
{
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  else if (!is.matrix(x)) 
    stop("'x' must be a matrix or a data frame")
  if (!all(is.finite(x))) 
    stop("'x' must contain finite values only")
  n <- nrow(x)
  if (with.wt <- !missing(wt)) {
    if (length(wt) != n) 
      stop("length of 'wt' must equal the number of rows in 'x'")
    if (any(wt < 0) || (s <- sum(wt)) == 0) 
      stop("weights must be non-negative and not all zero")
    wt <- wt/s
  }
  if (is.logical(center)) {
    center <- if (center) 
      colSums(wt * x)
    else 0
  }
  else {
    if (length(center) != ncol(x)) 
      stop("length of 'center' must equal the number of columns in 'x'")
  }
  x <- sqrt(wt) * sweep(x, 2, center, check.margin = FALSE)
  cov <- switch(match.arg(method), unbiased = crossprod(x)/(1 - sum(wt^2)), ML = crossprod(x))
  y <- list(cov = cov, center = center, n.obs = n)
  if (with.wt) 
    y$wt <- wt
  if (cor) {
    Is <- 1/sqrt(diag(cov))
    R <- cov
    R[] <- Is * cov * rep(Is, each = nrow(cov))
    y$cor <- R
  }
  y
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cov2cor
list(`package:stats` = function (V) 
{
  p <- (d <- dim(V))[1]
  if (!is.numeric(V) || length(d) != 2 || p != d[2]) 
    stop("'V' is not a square numeric matrix")
  Is <- sqrt(1/diag(V))
  if (any(!is.finite(Is))) 
    warning("diag(.) had 0 or NA entries; non-finite result is doubtful")
  r <- V
  r[] <- Is * V * rep(Is, each = p)
  r[cbind(1:p, 1:p)] <- 1
  r
}, new("standardGeneric", .Data = function (V) 
  standardGeneric("cov2cor"), generic = "cov2cor", package = "stats", group = list(), valueClass = character(0), signature = "V", default = new("derivedDefaultMethod", .Data = function (V) 
  {
    p <- (d <- dim(V))[1]
    if (!is.numeric(V) || length(d) != 2 || p != d[2]) 
      stop("'V' is not a square numeric matrix")
    Is <- sqrt(1/diag(V))
    if (any(!is.finite(Is))) 
      warning("diag(.) had 0 or NA entries; non-finite result is doubtful")
    r <- V
    r[] <- Is * V * rep(Is, each = p)
    r[cbind(1:p, 1:p)] <- 1
    r
  }, target = new("signature", .Data = "ANY", names = "V", package = "methods"), defined = new("signature", .Data = "ANY", names = "V", package = "methods"), generic = "cov2cor"), skeleton = (new("derivedDefaultMethod", .Data = function (V) 
  {
    p <- (d <- dim(V))[1]
    if (!is.numeric(V) || length(d) != 2 || p != d[2]) 
      stop("'V' is not a square numeric matrix")
    Is <- sqrt(1/diag(V))
    if (any(!is.finite(Is))) 
      warning("diag(.) had 0 or NA entries; non-finite result is doubtful")
    r <- V
    r[] <- Is * V * rep(Is, each = p)
    r[cbind(1:p, 1:p)] <- 1
    r
  }, target = new("signature", .Data = "ANY", names = "V", package = "methods"), defined = new("signature", .Data = "ANY", names = "V", package = "methods"), generic = "cov2cor"))(V)), function (V) 
  {
    p <- (d <- dim(V))[1]
    if (!is.numeric(V) || length(d) != 2 || p != d[2]) 
      stop("'V' is not a square numeric matrix")
    Is <- sqrt(1/diag(V))
    if (any(!is.finite(Is))) 
      warning("diag(.) had 0 or NA entries; non-finite result is doubtful")
    r <- V
    r[] <- Is * V * rep(Is, each = p)
    r[cbind(1:p, 1:p)] <- 1
    r
  })
c("package:stats", "namespace:Matrix", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
covratio
list(`package:stats` = function (model, infl = lm.influence(model, do.coef = FALSE), res = weighted.residuals(model)) 
{
  n <- nrow(qr.lm(model)$qr)
  p <- model$rank
  omh <- 1 - infl$hat
  e.star <- res/(infl$sigma * sqrt(omh))
  e.star[is.infinite(e.star)] <- NaN
  1/(omh * (((n - p - 1) + e.star^2)/(n - p))^p)
}, function (model, infl = lm.influence(model, do.coef = FALSE), res = weighted.residuals(model)) 
{
  n <- nrow(qr.lm(model)$qr)
  p <- model$rank
  omh <- 1 - infl$hat
  e.star <- res/(infl$sigma * sqrt(omh))
  e.star[is.infinite(e.star)] <- NaN
  1/(omh * (((n - p - 1) + e.star^2)/(n - p))^p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cpgram
list(`package:stats` = function (ts, taper = 0.1, main = paste("Series: ", deparse1(substitute(ts))), ci.col = "blue") 
{
  main
  if (NCOL(ts) > 1) 
    stop("only implemented for univariate time series")
  x <- as.vector(ts)
  x <- x[!is.na(x)]
  x <- spec.taper(scale(x, TRUE, FALSE), p = taper)
  y <- Mod(fft(x))^2/length(x)
  y[1] <- 0
  n <- length(x)
  x <- (0:(n/2)) * frequency(ts)/n
  if (length(x)%%2 == 0) {
    n <- length(x) - 1
    y <- y[1:n]
    x <- x[1:n]
  }
  else y <- y[seq_along(x)]
  xm <- frequency(ts)/2
  mp <- length(x) - 1
  crit <- 1.358/(sqrt(mp) + 0.12 + 0.11/sqrt(mp))
  oldpty <- par(pty = "s")
  on.exit(par(oldpty))
  plot(x, cumsum(y)/sum(y), type = "s", xlim = c(0, xm), ylim = c(0, 1), xaxs = "i", yaxs = "i", xlab = "frequency", ylab = "")
  lines(c(0, xm * (1 - crit)), c(crit, 1), col = ci.col, lty = 2)
  lines(c(xm * crit, xm), c(0, 1 - crit), col = ci.col, lty = 2)
  title(main = main)
  invisible()
}, function (ts, taper = 0.1, main = paste("Series: ", deparse1(substitute(ts))), ci.col = "blue") 
{
  main
  if (NCOL(ts) > 1) 
    stop("only implemented for univariate time series")
  x <- as.vector(ts)
  x <- x[!is.na(x)]
  x <- spec.taper(scale(x, TRUE, FALSE), p = taper)
  y <- Mod(fft(x))^2/length(x)
  y[1] <- 0
  n <- length(x)
  x <- (0:(n/2)) * frequency(ts)/n
  if (length(x)%%2 == 0) {
    n <- length(x) - 1
    y <- y[1:n]
    x <- x[1:n]
  }
  else y <- y[seq_along(x)]
  xm <- frequency(ts)/2
  mp <- length(x) - 1
  crit <- 1.358/(sqrt(mp) + 0.12 + 0.11/sqrt(mp))
  oldpty <- par(pty = "s")
  on.exit(par(oldpty))
  plot(x, cumsum(y)/sum(y), type = "s", xlim = c(0, xm), ylim = c(0, 1), xaxs = "i", yaxs = "i", xlab = "frequency", ylab = "")
  lines(c(0, xm * (1 - crit)), c(crit, 1), col = ci.col, lty = 2)
  lines(c(xm * crit, xm), c(0, 1 - crit), col = ci.col, lty = 2)
  title(main = main)
  invisible()
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cutree
list(`package:stats` = function (tree, k = NULL, h = NULL) 
{
  if (is.null(n1 <- nrow(tree$merge)) || n1 < 1) 
    stop("invalid 'tree' ('merge' component)")
  n <- n1 + 1
  if (is.null(k) && is.null(h)) 
    stop("either 'k' or 'h' must be specified")
  if (is.null(k)) {
    if (is.unsorted(tree$height)) 
      stop("the 'height' component of 'tree' is not sorted (increasingly)")
    k <- n + 1 - apply(outer(c(tree$height, Inf), h, `>`), 2, which.max)
    if (getOption("verbose")) 
      message("cutree(): k(h) = ", k, domain = NA)
  }
  else {
    k <- as.integer(k)
    if (min(k) < 1 || max(k) > n) 
      stop(gettextf("elements of 'k' must be between 1 and %d", n), domain = NA)
  }
  ans <- .Call(C_cutree, tree$merge, k)
  if (length(k) == 1) {
    ans <- setNames(as.vector(ans), tree$labels)
  }
  else {
    colnames(ans) <- if (!is.null(h)) 
      h
    else k
    rownames(ans) <- tree$labels
  }
  return(ans)
}, function (tree, k = NULL, h = NULL) 
{
  if (is.null(n1 <- nrow(tree$merge)) || n1 < 1) 
    stop("invalid 'tree' ('merge' component)")
  n <- n1 + 1
  if (is.null(k) && is.null(h)) 
    stop("either 'k' or 'h' must be specified")
  if (is.null(k)) {
    if (is.unsorted(tree$height)) 
      stop("the 'height' component of 'tree' is not sorted (increasingly)")
    k <- n + 1 - apply(outer(c(tree$height, Inf), h, `>`), 2, which.max)
    if (getOption("verbose")) 
      message("cutree(): k(h) = ", k, domain = NA)
  }
  else {
    k <- as.integer(k)
    if (min(k) < 1 || max(k) > n) 
      stop(gettextf("elements of 'k' must be between 1 and %d", n), domain = NA)
  }
  ans <- .Call(C_cutree, tree$merge, k)
  if (length(k) == 1) {
    ans <- setNames(as.vector(ans), tree$labels)
  }
  else {
    colnames(ans) <- if (!is.null(h)) 
      h
    else k
    rownames(ans) <- tree$labels
  }
  return(ans)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
cycle
list(`package:stats` = function (x, ...) 
  UseMethod("cycle"), function (x, ...) 
    UseMethod("cycle"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
D
list(`package:stats` = function (expr, name) 
  .External(C_doD, expr, name), function (expr, name) 
    .External(C_doD, expr, name))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dbeta
list(`package:stats` = function (x, shape1, shape2, ncp = 0, log = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_dbeta, x, shape1, shape2, log)
  else .Call(C_dnbeta, x, shape1, shape2, ncp, log)
}, function (x, shape1, shape2, ncp = 0, log = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_dbeta, x, shape1, shape2, log)
  else .Call(C_dnbeta, x, shape1, shape2, ncp, log)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dbinom
list(`package:stats` = function (x, size, prob, log = FALSE) 
  .Call(C_dbinom, x, size, prob, log), function (x, size, prob, log = FALSE) 
    .Call(C_dbinom, x, size, prob, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dcauchy
list(`package:stats` = function (x, location = 0, scale = 1, log = FALSE) 
  .Call(C_dcauchy, x, location, scale, log), function (x, location = 0, scale = 1, log = FALSE) 
    .Call(C_dcauchy, x, location, scale, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dchisq
list(`package:stats` = function (x, df, ncp = 0, log = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_dchisq, x, df, log)
  else .Call(C_dnchisq, x, df, ncp, log)
}, function (x, df, ncp = 0, log = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_dchisq, x, df, log)
  else .Call(C_dnchisq, x, df, ncp, log)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
decompose
list(`package:stats` = function (x, type = c("additive", "multiplicative"), filter = NULL) 
{
  type <- match.arg(type)
  l <- length(x)
  f <- frequency(x)
  if (f <= 1 || length(na.omit(x)) < 2 * f) 
    stop("time series has no or less than 2 periods")
  if (is.null(filter)) 
    filter <- if (!f%%2) 
      c(0.5, rep_len(1, f - 1), 0.5)/f
  else rep_len(1, f)/f
  trend <- filter(x, filter)
  season <- if (type == "additive") 
    x - trend
  else x/trend
  periods <- l%/%f
  index <- seq.int(1, l, by = f) - 1
  figure <- numeric(f)
  for (i in 1:f) figure[i] <- mean(season[index + i], na.rm = TRUE)
  figure <- if (type == "additive") 
    figure - mean(figure)
  else figure/mean(figure)
  seasonal <- ts(rep(figure, periods + 1)[seq_len(l)], start = start(x), frequency = f)
  structure(list(x = x, seasonal = seasonal, trend = trend, random = if (type == "additive") x - seasonal - trend else x/seasonal/trend, figure = figure, type = type), class = "decomposed.ts")
}, function (x) 
{
  x <- vec_data(x) * TICS_PER_SECOND
  xr <- round(x)
  out <- list(sign = xr < 0 & !is.na(xr), hours = abs(hours(xr)), minute_of_hour = minute_of_hour(xr), second_of_minute = second_of_minute(xr), tics = tic_of_second(xr))
  fake_zero <- (out$tics == 0) & (xr != x)
  out$tics[fake_zero] <- 0.25
  out
}, function (x, type = c("additive", "multiplicative"), filter = NULL) 
{
  type <- match.arg(type)
  l <- length(x)
  f <- frequency(x)
  if (f <= 1 || length(na.omit(x)) < 2 * f) 
    stop("time series has no or less than 2 periods")
  if (is.null(filter)) 
    filter <- if (!f%%2) 
      c(0.5, rep_len(1, f - 1), 0.5)/f
  else rep_len(1, f)/f
  trend <- filter(x, filter)
  season <- if (type == "additive") 
    x - trend
  else x/trend
  periods <- l%/%f
  index <- seq.int(1, l, by = f) - 1
  figure <- numeric(f)
  for (i in 1:f) figure[i] <- mean(season[index + i], na.rm = TRUE)
  figure <- if (type == "additive") 
    figure - mean(figure)
  else figure/mean(figure)
  seasonal <- ts(rep(figure, periods + 1)[seq_len(l)], start = start(x), frequency = f)
  structure(list(x = x, seasonal = seasonal, trend = trend, random = if (type == "additive") x - seasonal - trend else x/seasonal/trend, figure = figure, type = type), class = "decomposed.ts")
})
c("package:stats", "namespace:hms", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
delete.response
list(`package:stats` = function (termobj) 
{
  a <- attributes(termobj)
  y <- a$response
  if (!is.null(y) && y) {
    termobj[[2]] <- NULL
    a$response <- 0
    a$variables <- a$variables[-(1 + y)]
    a$predvars <- a$predvars[-(1 + y)]
    if (length(a$factors)) 
      a$factors <- a$factors[-y, , drop = FALSE]
    if (length(a$offset)) 
      a$offset <- ifelse(a$offset > y, a$offset - 1, a$offset)
    if (length(a$specials)) 
      for (i in seq_along(a$specials)) {
        b <- a$specials[[i]]
        a$specials[[i]] <- ifelse(b > y, b - 1, b)
      }
    attributes(termobj) <- a
  }
  termobj
}, function (termobj) 
{
  a <- attributes(termobj)
  y <- a$response
  if (!is.null(y) && y) {
    termobj[[2]] <- NULL
    a$response <- 0
    a$variables <- a$variables[-(1 + y)]
    a$predvars <- a$predvars[-(1 + y)]
    if (length(a$factors)) 
      a$factors <- a$factors[-y, , drop = FALSE]
    if (length(a$offset)) 
      a$offset <- ifelse(a$offset > y, a$offset - 1, a$offset)
    if (length(a$specials)) 
      for (i in seq_along(a$specials)) {
        b <- a$specials[[i]]
        a$specials[[i]] <- ifelse(b > y, b - 1, b)
      }
    attributes(termobj) <- a
  }
  termobj
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
deltat
list(`package:stats` = function (x, ...) 
  UseMethod("deltat"), function (x, ...) 
    UseMethod("deltat"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dendrapply
list(`package:stats` = function (X, FUN, ...) 
{
  FUN <- match.fun(FUN)
  if (!inherits(X, "dendrogram")) 
    stop("'X' is not a dendrogram")
  Napply <- function(d) {
    r <- FUN(d, ...)
    if (!is.leaf(d)) {
      if (!is.list(r)) 
        r <- as.list(r)
      if (length(r) < (n <- length(d))) 
        r[seq_len(n)] <- vector("list", n)
      r[] <- lapply(d, Napply)
    }
    r
  }
  Napply(X)
}, function (X, FUN, ...) 
{
  FUN <- match.fun(FUN)
  if (!inherits(X, "dendrogram")) 
    stop("'X' is not a dendrogram")
  Napply <- function(d) {
    r <- FUN(d, ...)
    if (!is.leaf(d)) {
      if (!is.list(r)) 
        r <- as.list(r)
      if (length(r) < (n <- length(d))) 
        r[seq_len(n)] <- vector("list", n)
      r[] <- lapply(d, Napply)
    }
    r
  }
  Napply(X)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
density
list(`package:stats` = function (x, ...) 
  UseMethod("density"), function (x, ...) 
    UseMethod("density"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
density.default
list(`package:stats` = function (x, bw = "nrd0", adjust = 1, kernel = c("gaussian", "epanechnikov", "rectangular", "triangular", "biweight", "cosine", "optcosine"), weights = NULL, window = kernel, width, give.Rkern = FALSE, subdensity = FALSE, n = 512, from, to, cut = 3, na.rm = FALSE, ...) 
{
  chkDots(...)
  if (!missing(window) && missing(kernel)) 
    kernel <- window
  kernel <- match.arg(kernel)
  if (give.Rkern) 
    return(switch(kernel, gaussian = 1/(2 * sqrt(pi)), rectangular = sqrt(3)/6, triangular = sqrt(6)/9, epanechnikov = 3/(5 * sqrt(5)), biweight = 5 * sqrt(7)/49, cosine = 3/4 * sqrt(1/3 - 2/pi^2), optcosine = sqrt(1 - 8/pi^2) * pi^2/16))
  if (!is.numeric(x)) 
    stop("argument 'x' must be numeric")
  name <- deparse1(substitute(x))
  x <- as.vector(x)
  N <- length(x)
  if (has.wts <- !is.null(weights)) {
    if (length(weights) != N) 
      stop("'x' and 'weights' have unequal length")
    some.na <- FALSE
  }
  x.na <- is.na(x)
  if (any(x.na)) {
    if (na.rm) {
      N <- length(x <- x[!x.na])
      if (has.wts) {
        some.na <- TRUE
        trueD <- isTRUE(all.equal(1, sum(weights)))
        weights <- weights[!x.na]
        if (trueD) 
          weights <- weights/sum(weights)
      }
    }
    else stop("'x' contains missing values")
  }
  nx <- N <- as.integer(N)
  if (is.na(N)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  x.finite <- is.finite(x)
  if (any(!x.finite)) {
    x <- x[x.finite]
    nx <- length(x)
  }
  if (!has.wts) {
    weights <- rep.int(1/nx, nx)
    totMass <- nx/N
  }
  else {
    if (!all(is.finite(weights))) 
      stop("'weights' must all be finite")
    if (any(weights < 0)) 
      stop("'weights' must not be negative")
    wsum <- sum(weights)
    if (any(!x.finite)) {
      weights <- weights[x.finite]
      totMass <- sum(weights)/wsum
    }
    else totMass <- 1
    if (!subdensity && !isTRUE(all.equal(1, wsum))) 
      warning("sum(weights) != 1  -- will not get true density")
  }
  n.user <- n
  n <- max(n, 512)
  if (n > 512) 
    n <- 2^ceiling(log2(n))
  if (missing(bw) && !missing(width)) {
    if (is.numeric(width)) {
      fac <- switch(kernel, gaussian = 4, rectangular = 2 * sqrt(3), triangular = 2 * sqrt(6), epanechnikov = 2 * sqrt(5), biweight = 2 * sqrt(7), cosine = 2/sqrt(1/3 - 2/pi^2), optcosine = 2/sqrt(1 - 8/pi^2))
      bw <- width/fac
    }
    if (is.character(width)) 
      bw <- width
  }
  if (is.character(bw)) {
    if (nx < 2) 
      stop("need at least 2 points to select a bandwidth automatically")
    bw <- switch(tolower(bw), nrd0 = bw.nrd0(x), nrd = bw.nrd(x), ucv = bw.ucv(x), bcv = bw.bcv(x), sj = , `sj-ste` = bw.SJ(x, method = "ste"), `sj-dpi` = bw.SJ(x, method = "dpi"), stop("unknown bandwidth rule"))
  }
  if (!is.finite(bw)) 
    stop("non-finite 'bw'")
  bw <- adjust * bw
  if (bw <= 0) 
    stop("'bw' is not positive.")
  if (missing(from)) 
    from <- min(x) - cut * bw
  if (missing(to)) 
    to <- max(x) + cut * bw
  if (!is.finite(from)) 
    stop("non-finite 'from'")
  if (!is.finite(to)) 
    stop("non-finite 'to'")
  lo <- from - 4 * bw
  up <- to + 4 * bw
  y <- .Call(C_BinDist, x, weights, lo, up, n) * totMass
  kords <- seq.int(0, 2 * (up - lo), length.out = 2 * n)
  kords[(n + 2):(2 * n)] <- -kords[n:2]
  kords <- switch(kernel, gaussian = dnorm(kords, sd = bw), rectangular = {
    a <- bw * sqrt(3)
    ifelse(abs(kords) < a, 0.5/a, 0)
  }, triangular = {
    a <- bw * sqrt(6)
    ax <- abs(kords)
    ifelse(ax < a, (1 - ax/a)/a, 0)
  }, epanechnikov = {
    a <- bw * sqrt(5)
    ax <- abs(kords)
    ifelse(ax < a, 3/4 * (1 - (ax/a)^2)/a, 0)
  }, biweight = {
    a <- bw * sqrt(7)
    ax <- abs(kords)
    ifelse(ax < a, 15/16 * (1 - (ax/a)^2)^2/a, 0)
  }, cosine = {
    a <- bw/sqrt(1/3 - 2/pi^2)
    ifelse(abs(kords) < a, (1 + cos(pi * kords/a))/(2 * a), 0)
  }, optcosine = {
    a <- bw/sqrt(1 - 8/pi^2)
    ifelse(abs(kords) < a, pi/4 * cos(pi * kords/(2 * a))/a, 0)
  })
  kords <- fft(fft(y) * Conj(fft(kords)), inverse = TRUE)
  kords <- pmax.int(0, Re(kords)[1:n]/length(y))
  xords <- seq.int(lo, up, length.out = n)
  x <- seq.int(from, to, length.out = n.user)
  structure(list(x = x, y = approx(xords, kords, x)$y, bw = bw, n = N, call = match.call(), data.name = name, has.na = FALSE), class = "density")
}, function (x, bw = "nrd0", adjust = 1, kernel = c("gaussian", "epanechnikov", "rectangular", "triangular", "biweight", "cosine", "optcosine"), weights = NULL, window = kernel, width, give.Rkern = FALSE, subdensity = FALSE, n = 512, from, to, cut = 3, na.rm = FALSE, ...) 
{
  chkDots(...)
  if (!missing(window) && missing(kernel)) 
    kernel <- window
  kernel <- match.arg(kernel)
  if (give.Rkern) 
    return(switch(kernel, gaussian = 1/(2 * sqrt(pi)), rectangular = sqrt(3)/6, triangular = sqrt(6)/9, epanechnikov = 3/(5 * sqrt(5)), biweight = 5 * sqrt(7)/49, cosine = 3/4 * sqrt(1/3 - 2/pi^2), optcosine = sqrt(1 - 8/pi^2) * pi^2/16))
  if (!is.numeric(x)) 
    stop("argument 'x' must be numeric")
  name <- deparse1(substitute(x))
  x <- as.vector(x)
  N <- length(x)
  if (has.wts <- !is.null(weights)) {
    if (length(weights) != N) 
      stop("'x' and 'weights' have unequal length")
    some.na <- FALSE
  }
  x.na <- is.na(x)
  if (any(x.na)) {
    if (na.rm) {
      N <- length(x <- x[!x.na])
      if (has.wts) {
        some.na <- TRUE
        trueD <- isTRUE(all.equal(1, sum(weights)))
        weights <- weights[!x.na]
        if (trueD) 
          weights <- weights/sum(weights)
      }
    }
    else stop("'x' contains missing values")
  }
  nx <- N <- as.integer(N)
  if (is.na(N)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  x.finite <- is.finite(x)
  if (any(!x.finite)) {
    x <- x[x.finite]
    nx <- length(x)
  }
  if (!has.wts) {
    weights <- rep.int(1/nx, nx)
    totMass <- nx/N
  }
  else {
    if (!all(is.finite(weights))) 
      stop("'weights' must all be finite")
    if (any(weights < 0)) 
      stop("'weights' must not be negative")
    wsum <- sum(weights)
    if (any(!x.finite)) {
      weights <- weights[x.finite]
      totMass <- sum(weights)/wsum
    }
    else totMass <- 1
    if (!subdensity && !isTRUE(all.equal(1, wsum))) 
      warning("sum(weights) != 1  -- will not get true density")
  }
  n.user <- n
  n <- max(n, 512)
  if (n > 512) 
    n <- 2^ceiling(log2(n))
  if (missing(bw) && !missing(width)) {
    if (is.numeric(width)) {
      fac <- switch(kernel, gaussian = 4, rectangular = 2 * sqrt(3), triangular = 2 * sqrt(6), epanechnikov = 2 * sqrt(5), biweight = 2 * sqrt(7), cosine = 2/sqrt(1/3 - 2/pi^2), optcosine = 2/sqrt(1 - 8/pi^2))
      bw <- width/fac
    }
    if (is.character(width)) 
      bw <- width
  }
  if (is.character(bw)) {
    if (nx < 2) 
      stop("need at least 2 points to select a bandwidth automatically")
    bw <- switch(tolower(bw), nrd0 = bw.nrd0(x), nrd = bw.nrd(x), ucv = bw.ucv(x), bcv = bw.bcv(x), sj = , `sj-ste` = bw.SJ(x, method = "ste"), `sj-dpi` = bw.SJ(x, method = "dpi"), stop("unknown bandwidth rule"))
  }
  if (!is.finite(bw)) 
    stop("non-finite 'bw'")
  bw <- adjust * bw
  if (bw <= 0) 
    stop("'bw' is not positive.")
  if (missing(from)) 
    from <- min(x) - cut * bw
  if (missing(to)) 
    to <- max(x) + cut * bw
  if (!is.finite(from)) 
    stop("non-finite 'from'")
  if (!is.finite(to)) 
    stop("non-finite 'to'")
  lo <- from - 4 * bw
  up <- to + 4 * bw
  y <- .Call(C_BinDist, x, weights, lo, up, n) * totMass
  kords <- seq.int(0, 2 * (up - lo), length.out = 2 * n)
  kords[(n + 2):(2 * n)] <- -kords[n:2]
  kords <- switch(kernel, gaussian = dnorm(kords, sd = bw), rectangular = {
    a <- bw * sqrt(3)
    ifelse(abs(kords) < a, 0.5/a, 0)
  }, triangular = {
    a <- bw * sqrt(6)
    ax <- abs(kords)
    ifelse(ax < a, (1 - ax/a)/a, 0)
  }, epanechnikov = {
    a <- bw * sqrt(5)
    ax <- abs(kords)
    ifelse(ax < a, 3/4 * (1 - (ax/a)^2)/a, 0)
  }, biweight = {
    a <- bw * sqrt(7)
    ax <- abs(kords)
    ifelse(ax < a, 15/16 * (1 - (ax/a)^2)^2/a, 0)
  }, cosine = {
    a <- bw/sqrt(1/3 - 2/pi^2)
    ifelse(abs(kords) < a, (1 + cos(pi * kords/a))/(2 * a), 0)
  }, optcosine = {
    a <- bw/sqrt(1 - 8/pi^2)
    ifelse(abs(kords) < a, pi/4 * cos(pi * kords/(2 * a))/a, 0)
  })
  kords <- fft(fft(y) * Conj(fft(kords)), inverse = TRUE)
  kords <- pmax.int(0, Re(kords)[1:n]/length(y))
  xords <- seq.int(lo, up, length.out = n)
  x <- seq.int(from, to, length.out = n.user)
  structure(list(x = x, y = approx(xords, kords, x)$y, bw = bw, n = N, call = match.call(), data.name = name, has.na = FALSE), class = "density")
}, function (x, bw = "nrd0", adjust = 1, kernel = c("gaussian", "epanechnikov", "rectangular", "triangular", "biweight", "cosine", "optcosine"), weights = NULL, window = kernel, width, give.Rkern = FALSE, subdensity = FALSE, n = 512, from, to, cut = 3, na.rm = FALSE, ...) 
{
  chkDots(...)
  if (!missing(window) && missing(kernel)) 
    kernel <- window
  kernel <- match.arg(kernel)
  if (give.Rkern) 
    return(switch(kernel, gaussian = 1/(2 * sqrt(pi)), rectangular = sqrt(3)/6, triangular = sqrt(6)/9, epanechnikov = 3/(5 * sqrt(5)), biweight = 5 * sqrt(7)/49, cosine = 3/4 * sqrt(1/3 - 2/pi^2), optcosine = sqrt(1 - 8/pi^2) * pi^2/16))
  if (!is.numeric(x)) 
    stop("argument 'x' must be numeric")
  name <- deparse1(substitute(x))
  x <- as.vector(x)
  N <- length(x)
  if (has.wts <- !is.null(weights)) {
    if (length(weights) != N) 
      stop("'x' and 'weights' have unequal length")
    some.na <- FALSE
  }
  x.na <- is.na(x)
  if (any(x.na)) {
    if (na.rm) {
      N <- length(x <- x[!x.na])
      if (has.wts) {
        some.na <- TRUE
        trueD <- isTRUE(all.equal(1, sum(weights)))
        weights <- weights[!x.na]
        if (trueD) 
          weights <- weights/sum(weights)
      }
    }
    else stop("'x' contains missing values")
  }
  nx <- N <- as.integer(N)
  if (is.na(N)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  x.finite <- is.finite(x)
  if (any(!x.finite)) {
    x <- x[x.finite]
    nx <- length(x)
  }
  if (!has.wts) {
    weights <- rep.int(1/nx, nx)
    totMass <- nx/N
  }
  else {
    if (!all(is.finite(weights))) 
      stop("'weights' must all be finite")
    if (any(weights < 0)) 
      stop("'weights' must not be negative")
    wsum <- sum(weights)
    if (any(!x.finite)) {
      weights <- weights[x.finite]
      totMass <- sum(weights)/wsum
    }
    else totMass <- 1
    if (!subdensity && !isTRUE(all.equal(1, wsum))) 
      warning("sum(weights) != 1  -- will not get true density")
  }
  n.user <- n
  n <- max(n, 512)
  if (n > 512) 
    n <- 2^ceiling(log2(n))
  if (missing(bw) && !missing(width)) {
    if (is.numeric(width)) {
      fac <- switch(kernel, gaussian = 4, rectangular = 2 * sqrt(3), triangular = 2 * sqrt(6), epanechnikov = 2 * sqrt(5), biweight = 2 * sqrt(7), cosine = 2/sqrt(1/3 - 2/pi^2), optcosine = 2/sqrt(1 - 8/pi^2))
      bw <- width/fac
    }
    if (is.character(width)) 
      bw <- width
  }
  if (is.character(bw)) {
    if (nx < 2) 
      stop("need at least 2 points to select a bandwidth automatically")
    bw <- switch(tolower(bw), nrd0 = bw.nrd0(x), nrd = bw.nrd(x), ucv = bw.ucv(x), bcv = bw.bcv(x), sj = , `sj-ste` = bw.SJ(x, method = "ste"), `sj-dpi` = bw.SJ(x, method = "dpi"), stop("unknown bandwidth rule"))
  }
  if (!is.finite(bw)) 
    stop("non-finite 'bw'")
  bw <- adjust * bw
  if (bw <= 0) 
    stop("'bw' is not positive.")
  if (missing(from)) 
    from <- min(x) - cut * bw
  if (missing(to)) 
    to <- max(x) + cut * bw
  if (!is.finite(from)) 
    stop("non-finite 'from'")
  if (!is.finite(to)) 
    stop("non-finite 'to'")
  lo <- from - 4 * bw
  up <- to + 4 * bw
  y <- .Call(C_BinDist, x, weights, lo, up, n) * totMass
  kords <- seq.int(0, 2 * (up - lo), length.out = 2 * n)
  kords[(n + 2):(2 * n)] <- -kords[n:2]
  kords <- switch(kernel, gaussian = dnorm(kords, sd = bw), rectangular = {
    a <- bw * sqrt(3)
    ifelse(abs(kords) < a, 0.5/a, 0)
  }, triangular = {
    a <- bw * sqrt(6)
    ax <- abs(kords)
    ifelse(ax < a, (1 - ax/a)/a, 0)
  }, epanechnikov = {
    a <- bw * sqrt(5)
    ax <- abs(kords)
    ifelse(ax < a, 3/4 * (1 - (ax/a)^2)/a, 0)
  }, biweight = {
    a <- bw * sqrt(7)
    ax <- abs(kords)
    ifelse(ax < a, 15/16 * (1 - (ax/a)^2)^2/a, 0)
  }, cosine = {
    a <- bw/sqrt(1/3 - 2/pi^2)
    ifelse(abs(kords) < a, (1 + cos(pi * kords/a))/(2 * a), 0)
  }, optcosine = {
    a <- bw/sqrt(1 - 8/pi^2)
    ifelse(abs(kords) < a, pi/4 * cos(pi * kords/(2 * a))/a, 0)
  })
  kords <- fft(fft(y) * Conj(fft(kords)), inverse = TRUE)
  kords <- pmax.int(0, Re(kords)[1:n]/length(y))
  xords <- seq.int(lo, up, length.out = n)
  x <- seq.int(from, to, length.out = n.user)
  structure(list(x = x, y = approx(xords, kords, x)$y, bw = bw, n = N, call = match.call(), data.name = name, has.na = FALSE), class = "density")
})
c("package:stats", "registered S3 method for density from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
deriv
list(`package:stats` = function (expr, ...) 
  UseMethod("deriv"), function (expr, ...) 
    UseMethod("deriv"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
deriv3
list(`package:stats` = function (expr, ...) 
  UseMethod("deriv3"), function (expr, ...) 
    UseMethod("deriv3"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
deviance
list(`package:stats` = function (object, ...) 
  UseMethod("deviance"), function (object, ...) 
    UseMethod("deviance"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dexp
list(`package:stats` = function (x, rate = 1, log = FALSE) 
  .Call(C_dexp, x, 1/rate, log), function (x, rate = 1, log = FALSE) 
    .Call(C_dexp, x, 1/rate, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
df
list(`package:stats` = function (x, df1, df2, ncp, log = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_df, x, df1, df2, log)
  else .Call(C_dnf, x, df1, df2, ncp, log)
}, function (x, df1, df2, ncp, log = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_df, x, df1, df2, log)
  else .Call(C_dnf, x, df1, df2, ncp, log)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
df.kernel
list(`package:stats` = function (k) 
{
  2/sum(k[-k$m:k$m]^2)
}, function (k) 
{
  2/sum(k[-k$m:k$m]^2)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
df.residual
list(`package:stats` = function (object, ...) 
  UseMethod("df.residual"), function (object, ...) 
    UseMethod("df.residual"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
DF2formula
list(`package:stats` = function (x, env = parent.frame()) 
{
  nm <- lapply(names(x), as.name)
  mkRHS <- function(nms) Reduce(function(x, y) call("+", x, y), nms)
  ff <- if (length(nm) > 1) 
    call("~", nm[[1]], mkRHS(nm[-1]))
  else if (length(nm) == 1) 
    call("~", nm[[1]])
  else stop("cannot create a formula from a zero-column data frame")
  class(ff) <- "formula"
  environment(ff) <- env
  ff
}, function (x, env = parent.frame()) 
{
  nm <- lapply(names(x), as.name)
  mkRHS <- function(nms) Reduce(function(x, y) call("+", x, y), nms)
  ff <- if (length(nm) > 1) 
    call("~", nm[[1]], mkRHS(nm[-1]))
  else if (length(nm) == 1) 
    call("~", nm[[1]])
  else stop("cannot create a formula from a zero-column data frame")
  class(ff) <- "formula"
  environment(ff) <- env
  ff
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dfbeta
list(`package:stats` = function (model, ...) 
  UseMethod("dfbeta"), function (model, ...) 
    UseMethod("dfbeta"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dfbetas
list(`package:stats` = function (model, ...) 
  UseMethod("dfbetas"), function (model, ...) 
    UseMethod("dfbetas"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dffits
list(`package:stats` = function (model, infl = lm.influence(model, do.coef = FALSE), res = weighted.residuals(model)) 
{
  res <- res * sqrt(infl$hat)/(infl$sigma * (1 - infl$hat))
  res[is.infinite(res)] <- NaN
  res
}, function (model, infl = lm.influence(model, do.coef = FALSE), res = weighted.residuals(model)) 
{
  res <- res * sqrt(infl$hat)/(infl$sigma * (1 - infl$hat))
  res[is.infinite(res)] <- NaN
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dgamma
list(`package:stats` = function (x, shape, rate = 1, scale = 1/rate, log = FALSE) 
{
  if (!missing(rate) && !missing(scale)) {
    if (abs(rate * scale - 1) < 1e-15) 
      warning("specify 'rate' or 'scale' but not both")
    else stop("specify 'rate' or 'scale' but not both")
  }
  .Call(C_dgamma, x, shape, scale, log)
}, function (x, shape, rate = 1, scale = 1/rate, log = FALSE) 
{
  if (!missing(rate) && !missing(scale)) {
    if (abs(rate * scale - 1) < 1e-15) 
      warning("specify 'rate' or 'scale' but not both")
    else stop("specify 'rate' or 'scale' but not both")
  }
  .Call(C_dgamma, x, shape, scale, log)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dgeom
list(`package:stats` = function (x, prob, log = FALSE) 
  .Call(C_dgeom, x, prob, log), function (x, prob, log = FALSE) 
    .Call(C_dgeom, x, prob, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dhyper
list(`package:stats` = function (x, m, n, k, log = FALSE) 
  .Call(C_dhyper, x, m, n, k, log), function (x, m, n, k, log = FALSE) 
    .Call(C_dhyper, x, m, n, k, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
diffinv
list(`package:stats` = function (x, ...) 
{
  UseMethod("diffinv")
}, function (x, ...) 
{
  UseMethod("diffinv")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dist
list(`package:stats` = function (x, method = "euclidean", diag = FALSE, upper = FALSE, p = 2) 
{
  if (!is.na(pmatch(method, "euclidian"))) 
    method <- "euclidean"
  METHODS <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski")
  method <- pmatch(method, METHODS)
  if (is.na(method)) 
    stop("invalid distance method")
  if (method == -1) 
    stop("ambiguous distance method")
  x <- as.matrix(x)
  N <- nrow(x)
  attrs <- if (method == 6) 
    list(Size = N, Labels = dimnames(x)[[1]], Diag = diag, Upper = upper, method = METHODS[method], p = p, call = match.call(), class = "dist")
  else list(Size = N, Labels = dimnames(x)[[1]], Diag = diag, Upper = upper, method = METHODS[method], call = match.call(), class = "dist")
  .Call(C_Cdist, x, method, attrs, p)
}, function (x, method = "euclidean", diag = FALSE, upper = FALSE, p = 2) 
{
  if (!is.na(pmatch(method, "euclidian"))) 
    method <- "euclidean"
  METHODS <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski")
  method <- pmatch(method, METHODS)
  if (is.na(method)) 
    stop("invalid distance method")
  if (method == -1) 
    stop("ambiguous distance method")
  x <- as.matrix(x)
  N <- nrow(x)
  attrs <- if (method == 6) 
    list(Size = N, Labels = dimnames(x)[[1]], Diag = diag, Upper = upper, method = METHODS[method], p = p, call = match.call(), class = "dist")
  else list(Size = N, Labels = dimnames(x)[[1]], Diag = diag, Upper = upper, method = METHODS[method], call = match.call(), class = "dist")
  .Call(C_Cdist, x, method, attrs, p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dlnorm
list(`package:stats` = function (x, meanlog = 0, sdlog = 1, log = FALSE) 
  .Call(C_dlnorm, x, meanlog, sdlog, log), function (x, meanlog = 0, sdlog = 1, log = FALSE) 
    .Call(C_dlnorm, x, meanlog, sdlog, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dlogis
list(`package:stats` = function (x, location = 0, scale = 1, log = FALSE) 
  .Call(C_dlogis, x, location, scale, log), function (x, location = 0, scale = 1, log = FALSE) 
    .Call(C_dlogis, x, location, scale, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dmultinom
list(`package:stats` = function (x, size = NULL, prob, log = FALSE) 
{
  K <- length(prob)
  if (length(x) != K) 
    stop("x[] and prob[] must be equal length vectors.")
  if (any(!is.finite(prob)) || any(prob < 0) || (s <- sum(prob)) == 0) 
    stop("probabilities must be finite, non-negative and not all 0")
  prob <- prob/s
  x <- as.integer(x + 0.5)
  if (any(x < 0)) 
    stop("'x' must be non-negative")
  N <- sum(x)
  if (is.null(size)) 
    size <- N
  else if (size != N) 
    stop("size != sum(x), i.e. one is wrong")
  i0 <- prob == 0
  if (any(i0)) {
    if (any(x[i0] != 0)) 
      return(if (log) -Inf else 0)
    if (all(i0)) 
      return(if (log) 0 else 1)
    x <- x[!i0]
    prob <- prob[!i0]
  }
  r <- lgamma(size + 1) + sum(x * log(prob) - lgamma(x + 1))
  if (log) 
    r
  else exp(r)
}, function (x, size = NULL, prob, log = FALSE) 
{
  K <- length(prob)
  if (length(x) != K) 
    stop("x[] and prob[] must be equal length vectors.")
  if (any(!is.finite(prob)) || any(prob < 0) || (s <- sum(prob)) == 0) 
    stop("probabilities must be finite, non-negative and not all 0")
  prob <- prob/s
  x <- as.integer(x + 0.5)
  if (any(x < 0)) 
    stop("'x' must be non-negative")
  N <- sum(x)
  if (is.null(size)) 
    size <- N
  else if (size != N) 
    stop("size != sum(x), i.e. one is wrong")
  i0 <- prob == 0
  if (any(i0)) {
    if (any(x[i0] != 0)) 
      return(if (log) -Inf else 0)
    if (all(i0)) 
      return(if (log) 0 else 1)
    x <- x[!i0]
    prob <- prob[!i0]
  }
  r <- lgamma(size + 1) + sum(x * log(prob) - lgamma(x + 1))
  if (log) 
    r
  else exp(r)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dnbinom
list(`package:stats` = function (x, size, prob, mu, log = FALSE) 
{
  if (!missing(mu)) {
    if (!missing(prob)) 
      stop("'prob' and 'mu' both specified")
    .Call(C_dnbinom_mu, x, size, mu, log)
  }
  else .Call(C_dnbinom, x, size, prob, log)
}, function (x, size, prob, mu, log = FALSE) 
{
  if (!missing(mu)) {
    if (!missing(prob)) 
      stop("'prob' and 'mu' both specified")
    .Call(C_dnbinom_mu, x, size, mu, log)
  }
  else .Call(C_dnbinom, x, size, prob, log)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dnorm
list(`package:stats` = function (x, mean = 0, sd = 1, log = FALSE) 
  .Call(C_dnorm, x, mean, sd, log), function (x, mean = 0, sd = 1, log = FALSE) 
    .Call(C_dnorm, x, mean, sd, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dpois
list(`package:stats` = function (x, lambda, log = FALSE) 
  .Call(C_dpois, x, lambda, log), function (x, lambda, log = FALSE) 
    .Call(C_dpois, x, lambda, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
drop.scope
list(`package:stats` = function (terms1, terms2) 
{
  terms1 <- terms(terms1)
  f2 <- if (missing(terms2)) 
    numeric()
  else attr(terms(terms2), "factors")
  factor.scope(attr(terms1, "factors"), list(drop = f2))$drop
}, function (terms1, terms2) 
{
  terms1 <- terms(terms1)
  f2 <- if (missing(terms2)) 
    numeric()
  else attr(terms(terms2), "factors")
  factor.scope(attr(terms1, "factors"), list(drop = f2))$drop
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
drop.terms
list(`package:stats` = function (termobj, dropx = NULL, keep.response = FALSE) 
{
  if (is.null(dropx)) 
    termobj
  else {
    if (!inherits(termobj, "terms")) 
      stop(gettextf("'termobj' must be a object of class %s", dQuote("terms")), domain = NA)
    newformula <- reformulate(attr(termobj, "term.labels")[-dropx], response = if (keep.response) 
      termobj[[2]], intercept = attr(termobj, "intercept"), env = environment(termobj))
    result <- terms(newformula, specials = names(attr(termobj, "specials")))
    response <- attr(termobj, "response")
    dropOpt <- if (response && !keep.response) 
      c(response, dropx + length(response))
    else dropx + max(response)
    if (!is.null(predvars <- attr(termobj, "predvars"))) {
      attr(result, "predvars") <- predvars[-(dropOpt + 1)]
    }
    if (!is.null(dataClasses <- attr(termobj, "dataClasses"))) {
      attr(result, "dataClasses") <- dataClasses[-dropOpt]
    }
    result
  }
}, function (termobj, dropx = NULL, keep.response = FALSE) 
{
  if (is.null(dropx)) 
    termobj
  else {
    if (!inherits(termobj, "terms")) 
      stop(gettextf("'termobj' must be a object of class %s", dQuote("terms")), domain = NA)
    newformula <- reformulate(attr(termobj, "term.labels")[-dropx], response = if (keep.response) 
      termobj[[2]], intercept = attr(termobj, "intercept"), env = environment(termobj))
    result <- terms(newformula, specials = names(attr(termobj, "specials")))
    response <- attr(termobj, "response")
    dropOpt <- if (response && !keep.response) 
      c(response, dropx + length(response))
    else dropx + max(response)
    if (!is.null(predvars <- attr(termobj, "predvars"))) {
      attr(result, "predvars") <- predvars[-(dropOpt + 1)]
    }
    if (!is.null(dataClasses <- attr(termobj, "dataClasses"))) {
      attr(result, "dataClasses") <- dataClasses[-dropOpt]
    }
    result
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
drop1
list(`package:stats` = function (object, scope, ...) 
  UseMethod("drop1"), function (object, scope, ...) 
    UseMethod("drop1"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dsignrank
list(`package:stats` = function (x, n, log = FALSE) 
{
  on.exit(.External(C_signrank_free))
  .Call(C_dsignrank, x, n, log)
}, function (x, n, log = FALSE) 
{
  on.exit(.External(C_signrank_free))
  .Call(C_dsignrank, x, n, log)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dt
list(`package:stats` = function (x, df, ncp, log = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_dt, x, df, log)
  else .Call(C_dnt, x, df, ncp, log)
}, function (x, df, ncp, log = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_dt, x, df, log)
  else .Call(C_dnt, x, df, ncp, log)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dummy.coef
list(`package:stats` = function (object, ...) 
  UseMethod("dummy.coef"), function (object, ...) 
    UseMethod("dummy.coef"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dummy.coef.lm
list(`package:stats` = function (object, use.na = FALSE, ...) 
{
  xl <- object$xlevels
  if (!length(xl)) 
    return(as.list(coef(object)))
  Terms <- terms(object)
  tl <- attr(Terms, "term.labels")
  int <- attr(Terms, "intercept")
  facs <- attr(Terms, "factors")[-1, , drop = FALSE]
  Terms <- delete.response(Terms)
  mf <- object$model %||% model.frame(object)
  vars <- dimnames(facs)[[1]]
  xtlv <- lapply(mf[, vars, drop = FALSE], levels)
  nxl <- pmax(lengths(xtlv), 1)
  lterms <- apply(facs, 2, function(x) prod(nxl[x > 0]))
  nl <- sum(lterms)
  args <- sapply(vars, function(i) if (nxl[i] == 1) 
    rep.int(1, nl)
    else factor(rep.int(xtlv[[i]][1], nl), levels = xtlv[[i]]), simplify = FALSE)
  dummy <- do.call(data.frame, args)
  names(dummy) <- vars
  pos <- 0
  rn <- rep.int(tl, lterms)
  rnn <- character(nl)
  for (j in tl) {
    i <- vars[facs[, j] > 0]
    ifac <- i[nxl[i] > 1]
    lt.j <- lterms[[j]]
    if (length(ifac) == 0) {
      rnn[pos + 1] <- j
    }
    else {
      p.j <- pos + seq_len(lt.j)
      if (length(ifac) == 1) {
        dummy[p.j, ifac] <- x.i <- xtlv[[ifac]]
        rnn[p.j] <- as.character(x.i)
      }
      else {
        tmp <- expand.grid(xtlv[ifac], KEEP.OUT.ATTRS = FALSE)
        dummy[p.j, ifac] <- tmp
        rnn[p.j] <- apply(as.matrix(tmp), 1, paste, collapse = ":")
      }
    }
    pos <- pos + lt.j
  }
  attr(dummy, "terms") <- attr(mf, "terms")
  lcontr <- object$contrasts
  lci <- vapply(dummy, is.factor, NA)
  lcontr <- lcontr[names(lci)[lci]]
  mm <- model.matrix(Terms, dummy, lcontr, xl)
  if (anyNA(mm)) {
    warning("some terms will have NAs due to the limits of the method")
    mm[is.na(mm)] <- NA
  }
  coef <- object$coefficients
  if (!use.na) 
    coef[is.na(coef)] <- 0
  asgn <- attr(mm, "assign")
  res <- setNames(vector("list", length(tl)), tl)
  if (isM <- is.matrix(coef)) {
    for (j in seq_along(tl)) {
      keep <- which(asgn == j)
      cf <- coef[keep, , drop = FALSE]
      ij <- rn == tl[j]
      cf <- if (any(na <- is.na(cf))) {
        if (ncol(cf) >= 2) 
          stop("multivariate case with missing coefficients is not yet implemented")
        rj <- t(mm[ij, keep[!na], drop = FALSE] %*% cf[!na])
        rj[apply(mm[ij, keep[na], drop = FALSE] != 0, 1, any)] <- NA
        rj
      }
      else t(mm[ij, keep, drop = FALSE] %*% cf)
      dimnames(cf) <- list(colnames(coef), rnn[ij])
      res[[j]] <- cf
    }
  }
  else {
    for (j in seq_along(tl)) {
      keep <- which(asgn == j)
      cf <- coef[keep]
      ij <- rn == tl[j]
      res[[j]] <- if (any(na <- is.na(cf))) {
        rj <- setNames(drop(mm[ij, keep[!na], drop = FALSE] %*% cf[!na]), rnn[ij])
        rj[apply(mm[ij, keep[na], drop = FALSE] != 0, 1, any)] <- NA
        rj
      }
      else setNames(drop(mm[ij, keep, drop = FALSE] %*% cf), rnn[ij])
    }
  }
  if (int > 0) 
    res <- c(list(`(Intercept)` = if (isM) coef[int, ] else coef[int]), res)
  structure(res, class = "dummy_coef", matrix = isM)
}, function (object, use.na = FALSE, ...) 
{
  xl <- object$xlevels
  if (!length(xl)) 
    return(as.list(coef(object)))
  Terms <- terms(object)
  tl <- attr(Terms, "term.labels")
  int <- attr(Terms, "intercept")
  facs <- attr(Terms, "factors")[-1, , drop = FALSE]
  Terms <- delete.response(Terms)
  mf <- object$model %||% model.frame(object)
  vars <- dimnames(facs)[[1]]
  xtlv <- lapply(mf[, vars, drop = FALSE], levels)
  nxl <- pmax(lengths(xtlv), 1)
  lterms <- apply(facs, 2, function(x) prod(nxl[x > 0]))
  nl <- sum(lterms)
  args <- sapply(vars, function(i) if (nxl[i] == 1) 
    rep.int(1, nl)
    else factor(rep.int(xtlv[[i]][1], nl), levels = xtlv[[i]]), simplify = FALSE)
  dummy <- do.call(data.frame, args)
  names(dummy) <- vars
  pos <- 0
  rn <- rep.int(tl, lterms)
  rnn <- character(nl)
  for (j in tl) {
    i <- vars[facs[, j] > 0]
    ifac <- i[nxl[i] > 1]
    lt.j <- lterms[[j]]
    if (length(ifac) == 0) {
      rnn[pos + 1] <- j
    }
    else {
      p.j <- pos + seq_len(lt.j)
      if (length(ifac) == 1) {
        dummy[p.j, ifac] <- x.i <- xtlv[[ifac]]
        rnn[p.j] <- as.character(x.i)
      }
      else {
        tmp <- expand.grid(xtlv[ifac], KEEP.OUT.ATTRS = FALSE)
        dummy[p.j, ifac] <- tmp
        rnn[p.j] <- apply(as.matrix(tmp), 1, paste, collapse = ":")
      }
    }
    pos <- pos + lt.j
  }
  attr(dummy, "terms") <- attr(mf, "terms")
  lcontr <- object$contrasts
  lci <- vapply(dummy, is.factor, NA)
  lcontr <- lcontr[names(lci)[lci]]
  mm <- model.matrix(Terms, dummy, lcontr, xl)
  if (anyNA(mm)) {
    warning("some terms will have NAs due to the limits of the method")
    mm[is.na(mm)] <- NA
  }
  coef <- object$coefficients
  if (!use.na) 
    coef[is.na(coef)] <- 0
  asgn <- attr(mm, "assign")
  res <- setNames(vector("list", length(tl)), tl)
  if (isM <- is.matrix(coef)) {
    for (j in seq_along(tl)) {
      keep <- which(asgn == j)
      cf <- coef[keep, , drop = FALSE]
      ij <- rn == tl[j]
      cf <- if (any(na <- is.na(cf))) {
        if (ncol(cf) >= 2) 
          stop("multivariate case with missing coefficients is not yet implemented")
        rj <- t(mm[ij, keep[!na], drop = FALSE] %*% cf[!na])
        rj[apply(mm[ij, keep[na], drop = FALSE] != 0, 1, any)] <- NA
        rj
      }
      else t(mm[ij, keep, drop = FALSE] %*% cf)
      dimnames(cf) <- list(colnames(coef), rnn[ij])
      res[[j]] <- cf
    }
  }
  else {
    for (j in seq_along(tl)) {
      keep <- which(asgn == j)
      cf <- coef[keep]
      ij <- rn == tl[j]
      res[[j]] <- if (any(na <- is.na(cf))) {
        rj <- setNames(drop(mm[ij, keep[!na], drop = FALSE] %*% cf[!na]), rnn[ij])
        rj[apply(mm[ij, keep[na], drop = FALSE] != 0, 1, any)] <- NA
        rj
      }
      else setNames(drop(mm[ij, keep, drop = FALSE] %*% cf), rnn[ij])
    }
  }
  if (int > 0) 
    res <- c(list(`(Intercept)` = if (isM) coef[int, ] else coef[int]), res)
  structure(res, class = "dummy_coef", matrix = isM)
}, function (object, use.na = FALSE, ...) 
{
  xl <- object$xlevels
  if (!length(xl)) 
    return(as.list(coef(object)))
  Terms <- terms(object)
  tl <- attr(Terms, "term.labels")
  int <- attr(Terms, "intercept")
  facs <- attr(Terms, "factors")[-1, , drop = FALSE]
  Terms <- delete.response(Terms)
  mf <- object$model %||% model.frame(object)
  vars <- dimnames(facs)[[1]]
  xtlv <- lapply(mf[, vars, drop = FALSE], levels)
  nxl <- pmax(lengths(xtlv), 1)
  lterms <- apply(facs, 2, function(x) prod(nxl[x > 0]))
  nl <- sum(lterms)
  args <- sapply(vars, function(i) if (nxl[i] == 1) 
    rep.int(1, nl)
    else factor(rep.int(xtlv[[i]][1], nl), levels = xtlv[[i]]), simplify = FALSE)
  dummy <- do.call(data.frame, args)
  names(dummy) <- vars
  pos <- 0
  rn <- rep.int(tl, lterms)
  rnn <- character(nl)
  for (j in tl) {
    i <- vars[facs[, j] > 0]
    ifac <- i[nxl[i] > 1]
    lt.j <- lterms[[j]]
    if (length(ifac) == 0) {
      rnn[pos + 1] <- j
    }
    else {
      p.j <- pos + seq_len(lt.j)
      if (length(ifac) == 1) {
        dummy[p.j, ifac] <- x.i <- xtlv[[ifac]]
        rnn[p.j] <- as.character(x.i)
      }
      else {
        tmp <- expand.grid(xtlv[ifac], KEEP.OUT.ATTRS = FALSE)
        dummy[p.j, ifac] <- tmp
        rnn[p.j] <- apply(as.matrix(tmp), 1, paste, collapse = ":")
      }
    }
    pos <- pos + lt.j
  }
  attr(dummy, "terms") <- attr(mf, "terms")
  lcontr <- object$contrasts
  lci <- vapply(dummy, is.factor, NA)
  lcontr <- lcontr[names(lci)[lci]]
  mm <- model.matrix(Terms, dummy, lcontr, xl)
  if (anyNA(mm)) {
    warning("some terms will have NAs due to the limits of the method")
    mm[is.na(mm)] <- NA
  }
  coef <- object$coefficients
  if (!use.na) 
    coef[is.na(coef)] <- 0
  asgn <- attr(mm, "assign")
  res <- setNames(vector("list", length(tl)), tl)
  if (isM <- is.matrix(coef)) {
    for (j in seq_along(tl)) {
      keep <- which(asgn == j)
      cf <- coef[keep, , drop = FALSE]
      ij <- rn == tl[j]
      cf <- if (any(na <- is.na(cf))) {
        if (ncol(cf) >= 2) 
          stop("multivariate case with missing coefficients is not yet implemented")
        rj <- t(mm[ij, keep[!na], drop = FALSE] %*% cf[!na])
        rj[apply(mm[ij, keep[na], drop = FALSE] != 0, 1, any)] <- NA
        rj
      }
      else t(mm[ij, keep, drop = FALSE] %*% cf)
      dimnames(cf) <- list(colnames(coef), rnn[ij])
      res[[j]] <- cf
    }
  }
  else {
    for (j in seq_along(tl)) {
      keep <- which(asgn == j)
      cf <- coef[keep]
      ij <- rn == tl[j]
      res[[j]] <- if (any(na <- is.na(cf))) {
        rj <- setNames(drop(mm[ij, keep[!na], drop = FALSE] %*% cf[!na]), rnn[ij])
        rj[apply(mm[ij, keep[na], drop = FALSE] != 0, 1, any)] <- NA
        rj
      }
      else setNames(drop(mm[ij, keep, drop = FALSE] %*% cf), rnn[ij])
    }
  }
  if (int > 0) 
    res <- c(list(`(Intercept)` = if (isM) coef[int, ] else coef[int]), res)
  structure(res, class = "dummy_coef", matrix = isM)
})
c("package:stats", "registered S3 method for dummy.coef from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
dunif
list(`package:stats` = function (x, min = 0, max = 1, log = FALSE) 
  .Call(C_dunif, x, min, max, log), function (x, min = 0, max = 1, log = FALSE) 
    .Call(C_dunif, x, min, max, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dweibull
list(`package:stats` = function (x, shape, scale = 1, log = FALSE) 
  .Call(C_dweibull, x, shape, scale, log), function (x, shape, scale = 1, log = FALSE) 
    .Call(C_dweibull, x, shape, scale, log))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
dwilcox
list(`package:stats` = function (x, m, n, log = FALSE) 
{
  on.exit(.External(C_wilcox_free))
  .Call(C_dwilcox, x, m, n, log)
}, function (x, m, n, log = FALSE) 
{
  on.exit(.External(C_wilcox_free))
  .Call(C_dwilcox, x, m, n, log)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ecdf
list(`package:stats` = function (x) 
{
  x <- sort(x)
  n <- length(x)
  if (n < 1) 
    stop("'x' must have 1 or more non-missing values")
  vals <- unique(x)
  rval <- approxfun(vals, cumsum(tabulate(match(x, vals)))/n, method = "constant", yleft = 0, yright = 1, f = 0, ties = "ordered")
  class(rval) <- c("ecdf", "stepfun", class(rval))
  assign("nobs", n, envir = environment(rval))
  attr(rval, "call") <- sys.call()
  rval
}, function (x) 
{
  x <- sort(x)
  n <- length(x)
  if (n < 1) 
    stop("'x' must have 1 or more non-missing values")
  vals <- unique(x)
  rval <- approxfun(vals, cumsum(tabulate(match(x, vals)))/n, method = "constant", yleft = 0, yright = 1, f = 0, ties = "ordered")
  class(rval) <- c("ecdf", "stepfun", class(rval))
  assign("nobs", n, envir = environment(rval))
  attr(rval, "call") <- sys.call()
  rval
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
eff.aovlist
list(`package:stats` = function (aovlist) 
{
  Terms <- terms(aovlist)
  if (names(aovlist)[[1]] == "(Intercept)") 
    aovlist <- aovlist[-1]
  pure.error.strata <- sapply(aovlist, function(x) is.null(x$qr))
  aovlist <- aovlist[!pure.error.strata]
  s.labs <- names(aovlist)
  s.terms <- lapply(aovlist, function(x) {
    asgn <- x$assign[x$qr$pivot[1:x$rank]]
    attr(terms(x), "term.labels")[asgn]
  })
  t.labs <- attr(Terms, "term.labels")
  t.labs <- t.labs[t.labs %in% unlist(s.terms)]
  eff <- matrix(0, ncol = length(t.labs), nrow = length(s.labs), dimnames = list(s.labs, t.labs))
  for (i in names(s.terms)) eff[i, s.terms[[i]]] <- 1
  cs <- colSums(eff)
  if (all(cs <= 1)) 
    return(eff[, cs > 0, drop = FALSE])
  nm <- t.labs[cs > 1]
  pl <- lapply(aovlist, function(x) {
    asgn <- x$assign[x$qr$pivot[1:x$rank]]
    sp <- split(seq_along(asgn), attr(terms(x), "term.labels")[asgn])
    sp <- sp[names(sp) %in% nm]
    sapply(sp, function(x, y) {
      y <- y[x, x, drop = FALSE]
      res <- sum(diag(y)^2)
      if (nrow(y) > 1 && sum(y^2) > 1.01 * res) 
        stop("eff.aovlist: non-orthogonal contrasts would give an incorrect answer")
      res
    }, y = x$qr$qr)
  })
  for (i in names(pl)) eff[i, names(pl[[i]])] <- pl[[i]]
  cs <- colSums(eff)
  eff <- eff/rep(cs, each = nrow(eff))
  eff[, cs != 0, drop = FALSE]
}, function (aovlist) 
{
  Terms <- terms(aovlist)
  if (names(aovlist)[[1]] == "(Intercept)") 
    aovlist <- aovlist[-1]
  pure.error.strata <- sapply(aovlist, function(x) is.null(x$qr))
  aovlist <- aovlist[!pure.error.strata]
  s.labs <- names(aovlist)
  s.terms <- lapply(aovlist, function(x) {
    asgn <- x$assign[x$qr$pivot[1:x$rank]]
    attr(terms(x), "term.labels")[asgn]
  })
  t.labs <- attr(Terms, "term.labels")
  t.labs <- t.labs[t.labs %in% unlist(s.terms)]
  eff <- matrix(0, ncol = length(t.labs), nrow = length(s.labs), dimnames = list(s.labs, t.labs))
  for (i in names(s.terms)) eff[i, s.terms[[i]]] <- 1
  cs <- colSums(eff)
  if (all(cs <= 1)) 
    return(eff[, cs > 0, drop = FALSE])
  nm <- t.labs[cs > 1]
  pl <- lapply(aovlist, function(x) {
    asgn <- x$assign[x$qr$pivot[1:x$rank]]
    sp <- split(seq_along(asgn), attr(terms(x), "term.labels")[asgn])
    sp <- sp[names(sp) %in% nm]
    sapply(sp, function(x, y) {
      y <- y[x, x, drop = FALSE]
      res <- sum(diag(y)^2)
      if (nrow(y) > 1 && sum(y^2) > 1.01 * res) 
        stop("eff.aovlist: non-orthogonal contrasts would give an incorrect answer")
      res
    }, y = x$qr$qr)
  })
  for (i in names(pl)) eff[i, names(pl[[i]])] <- pl[[i]]
  cs <- colSums(eff)
  eff <- eff/rep(cs, each = nrow(eff))
  eff[, cs != 0, drop = FALSE]
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
effects
list(`package:stats` = function (object, ...) 
  UseMethod("effects"), function (object, ...) 
    UseMethod("effects"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
embed
list(`package:stats` = function (x, dimension = 1) 
{
  if (is.matrix(x)) {
    n <- nrow(x)
    m <- ncol(x)
    if ((dimension < 1) || (dimension > n)) 
      stop("wrong embedding dimension")
    y <- matrix(0, n - dimension + 1, dimension * m)
    for (i in seq_len(m)) y[, seq.int(i, by = m, length.out = dimension)] <- Recall(as.vector(x[, i]), dimension)
    return(y)
  }
  else if (is.vector(x) || is.ts(x)) {
    n <- length(x)
    if ((dimension < 1) || (dimension > n)) 
      stop("wrong embedding dimension")
    m <- n - dimension + 1
    data <- x[1:m + rep.int(dimension:1, rep.int(m, dimension)) - 1]
    dim(data) <- c(m, dimension)
    return(data)
  }
  else stop("'x' is not a vector or matrix")
}, function (x, dimension = 1) 
{
  if (is.matrix(x)) {
    n <- nrow(x)
    m <- ncol(x)
    if ((dimension < 1) || (dimension > n)) 
      stop("wrong embedding dimension")
    y <- matrix(0, n - dimension + 1, dimension * m)
    for (i in seq_len(m)) y[, seq.int(i, by = m, length.out = dimension)] <- Recall(as.vector(x[, i]), dimension)
    return(y)
  }
  else if (is.vector(x) || is.ts(x)) {
    n <- length(x)
    if ((dimension < 1) || (dimension > n)) 
      stop("wrong embedding dimension")
    m <- n - dimension + 1
    data <- x[1:m + rep.int(dimension:1, rep.int(m, dimension)) - 1]
    dim(data) <- c(m, dimension)
    return(data)
  }
  else stop("'x' is not a vector or matrix")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
end
list(`package:stats` = function (x, ...) 
  UseMethod("end"), function (x, ...) 
    UseMethod("end"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
estVar
list(`package:stats` = function (object, ...) 
  UseMethod("estVar"), function (object, ...) 
    UseMethod("estVar"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
expand.model.frame
list(`package:stats` = function (model, extras, envir = environment(formula(model)), na.expand = FALSE) 
{
  f <- formula(model)
  data <- eval(model$call$data, envir)
  ff <- foo ~ bar + baz
  gg <- if (is.call(extras)) 
    extras
  else str2lang(paste("~", paste(extras, collapse = "+")))
  ff[[2]] <- f[[2]]
  ff[[3]][[2]] <- f[[3]]
  ff[[3]][[3]] <- gg[[2]]
  if (!na.expand) {
    naa <- model$call$na.action
    subset <- model$call$subset
    rval <- eval(call("model.frame", ff, data = data, subset = subset, na.action = naa), envir)
  }
  else {
    subset <- model$call$subset
    rval <- eval(call("model.frame", ff, data = data, subset = subset, na.action = I), envir)
    oldmf <- model.frame(model)
    keep <- match(rownames(oldmf), rownames(rval))
    rval <- rval[keep, ]
    class(rval) <- "data.frame"
  }
  return(rval)
}, function (model, extras, envir = environment(formula(model)), na.expand = FALSE) 
{
  f <- formula(model)
  data <- eval(model$call$data, envir)
  ff <- foo ~ bar + baz
  gg <- if (is.call(extras)) 
    extras
  else str2lang(paste("~", paste(extras, collapse = "+")))
  ff[[2]] <- f[[2]]
  ff[[3]][[2]] <- f[[3]]
  ff[[3]][[3]] <- gg[[2]]
  if (!na.expand) {
    naa <- model$call$na.action
    subset <- model$call$subset
    rval <- eval(call("model.frame", ff, data = data, subset = subset, na.action = naa), envir)
  }
  else {
    subset <- model$call$subset
    rval <- eval(call("model.frame", ff, data = data, subset = subset, na.action = I), envir)
    oldmf <- model.frame(model)
    keep <- match(rownames(oldmf), rownames(rval))
    rval <- rval[keep, ]
    class(rval) <- "data.frame"
  }
  return(rval)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
extractAIC
list(`package:stats` = function (fit, scale, k = 2, ...) 
  UseMethod("extractAIC"), function (fit, scale, k = 2, ...) 
    UseMethod("extractAIC"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
factanal
list(`package:stats` = function (x, factors, data = NULL, covmat = NULL, n.obs = NA, subset, na.action, start = NULL, scores = c("none", "regression", "Bartlett"), rotation = "varimax", control = NULL, ...) 
{
  sortLoadings <- function(Lambda) {
    cn <- colnames(Lambda)
    Phi <- attr(Lambda, "covariance")
    ssq <- apply(Lambda, 2, function(x) -sum(x^2))
    Lambda <- Lambda[, order(ssq), drop = FALSE]
    colnames(Lambda) <- cn
    neg <- colSums(Lambda) < 0
    Lambda[, neg] <- -Lambda[, neg]
    if (!is.null(Phi)) {
      unit <- ifelse(neg, -1, 1)
      attr(Lambda, "covariance") <- unit %*% Phi[order(ssq), order(ssq)] %*% unit
    }
    Lambda
  }
  cl <- match.call()
  na.act <- NULL
  if (is.list(covmat)) {
    if (anyNA(match(c("cov", "n.obs"), names(covmat)))) 
      stop("'covmat' is not a valid covariance list")
    cv <- covmat$cov
    n.obs <- covmat$n.obs
    have.x <- FALSE
  }
  else if (is.matrix(covmat)) {
    cv <- covmat
    have.x <- FALSE
  }
  else if (is.null(covmat)) {
    if (missing(x)) 
      stop("neither 'x' nor 'covmat' supplied")
    have.x <- TRUE
    if (inherits(x, "formula")) {
      mt <- terms(x, data = data)
      if (attr(mt, "response") > 0) 
        stop("response not allowed in formula")
      attr(mt, "intercept") <- 0
      mf <- match.call(expand.dots = FALSE)
      names(mf)[names(mf) == "x"] <- "formula"
      mf$factors <- mf$covmat <- mf$scores <- mf$start <- mf$rotation <- mf$control <- mf$... <- NULL
      mf[[1]] <- quote(stats::model.frame)
      mf <- eval.parent(mf)
      na.act <- attr(mf, "na.action")
      if (.check_vars_numeric(mf)) 
        stop("factor analysis applies only to numerical variables")
      z <- model.matrix(mt, mf)
    }
    else {
      z <- as.matrix(x)
      if (!is.numeric(z)) 
        stop("factor analysis applies only to numerical variables")
      if (!missing(subset)) 
        z <- z[subset, , drop = FALSE]
    }
    covmat <- cov.wt(z)
    cv <- covmat$cov
    n.obs <- covmat$n.obs
  }
  else stop("'covmat' is of unknown type")
  scores <- match.arg(scores)
  if (scores != "none" && !have.x) 
    stop("requested scores without an 'x' matrix")
  p <- ncol(cv)
  if (p < 3) 
    stop("factor analysis requires at least three variables")
  dof <- 0.5 * ((p - factors)^2 - p - factors)
  if (dof < 0) 
    stop(sprintf(ngettext(factors, "%d factor is too many for %d variables", "%d factors are too many for %d variables"), factors, p), domain = NA)
  sds <- sqrt(diag(cv))
  cv <- cv/(sds %o% sds)
  cn <- list(nstart = 1, trace = FALSE, lower = 0.005)
  cn[names(control)] <- control
  more <- list(...)[c("nstart", "trace", "lower", "opt", "rotate")]
  if (length(more)) 
    cn[names(more)] <- more
  if (is.null(start)) {
    start <- (1 - 0.5 * factors/p)/diag(solve(cv))
    if ((ns <- cn$nstart) > 1) 
      start <- cbind(start, matrix(runif(ns - 1), p, ns - 1, byrow = TRUE))
  }
  start <- as.matrix(start)
  if (nrow(start) != p) 
    stop(sprintf(ngettext(p, "'start' must have %d row", "'start' must have %d rows"), p), domain = NA)
  nc <- ncol(start)
  if (nc < 1) 
    stop("no starting values supplied")
  best <- Inf
  for (i in 1:nc) {
    nfit <- factanal.fit.mle(cv, factors, start[, i], max(cn$lower, 0), cn$opt)
    if (cn$trace) 
      cat("start", i, "value:", format(nfit$criteria[1]), "uniqs:", format(as.vector(round(nfit$uniquenesses, 4))), "\n")
    if (nfit$converged && nfit$criteria[1] < best) {
      fit <- nfit
      best <- fit$criteria[1]
    }
  }
  if (best == Inf) 
    stop(ngettext(nc, "unable to optimize from this starting value", "unable to optimize from these starting values"), domain = NA)
  load <- fit$loadings
  if (rotation != "none") {
    rot <- do.call(rotation, c(list(load), cn$rotate))
    load <- if (is.list(rot)) {
      load <- rot$loadings
      fit$rotmat <- if (inherits(rot, "GPArotation")) 
        t(solve(rot$Th))
      else rot$rotmat
      rot$loadings
    }
    else rot
  }
  fit$loadings <- sortLoadings(load)
  class(fit$loadings) <- "loadings"
  fit$na.action <- na.act
  if (have.x && scores != "none") {
    Lambda <- fit$loadings
    zz <- scale(z, TRUE, TRUE)
    switch(scores, regression = {
      sc <- zz %*% solve(cv, Lambda)
      if (!is.null(Phi <- attr(Lambda, "covariance"))) sc <- sc %*% Phi
    }, Bartlett = {
      d <- 1/fit$uniquenesses
      tmp <- t(Lambda * d)
      sc <- t(solve(tmp %*% Lambda, tmp %*% t(zz)))
    })
    rownames(sc) <- rownames(z)
    colnames(sc) <- colnames(Lambda)
    if (!is.null(na.act)) 
      sc <- napredict(na.act, sc)
    fit$scores <- sc
  }
  if (!is.na(n.obs) && dof > 0) {
    fit$STATISTIC <- (n.obs - 1 - (2 * p + 5)/6 - (2 * factors)/3) * fit$criteria["objective"]
    fit$PVAL <- pchisq(fit$STATISTIC, dof, lower.tail = FALSE)
  }
  fit$n.obs <- n.obs
  fit$call <- cl
  fit
}, function (x, factors, data = NULL, covmat = NULL, n.obs = NA, subset, na.action, start = NULL, scores = c("none", "regression", "Bartlett"), rotation = "varimax", control = NULL, ...) 
{
  sortLoadings <- function(Lambda) {
    cn <- colnames(Lambda)
    Phi <- attr(Lambda, "covariance")
    ssq <- apply(Lambda, 2, function(x) -sum(x^2))
    Lambda <- Lambda[, order(ssq), drop = FALSE]
    colnames(Lambda) <- cn
    neg <- colSums(Lambda) < 0
    Lambda[, neg] <- -Lambda[, neg]
    if (!is.null(Phi)) {
      unit <- ifelse(neg, -1, 1)
      attr(Lambda, "covariance") <- unit %*% Phi[order(ssq), order(ssq)] %*% unit
    }
    Lambda
  }
  cl <- match.call()
  na.act <- NULL
  if (is.list(covmat)) {
    if (anyNA(match(c("cov", "n.obs"), names(covmat)))) 
      stop("'covmat' is not a valid covariance list")
    cv <- covmat$cov
    n.obs <- covmat$n.obs
    have.x <- FALSE
  }
  else if (is.matrix(covmat)) {
    cv <- covmat
    have.x <- FALSE
  }
  else if (is.null(covmat)) {
    if (missing(x)) 
      stop("neither 'x' nor 'covmat' supplied")
    have.x <- TRUE
    if (inherits(x, "formula")) {
      mt <- terms(x, data = data)
      if (attr(mt, "response") > 0) 
        stop("response not allowed in formula")
      attr(mt, "intercept") <- 0
      mf <- match.call(expand.dots = FALSE)
      names(mf)[names(mf) == "x"] <- "formula"
      mf$factors <- mf$covmat <- mf$scores <- mf$start <- mf$rotation <- mf$control <- mf$... <- NULL
      mf[[1]] <- quote(stats::model.frame)
      mf <- eval.parent(mf)
      na.act <- attr(mf, "na.action")
      if (.check_vars_numeric(mf)) 
        stop("factor analysis applies only to numerical variables")
      z <- model.matrix(mt, mf)
    }
    else {
      z <- as.matrix(x)
      if (!is.numeric(z)) 
        stop("factor analysis applies only to numerical variables")
      if (!missing(subset)) 
        z <- z[subset, , drop = FALSE]
    }
    covmat <- cov.wt(z)
    cv <- covmat$cov
    n.obs <- covmat$n.obs
  }
  else stop("'covmat' is of unknown type")
  scores <- match.arg(scores)
  if (scores != "none" && !have.x) 
    stop("requested scores without an 'x' matrix")
  p <- ncol(cv)
  if (p < 3) 
    stop("factor analysis requires at least three variables")
  dof <- 0.5 * ((p - factors)^2 - p - factors)
  if (dof < 0) 
    stop(sprintf(ngettext(factors, "%d factor is too many for %d variables", "%d factors are too many for %d variables"), factors, p), domain = NA)
  sds <- sqrt(diag(cv))
  cv <- cv/(sds %o% sds)
  cn <- list(nstart = 1, trace = FALSE, lower = 0.005)
  cn[names(control)] <- control
  more <- list(...)[c("nstart", "trace", "lower", "opt", "rotate")]
  if (length(more)) 
    cn[names(more)] <- more
  if (is.null(start)) {
    start <- (1 - 0.5 * factors/p)/diag(solve(cv))
    if ((ns <- cn$nstart) > 1) 
      start <- cbind(start, matrix(runif(ns - 1), p, ns - 1, byrow = TRUE))
  }
  start <- as.matrix(start)
  if (nrow(start) != p) 
    stop(sprintf(ngettext(p, "'start' must have %d row", "'start' must have %d rows"), p), domain = NA)
  nc <- ncol(start)
  if (nc < 1) 
    stop("no starting values supplied")
  best <- Inf
  for (i in 1:nc) {
    nfit <- factanal.fit.mle(cv, factors, start[, i], max(cn$lower, 0), cn$opt)
    if (cn$trace) 
      cat("start", i, "value:", format(nfit$criteria[1]), "uniqs:", format(as.vector(round(nfit$uniquenesses, 4))), "\n")
    if (nfit$converged && nfit$criteria[1] < best) {
      fit <- nfit
      best <- fit$criteria[1]
    }
  }
  if (best == Inf) 
    stop(ngettext(nc, "unable to optimize from this starting value", "unable to optimize from these starting values"), domain = NA)
  load <- fit$loadings
  if (rotation != "none") {
    rot <- do.call(rotation, c(list(load), cn$rotate))
    load <- if (is.list(rot)) {
      load <- rot$loadings
      fit$rotmat <- if (inherits(rot, "GPArotation")) 
        t(solve(rot$Th))
      else rot$rotmat
      rot$loadings
    }
    else rot
  }
  fit$loadings <- sortLoadings(load)
  class(fit$loadings) <- "loadings"
  fit$na.action <- na.act
  if (have.x && scores != "none") {
    Lambda <- fit$loadings
    zz <- scale(z, TRUE, TRUE)
    switch(scores, regression = {
      sc <- zz %*% solve(cv, Lambda)
      if (!is.null(Phi <- attr(Lambda, "covariance"))) sc <- sc %*% Phi
    }, Bartlett = {
      d <- 1/fit$uniquenesses
      tmp <- t(Lambda * d)
      sc <- t(solve(tmp %*% Lambda, tmp %*% t(zz)))
    })
    rownames(sc) <- rownames(z)
    colnames(sc) <- colnames(Lambda)
    if (!is.null(na.act)) 
      sc <- napredict(na.act, sc)
    fit$scores <- sc
  }
  if (!is.na(n.obs) && dof > 0) {
    fit$STATISTIC <- (n.obs - 1 - (2 * p + 5)/6 - (2 * factors)/3) * fit$criteria["objective"]
    fit$PVAL <- pchisq(fit$STATISTIC, dof, lower.tail = FALSE)
  }
  fit$n.obs <- n.obs
  fit$call <- cl
  fit
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
factor.scope
list(`package:stats` = function (factor, scope) 
{
  drop <- scope$drop
  add <- scope$add
  if (length(factor) && !is.null(drop)) {
    nmdrop <- colnames(drop)
    facs <- factor
    if (length(drop)) {
      nmfac <- colnames(factor)
      nmfac0 <- sapply(strsplit(nmfac, ":", fixed = TRUE), function(x) paste(sort(x), collapse = ":"))
      nmdrop0 <- sapply(strsplit(nmdrop, ":", fixed = TRUE), function(x) paste(sort(x), collapse = ":"))
      where <- match(nmdrop0, nmfac0, 0)
      if (any(!where)) 
        stop(sprintf(ngettext(sum(where == 0), "lower scope has term %s not included in model", "lower scope has terms %s not included in model"), paste(sQuote(nmdrop[where == 0]), collapse = ", ")), domain = NA)
      facs <- factor[, -where, drop = FALSE]
      nmdrop <- nmfac[-where]
    }
    else nmdrop <- colnames(factor)
    if (ncol(facs) > 1) {
      keep <- rep.int(TRUE, ncol(facs))
      f <- crossprod(facs > 0)
      for (i in seq(keep)) keep[i] <- max(f[i, -i]) != f[i, i]
      nmdrop <- nmdrop[keep]
    }
  }
  else nmdrop <- character()
  if (!length(add)) 
    nmadd <- character()
  else {
    nmfac <- colnames(factor)
    nmadd <- colnames(add)
    if (!is.null(nmfac)) {
      nmfac0 <- sapply(strsplit(nmfac, ":", fixed = TRUE), function(x) paste(sort(x), collapse = ":"))
      nmadd0 <- sapply(strsplit(nmadd, ":", fixed = TRUE), function(x) paste(sort(x), collapse = ":"))
      where <- match(nmfac0, nmadd0, 0)
      if (any(!where)) 
        stop(sprintf(ngettext(sum(where == 0), "upper scope has term %s not included in model", "upper scope has terms %s not included in model"), paste(sQuote(nmdrop[where == 0]), collapse = ", ")), domain = NA)
      nmadd <- nmadd[-where]
      add <- add[, -where, drop = FALSE]
    }
    if (ncol(add) > 1) {
      keep <- rep.int(TRUE, ncol(add))
      f <- crossprod(add > 0)
      for (i in seq(keep)) keep[-i] <- keep[-i] & (f[i, -i] < f[i, i])
      nmadd <- nmadd[keep]
    }
  }
  list(drop = nmdrop, add = nmadd)
}, function (factor, scope) 
{
  drop <- scope$drop
  add <- scope$add
  if (length(factor) && !is.null(drop)) {
    nmdrop <- colnames(drop)
    facs <- factor
    if (length(drop)) {
      nmfac <- colnames(factor)
      nmfac0 <- sapply(strsplit(nmfac, ":", fixed = TRUE), function(x) paste(sort(x), collapse = ":"))
      nmdrop0 <- sapply(strsplit(nmdrop, ":", fixed = TRUE), function(x) paste(sort(x), collapse = ":"))
      where <- match(nmdrop0, nmfac0, 0)
      if (any(!where)) 
        stop(sprintf(ngettext(sum(where == 0), "lower scope has term %s not included in model", "lower scope has terms %s not included in model"), paste(sQuote(nmdrop[where == 0]), collapse = ", ")), domain = NA)
      facs <- factor[, -where, drop = FALSE]
      nmdrop <- nmfac[-where]
    }
    else nmdrop <- colnames(factor)
    if (ncol(facs) > 1) {
      keep <- rep.int(TRUE, ncol(facs))
      f <- crossprod(facs > 0)
      for (i in seq(keep)) keep[i] <- max(f[i, -i]) != f[i, i]
      nmdrop <- nmdrop[keep]
    }
  }
  else nmdrop <- character()
  if (!length(add)) 
    nmadd <- character()
  else {
    nmfac <- colnames(factor)
    nmadd <- colnames(add)
    if (!is.null(nmfac)) {
      nmfac0 <- sapply(strsplit(nmfac, ":", fixed = TRUE), function(x) paste(sort(x), collapse = ":"))
      nmadd0 <- sapply(strsplit(nmadd, ":", fixed = TRUE), function(x) paste(sort(x), collapse = ":"))
      where <- match(nmfac0, nmadd0, 0)
      if (any(!where)) 
        stop(sprintf(ngettext(sum(where == 0), "upper scope has term %s not included in model", "upper scope has terms %s not included in model"), paste(sQuote(nmdrop[where == 0]), collapse = ", ")), domain = NA)
      nmadd <- nmadd[-where]
      add <- add[, -where, drop = FALSE]
    }
    if (ncol(add) > 1) {
      keep <- rep.int(TRUE, ncol(add))
      f <- crossprod(add > 0)
      for (i in seq(keep)) keep[-i] <- keep[-i] & (f[i, -i] < f[i, i])
      nmadd <- nmadd[keep]
    }
  }
  list(drop = nmdrop, add = nmadd)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
family
list(`package:stats` = function (object, ...) 
  UseMethod("family"), function (object, ...) 
    UseMethod("family"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
fft
list(`package:stats` = function (z, inverse = FALSE) 
  .Call(C_fft, z, inverse), function (z, inverse = FALSE) 
    .Call(C_fft, z, inverse))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
filter
list(`package:stats` = function (x, filter, method = c("convolution", "recursive"), sides = 2, circular = FALSE, init = NULL) 
{
  method <- match.arg(method)
  x <- as.ts(x)
  storage.mode(x) <- "double"
  xtsp <- tsp(x)
  n <- as.integer(NROW(x))
  if (is.na(n)) 
    stop(gettextf("invalid value of %s", "NROW(x)"), domain = NA)
  nser <- NCOL(x)
  filter <- as.double(filter)
  nfilt <- as.integer(length(filter))
  if (is.na(nfilt)) 
    stop(gettextf("invalid value of %s", "length(filter)"), domain = NA)
  if (anyNA(filter)) 
    stop("missing values in 'filter'")
  if (method == "convolution") {
    if (nfilt > n) 
      stop("'filter' is longer than time series")
    sides <- as.integer(sides)
    if (is.na(sides) || (sides != 1 && sides != 2)) 
      stop("argument 'sides' must be 1 or 2")
    circular <- as.logical(circular)
    if (is.na(circular)) 
      stop("'circular' must be logical and not NA")
    if (is.matrix(x)) {
      y <- matrix(NA, n, nser)
      for (i in seq_len(nser)) y[, i] <- .Call(C_cfilter, x[, i], filter, sides, circular)
    }
    else y <- .Call(C_cfilter, x, filter, sides, circular)
  }
  else {
    if (missing(init)) {
      init <- matrix(0, nfilt, nser)
    }
    else {
      ni <- NROW(init)
      if (ni != nfilt) 
        stop("length of 'init' must equal length of 'filter'")
      if (NCOL(init) != 1 && NCOL(init) != nser) {
        stop(sprintf(ngettext(nser, "'init' must have %d column", "'init' must have 1 or %d columns", domain = "R-stats"), nser), domain = NA)
      }
      if (!is.matrix(init)) 
        dim(init) <- c(nfilt, nser)
    }
    ind <- seq_len(nfilt)
    if (is.matrix(x)) {
      y <- matrix(NA, n, nser)
      for (i in seq_len(nser)) y[, i] <- .Call(C_rfilter, x[, i], filter, c(rev(init[, i]), double(n)))[-ind]
    }
    else y <- .Call(C_rfilter, x, filter, c(rev(init[, 1]), double(n)))[-ind]
  }
  tsp(y) <- xtsp
  class(y) <- if (nser > 1) 
    c("mts", "ts")
  else "ts"
  y
}, function (.data, ..., .preserve = FALSE) 
{
  UseMethod("filter")
}, function (x, filter, method = c("convolution", "recursive"), sides = 2, circular = FALSE, init = NULL) 
{
  method <- match.arg(method)
  x <- as.ts(x)
  storage.mode(x) <- "double"
  xtsp <- tsp(x)
  n <- as.integer(NROW(x))
  if (is.na(n)) 
    stop(gettextf("invalid value of %s", "NROW(x)"), domain = NA)
  nser <- NCOL(x)
  filter <- as.double(filter)
  nfilt <- as.integer(length(filter))
  if (is.na(nfilt)) 
    stop(gettextf("invalid value of %s", "length(filter)"), domain = NA)
  if (anyNA(filter)) 
    stop("missing values in 'filter'")
  if (method == "convolution") {
    if (nfilt > n) 
      stop("'filter' is longer than time series")
    sides <- as.integer(sides)
    if (is.na(sides) || (sides != 1 && sides != 2)) 
      stop("argument 'sides' must be 1 or 2")
    circular <- as.logical(circular)
    if (is.na(circular)) 
      stop("'circular' must be logical and not NA")
    if (is.matrix(x)) {
      y <- matrix(NA, n, nser)
      for (i in seq_len(nser)) y[, i] <- .Call(C_cfilter, x[, i], filter, sides, circular)
    }
    else y <- .Call(C_cfilter, x, filter, sides, circular)
  }
  else {
    if (missing(init)) {
      init <- matrix(0, nfilt, nser)
    }
    else {
      ni <- NROW(init)
      if (ni != nfilt) 
        stop("length of 'init' must equal length of 'filter'")
      if (NCOL(init) != 1 && NCOL(init) != nser) {
        stop(sprintf(ngettext(nser, "'init' must have %d column", "'init' must have 1 or %d columns", domain = "R-stats"), nser), domain = NA)
      }
      if (!is.matrix(init)) 
        dim(init) <- c(nfilt, nser)
    }
    ind <- seq_len(nfilt)
    if (is.matrix(x)) {
      y <- matrix(NA, n, nser)
      for (i in seq_len(nser)) y[, i] <- .Call(C_rfilter, x[, i], filter, c(rev(init[, i]), double(n)))[-ind]
    }
    else y <- .Call(C_rfilter, x, filter, c(rev(init[, 1]), double(n)))[-ind]
  }
  tsp(y) <- xtsp
  class(y) <- if (nser > 1) 
    c("mts", "ts")
  else "ts"
  y
})
c("package:stats", "namespace:dplyr", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
fisher.test
list(`package:stats` = function (x, y = NULL, workspace = 2e+05, hybrid = FALSE, hybridPars = c(expect = 5, percent = 80, Emin = 1), control = list(), or = 1, alternative = "two.sided", conf.int = TRUE, conf.level = 0.95, simulate.p.value = FALSE, B = 2000) 
{
  DNAME <- deparse1(substitute(x))
  METHOD <- "Fisher's Exact Test for Count Data"
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (is.matrix(x)) {
    if (any(dim(x) < 2)) 
      stop("'x' must have at least 2 rows and columns")
    if (!is.numeric(x) || any(x < 0) || anyNA(x)) 
      stop("all entries of 'x' must be nonnegative and finite")
    if (!is.integer(x)) {
      xo <- x
      x <- round(x)
      if (any(x > .Machine$integer.max)) 
        stop("'x' has entries too large to be integer")
      if (!identical(TRUE, (ax <- all.equal(xo, x)))) 
        warning(gettextf("'x' has been rounded to integer: %s", ax), domain = NA)
      storage.mode(x) <- "integer"
    }
  }
  else {
    if (is.null(y)) 
      stop("if 'x' is not a matrix, 'y' must be given")
    if (length(x) != length(y)) 
      stop("'x' and 'y' must have the same length")
    DNAME <- paste(DNAME, "and", deparse1(substitute(y)))
    OK <- complete.cases(x, y)
    x <- as.factor(x[OK])
    y <- as.factor(y[OK])
    if ((nlevels(x) < 2) || (nlevels(y) < 2)) 
      stop("'x' and 'y' must have at least 2 levels")
    x <- table(x, y)
  }
  con <- list(mult = 30)
  con[names(control)] <- control
  if ((mult <- as.integer(con$mult)) < 2) 
    stop("'mult' must be integer >= 2, typically = 30")
  nr <- nrow(x)
  nc <- ncol(x)
  have.2x2 <- (nr == 2) && (nc == 2)
  if (have.2x2) {
    alternative <- char.expand(alternative, c("two.sided", "less", "greater"))
    if (length(alternative) > 1 || is.na(alternative)) 
      stop("alternative must be \"two.sided\", \"less\" or \"greater\"")
    if (!((length(conf.level) == 1) && is.finite(conf.level) && (conf.level > 0) && (conf.level < 1))) 
      stop("'conf.level' must be a single number between 0 and 1")
    if (!missing(or) && (length(or) > 1 || is.na(or) || or < 0)) 
      stop("'or' must be a single number between 0 and Inf")
  }
  PVAL <- NULL
  if (!have.2x2) {
    if (simulate.p.value) {
      sr <- rowSums(x)
      sc <- colSums(x)
      x <- x[sr > 0, sc > 0, drop = FALSE]
      nr <- as.integer(nrow(x))
      nc <- as.integer(ncol(x))
      if (is.na(nr) || is.na(nc) || is.na(nr * nc)) 
        stop("invalid nrow(x) or ncol(x)", domain = NA)
      if (nr <= 1) 
        stop("need 2 or more non-zero row marginals")
      if (nc <= 1) 
        stop("need 2 or more non-zero column marginals")
      METHOD <- paste(METHOD, "with simulated p-value\n\t (based on", B, "replicates)")
      STATISTIC <- -sum(lfactorial(x))
      tmp <- .Call(C_Fisher_sim, rowSums(x), colSums(x), B)
      almost.1 <- 1 + 64 * .Machine$double.eps
      PVAL <- (1 + sum(tmp <= STATISTIC/almost.1))/(B + 1)
    }
    else if (hybrid) {
      if (!is.null(nhP <- names(hybridPars)) && !identical(nhP, c("expect", "percent", "Emin"))) 
        stop("names(hybridPars) should be NULL or be identical to the default's")
      stopifnot(is.double(hypp <- as.double(hybridPars)), length(hypp) == 3, hypp[1] > 0, hypp[3] >= 0, 0 <= hypp[2], hypp[2] <= 100)
      PVAL <- .Call(C_Fexact, x, hypp, workspace, mult)
      METHOD <- paste(METHOD, sprintf("hybrid using asym.chisq. iff (exp=%g, perc=%g, Emin=%g)", hypp[1], hypp[2], hypp[3]))
    }
    else {
      PVAL <- .Call(C_Fexact, x, c(-1, 100, 0), workspace, mult)
    }
    RVAL <- list(p.value = max(0, min(1, PVAL)))
  }
  else {
    if (hybrid) 
      warning("'hybrid' is ignored for a 2 x 2 table")
    m <- sum(x[, 1])
    n <- sum(x[, 2])
    k <- sum(x[1, ])
    x <- x[1, 1]
    lo <- max(0, k - n)
    hi <- min(k, m)
    NVAL <- c(`odds ratio` = or)
    support <- lo:hi
    logdc <- dhyper(support, m, n, k, log = TRUE)
    dnhyper <- function(ncp) {
      d <- logdc + log(ncp) * support
      d <- exp(d - max(d))
      d/sum(d)
    }
    mnhyper <- function(ncp) {
      if (ncp == 0) 
        return(lo)
      if (ncp == Inf) 
        return(hi)
      sum(support * dnhyper(ncp))
    }
    pnhyper <- function(q, ncp = 1, upper.tail = FALSE) {
      if (ncp == 1) {
        return(if (upper.tail) phyper(x - 1, m, n, k, lower.tail = FALSE) else phyper(x, m, n, k))
      }
      if (ncp == 0) {
        return(as.numeric(if (upper.tail) q <= lo else q >= lo))
      }
      if (ncp == Inf) {
        return(as.numeric(if (upper.tail) q <= hi else q >= hi))
      }
      sum(dnhyper(ncp)[if (upper.tail) support >= q else support <= q])
    }
    if (is.null(PVAL)) {
      PVAL <- switch(alternative, less = pnhyper(x, or), greater = pnhyper(x, or, upper.tail = TRUE), two.sided = {
        if (or == 0) as.numeric(x == lo) else if (or == Inf) as.numeric(x == hi) else {
          relErr <- 1 + 10^(-7)
          d <- dnhyper(or)
          sum(d[d <= d[x - lo + 1] * relErr])
        }
      })
      RVAL <- list(p.value = PVAL)
    }
    mle <- function(x) {
      if (x == lo) 
        return(0)
      if (x == hi) 
        return(Inf)
      mu <- mnhyper(1)
      if (mu > x) 
        uniroot(function(t) mnhyper(t) - x, c(0, 1))$root
      else if (mu < x) 
        1/uniroot(function(t) mnhyper(1/t) - x, c(.Machine$double.eps, 1))$root
      else 1
    }
    ESTIMATE <- c(`odds ratio` = mle(x))
    if (conf.int) {
      ncp.U <- function(x, alpha) {
        if (x == hi) 
          return(Inf)
        p <- pnhyper(x, 1)
        if (p < alpha) 
          uniroot(function(t) pnhyper(x, t) - alpha, c(0, 1))$root
        else if (p > alpha) 
          1/uniroot(function(t) pnhyper(x, 1/t) - alpha, c(.Machine$double.eps, 1))$root
        else 1
      }
      ncp.L <- function(x, alpha) {
        if (x == lo) 
          return(0)
        p <- pnhyper(x, 1, upper.tail = TRUE)
        if (p > alpha) 
          uniroot(function(t) pnhyper(x, t, upper.tail = TRUE) - alpha, c(0, 1))$root
        else if (p < alpha) 
          1/uniroot(function(t) pnhyper(x, 1/t, upper.tail = TRUE) - alpha, c(.Machine$double.eps, 1))$root
        else 1
      }
      CINT <- switch(alternative, less = c(0, ncp.U(x, 1 - conf.level)), greater = c(ncp.L(x, 1 - conf.level), Inf), two.sided = {
        alpha <- (1 - conf.level)/2
        c(ncp.L(x, alpha), ncp.U(x, alpha))
      })
      attr(CINT, "conf.level") <- conf.level
    }
    RVAL <- c(RVAL, list(conf.int = if (conf.int) CINT, estimate = ESTIMATE, null.value = NVAL))
  }
  structure(c(RVAL, alternative = alternative, method = METHOD, data.name = DNAME), class = "htest")
}, function (x, y = NULL, workspace = 2e+05, hybrid = FALSE, hybridPars = c(expect = 5, percent = 80, Emin = 1), control = list(), or = 1, alternative = "two.sided", conf.int = TRUE, conf.level = 0.95, simulate.p.value = FALSE, B = 2000) 
{
  DNAME <- deparse1(substitute(x))
  METHOD <- "Fisher's Exact Test for Count Data"
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  if (is.matrix(x)) {
    if (any(dim(x) < 2)) 
      stop("'x' must have at least 2 rows and columns")
    if (!is.numeric(x) || any(x < 0) || anyNA(x)) 
      stop("all entries of 'x' must be nonnegative and finite")
    if (!is.integer(x)) {
      xo <- x
      x <- round(x)
      if (any(x > .Machine$integer.max)) 
        stop("'x' has entries too large to be integer")
      if (!identical(TRUE, (ax <- all.equal(xo, x)))) 
        warning(gettextf("'x' has been rounded to integer: %s", ax), domain = NA)
      storage.mode(x) <- "integer"
    }
  }
  else {
    if (is.null(y)) 
      stop("if 'x' is not a matrix, 'y' must be given")
    if (length(x) != length(y)) 
      stop("'x' and 'y' must have the same length")
    DNAME <- paste(DNAME, "and", deparse1(substitute(y)))
    OK <- complete.cases(x, y)
    x <- as.factor(x[OK])
    y <- as.factor(y[OK])
    if ((nlevels(x) < 2) || (nlevels(y) < 2)) 
      stop("'x' and 'y' must have at least 2 levels")
    x <- table(x, y)
  }
  con <- list(mult = 30)
  con[names(control)] <- control
  if ((mult <- as.integer(con$mult)) < 2) 
    stop("'mult' must be integer >= 2, typically = 30")
  nr <- nrow(x)
  nc <- ncol(x)
  have.2x2 <- (nr == 2) && (nc == 2)
  if (have.2x2) {
    alternative <- char.expand(alternative, c("two.sided", "less", "greater"))
    if (length(alternative) > 1 || is.na(alternative)) 
      stop("alternative must be \"two.sided\", \"less\" or \"greater\"")
    if (!((length(conf.level) == 1) && is.finite(conf.level) && (conf.level > 0) && (conf.level < 1))) 
      stop("'conf.level' must be a single number between 0 and 1")
    if (!missing(or) && (length(or) > 1 || is.na(or) || or < 0)) 
      stop("'or' must be a single number between 0 and Inf")
  }
  PVAL <- NULL
  if (!have.2x2) {
    if (simulate.p.value) {
      sr <- rowSums(x)
      sc <- colSums(x)
      x <- x[sr > 0, sc > 0, drop = FALSE]
      nr <- as.integer(nrow(x))
      nc <- as.integer(ncol(x))
      if (is.na(nr) || is.na(nc) || is.na(nr * nc)) 
        stop("invalid nrow(x) or ncol(x)", domain = NA)
      if (nr <= 1) 
        stop("need 2 or more non-zero row marginals")
      if (nc <= 1) 
        stop("need 2 or more non-zero column marginals")
      METHOD <- paste(METHOD, "with simulated p-value\n\t (based on", B, "replicates)")
      STATISTIC <- -sum(lfactorial(x))
      tmp <- .Call(C_Fisher_sim, rowSums(x), colSums(x), B)
      almost.1 <- 1 + 64 * .Machine$double.eps
      PVAL <- (1 + sum(tmp <= STATISTIC/almost.1))/(B + 1)
    }
    else if (hybrid) {
      if (!is.null(nhP <- names(hybridPars)) && !identical(nhP, c("expect", "percent", "Emin"))) 
        stop("names(hybridPars) should be NULL or be identical to the default's")
      stopifnot(is.double(hypp <- as.double(hybridPars)), length(hypp) == 3, hypp[1] > 0, hypp[3] >= 0, 0 <= hypp[2], hypp[2] <= 100)
      PVAL <- .Call(C_Fexact, x, hypp, workspace, mult)
      METHOD <- paste(METHOD, sprintf("hybrid using asym.chisq. iff (exp=%g, perc=%g, Emin=%g)", hypp[1], hypp[2], hypp[3]))
    }
    else {
      PVAL <- .Call(C_Fexact, x, c(-1, 100, 0), workspace, mult)
    }
    RVAL <- list(p.value = max(0, min(1, PVAL)))
  }
  else {
    if (hybrid) 
      warning("'hybrid' is ignored for a 2 x 2 table")
    m <- sum(x[, 1])
    n <- sum(x[, 2])
    k <- sum(x[1, ])
    x <- x[1, 1]
    lo <- max(0, k - n)
    hi <- min(k, m)
    NVAL <- c(`odds ratio` = or)
    support <- lo:hi
    logdc <- dhyper(support, m, n, k, log = TRUE)
    dnhyper <- function(ncp) {
      d <- logdc + log(ncp) * support
      d <- exp(d - max(d))
      d/sum(d)
    }
    mnhyper <- function(ncp) {
      if (ncp == 0) 
        return(lo)
      if (ncp == Inf) 
        return(hi)
      sum(support * dnhyper(ncp))
    }
    pnhyper <- function(q, ncp = 1, upper.tail = FALSE) {
      if (ncp == 1) {
        return(if (upper.tail) phyper(x - 1, m, n, k, lower.tail = FALSE) else phyper(x, m, n, k))
      }
      if (ncp == 0) {
        return(as.numeric(if (upper.tail) q <= lo else q >= lo))
      }
      if (ncp == Inf) {
        return(as.numeric(if (upper.tail) q <= hi else q >= hi))
      }
      sum(dnhyper(ncp)[if (upper.tail) support >= q else support <= q])
    }
    if (is.null(PVAL)) {
      PVAL <- switch(alternative, less = pnhyper(x, or), greater = pnhyper(x, or, upper.tail = TRUE), two.sided = {
        if (or == 0) as.numeric(x == lo) else if (or == Inf) as.numeric(x == hi) else {
          relErr <- 1 + 10^(-7)
          d <- dnhyper(or)
          sum(d[d <= d[x - lo + 1] * relErr])
        }
      })
      RVAL <- list(p.value = PVAL)
    }
    mle <- function(x) {
      if (x == lo) 
        return(0)
      if (x == hi) 
        return(Inf)
      mu <- mnhyper(1)
      if (mu > x) 
        uniroot(function(t) mnhyper(t) - x, c(0, 1))$root
      else if (mu < x) 
        1/uniroot(function(t) mnhyper(1/t) - x, c(.Machine$double.eps, 1))$root
      else 1
    }
    ESTIMATE <- c(`odds ratio` = mle(x))
    if (conf.int) {
      ncp.U <- function(x, alpha) {
        if (x == hi) 
          return(Inf)
        p <- pnhyper(x, 1)
        if (p < alpha) 
          uniroot(function(t) pnhyper(x, t) - alpha, c(0, 1))$root
        else if (p > alpha) 
          1/uniroot(function(t) pnhyper(x, 1/t) - alpha, c(.Machine$double.eps, 1))$root
        else 1
      }
      ncp.L <- function(x, alpha) {
        if (x == lo) 
          return(0)
        p <- pnhyper(x, 1, upper.tail = TRUE)
        if (p > alpha) 
          uniroot(function(t) pnhyper(x, t, upper.tail = TRUE) - alpha, c(0, 1))$root
        else if (p < alpha) 
          1/uniroot(function(t) pnhyper(x, 1/t, upper.tail = TRUE) - alpha, c(.Machine$double.eps, 1))$root
        else 1
      }
      CINT <- switch(alternative, less = c(0, ncp.U(x, 1 - conf.level)), greater = c(ncp.L(x, 1 - conf.level), Inf), two.sided = {
        alpha <- (1 - conf.level)/2
        c(ncp.L(x, alpha), ncp.U(x, alpha))
      })
      attr(CINT, "conf.level") <- conf.level
    }
    RVAL <- c(RVAL, list(conf.int = if (conf.int) CINT, estimate = ESTIMATE, null.value = NVAL))
  }
  structure(c(RVAL, alternative = alternative, method = METHOD, data.name = DNAME), class = "htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
fitted
list(`package:stats` = function (object, ...) 
  UseMethod("fitted"), function (object, ...) 
    UseMethod("fitted"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
fitted.values
list(`package:stats` = function (object, ...) 
  UseMethod("fitted"), function (object, ...) 
    UseMethod("fitted"), function (object, ...) 
      UseMethod("fitted"))
c("package:stats", "registered S3 method for fitted from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
fivenum
list(`package:stats` = function (x, na.rm = TRUE) 
{
  xna <- is.na(x)
  if (any(xna)) {
    if (na.rm) 
      x <- x[!xna]
    else return(rep.int(NA, 5))
  }
  x <- sort(x)
  n <- length(x)
  if (n == 0) 
    rep.int(NA, 5)
  else {
    n4 <- floor((n + 3)/2)/2
    d <- c(1, n4, (n + 1)/2, n + 1 - n4, n)
    0.5 * (x[floor(d)] + x[ceiling(d)])
  }
}, function (x, na.rm = TRUE) 
{
  xna <- is.na(x)
  if (any(xna)) {
    if (na.rm) 
      x <- x[!xna]
    else return(rep.int(NA, 5))
  }
  x <- sort(x)
  n <- length(x)
  if (n == 0) 
    rep.int(NA, 5)
  else {
    n4 <- floor((n + 3)/2)/2
    d <- c(1, n4, (n + 1)/2, n + 1 - n4, n)
    0.5 * (x[floor(d)] + x[ceiling(d)])
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
fligner.test
list(`package:stats` = function (x, ...) 
  UseMethod("fligner.test"), function (x, ...) 
    UseMethod("fligner.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
formula
list(`package:stats` = function (x, ...) 
  UseMethod("formula"), function (x, ...) 
    UseMethod("formula"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
frequency
list(`package:stats` = function (x, ...) 
  UseMethod("frequency"), function (x, ...) 
    UseMethod("frequency"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
friedman.test
list(`package:stats` = function (y, ...) 
  UseMethod("friedman.test"), function (y, ...) 
    UseMethod("friedman.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ftable
list(`package:stats` = function (x, ...) 
  UseMethod("ftable"), function (x, ...) 
    UseMethod("ftable"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
Gamma
list(`package:stats` = function (link = "inverse") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("inverse", "log", "identity")
  family <- "Gamma"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu^2
  validmu <- function(mu) all(is.finite(mu)) && all(mu > 0)
  dev.resids <- function(y, mu, wt) -2 * wt * (log(ifelse(y == 0, 1, y/mu)) - (y - mu)/mu)
  aic <- function(y, n, mu, wt, dev) {
    n <- sum(wt)
    disp <- dev/n
    -2 * sum(dgamma(y, 1/disp, scale = mu * disp, log = TRUE) * wt) + 2
  }
  initialize <- expression({
    if (any(y <= 0)) stop("non-positive values not allowed for the 'Gamma' family")
    n <- rep.int(1, nobs)
    mustart <- y
  })
  simfun <- function(object, nsim) {
    wts <- object$prior.weights
    if (any(wts != 1)) 
      message("using weights as shape parameters")
    ftd <- fitted(object)
    shape <- MASS::gamma.shape(object)$alpha * wts
    rgamma(nsim * length(ftd), shape = shape, rate = shape/ftd)
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
}, function (link = "inverse") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("inverse", "log", "identity")
  family <- "Gamma"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu^2
  validmu <- function(mu) all(is.finite(mu)) && all(mu > 0)
  dev.resids <- function(y, mu, wt) -2 * wt * (log(ifelse(y == 0, 1, y/mu)) - (y - mu)/mu)
  aic <- function(y, n, mu, wt, dev) {
    n <- sum(wt)
    disp <- dev/n
    -2 * sum(dgamma(y, 1/disp, scale = mu * disp, log = TRUE) * wt) + 2
  }
  initialize <- expression({
    if (any(y <= 0)) stop("non-positive values not allowed for the 'Gamma' family")
    n <- rep.int(1, nobs)
    mustart <- y
  })
  simfun <- function(object, nsim) {
    wts <- object$prior.weights
    if (any(wts != 1)) 
      message("using weights as shape parameters")
    ftd <- fitted(object)
    shape <- MASS::gamma.shape(object)$alpha * wts
    rgamma(nsim * length(ftd), shape = shape, rate = shape/ftd)
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
gaussian
list(`package:stats` = function (link = "identity") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("inverse", "log", "identity")
  family <- "gaussian"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = function(mu) rep.int(1, length(mu)), dev.resids = function(y, mu, wt) wt * ((y - mu)^2), aic = function(y, n, mu, wt, dev) {
    nobs <- length(y)
    nobs * (log(dev/nobs * 2 * pi) + 1) + 2 - sum(log(wt))
  }, mu.eta = stats$mu.eta, initialize = expression({
    n <- rep.int(1, nobs)
    if (is.null(etastart) && is.null(start) && is.null(mustart) && ((family$link == "inverse" && any(y == 0)) || (family$link == "log" && any(y <= 0)))) stop("cannot find valid starting values: please specify some")
    mustart <- y
  }), validmu = function(mu) TRUE, valideta = stats$valideta), class = "family")
}, function (link = "identity") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("inverse", "log", "identity")
  family <- "gaussian"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = function(mu) rep.int(1, length(mu)), dev.resids = function(y, mu, wt) wt * ((y - mu)^2), aic = function(y, n, mu, wt, dev) {
    nobs <- length(y)
    nobs * (log(dev/nobs * 2 * pi) + 1) + 2 - sum(log(wt))
  }, mu.eta = stats$mu.eta, initialize = expression({
    n <- rep.int(1, nobs)
    if (is.null(etastart) && is.null(start) && is.null(mustart) && ((family$link == "inverse" && any(y == 0)) || (family$link == "log" && any(y <= 0)))) stop("cannot find valid starting values: please specify some")
    mustart <- y
  }), validmu = function(mu) TRUE, valideta = stats$valideta), class = "family")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
get_all_vars
list(`package:stats` = function (formula, data = NULL, ...) 
{
  if (missing(formula)) {
    if (!missing(data) && inherits(data, "data.frame") && length(attr(data, "terms"))) 
      return(data)
    formula <- as.formula(data)
  }
  else if (missing(data) && inherits(formula, "data.frame")) {
    if (length(attr(formula, "terms"))) 
      return(formula)
    data <- formula
    formula <- as.formula(data)
  }
  formula <- as.formula(formula)
  if (missing(data)) 
    data <- environment(formula)
  else if (!is.data.frame(data) && !is.environment(data) && !is.null(attr(data, "class"))) 
    data <- as.data.frame(data)
  else if (is.array(data)) 
    stop("'data' must be a data.frame, not a matrix or an array")
  if (!is.data.frame(data) && !is.environment(data) && !is.list(data) && !is.null(data)) 
    stop("'data' must be a data.frame, environment, or list")
  if (!inherits(formula, "terms")) 
    formula <- terms(formula, data = data)
  env <- environment(formula)
  rownames <- .row_names_info(data, 0)
  varnames <- all.vars(formula)
  variables <- lapply(lapply(varnames, as.name), eval, data, env)
  if (is.null(rownames) && (resp <- attr(formula, "response")) > 0) {
    lhs <- variables[[resp]]
    rownames <- if (!is.null(d <- dim(lhs)) && length(d) == 2) {
      if (is.data.frame(lhs)) 
        .row_names_info(lhs, 0)
      else rownames(lhs)
    }
    else names(lhs)
  }
  extras <- substitute(list(...))
  extranames <- names(extras[-1])
  extras <- eval(extras, data, env)
  x <- c(variables, extras)
  if (anyM <- any(isM <- vapply(x, function(o) is.matrix(o) && !inherits(o, "AsIs"), NA))) 
    x[isM] <- lapply(x[isM], I)
  nms.x <- c(varnames, extranames)
  if (any(vapply(x, is.data.frame, NA))) 
    nms.x <- unlist(lapply(seq_along(x), function(i) if (is.list(x[[i]])) 
      names(x[[i]])
      else nms.x[[i]]))
  x <- as.data.frame(x, optional = TRUE)
  names(x) <- nms.x
  if (anyM) 
    x[isM] <- lapply(x[isM], function(o) `class<-`(o, class(o)[class(o) != "AsIs"]))
  attr(x, "row.names") <- if (is.null(rownames)) 
    .set_row_names(max(vapply(x, NROW, integer(1))))
  else rownames
  x
}, function (formula, data = NULL, ...) 
{
  if (missing(formula)) {
    if (!missing(data) && inherits(data, "data.frame") && length(attr(data, "terms"))) 
      return(data)
    formula <- as.formula(data)
  }
  else if (missing(data) && inherits(formula, "data.frame")) {
    if (length(attr(formula, "terms"))) 
      return(formula)
    data <- formula
    formula <- as.formula(data)
  }
  formula <- as.formula(formula)
  if (missing(data)) 
    data <- environment(formula)
  else if (!is.data.frame(data) && !is.environment(data) && !is.null(attr(data, "class"))) 
    data <- as.data.frame(data)
  else if (is.array(data)) 
    stop("'data' must be a data.frame, not a matrix or an array")
  if (!is.data.frame(data) && !is.environment(data) && !is.list(data) && !is.null(data)) 
    stop("'data' must be a data.frame, environment, or list")
  if (!inherits(formula, "terms")) 
    formula <- terms(formula, data = data)
  env <- environment(formula)
  rownames <- .row_names_info(data, 0)
  varnames <- all.vars(formula)
  variables <- lapply(lapply(varnames, as.name), eval, data, env)
  if (is.null(rownames) && (resp <- attr(formula, "response")) > 0) {
    lhs <- variables[[resp]]
    rownames <- if (!is.null(d <- dim(lhs)) && length(d) == 2) {
      if (is.data.frame(lhs)) 
        .row_names_info(lhs, 0)
      else rownames(lhs)
    }
    else names(lhs)
  }
  extras <- substitute(list(...))
  extranames <- names(extras[-1])
  extras <- eval(extras, data, env)
  x <- c(variables, extras)
  if (anyM <- any(isM <- vapply(x, function(o) is.matrix(o) && !inherits(o, "AsIs"), NA))) 
    x[isM] <- lapply(x[isM], I)
  nms.x <- c(varnames, extranames)
  if (any(vapply(x, is.data.frame, NA))) 
    nms.x <- unlist(lapply(seq_along(x), function(i) if (is.list(x[[i]])) 
      names(x[[i]])
      else nms.x[[i]]))
  x <- as.data.frame(x, optional = TRUE)
  names(x) <- nms.x
  if (anyM) 
    x[isM] <- lapply(x[isM], function(o) `class<-`(o, class(o)[class(o) != "AsIs"]))
  attr(x, "row.names") <- if (is.null(rownames)) 
    .set_row_names(max(vapply(x, NROW, integer(1))))
  else rownames
  x
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
getCall
list(`package:stats` = function (x, ...) 
  UseMethod("getCall"), function (x, ...) 
    UseMethod("getCall"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
getInitial
list(`package:stats` = function (object, data, ...) 
  UseMethod("getInitial"), function (object, data, ...) 
    UseMethod("getInitial"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
glm
list(`package:stats` = function (formula, family = gaussian, data, weights, subset, na.action, start = NULL, etastart, mustart, offset, control = list(...), model = TRUE, method = "glm.fit", x = FALSE, y = TRUE, singular.ok = TRUE, contrasts = NULL, ...) 
{
  cal <- match.call()
  if (is.character(family)) 
    family <- get(family, mode = "function", envir = parent.frame())
  if (is.function(family)) 
    family <- family()
  if (is.null(family$family)) {
    print(family)
    stop("'family' not recognized")
  }
  if (missing(data)) 
    data <- environment(formula)
  mf <- match.call(expand.dots = FALSE)
  m <- match(c("formula", "data", "subset", "weights", "na.action", "etastart", "mustart", "offset"), names(mf), 0)
  mf <- mf[c(1, m)]
  mf$drop.unused.levels <- TRUE
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval(mf, parent.frame())
  if (identical(method, "model.frame")) 
    return(mf)
  if (!is.character(method) && !is.function(method)) 
    stop("invalid 'method' argument")
  if (identical(method, "glm.fit")) 
    control <- do.call("glm.control", control)
  mt <- attr(mf, "terms")
  Y <- model.response(mf, "any")
  if (length(dim(Y)) == 1) {
    nm <- rownames(Y)
    dim(Y) <- NULL
    if (!is.null(nm)) 
      names(Y) <- nm
  }
  X <- if (!is.empty.model(mt)) 
    model.matrix(mt, mf, contrasts)
  else matrix(, NROW(Y), 0)
  weights <- as.vector(model.weights(mf))
  if (!is.null(weights) && !is.numeric(weights)) 
    stop("'weights' must be a numeric vector")
  if (!is.null(weights) && any(weights < 0)) 
    stop("negative weights not allowed")
  offset <- as.vector(model.offset(mf))
  if (!is.null(offset)) {
    if (length(offset) != NROW(Y)) 
      stop(gettextf("number of offsets is %d should equal %d (number of observations)", length(offset), NROW(Y)), domain = NA)
  }
  mustart <- model.extract(mf, "mustart")
  etastart <- model.extract(mf, "etastart")
  fit <- eval(call(if (is.function(method)) "method" else method, x = X, y = Y, weights = weights, start = start, etastart = etastart, mustart = mustart, offset = offset, family = family, control = control, intercept = attr(mt, "intercept") > 0, singular.ok = singular.ok))
  if (length(offset) && attr(mt, "intercept") > 0) {
    fit2 <- eval(call(if (is.function(method)) "method" else method, x = X[, "(Intercept)", drop = FALSE], y = Y, mustart = fit$fitted.values, weights = weights, offset = offset, family = family, control = control, intercept = TRUE))
    if (!fit2$converged) 
      warning("fitting to calculate the null deviance did not converge -- increase 'maxit'?")
    fit$null.deviance <- fit2$deviance
  }
  if (model) 
    fit$model <- mf
  fit$na.action <- attr(mf, "na.action")
  if (x) 
    fit$x <- X
  if (!y) 
    fit$y <- NULL
  structure(c(fit, list(call = cal, formula = formula, terms = mt, data = data, offset = offset, control = control, method = method, contrasts = attr(X, "contrasts"), xlevels = .getXlevels(mt, mf))), class = c(fit$class, c("glm", "lm")))
}, function (formula, family = gaussian, data, weights, subset, na.action, start = NULL, etastart, mustart, offset, control = list(...), model = TRUE, method = "glm.fit", x = FALSE, y = TRUE, singular.ok = TRUE, contrasts = NULL, ...) 
{
  cal <- match.call()
  if (is.character(family)) 
    family <- get(family, mode = "function", envir = parent.frame())
  if (is.function(family)) 
    family <- family()
  if (is.null(family$family)) {
    print(family)
    stop("'family' not recognized")
  }
  if (missing(data)) 
    data <- environment(formula)
  mf <- match.call(expand.dots = FALSE)
  m <- match(c("formula", "data", "subset", "weights", "na.action", "etastart", "mustart", "offset"), names(mf), 0)
  mf <- mf[c(1, m)]
  mf$drop.unused.levels <- TRUE
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval(mf, parent.frame())
  if (identical(method, "model.frame")) 
    return(mf)
  if (!is.character(method) && !is.function(method)) 
    stop("invalid 'method' argument")
  if (identical(method, "glm.fit")) 
    control <- do.call("glm.control", control)
  mt <- attr(mf, "terms")
  Y <- model.response(mf, "any")
  if (length(dim(Y)) == 1) {
    nm <- rownames(Y)
    dim(Y) <- NULL
    if (!is.null(nm)) 
      names(Y) <- nm
  }
  X <- if (!is.empty.model(mt)) 
    model.matrix(mt, mf, contrasts)
  else matrix(, NROW(Y), 0)
  weights <- as.vector(model.weights(mf))
  if (!is.null(weights) && !is.numeric(weights)) 
    stop("'weights' must be a numeric vector")
  if (!is.null(weights) && any(weights < 0)) 
    stop("negative weights not allowed")
  offset <- as.vector(model.offset(mf))
  if (!is.null(offset)) {
    if (length(offset) != NROW(Y)) 
      stop(gettextf("number of offsets is %d should equal %d (number of observations)", length(offset), NROW(Y)), domain = NA)
  }
  mustart <- model.extract(mf, "mustart")
  etastart <- model.extract(mf, "etastart")
  fit <- eval(call(if (is.function(method)) "method" else method, x = X, y = Y, weights = weights, start = start, etastart = etastart, mustart = mustart, offset = offset, family = family, control = control, intercept = attr(mt, "intercept") > 0, singular.ok = singular.ok))
  if (length(offset) && attr(mt, "intercept") > 0) {
    fit2 <- eval(call(if (is.function(method)) "method" else method, x = X[, "(Intercept)", drop = FALSE], y = Y, mustart = fit$fitted.values, weights = weights, offset = offset, family = family, control = control, intercept = TRUE))
    if (!fit2$converged) 
      warning("fitting to calculate the null deviance did not converge -- increase 'maxit'?")
    fit$null.deviance <- fit2$deviance
  }
  if (model) 
    fit$model <- mf
  fit$na.action <- attr(mf, "na.action")
  if (x) 
    fit$x <- X
  if (!y) 
    fit$y <- NULL
  structure(c(fit, list(call = cal, formula = formula, terms = mt, data = data, offset = offset, control = control, method = method, contrasts = attr(X, "contrasts"), xlevels = .getXlevels(mt, mf))), class = c(fit$class, c("glm", "lm")))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
glm.control
list(`package:stats` = function (epsilon = 1e-08, maxit = 25, trace = FALSE) 
{
  if (!is.numeric(epsilon) || epsilon <= 0) 
    stop("value of 'epsilon' must be > 0")
  if (!is.numeric(maxit) || maxit <= 0) 
    stop("maximum number of iterations must be > 0")
  list(epsilon = epsilon, maxit = maxit, trace = trace)
}, function (epsilon = 1e-08, maxit = 25, trace = FALSE) 
{
  if (!is.numeric(epsilon) || epsilon <= 0) 
    stop("value of 'epsilon' must be > 0")
  if (!is.numeric(maxit) || maxit <= 0) 
    stop("maximum number of iterations must be > 0")
  list(epsilon = epsilon, maxit = maxit, trace = trace)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
glm.fit
list(`package:stats` = function (x, y, weights = rep.int(1, nobs), start = NULL, etastart = NULL, mustart = NULL, offset = rep.int(0, nobs), family = gaussian(), control = list(), intercept = TRUE, singular.ok = TRUE) 
{
  control <- do.call("glm.control", control)
  x <- as.matrix(x)
  xnames <- dimnames(x)[[2]]
  ynames <- if (is.matrix(y)) 
    rownames(y)
  else names(y)
  conv <- FALSE
  nobs <- NROW(y)
  nvars <- ncol(x)
  EMPTY <- nvars == 0
  if (is.null(weights)) 
    weights <- rep.int(1, nobs)
  if (is.null(offset)) 
    offset <- rep.int(0, nobs)
  variance <- family$variance
  linkinv <- family$linkinv
  if (!is.function(variance) || !is.function(linkinv)) 
    stop("'family' argument seems not to be a valid family object", call. = FALSE)
  dev.resids <- family$dev.resids
  aic <- family$aic
  mu.eta <- family$mu.eta
  valideta <- family$valideta %||% function(eta) TRUE
  validmu <- family$validmu %||% function(mu) TRUE
  if (is.null(mustart)) {
    eval(family$initialize)
  }
  else {
    mukeep <- mustart
    eval(family$initialize)
    mustart <- mukeep
  }
  if (EMPTY) {
    eta <- rep.int(0, nobs) + offset
    if (!valideta(eta)) 
      stop("invalid linear predictor values in empty model", call. = FALSE)
    mu <- linkinv(eta)
    if (!validmu(mu)) 
      stop("invalid fitted means in empty model", call. = FALSE)
    dev <- sum(dev.resids(y, mu, weights))
    w <- sqrt((weights * mu.eta(eta)^2)/variance(mu))
    residuals <- (y - mu)/mu.eta(eta)
    good <- rep_len(TRUE, length(residuals))
    boundary <- conv <- TRUE
    coef <- numeric()
    iter <- 0
  }
  else {
    coefold <- NULL
    eta <- etastart %||% {
      if (!is.null(start)) 
        if (length(start) != nvars) 
          stop(gettextf("length of 'start' should equal %d and correspond to initial coefs for %s", nvars, paste(deparse(xnames), collapse = ", ")), domain = NA)
      else {
        coefold <- start
        offset + as.vector(if (NCOL(x) == 1) 
          x * start
          else x %*% start)
      }
      else family$linkfun(mustart)
    }
    mu <- linkinv(eta)
    if (!(validmu(mu) && valideta(eta))) 
      stop("cannot find valid starting values: please specify some", call. = FALSE)
    devold <- sum(dev.resids(y, mu, weights))
    boundary <- conv <- FALSE
    for (iter in 1:control$maxit) {
      good <- weights > 0
      varmu <- variance(mu)[good]
      if (anyNA(varmu)) 
        stop("NAs in V(mu)")
      if (any(varmu == 0)) 
        stop("0s in V(mu)")
      mu.eta.val <- mu.eta(eta)
      if (any(is.na(mu.eta.val[good]))) 
        stop("NAs in d(mu)/d(eta)")
      good <- (weights > 0) & (mu.eta.val != 0)
      if (all(!good)) {
        conv <- FALSE
        warning(gettextf("no observations informative at iteration %d", iter), domain = NA)
        break
      }
      z <- (eta - offset)[good] + (y - mu)[good]/mu.eta.val[good]
      w <- sqrt((weights[good] * mu.eta.val[good]^2)/variance(mu)[good])
      fit <- .Call(C_Cdqrls, x[good, , drop = FALSE] * w, z * w, min(1e-07, control$epsilon/1000), check = FALSE)
      if (any(!is.finite(fit$coefficients))) {
        conv <- FALSE
        warning(gettextf("non-finite coefficients at iteration %d", iter), domain = NA)
        break
      }
      if (nobs < fit$rank) 
        stop(sprintf(ngettext(nobs, "X matrix has rank %d, but only %d observation", "X matrix has rank %d, but only %d observations"), fit$rank, nobs), domain = NA)
      if (!singular.ok && fit$rank < nvars) 
        stop("singular fit encountered")
      start[fit$pivot] <- fit$coefficients
      eta <- drop(x %*% start)
      mu <- linkinv(eta <- eta + offset)
      dev <- sum(dev.resids(y, mu, weights))
      if (control$trace) 
        cat("Deviance = ", dev, " Iterations - ", iter, "\n", sep = "")
      boundary <- FALSE
      if (!is.finite(dev)) {
        if (is.null(coefold)) 
          stop("no valid set of coefficients has been found: please supply starting values", call. = FALSE)
        warning("step size truncated due to divergence", call. = FALSE)
        ii <- 1
        while (!is.finite(dev)) {
          if (ii > control$maxit) 
            stop("inner loop 1; cannot correct step size", call. = FALSE)
          ii <- ii + 1
          start <- (start + coefold)/2
          eta <- drop(x %*% start)
          mu <- linkinv(eta <- eta + offset)
          dev <- sum(dev.resids(y, mu, weights))
        }
        boundary <- TRUE
        if (control$trace) 
          cat("Step halved: new deviance = ", dev, "\n", sep = "")
      }
      if (!(valideta(eta) && validmu(mu))) {
        if (is.null(coefold)) 
          stop("no valid set of coefficients has been found: please supply starting values", call. = FALSE)
        warning("step size truncated: out of bounds", call. = FALSE)
        ii <- 1
        while (!(valideta(eta) && validmu(mu))) {
          if (ii > control$maxit) 
            stop("inner loop 2; cannot correct step size", call. = FALSE)
          ii <- ii + 1
          start <- (start + coefold)/2
          eta <- drop(x %*% start)
          mu <- linkinv(eta <- eta + offset)
        }
        boundary <- TRUE
        dev <- sum(dev.resids(y, mu, weights))
        if (control$trace) 
          cat("Step halved: new deviance = ", dev, "\n", sep = "")
      }
      if (abs(dev - devold)/(0.1 + abs(dev)) < control$epsilon) {
        conv <- TRUE
        coef <- start
        break
      }
      else {
        devold <- dev
        coef <- coefold <- start
      }
    }
    if (!conv) 
      warning("glm.fit: algorithm did not converge", call. = FALSE)
    if (boundary) 
      warning("glm.fit: algorithm stopped at boundary value", call. = FALSE)
    eps <- 10 * .Machine$double.eps
    if (family$family == "binomial") {
      if (any(mu > 1 - eps) || any(mu < eps)) 
        warning("glm.fit: fitted probabilities numerically 0 or 1 occurred", call. = FALSE)
    }
    if (family$family == "poisson") {
      if (any(mu < eps)) 
        warning("glm.fit: fitted rates numerically 0 occurred", call. = FALSE)
    }
    if (fit$rank < nvars) 
      coef[fit$pivot][seq.int(fit$rank + 1, nvars)] <- NA
    xxnames <- xnames[fit$pivot]
    residuals <- (y - mu)/mu.eta(eta)
    fit$qr <- as.matrix(fit$qr)
    nr <- min(sum(good), nvars)
    if (nr < nvars) {
      Rmat <- diag(nvars)
      Rmat[1:nr, 1:nvars] <- fit$qr[1:nr, 1:nvars]
    }
    else Rmat <- fit$qr[1:nvars, 1:nvars]
    Rmat <- as.matrix(Rmat)
    Rmat[row(Rmat) > col(Rmat)] <- 0
    names(coef) <- xnames
    colnames(fit$qr) <- xxnames
    dimnames(Rmat) <- list(xxnames, xxnames)
  }
  names(residuals) <- ynames
  names(mu) <- ynames
  names(eta) <- ynames
  wt <- rep.int(0, nobs)
  wt[good] <- w^2
  names(wt) <- ynames
  names(weights) <- ynames
  names(y) <- ynames
  if (!EMPTY) 
    names(fit$effects) <- c(xxnames[seq_len(fit$rank)], rep.int("", sum(good) - fit$rank))
  wtdmu <- if (intercept) 
    sum(weights * y)/sum(weights)
  else linkinv(offset)
  nulldev <- sum(dev.resids(y, wtdmu, weights))
  n.ok <- nobs - sum(weights == 0)
  nulldf <- n.ok - as.integer(intercept)
  rank <- if (EMPTY) 
    0
  else fit$rank
  resdf <- n.ok - rank
  aic.model <- aic(y, n, mu, weights, dev) + 2 * rank
  list(coefficients = coef, residuals = residuals, fitted.values = mu, effects = if (!EMPTY) fit$effects, R = if (!EMPTY) Rmat, rank = rank, qr = if (!EMPTY) structure(fit[c("qr", "rank", "qraux", "pivot", "tol")], class = "qr"), family = family, linear.predictors = eta, deviance = dev, aic = aic.model, null.deviance = nulldev, iter = iter, weights = wt, prior.weights = weights, df.residual = resdf, df.null = nulldf, y = y, converged = conv, boundary = boundary)
}, function (x, y, weights = rep.int(1, nobs), start = NULL, etastart = NULL, mustart = NULL, offset = rep.int(0, nobs), family = gaussian(), control = list(), intercept = TRUE, singular.ok = TRUE) 
{
  control <- do.call("glm.control", control)
  x <- as.matrix(x)
  xnames <- dimnames(x)[[2]]
  ynames <- if (is.matrix(y)) 
    rownames(y)
  else names(y)
  conv <- FALSE
  nobs <- NROW(y)
  nvars <- ncol(x)
  EMPTY <- nvars == 0
  if (is.null(weights)) 
    weights <- rep.int(1, nobs)
  if (is.null(offset)) 
    offset <- rep.int(0, nobs)
  variance <- family$variance
  linkinv <- family$linkinv
  if (!is.function(variance) || !is.function(linkinv)) 
    stop("'family' argument seems not to be a valid family object", call. = FALSE)
  dev.resids <- family$dev.resids
  aic <- family$aic
  mu.eta <- family$mu.eta
  valideta <- family$valideta %||% function(eta) TRUE
  validmu <- family$validmu %||% function(mu) TRUE
  if (is.null(mustart)) {
    eval(family$initialize)
  }
  else {
    mukeep <- mustart
    eval(family$initialize)
    mustart <- mukeep
  }
  if (EMPTY) {
    eta <- rep.int(0, nobs) + offset
    if (!valideta(eta)) 
      stop("invalid linear predictor values in empty model", call. = FALSE)
    mu <- linkinv(eta)
    if (!validmu(mu)) 
      stop("invalid fitted means in empty model", call. = FALSE)
    dev <- sum(dev.resids(y, mu, weights))
    w <- sqrt((weights * mu.eta(eta)^2)/variance(mu))
    residuals <- (y - mu)/mu.eta(eta)
    good <- rep_len(TRUE, length(residuals))
    boundary <- conv <- TRUE
    coef <- numeric()
    iter <- 0
  }
  else {
    coefold <- NULL
    eta <- etastart %||% {
      if (!is.null(start)) 
        if (length(start) != nvars) 
          stop(gettextf("length of 'start' should equal %d and correspond to initial coefs for %s", nvars, paste(deparse(xnames), collapse = ", ")), domain = NA)
      else {
        coefold <- start
        offset + as.vector(if (NCOL(x) == 1) 
          x * start
          else x %*% start)
      }
      else family$linkfun(mustart)
    }
    mu <- linkinv(eta)
    if (!(validmu(mu) && valideta(eta))) 
      stop("cannot find valid starting values: please specify some", call. = FALSE)
    devold <- sum(dev.resids(y, mu, weights))
    boundary <- conv <- FALSE
    for (iter in 1:control$maxit) {
      good <- weights > 0
      varmu <- variance(mu)[good]
      if (anyNA(varmu)) 
        stop("NAs in V(mu)")
      if (any(varmu == 0)) 
        stop("0s in V(mu)")
      mu.eta.val <- mu.eta(eta)
      if (any(is.na(mu.eta.val[good]))) 
        stop("NAs in d(mu)/d(eta)")
      good <- (weights > 0) & (mu.eta.val != 0)
      if (all(!good)) {
        conv <- FALSE
        warning(gettextf("no observations informative at iteration %d", iter), domain = NA)
        break
      }
      z <- (eta - offset)[good] + (y - mu)[good]/mu.eta.val[good]
      w <- sqrt((weights[good] * mu.eta.val[good]^2)/variance(mu)[good])
      fit <- .Call(C_Cdqrls, x[good, , drop = FALSE] * w, z * w, min(1e-07, control$epsilon/1000), check = FALSE)
      if (any(!is.finite(fit$coefficients))) {
        conv <- FALSE
        warning(gettextf("non-finite coefficients at iteration %d", iter), domain = NA)
        break
      }
      if (nobs < fit$rank) 
        stop(sprintf(ngettext(nobs, "X matrix has rank %d, but only %d observation", "X matrix has rank %d, but only %d observations"), fit$rank, nobs), domain = NA)
      if (!singular.ok && fit$rank < nvars) 
        stop("singular fit encountered")
      start[fit$pivot] <- fit$coefficients
      eta <- drop(x %*% start)
      mu <- linkinv(eta <- eta + offset)
      dev <- sum(dev.resids(y, mu, weights))
      if (control$trace) 
        cat("Deviance = ", dev, " Iterations - ", iter, "\n", sep = "")
      boundary <- FALSE
      if (!is.finite(dev)) {
        if (is.null(coefold)) 
          stop("no valid set of coefficients has been found: please supply starting values", call. = FALSE)
        warning("step size truncated due to divergence", call. = FALSE)
        ii <- 1
        while (!is.finite(dev)) {
          if (ii > control$maxit) 
            stop("inner loop 1; cannot correct step size", call. = FALSE)
          ii <- ii + 1
          start <- (start + coefold)/2
          eta <- drop(x %*% start)
          mu <- linkinv(eta <- eta + offset)
          dev <- sum(dev.resids(y, mu, weights))
        }
        boundary <- TRUE
        if (control$trace) 
          cat("Step halved: new deviance = ", dev, "\n", sep = "")
      }
      if (!(valideta(eta) && validmu(mu))) {
        if (is.null(coefold)) 
          stop("no valid set of coefficients has been found: please supply starting values", call. = FALSE)
        warning("step size truncated: out of bounds", call. = FALSE)
        ii <- 1
        while (!(valideta(eta) && validmu(mu))) {
          if (ii > control$maxit) 
            stop("inner loop 2; cannot correct step size", call. = FALSE)
          ii <- ii + 1
          start <- (start + coefold)/2
          eta <- drop(x %*% start)
          mu <- linkinv(eta <- eta + offset)
        }
        boundary <- TRUE
        dev <- sum(dev.resids(y, mu, weights))
        if (control$trace) 
          cat("Step halved: new deviance = ", dev, "\n", sep = "")
      }
      if (abs(dev - devold)/(0.1 + abs(dev)) < control$epsilon) {
        conv <- TRUE
        coef <- start
        break
      }
      else {
        devold <- dev
        coef <- coefold <- start
      }
    }
    if (!conv) 
      warning("glm.fit: algorithm did not converge", call. = FALSE)
    if (boundary) 
      warning("glm.fit: algorithm stopped at boundary value", call. = FALSE)
    eps <- 10 * .Machine$double.eps
    if (family$family == "binomial") {
      if (any(mu > 1 - eps) || any(mu < eps)) 
        warning("glm.fit: fitted probabilities numerically 0 or 1 occurred", call. = FALSE)
    }
    if (family$family == "poisson") {
      if (any(mu < eps)) 
        warning("glm.fit: fitted rates numerically 0 occurred", call. = FALSE)
    }
    if (fit$rank < nvars) 
      coef[fit$pivot][seq.int(fit$rank + 1, nvars)] <- NA
    xxnames <- xnames[fit$pivot]
    residuals <- (y - mu)/mu.eta(eta)
    fit$qr <- as.matrix(fit$qr)
    nr <- min(sum(good), nvars)
    if (nr < nvars) {
      Rmat <- diag(nvars)
      Rmat[1:nr, 1:nvars] <- fit$qr[1:nr, 1:nvars]
    }
    else Rmat <- fit$qr[1:nvars, 1:nvars]
    Rmat <- as.matrix(Rmat)
    Rmat[row(Rmat) > col(Rmat)] <- 0
    names(coef) <- xnames
    colnames(fit$qr) <- xxnames
    dimnames(Rmat) <- list(xxnames, xxnames)
  }
  names(residuals) <- ynames
  names(mu) <- ynames
  names(eta) <- ynames
  wt <- rep.int(0, nobs)
  wt[good] <- w^2
  names(wt) <- ynames
  names(weights) <- ynames
  names(y) <- ynames
  if (!EMPTY) 
    names(fit$effects) <- c(xxnames[seq_len(fit$rank)], rep.int("", sum(good) - fit$rank))
  wtdmu <- if (intercept) 
    sum(weights * y)/sum(weights)
  else linkinv(offset)
  nulldev <- sum(dev.resids(y, wtdmu, weights))
  n.ok <- nobs - sum(weights == 0)
  nulldf <- n.ok - as.integer(intercept)
  rank <- if (EMPTY) 
    0
  else fit$rank
  resdf <- n.ok - rank
  aic.model <- aic(y, n, mu, weights, dev) + 2 * rank
  list(coefficients = coef, residuals = residuals, fitted.values = mu, effects = if (!EMPTY) fit$effects, R = if (!EMPTY) Rmat, rank = rank, qr = if (!EMPTY) structure(fit[c("qr", "rank", "qraux", "pivot", "tol")], class = "qr"), family = family, linear.predictors = eta, deviance = dev, aic = aic.model, null.deviance = nulldev, iter = iter, weights = wt, prior.weights = weights, df.residual = resdf, df.null = nulldf, y = y, converged = conv, boundary = boundary)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
hasTsp
list(`package:stats` = function (x) 
{
  if (is.null(attr(x, "tsp"))) 
    attr(x, "tsp") <- c(1, NROW(x), 1)
  x
}, function (x) 
{
  if (is.null(attr(x, "tsp"))) 
    attr(x, "tsp") <- c(1, NROW(x), 1)
  x
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
hat
list(`package:stats` = function (x, intercept = TRUE) 
{
  if (is.qr(x)) 
    n <- nrow(x$qr)
  else {
    if (intercept) 
      x <- cbind(1, x)
    n <- nrow(x)
    x <- qr(x)
  }
  rowSums(qr.qy(x, diag(1, nrow = n, ncol = x$rank))^2)
}, function (x, intercept = TRUE) 
{
  if (is.qr(x)) 
    n <- nrow(x$qr)
  else {
    if (intercept) 
      x <- cbind(1, x)
    n <- nrow(x)
    x <- qr(x)
  }
  rowSums(qr.qy(x, diag(1, nrow = n, ncol = x$rank))^2)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
hatvalues
list(`package:stats` = function (model, ...) 
  UseMethod("hatvalues"), function (model, ...) 
    UseMethod("hatvalues"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
hclust
list(`package:stats` = function (d, method = "complete", members = NULL) 
{
  METHODS <- c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2")
  if (method == "ward") {
    message("The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\"")
    method <- "ward.D"
  }
  i.meth <- pmatch(method, METHODS)
  if (is.na(i.meth)) 
    stop("invalid clustering method", paste("", method))
  if (i.meth == -1) 
    stop("ambiguous clustering method", paste("", method))
  n <- as.integer(attr(d, "Size"))
  if (is.null(n)) 
    stop("invalid dissimilarities")
  if (is.na(n) || n > 65536) 
    stop("size cannot be NA nor exceed 65536")
  if (n < 2) 
    stop("must have n >= 2 objects to cluster")
  len <- as.integer(n * (n - 1)/2)
  if (length(d) != len) 
    (if (length(d) < len) 
      stop
     else warning)("dissimilarities of improper length")
  if (is.null(members)) 
    members <- rep(1, n)
  else if (length(members) != n) 
    stop("invalid length of members")
  storage.mode(d) <- "double"
  hcl <- .Fortran(C_hclust, n = n, len = len, method = as.integer(i.meth), ia = integer(n), ib = integer(n), crit = double(n), members = as.double(members), nn = integer(n), disnn = double(n), diss = d)
  hcass <- .Fortran(C_hcass2, n = n, ia = hcl$ia, ib = hcl$ib, order = integer(n), iia = integer(n), iib = integer(n))
  structure(list(merge = cbind(hcass$iia[1:(n - 1)], hcass$iib[1:(n - 1)]), height = hcl$crit[1:(n - 1)], order = hcass$order, labels = attr(d, "Labels"), method = METHODS[i.meth], call = match.call(), dist.method = attr(d, "method")), class = "hclust")
}, function (d, method = "complete", members = NULL) 
{
  METHODS <- c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2")
  if (method == "ward") {
    message("The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\"")
    method <- "ward.D"
  }
  i.meth <- pmatch(method, METHODS)
  if (is.na(i.meth)) 
    stop("invalid clustering method", paste("", method))
  if (i.meth == -1) 
    stop("ambiguous clustering method", paste("", method))
  n <- as.integer(attr(d, "Size"))
  if (is.null(n)) 
    stop("invalid dissimilarities")
  if (is.na(n) || n > 65536) 
    stop("size cannot be NA nor exceed 65536")
  if (n < 2) 
    stop("must have n >= 2 objects to cluster")
  len <- as.integer(n * (n - 1)/2)
  if (length(d) != len) 
    (if (length(d) < len) 
      stop
     else warning)("dissimilarities of improper length")
  if (is.null(members)) 
    members <- rep(1, n)
  else if (length(members) != n) 
    stop("invalid length of members")
  storage.mode(d) <- "double"
  hcl <- .Fortran(C_hclust, n = n, len = len, method = as.integer(i.meth), ia = integer(n), ib = integer(n), crit = double(n), members = as.double(members), nn = integer(n), disnn = double(n), diss = d)
  hcass <- .Fortran(C_hcass2, n = n, ia = hcl$ia, ib = hcl$ib, order = integer(n), iia = integer(n), iib = integer(n))
  structure(list(merge = cbind(hcass$iia[1:(n - 1)], hcass$iib[1:(n - 1)]), height = hcl$crit[1:(n - 1)], order = hcass$order, labels = attr(d, "Labels"), method = METHODS[i.meth], call = match.call(), dist.method = attr(d, "method")), class = "hclust")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
heatmap
list(`package:stats` = function (x, Rowv = NULL, Colv = if (symm) "Rowv" else NULL, distfun = dist, hclustfun = hclust, reorderfun = function(d, w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv, "Rowv"), scale = c("row", "column", "none"), na.rm = TRUE, margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, labCol = NULL, main = NULL, xlab = NULL, ylab = NULL, keep.dendro = FALSE, verbose = getOption("verbose"), ...) 
{
  scale <- if (symm && missing(scale)) 
    "none"
  else match.arg(scale)
  if (length(di <- dim(x)) != 2 || !is.numeric(x)) 
    stop("'x' must be a numeric matrix")
  nr <- di[1]
  nc <- di[2]
  if (nr <= 1 || nc <= 1) 
    stop("'x' must have at least 2 rows and 2 columns")
  if (!is.numeric(margins) || length(margins) != 2) 
    stop("'margins' must be a numeric vector of length 2")
  doRdend <- !identical(Rowv, NA)
  doCdend <- !identical(Colv, NA)
  if (!doRdend && identical(Colv, "Rowv")) 
    doCdend <- FALSE
  if (is.null(Rowv)) 
    Rowv <- rowMeans(x, na.rm = na.rm)
  if (is.null(Colv)) 
    Colv <- colMeans(x, na.rm = na.rm)
  if (doRdend) {
    if (inherits(Rowv, "dendrogram")) 
      ddr <- Rowv
    else {
      hcr <- hclustfun(distfun(x))
      ddr <- as.dendrogram(hcr)
      if (!is.logical(Rowv) || Rowv) 
        ddr <- reorderfun(ddr, Rowv)
    }
    if (nr != length(rowInd <- order.dendrogram(ddr))) 
      stop("row dendrogram ordering gave index of wrong length")
  }
  else rowInd <- 1:nr
  if (doCdend) {
    if (inherits(Colv, "dendrogram")) 
      ddc <- Colv
    else if (identical(Colv, "Rowv")) {
      if (nr != nc) 
        stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
      ddc <- ddr
    }
    else {
      hcc <- hclustfun(distfun(if (symm) 
        x
        else t(x)))
      ddc <- as.dendrogram(hcc)
      if (!is.logical(Colv) || Colv) 
        ddc <- reorderfun(ddc, Colv)
    }
    if (nc != length(colInd <- order.dendrogram(ddc))) 
      stop("column dendrogram ordering gave index of wrong length")
  }
  else colInd <- 1:nc
  x <- x[rowInd, colInd]
  labRow <- labRow[rowInd] %||% rownames(x) %||% (1:nr)[rowInd]
  labCol <- labCol[colInd] %||% colnames(x) %||% (1:nc)[colInd]
  if (scale == "row") {
    x <- sweep(x, 1, rowMeans(x, na.rm = na.rm), check.margin = FALSE)
    sx <- apply(x, 1, sd, na.rm = na.rm)
    x <- sweep(x, 1, sx, `/`, check.margin = FALSE)
  }
  else if (scale == "column") {
    x <- sweep(x, 2, colMeans(x, na.rm = na.rm), check.margin = FALSE)
    sx <- apply(x, 2, sd, na.rm = na.rm)
    x <- sweep(x, 2, sx, `/`, check.margin = FALSE)
  }
  lmat <- rbind(c(NA, 3), 2:1)
  lwid <- c(if (doRdend) 1 else 0.05, 4)
  lhei <- c((if (doCdend) 1 else 0.05) + if (!is.null(main)) 0.2 else 0, 4)
  if (!missing(ColSideColors)) {
    if (!is.character(ColSideColors) || length(ColSideColors) != nc) 
      stop("'ColSideColors' must be a character vector of length ncol(x)")
    lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
    lhei <- c(lhei[1], 0.2, lhei[2])
  }
  if (!missing(RowSideColors)) {
    if (!is.character(RowSideColors) || length(RowSideColors) != nr) 
      stop("'RowSideColors' must be a character vector of length nrow(x)")
    lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 1), lmat[, 2] + 1)
    lwid <- c(lwid[1], 0.2, lwid[2])
  }
  lmat[is.na(lmat)] <- 0
  if (verbose) {
    cat("layout: widths = ", lwid, ", heights = ", lhei, "; lmat=\n")
    print(lmat)
  }
  dev.hold()
  on.exit(dev.flush())
  op <- par(no.readonly = TRUE)
  on.exit(par(op), add = TRUE)
  layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
  if (!missing(RowSideColors)) {
    par(mar = c(margins[1], 0, 0, 0.5))
    image(rbind(if (revC) 
      nr:1
      else 1:nr), col = RowSideColors[rowInd], axes = FALSE)
  }
  if (!missing(ColSideColors)) {
    par(mar = c(0.5, 0, 0, margins[2]))
    image(cbind(1:nc), col = ColSideColors[colInd], axes = FALSE)
  }
  par(mar = c(margins[1], 0, 0, margins[2]))
  if (!symm || scale != "none") 
    x <- t(x)
  if (revC) {
    iy <- nr:1
    if (doRdend) 
      ddr <- rev(ddr)
    x <- x[, iy]
  }
  else iy <- 1:nr
  image(1:nc, 1:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", ...)
  axis(1, 1:nc, labels = labCol, las = 2, line = -0.5, tick = 0, cex.axis = cexCol)
  if (!is.null(xlab)) 
    mtext(xlab, side = 1, line = margins[1] - 1.25)
  axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0, cex.axis = cexRow)
  if (!is.null(ylab)) 
    mtext(ylab, side = 4, line = margins[2] - 1.25)
  if (!missing(add.expr)) 
    eval.parent(substitute(add.expr))
  par(mar = c(margins[1], 0, 0, 0))
  if (doRdend) 
    plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
  else frame()
  par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2]))
  if (doCdend) 
    plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
  else if (!is.null(main)) 
    frame()
  if (!is.null(main)) {
    par(xpd = NA)
    title(main, cex.main = 1.5 * op[["cex.main"]])
  }
  invisible(list(rowInd = rowInd, colInd = colInd, Rowv = if (keep.dendro && doRdend) ddr, Colv = if (keep.dendro && doCdend) ddc))
}, function (x, Rowv = NULL, Colv = if (symm) "Rowv" else NULL, distfun = dist, hclustfun = hclust, reorderfun = function(d, w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv, "Rowv"), scale = c("row", "column", "none"), na.rm = TRUE, margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, labCol = NULL, main = NULL, xlab = NULL, ylab = NULL, keep.dendro = FALSE, verbose = getOption("verbose"), ...) 
{
  scale <- if (symm && missing(scale)) 
    "none"
  else match.arg(scale)
  if (length(di <- dim(x)) != 2 || !is.numeric(x)) 
    stop("'x' must be a numeric matrix")
  nr <- di[1]
  nc <- di[2]
  if (nr <= 1 || nc <= 1) 
    stop("'x' must have at least 2 rows and 2 columns")
  if (!is.numeric(margins) || length(margins) != 2) 
    stop("'margins' must be a numeric vector of length 2")
  doRdend <- !identical(Rowv, NA)
  doCdend <- !identical(Colv, NA)
  if (!doRdend && identical(Colv, "Rowv")) 
    doCdend <- FALSE
  if (is.null(Rowv)) 
    Rowv <- rowMeans(x, na.rm = na.rm)
  if (is.null(Colv)) 
    Colv <- colMeans(x, na.rm = na.rm)
  if (doRdend) {
    if (inherits(Rowv, "dendrogram")) 
      ddr <- Rowv
    else {
      hcr <- hclustfun(distfun(x))
      ddr <- as.dendrogram(hcr)
      if (!is.logical(Rowv) || Rowv) 
        ddr <- reorderfun(ddr, Rowv)
    }
    if (nr != length(rowInd <- order.dendrogram(ddr))) 
      stop("row dendrogram ordering gave index of wrong length")
  }
  else rowInd <- 1:nr
  if (doCdend) {
    if (inherits(Colv, "dendrogram")) 
      ddc <- Colv
    else if (identical(Colv, "Rowv")) {
      if (nr != nc) 
        stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
      ddc <- ddr
    }
    else {
      hcc <- hclustfun(distfun(if (symm) 
        x
        else t(x)))
      ddc <- as.dendrogram(hcc)
      if (!is.logical(Colv) || Colv) 
        ddc <- reorderfun(ddc, Colv)
    }
    if (nc != length(colInd <- order.dendrogram(ddc))) 
      stop("column dendrogram ordering gave index of wrong length")
  }
  else colInd <- 1:nc
  x <- x[rowInd, colInd]
  labRow <- labRow[rowInd] %||% rownames(x) %||% (1:nr)[rowInd]
  labCol <- labCol[colInd] %||% colnames(x) %||% (1:nc)[colInd]
  if (scale == "row") {
    x <- sweep(x, 1, rowMeans(x, na.rm = na.rm), check.margin = FALSE)
    sx <- apply(x, 1, sd, na.rm = na.rm)
    x <- sweep(x, 1, sx, `/`, check.margin = FALSE)
  }
  else if (scale == "column") {
    x <- sweep(x, 2, colMeans(x, na.rm = na.rm), check.margin = FALSE)
    sx <- apply(x, 2, sd, na.rm = na.rm)
    x <- sweep(x, 2, sx, `/`, check.margin = FALSE)
  }
  lmat <- rbind(c(NA, 3), 2:1)
  lwid <- c(if (doRdend) 1 else 0.05, 4)
  lhei <- c((if (doCdend) 1 else 0.05) + if (!is.null(main)) 0.2 else 0, 4)
  if (!missing(ColSideColors)) {
    if (!is.character(ColSideColors) || length(ColSideColors) != nc) 
      stop("'ColSideColors' must be a character vector of length ncol(x)")
    lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
    lhei <- c(lhei[1], 0.2, lhei[2])
  }
  if (!missing(RowSideColors)) {
    if (!is.character(RowSideColors) || length(RowSideColors) != nr) 
      stop("'RowSideColors' must be a character vector of length nrow(x)")
    lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 1), lmat[, 2] + 1)
    lwid <- c(lwid[1], 0.2, lwid[2])
  }
  lmat[is.na(lmat)] <- 0
  if (verbose) {
    cat("layout: widths = ", lwid, ", heights = ", lhei, "; lmat=\n")
    print(lmat)
  }
  dev.hold()
  on.exit(dev.flush())
  op <- par(no.readonly = TRUE)
  on.exit(par(op), add = TRUE)
  layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
  if (!missing(RowSideColors)) {
    par(mar = c(margins[1], 0, 0, 0.5))
    image(rbind(if (revC) 
      nr:1
      else 1:nr), col = RowSideColors[rowInd], axes = FALSE)
  }
  if (!missing(ColSideColors)) {
    par(mar = c(0.5, 0, 0, margins[2]))
    image(cbind(1:nc), col = ColSideColors[colInd], axes = FALSE)
  }
  par(mar = c(margins[1], 0, 0, margins[2]))
  if (!symm || scale != "none") 
    x <- t(x)
  if (revC) {
    iy <- nr:1
    if (doRdend) 
      ddr <- rev(ddr)
    x <- x[, iy]
  }
  else iy <- 1:nr
  image(1:nc, 1:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", ...)
  axis(1, 1:nc, labels = labCol, las = 2, line = -0.5, tick = 0, cex.axis = cexCol)
  if (!is.null(xlab)) 
    mtext(xlab, side = 1, line = margins[1] - 1.25)
  axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0, cex.axis = cexRow)
  if (!is.null(ylab)) 
    mtext(ylab, side = 4, line = margins[2] - 1.25)
  if (!missing(add.expr)) 
    eval.parent(substitute(add.expr))
  par(mar = c(margins[1], 0, 0, 0))
  if (doRdend) 
    plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
  else frame()
  par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2]))
  if (doCdend) 
    plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
  else if (!is.null(main)) 
    frame()
  if (!is.null(main)) {
    par(xpd = NA)
    title(main, cex.main = 1.5 * op[["cex.main"]])
  }
  invisible(list(rowInd = rowInd, colInd = colInd, Rowv = if (keep.dendro && doRdend) ddr, Colv = if (keep.dendro && doCdend) ddc))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
HoltWinters
list(`package:stats` = function (x, alpha = NULL, beta = NULL, gamma = NULL, seasonal = c("additive", "multiplicative"), start.periods = 2, l.start = NULL, b.start = NULL, s.start = NULL, optim.start = c(alpha = 0.3, beta = 0.1, gamma = 0.1), optim.control = list()) 
{
  x <- as.ts(x)
  seasonal <- match.arg(seasonal)
  f <- frequency(x)
  if (!is.null(alpha) && (alpha == 0)) 
    stop("cannot fit models without level ('alpha' must not be 0 or FALSE)")
  if (!is.null(abg <- c(alpha, beta, gamma)) && any(abg < 0 | abg > 1)) 
    stop("'alpha', 'beta' and 'gamma' must be within the unit interval")
  if (is.null(gamma) || gamma > 0) {
    if (seasonal == "multiplicative" && any(x == 0)) 
      stop("data must be non-zero for multiplicative Holt-Winters")
    if (start.periods < 2) 
      stop("need at least 2 periods to compute seasonal start values")
  }
  if (!is.null(gamma) && is.logical(gamma) && !gamma) {
    expsmooth <- !is.null(beta) && is.logical(beta) && !beta
    if (is.null(l.start)) 
      l.start <- if (expsmooth) 
        x[1]
    else x[2]
    if (is.null(b.start)) 
      if (is.null(beta) || !is.logical(beta) || beta) 
        b.start <- x[2] - x[1]
    start.time <- 3 - expsmooth
    s.start <- 0
  }
  else {
    start.time <- f + 1
    wind <- start.periods * f
    st <- decompose(ts(x[1:wind], start = start(x), frequency = f), seasonal)
    if (is.null(l.start) || is.null(b.start)) {
      dat <- na.omit(st$trend)
      cf <- coef(.lm.fit(x = cbind(1, seq_along(dat)), y = dat))
      if (is.null(l.start)) 
        l.start <- cf[1]
      if (is.null(b.start)) 
        b.start <- cf[2]
    }
    if (is.null(s.start)) 
      s.start <- st$figure
  }
  lenx <- as.integer(length(x))
  if (is.na(lenx)) 
    stop("invalid length(x)")
  len <- lenx - start.time + 1
  hw <- function(alpha, beta, gamma) .C(C_HoltWinters, as.double(x), lenx, as.double(max(min(alpha, 1), 0)), as.double(max(min(beta, 1), 0)), as.double(max(min(gamma, 1), 0)), as.integer(start.time), as.integer(!+(seasonal == "multiplicative")), as.integer(f), as.integer(!is.logical(beta) || beta), as.integer(!is.logical(gamma) || gamma), a = as.double(l.start), b = as.double(b.start), s = as.double(s.start), SSE = as.double(0), level = double(len + 1), trend = double(len + 1), seasonal = double(len + 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       f))
  if (is.null(gamma)) {
    if (is.null(alpha)) {
      if (is.null(beta)) {
        error <- function(p) hw(p[1], p[2], p[3])$SSE
        sol <- optim(optim.start, error, method = "L-BFGS-B", lower = c(0, 0, 0), upper = c(1, 1, 1), control = optim.control)
        if (sol$convergence || any(sol$par < 0 | sol$par > 1)) {
          if (sol$convergence > 50) {
            warning(gettextf("optimization difficulties: %s", sol$message), domain = NA)
          }
          else stop("optimization failure")
        }
        alpha <- sol$par[1]
        beta <- sol$par[2]
        gamma <- sol$par[3]
      }
      else {
        error <- function(p) hw(p[1], beta, p[2])$SSE
        sol <- optim(c(optim.start["alpha"], optim.start["gamma"]), error, method = "L-BFGS-B", lower = c(0, 0), upper = c(1, 1), control = optim.control)
        if (sol$convergence || any(sol$par < 0 | sol$par > 1)) {
          if (sol$convergence > 50) {
            warning(gettextf("optimization difficulties: %s", sol$message), domain = NA)
          }
          else stop("optimization failure")
        }
        alpha <- sol$par[1]
        gamma <- sol$par[2]
      }
    }
    else {
      if (is.null(beta)) {
        error <- function(p) hw(alpha, p[1], p[2])$SSE
        sol <- optim(c(optim.start["beta"], optim.start["gamma"]), error, method = "L-BFGS-B", lower = c(0, 0), upper = c(1, 1), control = optim.control)
        if (sol$convergence || any(sol$par < 0 | sol$par > 1)) {
          if (sol$convergence > 50) {
            warning(gettextf("optimization difficulties: %s", sol$message), domain = NA)
          }
          else stop("optimization failure")
        }
        beta <- sol$par[1]
        gamma <- sol$par[2]
      }
      else {
        error <- function(p) hw(alpha, beta, p)$SSE
        gamma <- optimize(error, lower = 0, upper = 1)$minimum
      }
    }
  }
  else {
    if (is.null(alpha)) {
      if (is.null(beta)) {
        error <- function(p) hw(p[1], p[2], gamma)$SSE
        sol <- optim(c(optim.start["alpha"], optim.start["beta"]), error, method = "L-BFGS-B", lower = c(0, 0), upper = c(1, 1), control = optim.control)
        if (sol$convergence || any(sol$par < 0 | sol$par > 1)) {
          if (sol$convergence > 50) {
            warning(gettextf("optimization difficulties: %s", sol$message), domain = NA)
          }
          else stop("optimization failure")
        }
        alpha <- sol$par[1]
        beta <- sol$par[2]
      }
      else {
        error <- function(p) hw(p, beta, gamma)$SSE
        alpha <- optimize(error, lower = 0, upper = 1)$minimum
      }
    }
    else {
      if (is.null(beta)) {
        error <- function(p) hw(alpha, p, gamma)$SSE
        beta <- optimize(error, lower = 0, upper = 1)$minimum
      }
    }
  }
  final.fit <- hw(alpha, beta, gamma)
  fitted <- ts(cbind(xhat = final.fit$level[-len - 1], level = final.fit$level[-len - 1], trend = if (!is.logical(beta) || beta) 
    final.fit$trend[-len - 1], season = if (!is.logical(gamma) || gamma) 
      final.fit$seasonal[1:len]), start = start(lag(x, k = 1 - start.time)), frequency = frequency(x))
  if (!is.logical(beta) || beta) 
    fitted[, 1] <- fitted[, 1] + fitted[, "trend"]
  if (!is.logical(gamma) || gamma) 
    fitted[, 1] <- if (seasonal == "multiplicative") 
      fitted[, 1] * fitted[, "season"]
  else fitted[, 1] + fitted[, "season"]
  structure(list(fitted = fitted, x = x, alpha = alpha, beta = beta, gamma = gamma, coefficients = c(a = final.fit$level[len + 1], b = if (!is.logical(beta) || beta) final.fit$trend[len + 1], s = if (!is.logical(gamma) || gamma) final.fit$seasonal[len + 1:f]), seasonal = seasonal, SSE = final.fit$SSE, call = match.call()), class = "HoltWinters")
}, function (x, alpha = NULL, beta = NULL, gamma = NULL, seasonal = c("additive", "multiplicative"), start.periods = 2, l.start = NULL, b.start = NULL, s.start = NULL, optim.start = c(alpha = 0.3, beta = 0.1, gamma = 0.1), optim.control = list()) 
{
  x <- as.ts(x)
  seasonal <- match.arg(seasonal)
  f <- frequency(x)
  if (!is.null(alpha) && (alpha == 0)) 
    stop("cannot fit models without level ('alpha' must not be 0 or FALSE)")
  if (!is.null(abg <- c(alpha, beta, gamma)) && any(abg < 0 | abg > 1)) 
    stop("'alpha', 'beta' and 'gamma' must be within the unit interval")
  if (is.null(gamma) || gamma > 0) {
    if (seasonal == "multiplicative" && any(x == 0)) 
      stop("data must be non-zero for multiplicative Holt-Winters")
    if (start.periods < 2) 
      stop("need at least 2 periods to compute seasonal start values")
  }
  if (!is.null(gamma) && is.logical(gamma) && !gamma) {
    expsmooth <- !is.null(beta) && is.logical(beta) && !beta
    if (is.null(l.start)) 
      l.start <- if (expsmooth) 
        x[1]
    else x[2]
    if (is.null(b.start)) 
      if (is.null(beta) || !is.logical(beta) || beta) 
        b.start <- x[2] - x[1]
    start.time <- 3 - expsmooth
    s.start <- 0
  }
  else {
    start.time <- f + 1
    wind <- start.periods * f
    st <- decompose(ts(x[1:wind], start = start(x), frequency = f), seasonal)
    if (is.null(l.start) || is.null(b.start)) {
      dat <- na.omit(st$trend)
      cf <- coef(.lm.fit(x = cbind(1, seq_along(dat)), y = dat))
      if (is.null(l.start)) 
        l.start <- cf[1]
      if (is.null(b.start)) 
        b.start <- cf[2]
    }
    if (is.null(s.start)) 
      s.start <- st$figure
  }
  lenx <- as.integer(length(x))
  if (is.na(lenx)) 
    stop("invalid length(x)")
  len <- lenx - start.time + 1
  hw <- function(alpha, beta, gamma) .C(C_HoltWinters, as.double(x), lenx, as.double(max(min(alpha, 1), 0)), as.double(max(min(beta, 1), 0)), as.double(max(min(gamma, 1), 0)), as.integer(start.time), as.integer(!+(seasonal == "multiplicative")), as.integer(f), as.integer(!is.logical(beta) || beta), as.integer(!is.logical(gamma) || gamma), a = as.double(l.start), b = as.double(b.start), s = as.double(s.start), SSE = as.double(0), level = double(len + 1), trend = double(len + 1), seasonal = double(len + 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       f))
  if (is.null(gamma)) {
    if (is.null(alpha)) {
      if (is.null(beta)) {
        error <- function(p) hw(p[1], p[2], p[3])$SSE
        sol <- optim(optim.start, error, method = "L-BFGS-B", lower = c(0, 0, 0), upper = c(1, 1, 1), control = optim.control)
        if (sol$convergence || any(sol$par < 0 | sol$par > 1)) {
          if (sol$convergence > 50) {
            warning(gettextf("optimization difficulties: %s", sol$message), domain = NA)
          }
          else stop("optimization failure")
        }
        alpha <- sol$par[1]
        beta <- sol$par[2]
        gamma <- sol$par[3]
      }
      else {
        error <- function(p) hw(p[1], beta, p[2])$SSE
        sol <- optim(c(optim.start["alpha"], optim.start["gamma"]), error, method = "L-BFGS-B", lower = c(0, 0), upper = c(1, 1), control = optim.control)
        if (sol$convergence || any(sol$par < 0 | sol$par > 1)) {
          if (sol$convergence > 50) {
            warning(gettextf("optimization difficulties: %s", sol$message), domain = NA)
          }
          else stop("optimization failure")
        }
        alpha <- sol$par[1]
        gamma <- sol$par[2]
      }
    }
    else {
      if (is.null(beta)) {
        error <- function(p) hw(alpha, p[1], p[2])$SSE
        sol <- optim(c(optim.start["beta"], optim.start["gamma"]), error, method = "L-BFGS-B", lower = c(0, 0), upper = c(1, 1), control = optim.control)
        if (sol$convergence || any(sol$par < 0 | sol$par > 1)) {
          if (sol$convergence > 50) {
            warning(gettextf("optimization difficulties: %s", sol$message), domain = NA)
          }
          else stop("optimization failure")
        }
        beta <- sol$par[1]
        gamma <- sol$par[2]
      }
      else {
        error <- function(p) hw(alpha, beta, p)$SSE
        gamma <- optimize(error, lower = 0, upper = 1)$minimum
      }
    }
  }
  else {
    if (is.null(alpha)) {
      if (is.null(beta)) {
        error <- function(p) hw(p[1], p[2], gamma)$SSE
        sol <- optim(c(optim.start["alpha"], optim.start["beta"]), error, method = "L-BFGS-B", lower = c(0, 0), upper = c(1, 1), control = optim.control)
        if (sol$convergence || any(sol$par < 0 | sol$par > 1)) {
          if (sol$convergence > 50) {
            warning(gettextf("optimization difficulties: %s", sol$message), domain = NA)
          }
          else stop("optimization failure")
        }
        alpha <- sol$par[1]
        beta <- sol$par[2]
      }
      else {
        error <- function(p) hw(p, beta, gamma)$SSE
        alpha <- optimize(error, lower = 0, upper = 1)$minimum
      }
    }
    else {
      if (is.null(beta)) {
        error <- function(p) hw(alpha, p, gamma)$SSE
        beta <- optimize(error, lower = 0, upper = 1)$minimum
      }
    }
  }
  final.fit <- hw(alpha, beta, gamma)
  fitted <- ts(cbind(xhat = final.fit$level[-len - 1], level = final.fit$level[-len - 1], trend = if (!is.logical(beta) || beta) 
    final.fit$trend[-len - 1], season = if (!is.logical(gamma) || gamma) 
      final.fit$seasonal[1:len]), start = start(lag(x, k = 1 - start.time)), frequency = frequency(x))
  if (!is.logical(beta) || beta) 
    fitted[, 1] <- fitted[, 1] + fitted[, "trend"]
  if (!is.logical(gamma) || gamma) 
    fitted[, 1] <- if (seasonal == "multiplicative") 
      fitted[, 1] * fitted[, "season"]
  else fitted[, 1] + fitted[, "season"]
  structure(list(fitted = fitted, x = x, alpha = alpha, beta = beta, gamma = gamma, coefficients = c(a = final.fit$level[len + 1], b = if (!is.logical(beta) || beta) final.fit$trend[len + 1], s = if (!is.logical(gamma) || gamma) final.fit$seasonal[len + 1:f]), seasonal = seasonal, SSE = final.fit$SSE, call = match.call()), class = "HoltWinters")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
influence
list(`package:stats` = function (model, ...) 
  UseMethod("influence"), function (model, ...) 
    UseMethod("influence"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
influence.measures
list(`package:stats` = function (model, infl = influence(model)) 
{
  is.influential <- function(infmat, n) {
    d <- dim(infmat)
    k <- d[[length(d)]] - 4
    if (n <= k) 
      stop("too few cases i with h_ii > 0), n < k")
    absmat <- abs(infmat)
    r <- if (is.matrix(infmat)) {
      cbind(absmat[, 1:k] > 1, absmat[, k + 1] > 3 * sqrt(k/(n - k)), abs(1 - infmat[, k + 2]) > (3 * k)/(n - k), pf(infmat[, k + 3], k, n - k) > 0.5, infmat[, k + 4] > (3 * k)/n)
    }
    else {
      c(absmat[, , 1:k] > 1, absmat[, , k + 1] > 3 * sqrt(k/(n - k)), abs(1 - infmat[, , k + 2]) > (3 * k)/(n - k), pf(infmat[, , k + 3], k, n - k) > 0.5, infmat[, , k + 4] > (3 * k)/n)
    }
    attributes(r) <- attributes(infmat)
    r
  }
  p <- model$rank
  e <- weighted.residuals(model)
  s <- sqrt(sum(e^2, na.rm = TRUE)/df.residual(model))
  mqr <- qr.lm(model)
  xxi <- chol2inv(mqr$qr, mqr$rank)
  si <- infl$sigma
  h <- infl$hat
  is.mlm <- is.matrix(e)
  cf <- if (is.mlm) 
    aperm(infl$coefficients, c(1, 3:2))
  else infl$coefficients
  dfbetas <- cf/outer(infl$sigma, sqrt(diag(xxi)))
  vn <- variable.names(model)
  vn[vn == "(Intercept)"] <- "1_"
  dimnames(dfbetas)[[length(dim(dfbetas))]] <- paste0("dfb.", abbreviate(vn))
  dffits <- e * sqrt(h)/(si * (1 - h))
  if (any(ii <- is.infinite(dffits))) 
    dffits[ii] <- NaN
  cov.ratio <- (si/s)^(2 * p)/(1 - h)
  cooks.d <- if (inherits(model, "glm")) 
    (infl$pear.res/(1 - h))^2 * h/(summary(model)$dispersion * p)
  else ((e/(s * (1 - h)))^2 * h)/p
  infmat <- if (is.mlm) {
    dns <- dimnames(dfbetas)
    dns[[3]] <- c(dns[[3]], "dffit", "cov.r", "cook.d", "hat")
    a <- array(dfbetas, dim = dim(dfbetas) + c(0, 0, 3 + 1), dimnames = dns)
    a[, , "dffit"] <- dffits
    a[, , "cov.r"] <- cov.ratio
    a[, , "cook.d"] <- cooks.d
    a[, , "hat"] <- h
    a
  }
  else {
    cbind(dfbetas, dffit = dffits, cov.r = cov.ratio, cook.d = cooks.d, hat = h)
  }
  infmat[is.infinite(infmat)] <- NaN
  is.inf <- is.influential(infmat, sum(h > 0))
  ans <- list(infmat = infmat, is.inf = is.inf, call = model$call)
  class(ans) <- "infl"
  ans
}, function (model, infl = influence(model)) 
{
  is.influential <- function(infmat, n) {
    d <- dim(infmat)
    k <- d[[length(d)]] - 4
    if (n <= k) 
      stop("too few cases i with h_ii > 0), n < k")
    absmat <- abs(infmat)
    r <- if (is.matrix(infmat)) {
      cbind(absmat[, 1:k] > 1, absmat[, k + 1] > 3 * sqrt(k/(n - k)), abs(1 - infmat[, k + 2]) > (3 * k)/(n - k), pf(infmat[, k + 3], k, n - k) > 0.5, infmat[, k + 4] > (3 * k)/n)
    }
    else {
      c(absmat[, , 1:k] > 1, absmat[, , k + 1] > 3 * sqrt(k/(n - k)), abs(1 - infmat[, , k + 2]) > (3 * k)/(n - k), pf(infmat[, , k + 3], k, n - k) > 0.5, infmat[, , k + 4] > (3 * k)/n)
    }
    attributes(r) <- attributes(infmat)
    r
  }
  p <- model$rank
  e <- weighted.residuals(model)
  s <- sqrt(sum(e^2, na.rm = TRUE)/df.residual(model))
  mqr <- qr.lm(model)
  xxi <- chol2inv(mqr$qr, mqr$rank)
  si <- infl$sigma
  h <- infl$hat
  is.mlm <- is.matrix(e)
  cf <- if (is.mlm) 
    aperm(infl$coefficients, c(1, 3:2))
  else infl$coefficients
  dfbetas <- cf/outer(infl$sigma, sqrt(diag(xxi)))
  vn <- variable.names(model)
  vn[vn == "(Intercept)"] <- "1_"
  dimnames(dfbetas)[[length(dim(dfbetas))]] <- paste0("dfb.", abbreviate(vn))
  dffits <- e * sqrt(h)/(si * (1 - h))
  if (any(ii <- is.infinite(dffits))) 
    dffits[ii] <- NaN
  cov.ratio <- (si/s)^(2 * p)/(1 - h)
  cooks.d <- if (inherits(model, "glm")) 
    (infl$pear.res/(1 - h))^2 * h/(summary(model)$dispersion * p)
  else ((e/(s * (1 - h)))^2 * h)/p
  infmat <- if (is.mlm) {
    dns <- dimnames(dfbetas)
    dns[[3]] <- c(dns[[3]], "dffit", "cov.r", "cook.d", "hat")
    a <- array(dfbetas, dim = dim(dfbetas) + c(0, 0, 3 + 1), dimnames = dns)
    a[, , "dffit"] <- dffits
    a[, , "cov.r"] <- cov.ratio
    a[, , "cook.d"] <- cooks.d
    a[, , "hat"] <- h
    a
  }
  else {
    cbind(dfbetas, dffit = dffits, cov.r = cov.ratio, cook.d = cooks.d, hat = h)
  }
  infmat[is.infinite(infmat)] <- NaN
  is.inf <- is.influential(infmat, sum(h > 0))
  ans <- list(infmat = infmat, is.inf = is.inf, call = model$call)
  class(ans) <- "infl"
  ans
}, function (model, infl = influence(model)) 
{
  is.influential <- function(infmat, n) {
    d <- dim(infmat)
    k <- d[[length(d)]] - 4
    if (n <= k) 
      stop("too few cases i with h_ii > 0), n < k")
    absmat <- abs(infmat)
    r <- if (is.matrix(infmat)) {
      cbind(absmat[, 1:k] > 1, absmat[, k + 1] > 3 * sqrt(k/(n - k)), abs(1 - infmat[, k + 2]) > (3 * k)/(n - k), pf(infmat[, k + 3], k, n - k) > 0.5, infmat[, k + 4] > (3 * k)/n)
    }
    else {
      c(absmat[, , 1:k] > 1, absmat[, , k + 1] > 3 * sqrt(k/(n - k)), abs(1 - infmat[, , k + 2]) > (3 * k)/(n - k), pf(infmat[, , k + 3], k, n - k) > 0.5, infmat[, , k + 4] > (3 * k)/n)
    }
    attributes(r) <- attributes(infmat)
    r
  }
  p <- model$rank
  e <- weighted.residuals(model)
  s <- sqrt(sum(e^2, na.rm = TRUE)/df.residual(model))
  mqr <- qr.lm(model)
  xxi <- chol2inv(mqr$qr, mqr$rank)
  si <- infl$sigma
  h <- infl$hat
  is.mlm <- is.matrix(e)
  cf <- if (is.mlm) 
    aperm(infl$coefficients, c(1, 3:2))
  else infl$coefficients
  dfbetas <- cf/outer(infl$sigma, sqrt(diag(xxi)))
  vn <- variable.names(model)
  vn[vn == "(Intercept)"] <- "1_"
  dimnames(dfbetas)[[length(dim(dfbetas))]] <- paste0("dfb.", abbreviate(vn))
  dffits <- e * sqrt(h)/(si * (1 - h))
  if (any(ii <- is.infinite(dffits))) 
    dffits[ii] <- NaN
  cov.ratio <- (si/s)^(2 * p)/(1 - h)
  cooks.d <- if (inherits(model, "glm")) 
    (infl$pear.res/(1 - h))^2 * h/(summary(model)$dispersion * p)
  else ((e/(s * (1 - h)))^2 * h)/p
  infmat <- if (is.mlm) {
    dns <- dimnames(dfbetas)
    dns[[3]] <- c(dns[[3]], "dffit", "cov.r", "cook.d", "hat")
    a <- array(dfbetas, dim = dim(dfbetas) + c(0, 0, 3 + 1), dimnames = dns)
    a[, , "dffit"] <- dffits
    a[, , "cov.r"] <- cov.ratio
    a[, , "cook.d"] <- cooks.d
    a[, , "hat"] <- h
    a
  }
  else {
    cbind(dfbetas, dffit = dffits, cov.r = cov.ratio, cook.d = cooks.d, hat = h)
  }
  infmat[is.infinite(infmat)] <- NaN
  is.inf <- is.influential(infmat, sum(h > 0))
  ans <- list(infmat = infmat, is.inf = is.inf, call = model$call)
  class(ans) <- "infl"
  ans
})
c("package:stats", "registered S3 method for influence from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
integrate
list(`package:stats` = function (f, lower, upper, ..., subdivisions = 100, rel.tol = .Machine$double.eps^0.25, abs.tol = rel.tol, stop.on.error = TRUE, keep.xy = FALSE, aux = NULL) 
{
  f <- match.fun(f)
  ff <- function(x) f(x, ...)
  limit <- as.integer(subdivisions)
  if (limit < 1 || (abs.tol <= 0 && rel.tol < max(50 * .Machine$double.eps, 5e-29))) 
    stop("invalid parameter values")
  stopifnot(length(lower) == 1, length(upper) == 1)
  if (is.finite(lower) && is.finite(upper)) {
    wk <- .External(C_call_dqags, ff, rho = environment(), as.double(lower), as.double(upper), as.double(abs.tol), as.double(rel.tol), limit = limit)
  }
  else {
    if (is.na(lower) || is.na(upper)) 
      stop("a limit is NA or NaN")
    if (is.finite(lower)) {
      inf <- 1
      bound <- lower
    }
    else if (is.finite(upper)) {
      inf <- -1
      bound <- upper
    }
    else {
      inf <- 2
      bound <- 0
    }
    wk <- .External(C_call_dqagi, ff, rho = environment(), as.double(bound), inf, as.double(abs.tol), as.double(rel.tol), limit = limit)
  }
  res <- wk[c("value", "abs.error", "subdivisions")]
  res$message <- switch(wk$ierr + 1, "OK", "maximum number of subdivisions reached", "roundoff error was detected", "extremely bad integrand behaviour", "roundoff error is detected in the extrapolation table", "the integral is probably divergent", "the input is invalid")
  if (wk$ierr == 6 || (wk$ierr > 0 && stop.on.error)) 
    stop(res$message)
  res$call <- match.call()
  class(res) <- "integrate"
  res
}, function (f, lower, upper, ..., subdivisions = 100, rel.tol = .Machine$double.eps^0.25, abs.tol = rel.tol, stop.on.error = TRUE, keep.xy = FALSE, aux = NULL) 
{
  f <- match.fun(f)
  ff <- function(x) f(x, ...)
  limit <- as.integer(subdivisions)
  if (limit < 1 || (abs.tol <= 0 && rel.tol < max(50 * .Machine$double.eps, 5e-29))) 
    stop("invalid parameter values")
  stopifnot(length(lower) == 1, length(upper) == 1)
  if (is.finite(lower) && is.finite(upper)) {
    wk <- .External(C_call_dqags, ff, rho = environment(), as.double(lower), as.double(upper), as.double(abs.tol), as.double(rel.tol), limit = limit)
  }
  else {
    if (is.na(lower) || is.na(upper)) 
      stop("a limit is NA or NaN")
    if (is.finite(lower)) {
      inf <- 1
      bound <- lower
    }
    else if (is.finite(upper)) {
      inf <- -1
      bound <- upper
    }
    else {
      inf <- 2
      bound <- 0
    }
    wk <- .External(C_call_dqagi, ff, rho = environment(), as.double(bound), inf, as.double(abs.tol), as.double(rel.tol), limit = limit)
  }
  res <- wk[c("value", "abs.error", "subdivisions")]
  res$message <- switch(wk$ierr + 1, "OK", "maximum number of subdivisions reached", "roundoff error was detected", "extremely bad integrand behaviour", "roundoff error is detected in the extrapolation table", "the integral is probably divergent", "the input is invalid")
  if (wk$ierr == 6 || (wk$ierr > 0 && stop.on.error)) 
    stop(res$message)
  res$call <- match.call()
  class(res) <- "integrate"
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
interaction.plot
list(`package:stats` = function (x.factor, trace.factor, response, fun = mean, type = c("l", "p", "b", "o", "c"), legend = TRUE, trace.label = deparse1(substitute(trace.factor)), fixed = FALSE, xlab = deparse1(substitute(x.factor)), ylab = ylabel, ylim = range(cells, na.rm = TRUE), lty = nc:1, col = 1, pch = c(1:9, 0, letters), xpd = NULL, leg.bg = par("bg"), leg.bty = "n", xtick = FALSE, xaxt = par("xaxt"), axes = TRUE, ...) 
{
  ylabel <- paste(deparse1(substitute(fun)), "of ", deparse1(substitute(response)))
  type <- match.arg(type)
  cells <- tapply(response, list(x.factor, trace.factor), fun)
  nr <- nrow(cells)
  nc <- ncol(cells)
  xvals <- 1:nr
  if (is.ordered(x.factor)) {
    wn <- getOption("warn")
    options(warn = -1)
    xnm <- as.numeric(levels(x.factor))
    options(warn = wn)
    if (!anyNA(xnm)) 
      xvals <- xnm
  }
  xlabs <- rownames(cells)
  ylabs <- colnames(cells)
  nch <- max(sapply(ylabs, nchar, type = "width"))
  if (is.null(xlabs)) 
    xlabs <- as.character(xvals)
  if (is.null(ylabs)) 
    ylabs <- as.character(1:nc)
  xlim <- range(xvals)
  xleg <- xlim[2] + 0.05 * diff(xlim)
  xlim <- xlim + c(-0.2/nr, if (legend) 0.2 + 0.02 * nch else 0.2/nr) * diff(xlim)
  dev.hold()
  on.exit(dev.flush())
  matplot(xvals, cells, ..., type = type, xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab, axes = axes, xaxt = "n", col = col, lty = lty, pch = pch)
  if (axes && xaxt != "n") {
    axisInt <- function(main, sub, lwd, bg, log, asp, ...) axis(...)
    axisInt(side = 1, at = xvals, labels = xlabs, tick = xtick, xaxt = xaxt, ...)
  }
  if (legend) {
    yrng <- diff(ylim)
    yleg <- ylim[2] - 0.1 * yrng
    if (!is.null(xpd) || {
      xpd. <- par("xpd")
      !is.na(xpd.) && !xpd. && (xpd <- TRUE)
    }) {
      op <- par(xpd = xpd)
      on.exit(par(op), add = TRUE)
    }
    text(xleg, ylim[2] - 0.05 * yrng, paste("  ", trace.label), adj = 0)
    if (!fixed) {
      ord <- sort.list(cells[nr, ], decreasing = TRUE)
      ylabs <- ylabs[ord]
      lty <- lty[1 + (ord - 1)%%length(lty)]
      col <- col[1 + (ord - 1)%%length(col)]
      pch <- pch[ord]
    }
    legend(xleg, yleg, legend = ylabs, col = col, pch = if (type %in% c("p", "b")) 
      pch, lty = if (type %in% c("l", "b")) 
        lty, bty = leg.bty, bg = leg.bg)
  }
  invisible()
}, function (x.factor, trace.factor, response, fun = mean, type = c("l", "p", "b", "o", "c"), legend = TRUE, trace.label = deparse1(substitute(trace.factor)), fixed = FALSE, xlab = deparse1(substitute(x.factor)), ylab = ylabel, ylim = range(cells, na.rm = TRUE), lty = nc:1, col = 1, pch = c(1:9, 0, letters), xpd = NULL, leg.bg = par("bg"), leg.bty = "n", xtick = FALSE, xaxt = par("xaxt"), axes = TRUE, ...) 
{
  ylabel <- paste(deparse1(substitute(fun)), "of ", deparse1(substitute(response)))
  type <- match.arg(type)
  cells <- tapply(response, list(x.factor, trace.factor), fun)
  nr <- nrow(cells)
  nc <- ncol(cells)
  xvals <- 1:nr
  if (is.ordered(x.factor)) {
    wn <- getOption("warn")
    options(warn = -1)
    xnm <- as.numeric(levels(x.factor))
    options(warn = wn)
    if (!anyNA(xnm)) 
      xvals <- xnm
  }
  xlabs <- rownames(cells)
  ylabs <- colnames(cells)
  nch <- max(sapply(ylabs, nchar, type = "width"))
  if (is.null(xlabs)) 
    xlabs <- as.character(xvals)
  if (is.null(ylabs)) 
    ylabs <- as.character(1:nc)
  xlim <- range(xvals)
  xleg <- xlim[2] + 0.05 * diff(xlim)
  xlim <- xlim + c(-0.2/nr, if (legend) 0.2 + 0.02 * nch else 0.2/nr) * diff(xlim)
  dev.hold()
  on.exit(dev.flush())
  matplot(xvals, cells, ..., type = type, xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab, axes = axes, xaxt = "n", col = col, lty = lty, pch = pch)
  if (axes && xaxt != "n") {
    axisInt <- function(main, sub, lwd, bg, log, asp, ...) axis(...)
    axisInt(side = 1, at = xvals, labels = xlabs, tick = xtick, xaxt = xaxt, ...)
  }
  if (legend) {
    yrng <- diff(ylim)
    yleg <- ylim[2] - 0.1 * yrng
    if (!is.null(xpd) || {
      xpd. <- par("xpd")
      !is.na(xpd.) && !xpd. && (xpd <- TRUE)
    }) {
      op <- par(xpd = xpd)
      on.exit(par(op), add = TRUE)
    }
    text(xleg, ylim[2] - 0.05 * yrng, paste("  ", trace.label), adj = 0)
    if (!fixed) {
      ord <- sort.list(cells[nr, ], decreasing = TRUE)
      ylabs <- ylabs[ord]
      lty <- lty[1 + (ord - 1)%%length(lty)]
      col <- col[1 + (ord - 1)%%length(col)]
      pch <- pch[ord]
    }
    legend(xleg, yleg, legend = ylabs, col = col, pch = if (type %in% c("p", "b")) 
      pch, lty = if (type %in% c("l", "b")) 
        lty, bty = leg.bty, bg = leg.bg)
  }
  invisible()
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
inverse.gaussian
list(`package:stats` = function (link = "1/mu^2") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  family <- "inverse.gaussian"
  okLinks <- c("inverse", "log", "identity", "1/mu^2")
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu^3
  dev.resids <- function(y, mu, wt) wt * ((y - mu)^2)/(y * mu^2)
  aic <- function(y, n, mu, wt, dev) sum(wt) * (1 + log(dev/sum(wt) * 2 * pi)) + 3 * sum(log(y) * wt) + 2
  initialize <- expression({
    if (any(y <= 0)) stop("positive values only are allowed for the 'inverse.gaussian' family")
    n <- rep.int(1, nobs)
    mustart <- y
  })
  validmu <- function(mu) TRUE
  simfun <- function(object, nsim) {
    if (!requireNamespace("SuppDists", quietly = TRUE)) 
      stop("need CRAN package 'SuppDists' for simulation from the 'inverse.gaussian' family")
    wts <- object$prior.weights
    if (any(wts != 1)) 
      message("using weights as inverse variances")
    ftd <- fitted(object)
    SuppDists::rinvGauss(nsim * length(ftd), nu = ftd, lambda = wts/summary(object)$dispersion)
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
}, function (link = "1/mu^2") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  family <- "inverse.gaussian"
  okLinks <- c("inverse", "log", "identity", "1/mu^2")
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu^3
  dev.resids <- function(y, mu, wt) wt * ((y - mu)^2)/(y * mu^2)
  aic <- function(y, n, mu, wt, dev) sum(wt) * (1 + log(dev/sum(wt) * 2 * pi)) + 3 * sum(log(y) * wt) + 2
  initialize <- expression({
    if (any(y <= 0)) stop("positive values only are allowed for the 'inverse.gaussian' family")
    n <- rep.int(1, nobs)
    mustart <- y
  })
  validmu <- function(mu) TRUE
  simfun <- function(object, nsim) {
    if (!requireNamespace("SuppDists", quietly = TRUE)) 
      stop("need CRAN package 'SuppDists' for simulation from the 'inverse.gaussian' family")
    wts <- object$prior.weights
    if (any(wts != 1)) 
      message("using weights as inverse variances")
    ftd <- fitted(object)
    SuppDists::rinvGauss(nsim * length(ftd), nu = ftd, lambda = wts/summary(object)$dispersion)
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
IQR
list(`package:stats` = function (x, na.rm = FALSE, type = 7) 
  diff(quantile(as.numeric(x), c(0.25, 0.75), na.rm = na.rm, names = FALSE, type = type)), function (x, na.rm = FALSE, type = 7) 
    diff(quantile(as.numeric(x), c(0.25, 0.75), na.rm = na.rm, names = FALSE, type = type)))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.empty.model
list(`package:stats` = function (x) 
{
  tt <- terms(x)
  (length(attr(tt, "factors")) == 0) & (attr(tt, "intercept") == 0)
}, function (x) 
{
  tt <- terms(x)
  (length(attr(tt, "factors")) == 0) & (attr(tt, "intercept") == 0)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.leaf
list(`package:stats` = function (object) 
  (is.logical(L <- attr(object, "leaf"))) && L, function (object) 
    (is.logical(L <- attr(object, "leaf"))) && L)
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.mts
list(`package:stats` = function (x) 
  inherits(x, "mts"), function (x) 
    inherits(x, "mts"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.stepfun
list(`package:stats` = function (x) 
  is.function(x) && inherits(x, "stepfun"), function (x) 
    is.function(x) && inherits(x, "stepfun"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.ts
list(`package:stats` = function (x) 
  inherits(x, "ts") && length(x), function (x) 
    inherits(x, "ts") && length(x))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.tskernel
list(`package:stats` = function (k) 
{
  inherits(k, "tskernel")
}, function (k) 
{
  inherits(k, "tskernel")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
isoreg
list(`package:stats` = function (x, y = NULL) 
{
  xy <- xy.coords(x, y)
  x <- xy$x
  if (anyNA(x) || anyNA(xy$y)) 
    stop("missing values not allowed")
  isOrd <- ((!is.null(xy$xlab) && xy$xlab == "Index") || !is.unsorted(x, strictly = TRUE))
  if (!isOrd) {
    y <- xy$y
    ord <- order(x, -y)
    y <- y[ord]
  }
  z <- .Call(C_isoreg, if (isOrd) xy$y else y)
  structure(c(xy[c("x", "y")], z[c("yf", "yc", "iKnots")], list(isOrd = isOrd, ord = if (!isOrd) ord, call = match.call())), class = "isoreg")
}, function (x, y = NULL) 
{
  xy <- xy.coords(x, y)
  x <- xy$x
  if (anyNA(x) || anyNA(xy$y)) 
    stop("missing values not allowed")
  isOrd <- ((!is.null(xy$xlab) && xy$xlab == "Index") || !is.unsorted(x, strictly = TRUE))
  if (!isOrd) {
    y <- xy$y
    ord <- order(x, -y)
    y <- y[ord]
  }
  z <- .Call(C_isoreg, if (isOrd) xy$y else y)
  structure(c(xy[c("x", "y")], z[c("yf", "yc", "iKnots")], list(isOrd = isOrd, ord = if (!isOrd) ord, call = match.call())), class = "isoreg")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
KalmanForecast
list(`package:stats` = function (n.ahead = 10, mod, update = FALSE) 
  .Call(C_KalmanFore, as.integer(n.ahead), mod, update), function (n.ahead = 10, mod, update = FALSE) 
    .Call(C_KalmanFore, as.integer(n.ahead), mod, update))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
KalmanLike
list(`package:stats` = function (y, mod, nit = 0, update = FALSE) 
{
  x <- .Call(C_KalmanLike, y, mod, nit, FALSE, update)
  z <- list(Lik = 0.5 * (log(x[1]) + x[2]), s2 = x[1])
  if (update) 
    attr(z, "mod") <- attr(x, "mod")
  z
}, function (y, mod, nit = 0, update = FALSE) 
{
  x <- .Call(C_KalmanLike, y, mod, nit, FALSE, update)
  z <- list(Lik = 0.5 * (log(x[1]) + x[2]), s2 = x[1])
  if (update) 
    attr(z, "mod") <- attr(x, "mod")
  z
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
KalmanRun
list(`package:stats` = function (y, mod, nit = 0, update = FALSE) 
{
  z <- .Call(C_KalmanLike, y, mod, nit, TRUE, update)
  x <- z$values
  z[[1]] <- c(Lik = 0.5 * (log(x[1]) + x[2]), s2 = x[1])
  z
}, function (y, mod, nit = 0, update = FALSE) 
{
  z <- .Call(C_KalmanLike, y, mod, nit, TRUE, update)
  x <- z$values
  z[[1]] <- c(Lik = 0.5 * (log(x[1]) + x[2]), s2 = x[1])
  z
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
KalmanSmooth
list(`package:stats` = function (y, mod, nit = 0) 
{
  z <- .Call(C_KalmanSmooth, y, mod, as.integer(nit))
  dn <- dim(z$smooth)
  dim(z$var) <- dn[c(1, 2, 2)]
  z
}, function (y, mod, nit = 0) 
{
  z <- .Call(C_KalmanSmooth, y, mod, as.integer(nit))
  dn <- dim(z$smooth)
  dim(z$var) <- dn[c(1, 2, 2)]
  z
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
kernapply
list(`package:stats` = function (x, ...) 
{
  UseMethod("kernapply")
}, function (x, ...) 
{
  UseMethod("kernapply")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
kernel
list(`package:stats` = function (coef, m = 2, r, name = "unknown") 
{
  mkName <- function(name, args) paste0(name, "(", paste(args, collapse = ","), ")")
  modified.daniell.kernel <- function(m) {
    if (length(m) == 1) 
      k <- kernel(c(rep_len(1, m), 0.5)/(2 * m), m)
    else {
      k <- Recall(m[1])
      for (i in 2:length(m)) k <- kernapply(k, Recall(m[i]))
    }
    attr(k, "name") <- mkName("mDaniell", m)
    k
  }
  daniell.kernel <- function(m) {
    if (length(m) == 1) 
      k <- kernel(rep_len(1/(2 * m + 1), m + 1), m)
    else {
      k <- Recall(m[1])
      for (i in 2:length(m)) k <- kernapply(k, Recall(m[i]))
    }
    attr(k, "name") <- mkName("Daniell", m)
    k
  }
  fejer.kernel <- function(m, r) {
    if (r < 1) 
      stop("'r' is less than 1")
    if (m < 1) 
      stop("'m' is less than 1")
    n <- 2 * m + 1
    wn <- double(m + 1)
    wj <- 2 * pi * (1:m)/n
    wn[2:(m + 1)] <- sin(r * wj/2)^2/sin(wj/2)^2/r
    wn[1] <- r
    wn <- wn/(wn[1] + 2 * sum(wn[2:(m + 1)]))
    kernel(wn, m, name = mkName("Fejer", c(m, r)))
  }
  dirichlet.kernel <- function(m, r) {
    if (r < 0) 
      stop("'r' is less than 0")
    if (m < 1) 
      stop("'m' is less than 1")
    n <- 2 * m + 1
    wn <- double(m + 1)
    wj <- 2 * pi * (1:m)/n
    wn[2:(m + 1)] <- sin((r + 0.5) * wj)/sin(wj/2)
    wn[1] <- 2 * r + 1
    wn <- wn/(wn[1] + 2 * sum(wn[2:(m + 1)]))
    kernel(wn, m, name = mkName("Dirichlet", c(m, r)))
  }
  if (!missing(m)) 
    if (!is.numeric(m) || length(m) < 1 || any(m != round(m)) || any(m < 0)) 
      stop("'m' must be numeric with non-negative integers")
  if (is.character(coef)) {
    switch(coef, daniell = daniell.kernel(m), dirichlet = dirichlet.kernel(m, r), fejer = fejer.kernel(m, r), modified.daniell = modified.daniell.kernel(m), stop("unknown named kernel"))
  }
  else {
    if (!is.numeric(coef)) 
      stop("'coef' must be a vector")
    if (length(coef) < 1) 
      stop("'coef' does not have the correct length")
    m <- length(coef) - 1
    kernel <- list(coef = coef, m = m)
    attr(kernel, "name") <- name
    class(kernel) <- "tskernel"
    sk <- sum(kernel[-m:m])
    if (abs(sk - 1) > getOption("ts.eps")) 
      stop("coefficients do not add to 1")
    kernel
  }
}, function (coef, m = 2, r, name = "unknown") 
{
  mkName <- function(name, args) paste0(name, "(", paste(args, collapse = ","), ")")
  modified.daniell.kernel <- function(m) {
    if (length(m) == 1) 
      k <- kernel(c(rep_len(1, m), 0.5)/(2 * m), m)
    else {
      k <- Recall(m[1])
      for (i in 2:length(m)) k <- kernapply(k, Recall(m[i]))
    }
    attr(k, "name") <- mkName("mDaniell", m)
    k
  }
  daniell.kernel <- function(m) {
    if (length(m) == 1) 
      k <- kernel(rep_len(1/(2 * m + 1), m + 1), m)
    else {
      k <- Recall(m[1])
      for (i in 2:length(m)) k <- kernapply(k, Recall(m[i]))
    }
    attr(k, "name") <- mkName("Daniell", m)
    k
  }
  fejer.kernel <- function(m, r) {
    if (r < 1) 
      stop("'r' is less than 1")
    if (m < 1) 
      stop("'m' is less than 1")
    n <- 2 * m + 1
    wn <- double(m + 1)
    wj <- 2 * pi * (1:m)/n
    wn[2:(m + 1)] <- sin(r * wj/2)^2/sin(wj/2)^2/r
    wn[1] <- r
    wn <- wn/(wn[1] + 2 * sum(wn[2:(m + 1)]))
    kernel(wn, m, name = mkName("Fejer", c(m, r)))
  }
  dirichlet.kernel <- function(m, r) {
    if (r < 0) 
      stop("'r' is less than 0")
    if (m < 1) 
      stop("'m' is less than 1")
    n <- 2 * m + 1
    wn <- double(m + 1)
    wj <- 2 * pi * (1:m)/n
    wn[2:(m + 1)] <- sin((r + 0.5) * wj)/sin(wj/2)
    wn[1] <- 2 * r + 1
    wn <- wn/(wn[1] + 2 * sum(wn[2:(m + 1)]))
    kernel(wn, m, name = mkName("Dirichlet", c(m, r)))
  }
  if (!missing(m)) 
    if (!is.numeric(m) || length(m) < 1 || any(m != round(m)) || any(m < 0)) 
      stop("'m' must be numeric with non-negative integers")
  if (is.character(coef)) {
    switch(coef, daniell = daniell.kernel(m), dirichlet = dirichlet.kernel(m, r), fejer = fejer.kernel(m, r), modified.daniell = modified.daniell.kernel(m), stop("unknown named kernel"))
  }
  else {
    if (!is.numeric(coef)) 
      stop("'coef' must be a vector")
    if (length(coef) < 1) 
      stop("'coef' does not have the correct length")
    m <- length(coef) - 1
    kernel <- list(coef = coef, m = m)
    attr(kernel, "name") <- name
    class(kernel) <- "tskernel"
    sk <- sum(kernel[-m:m])
    if (abs(sk - 1) > getOption("ts.eps")) 
      stop("coefficients do not add to 1")
    kernel
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
kmeans
list(`package:stats` = function (x, centers, iter.max = 10, nstart = 1, algorithm = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"), trace = FALSE) 
{
  .Mimax <- .Machine$integer.max
  do_one <- function(nmeth) {
    switch(nmeth, {
      isteps.Qtran <- as.integer(min(.Mimax, 50 * m))
      iTran <- c(isteps.Qtran, integer(k))
      Z <- .Fortran(C_kmns, x, m, p, centers = centers, as.integer(k), c1 = integer(m), c2 = integer(m), nc = integer(k), double(k), double(k), ncp = integer(k), D = double(m), iTran = iTran, live = integer(k), iter = iter.max, wss = double(k), ifault = as.integer(trace))
      switch(Z$ifault, stop("empty cluster: try a better set of initial centers", call. = FALSE), Z$iter <- max(Z$iter, iter.max + 1), stop("number of cluster centres must lie between 1 and nrow(x)", call. = FALSE), warning(gettextf("Quick-TRANSfer stage steps exceeded maximum (= %d)", isteps.Qtran), call. = FALSE))
    }, {
      Z <- .C(C_kmeans_Lloyd, x, m, p, centers = centers, k, c1 = integer(m), iter = iter.max, nc = integer(k), wss = double(k))
    }, {
      Z <- .C(C_kmeans_MacQueen, x, m, p, centers = as.double(centers), k, c1 = integer(m), iter = iter.max, nc = integer(k), wss = double(k))
    })
    if (m23 <- any(nmeth == c(2, 3))) {
      if (any(Z$nc == 0)) 
        warning("empty cluster: try a better set of initial centers", call. = FALSE)
    }
    if (Z$iter > iter.max) {
      warning(sprintf(ngettext(iter.max, "did not converge in %d iteration", "did not converge in %d iterations"), iter.max), call. = FALSE, domain = NA)
      if (m23) 
        Z$ifault <- 2
    }
    if (nmeth %in% c(2, 3)) {
      if (any(Z$nc == 0)) 
        warning("empty cluster: try a better set of initial centers", call. = FALSE)
    }
    Z
  }
  x <- as.matrix(x)
  m <- as.integer(nrow(x))
  if (is.na(m)) 
    stop("invalid nrow(x)")
  p <- as.integer(ncol(x))
  if (is.na(p)) 
    stop("invalid ncol(x)")
  if (missing(centers)) 
    stop("'centers' must be a number or a matrix")
  nmeth <- switch(match.arg(algorithm), `Hartigan-Wong` = 1, Lloyd = 2, Forgy = 2, MacQueen = 3)
  storage.mode(x) <- "double"
  if (length(centers) == 1) {
    k <- centers
    if (nstart == 1) 
      centers <- x[sample.int(m, k), , drop = FALSE]
    if (nstart >= 2 || any(duplicated(centers))) {
      cn <- unique(x)
      mm <- nrow(cn)
      if (mm < k) 
        stop("more cluster centers than distinct data points.")
      centers <- cn[sample.int(mm, k), , drop = FALSE]
    }
  }
  else {
    centers <- as.matrix(centers)
    if (any(duplicated(centers))) 
      stop("initial centers are not distinct")
    cn <- NULL
    k <- nrow(centers)
    if (m < k) 
      stop("more cluster centers than data points")
  }
  k <- as.integer(k)
  if (is.na(k)) 
    stop(gettextf("invalid value of %s", "'k'"), domain = NA)
  if (k == 1) 
    nmeth <- 3
  iter.max <- as.integer(iter.max)
  if (is.na(iter.max) || iter.max < 1) 
    stop("'iter.max' must be positive")
  if (ncol(x) != ncol(centers)) 
    stop("must have same number of columns in 'x' and 'centers'")
  storage.mode(centers) <- "double"
  Z <- do_one(nmeth)
  best <- sum(Z$wss)
  if (nstart >= 2 && !is.null(cn)) 
    for (i in 2:nstart) {
      centers <- cn[sample.int(mm, k), , drop = FALSE]
      ZZ <- do_one(nmeth)
      if ((z <- sum(ZZ$wss)) < best) {
        Z <- ZZ
        best <- z
      }
    }
  centers <- matrix(Z$centers, k)
  dimnames(centers) <- list(1:k, dimnames(x)[[2]])
  cluster <- Z$c1
  if (!is.null(rn <- rownames(x))) 
    names(cluster) <- rn
  totss <- sum(scale(x, scale = FALSE)^2)
  structure(list(cluster = cluster, centers = centers, totss = totss, withinss = Z$wss, tot.withinss = best, betweenss = totss - best, size = Z$nc, iter = Z$iter, ifault = Z$ifault), class = "kmeans")
}, function (x, centers, iter.max = 10, nstart = 1, algorithm = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"), trace = FALSE) 
{
  .Mimax <- .Machine$integer.max
  do_one <- function(nmeth) {
    switch(nmeth, {
      isteps.Qtran <- as.integer(min(.Mimax, 50 * m))
      iTran <- c(isteps.Qtran, integer(k))
      Z <- .Fortran(C_kmns, x, m, p, centers = centers, as.integer(k), c1 = integer(m), c2 = integer(m), nc = integer(k), double(k), double(k), ncp = integer(k), D = double(m), iTran = iTran, live = integer(k), iter = iter.max, wss = double(k), ifault = as.integer(trace))
      switch(Z$ifault, stop("empty cluster: try a better set of initial centers", call. = FALSE), Z$iter <- max(Z$iter, iter.max + 1), stop("number of cluster centres must lie between 1 and nrow(x)", call. = FALSE), warning(gettextf("Quick-TRANSfer stage steps exceeded maximum (= %d)", isteps.Qtran), call. = FALSE))
    }, {
      Z <- .C(C_kmeans_Lloyd, x, m, p, centers = centers, k, c1 = integer(m), iter = iter.max, nc = integer(k), wss = double(k))
    }, {
      Z <- .C(C_kmeans_MacQueen, x, m, p, centers = as.double(centers), k, c1 = integer(m), iter = iter.max, nc = integer(k), wss = double(k))
    })
    if (m23 <- any(nmeth == c(2, 3))) {
      if (any(Z$nc == 0)) 
        warning("empty cluster: try a better set of initial centers", call. = FALSE)
    }
    if (Z$iter > iter.max) {
      warning(sprintf(ngettext(iter.max, "did not converge in %d iteration", "did not converge in %d iterations"), iter.max), call. = FALSE, domain = NA)
      if (m23) 
        Z$ifault <- 2
    }
    if (nmeth %in% c(2, 3)) {
      if (any(Z$nc == 0)) 
        warning("empty cluster: try a better set of initial centers", call. = FALSE)
    }
    Z
  }
  x <- as.matrix(x)
  m <- as.integer(nrow(x))
  if (is.na(m)) 
    stop("invalid nrow(x)")
  p <- as.integer(ncol(x))
  if (is.na(p)) 
    stop("invalid ncol(x)")
  if (missing(centers)) 
    stop("'centers' must be a number or a matrix")
  nmeth <- switch(match.arg(algorithm), `Hartigan-Wong` = 1, Lloyd = 2, Forgy = 2, MacQueen = 3)
  storage.mode(x) <- "double"
  if (length(centers) == 1) {
    k <- centers
    if (nstart == 1) 
      centers <- x[sample.int(m, k), , drop = FALSE]
    if (nstart >= 2 || any(duplicated(centers))) {
      cn <- unique(x)
      mm <- nrow(cn)
      if (mm < k) 
        stop("more cluster centers than distinct data points.")
      centers <- cn[sample.int(mm, k), , drop = FALSE]
    }
  }
  else {
    centers <- as.matrix(centers)
    if (any(duplicated(centers))) 
      stop("initial centers are not distinct")
    cn <- NULL
    k <- nrow(centers)
    if (m < k) 
      stop("more cluster centers than data points")
  }
  k <- as.integer(k)
  if (is.na(k)) 
    stop(gettextf("invalid value of %s", "'k'"), domain = NA)
  if (k == 1) 
    nmeth <- 3
  iter.max <- as.integer(iter.max)
  if (is.na(iter.max) || iter.max < 1) 
    stop("'iter.max' must be positive")
  if (ncol(x) != ncol(centers)) 
    stop("must have same number of columns in 'x' and 'centers'")
  storage.mode(centers) <- "double"
  Z <- do_one(nmeth)
  best <- sum(Z$wss)
  if (nstart >= 2 && !is.null(cn)) 
    for (i in 2:nstart) {
      centers <- cn[sample.int(mm, k), , drop = FALSE]
      ZZ <- do_one(nmeth)
      if ((z <- sum(ZZ$wss)) < best) {
        Z <- ZZ
        best <- z
      }
    }
  centers <- matrix(Z$centers, k)
  dimnames(centers) <- list(1:k, dimnames(x)[[2]])
  cluster <- Z$c1
  if (!is.null(rn <- rownames(x))) 
    names(cluster) <- rn
  totss <- sum(scale(x, scale = FALSE)^2)
  structure(list(cluster = cluster, centers = centers, totss = totss, withinss = Z$wss, tot.withinss = best, betweenss = totss - best, size = Z$nc, iter = Z$iter, ifault = Z$ifault), class = "kmeans")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
knots
list(`package:stats` = function (Fn, ...) 
  UseMethod("knots"), function (Fn, ...) 
    UseMethod("knots"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
kruskal.test
list(`package:stats` = function (x, ...) 
  UseMethod("kruskal.test"), function (x, ...) 
    UseMethod("kruskal.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ks.test
list(`package:stats` = function (x, ...) 
  UseMethod("ks.test"), function (x, ...) 
    UseMethod("ks.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ksmooth
list(`package:stats` = function (x, y, kernel = c("box", "normal"), bandwidth = 0.5, range.x = range(x), n.points = max(100, length(x)), x.points) 
{
  if (missing(y) || is.null(y)) 
    stop("numeric y must be supplied.\nFor density estimation use density()")
  kernel <- match.arg(kernel)
  krn <- switch(kernel, box = 1, normal = 2)
  x.points <- if (missing(x.points)) 
    seq.int(range.x[1], range.x[2], length.out = n.points)
  else {
    n.points <- length(x.points)
    sort(x.points)
  }
  ord <- order(x)
  .Call(C_ksmooth, x[ord], y[ord], x.points, krn, bandwidth)
}, function (x, y, kernel = c("box", "normal"), bandwidth = 0.5, range.x = range(x), n.points = max(100, length(x)), x.points) 
{
  if (missing(y) || is.null(y)) 
    stop("numeric y must be supplied.\nFor density estimation use density()")
  kernel <- match.arg(kernel)
  krn <- switch(kernel, box = 1, normal = 2)
  x.points <- if (missing(x.points)) 
    seq.int(range.x[1], range.x[2], length.out = n.points)
  else {
    n.points <- length(x.points)
    sort(x.points)
  }
  ord <- order(x)
  .Call(C_ksmooth, x[ord], y[ord], x.points, krn, bandwidth)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
lag
list(`package:stats` = function (x, ...) 
  UseMethod("lag"), function (x, n = 1, default = NA, order_by = NULL, ...) 
  {
    if (!is.null(order_by)) {
      return(with_order(order_by, lag, x, n = n, default = default))
    }
    if (inherits(x, "ts")) {
      msg <- "`x` must be a vector, not a ts object, do you want `stats::lag()`?"
      abort(msg)
    }
    if (length(n) != 1 || !is.numeric(n) || n < 0) {
      msg <- glue("`n` must be a positive integer, not {friendly_type_of(n)} of length {length(n)}.")
      abort(msg)
    }
    if (n == 0) 
      return(x)
    if (vec_size(default) != 1) {
      msg <- glue("`default` must be size 1, not size {vec_size(default)}")
      abort(msg)
    }
    xlen <- vec_size(x)
    n <- pmin(n, xlen)
    inputs <- fix_call(vec_cast_common(default = default, x = x))
    vec_c(vec_rep(inputs$default, n), vec_slice(inputs$x, seq_len(xlen - n)))
  }, function (x, ...) 
    UseMethod("lag"))
c("package:stats", "namespace:dplyr", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
lag.plot
list(`package:stats` = function (x, lags = 1, layout = NULL, set.lags = 1:lags, main = NULL, asp = 1, diag = TRUE, diag.col = "gray", type = "p", oma = NULL, ask = NULL, do.lines = (n <= 150), labels = do.lines, ...) 
{
  lAxis <- function(side, ..., mgp, xpd, panel, Mgp) if (missing(Mgp)) 
    axis(side, ..., xpd = NA)
  else axis(side, ..., xpd = NA, mgp = Mgp)
  xnam <- deparse1(substitute(x))
  is.mat <- !is.null(ncol(x))
  nser <- ncol(x <- as.ts(as.matrix(x)))
  n <- nrow(x)
  if (missing(lags) && !missing(set.lags)) 
    lags <- length(set.lags <- as.integer(set.lags))
  tot.lags <- nser * lags
  if (is.null(ask)) {
    if (.Device == "null device") 
      dev.new()
    ask <- if (is.null(layout)) 
      par("ask")
    else (dev.interactive() && prod(layout) < tot.lags)
  }
  if (is.null(layout)) 
    layout <- if (prod(pmf <- par("mfrow")) >= tot.lags) 
      pmf
  else n2mfrow(tot.lags)
  mlayout <- any(layout > 1)
  if (mlayout) {
    dots <- list(...)
    cex.main <- dots$cex.main %||% par("cex.main")
    if (is.null(oma)) {
      oma <- rep(2, 4)
      if (!is.null(main)) 
        oma[3] <- oma[3] + 3 * cex.main
    }
    opar <- par(mfrow = layout, mar = c(1.1, 1.1, 0.5, 0.5) + is.mat * c(0, 0.5, 0, 0.5), oma = oma, ask = ask)
    on.exit(par(opar))
  }
  nR <- layout[1]
  nC <- layout[2]
  ii <- jj <- 0
  for (i in 1:nser) {
    X <- x[, i]
    xl <- range(X)
    nam <- if (is.mat) 
      dimnames(x)[[2]][i]
    else xnam
    newX <- is.mat
    for (ll in set.lags) {
      jj <- 1 + jj%%nC
      if (jj == 1) 
        ii <- 1 + ii%%nR
      if (mlayout) {
        plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, xlab = paste("lag", ll), ylab = nam, mgp = if (mlayout) 
          c(0, 0, 0), axes = FALSE, type = type, xy.lines = do.lines, xy.labels = labels, col.lab = if (newX) 
            "red", font.lab = if (newX) 
              2, ...)
        box(...)
        if (jj == 1 && ii%%2 == 1 && !newX) 
          lAxis(2, ...)
        if (ii == 1 && jj%%2 == 1) 
          lAxis(3, ...)
        do.4 <- (ii%%2 == 0 && (jj == nC || (i == nser && ll == set.lags[lags])))
        if (do.4) 
          lAxis(4, ...)
        if (jj%%2 == 0 && ii == nR) 
          lAxis(1, ...)
        if (newX) {
          newX <- FALSE
          if (!do.4) 
            lAxis(4, Mgp = c(0, 0.6, 0), ...)
        }
      }
      else {
        plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, xlab = paste("lag", ll), ylab = nam, type = type, xy.lines = do.lines, xy.labels = labels, main = main, ...)
      }
      if (diag) 
        abline(c(0, 1), lty = 2, col = diag.col)
      if (mlayout && !is.null(main)) {
        font.main <- dots$font.main %||% par("font.main")
        if ((jj == nC && ii == nR) || ll == set.lags[lags]) 
          mtext(main, 3, 3, outer = TRUE, at = 0.5, cex = cex.main, font = font.main)
      }
    }
  }
  invisible(NULL)
}, function (x, lags = 1, layout = NULL, set.lags = 1:lags, main = NULL, asp = 1, diag = TRUE, diag.col = "gray", type = "p", oma = NULL, ask = NULL, do.lines = (n <= 150), labels = do.lines, ...) 
{
  lAxis <- function(side, ..., mgp, xpd, panel, Mgp) if (missing(Mgp)) 
    axis(side, ..., xpd = NA)
  else axis(side, ..., xpd = NA, mgp = Mgp)
  xnam <- deparse1(substitute(x))
  is.mat <- !is.null(ncol(x))
  nser <- ncol(x <- as.ts(as.matrix(x)))
  n <- nrow(x)
  if (missing(lags) && !missing(set.lags)) 
    lags <- length(set.lags <- as.integer(set.lags))
  tot.lags <- nser * lags
  if (is.null(ask)) {
    if (.Device == "null device") 
      dev.new()
    ask <- if (is.null(layout)) 
      par("ask")
    else (dev.interactive() && prod(layout) < tot.lags)
  }
  if (is.null(layout)) 
    layout <- if (prod(pmf <- par("mfrow")) >= tot.lags) 
      pmf
  else n2mfrow(tot.lags)
  mlayout <- any(layout > 1)
  if (mlayout) {
    dots <- list(...)
    cex.main <- dots$cex.main %||% par("cex.main")
    if (is.null(oma)) {
      oma <- rep(2, 4)
      if (!is.null(main)) 
        oma[3] <- oma[3] + 3 * cex.main
    }
    opar <- par(mfrow = layout, mar = c(1.1, 1.1, 0.5, 0.5) + is.mat * c(0, 0.5, 0, 0.5), oma = oma, ask = ask)
    on.exit(par(opar))
  }
  nR <- layout[1]
  nC <- layout[2]
  ii <- jj <- 0
  for (i in 1:nser) {
    X <- x[, i]
    xl <- range(X)
    nam <- if (is.mat) 
      dimnames(x)[[2]][i]
    else xnam
    newX <- is.mat
    for (ll in set.lags) {
      jj <- 1 + jj%%nC
      if (jj == 1) 
        ii <- 1 + ii%%nR
      if (mlayout) {
        plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, xlab = paste("lag", ll), ylab = nam, mgp = if (mlayout) 
          c(0, 0, 0), axes = FALSE, type = type, xy.lines = do.lines, xy.labels = labels, col.lab = if (newX) 
            "red", font.lab = if (newX) 
              2, ...)
        box(...)
        if (jj == 1 && ii%%2 == 1 && !newX) 
          lAxis(2, ...)
        if (ii == 1 && jj%%2 == 1) 
          lAxis(3, ...)
        do.4 <- (ii%%2 == 0 && (jj == nC || (i == nser && ll == set.lags[lags])))
        if (do.4) 
          lAxis(4, ...)
        if (jj%%2 == 0 && ii == nR) 
          lAxis(1, ...)
        if (newX) {
          newX <- FALSE
          if (!do.4) 
            lAxis(4, Mgp = c(0, 0.6, 0), ...)
        }
      }
      else {
        plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, xlab = paste("lag", ll), ylab = nam, type = type, xy.lines = do.lines, xy.labels = labels, main = main, ...)
      }
      if (diag) 
        abline(c(0, 1), lty = 2, col = diag.col)
      if (mlayout && !is.null(main)) {
        font.main <- dots$font.main %||% par("font.main")
        if ((jj == nC && ii == nR) || ll == set.lags[lags]) 
          mtext(main, 3, 3, outer = TRUE, at = 0.5, cex = cex.main, font = font.main)
      }
    }
  }
  invisible(NULL)
}, function (x, lags = 1, layout = NULL, set.lags = 1:lags, main = NULL, asp = 1, diag = TRUE, diag.col = "gray", type = "p", oma = NULL, ask = NULL, do.lines = (n <= 150), labels = do.lines, ...) 
{
  lAxis <- function(side, ..., mgp, xpd, panel, Mgp) if (missing(Mgp)) 
    axis(side, ..., xpd = NA)
  else axis(side, ..., xpd = NA, mgp = Mgp)
  xnam <- deparse1(substitute(x))
  is.mat <- !is.null(ncol(x))
  nser <- ncol(x <- as.ts(as.matrix(x)))
  n <- nrow(x)
  if (missing(lags) && !missing(set.lags)) 
    lags <- length(set.lags <- as.integer(set.lags))
  tot.lags <- nser * lags
  if (is.null(ask)) {
    if (.Device == "null device") 
      dev.new()
    ask <- if (is.null(layout)) 
      par("ask")
    else (dev.interactive() && prod(layout) < tot.lags)
  }
  if (is.null(layout)) 
    layout <- if (prod(pmf <- par("mfrow")) >= tot.lags) 
      pmf
  else n2mfrow(tot.lags)
  mlayout <- any(layout > 1)
  if (mlayout) {
    dots <- list(...)
    cex.main <- dots$cex.main %||% par("cex.main")
    if (is.null(oma)) {
      oma <- rep(2, 4)
      if (!is.null(main)) 
        oma[3] <- oma[3] + 3 * cex.main
    }
    opar <- par(mfrow = layout, mar = c(1.1, 1.1, 0.5, 0.5) + is.mat * c(0, 0.5, 0, 0.5), oma = oma, ask = ask)
    on.exit(par(opar))
  }
  nR <- layout[1]
  nC <- layout[2]
  ii <- jj <- 0
  for (i in 1:nser) {
    X <- x[, i]
    xl <- range(X)
    nam <- if (is.mat) 
      dimnames(x)[[2]][i]
    else xnam
    newX <- is.mat
    for (ll in set.lags) {
      jj <- 1 + jj%%nC
      if (jj == 1) 
        ii <- 1 + ii%%nR
      if (mlayout) {
        plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, xlab = paste("lag", ll), ylab = nam, mgp = if (mlayout) 
          c(0, 0, 0), axes = FALSE, type = type, xy.lines = do.lines, xy.labels = labels, col.lab = if (newX) 
            "red", font.lab = if (newX) 
              2, ...)
        box(...)
        if (jj == 1 && ii%%2 == 1 && !newX) 
          lAxis(2, ...)
        if (ii == 1 && jj%%2 == 1) 
          lAxis(3, ...)
        do.4 <- (ii%%2 == 0 && (jj == nC || (i == nser && ll == set.lags[lags])))
        if (do.4) 
          lAxis(4, ...)
        if (jj%%2 == 0 && ii == nR) 
          lAxis(1, ...)
        if (newX) {
          newX <- FALSE
          if (!do.4) 
            lAxis(4, Mgp = c(0, 0.6, 0), ...)
        }
      }
      else {
        plot(lag(X, ll), X, xlim = xl, ylim = xl, asp = asp, xlab = paste("lag", ll), ylab = nam, type = type, xy.lines = do.lines, xy.labels = labels, main = main, ...)
      }
      if (diag) 
        abline(c(0, 1), lty = 2, col = diag.col)
      if (mlayout && !is.null(main)) {
        font.main <- dots$font.main %||% par("font.main")
        if ((jj == nC && ii == nR) || ll == set.lags[lags]) 
          mtext(main, 3, 3, outer = TRUE, at = 0.5, cex = cex.main, font = font.main)
      }
    }
  }
  invisible(NULL)
})
c("package:stats", "registered S3 method for lag from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
line
list(`package:stats` = function (x, y = NULL, iter = 1) 
{
  xy <- xy.coords(x, y, setLab = FALSE)
  ok <- complete.cases(xy$x, xy$y)
  Call <- sys.call()
  structure(.Call(C_tukeyline, as.double(xy$x[ok]), as.double(xy$y[ok]), as.integer(iter), Call), class = "tukeyline")
}, function (x, y = NULL, iter = 1) 
{
  xy <- xy.coords(x, y, setLab = FALSE)
  ok <- complete.cases(xy$x, xy$y)
  Call <- sys.call()
  structure(.Call(C_tukeyline, as.double(xy$x[ok]), as.double(xy$y[ok]), as.integer(iter), Call), class = "tukeyline")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
lm
list(`package:stats` = function (formula, data, subset, weights, na.action, method = "qr", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) 
{
  ret.x <- x
  ret.y <- y
  cl <- match.call()
  mf <- match.call(expand.dots = FALSE)
  m <- match(c("formula", "data", "subset", "weights", "na.action", "offset"), names(mf), 0)
  mf <- mf[c(1, m)]
  mf$drop.unused.levels <- TRUE
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval(mf, parent.frame())
  if (method == "model.frame") 
    return(mf)
  else if (method != "qr") 
    warning(gettextf("method = '%s' is not supported. Using 'qr'", method), domain = NA)
  mt <- attr(mf, "terms")
  y <- model.response(mf, "numeric")
  w <- as.vector(model.weights(mf))
  if (!is.null(w) && !is.numeric(w)) 
    stop("'weights' must be a numeric vector")
  offset <- model.offset(mf)
  mlm <- is.matrix(y)
  ny <- if (mlm) 
    nrow(y)
  else length(y)
  if (!is.null(offset)) {
    if (!mlm) 
      offset <- as.vector(offset)
    if (NROW(offset) != ny) 
      stop(gettextf("number of offsets is %d, should equal %d (number of observations)", NROW(offset), ny), domain = NA)
  }
  if (is.empty.model(mt)) {
    x <- NULL
    z <- list(coefficients = if (mlm) matrix(NA, 0, ncol(y)) else numeric(), residuals = y, fitted.values = 0 * y, weights = w, rank = 0, df.residual = if (!is.null(w)) sum(w != 0) else ny)
    if (!is.null(offset)) {
      z$fitted.values <- offset
      z$residuals <- y - offset
    }
  }
  else {
    x <- model.matrix(mt, mf, contrasts)
    z <- if (is.null(w)) 
      lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...)
    else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, ...)
  }
  class(z) <- c(if (mlm) "mlm", "lm")
  z$na.action <- attr(mf, "na.action")
  z$offset <- offset
  z$contrasts <- attr(x, "contrasts")
  z$xlevels <- .getXlevels(mt, mf)
  z$call <- cl
  z$terms <- mt
  if (model) 
    z$model <- mf
  if (ret.x) 
    z$x <- x
  if (ret.y) 
    z$y <- y
  if (!qr) 
    z$qr <- NULL
  z
}, function (formula, data, subset, weights, na.action, method = "qr", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) 
{
  ret.x <- x
  ret.y <- y
  cl <- match.call()
  mf <- match.call(expand.dots = FALSE)
  m <- match(c("formula", "data", "subset", "weights", "na.action", "offset"), names(mf), 0)
  mf <- mf[c(1, m)]
  mf$drop.unused.levels <- TRUE
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval(mf, parent.frame())
  if (method == "model.frame") 
    return(mf)
  else if (method != "qr") 
    warning(gettextf("method = '%s' is not supported. Using 'qr'", method), domain = NA)
  mt <- attr(mf, "terms")
  y <- model.response(mf, "numeric")
  w <- as.vector(model.weights(mf))
  if (!is.null(w) && !is.numeric(w)) 
    stop("'weights' must be a numeric vector")
  offset <- model.offset(mf)
  mlm <- is.matrix(y)
  ny <- if (mlm) 
    nrow(y)
  else length(y)
  if (!is.null(offset)) {
    if (!mlm) 
      offset <- as.vector(offset)
    if (NROW(offset) != ny) 
      stop(gettextf("number of offsets is %d, should equal %d (number of observations)", NROW(offset), ny), domain = NA)
  }
  if (is.empty.model(mt)) {
    x <- NULL
    z <- list(coefficients = if (mlm) matrix(NA, 0, ncol(y)) else numeric(), residuals = y, fitted.values = 0 * y, weights = w, rank = 0, df.residual = if (!is.null(w)) sum(w != 0) else ny)
    if (!is.null(offset)) {
      z$fitted.values <- offset
      z$residuals <- y - offset
    }
  }
  else {
    x <- model.matrix(mt, mf, contrasts)
    z <- if (is.null(w)) 
      lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...)
    else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, ...)
  }
  class(z) <- c(if (mlm) "mlm", "lm")
  z$na.action <- attr(mf, "na.action")
  z$offset <- offset
  z$contrasts <- attr(x, "contrasts")
  z$xlevels <- .getXlevels(mt, mf)
  z$call <- cl
  z$terms <- mt
  if (model) 
    z$model <- mf
  if (ret.x) 
    z$x <- x
  if (ret.y) 
    z$y <- y
  if (!qr) 
    z$qr <- NULL
  z
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
lm.fit
list(`package:stats` = function (x, y, offset = NULL, method = "qr", tol = 1e-07, singular.ok = TRUE, ...) 
{
  if (is.null(n <- nrow(x))) 
    stop("'x' must be a matrix")
  if (n == 0) 
    stop("0 (non-NA) cases")
  p <- ncol(x)
  if (p == 0) {
    return(list(coefficients = numeric(), residuals = y, fitted.values = 0 * y, rank = 0, df.residual = length(y)))
  }
  ny <- NCOL(y)
  if (is.matrix(y) && ny == 1) 
    y <- drop(y)
  if (!is.null(offset)) 
    y <- y - offset
  if (NROW(y) != n) 
    stop("incompatible dimensions")
  if (method != "qr") 
    warning(gettextf("method = '%s' is not supported. Using 'qr'", method), domain = NA)
  chkDots(...)
  z <- .Call(C_Cdqrls, x, y, tol, FALSE)
  if (!singular.ok && z$rank < p) 
    stop("singular fit encountered")
  coef <- z$coefficients
  pivot <- z$pivot
  r1 <- seq_len(z$rank)
  dn <- colnames(x) %||% paste0("x", 1:p)
  nmeffects <- c(dn[pivot[r1]], rep.int("", n - z$rank))
  r2 <- if (z$rank < p) 
    (z$rank + 1):p
  else integer()
  if (is.matrix(y)) {
    coef[r2, ] <- NA
    if (z$pivoted) 
      coef[pivot, ] <- coef
    dimnames(coef) <- list(dn, colnames(y))
    dimnames(z$effects) <- list(nmeffects, colnames(y))
  }
  else {
    coef[r2] <- NA
    if (z$pivoted) 
      coef[pivot] <- coef
    names(coef) <- dn
    names(z$effects) <- nmeffects
  }
  z$coefficients <- coef
  r1 <- y - z$residuals
  if (!is.null(offset)) 
    r1 <- r1 + offset
  if (z$pivoted) 
    colnames(z$qr) <- colnames(x)[z$pivot]
  qr <- z[c("qr", "qraux", "pivot", "tol", "rank")]
  c(z[c("coefficients", "residuals", "effects", "rank")], list(fitted.values = r1, assign = attr(x, "assign"), qr = structure(qr, class = "qr"), df.residual = n - z$rank))
}, function (x, y, offset = NULL, method = "qr", tol = 1e-07, singular.ok = TRUE, ...) 
{
  if (is.null(n <- nrow(x))) 
    stop("'x' must be a matrix")
  if (n == 0) 
    stop("0 (non-NA) cases")
  p <- ncol(x)
  if (p == 0) {
    return(list(coefficients = numeric(), residuals = y, fitted.values = 0 * y, rank = 0, df.residual = length(y)))
  }
  ny <- NCOL(y)
  if (is.matrix(y) && ny == 1) 
    y <- drop(y)
  if (!is.null(offset)) 
    y <- y - offset
  if (NROW(y) != n) 
    stop("incompatible dimensions")
  if (method != "qr") 
    warning(gettextf("method = '%s' is not supported. Using 'qr'", method), domain = NA)
  chkDots(...)
  z <- .Call(C_Cdqrls, x, y, tol, FALSE)
  if (!singular.ok && z$rank < p) 
    stop("singular fit encountered")
  coef <- z$coefficients
  pivot <- z$pivot
  r1 <- seq_len(z$rank)
  dn <- colnames(x) %||% paste0("x", 1:p)
  nmeffects <- c(dn[pivot[r1]], rep.int("", n - z$rank))
  r2 <- if (z$rank < p) 
    (z$rank + 1):p
  else integer()
  if (is.matrix(y)) {
    coef[r2, ] <- NA
    if (z$pivoted) 
      coef[pivot, ] <- coef
    dimnames(coef) <- list(dn, colnames(y))
    dimnames(z$effects) <- list(nmeffects, colnames(y))
  }
  else {
    coef[r2] <- NA
    if (z$pivoted) 
      coef[pivot] <- coef
    names(coef) <- dn
    names(z$effects) <- nmeffects
  }
  z$coefficients <- coef
  r1 <- y - z$residuals
  if (!is.null(offset)) 
    r1 <- r1 + offset
  if (z$pivoted) 
    colnames(z$qr) <- colnames(x)[z$pivot]
  qr <- z[c("qr", "qraux", "pivot", "tol", "rank")]
  c(z[c("coefficients", "residuals", "effects", "rank")], list(fitted.values = r1, assign = attr(x, "assign"), qr = structure(qr, class = "qr"), df.residual = n - z$rank))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
lm.influence
list(`package:stats` = function (model, do.coef = TRUE) 
{
  wt.res <- weighted.residuals(model)
  e <- na.omit(wt.res)
  is.mlm <- is.matrix(e)
  if (model$rank == 0) {
    n <- length(wt.res)
    sigma <- sqrt(deviance(model)/df.residual(model))
    res <- list(hat = rep(0, n), coefficients = matrix(0, n, 0), sigma = rep(sigma, n))
  }
  else {
    e[abs(e) < 100 * .Machine$double.eps * median(abs(e))] <- 0
    mqr <- qr.lm(model)
    n <- as.integer(nrow(mqr$qr))
    if (is.na(n)) 
      stop("invalid model QR matrix")
    if (NROW(e) != n) 
      stop("non-NA residual length does not match cases used in fitting")
    do.coef <- as.logical(do.coef)
    tol <- 10 * .Machine$double.eps
    res <- .Call(C_influence, mqr, e, tol)
    if (do.coef) {
      ok <- seq_len(mqr$rank)
      Q <- qr.Q(mqr)[, ok, drop = FALSE]
      R <- qr.R(mqr)[ok, ok, drop = FALSE]
      hat <- res$hat
      invRQtt <- t(backsolve(R, t(Q)))
      k <- NCOL(Q)
      q <- NCOL(e)
      if (is.mlm) {
        cf <- array(0, c(n, k, q))
        for (j in seq_len(q)) cf[, , j] <- invRQtt * ifelse(hat == 1, 0, e[, j]/(1 - hat))
      }
      else cf <- invRQtt * ifelse(hat == 1, 0, e/(1 - hat))
      res$coefficients <- cf
    }
    drop1d <- function(a) {
      d <- dim(a)
      if (length(d) == 3 && d[[3]] == 1) 
        dim(a) <- d[-3]
      a
    }
    if (is.null(model$na.action)) {
      if (!is.mlm) {
        res$sigma <- drop(res$sigma)
        if (do.coef) 
          res$coefficients <- drop1d(res$coefficients)
      }
    }
    else {
      hat <- naresid(model$na.action, res$hat)
      hat[is.na(hat)] <- 0
      res$hat <- hat
      if (do.coef) {
        coefficients <- naresid(model$na.action, res$coefficients)
        coefficients[is.na(coefficients)] <- 0
        res$coefficients <- if (is.mlm) 
          coefficients
        else drop1d(coefficients)
      }
      sigma <- naresid(model$na.action, res$sigma)
      sigma[is.na(sigma)] <- sqrt(deviance(model)/df.residual(model))
      res$sigma <- if (is.mlm) 
        sigma
      else drop(sigma)
    }
  }
  res$wt.res <- naresid(model$na.action, e)
  res$hat[res$hat > 1 - 10 * .Machine$double.eps] <- 1
  names(res$hat) <- names(res$sigma) <- names(res$wt.res)
  if (do.coef) {
    cf <- coef(model)
    if (is.mlm) {
      dnr <- dimnames(res$wt.res)
      dimnames(res$coefficients) <- list(dnr[[1]], rownames(cf)[!apply(cf, 1, anyNA)], dnr[[2]])
    }
    else {
      dimnames(res$coefficients) <- list(names(res$wt.res), names(cf)[!is.na(cf)])
    }
  }
  res[c("hat", "coefficients", "sigma", "wt.res")]
}, function (model, do.coef = TRUE) 
{
  wt.res <- weighted.residuals(model)
  e <- na.omit(wt.res)
  is.mlm <- is.matrix(e)
  if (model$rank == 0) {
    n <- length(wt.res)
    sigma <- sqrt(deviance(model)/df.residual(model))
    res <- list(hat = rep(0, n), coefficients = matrix(0, n, 0), sigma = rep(sigma, n))
  }
  else {
    e[abs(e) < 100 * .Machine$double.eps * median(abs(e))] <- 0
    mqr <- qr.lm(model)
    n <- as.integer(nrow(mqr$qr))
    if (is.na(n)) 
      stop("invalid model QR matrix")
    if (NROW(e) != n) 
      stop("non-NA residual length does not match cases used in fitting")
    do.coef <- as.logical(do.coef)
    tol <- 10 * .Machine$double.eps
    res <- .Call(C_influence, mqr, e, tol)
    if (do.coef) {
      ok <- seq_len(mqr$rank)
      Q <- qr.Q(mqr)[, ok, drop = FALSE]
      R <- qr.R(mqr)[ok, ok, drop = FALSE]
      hat <- res$hat
      invRQtt <- t(backsolve(R, t(Q)))
      k <- NCOL(Q)
      q <- NCOL(e)
      if (is.mlm) {
        cf <- array(0, c(n, k, q))
        for (j in seq_len(q)) cf[, , j] <- invRQtt * ifelse(hat == 1, 0, e[, j]/(1 - hat))
      }
      else cf <- invRQtt * ifelse(hat == 1, 0, e/(1 - hat))
      res$coefficients <- cf
    }
    drop1d <- function(a) {
      d <- dim(a)
      if (length(d) == 3 && d[[3]] == 1) 
        dim(a) <- d[-3]
      a
    }
    if (is.null(model$na.action)) {
      if (!is.mlm) {
        res$sigma <- drop(res$sigma)
        if (do.coef) 
          res$coefficients <- drop1d(res$coefficients)
      }
    }
    else {
      hat <- naresid(model$na.action, res$hat)
      hat[is.na(hat)] <- 0
      res$hat <- hat
      if (do.coef) {
        coefficients <- naresid(model$na.action, res$coefficients)
        coefficients[is.na(coefficients)] <- 0
        res$coefficients <- if (is.mlm) 
          coefficients
        else drop1d(coefficients)
      }
      sigma <- naresid(model$na.action, res$sigma)
      sigma[is.na(sigma)] <- sqrt(deviance(model)/df.residual(model))
      res$sigma <- if (is.mlm) 
        sigma
      else drop(sigma)
    }
  }
  res$wt.res <- naresid(model$na.action, e)
  res$hat[res$hat > 1 - 10 * .Machine$double.eps] <- 1
  names(res$hat) <- names(res$sigma) <- names(res$wt.res)
  if (do.coef) {
    cf <- coef(model)
    if (is.mlm) {
      dnr <- dimnames(res$wt.res)
      dimnames(res$coefficients) <- list(dnr[[1]], rownames(cf)[!apply(cf, 1, anyNA)], dnr[[2]])
    }
    else {
      dimnames(res$coefficients) <- list(names(res$wt.res), names(cf)[!is.na(cf)])
    }
  }
  res[c("hat", "coefficients", "sigma", "wt.res")]
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
lm.wfit
list(`package:stats` = function (x, y, w, offset = NULL, method = "qr", tol = 1e-07, singular.ok = TRUE, ...) 
{
  if (is.null(n <- nrow(x))) 
    stop("'x' must be a matrix")
  if (n == 0) 
    stop("0 (non-NA) cases")
  ny <- NCOL(y)
  if (is.matrix(y) && ny == 1) 
    y <- drop(y)
  if (!is.null(offset)) 
    y <- y - offset
  if (NROW(y) != n || length(w) != n) 
    stop("incompatible dimensions")
  if (any(w < 0 | is.na(w))) 
    stop("missing or negative weights not allowed")
  if (method != "qr") 
    warning(gettextf("method = '%s' is not supported. Using 'qr'", method), domain = NA)
  chkDots(...)
  x.asgn <- attr(x, "assign")
  zero.weights <- any(w == 0)
  if (zero.weights) {
    save.r <- y
    save.f <- y
    save.w <- w
    ok <- w != 0
    nok <- !ok
    w <- w[ok]
    x0 <- x[!ok, , drop = FALSE]
    x <- x[ok, , drop = FALSE]
    n <- nrow(x)
    y0 <- if (ny > 1) 
      y[!ok, , drop = FALSE]
    else y[!ok]
    y <- if (ny > 1) 
      y[ok, , drop = FALSE]
    else y[ok]
  }
  p <- ncol(x)
  if (p == 0) {
    return(list(coefficients = numeric(), residuals = y, fitted.values = 0 * y, weights = w, rank = 0, df.residual = length(y)))
  }
  if (n == 0) {
    return(list(coefficients = rep(NA, p), residuals = y, fitted.values = 0 * y, weights = w, rank = 0, df.residual = 0))
  }
  wts <- sqrt(w)
  z <- .Call(C_Cdqrls, x * wts, y * wts, tol, FALSE)
  if (!singular.ok && z$rank < p) 
    stop("singular fit encountered")
  coef <- z$coefficients
  pivot <- z$pivot
  r1 <- seq_len(z$rank)
  dn <- colnames(x) %||% paste0("x", 1:p)
  nmeffects <- c(dn[pivot[r1]], rep.int("", n - z$rank))
  r2 <- if (z$rank < p) 
    (z$rank + 1):p
  else integer()
  if (is.matrix(y)) {
    coef[r2, ] <- NA
    if (z$pivoted) 
      coef[pivot, ] <- coef
    dimnames(coef) <- list(dn, colnames(y))
    dimnames(z$effects) <- list(nmeffects, colnames(y))
  }
  else {
    coef[r2] <- NA
    if (z$pivoted) 
      coef[pivot] <- coef
    names(coef) <- dn
    names(z$effects) <- nmeffects
  }
  z$coefficients <- coef
  z$residuals <- z$residuals/wts
  z$fitted.values <- y - z$residuals
  z$weights <- w
  if (zero.weights) {
    coef[is.na(coef)] <- 0
    f0 <- x0 %*% coef
    if (ny > 1) {
      save.r[ok, ] <- z$residuals
      save.r[nok, ] <- y0 - f0
      save.f[ok, ] <- z$fitted.values
      save.f[nok, ] <- f0
    }
    else {
      save.r[ok] <- z$residuals
      save.r[nok] <- y0 - f0
      save.f[ok] <- z$fitted.values
      save.f[nok] <- f0
    }
    z$residuals <- save.r
    z$fitted.values <- save.f
    z$weights <- save.w
  }
  if (!is.null(offset)) 
    z$fitted.values <- z$fitted.values + offset
  if (z$pivoted) 
    colnames(z$qr) <- colnames(x)[z$pivot]
  qr <- z[c("qr", "qraux", "pivot", "tol", "rank")]
  c(z[c("coefficients", "residuals", "fitted.values", "effects", "weights", "rank")], list(assign = x.asgn, qr = structure(qr, class = "qr"), df.residual = n - z$rank))
}, function (x, y, w, offset = NULL, method = "qr", tol = 1e-07, singular.ok = TRUE, ...) 
{
  if (is.null(n <- nrow(x))) 
    stop("'x' must be a matrix")
  if (n == 0) 
    stop("0 (non-NA) cases")
  ny <- NCOL(y)
  if (is.matrix(y) && ny == 1) 
    y <- drop(y)
  if (!is.null(offset)) 
    y <- y - offset
  if (NROW(y) != n || length(w) != n) 
    stop("incompatible dimensions")
  if (any(w < 0 | is.na(w))) 
    stop("missing or negative weights not allowed")
  if (method != "qr") 
    warning(gettextf("method = '%s' is not supported. Using 'qr'", method), domain = NA)
  chkDots(...)
  x.asgn <- attr(x, "assign")
  zero.weights <- any(w == 0)
  if (zero.weights) {
    save.r <- y
    save.f <- y
    save.w <- w
    ok <- w != 0
    nok <- !ok
    w <- w[ok]
    x0 <- x[!ok, , drop = FALSE]
    x <- x[ok, , drop = FALSE]
    n <- nrow(x)
    y0 <- if (ny > 1) 
      y[!ok, , drop = FALSE]
    else y[!ok]
    y <- if (ny > 1) 
      y[ok, , drop = FALSE]
    else y[ok]
  }
  p <- ncol(x)
  if (p == 0) {
    return(list(coefficients = numeric(), residuals = y, fitted.values = 0 * y, weights = w, rank = 0, df.residual = length(y)))
  }
  if (n == 0) {
    return(list(coefficients = rep(NA, p), residuals = y, fitted.values = 0 * y, weights = w, rank = 0, df.residual = 0))
  }
  wts <- sqrt(w)
  z <- .Call(C_Cdqrls, x * wts, y * wts, tol, FALSE)
  if (!singular.ok && z$rank < p) 
    stop("singular fit encountered")
  coef <- z$coefficients
  pivot <- z$pivot
  r1 <- seq_len(z$rank)
  dn <- colnames(x) %||% paste0("x", 1:p)
  nmeffects <- c(dn[pivot[r1]], rep.int("", n - z$rank))
  r2 <- if (z$rank < p) 
    (z$rank + 1):p
  else integer()
  if (is.matrix(y)) {
    coef[r2, ] <- NA
    if (z$pivoted) 
      coef[pivot, ] <- coef
    dimnames(coef) <- list(dn, colnames(y))
    dimnames(z$effects) <- list(nmeffects, colnames(y))
  }
  else {
    coef[r2] <- NA
    if (z$pivoted) 
      coef[pivot] <- coef
    names(coef) <- dn
    names(z$effects) <- nmeffects
  }
  z$coefficients <- coef
  z$residuals <- z$residuals/wts
  z$fitted.values <- y - z$residuals
  z$weights <- w
  if (zero.weights) {
    coef[is.na(coef)] <- 0
    f0 <- x0 %*% coef
    if (ny > 1) {
      save.r[ok, ] <- z$residuals
      save.r[nok, ] <- y0 - f0
      save.f[ok, ] <- z$fitted.values
      save.f[nok, ] <- f0
    }
    else {
      save.r[ok] <- z$residuals
      save.r[nok] <- y0 - f0
      save.f[ok] <- z$fitted.values
      save.f[nok] <- f0
    }
    z$residuals <- save.r
    z$fitted.values <- save.f
    z$weights <- save.w
  }
  if (!is.null(offset)) 
    z$fitted.values <- z$fitted.values + offset
  if (z$pivoted) 
    colnames(z$qr) <- colnames(x)[z$pivot]
  qr <- z[c("qr", "qraux", "pivot", "tol", "rank")]
  c(z[c("coefficients", "residuals", "fitted.values", "effects", "weights", "rank")], list(assign = x.asgn, qr = structure(qr, class = "qr"), df.residual = n - z$rank))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
loadings
list(`package:stats` = function (x, ...) 
  x$loadings, function (x, ...) 
    x$loadings)
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
loess
list(`package:stats` = function (formula, data, weights, subset, na.action, model = FALSE, span = 0.75, enp.target, degree = 2, parametric = FALSE, drop.square = FALSE, normalize = TRUE, family = c("gaussian", "symmetric"), method = c("loess", "model.frame"), control = loess.control(...), ...) 
{
  family <- match.arg(family)
  method <- match.arg(method)
  mf <- match.call(expand.dots = FALSE)
  mf$model <- mf$span <- mf$enp.target <- mf$degree <- mf$parametric <- mf$drop.square <- mf$normalize <- mf$family <- mf$method <- mf$control <- mf$... <- NULL
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval(mf, parent.frame())
  if (match.arg(method) == "model.frame") 
    return(mf)
  mt <- attr(mf, "terms")
  y <- model.response(mf, "numeric")
  w <- model.weights(mf) %||% rep_len(1, length(y))
  nmx <- as.character(attr(mt, "variables"))[-(1:2)]
  x <- mf[, nmx, drop = FALSE]
  if (any(sapply(x, is.factor))) 
    stop("predictors must all be numeric")
  x <- as.matrix(x)
  D <- ncol(x)
  nmx <- setNames(nm = colnames(x))
  drop.square <- match(nmx, nmx[drop.square], 0) > 0
  parametric <- match(nmx, nmx[parametric], 0) > 0
  if (!match(degree, 0:2, 0)) 
    stop("'degree' must be 0, 1 or 2")
  iterations <- if (family == "gaussian") 
    1
  else control$iterations
  if (!missing(enp.target)) 
    if (!missing(span)) 
      warning("both 'span' and 'enp.target' specified: 'span' will be used")
  else {
    tau <- switch(degree + 1, 1, D + 1, (D + 1) * (D + 2)/2) - sum(drop.square)
    span <- 1.2 * tau/enp.target
  }
  if (!is.list(control) || !is.character(control$surface) || !is.character(control$statistics) || !is.character(control$trace.hat) || !is.numeric(control$cell) || !is.numeric(iterations)) 
    stop("invalid 'control' argument")
  fit <- simpleLoess(y, x, w, span, degree = degree, parametric = parametric, drop.square = drop.square, normalize = normalize, statistics = control$statistics, surface = control$surface, cell = control$cell, iterations = iterations, iterTrace = control$iterTrace, trace.hat = control$trace.hat)
  fit$call <- match.call()
  fit$terms <- mt
  fit$xnames <- nmx
  fit$x <- x
  fit$y <- y
  fit$weights <- w
  if (model) 
    fit$model <- mf
  fit$na.action <- attr(mf, "na.action")
  fit
}, function (formula, data, weights, subset, na.action, model = FALSE, span = 0.75, enp.target, degree = 2, parametric = FALSE, drop.square = FALSE, normalize = TRUE, family = c("gaussian", "symmetric"), method = c("loess", "model.frame"), control = loess.control(...), ...) 
{
  family <- match.arg(family)
  method <- match.arg(method)
  mf <- match.call(expand.dots = FALSE)
  mf$model <- mf$span <- mf$enp.target <- mf$degree <- mf$parametric <- mf$drop.square <- mf$normalize <- mf$family <- mf$method <- mf$control <- mf$... <- NULL
  mf[[1]] <- quote(stats::model.frame)
  mf <- eval(mf, parent.frame())
  if (match.arg(method) == "model.frame") 
    return(mf)
  mt <- attr(mf, "terms")
  y <- model.response(mf, "numeric")
  w <- model.weights(mf) %||% rep_len(1, length(y))
  nmx <- as.character(attr(mt, "variables"))[-(1:2)]
  x <- mf[, nmx, drop = FALSE]
  if (any(sapply(x, is.factor))) 
    stop("predictors must all be numeric")
  x <- as.matrix(x)
  D <- ncol(x)
  nmx <- setNames(nm = colnames(x))
  drop.square <- match(nmx, nmx[drop.square], 0) > 0
  parametric <- match(nmx, nmx[parametric], 0) > 0
  if (!match(degree, 0:2, 0)) 
    stop("'degree' must be 0, 1 or 2")
  iterations <- if (family == "gaussian") 
    1
  else control$iterations
  if (!missing(enp.target)) 
    if (!missing(span)) 
      warning("both 'span' and 'enp.target' specified: 'span' will be used")
  else {
    tau <- switch(degree + 1, 1, D + 1, (D + 1) * (D + 2)/2) - sum(drop.square)
    span <- 1.2 * tau/enp.target
  }
  if (!is.list(control) || !is.character(control$surface) || !is.character(control$statistics) || !is.character(control$trace.hat) || !is.numeric(control$cell) || !is.numeric(iterations)) 
    stop("invalid 'control' argument")
  fit <- simpleLoess(y, x, w, span, degree = degree, parametric = parametric, drop.square = drop.square, normalize = normalize, statistics = control$statistics, surface = control$surface, cell = control$cell, iterations = iterations, iterTrace = control$iterTrace, trace.hat = control$trace.hat)
  fit$call <- match.call()
  fit$terms <- mt
  fit$xnames <- nmx
  fit$x <- x
  fit$y <- y
  fit$weights <- w
  if (model) 
    fit$model <- mf
  fit$na.action <- attr(mf, "na.action")
  fit
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
loess.control
list(`package:stats` = function (surface = c("interpolate", "direct"), statistics = c("approximate", "exact", "none"), trace.hat = c("exact", "approximate"), cell = 0.2, iterations = 4, iterTrace = FALSE, ...) 
{
  stopifnot(length(iterations) == 1, !is.na(iterations), as.integer(iterations) > 0, length(iterTrace) == 1, !is.na(iterTrace), as.integer(iterTrace) >= 0)
  list(surface = match.arg(surface), statistics = match.arg(statistics), trace.hat = match.arg(trace.hat), cell = cell, iterations = iterations, iterTrace = iterTrace)
}, function (surface = c("interpolate", "direct"), statistics = c("approximate", "exact", "none"), trace.hat = c("exact", "approximate"), cell = 0.2, iterations = 4, iterTrace = FALSE, ...) 
{
  stopifnot(length(iterations) == 1, !is.na(iterations), as.integer(iterations) > 0, length(iterTrace) == 1, !is.na(iterTrace), as.integer(iterTrace) >= 0)
  list(surface = match.arg(surface), statistics = match.arg(statistics), trace.hat = match.arg(trace.hat), cell = cell, iterations = iterations, iterTrace = iterTrace)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
loess.smooth
list(`package:stats` = function (x, y, span = 2/3, degree = 1, family = c("symmetric", "gaussian"), evaluation = 50, ...) 
{
  notna <- !(is.na(x) | is.na(y))
  x <- x[notna]
  y <- y[notna]
  new.x <- seq.int(min(x), max(x), length.out = evaluation)
  control <- loess.control(...)
  w <- rep_len(1, length(y))
  family <- match.arg(family)
  iterations <- if (family == "gaussian") 
    1
  else control$iterations
  kd <- simpleLoess(y, x, w, span, degree = degree, parametric = FALSE, drop.square = FALSE, normalize = FALSE, statistics = "none", surface = "interpolate", cell = control$cell, iterations = iterations, iterTrace = control$iterTrace, trace.hat = control$trace.hat)$kd
  z <- .C(C_loess_ifit, as.integer(kd$parameter), as.integer(kd$a), as.double(kd$xi), as.double(kd$vert), as.double(kd$vval), as.integer(evaluation), as.double(new.x), fit = double(evaluation))$fit
  list(x = new.x, y = z)
}, function (x, y, span = 2/3, degree = 1, family = c("symmetric", "gaussian"), evaluation = 50, ...) 
{
  notna <- !(is.na(x) | is.na(y))
  x <- x[notna]
  y <- y[notna]
  new.x <- seq.int(min(x), max(x), length.out = evaluation)
  control <- loess.control(...)
  w <- rep_len(1, length(y))
  family <- match.arg(family)
  iterations <- if (family == "gaussian") 
    1
  else control$iterations
  kd <- simpleLoess(y, x, w, span, degree = degree, parametric = FALSE, drop.square = FALSE, normalize = FALSE, statistics = "none", surface = "interpolate", cell = control$cell, iterations = iterations, iterTrace = control$iterTrace, trace.hat = control$trace.hat)$kd
  z <- .C(C_loess_ifit, as.integer(kd$parameter), as.integer(kd$a), as.double(kd$xi), as.double(kd$vert), as.double(kd$vval), as.integer(evaluation), as.double(new.x), fit = double(evaluation))$fit
  list(x = new.x, y = z)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
logLik
list(`package:stats` = function (object, ...) 
  UseMethod("logLik"), function (object, ...) 
    UseMethod("logLik"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
loglin
list(`package:stats` = function (table, margin, start = rep(1, length(table)), fit = FALSE, eps = 0.1, iter = 20, param = FALSE, print = TRUE) 
{
  rfit <- fit
  dtab <- dim(table)
  nvar <- length(dtab)
  ncon <- length(margin)
  conf <- matrix(0, nrow = nvar, ncol = ncon)
  nmar <- 0
  varnames <- names(dimnames(table))
  for (k in seq_along(margin)) {
    tmp <- margin[[k]]
    if (is.character(tmp)) {
      tmp <- match(tmp, varnames)
      margin[[k]] <- tmp
    }
    if (!is.numeric(tmp) || any(is.na(tmp) | tmp <= 0)) 
      stop("'margin' must contain names or numbers corresponding to 'table'")
    conf[seq_along(tmp), k] <- tmp
    nmar <- nmar + prod(dtab[tmp])
  }
  ntab <- length(table)
  if (length(start) != ntab) 
    stop("'start' and 'table' must be same length")
  z <- .Call(C_LogLin, dtab, conf, table, start, nmar, eps, iter)
  if (print) 
    cat(z$nlast, "iterations: deviation", z$dev[z$nlast], "\n")
  fit <- z$fit
  attributes(fit) <- attributes(table)
  observed <- as.vector(table[start > 0])
  expected <- as.vector(fit[start > 0])
  pearson <- sum((observed - expected)^2/expected)
  observed <- as.vector(table[table * fit > 0])
  expected <- as.vector(fit[table * fit > 0])
  lrt <- 2 * sum(observed * log(observed/expected))
  subsets <- function(x) {
    y <- list(vector(mode(x), length = 0))
    for (i in seq_along(x)) {
      y <- c(y, lapply(y, c, x[i]))
    }
    y[-1]
  }
  df <- rep.int(0, 2^nvar)
  for (k in seq_along(margin)) {
    terms <- subsets(margin[[k]])
    for (j in seq_along(terms)) df[sum(2^(terms[[j]] - 1))] <- prod(dtab[terms[[j]]] - 1)
  }
  if (!is.null(varnames) && all(nzchar(varnames))) {
    for (k in seq_along(margin)) margin[[k]] <- varnames[margin[[k]]]
  }
  else {
    varnames <- as.character(1:ntab)
  }
  y <- list(lrt = lrt, pearson = pearson, df = ntab - sum(df) - 1, margin = margin)
  if (rfit) 
    y$fit <- fit
  if (param) {
    fit <- log(fit)
    terms <- seq_along(df)[df > 0]
    parlen <- length(terms) + 1
    parval <- list(parlen)
    parnam <- character(parlen)
    parval[[1]] <- mean(fit)
    parnam[1] <- "(Intercept)"
    fit <- fit - parval[[1]]
    dyadic <- NULL
    while (any(terms > 0)) {
      dyadic <- cbind(dyadic, terms%%2)
      terms <- terms%/%2
    }
    dyadic <- dyadic[order(rowSums(dyadic)), , drop = FALSE]
    for (i in 2:parlen) {
      vars <- which(dyadic[i - 1, ] > 0)
      parval[[i]] <- apply(fit, vars, mean)
      parnam[i] <- paste(varnames[vars], collapse = ".")
      fit <- sweep(fit, vars, parval[[i]], check.margin = FALSE)
    }
    names(parval) <- parnam
    y$param <- parval
  }
  return(y)
}, function (table, margin, start = rep(1, length(table)), fit = FALSE, eps = 0.1, iter = 20, param = FALSE, print = TRUE) 
{
  rfit <- fit
  dtab <- dim(table)
  nvar <- length(dtab)
  ncon <- length(margin)
  conf <- matrix(0, nrow = nvar, ncol = ncon)
  nmar <- 0
  varnames <- names(dimnames(table))
  for (k in seq_along(margin)) {
    tmp <- margin[[k]]
    if (is.character(tmp)) {
      tmp <- match(tmp, varnames)
      margin[[k]] <- tmp
    }
    if (!is.numeric(tmp) || any(is.na(tmp) | tmp <= 0)) 
      stop("'margin' must contain names or numbers corresponding to 'table'")
    conf[seq_along(tmp), k] <- tmp
    nmar <- nmar + prod(dtab[tmp])
  }
  ntab <- length(table)
  if (length(start) != ntab) 
    stop("'start' and 'table' must be same length")
  z <- .Call(C_LogLin, dtab, conf, table, start, nmar, eps, iter)
  if (print) 
    cat(z$nlast, "iterations: deviation", z$dev[z$nlast], "\n")
  fit <- z$fit
  attributes(fit) <- attributes(table)
  observed <- as.vector(table[start > 0])
  expected <- as.vector(fit[start > 0])
  pearson <- sum((observed - expected)^2/expected)
  observed <- as.vector(table[table * fit > 0])
  expected <- as.vector(fit[table * fit > 0])
  lrt <- 2 * sum(observed * log(observed/expected))
  subsets <- function(x) {
    y <- list(vector(mode(x), length = 0))
    for (i in seq_along(x)) {
      y <- c(y, lapply(y, c, x[i]))
    }
    y[-1]
  }
  df <- rep.int(0, 2^nvar)
  for (k in seq_along(margin)) {
    terms <- subsets(margin[[k]])
    for (j in seq_along(terms)) df[sum(2^(terms[[j]] - 1))] <- prod(dtab[terms[[j]]] - 1)
  }
  if (!is.null(varnames) && all(nzchar(varnames))) {
    for (k in seq_along(margin)) margin[[k]] <- varnames[margin[[k]]]
  }
  else {
    varnames <- as.character(1:ntab)
  }
  y <- list(lrt = lrt, pearson = pearson, df = ntab - sum(df) - 1, margin = margin)
  if (rfit) 
    y$fit <- fit
  if (param) {
    fit <- log(fit)
    terms <- seq_along(df)[df > 0]
    parlen <- length(terms) + 1
    parval <- list(parlen)
    parnam <- character(parlen)
    parval[[1]] <- mean(fit)
    parnam[1] <- "(Intercept)"
    fit <- fit - parval[[1]]
    dyadic <- NULL
    while (any(terms > 0)) {
      dyadic <- cbind(dyadic, terms%%2)
      terms <- terms%/%2
    }
    dyadic <- dyadic[order(rowSums(dyadic)), , drop = FALSE]
    for (i in 2:parlen) {
      vars <- which(dyadic[i - 1, ] > 0)
      parval[[i]] <- apply(fit, vars, mean)
      parnam[i] <- paste(varnames[vars], collapse = ".")
      fit <- sweep(fit, vars, parval[[i]], check.margin = FALSE)
    }
    names(parval) <- parnam
    y$param <- parval
  }
  return(y)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
lowess
list(`package:stats` = function (x, y = NULL, f = 2/3, iter = 3, delta = 0.01 * diff(range(x))) 
{
  xy <- xy.coords(x, y, setLab = FALSE)
  o <- order(xy$x)
  x <- as.double(xy$x[o])
  list(x = x, y = .Call(C_lowess, x, as.double(xy$y[o]), f, iter, delta))
}, function (x, y = NULL, f = 2/3, iter = 3, delta = 0.01 * diff(range(x))) 
{
  xy <- xy.coords(x, y, setLab = FALSE)
  o <- order(xy$x)
  x <- as.double(xy$x[o])
  list(x = x, y = .Call(C_lowess, x, as.double(xy$y[o]), f, iter, delta))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ls.diag
list(`package:stats` = function (ls.out) 
{
  resids <- as.matrix(ls.out$residuals)
  d0 <- dim(resids)
  xnames <- colnames(ls.out$qr$qr)
  yname <- colnames(resids)
  good <- complete.cases(resids, ls.out$wt)
  if (any(!good)) {
    warning("missing observations deleted")
    resids <- resids[good, , drop = FALSE]
  }
  if (!is.null(ls.out$wt)) {
    if (any(ls.out$wt[good] == 0)) 
      warning("observations with 0 weight not used in calculating standard deviation")
    resids <- resids * sqrt(ls.out$wt[good])
  }
  p <- ls.out$qr$rank
  n <- nrow(resids)
  hatdiag <- rep.int(NA, d0[1])
  stats <- array(NA, dim = d0)
  colnames(stats) <- yname
  stdres <- studres <- dfits <- Cooks <- stats
  q <- qr.qy(ls.out$qr, rbind(diag(p), matrix(0, nrow = n - p, ncol = p)))
  hatdiag[good] <- rowSums(as.matrix(q^2))
  stddev <- sqrt(colSums(as.matrix(resids^2))/(n - p))
  stddevmat <- matrix(stddev, nrow = sum(good), ncol = ncol(resids), byrow = TRUE)
  stdres[good, ] <- resids/(sqrt(1 - hatdiag[good]) * stddevmat)
  studres[good, ] <- (stdres[good, ] * stddevmat)/sqrt(((n - p) * stddevmat^2 - resids^2/(1 - hatdiag[good]))/(n - p - 1))
  dfits[good, ] <- sqrt(hatdiag[good]/(1 - hatdiag[good])) * studres[good, ]
  Cooks[good, ] <- ((stdres[good, ]^2 * hatdiag[good])/p)/(1 - hatdiag[good])
  if (ncol(resids) == 1 && is.null(yname)) {
    stdres <- as.vector(stdres)
    Cooks <- as.vector(Cooks)
    studres <- as.vector(studres)
    dfits <- as.vector(dfits)
  }
  qr <- as.matrix(ls.out$qr$qr[1:p, 1:p])
  qr[row(qr) > col(qr)] <- 0
  covmat.unscaled <- tcrossprod(solve(qr))
  dimnames(covmat.unscaled) <- list(xnames, xnames)
  covmat.scaled <- sum(stddev^2) * covmat.unscaled
  cormat <- covmat.scaled/sqrt(outer(diag(covmat.scaled), diag(covmat.scaled)))
  stderr <- outer(sqrt(diag(covmat.unscaled)), stddev)
  dimnames(stderr) <- list(xnames, yname)
  return(list(std.dev = stddev, hat = hatdiag, std.res = stdres, stud.res = studres, cooks = Cooks, dfits = dfits, correlation = cormat, std.err = stderr, cov.scaled = covmat.scaled, cov.unscaled = covmat.unscaled))
}, function (ls.out) 
{
  resids <- as.matrix(ls.out$residuals)
  d0 <- dim(resids)
  xnames <- colnames(ls.out$qr$qr)
  yname <- colnames(resids)
  good <- complete.cases(resids, ls.out$wt)
  if (any(!good)) {
    warning("missing observations deleted")
    resids <- resids[good, , drop = FALSE]
  }
  if (!is.null(ls.out$wt)) {
    if (any(ls.out$wt[good] == 0)) 
      warning("observations with 0 weight not used in calculating standard deviation")
    resids <- resids * sqrt(ls.out$wt[good])
  }
  p <- ls.out$qr$rank
  n <- nrow(resids)
  hatdiag <- rep.int(NA, d0[1])
  stats <- array(NA, dim = d0)
  colnames(stats) <- yname
  stdres <- studres <- dfits <- Cooks <- stats
  q <- qr.qy(ls.out$qr, rbind(diag(p), matrix(0, nrow = n - p, ncol = p)))
  hatdiag[good] <- rowSums(as.matrix(q^2))
  stddev <- sqrt(colSums(as.matrix(resids^2))/(n - p))
  stddevmat <- matrix(stddev, nrow = sum(good), ncol = ncol(resids), byrow = TRUE)
  stdres[good, ] <- resids/(sqrt(1 - hatdiag[good]) * stddevmat)
  studres[good, ] <- (stdres[good, ] * stddevmat)/sqrt(((n - p) * stddevmat^2 - resids^2/(1 - hatdiag[good]))/(n - p - 1))
  dfits[good, ] <- sqrt(hatdiag[good]/(1 - hatdiag[good])) * studres[good, ]
  Cooks[good, ] <- ((stdres[good, ]^2 * hatdiag[good])/p)/(1 - hatdiag[good])
  if (ncol(resids) == 1 && is.null(yname)) {
    stdres <- as.vector(stdres)
    Cooks <- as.vector(Cooks)
    studres <- as.vector(studres)
    dfits <- as.vector(dfits)
  }
  qr <- as.matrix(ls.out$qr$qr[1:p, 1:p])
  qr[row(qr) > col(qr)] <- 0
  covmat.unscaled <- tcrossprod(solve(qr))
  dimnames(covmat.unscaled) <- list(xnames, xnames)
  covmat.scaled <- sum(stddev^2) * covmat.unscaled
  cormat <- covmat.scaled/sqrt(outer(diag(covmat.scaled), diag(covmat.scaled)))
  stderr <- outer(sqrt(diag(covmat.unscaled)), stddev)
  dimnames(stderr) <- list(xnames, yname)
  return(list(std.dev = stddev, hat = hatdiag, std.res = stdres, stud.res = studres, cooks = Cooks, dfits = dfits, correlation = cormat, std.err = stderr, cov.scaled = covmat.scaled, cov.unscaled = covmat.unscaled))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ls.print
list(`package:stats` = function (ls.out, digits = 4, print.it = TRUE) 
{
  resids <- as.matrix(ls.out$residuals)
  if (!is.null(ls.out$wt)) {
    if (any(ls.out$wt == 0)) 
      warning("observations with 0 weights not used")
    resids <- resids * sqrt(ls.out$wt)
  }
  n <- apply(resids, 2, length) - colSums(is.na(resids))
  lsqr <- ls.out$qr
  p <- lsqr$rank
  if (ls.out$intercept) {
    if (is.matrix(lsqr$qt)) 
      totss <- colSums(lsqr$qt[-1, ]^2)
    else totss <- sum(lsqr$qt[-1]^2)
    degfree <- p - 1
  }
  else {
    totss <- colSums(as.matrix(lsqr$qt^2))
    degfree <- p
  }
  resss <- colSums(resids^2, na.rm = TRUE)
  resse <- sqrt(resss/(n - p))
  regss <- totss - resss
  rsquared <- regss/totss
  fstat <- (regss/degfree)/(resss/(n - p))
  pvalue <- pf(fstat, degfree, (n - p), lower.tail = FALSE)
  Ynames <- colnames(resids)
  summary <- cbind(format(round(resse, digits)), format(round(rsquared, digits)), format(round(fstat, digits)), format(degfree), format(n - p), format(round(pvalue, digits)))
  dimnames(summary) <- list(Ynames, c("Mean Sum Sq", "R Squared", "F-value", "Df 1", "Df 2", "Pr(>F)"))
  mat <- as.matrix(lsqr$qr[1:p, 1:p])
  mat[row(mat) > col(mat)] <- 0
  uVar <- diag(tcrossprod(solve(mat)))
  m.y <- ncol(resids)
  coef.table <- as.list(1:m.y)
  coef <- if (m.y == 1) 
    matrix(ls.out$coefficients, ncol = 1)
  else ls.out$coefficients
  for (i in 1:m.y) {
    se <- sqrt((resss[i]/(n[i] - p)) * uVar)
    coef.table[[i]] <- cbind(coef[, i], se, coef[, i]/se, 2 * pt(abs(coef[, i]/se), n[i] - p, lower.tail = FALSE), deparse.level = 0)
    dimnames(coef.table[[i]]) <- list(colnames(lsqr$qr), c("Estimate", "Std.Err", "t-value", "Pr(>|t|)"))
    if (print.it) {
      if (m.y > 1) 
        cat("Response:", Ynames[i], "\n\n")
      cat(paste0("Residual Standard Error=", format(round(resse[i], digits)), "\nR-Square=", format(round(rsquared[i], digits)), "\nF-statistic (df=", format(degfree), ", ", format(n[i] - p), ")=", format(round(fstat[i], digits)), "\np-value=", format(round(pvalue[i], digits)), "\n\n"))
      print(round(coef.table[[i]], digits))
      cat("\n\n")
    }
  }
  names(coef.table) <- Ynames
  invisible(list(summary = summary, coef.table = coef.table))
}, function (ls.out, digits = 4, print.it = TRUE) 
{
  resids <- as.matrix(ls.out$residuals)
  if (!is.null(ls.out$wt)) {
    if (any(ls.out$wt == 0)) 
      warning("observations with 0 weights not used")
    resids <- resids * sqrt(ls.out$wt)
  }
  n <- apply(resids, 2, length) - colSums(is.na(resids))
  lsqr <- ls.out$qr
  p <- lsqr$rank
  if (ls.out$intercept) {
    if (is.matrix(lsqr$qt)) 
      totss <- colSums(lsqr$qt[-1, ]^2)
    else totss <- sum(lsqr$qt[-1]^2)
    degfree <- p - 1
  }
  else {
    totss <- colSums(as.matrix(lsqr$qt^2))
    degfree <- p
  }
  resss <- colSums(resids^2, na.rm = TRUE)
  resse <- sqrt(resss/(n - p))
  regss <- totss - resss
  rsquared <- regss/totss
  fstat <- (regss/degfree)/(resss/(n - p))
  pvalue <- pf(fstat, degfree, (n - p), lower.tail = FALSE)
  Ynames <- colnames(resids)
  summary <- cbind(format(round(resse, digits)), format(round(rsquared, digits)), format(round(fstat, digits)), format(degfree), format(n - p), format(round(pvalue, digits)))
  dimnames(summary) <- list(Ynames, c("Mean Sum Sq", "R Squared", "F-value", "Df 1", "Df 2", "Pr(>F)"))
  mat <- as.matrix(lsqr$qr[1:p, 1:p])
  mat[row(mat) > col(mat)] <- 0
  uVar <- diag(tcrossprod(solve(mat)))
  m.y <- ncol(resids)
  coef.table <- as.list(1:m.y)
  coef <- if (m.y == 1) 
    matrix(ls.out$coefficients, ncol = 1)
  else ls.out$coefficients
  for (i in 1:m.y) {
    se <- sqrt((resss[i]/(n[i] - p)) * uVar)
    coef.table[[i]] <- cbind(coef[, i], se, coef[, i]/se, 2 * pt(abs(coef[, i]/se), n[i] - p, lower.tail = FALSE), deparse.level = 0)
    dimnames(coef.table[[i]]) <- list(colnames(lsqr$qr), c("Estimate", "Std.Err", "t-value", "Pr(>|t|)"))
    if (print.it) {
      if (m.y > 1) 
        cat("Response:", Ynames[i], "\n\n")
      cat(paste0("Residual Standard Error=", format(round(resse[i], digits)), "\nR-Square=", format(round(rsquared[i], digits)), "\nF-statistic (df=", format(degfree), ", ", format(n[i] - p), ")=", format(round(fstat[i], digits)), "\np-value=", format(round(pvalue[i], digits)), "\n\n"))
      print(round(coef.table[[i]], digits))
      cat("\n\n")
    }
  }
  names(coef.table) <- Ynames
  invisible(list(summary = summary, coef.table = coef.table))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
lsfit
list(`package:stats` = function (x, y, wt = NULL, intercept = TRUE, tolerance = 1e-07, yname = NULL) 
{
  x <- as.matrix(x)
  y <- as.matrix(y)
  xnames <- colnames(x)
  if (is.null(xnames)) {
    if (ncol(x) == 1) 
      xnames <- "X"
    else xnames <- paste0("X", 1:ncol(x))
  }
  if (intercept) {
    x <- cbind(1, x)
    xnames <- c("Intercept", xnames)
  }
  if (is.null(yname) && ncol(y) > 1) 
    yname <- paste0("Y", 1:ncol(y))
  good <- complete.cases(x, y, wt)
  dimy <- dim(as.matrix(y))
  if (any(!good)) {
    warning(sprintf(ngettext(sum(!good), "%d missing value deleted", "%d missing values deleted"), sum(!good)), domain = NA)
    x <- as.matrix(x)[good, , drop = FALSE]
    y <- as.matrix(y)[good, , drop = FALSE]
    wt <- wt[good]
  }
  nrx <- NROW(x)
  ncx <- NCOL(x)
  nry <- NROW(y)
  ncy <- NCOL(y)
  nwts <- length(wt)
  if (nry != nrx) 
    stop(sprintf(paste0(ngettext(nrx, "'X' matrix has %d case (row)", "'X' matrix has %d cases (rows)"), ", ", ngettext(nry, "'Y' has %d case (row)", "'Y' has %d cases (rows)")), nrx, nry), domain = NA)
  if (nry < ncx) 
    stop(sprintf(paste0(ngettext(nry, "only %d case", "only %d cases"), ", ", ngettext(ncx, "but %d variable", "but %d variables")), nry, ncx), domain = NA)
  if (!is.null(wt)) {
    if (any(wt < 0)) 
      stop("negative weights not allowed")
    if (nwts != nry) 
      stop(gettextf("number of weights = %d should equal %d (number of responses)", nwts, nry), domain = NA)
    wtmult <- sqrt(wt)
    if (any(wt == 0)) {
      xzero <- as.matrix(x)[wt == 0, ]
      yzero <- as.matrix(y)[wt == 0, ]
    }
    x <- x * wtmult
    y <- y * wtmult
    invmult <- 1/ifelse(wt == 0, 1, wtmult)
  }
  z <- .Call(C_Cdqrls, x, y, tolerance, FALSE)
  resids <- array(NA, dim = dimy)
  dim(z$residuals) <- c(nry, ncy)
  if (!is.null(wt)) {
    if (any(wt == 0)) {
      if (ncx == 1) 
        fitted.zeros <- xzero * z$coefficients
      else fitted.zeros <- xzero %*% z$coefficients
      z$residuals[wt == 0, ] <- yzero - fitted.zeros
    }
    z$residuals <- z$residuals * invmult
  }
  resids[good, ] <- z$residuals
  if (dimy[2] == 1 && is.null(yname)) {
    resids <- drop(resids)
    names(z$coefficients) <- xnames
  }
  else {
    colnames(resids) <- yname
    colnames(z$effects) <- yname
    dim(z$coefficients) <- c(ncx, ncy)
    dimnames(z$coefficients) <- list(xnames, yname)
  }
  z$qr <- as.matrix(z$qr)
  colnames(z$qr) <- xnames
  output <- list(coefficients = z$coefficients, residuals = resids)
  if (z$rank != ncx) {
    xnames <- xnames[z$pivot]
    dimnames(z$qr) <- list(NULL, xnames)
    warning("'X' matrix was collinear")
  }
  if (!is.null(wt)) {
    weights <- rep.int(NA, dimy[1])
    weights[good] <- wt
    output <- c(output, list(wt = weights))
  }
  rqr <- list(qt = drop(z$effects), qr = z$qr, qraux = z$qraux, rank = z$rank, pivot = z$pivot, tol = z$tol)
  oldClass(rqr) <- "qr"
  output <- c(output, list(intercept = intercept, qr = rqr))
  return(output)
}, function (x, y, wt = NULL, intercept = TRUE, tolerance = 1e-07, yname = NULL) 
{
  x <- as.matrix(x)
  y <- as.matrix(y)
  xnames <- colnames(x)
  if (is.null(xnames)) {
    if (ncol(x) == 1) 
      xnames <- "X"
    else xnames <- paste0("X", 1:ncol(x))
  }
  if (intercept) {
    x <- cbind(1, x)
    xnames <- c("Intercept", xnames)
  }
  if (is.null(yname) && ncol(y) > 1) 
    yname <- paste0("Y", 1:ncol(y))
  good <- complete.cases(x, y, wt)
  dimy <- dim(as.matrix(y))
  if (any(!good)) {
    warning(sprintf(ngettext(sum(!good), "%d missing value deleted", "%d missing values deleted"), sum(!good)), domain = NA)
    x <- as.matrix(x)[good, , drop = FALSE]
    y <- as.matrix(y)[good, , drop = FALSE]
    wt <- wt[good]
  }
  nrx <- NROW(x)
  ncx <- NCOL(x)
  nry <- NROW(y)
  ncy <- NCOL(y)
  nwts <- length(wt)
  if (nry != nrx) 
    stop(sprintf(paste0(ngettext(nrx, "'X' matrix has %d case (row)", "'X' matrix has %d cases (rows)"), ", ", ngettext(nry, "'Y' has %d case (row)", "'Y' has %d cases (rows)")), nrx, nry), domain = NA)
  if (nry < ncx) 
    stop(sprintf(paste0(ngettext(nry, "only %d case", "only %d cases"), ", ", ngettext(ncx, "but %d variable", "but %d variables")), nry, ncx), domain = NA)
  if (!is.null(wt)) {
    if (any(wt < 0)) 
      stop("negative weights not allowed")
    if (nwts != nry) 
      stop(gettextf("number of weights = %d should equal %d (number of responses)", nwts, nry), domain = NA)
    wtmult <- sqrt(wt)
    if (any(wt == 0)) {
      xzero <- as.matrix(x)[wt == 0, ]
      yzero <- as.matrix(y)[wt == 0, ]
    }
    x <- x * wtmult
    y <- y * wtmult
    invmult <- 1/ifelse(wt == 0, 1, wtmult)
  }
  z <- .Call(C_Cdqrls, x, y, tolerance, FALSE)
  resids <- array(NA, dim = dimy)
  dim(z$residuals) <- c(nry, ncy)
  if (!is.null(wt)) {
    if (any(wt == 0)) {
      if (ncx == 1) 
        fitted.zeros <- xzero * z$coefficients
      else fitted.zeros <- xzero %*% z$coefficients
      z$residuals[wt == 0, ] <- yzero - fitted.zeros
    }
    z$residuals <- z$residuals * invmult
  }
  resids[good, ] <- z$residuals
  if (dimy[2] == 1 && is.null(yname)) {
    resids <- drop(resids)
    names(z$coefficients) <- xnames
  }
  else {
    colnames(resids) <- yname
    colnames(z$effects) <- yname
    dim(z$coefficients) <- c(ncx, ncy)
    dimnames(z$coefficients) <- list(xnames, yname)
  }
  z$qr <- as.matrix(z$qr)
  colnames(z$qr) <- xnames
  output <- list(coefficients = z$coefficients, residuals = resids)
  if (z$rank != ncx) {
    xnames <- xnames[z$pivot]
    dimnames(z$qr) <- list(NULL, xnames)
    warning("'X' matrix was collinear")
  }
  if (!is.null(wt)) {
    weights <- rep.int(NA, dimy[1])
    weights[good] <- wt
    output <- c(output, list(wt = weights))
  }
  rqr <- list(qt = drop(z$effects), qr = z$qr, qraux = z$qraux, rank = z$rank, pivot = z$pivot, tol = z$tol)
  oldClass(rqr) <- "qr"
  output <- c(output, list(intercept = intercept, qr = rqr))
  return(output)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
mad
list(`package:stats` = function (x, center = median(x), constant = 1.4826, na.rm = FALSE, low = FALSE, high = FALSE) 
{
  if (na.rm) 
    x <- x[!is.na(x)]
  n <- length(x)
  constant * if ((low || high) && n%%2 == 0) {
    if (low && high) 
      stop("'low' and 'high' cannot be both TRUE")
    n2 <- n%/%2 + as.integer(high)
    sort(abs(x - center), partial = n2)[n2]
  }
  else median(abs(x - center))
}, function (x, center = median(x), constant = 1.4826, na.rm = FALSE, low = FALSE, high = FALSE) 
{
  if (na.rm) 
    x <- x[!is.na(x)]
  n <- length(x)
  constant * if ((low || high) && n%%2 == 0) {
    if (low && high) 
      stop("'low' and 'high' cannot be both TRUE")
    n2 <- n%/%2 + as.integer(high)
    sort(abs(x - center), partial = n2)[n2]
  }
  else median(abs(x - center))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
mahalanobis
list(`package:stats` = function (x, center, cov, inverted = FALSE, ...) 
{
  x <- if (is.vector(x)) 
    matrix(x, ncol = length(x))
  else as.matrix(x)
  if (!isFALSE(center)) 
    x <- sweep(x, 2, center)
  if (!inverted) 
    cov <- solve(cov, ...)
  setNames(rowSums(x %*% cov * x), rownames(x))
}, function (x, center, cov, inverted = FALSE, ...) 
{
  x <- if (is.vector(x)) 
    matrix(x, ncol = length(x))
  else as.matrix(x)
  if (!isFALSE(center)) 
    x <- sweep(x, 2, center)
  if (!inverted) 
    cov <- solve(cov, ...)
  setNames(rowSums(x %*% cov * x), rownames(x))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
make.link
list(`package:stats` = function (link) 
{
  switch(link, logit = {
    linkfun <- function(mu) .Call(C_logit_link, mu)
    linkinv <- function(eta) .Call(C_logit_linkinv, eta)
    mu.eta <- function(eta) .Call(C_logit_mu_eta, eta)
    valideta <- function(eta) TRUE
  }, probit = {
    linkfun <- function(mu) qnorm(mu)
    linkinv <- function(eta) {
      thresh <- -qnorm(.Machine$double.eps)
      eta <- pmin(pmax(eta, -thresh), thresh)
      pnorm(eta)
    }
    mu.eta <- function(eta) pmax(dnorm(eta), .Machine$double.eps)
    valideta <- function(eta) TRUE
  }, cauchit = {
    linkfun <- function(mu) qcauchy(mu)
    linkinv <- function(eta) {
      thresh <- -qcauchy(.Machine$double.eps)
      eta <- pmin(pmax(eta, -thresh), thresh)
      pcauchy(eta)
    }
    mu.eta <- function(eta) pmax(dcauchy(eta), .Machine$double.eps)
    valideta <- function(eta) TRUE
  }, cloglog = {
    linkfun <- function(mu) log(-log(1 - mu))
    linkinv <- function(eta) pmax(pmin(-expm1(-exp(eta)), 1 - .Machine$double.eps), .Machine$double.eps)
    mu.eta <- function(eta) {
      eta <- pmin(eta, 700)
      pmax(exp(eta) * exp(-exp(eta)), .Machine$double.eps)
    }
    valideta <- function(eta) TRUE
  }, identity = {
    linkfun <- function(mu) mu
    linkinv <- function(eta) eta
    mu.eta <- function(eta) rep.int(1, length(eta))
    valideta <- function(eta) TRUE
  }, log = {
    linkfun <- function(mu) log(mu)
    linkinv <- function(eta) pmax(exp(eta), .Machine$double.eps)
    mu.eta <- function(eta) pmax(exp(eta), .Machine$double.eps)
    valideta <- function(eta) TRUE
  }, sqrt = {
    linkfun <- function(mu) sqrt(mu)
    linkinv <- function(eta) eta^2
    mu.eta <- function(eta) 2 * eta
    valideta <- function(eta) all(is.finite(eta)) && all(eta > 0)
  }, `1/mu^2` = {
    linkfun <- function(mu) 1/mu^2
    linkinv <- function(eta) 1/sqrt(eta)
    mu.eta <- function(eta) -1/(2 * eta^1.5)
    valideta <- function(eta) all(is.finite(eta)) && all(eta > 0)
  }, inverse = {
    linkfun <- function(mu) 1/mu
    linkinv <- function(eta) 1/eta
    mu.eta <- function(eta) -1/(eta^2)
    valideta <- function(eta) all(is.finite(eta)) && all(eta != 0)
  }, stop(gettextf("%s link not recognised", sQuote(link)), domain = NA))
  environment(linkfun) <- environment(linkinv) <- environment(mu.eta) <- environment(valideta) <- asNamespace("stats")
  structure(list(linkfun = linkfun, linkinv = linkinv, mu.eta = mu.eta, valideta = valideta, name = link), class = "link-glm")
}, function (link) 
{
  switch(link, logit = {
    linkfun <- function(mu) .Call(C_logit_link, mu)
    linkinv <- function(eta) .Call(C_logit_linkinv, eta)
    mu.eta <- function(eta) .Call(C_logit_mu_eta, eta)
    valideta <- function(eta) TRUE
  }, probit = {
    linkfun <- function(mu) qnorm(mu)
    linkinv <- function(eta) {
      thresh <- -qnorm(.Machine$double.eps)
      eta <- pmin(pmax(eta, -thresh), thresh)
      pnorm(eta)
    }
    mu.eta <- function(eta) pmax(dnorm(eta), .Machine$double.eps)
    valideta <- function(eta) TRUE
  }, cauchit = {
    linkfun <- function(mu) qcauchy(mu)
    linkinv <- function(eta) {
      thresh <- -qcauchy(.Machine$double.eps)
      eta <- pmin(pmax(eta, -thresh), thresh)
      pcauchy(eta)
    }
    mu.eta <- function(eta) pmax(dcauchy(eta), .Machine$double.eps)
    valideta <- function(eta) TRUE
  }, cloglog = {
    linkfun <- function(mu) log(-log(1 - mu))
    linkinv <- function(eta) pmax(pmin(-expm1(-exp(eta)), 1 - .Machine$double.eps), .Machine$double.eps)
    mu.eta <- function(eta) {
      eta <- pmin(eta, 700)
      pmax(exp(eta) * exp(-exp(eta)), .Machine$double.eps)
    }
    valideta <- function(eta) TRUE
  }, identity = {
    linkfun <- function(mu) mu
    linkinv <- function(eta) eta
    mu.eta <- function(eta) rep.int(1, length(eta))
    valideta <- function(eta) TRUE
  }, log = {
    linkfun <- function(mu) log(mu)
    linkinv <- function(eta) pmax(exp(eta), .Machine$double.eps)
    mu.eta <- function(eta) pmax(exp(eta), .Machine$double.eps)
    valideta <- function(eta) TRUE
  }, sqrt = {
    linkfun <- function(mu) sqrt(mu)
    linkinv <- function(eta) eta^2
    mu.eta <- function(eta) 2 * eta
    valideta <- function(eta) all(is.finite(eta)) && all(eta > 0)
  }, `1/mu^2` = {
    linkfun <- function(mu) 1/mu^2
    linkinv <- function(eta) 1/sqrt(eta)
    mu.eta <- function(eta) -1/(2 * eta^1.5)
    valideta <- function(eta) all(is.finite(eta)) && all(eta > 0)
  }, inverse = {
    linkfun <- function(mu) 1/mu
    linkinv <- function(eta) 1/eta
    mu.eta <- function(eta) -1/(eta^2)
    valideta <- function(eta) all(is.finite(eta)) && all(eta != 0)
  }, stop(gettextf("%s link not recognised", sQuote(link)), domain = NA))
  environment(linkfun) <- environment(linkinv) <- environment(mu.eta) <- environment(valideta) <- asNamespace("stats")
  structure(list(linkfun = linkfun, linkinv = linkinv, mu.eta = mu.eta, valideta = valideta, name = link), class = "link-glm")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeARIMA
list(`package:stats` = function (phi, theta, Delta, kappa = 1e+06, SSinit = c("Gardner1980", "Rossignol2011"), tol = .Machine$double.eps) 
{
  if (anyNA(phi)) 
    warning(gettextf("NAs in '%s'", "phi"), domain = NA)
  if (anyNA(theta)) 
    warning(gettextf("NAs in '%s'", "theta"), domain = NA)
  p <- length(phi)
  q <- length(theta)
  r <- max(p, q + 1)
  d <- length(Delta)
  rd <- r + d
  Z <- c(1, rep.int(0, r - 1), Delta)
  T <- matrix(0, rd, rd)
  if (p > 0) 
    T[1:p, 1] <- phi
  if (r > 1) {
    ind <- 2:r
    T[cbind(ind - 1, ind)] <- 1
  }
  if (d > 0) {
    T[r + 1, ] <- Z
    if (d > 1) {
      ind <- r + 2:d
      T[cbind(ind, ind - 1)] <- 1
    }
  }
  if (q < r - 1) 
    theta <- c(theta, rep.int(0, r - 1 - q))
  R <- c(1, theta, rep.int(0, d))
  V <- R %o% R
  h <- 0
  a <- rep(0, rd)
  Pn <- P <- matrix(0, rd, rd)
  if (r > 1) 
    Pn[1:r, 1:r] <- switch(match.arg(SSinit), Gardner1980 = .Call(C_getQ0, phi, theta), Rossignol2011 = .Call(C_getQ0bis, phi, theta, tol), stop("invalid 'SSinit'"))
  else Pn[1, 1] <- if (p > 0) 
    1/(1 - phi^2)
  else 1
  if (d > 0) 
    Pn[cbind(r + 1:d, r + 1:d)] <- kappa
  list(phi = phi, theta = theta, Delta = Delta, Z = Z, a = a, P = P, T = T, V = V, h = h, Pn = Pn)
}, function (phi, theta, Delta, kappa = 1e+06, SSinit = c("Gardner1980", "Rossignol2011"), tol = .Machine$double.eps) 
{
  if (anyNA(phi)) 
    warning(gettextf("NAs in '%s'", "phi"), domain = NA)
  if (anyNA(theta)) 
    warning(gettextf("NAs in '%s'", "theta"), domain = NA)
  p <- length(phi)
  q <- length(theta)
  r <- max(p, q + 1)
  d <- length(Delta)
  rd <- r + d
  Z <- c(1, rep.int(0, r - 1), Delta)
  T <- matrix(0, rd, rd)
  if (p > 0) 
    T[1:p, 1] <- phi
  if (r > 1) {
    ind <- 2:r
    T[cbind(ind - 1, ind)] <- 1
  }
  if (d > 0) {
    T[r + 1, ] <- Z
    if (d > 1) {
      ind <- r + 2:d
      T[cbind(ind, ind - 1)] <- 1
    }
  }
  if (q < r - 1) 
    theta <- c(theta, rep.int(0, r - 1 - q))
  R <- c(1, theta, rep.int(0, d))
  V <- R %o% R
  h <- 0
  a <- rep(0, rd)
  Pn <- P <- matrix(0, rd, rd)
  if (r > 1) 
    Pn[1:r, 1:r] <- switch(match.arg(SSinit), Gardner1980 = .Call(C_getQ0, phi, theta), Rossignol2011 = .Call(C_getQ0bis, phi, theta, tol), stop("invalid 'SSinit'"))
  else Pn[1, 1] <- if (p > 0) 
    1/(1 - phi^2)
  else 1
  if (d > 0) 
    Pn[cbind(r + 1:d, r + 1:d)] <- kappa
  list(phi = phi, theta = theta, Delta = Delta, Z = Z, a = a, P = P, T = T, V = V, h = h, Pn = Pn)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
makepredictcall
list(`package:stats` = function (var, call) 
  UseMethod("makepredictcall"), function (var, call) 
    UseMethod("makepredictcall"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
manova
list(`package:stats` = function (...) 
{
  Call <- fcall <- match.call()
  fcall[[1]] <- quote(stats::aov)
  result <- eval(fcall, parent.frame())
  if (inherits(result, "aovlist")) {
    for (i in seq_along(result)) {
      if (!inherits(result[[i]], "maov")) 
        stop("need multiple responses")
      class(result[[i]]) <- c("manova", oldClass(result[[i]]))
    }
    attr(result, "call") <- Call
  }
  else {
    if (!inherits(result, "maov")) 
      stop("need multiple responses")
    class(result) <- c("manova", oldClass(result))
    result$call <- Call
  }
  result
}, function (...) 
{
  Call <- fcall <- match.call()
  fcall[[1]] <- quote(stats::aov)
  result <- eval(fcall, parent.frame())
  if (inherits(result, "aovlist")) {
    for (i in seq_along(result)) {
      if (!inherits(result[[i]], "maov")) 
        stop("need multiple responses")
      class(result[[i]]) <- c("manova", oldClass(result[[i]]))
    }
    attr(result, "call") <- Call
  }
  else {
    if (!inherits(result, "maov")) 
      stop("need multiple responses")
    class(result) <- c("manova", oldClass(result))
    result$call <- Call
  }
  result
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
mantelhaen.test
list(`package:stats` = function (x, y = NULL, z = NULL, alternative = c("two.sided", "less", "greater"), correct = TRUE, exact = FALSE, conf.level = 0.95) 
{
  DNAME <- deparse1(substitute(x))
  if (is.array(x)) {
    if (length(dim(x)) == 3) {
      if (anyNA(x)) 
        stop("NAs are not allowed")
      if (any(dim(x) < 2)) 
        stop("each dimension in table must be >= 2")
    }
    else stop("'x' must be a 3-dimensional array")
  }
  else {
    if (is.null(y)) 
      stop("if 'x' is not an array, 'y' must be given")
    if (is.null(z)) 
      stop("if 'x' is not an array, 'z' must be given")
    if (any(diff(c(length(x), length(y), length(z))) != 0)) 
      stop("'x', 'y', and 'z' must have the same length")
    DNAME <- paste(DNAME, "and", deparse1(substitute(y)), "and", deparse1(substitute(z)))
    OK <- complete.cases(x, y, z)
    x <- factor(x[OK])
    y <- factor(y[OK])
    if ((nlevels(x) < 2) || (nlevels(y) < 2)) 
      stop("'x' and 'y' must have at least 2 levels")
    else x <- table(x, y, z[OK])
  }
  if (any(apply(x, 3, sum) < 2)) 
    stop("sample size in each stratum must be > 1")
  I <- dim(x)[1]
  J <- dim(x)[2]
  K <- dim(x)[3]
  if ((I == 2) && (J == 2)) {
    alternative <- match.arg(alternative)
    if (!missing(conf.level) && (length(conf.level) != 1 || !is.finite(conf.level) || conf.level < 0 || conf.level > 1)) 
      stop("'conf.level' must be a single number between 0 and 1")
    NVAL <- c(`common odds ratio` = 1)
    if (!exact) {
      s.x <- apply(x, c(1, 3), sum)
      s.y <- apply(x, c(2, 3), sum)
      n <- as.double(apply(x, 3, sum))
      DELTA <- sum(x[1, 1, ] - s.x[1, ] * s.y[1, ]/n)
      YATES <- if (correct && (abs(DELTA) >= 0.5)) 
        0.5
      else 0
      STATISTIC <- ((abs(DELTA) - YATES)^2/sum(apply(rbind(s.x, s.y), 2, prod)/(n^2 * (n - 1))))
      PARAMETER <- 1
      if (alternative == "two.sided") 
        PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
      else {
        z <- sign(DELTA) * sqrt(STATISTIC)
        PVAL <- pnorm(z, lower.tail = (alternative == "less"))
      }
      names(STATISTIC) <- "Mantel-Haenszel X-squared"
      names(PARAMETER) <- "df"
      METHOD <- paste("Mantel-Haenszel chi-squared test", if (YATES) 
        "with"
        else "without", "continuity correction")
      s.diag <- sum(x[1, 1, ] * x[2, 2, ]/n)
      s.offd <- sum(x[1, 2, ] * x[2, 1, ]/n)
      ESTIMATE <- s.diag/s.offd
      sd <- sqrt(sum((x[1, 1, ] + x[2, 2, ]) * x[1, 1, ] * x[2, 2, ]/n^2)/(2 * s.diag^2) + sum(((x[1, 1, ] + x[2, 2, ]) * x[1, 2, ] * x[2, 1, ] + (x[1, 2, ] + x[2, 1, ]) * x[1, 1, ] * x[2, 2, ])/n^2)/(2 * s.diag * s.offd) + sum((x[1, 2, ] + x[2, 1, ]) * x[1, 2, ] * x[2, 1, ]/n^2)/(2 * s.offd^2))
      CINT <- switch(alternative, less = c(0, ESTIMATE * exp(qnorm(conf.level) * sd)), greater = c(ESTIMATE * exp(qnorm(conf.level, lower.tail = FALSE) * sd), Inf), two.sided = {
        ESTIMATE * exp(c(1, -1) * qnorm((1 - conf.level)/2) * sd)
      })
      RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL)
    }
    else {
      METHOD <- paste("Exact conditional test of independence", "in 2 x 2 x k tables")
      mn <- apply(x, c(2, 3), sum)
      m <- mn[1, ]
      n <- mn[2, ]
      t <- apply(x, c(1, 3), sum)[1, ]
      s <- sum(x[1, 1, ])
      lo <- sum(pmax(0, t - n))
      hi <- sum(pmin(m, t))
      support <- lo:hi
      dc <- .Call(C_d2x2xk, K, m, n, t, hi - lo + 1)
      logdc <- log(dc)
      dn2x2xk <- function(ncp) {
        if (ncp == 1) 
          return(dc)
        d <- logdc + log(ncp) * support
        d <- exp(d - max(d))
        d/sum(d)
      }
      mn2x2xk <- function(ncp) {
        if (ncp == 0) 
          return(lo)
        if (ncp == Inf) 
          return(hi)
        sum(support * dn2x2xk(ncp))
      }
      pn2x2xk <- function(q, ncp = 1, upper.tail = FALSE) {
        if (ncp == 0) {
          as.numeric(if (upper.tail) q <= lo else q >= lo)
        }
        else if (ncp == Inf) 
          as.numeric(if (upper.tail) q <= hi else q >= hi)
        else {
          d <- dn2x2xk(ncp)
          sum(d[if (upper.tail) support >= q else support <= q])
        }
      }
      PVAL <- switch(alternative, less = pn2x2xk(s, 1), greater = pn2x2xk(s, 1, upper.tail = TRUE), two.sided = {
        relErr <- 1 + 10^(-7)
        d <- dc
        sum(d[d <= d[s - lo + 1] * relErr])
      })
      mle <- function(x) {
        if (x == lo) 
          return(0)
        if (x == hi) 
          return(Inf)
        mu <- mn2x2xk(1)
        if (mu > x) 
          uniroot(function(t) mn2x2xk(t) - x, c(0, 1))$root
        else if (mu < x) 
          1/uniroot(function(t) mn2x2xk(1/t) - x, c(.Machine$double.eps, 1))$root
        else 1
      }
      ESTIMATE <- mle(s)
      ncp.U <- function(x, alpha) {
        if (x == hi) 
          return(Inf)
        p <- pn2x2xk(x, 1)
        if (p < alpha) 
          uniroot(function(t) pn2x2xk(x, t) - alpha, c(0, 1))$root
        else if (p > alpha) 
          1/uniroot(function(t) pn2x2xk(x, 1/t) - alpha, c(.Machine$double.eps, 1))$root
        else 1
      }
      ncp.L <- function(x, alpha) {
        if (x == lo) 
          return(0)
        p <- pn2x2xk(x, 1, upper.tail = TRUE)
        if (p > alpha) 
          uniroot(function(t) pn2x2xk(x, t, upper.tail = TRUE) - alpha, c(0, 1))$root
        else if (p < alpha) 
          1/uniroot(function(t) pn2x2xk(x, 1/t, upper.tail = TRUE) - alpha, c(.Machine$double.eps, 1))$root
        else 1
      }
      CINT <- switch(alternative, less = c(0, ncp.U(s, 1 - conf.level)), greater = c(ncp.L(s, 1 - conf.level), Inf), two.sided = {
        alpha <- (1 - conf.level)/2
        c(ncp.L(s, alpha), ncp.U(s, alpha))
      })
      STATISTIC <- c(S = s)
      RVAL <- list(statistic = STATISTIC, p.value = PVAL)
    }
    names(ESTIMATE) <- names(NVAL)
    attr(CINT, "conf.level") <- conf.level
    RVAL <- c(RVAL, list(conf.int = CINT, estimate = ESTIMATE, null.value = NVAL, alternative = alternative))
  }
  else {
    df <- (I - 1) * (J - 1)
    n <- m <- double(length = df)
    V <- matrix(0, nrow = df, ncol = df)
    for (k in 1:K) {
      f <- x[, , k]
      ntot <- as.double(sum(f))
      rowsums <- rowSums(f)[-I]
      colsums <- colSums(f)[-J]
      n <- n + c(f[-I, -J])
      m <- m + c(outer(rowsums, colsums))/ntot
      V <- V + (kronecker(diag(ntot * colsums, nrow = J - 1) - outer(colsums, colsums), diag(ntot * rowsums, nrow = I - 1) - outer(rowsums, rowsums))/(ntot^2 * (ntot - 1)))
    }
    n <- n - m
    STATISTIC <- c(crossprod(n, qr.solve(V, n)))
    PARAMETER <- df
    PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    names(STATISTIC) <- "Cochran-Mantel-Haenszel M^2"
    names(PARAMETER) <- "df"
    METHOD <- "Cochran-Mantel-Haenszel test"
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL)
  }
  structure(c(RVAL, list(method = METHOD, data.name = DNAME)), class = "htest")
}, function (x, y = NULL, z = NULL, alternative = c("two.sided", "less", "greater"), correct = TRUE, exact = FALSE, conf.level = 0.95) 
{
  DNAME <- deparse1(substitute(x))
  if (is.array(x)) {
    if (length(dim(x)) == 3) {
      if (anyNA(x)) 
        stop("NAs are not allowed")
      if (any(dim(x) < 2)) 
        stop("each dimension in table must be >= 2")
    }
    else stop("'x' must be a 3-dimensional array")
  }
  else {
    if (is.null(y)) 
      stop("if 'x' is not an array, 'y' must be given")
    if (is.null(z)) 
      stop("if 'x' is not an array, 'z' must be given")
    if (any(diff(c(length(x), length(y), length(z))) != 0)) 
      stop("'x', 'y', and 'z' must have the same length")
    DNAME <- paste(DNAME, "and", deparse1(substitute(y)), "and", deparse1(substitute(z)))
    OK <- complete.cases(x, y, z)
    x <- factor(x[OK])
    y <- factor(y[OK])
    if ((nlevels(x) < 2) || (nlevels(y) < 2)) 
      stop("'x' and 'y' must have at least 2 levels")
    else x <- table(x, y, z[OK])
  }
  if (any(apply(x, 3, sum) < 2)) 
    stop("sample size in each stratum must be > 1")
  I <- dim(x)[1]
  J <- dim(x)[2]
  K <- dim(x)[3]
  if ((I == 2) && (J == 2)) {
    alternative <- match.arg(alternative)
    if (!missing(conf.level) && (length(conf.level) != 1 || !is.finite(conf.level) || conf.level < 0 || conf.level > 1)) 
      stop("'conf.level' must be a single number between 0 and 1")
    NVAL <- c(`common odds ratio` = 1)
    if (!exact) {
      s.x <- apply(x, c(1, 3), sum)
      s.y <- apply(x, c(2, 3), sum)
      n <- as.double(apply(x, 3, sum))
      DELTA <- sum(x[1, 1, ] - s.x[1, ] * s.y[1, ]/n)
      YATES <- if (correct && (abs(DELTA) >= 0.5)) 
        0.5
      else 0
      STATISTIC <- ((abs(DELTA) - YATES)^2/sum(apply(rbind(s.x, s.y), 2, prod)/(n^2 * (n - 1))))
      PARAMETER <- 1
      if (alternative == "two.sided") 
        PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
      else {
        z <- sign(DELTA) * sqrt(STATISTIC)
        PVAL <- pnorm(z, lower.tail = (alternative == "less"))
      }
      names(STATISTIC) <- "Mantel-Haenszel X-squared"
      names(PARAMETER) <- "df"
      METHOD <- paste("Mantel-Haenszel chi-squared test", if (YATES) 
        "with"
        else "without", "continuity correction")
      s.diag <- sum(x[1, 1, ] * x[2, 2, ]/n)
      s.offd <- sum(x[1, 2, ] * x[2, 1, ]/n)
      ESTIMATE <- s.diag/s.offd
      sd <- sqrt(sum((x[1, 1, ] + x[2, 2, ]) * x[1, 1, ] * x[2, 2, ]/n^2)/(2 * s.diag^2) + sum(((x[1, 1, ] + x[2, 2, ]) * x[1, 2, ] * x[2, 1, ] + (x[1, 2, ] + x[2, 1, ]) * x[1, 1, ] * x[2, 2, ])/n^2)/(2 * s.diag * s.offd) + sum((x[1, 2, ] + x[2, 1, ]) * x[1, 2, ] * x[2, 1, ]/n^2)/(2 * s.offd^2))
      CINT <- switch(alternative, less = c(0, ESTIMATE * exp(qnorm(conf.level) * sd)), greater = c(ESTIMATE * exp(qnorm(conf.level, lower.tail = FALSE) * sd), Inf), two.sided = {
        ESTIMATE * exp(c(1, -1) * qnorm((1 - conf.level)/2) * sd)
      })
      RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL)
    }
    else {
      METHOD <- paste("Exact conditional test of independence", "in 2 x 2 x k tables")
      mn <- apply(x, c(2, 3), sum)
      m <- mn[1, ]
      n <- mn[2, ]
      t <- apply(x, c(1, 3), sum)[1, ]
      s <- sum(x[1, 1, ])
      lo <- sum(pmax(0, t - n))
      hi <- sum(pmin(m, t))
      support <- lo:hi
      dc <- .Call(C_d2x2xk, K, m, n, t, hi - lo + 1)
      logdc <- log(dc)
      dn2x2xk <- function(ncp) {
        if (ncp == 1) 
          return(dc)
        d <- logdc + log(ncp) * support
        d <- exp(d - max(d))
        d/sum(d)
      }
      mn2x2xk <- function(ncp) {
        if (ncp == 0) 
          return(lo)
        if (ncp == Inf) 
          return(hi)
        sum(support * dn2x2xk(ncp))
      }
      pn2x2xk <- function(q, ncp = 1, upper.tail = FALSE) {
        if (ncp == 0) {
          as.numeric(if (upper.tail) q <= lo else q >= lo)
        }
        else if (ncp == Inf) 
          as.numeric(if (upper.tail) q <= hi else q >= hi)
        else {
          d <- dn2x2xk(ncp)
          sum(d[if (upper.tail) support >= q else support <= q])
        }
      }
      PVAL <- switch(alternative, less = pn2x2xk(s, 1), greater = pn2x2xk(s, 1, upper.tail = TRUE), two.sided = {
        relErr <- 1 + 10^(-7)
        d <- dc
        sum(d[d <= d[s - lo + 1] * relErr])
      })
      mle <- function(x) {
        if (x == lo) 
          return(0)
        if (x == hi) 
          return(Inf)
        mu <- mn2x2xk(1)
        if (mu > x) 
          uniroot(function(t) mn2x2xk(t) - x, c(0, 1))$root
        else if (mu < x) 
          1/uniroot(function(t) mn2x2xk(1/t) - x, c(.Machine$double.eps, 1))$root
        else 1
      }
      ESTIMATE <- mle(s)
      ncp.U <- function(x, alpha) {
        if (x == hi) 
          return(Inf)
        p <- pn2x2xk(x, 1)
        if (p < alpha) 
          uniroot(function(t) pn2x2xk(x, t) - alpha, c(0, 1))$root
        else if (p > alpha) 
          1/uniroot(function(t) pn2x2xk(x, 1/t) - alpha, c(.Machine$double.eps, 1))$root
        else 1
      }
      ncp.L <- function(x, alpha) {
        if (x == lo) 
          return(0)
        p <- pn2x2xk(x, 1, upper.tail = TRUE)
        if (p > alpha) 
          uniroot(function(t) pn2x2xk(x, t, upper.tail = TRUE) - alpha, c(0, 1))$root
        else if (p < alpha) 
          1/uniroot(function(t) pn2x2xk(x, 1/t, upper.tail = TRUE) - alpha, c(.Machine$double.eps, 1))$root
        else 1
      }
      CINT <- switch(alternative, less = c(0, ncp.U(s, 1 - conf.level)), greater = c(ncp.L(s, 1 - conf.level), Inf), two.sided = {
        alpha <- (1 - conf.level)/2
        c(ncp.L(s, alpha), ncp.U(s, alpha))
      })
      STATISTIC <- c(S = s)
      RVAL <- list(statistic = STATISTIC, p.value = PVAL)
    }
    names(ESTIMATE) <- names(NVAL)
    attr(CINT, "conf.level") <- conf.level
    RVAL <- c(RVAL, list(conf.int = CINT, estimate = ESTIMATE, null.value = NVAL, alternative = alternative))
  }
  else {
    df <- (I - 1) * (J - 1)
    n <- m <- double(length = df)
    V <- matrix(0, nrow = df, ncol = df)
    for (k in 1:K) {
      f <- x[, , k]
      ntot <- as.double(sum(f))
      rowsums <- rowSums(f)[-I]
      colsums <- colSums(f)[-J]
      n <- n + c(f[-I, -J])
      m <- m + c(outer(rowsums, colsums))/ntot
      V <- V + (kronecker(diag(ntot * colsums, nrow = J - 1) - outer(colsums, colsums), diag(ntot * rowsums, nrow = I - 1) - outer(rowsums, rowsums))/(ntot^2 * (ntot - 1)))
    }
    n <- n - m
    STATISTIC <- c(crossprod(n, qr.solve(V, n)))
    PARAMETER <- df
    PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
    names(STATISTIC) <- "Cochran-Mantel-Haenszel M^2"
    names(PARAMETER) <- "df"
    METHOD <- "Cochran-Mantel-Haenszel test"
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL)
  }
  structure(c(RVAL, list(method = METHOD, data.name = DNAME)), class = "htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
mauchly.test
list(`package:stats` = function (object, ...) 
  UseMethod("mauchly.test", object), function (object, ...) 
    UseMethod("mauchly.test", object))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
mcnemar.test
list(`package:stats` = function (x, y = NULL, correct = TRUE) 
{
  if (is.matrix(x)) {
    r <- nrow(x)
    if ((r < 2) || (ncol(x) != r)) 
      stop("'x' must be square with at least two rows and columns")
    if (any(x < 0) || anyNA(x)) 
      stop("all entries of 'x' must be nonnegative and finite")
    DNAME <- deparse1(substitute(x))
  }
  else {
    if (is.null(y)) 
      stop("if 'x' is not a matrix, 'y' must be given")
    if (length(x) != length(y)) 
      stop("'x' and 'y' must have the same length")
    DNAME <- paste(deparse1(substitute(x)), "and", deparse1(substitute(y)))
    OK <- complete.cases(x, y)
    x <- as.factor(x[OK])
    y <- as.factor(y[OK])
    r <- nlevels(x)
    if ((r < 2) || (nlevels(y) != r)) 
      stop("'x' and 'y' must have the same number of levels (minimum 2)")
    x <- table(x, y)
  }
  PARAMETER <- r * (r - 1)/2
  METHOD <- "McNemar's Chi-squared test"
  if (correct && (r == 2) && any(x - t(x) != 0)) {
    y <- (abs(x - t(x)) - 1)
    METHOD <- paste(METHOD, "with continuity correction")
  }
  else y <- x - t(x)
  x <- x + t(x)
  STATISTIC <- sum(y[upper.tri(x)]^2/x[upper.tri(x)])
  PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
  names(STATISTIC) <- "McNemar's chi-squared"
  names(PARAMETER) <- "df"
  RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME)
  class(RVAL) <- "htest"
  return(RVAL)
}, function (x, y = NULL, correct = TRUE) 
{
  if (is.matrix(x)) {
    r <- nrow(x)
    if ((r < 2) || (ncol(x) != r)) 
      stop("'x' must be square with at least two rows and columns")
    if (any(x < 0) || anyNA(x)) 
      stop("all entries of 'x' must be nonnegative and finite")
    DNAME <- deparse1(substitute(x))
  }
  else {
    if (is.null(y)) 
      stop("if 'x' is not a matrix, 'y' must be given")
    if (length(x) != length(y)) 
      stop("'x' and 'y' must have the same length")
    DNAME <- paste(deparse1(substitute(x)), "and", deparse1(substitute(y)))
    OK <- complete.cases(x, y)
    x <- as.factor(x[OK])
    y <- as.factor(y[OK])
    r <- nlevels(x)
    if ((r < 2) || (nlevels(y) != r)) 
      stop("'x' and 'y' must have the same number of levels (minimum 2)")
    x <- table(x, y)
  }
  PARAMETER <- r * (r - 1)/2
  METHOD <- "McNemar's Chi-squared test"
  if (correct && (r == 2) && any(x - t(x) != 0)) {
    y <- (abs(x - t(x)) - 1)
    METHOD <- paste(METHOD, "with continuity correction")
  }
  else y <- x - t(x)
  x <- x + t(x)
  STATISTIC <- sum(y[upper.tri(x)]^2/x[upper.tri(x)])
  PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
  names(STATISTIC) <- "McNemar's chi-squared"
  names(PARAMETER) <- "df"
  RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME)
  class(RVAL) <- "htest"
  return(RVAL)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
median
list(`package:stats` = function (x, na.rm = FALSE, ...) 
  UseMethod("median"), function (x, na.rm = FALSE, ...) 
    UseMethod("median"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
median.default
list(`package:stats` = function (x, na.rm = FALSE, ...) 
{
  if (is.factor(x) || is.data.frame(x)) 
    stop("need numeric data")
  if (length(names(x))) 
    names(x) <- NULL
  if (na.rm) 
    x <- x[!is.na(x)]
  else if (any(is.na(x))) 
    return(x[NA])
  n <- length(x)
  if (n == 0) 
    return(x[NA])
  half <- (n + 1)%/%2
  if (n%%2 == 1) 
    sort(x, partial = half)[half]
  else mean(sort(x, partial = half + 0:1)[half + 0:1])
}, function (x, na.rm = FALSE, ...) 
{
  if (is.factor(x) || is.data.frame(x)) 
    stop("need numeric data")
  if (length(names(x))) 
    names(x) <- NULL
  if (na.rm) 
    x <- x[!is.na(x)]
  else if (any(is.na(x))) 
    return(x[NA])
  n <- length(x)
  if (n == 0) 
    return(x[NA])
  half <- (n + 1)%/%2
  if (n%%2 == 1) 
    sort(x, partial = half)[half]
  else mean(sort(x, partial = half + 0:1)[half + 0:1])
}, function (x, na.rm = FALSE, ...) 
{
  if (is.factor(x) || is.data.frame(x)) 
    stop("need numeric data")
  if (length(names(x))) 
    names(x) <- NULL
  if (na.rm) 
    x <- x[!is.na(x)]
  else if (any(is.na(x))) 
    return(x[NA])
  n <- length(x)
  if (n == 0) 
    return(x[NA])
  half <- (n + 1)%/%2
  if (n%%2 == 1) 
    sort(x, partial = half)[half]
  else mean(sort(x, partial = half + 0:1)[half + 0:1])
})
c("package:stats", "registered S3 method for median from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
medpolish
list(`package:stats` = function (x, eps = 0.01, maxiter = 10, trace.iter = TRUE, na.rm = FALSE) 
{
  z <- as.matrix(x)
  nr <- nrow(z)
  nc <- ncol(z)
  t <- 0
  r <- numeric(nr)
  c <- numeric(nc)
  oldsum <- 0
  for (iter in 1:maxiter) {
    rdelta <- apply(z, 1, median, na.rm = na.rm)
    z <- z - matrix(rdelta, nrow = nr, ncol = nc)
    r <- r + rdelta
    delta <- median(c, na.rm = na.rm)
    c <- c - delta
    t <- t + delta
    cdelta <- apply(z, 2, median, na.rm = na.rm)
    z <- z - matrix(cdelta, nrow = nr, ncol = nc, byrow = TRUE)
    c <- c + cdelta
    delta <- median(r, na.rm = na.rm)
    r <- r - delta
    t <- t + delta
    newsum <- sum(abs(z), na.rm = na.rm)
    converged <- newsum == 0 || abs(newsum - oldsum) < eps * newsum
    if (converged) 
      break
    oldsum <- newsum
    if (trace.iter) 
      cat(iter, ": ", newsum, "\n", sep = "")
  }
  if (converged) {
    if (trace.iter) 
      cat("Final: ", newsum, "\n", sep = "")
  }
  else warning(sprintf(ngettext(maxiter, "medpolish() did not converge in %d iteration", "medpolish() did not converge in %d iterations"), maxiter), domain = NA)
  names(r) <- rownames(z)
  names(c) <- colnames(z)
  ans <- list(overall = t, row = r, col = c, residuals = z, name = deparse1(substitute(x)))
  class(ans) <- "medpolish"
  ans
}, function (x, eps = 0.01, maxiter = 10, trace.iter = TRUE, na.rm = FALSE) 
{
  z <- as.matrix(x)
  nr <- nrow(z)
  nc <- ncol(z)
  t <- 0
  r <- numeric(nr)
  c <- numeric(nc)
  oldsum <- 0
  for (iter in 1:maxiter) {
    rdelta <- apply(z, 1, median, na.rm = na.rm)
    z <- z - matrix(rdelta, nrow = nr, ncol = nc)
    r <- r + rdelta
    delta <- median(c, na.rm = na.rm)
    c <- c - delta
    t <- t + delta
    cdelta <- apply(z, 2, median, na.rm = na.rm)
    z <- z - matrix(cdelta, nrow = nr, ncol = nc, byrow = TRUE)
    c <- c + cdelta
    delta <- median(r, na.rm = na.rm)
    r <- r - delta
    t <- t + delta
    newsum <- sum(abs(z), na.rm = na.rm)
    converged <- newsum == 0 || abs(newsum - oldsum) < eps * newsum
    if (converged) 
      break
    oldsum <- newsum
    if (trace.iter) 
      cat(iter, ": ", newsum, "\n", sep = "")
  }
  if (converged) {
    if (trace.iter) 
      cat("Final: ", newsum, "\n", sep = "")
  }
  else warning(sprintf(ngettext(maxiter, "medpolish() did not converge in %d iteration", "medpolish() did not converge in %d iterations"), maxiter), domain = NA)
  names(r) <- rownames(z)
  names(c) <- colnames(z)
  ans <- list(overall = t, row = r, col = c, residuals = z, name = deparse1(substitute(x)))
  class(ans) <- "medpolish"
  ans
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
model.extract
list(`package:stats` = function (frame, component) 
{
  component <- as.character(substitute(component))
  rval <- switch(component, response = model.response(frame), offset = model.offset(frame), frame[[paste0("(", component, ")")]])
  if (!is.null(rval)) {
    if (length(rval) == nrow(frame)) 
      names(rval) <- attr(frame, "row.names")
    else if (is.matrix(rval) && nrow(rval) == nrow(frame)) {
      t1 <- dimnames(rval)
      dimnames(rval) <- list(attr(frame, "row.names"), t1[[2]])
    }
  }
  rval
}, function (frame, component) 
{
  component <- as.character(substitute(component))
  rval <- switch(component, response = model.response(frame), offset = model.offset(frame), frame[[paste0("(", component, ")")]])
  if (!is.null(rval)) {
    if (length(rval) == nrow(frame)) 
      names(rval) <- attr(frame, "row.names")
    else if (is.matrix(rval) && nrow(rval) == nrow(frame)) {
      t1 <- dimnames(rval)
      dimnames(rval) <- list(attr(frame, "row.names"), t1[[2]])
    }
  }
  rval
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
model.frame
list(`package:stats` = function (formula, ...) 
  UseMethod("model.frame"), function (formula, ...) 
    UseMethod("model.frame"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
model.frame.default
list(`package:stats` = function (formula, data = NULL, subset = NULL, na.action = na.fail, drop.unused.levels = FALSE, xlev = NULL, ...) 
{
  possible_newdata <- !missing(data) && is.data.frame(data) && identical(substitute(data), quote(newdata)) && (nr <- nrow(data)) > 0
  if (!missing(formula) && nargs() == 1 && is.list(formula) && !is.null(m <- formula$model)) 
    return(m)
  if (!missing(formula) && nargs() == 1 && is.list(formula) && all(c("terms", "call") %in% names(formula))) {
    fcall <- formula$call
    m <- match(c("formula", "data", "subset", "weights", "na.action"), names(fcall), 0)
    fcall <- fcall[c(1, m)]
    fcall[[1]] <- quote(stats::model.frame)
    env <- environment(formula$terms) %||% parent.frame()
    return(eval(fcall, env))
  }
  if (missing(formula)) {
    if (!missing(data) && inherits(data, "data.frame") && length(attr(data, "terms"))) 
      return(data)
    formula <- as.formula(data)
  }
  else if (missing(data) && inherits(formula, "data.frame")) {
    if (length(attr(formula, "terms"))) 
      return(formula)
    data <- formula
    formula <- as.formula(data)
  }
  else formula <- as.formula(formula)
  if (missing(na.action)) {
    if (!is.null(naa <- attr(data, "na.action")) && mode(naa) != "numeric") 
      na.action <- naa
    else if (!is.null(naa <- getOption("na.action"))) 
      na.action <- naa
  }
  if (missing(data)) 
    data <- environment(formula)
  else if (!is.data.frame(data) && !is.environment(data) && !is.null(attr(data, "class"))) 
    data <- as.data.frame(data)
  else if (is.array(data)) 
    stop("'data' must be a data.frame, not a matrix or an array")
  if (!is.data.frame(data) && !is.environment(data) && !is.list(data) && !is.null(data)) 
    stop("'data' must be a data.frame, environment, or list")
  if (!inherits(formula, "terms")) 
    formula <- terms(formula, data = data)
  env <- environment(formula)
  rownames <- .row_names_info(data, 0)
  vars <- attr(formula, "variables")
  predvars <- attr(formula, "predvars") %||% vars
  varnames <- vapply(vars, deparse2, " ")[-1]
  variables <- eval(predvars, data, env)
  resp <- attr(formula, "response")
  if (is.null(rownames) && resp > 0) {
    lhs <- variables[[resp]]
    rownames <- if (is.matrix(lhs)) 
      rownames(lhs)
    else names(lhs)
  }
  if (possible_newdata && length(variables)) {
    nr2 <- max(sapply(variables, NROW))
    if (nr2 != nr) 
      warning(sprintf(paste0(ngettext(nr, "'newdata' had %d row", "'newdata' had %d rows"), " ", ngettext(nr2, "but variable found had %d row", "but variables found have %d rows")), nr, nr2), call. = FALSE, domain = NA)
  }
  if (is.null(attr(formula, "predvars"))) {
    for (i in seq_along(varnames)) predvars[[i + 1]] <- makepredictcall(variables[[i]], vars[[i + 1]])
    attr(formula, "predvars") <- predvars
  }
  extras <- substitute(list(...))
  extranames <- names(extras[-1])
  extras <- eval(extras, data, env)
  subset <- eval(substitute(subset), data, env)
  data <- .External2(C_modelframe, formula, rownames, variables, varnames, extras, extranames, subset, na.action)
  if (length(xlev)) {
    for (nm in names(xlev)) if (!is.null(xl <- xlev[[nm]])) {
      xi <- data[[nm]]
      if (is.character(xi)) 
        xi <- as.factor(xi)
      if (!is.factor(xi) || is.null(nxl <- levels(xi))) 
        warning(gettextf("variable '%s' is not a factor", nm), domain = NA)
      else {
        ctr <- attr(xi, "contrasts")
        xi <- xi[, drop = TRUE]
        nxl <- levels(xi)
        if (any(m <- is.na(match(nxl, xl)))) 
          stop(sprintf(ngettext(length(m), "factor %s has new level %s", "factor %s has new levels %s"), nm, paste(nxl[m], collapse = ", ")), domain = NA)
        data[[nm]] <- factor(xi, levels = xl, exclude = NULL)
        if (!identical(attr(data[[nm]], "contrasts"), ctr)) 
          warning(gettextf("contrasts dropped from factor %s", nm), call. = FALSE, domain = NA)
      }
    }
  }
  else if (drop.unused.levels) {
    for (nm in names(data)) {
      x <- data[[nm]]
      if (is.factor(x) && length(unique(x[!is.na(x)])) < length(levels(x))) {
        ctr <- attr(x, "contrasts")
        data[[nm]] <- x[, drop = TRUE]
        if (!identical(attr(data[[nm]], "contrasts"), ctr)) 
          warning(gettextf("contrasts dropped from factor %s due to missing levels", nm), domain = NA, call. = FALSE)
      }
    }
  }
  attr(formula, "dataClasses") <- vapply(data, .MFclass, "")
  attr(data, "terms") <- formula
  data
}, function (formula, data = NULL, subset = NULL, na.action = na.fail, drop.unused.levels = FALSE, xlev = NULL, ...) 
{
  possible_newdata <- !missing(data) && is.data.frame(data) && identical(substitute(data), quote(newdata)) && (nr <- nrow(data)) > 0
  if (!missing(formula) && nargs() == 1 && is.list(formula) && !is.null(m <- formula$model)) 
    return(m)
  if (!missing(formula) && nargs() == 1 && is.list(formula) && all(c("terms", "call") %in% names(formula))) {
    fcall <- formula$call
    m <- match(c("formula", "data", "subset", "weights", "na.action"), names(fcall), 0)
    fcall <- fcall[c(1, m)]
    fcall[[1]] <- quote(stats::model.frame)
    env <- environment(formula$terms) %||% parent.frame()
    return(eval(fcall, env))
  }
  if (missing(formula)) {
    if (!missing(data) && inherits(data, "data.frame") && length(attr(data, "terms"))) 
      return(data)
    formula <- as.formula(data)
  }
  else if (missing(data) && inherits(formula, "data.frame")) {
    if (length(attr(formula, "terms"))) 
      return(formula)
    data <- formula
    formula <- as.formula(data)
  }
  else formula <- as.formula(formula)
  if (missing(na.action)) {
    if (!is.null(naa <- attr(data, "na.action")) && mode(naa) != "numeric") 
      na.action <- naa
    else if (!is.null(naa <- getOption("na.action"))) 
      na.action <- naa
  }
  if (missing(data)) 
    data <- environment(formula)
  else if (!is.data.frame(data) && !is.environment(data) && !is.null(attr(data, "class"))) 
    data <- as.data.frame(data)
  else if (is.array(data)) 
    stop("'data' must be a data.frame, not a matrix or an array")
  if (!is.data.frame(data) && !is.environment(data) && !is.list(data) && !is.null(data)) 
    stop("'data' must be a data.frame, environment, or list")
  if (!inherits(formula, "terms")) 
    formula <- terms(formula, data = data)
  env <- environment(formula)
  rownames <- .row_names_info(data, 0)
  vars <- attr(formula, "variables")
  predvars <- attr(formula, "predvars") %||% vars
  varnames <- vapply(vars, deparse2, " ")[-1]
  variables <- eval(predvars, data, env)
  resp <- attr(formula, "response")
  if (is.null(rownames) && resp > 0) {
    lhs <- variables[[resp]]
    rownames <- if (is.matrix(lhs)) 
      rownames(lhs)
    else names(lhs)
  }
  if (possible_newdata && length(variables)) {
    nr2 <- max(sapply(variables, NROW))
    if (nr2 != nr) 
      warning(sprintf(paste0(ngettext(nr, "'newdata' had %d row", "'newdata' had %d rows"), " ", ngettext(nr2, "but variable found had %d row", "but variables found have %d rows")), nr, nr2), call. = FALSE, domain = NA)
  }
  if (is.null(attr(formula, "predvars"))) {
    for (i in seq_along(varnames)) predvars[[i + 1]] <- makepredictcall(variables[[i]], vars[[i + 1]])
    attr(formula, "predvars") <- predvars
  }
  extras <- substitute(list(...))
  extranames <- names(extras[-1])
  extras <- eval(extras, data, env)
  subset <- eval(substitute(subset), data, env)
  data <- .External2(C_modelframe, formula, rownames, variables, varnames, extras, extranames, subset, na.action)
  if (length(xlev)) {
    for (nm in names(xlev)) if (!is.null(xl <- xlev[[nm]])) {
      xi <- data[[nm]]
      if (is.character(xi)) 
        xi <- as.factor(xi)
      if (!is.factor(xi) || is.null(nxl <- levels(xi))) 
        warning(gettextf("variable '%s' is not a factor", nm), domain = NA)
      else {
        ctr <- attr(xi, "contrasts")
        xi <- xi[, drop = TRUE]
        nxl <- levels(xi)
        if (any(m <- is.na(match(nxl, xl)))) 
          stop(sprintf(ngettext(length(m), "factor %s has new level %s", "factor %s has new levels %s"), nm, paste(nxl[m], collapse = ", ")), domain = NA)
        data[[nm]] <- factor(xi, levels = xl, exclude = NULL)
        if (!identical(attr(data[[nm]], "contrasts"), ctr)) 
          warning(gettextf("contrasts dropped from factor %s", nm), call. = FALSE, domain = NA)
      }
    }
  }
  else if (drop.unused.levels) {
    for (nm in names(data)) {
      x <- data[[nm]]
      if (is.factor(x) && length(unique(x[!is.na(x)])) < length(levels(x))) {
        ctr <- attr(x, "contrasts")
        data[[nm]] <- x[, drop = TRUE]
        if (!identical(attr(data[[nm]], "contrasts"), ctr)) 
          warning(gettextf("contrasts dropped from factor %s due to missing levels", nm), domain = NA, call. = FALSE)
      }
    }
  }
  attr(formula, "dataClasses") <- vapply(data, .MFclass, "")
  attr(data, "terms") <- formula
  data
}, function (formula, data = NULL, subset = NULL, na.action = na.fail, drop.unused.levels = FALSE, xlev = NULL, ...) 
{
  possible_newdata <- !missing(data) && is.data.frame(data) && identical(substitute(data), quote(newdata)) && (nr <- nrow(data)) > 0
  if (!missing(formula) && nargs() == 1 && is.list(formula) && !is.null(m <- formula$model)) 
    return(m)
  if (!missing(formula) && nargs() == 1 && is.list(formula) && all(c("terms", "call") %in% names(formula))) {
    fcall <- formula$call
    m <- match(c("formula", "data", "subset", "weights", "na.action"), names(fcall), 0)
    fcall <- fcall[c(1, m)]
    fcall[[1]] <- quote(stats::model.frame)
    env <- environment(formula$terms) %||% parent.frame()
    return(eval(fcall, env))
  }
  if (missing(formula)) {
    if (!missing(data) && inherits(data, "data.frame") && length(attr(data, "terms"))) 
      return(data)
    formula <- as.formula(data)
  }
  else if (missing(data) && inherits(formula, "data.frame")) {
    if (length(attr(formula, "terms"))) 
      return(formula)
    data <- formula
    formula <- as.formula(data)
  }
  else formula <- as.formula(formula)
  if (missing(na.action)) {
    if (!is.null(naa <- attr(data, "na.action")) && mode(naa) != "numeric") 
      na.action <- naa
    else if (!is.null(naa <- getOption("na.action"))) 
      na.action <- naa
  }
  if (missing(data)) 
    data <- environment(formula)
  else if (!is.data.frame(data) && !is.environment(data) && !is.null(attr(data, "class"))) 
    data <- as.data.frame(data)
  else if (is.array(data)) 
    stop("'data' must be a data.frame, not a matrix or an array")
  if (!is.data.frame(data) && !is.environment(data) && !is.list(data) && !is.null(data)) 
    stop("'data' must be a data.frame, environment, or list")
  if (!inherits(formula, "terms")) 
    formula <- terms(formula, data = data)
  env <- environment(formula)
  rownames <- .row_names_info(data, 0)
  vars <- attr(formula, "variables")
  predvars <- attr(formula, "predvars") %||% vars
  varnames <- vapply(vars, deparse2, " ")[-1]
  variables <- eval(predvars, data, env)
  resp <- attr(formula, "response")
  if (is.null(rownames) && resp > 0) {
    lhs <- variables[[resp]]
    rownames <- if (is.matrix(lhs)) 
      rownames(lhs)
    else names(lhs)
  }
  if (possible_newdata && length(variables)) {
    nr2 <- max(sapply(variables, NROW))
    if (nr2 != nr) 
      warning(sprintf(paste0(ngettext(nr, "'newdata' had %d row", "'newdata' had %d rows"), " ", ngettext(nr2, "but variable found had %d row", "but variables found have %d rows")), nr, nr2), call. = FALSE, domain = NA)
  }
  if (is.null(attr(formula, "predvars"))) {
    for (i in seq_along(varnames)) predvars[[i + 1]] <- makepredictcall(variables[[i]], vars[[i + 1]])
    attr(formula, "predvars") <- predvars
  }
  extras <- substitute(list(...))
  extranames <- names(extras[-1])
  extras <- eval(extras, data, env)
  subset <- eval(substitute(subset), data, env)
  data <- .External2(C_modelframe, formula, rownames, variables, varnames, extras, extranames, subset, na.action)
  if (length(xlev)) {
    for (nm in names(xlev)) if (!is.null(xl <- xlev[[nm]])) {
      xi <- data[[nm]]
      if (is.character(xi)) 
        xi <- as.factor(xi)
      if (!is.factor(xi) || is.null(nxl <- levels(xi))) 
        warning(gettextf("variable '%s' is not a factor", nm), domain = NA)
      else {
        ctr <- attr(xi, "contrasts")
        xi <- xi[, drop = TRUE]
        nxl <- levels(xi)
        if (any(m <- is.na(match(nxl, xl)))) 
          stop(sprintf(ngettext(length(m), "factor %s has new level %s", "factor %s has new levels %s"), nm, paste(nxl[m], collapse = ", ")), domain = NA)
        data[[nm]] <- factor(xi, levels = xl, exclude = NULL)
        if (!identical(attr(data[[nm]], "contrasts"), ctr)) 
          warning(gettextf("contrasts dropped from factor %s", nm), call. = FALSE, domain = NA)
      }
    }
  }
  else if (drop.unused.levels) {
    for (nm in names(data)) {
      x <- data[[nm]]
      if (is.factor(x) && length(unique(x[!is.na(x)])) < length(levels(x))) {
        ctr <- attr(x, "contrasts")
        data[[nm]] <- x[, drop = TRUE]
        if (!identical(attr(data[[nm]], "contrasts"), ctr)) 
          warning(gettextf("contrasts dropped from factor %s due to missing levels", nm), domain = NA, call. = FALSE)
      }
    }
  }
  attr(formula, "dataClasses") <- vapply(data, .MFclass, "")
  attr(data, "terms") <- formula
  data
})
c("package:stats", "registered S3 method for model.frame from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
model.matrix
list(`package:stats` = function (object, ...) 
  UseMethod("model.matrix"), function (object, ...) 
    UseMethod("model.matrix"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
model.matrix.default
list(`package:stats` = function (object, data = environment(object), contrasts.arg = NULL, xlev = NULL, ...) 
{
  t <- if (missing(data)) 
    terms(object)
  else terms(object, data = data)
  if (is.null(attr(data, "terms"))) 
    data <- model.frame(object, data, xlev = xlev)
  else {
    reorder <- match(vapply(attr(t, "variables"), deparse2, "")[-1], names(data))
    if (anyNA(reorder)) 
      stop("model frame and formula mismatch in model.matrix()")
    if (!identical(reorder, seq_len(ncol(data)))) 
      data <- data[, reorder, drop = FALSE]
  }
  int <- attr(t, "response")
  if (length(data)) {
    contr.funs <- as.character(getOption("contrasts"))
    namD <- names(data)
    for (i in namD) if (is.character(data[[i]])) 
      data[[i]] <- factor(data[[i]])
    isF <- vapply(data, function(x) is.factor(x) || is.logical(x), NA)
    isF[int] <- FALSE
    isOF <- vapply(data, is.ordered, NA)
    for (nn in namD[isF]) if (is.null(attr(data[[nn]], "contrasts"))) 
      contrasts(data[[nn]]) <- contr.funs[1 + isOF[nn]]
    if (!is.null(contrasts.arg)) {
      if (!is.list(contrasts.arg)) 
        warning("non-list contrasts argument ignored")
      else {
        if (is.null(namC <- names(contrasts.arg))) 
          stop("'contrasts.arg' argument must be named")
        for (nn in namC) {
          if (is.na(ni <- match(nn, namD))) 
            warning(gettextf("variable '%s' is absent, its contrast will be ignored", nn), domain = NA)
          else {
            ca <- contrasts.arg[[nn]]
            if (is.matrix(ca)) 
              contrasts(data[[ni]], ncol(ca)) <- ca
            else contrasts(data[[ni]]) <- contrasts.arg[[nn]]
          }
        }
      }
    }
  }
  else {
    isF <- FALSE
    data[["x"]] <- raw(nrow(data))
  }
  ans <- .External2(C_modelmatrix, t, data)
  if (any(isF)) 
    attr(ans, "contrasts") <- lapply(data[isF], attr, "contrasts")
  ans
}, function (object, data = environment(object), contrasts.arg = NULL, xlev = NULL, ...) 
{
  t <- if (missing(data)) 
    terms(object)
  else terms(object, data = data)
  if (is.null(attr(data, "terms"))) 
    data <- model.frame(object, data, xlev = xlev)
  else {
    reorder <- match(vapply(attr(t, "variables"), deparse2, "")[-1], names(data))
    if (anyNA(reorder)) 
      stop("model frame and formula mismatch in model.matrix()")
    if (!identical(reorder, seq_len(ncol(data)))) 
      data <- data[, reorder, drop = FALSE]
  }
  int <- attr(t, "response")
  if (length(data)) {
    contr.funs <- as.character(getOption("contrasts"))
    namD <- names(data)
    for (i in namD) if (is.character(data[[i]])) 
      data[[i]] <- factor(data[[i]])
    isF <- vapply(data, function(x) is.factor(x) || is.logical(x), NA)
    isF[int] <- FALSE
    isOF <- vapply(data, is.ordered, NA)
    for (nn in namD[isF]) if (is.null(attr(data[[nn]], "contrasts"))) 
      contrasts(data[[nn]]) <- contr.funs[1 + isOF[nn]]
    if (!is.null(contrasts.arg)) {
      if (!is.list(contrasts.arg)) 
        warning("non-list contrasts argument ignored")
      else {
        if (is.null(namC <- names(contrasts.arg))) 
          stop("'contrasts.arg' argument must be named")
        for (nn in namC) {
          if (is.na(ni <- match(nn, namD))) 
            warning(gettextf("variable '%s' is absent, its contrast will be ignored", nn), domain = NA)
          else {
            ca <- contrasts.arg[[nn]]
            if (is.matrix(ca)) 
              contrasts(data[[ni]], ncol(ca)) <- ca
            else contrasts(data[[ni]]) <- contrasts.arg[[nn]]
          }
        }
      }
    }
  }
  else {
    isF <- FALSE
    data[["x"]] <- raw(nrow(data))
  }
  ans <- .External2(C_modelmatrix, t, data)
  if (any(isF)) 
    attr(ans, "contrasts") <- lapply(data[isF], attr, "contrasts")
  ans
}, function (object, data = environment(object), contrasts.arg = NULL, xlev = NULL, ...) 
{
  t <- if (missing(data)) 
    terms(object)
  else terms(object, data = data)
  if (is.null(attr(data, "terms"))) 
    data <- model.frame(object, data, xlev = xlev)
  else {
    reorder <- match(vapply(attr(t, "variables"), deparse2, "")[-1], names(data))
    if (anyNA(reorder)) 
      stop("model frame and formula mismatch in model.matrix()")
    if (!identical(reorder, seq_len(ncol(data)))) 
      data <- data[, reorder, drop = FALSE]
  }
  int <- attr(t, "response")
  if (length(data)) {
    contr.funs <- as.character(getOption("contrasts"))
    namD <- names(data)
    for (i in namD) if (is.character(data[[i]])) 
      data[[i]] <- factor(data[[i]])
    isF <- vapply(data, function(x) is.factor(x) || is.logical(x), NA)
    isF[int] <- FALSE
    isOF <- vapply(data, is.ordered, NA)
    for (nn in namD[isF]) if (is.null(attr(data[[nn]], "contrasts"))) 
      contrasts(data[[nn]]) <- contr.funs[1 + isOF[nn]]
    if (!is.null(contrasts.arg)) {
      if (!is.list(contrasts.arg)) 
        warning("non-list contrasts argument ignored")
      else {
        if (is.null(namC <- names(contrasts.arg))) 
          stop("'contrasts.arg' argument must be named")
        for (nn in namC) {
          if (is.na(ni <- match(nn, namD))) 
            warning(gettextf("variable '%s' is absent, its contrast will be ignored", nn), domain = NA)
          else {
            ca <- contrasts.arg[[nn]]
            if (is.matrix(ca)) 
              contrasts(data[[ni]], ncol(ca)) <- ca
            else contrasts(data[[ni]]) <- contrasts.arg[[nn]]
          }
        }
      }
    }
  }
  else {
    isF <- FALSE
    data[["x"]] <- raw(nrow(data))
  }
  ans <- .External2(C_modelmatrix, t, data)
  if (any(isF)) 
    attr(ans, "contrasts") <- lapply(data[isF], attr, "contrasts")
  ans
})
c("package:stats", "registered S3 method for model.matrix from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
model.matrix.lm
list(`package:stats` = function (object, ...) 
{
  if (n_match <- match("x", names(object), 0)) 
    object[[n_match]]
  else {
    data <- model.frame(object, xlev = object$xlevels, ...)
    if (exists(".GenericCallEnv", inherits = FALSE)) 
      NextMethod("model.matrix", data = data, contrasts.arg = object$contrasts)
    else {
      dots <- list(...)
      dots$data <- dots$contrasts.arg <- NULL
      do.call("model.matrix.default", c(list(object = object, data = data, contrasts.arg = object$contrasts), dots))
    }
  }
}, function (object, ...) 
{
  if (n_match <- match("x", names(object), 0)) 
    object[[n_match]]
  else {
    data <- model.frame(object, xlev = object$xlevels, ...)
    if (exists(".GenericCallEnv", inherits = FALSE)) 
      NextMethod("model.matrix", data = data, contrasts.arg = object$contrasts)
    else {
      dots <- list(...)
      dots$data <- dots$contrasts.arg <- NULL
      do.call("model.matrix.default", c(list(object = object, data = data, contrasts.arg = object$contrasts), dots))
    }
  }
}, function (object, ...) 
{
  if (n_match <- match("x", names(object), 0)) 
    object[[n_match]]
  else {
    data <- model.frame(object, xlev = object$xlevels, ...)
    if (exists(".GenericCallEnv", inherits = FALSE)) 
      NextMethod("model.matrix", data = data, contrasts.arg = object$contrasts)
    else {
      dots <- list(...)
      dots$data <- dots$contrasts.arg <- NULL
      do.call("model.matrix.default", c(list(object = object, data = data, contrasts.arg = object$contrasts), dots))
    }
  }
})
c("package:stats", "registered S3 method for model.matrix from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
model.offset
list(`package:stats` = function (x) 
{
  offsets <- attr(attr(x, "terms"), "offset")
  if (length(offsets)) {
    ans <- .subset2(x, "(offset)") %||% 0
    for (i in offsets) ans <- ans + x[[i]]
  }
  else ans <- .subset2(x, "(offset)")
  if (!is.null(ans) && !is.numeric(ans)) 
    stop("'offset' must be numeric")
  ans
}, function (x) 
{
  offsets <- attr(attr(x, "terms"), "offset")
  if (length(offsets)) {
    ans <- .subset2(x, "(offset)") %||% 0
    for (i in offsets) ans <- ans + x[[i]]
  }
  else ans <- .subset2(x, "(offset)")
  if (!is.null(ans) && !is.numeric(ans)) 
    stop("'offset' must be numeric")
  ans
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
model.response
list(`package:stats` = function (data, type = "any") 
{
  if (attr(attr(data, "terms"), "response")) {
    if (is.list(data) || is.data.frame(data)) {
      v <- data[[1]]
      if (type == "numeric" && is.factor(v)) {
        warning("using type = \"numeric\" with a factor response will be ignored")
      }
      else if (type == "numeric" || type == "double") 
        storage.mode(v) <- "double"
      else if (type != "any") 
        stop("invalid response type")
      if (is.matrix(v) && ncol(v) == 1) 
        dim(v) <- NULL
      if (is.object(v) && inherits(v, "AsIs")) 
        v <- unclass(v)
      rows <- attr(data, "row.names")
      if (nrows <- length(rows)) {
        if (length(v) == nrows) 
          names(v) <- rows
        else if (length(dd <- dim(v)) == 2) 
          if (dd[1] == nrows && !length((dn <- dimnames(v))[[1]])) 
            dimnames(v) <- list(rows, dn[[2]])
      }
      return(v)
    }
    else stop("invalid 'data' argument")
  }
  else return(NULL)
}, function (data, type = "any") 
{
  if (attr(attr(data, "terms"), "response")) {
    if (is.list(data) || is.data.frame(data)) {
      v <- data[[1]]
      if (type == "numeric" && is.factor(v)) {
        warning("using type = \"numeric\" with a factor response will be ignored")
      }
      else if (type == "numeric" || type == "double") 
        storage.mode(v) <- "double"
      else if (type != "any") 
        stop("invalid response type")
      if (is.matrix(v) && ncol(v) == 1) 
        dim(v) <- NULL
      if (is.object(v) && inherits(v, "AsIs")) 
        v <- unclass(v)
      rows <- attr(data, "row.names")
      if (nrows <- length(rows)) {
        if (length(v) == nrows) 
          names(v) <- rows
        else if (length(dd <- dim(v)) == 2) 
          if (dd[1] == nrows && !length((dn <- dimnames(v))[[1]])) 
            dimnames(v) <- list(rows, dn[[2]])
      }
      return(v)
    }
    else stop("invalid 'data' argument")
  }
  else return(NULL)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
model.tables
list(`package:stats` = function (x, ...) 
  UseMethod("model.tables"), function (x, ...) 
    UseMethod("model.tables"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
model.weights
list(`package:stats` = function (x) 
  .subset2(x, "(weights)"), function (x) 
    .subset2(x, "(weights)"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
monthplot
list(`package:stats` = function (x, ...) 
  UseMethod("monthplot"), function (x, ...) 
    UseMethod("monthplot"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
mood.test
list(`package:stats` = function (x, ...) 
  UseMethod("mood.test"), function (x, ...) 
    UseMethod("mood.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
mvfft
list(`package:stats` = function (z, inverse = FALSE) 
  .Call(C_mvfft, z, inverse), function (z, inverse = FALSE) 
    .Call(C_mvfft, z, inverse))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
na.action
list(`package:stats` = function (object, ...) 
  UseMethod("na.action"), function (object, ...) 
    UseMethod("na.action"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
na.contiguous
list(`package:stats` = function (object, ...) 
  UseMethod("na.contiguous"), function (object, ...) 
    UseMethod("na.contiguous"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
na.exclude
list(`package:stats` = function (object, ...) 
  UseMethod("na.exclude"), function (object, ...) 
    UseMethod("na.exclude"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
na.fail
list(`package:stats` = function (object, ...) 
  UseMethod("na.fail"), function (object, ...) 
    UseMethod("na.fail"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
na.omit
list(`package:stats` = function (object, ...) 
  UseMethod("na.omit"), function (x) 
  {
    if (is.atomic(x)) 
      x[!is.na(x)]
    else x
  }, function (object, ...) 
    UseMethod("na.omit"))
c("package:stats", "namespace:cli", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
na.pass
list(`package:stats` = function (object, ...) 
  object, function (object, ...) 
    object)
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
napredict
list(`package:stats` = function (omit, x, ...) 
  UseMethod("napredict"), function (omit, x, ...) 
    UseMethod("napredict"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
naprint
list(`package:stats` = function (x, ...) 
  UseMethod("naprint"), function (x, ...) 
    UseMethod("naprint"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
naresid
list(`package:stats` = function (omit, x, ...) 
  UseMethod("naresid"), function (omit, x, ...) 
    UseMethod("naresid"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
nextn
list(`package:stats` = function (n, factors = c(2, 3, 5)) 
  .Call(C_nextn, n, factors), function (n, factors = c(2, 3, 5)) 
    .Call(C_nextn, n, factors))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
nlm
list(`package:stats` = function (f, p, ..., hessian = FALSE, typsize = rep(1, length(p)), fscale = 1, print.level = 0, ndigit = 12, gradtol = 1e-06, stepmax = max(1000 * sqrt(sum((p/typsize)^2)), 1000), steptol = 1e-06, iterlim = 100, check.analyticals = TRUE) 
{
  print.level <- as.integer(print.level)
  if (print.level < 0 || print.level > 2) 
    stop("'print.level' must be in {0,1,2}")
  msg <- (1 + c(8, 0, 16))[1 + print.level]
  if (!check.analyticals) 
    msg <- msg + (2 + 4)
  .External2(C_nlm, function(x) f(x, ...), p, hessian, typsize, fscale, msg, ndigit, gradtol, stepmax, steptol, iterlim)
}, function (f, p, ..., hessian = FALSE, typsize = rep(1, length(p)), fscale = 1, print.level = 0, ndigit = 12, gradtol = 1e-06, stepmax = max(1000 * sqrt(sum((p/typsize)^2)), 1000), steptol = 1e-06, iterlim = 100, check.analyticals = TRUE) 
{
  print.level <- as.integer(print.level)
  if (print.level < 0 || print.level > 2) 
    stop("'print.level' must be in {0,1,2}")
  msg <- (1 + c(8, 0, 16))[1 + print.level]
  if (!check.analyticals) 
    msg <- msg + (2 + 4)
  .External2(C_nlm, function(x) f(x, ...), p, hessian, typsize, fscale, msg, ndigit, gradtol, stepmax, steptol, iterlim)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
nlminb
list(`package:stats` = function (start, objective, gradient = NULL, hessian = NULL, ..., scale = 1, control = list(), lower = -Inf, upper = Inf) 
{
  par <- setNames(as.double(start), names(start))
  n <- length(par)
  iv <- integer(78 + 3 * n)
  v <- double(130 + (n * (n + 27))/2)
  .Call(C_port_ivset, 2, iv, v)
  if (length(control)) {
    nms <- names(control)
    if (!is.list(control) || is.null(nms)) 
      stop("'control' argument must be a named list")
    pos <- pmatch(nms, names(port_cpos))
    if (any(nap <- is.na(pos))) {
      warning(sprintf(ngettext(length(nap), "unrecognized control element named %s ignored", "unrecognized control elements named %s ignored"), paste(sQuote(nms[nap]), collapse = ", ")), domain = NA)
      pos <- pos[!nap]
      control <- control[!nap]
    }
    ivpars <- pos <= 4
    vpars <- !ivpars
    if (any(ivpars)) 
      iv[port_cpos[pos[ivpars]]] <- as.integer(unlist(control[ivpars]))
    if (any(vpars)) 
      v[port_cpos[pos[vpars]]] <- as.double(unlist(control[vpars]))
  }
  obj <- quote(objective(.par, ...))
  rho <- new.env(parent = environment())
  assign(".par", par, envir = rho)
  grad <- hess <- low <- upp <- NULL
  if (!is.null(gradient)) {
    grad <- quote(gradient(.par, ...))
    if (!is.null(hessian)) {
      if (is.logical(hessian)) 
        stop("logical 'hessian' argument not allowed.  See documentation.")
      hess <- quote(hessian(.par, ...))
    }
  }
  if (any(lower != -Inf) || any(upper != Inf)) {
    low <- rep_len(as.double(lower), length(par))
    upp <- rep_len(as.double(upper), length(par))
  }
  else low <- upp <- numeric()
  .Call(C_port_nlminb, obj, grad, hess, rho, low, upp, d = rep_len(as.double(scale), length(par)), iv, v)
  iv1 <- iv[1]
  list(par = get(".par", envir = rho), objective = v[10], convergence = (if (iv1 %in% 3:6) 0 else 1), iterations = iv[31], evaluations = c(`function` = iv[6], gradient = iv[30]), message = if (19 <= iv1 && iv1 <= 43) {
    if (any(B <- iv1 == port_cpos)) sprintf("'control' component '%s' = %g, is out of range", names(port_cpos)[B], v[iv1]) else sprintf("V[IV[1]] = V[%d] = %g is out of range (see PORT docu.)", iv1, v[iv1])
  } else port_msg(iv1))
}, function (start, objective, gradient = NULL, hessian = NULL, ..., scale = 1, control = list(), lower = -Inf, upper = Inf) 
{
  par <- setNames(as.double(start), names(start))
  n <- length(par)
  iv <- integer(78 + 3 * n)
  v <- double(130 + (n * (n + 27))/2)
  .Call(C_port_ivset, 2, iv, v)
  if (length(control)) {
    nms <- names(control)
    if (!is.list(control) || is.null(nms)) 
      stop("'control' argument must be a named list")
    pos <- pmatch(nms, names(port_cpos))
    if (any(nap <- is.na(pos))) {
      warning(sprintf(ngettext(length(nap), "unrecognized control element named %s ignored", "unrecognized control elements named %s ignored"), paste(sQuote(nms[nap]), collapse = ", ")), domain = NA)
      pos <- pos[!nap]
      control <- control[!nap]
    }
    ivpars <- pos <= 4
    vpars <- !ivpars
    if (any(ivpars)) 
      iv[port_cpos[pos[ivpars]]] <- as.integer(unlist(control[ivpars]))
    if (any(vpars)) 
      v[port_cpos[pos[vpars]]] <- as.double(unlist(control[vpars]))
  }
  obj <- quote(objective(.par, ...))
  rho <- new.env(parent = environment())
  assign(".par", par, envir = rho)
  grad <- hess <- low <- upp <- NULL
  if (!is.null(gradient)) {
    grad <- quote(gradient(.par, ...))
    if (!is.null(hessian)) {
      if (is.logical(hessian)) 
        stop("logical 'hessian' argument not allowed.  See documentation.")
      hess <- quote(hessian(.par, ...))
    }
  }
  if (any(lower != -Inf) || any(upper != Inf)) {
    low <- rep_len(as.double(lower), length(par))
    upp <- rep_len(as.double(upper), length(par))
  }
  else low <- upp <- numeric()
  .Call(C_port_nlminb, obj, grad, hess, rho, low, upp, d = rep_len(as.double(scale), length(par)), iv, v)
  iv1 <- iv[1]
  list(par = get(".par", envir = rho), objective = v[10], convergence = (if (iv1 %in% 3:6) 0 else 1), iterations = iv[31], evaluations = c(`function` = iv[6], gradient = iv[30]), message = if (19 <= iv1 && iv1 <= 43) {
    if (any(B <- iv1 == port_cpos)) sprintf("'control' component '%s' = %g, is out of range", names(port_cpos)[B], v[iv1]) else sprintf("V[IV[1]] = V[%d] = %g is out of range (see PORT docu.)", iv1, v[iv1])
  } else port_msg(iv1))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
nls
list(`package:stats` = function (formula, data = parent.frame(), start, control = nls.control(), algorithm = c("default", "plinear", "port"), trace = FALSE, subset, weights, na.action, model = FALSE, lower = -Inf, upper = Inf, ...) 
{
  formula <- as.formula(formula)
  algorithm <- match.arg(algorithm)
  if (!is.list(data) && !is.environment(data)) 
    stop("'data' must be a list or an environment")
  mf <- cl <- match.call()
  varNames <- all.vars(formula)
  if (length(formula) == 2) {
    formula[[3]] <- formula[[2]]
    formula[[2]] <- 0
  }
  form2 <- formula
  form2[[2]] <- 0
  varNamesRHS <- all.vars(form2)
  mWeights <- missing(weights)
  pnames <- if (missing(start)) {
    if (!is.null(attr(data, "parameters"))) {
      names(attr(data, "parameters"))
    }
    else {
      cll <- formula[[length(formula)]]
      if (is.symbol(cll)) {
        cll <- substitute(S + 0, list(S = cll))
      }
      fn <- as.character(cll[[1]])
      if (is.null(func <- tryCatch(get(fn), error = function(e) NULL))) 
        func <- get(fn, envir = parent.frame())
      if (!is.null(pn <- attr(func, "pnames"))) 
        as.character(as.list(match.call(func, call = cll))[-1][pn])
    }
  }
  else names(start)
  env <- environment(formula) %||% parent.frame()
  if (length(pnames)) 
    varNames <- varNames[is.na(match(varNames, pnames))]
  lenVar <- function(var) tryCatch(length(eval(as.name(var), data, env)), error = function(e) -1)
  if (length(varNames)) {
    n <- vapply(varNames, lenVar, 0)
    if (any(not.there <- n == -1)) {
      nnn <- names(n[not.there])
      if (missing(start)) {
        if (algorithm == "plinear") 
          stop("no starting values specified")
        warning("No starting values specified for some parameters.\n", "Initializing ", paste(sQuote(nnn), collapse = ", "), " to '1.'.\n", "Consider specifying 'start' or using a selfStart model", domain = NA)
        start <- setNames(as.list(rep_len(1, length(nnn))), nnn)
        varNames <- varNames[i <- is.na(match(varNames, nnn))]
        n <- n[i]
      }
      else stop(gettextf("parameters without starting value in 'data': %s", paste(nnn, collapse = ", ")), domain = NA)
    }
  }
  else {
    if (length(pnames) && any((np <- sapply(pnames, lenVar)) == -1)) {
      message(sprintf(ngettext(sum(np == -1), "fitting parameter %s without any variables", "fitting parameters %s without any variables"), paste(sQuote(pnames[np == -1]), collapse = ", ")), domain = NA)
      n <- integer()
    }
    else stop("no parameters to fit")
  }
  respLength <- length(eval(formula[[2]], data, env))
  if (length(n) > 0) {
    varIndex <- n%%respLength == 0
    if (is.list(data) && diff(range(n[names(n) %in% names(data)])) > 0) {
      mf <- data
      if (!missing(subset)) 
        warning("argument 'subset' will be ignored")
      if (!missing(na.action)) 
        warning("argument 'na.action' will be ignored")
      if (missing(start)) 
        start <- getInitial(formula, data = mf, control = control, trace = trace)
      startEnv <- new.env(hash = FALSE, parent = environment(formula))
      for (i in names(start)) startEnv[[i]] <- start[[i]]
      rhs <- eval(formula[[3]], data, startEnv)
      n <- NROW(rhs)
      wts <- if (mWeights) 
        rep_len(1, n)
      else eval(substitute(weights), data, environment(formula))
    }
    else {
      vNms <- varNames[varIndex]
      if (any(nEQ <- vNms != make.names(vNms))) 
        vNms[nEQ] <- paste0("`", vNms[nEQ], "`")
      mf$formula <- as.formula(paste("~", paste(vNms, collapse = "+")), env = environment(formula))
      mf$start <- mf$control <- mf$algorithm <- mf$trace <- mf$model <- NULL
      mf$lower <- mf$upper <- NULL
      mf[[1]] <- quote(stats::model.frame)
      mf <- eval.parent(mf)
      n <- nrow(mf)
      mf <- as.list(mf)
      wts <- if (!mWeights) 
        model.weights(mf)
      else rep_len(1, n)
    }
    if (any(wts < 0 | is.na(wts))) 
      stop("missing or negative weights not allowed")
  }
  else {
    varIndex <- logical()
    mf <- list(0)
    wts <- numeric()
  }
  if (missing(start)) 
    start <- getInitial(formula, data = mf, control = control, trace = trace)
  for (var in varNames[!varIndex]) mf[[var]] <- eval(as.name(var), data, env)
  varNamesRHS <- varNamesRHS[varNamesRHS %in% varNames[varIndex]]
  ctrl <- nls.control()
  if (!missing(control)) {
    control <- as.list(control)
    ctrl[names(control)] <- control
  }
  scOff <- ctrl$scaleOffset
  nDcntr <- ctrl$nDcentral
  m <- switch(algorithm, plinear = nlsModel.plinear(formula, mf, start, wts, scaleOffset = scOff, nDcentral = nDcntr), port = nlsModel(formula, mf, start, wts, upper, scaleOffset = scOff, nDcentral = nDcntr), default = nlsModel(formula, mf, start, wts, scaleOffset = scOff, nDcentral = nDcntr))
  if (algorithm != "port") {
    if (!identical(lower, -Inf) || !identical(upper, +Inf)) {
      warning("upper and lower bounds ignored unless algorithm = \"port\"")
      cl$lower <- NULL
      cl$upper <- NULL
    }
    convInfo <- .Call(C_nls_iter, m, ctrl, trace)
    nls.out <- list(m = m, convInfo = convInfo, data = substitute(data), call = cl)
  }
  else {
    pfit <- nls_port_fit(m, start, lower, upper, control, trace, give.v = TRUE)
    iv <- pfit[["iv"]]
    msg.nls <- port_msg(iv[1])
    conv <- (iv[1] %in% 3:6)
    if (!conv) {
      msg <- paste("Convergence failure:", msg.nls)
      if (ctrl$warnOnly) 
        warning(msg)
      else stop(msg)
    }
    v. <- port_get_named_v(pfit[["v"]])
    cInfo <- list(isConv = conv, finIter = iv[31], finTol = v.[["NREDUC"]], nEval = c(`function` = iv[6], gradient = iv[30]), stopCode = iv[1], stopMessage = msg.nls)
    cl$lower <- lower
    cl$upper <- upper
    nls.out <- list(m = m, data = substitute(data), call = cl, convInfo = cInfo, convergence = as.integer(!conv), message = msg.nls)
  }
  nls.out$call$algorithm <- algorithm
  nls.out$call$control <- ctrl
  nls.out$call$trace <- trace
  nls.out$na.action <- attr(mf, "na.action")
  nls.out$dataClasses <- attr(attr(mf, "terms"), "dataClasses")[varNamesRHS]
  if (model) 
    nls.out$model <- mf
  if (!mWeights) 
    nls.out$weights <- wts
  nls.out$control <- control
  class(nls.out) <- "nls"
  nls.out
}, function (formula, data = parent.frame(), start, control = nls.control(), algorithm = c("default", "plinear", "port"), trace = FALSE, subset, weights, na.action, model = FALSE, lower = -Inf, upper = Inf, ...) 
{
  formula <- as.formula(formula)
  algorithm <- match.arg(algorithm)
  if (!is.list(data) && !is.environment(data)) 
    stop("'data' must be a list or an environment")
  mf <- cl <- match.call()
  varNames <- all.vars(formula)
  if (length(formula) == 2) {
    formula[[3]] <- formula[[2]]
    formula[[2]] <- 0
  }
  form2 <- formula
  form2[[2]] <- 0
  varNamesRHS <- all.vars(form2)
  mWeights <- missing(weights)
  pnames <- if (missing(start)) {
    if (!is.null(attr(data, "parameters"))) {
      names(attr(data, "parameters"))
    }
    else {
      cll <- formula[[length(formula)]]
      if (is.symbol(cll)) {
        cll <- substitute(S + 0, list(S = cll))
      }
      fn <- as.character(cll[[1]])
      if (is.null(func <- tryCatch(get(fn), error = function(e) NULL))) 
        func <- get(fn, envir = parent.frame())
      if (!is.null(pn <- attr(func, "pnames"))) 
        as.character(as.list(match.call(func, call = cll))[-1][pn])
    }
  }
  else names(start)
  env <- environment(formula) %||% parent.frame()
  if (length(pnames)) 
    varNames <- varNames[is.na(match(varNames, pnames))]
  lenVar <- function(var) tryCatch(length(eval(as.name(var), data, env)), error = function(e) -1)
  if (length(varNames)) {
    n <- vapply(varNames, lenVar, 0)
    if (any(not.there <- n == -1)) {
      nnn <- names(n[not.there])
      if (missing(start)) {
        if (algorithm == "plinear") 
          stop("no starting values specified")
        warning("No starting values specified for some parameters.\n", "Initializing ", paste(sQuote(nnn), collapse = ", "), " to '1.'.\n", "Consider specifying 'start' or using a selfStart model", domain = NA)
        start <- setNames(as.list(rep_len(1, length(nnn))), nnn)
        varNames <- varNames[i <- is.na(match(varNames, nnn))]
        n <- n[i]
      }
      else stop(gettextf("parameters without starting value in 'data': %s", paste(nnn, collapse = ", ")), domain = NA)
    }
  }
  else {
    if (length(pnames) && any((np <- sapply(pnames, lenVar)) == -1)) {
      message(sprintf(ngettext(sum(np == -1), "fitting parameter %s without any variables", "fitting parameters %s without any variables"), paste(sQuote(pnames[np == -1]), collapse = ", ")), domain = NA)
      n <- integer()
    }
    else stop("no parameters to fit")
  }
  respLength <- length(eval(formula[[2]], data, env))
  if (length(n) > 0) {
    varIndex <- n%%respLength == 0
    if (is.list(data) && diff(range(n[names(n) %in% names(data)])) > 0) {
      mf <- data
      if (!missing(subset)) 
        warning("argument 'subset' will be ignored")
      if (!missing(na.action)) 
        warning("argument 'na.action' will be ignored")
      if (missing(start)) 
        start <- getInitial(formula, data = mf, control = control, trace = trace)
      startEnv <- new.env(hash = FALSE, parent = environment(formula))
      for (i in names(start)) startEnv[[i]] <- start[[i]]
      rhs <- eval(formula[[3]], data, startEnv)
      n <- NROW(rhs)
      wts <- if (mWeights) 
        rep_len(1, n)
      else eval(substitute(weights), data, environment(formula))
    }
    else {
      vNms <- varNames[varIndex]
      if (any(nEQ <- vNms != make.names(vNms))) 
        vNms[nEQ] <- paste0("`", vNms[nEQ], "`")
      mf$formula <- as.formula(paste("~", paste(vNms, collapse = "+")), env = environment(formula))
      mf$start <- mf$control <- mf$algorithm <- mf$trace <- mf$model <- NULL
      mf$lower <- mf$upper <- NULL
      mf[[1]] <- quote(stats::model.frame)
      mf <- eval.parent(mf)
      n <- nrow(mf)
      mf <- as.list(mf)
      wts <- if (!mWeights) 
        model.weights(mf)
      else rep_len(1, n)
    }
    if (any(wts < 0 | is.na(wts))) 
      stop("missing or negative weights not allowed")
  }
  else {
    varIndex <- logical()
    mf <- list(0)
    wts <- numeric()
  }
  if (missing(start)) 
    start <- getInitial(formula, data = mf, control = control, trace = trace)
  for (var in varNames[!varIndex]) mf[[var]] <- eval(as.name(var), data, env)
  varNamesRHS <- varNamesRHS[varNamesRHS %in% varNames[varIndex]]
  ctrl <- nls.control()
  if (!missing(control)) {
    control <- as.list(control)
    ctrl[names(control)] <- control
  }
  scOff <- ctrl$scaleOffset
  nDcntr <- ctrl$nDcentral
  m <- switch(algorithm, plinear = nlsModel.plinear(formula, mf, start, wts, scaleOffset = scOff, nDcentral = nDcntr), port = nlsModel(formula, mf, start, wts, upper, scaleOffset = scOff, nDcentral = nDcntr), default = nlsModel(formula, mf, start, wts, scaleOffset = scOff, nDcentral = nDcntr))
  if (algorithm != "port") {
    if (!identical(lower, -Inf) || !identical(upper, +Inf)) {
      warning("upper and lower bounds ignored unless algorithm = \"port\"")
      cl$lower <- NULL
      cl$upper <- NULL
    }
    convInfo <- .Call(C_nls_iter, m, ctrl, trace)
    nls.out <- list(m = m, convInfo = convInfo, data = substitute(data), call = cl)
  }
  else {
    pfit <- nls_port_fit(m, start, lower, upper, control, trace, give.v = TRUE)
    iv <- pfit[["iv"]]
    msg.nls <- port_msg(iv[1])
    conv <- (iv[1] %in% 3:6)
    if (!conv) {
      msg <- paste("Convergence failure:", msg.nls)
      if (ctrl$warnOnly) 
        warning(msg)
      else stop(msg)
    }
    v. <- port_get_named_v(pfit[["v"]])
    cInfo <- list(isConv = conv, finIter = iv[31], finTol = v.[["NREDUC"]], nEval = c(`function` = iv[6], gradient = iv[30]), stopCode = iv[1], stopMessage = msg.nls)
    cl$lower <- lower
    cl$upper <- upper
    nls.out <- list(m = m, data = substitute(data), call = cl, convInfo = cInfo, convergence = as.integer(!conv), message = msg.nls)
  }
  nls.out$call$algorithm <- algorithm
  nls.out$call$control <- ctrl
  nls.out$call$trace <- trace
  nls.out$na.action <- attr(mf, "na.action")
  nls.out$dataClasses <- attr(attr(mf, "terms"), "dataClasses")[varNamesRHS]
  if (model) 
    nls.out$model <- mf
  if (!mWeights) 
    nls.out$weights <- wts
  nls.out$control <- control
  class(nls.out) <- "nls"
  nls.out
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
nls.control
list(`package:stats` = function (maxiter = 50, tol = 1e-05, minFactor = 1/1024, printEval = FALSE, warnOnly = FALSE, scaleOffset = 0, nDcentral = FALSE) 
{
  stopifnot(is.numeric(tol), length(tol) == 1, tol > 0, is.numeric(minFactor), length(minFactor) == 1, is.numeric(scaleOffset), length(scaleOffset) == 1, is.logical(nDcentral), length(nDcentral) == 1, !is.na(nDcentral))
  list(maxiter = maxiter, tol = tol, minFactor = minFactor, printEval = printEval, warnOnly = warnOnly, scaleOffset = scaleOffset, nDcentral = nDcentral)
}, function (maxiter = 50, tol = 1e-05, minFactor = 1/1024, printEval = FALSE, warnOnly = FALSE, scaleOffset = 0, nDcentral = FALSE) 
{
  stopifnot(is.numeric(tol), length(tol) == 1, tol > 0, is.numeric(minFactor), length(minFactor) == 1, is.numeric(scaleOffset), length(scaleOffset) == 1, is.logical(nDcentral), length(nDcentral) == 1, !is.na(nDcentral))
  list(maxiter = maxiter, tol = tol, minFactor = minFactor, printEval = printEval, warnOnly = warnOnly, scaleOffset = scaleOffset, nDcentral = nDcentral)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
NLSstAsymptotic
list(`package:stats` = function (xy) 
  UseMethod("NLSstAsymptotic"), function (xy) 
    UseMethod("NLSstAsymptotic"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
NLSstClosestX
list(`package:stats` = function (xy, yval) 
  UseMethod("NLSstClosestX"), function (xy, yval) 
    UseMethod("NLSstClosestX"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
NLSstLfAsymptote
list(`package:stats` = function (xy) 
  UseMethod("NLSstLfAsymptote"), function (xy) 
    UseMethod("NLSstLfAsymptote"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
NLSstRtAsymptote
list(`package:stats` = function (xy) 
  UseMethod("NLSstRtAsymptote"), function (xy) 
    UseMethod("NLSstRtAsymptote"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
nobs
list(`package:stats` = function (object, ...) 
  UseMethod("nobs"), function (object, ...) 
    UseMethod("nobs"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
numericDeriv
list(`package:stats` = function (expr, theta, rho = parent.frame(), dir = 1, eps = .Machine$double.eps^(1/if (central) 3 else 2), central = FALSE) 
{
  dir <- rep_len(dir, length(theta))
  stopifnot(is.finite(eps), eps > 0)
  val <- .Call(C_numeric_deriv, expr, theta, rho, dir, eps, central)
  if (!is.null(d <- dim(val))) {
    if (d[length(d)] == 1) 
      d <- d[-length(d)]
    if (length(d) > 1) 
      dim(attr(val, "gradient")) <- c(d, dim(attr(val, "gradient"))[-1])
  }
  val
}, function (expr, theta, rho = parent.frame(), dir = 1, eps = .Machine$double.eps^(1/if (central) 3 else 2), central = FALSE) 
{
  dir <- rep_len(dir, length(theta))
  stopifnot(is.finite(eps), eps > 0)
  val <- .Call(C_numeric_deriv, expr, theta, rho, dir, eps, central)
  if (!is.null(d <- dim(val))) {
    if (d[length(d)] == 1) 
      d <- d[-length(d)]
    if (length(d) > 1) 
      dim(attr(val, "gradient")) <- c(d, dim(attr(val, "gradient"))[-1])
  }
  val
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
offset
list(`package:stats` = function (object) 
  object, function (object) 
    object)
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
oneway.test
list(`package:stats` = function (formula, data, subset, na.action, var.equal = FALSE) 
{
  if (missing(formula) || (length(formula) != 3)) 
    stop("'formula' missing or incorrect")
  dp <- as.character(formula)
  if (length(dp) != 3) 
    stop("a two-sided formula is required")
  DNAME <- paste(dp[[2]], "and", dp[[3]])
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$var.equal <- NULL
  m[[1]] <- quote(stats::model.frame)
  mf <- eval(m, parent.frame())
  response <- attr(attr(mf, "terms"), "response")
  y <- mf[[response]]
  if (length(mf[-response]) > 1) 
    g <- factor(do.call("interaction", mf[-response]))
  else g <- factor(mf[[-response]])
  k <- nlevels(g)
  if (k < 2) 
    stop("not enough groups")
  n.i <- tapply(y, g, length)
  if (any(n.i < 2)) 
    stop("not enough observations")
  m.i <- tapply(y, g, mean)
  v.i <- tapply(y, g, var)
  w.i <- n.i/v.i
  sum.w.i <- sum(w.i)
  tmp <- sum((1 - w.i/sum.w.i)^2/(n.i - 1))/(k^2 - 1)
  METHOD <- "One-way analysis of means"
  if (var.equal) {
    n <- sum(n.i)
    STATISTIC <- ((sum(n.i * (m.i - mean(y))^2)/(k - 1))/(sum((n.i - 1) * v.i)/(n - k)))
    PARAMETER <- c(k - 1, n - k)
    PVAL <- pf(STATISTIC, k - 1, n - k, lower.tail = FALSE)
  }
  else {
    m <- sum(w.i * m.i)/sum.w.i
    STATISTIC <- sum(w.i * (m.i - m)^2)/((k - 1) * (1 + 2 * (k - 2) * tmp))
    PARAMETER <- c(k - 1, 1/(3 * tmp))
    PVAL <- pf(STATISTIC, k - 1, 1/(3 * tmp), lower.tail = FALSE)
    METHOD <- paste(METHOD, "(not assuming equal variances)")
  }
  names(STATISTIC) <- "F"
  names(PARAMETER) <- c("num df", "denom df")
  RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME)
  class(RVAL) <- "htest"
  RVAL
}, function (formula, data, subset, na.action, var.equal = FALSE) 
{
  if (missing(formula) || (length(formula) != 3)) 
    stop("'formula' missing or incorrect")
  dp <- as.character(formula)
  if (length(dp) != 3) 
    stop("a two-sided formula is required")
  DNAME <- paste(dp[[2]], "and", dp[[3]])
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$var.equal <- NULL
  m[[1]] <- quote(stats::model.frame)
  mf <- eval(m, parent.frame())
  response <- attr(attr(mf, "terms"), "response")
  y <- mf[[response]]
  if (length(mf[-response]) > 1) 
    g <- factor(do.call("interaction", mf[-response]))
  else g <- factor(mf[[-response]])
  k <- nlevels(g)
  if (k < 2) 
    stop("not enough groups")
  n.i <- tapply(y, g, length)
  if (any(n.i < 2)) 
    stop("not enough observations")
  m.i <- tapply(y, g, mean)
  v.i <- tapply(y, g, var)
  w.i <- n.i/v.i
  sum.w.i <- sum(w.i)
  tmp <- sum((1 - w.i/sum.w.i)^2/(n.i - 1))/(k^2 - 1)
  METHOD <- "One-way analysis of means"
  if (var.equal) {
    n <- sum(n.i)
    STATISTIC <- ((sum(n.i * (m.i - mean(y))^2)/(k - 1))/(sum((n.i - 1) * v.i)/(n - k)))
    PARAMETER <- c(k - 1, n - k)
    PVAL <- pf(STATISTIC, k - 1, n - k, lower.tail = FALSE)
  }
  else {
    m <- sum(w.i * m.i)/sum.w.i
    STATISTIC <- sum(w.i * (m.i - m)^2)/((k - 1) * (1 + 2 * (k - 2) * tmp))
    PARAMETER <- c(k - 1, 1/(3 * tmp))
    PVAL <- pf(STATISTIC, k - 1, 1/(3 * tmp), lower.tail = FALSE)
    METHOD <- paste(METHOD, "(not assuming equal variances)")
  }
  names(STATISTIC) <- "F"
  names(PARAMETER) <- c("num df", "denom df")
  RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME)
  class(RVAL) <- "htest"
  RVAL
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
optim
list(`package:stats` = function (par, fn, gr = NULL, ..., method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), lower = -Inf, upper = Inf, control = list(), hessian = FALSE) 
{
  fn1 <- function(par) fn(par, ...)
  gr1 <- if (!is.null(gr)) 
    function(par) gr(par, ...)
  method <- match.arg(method)
  if ((any(lower > -Inf) || any(upper < Inf)) && !any(method == c("L-BFGS-B", "Brent"))) {
    warning("bounds can only be used with method L-BFGS-B (or Brent)")
    method <- "L-BFGS-B"
  }
  npar <- length(par)
  con <- list(trace = 0, fnscale = 1, parscale = rep.int(1, npar), ndeps = rep.int(0.001, npar), maxit = 100, abstol = -Inf, reltol = sqrt(.Machine$double.eps), alpha = 1, beta = 0.5, gamma = 2, REPORT = 10, warn.1d.NelderMead = TRUE, type = 1, lmm = 5, factr = 1e+07, pgtol = 0, tmax = 10, temp = 10)
  nmsC <- names(con)
  if (method == "Nelder-Mead") 
    con$maxit <- 500
  if (method == "SANN") {
    con$maxit <- 10000
    con$REPORT <- 100
  }
  con[(namc <- names(control))] <- control
  if (length(noNms <- namc[!namc %in% nmsC])) 
    warning("unknown names in control: ", paste(noNms, collapse = ", "))
  if (con$trace < 0) 
    warning("read the documentation for 'trace' more carefully")
  else if (method == "SANN" && con$trace && as.integer(con$REPORT) == 0) 
    stop("'trace != 0' needs 'REPORT >= 1'")
  if (method == "L-BFGS-B" && any(!is.na(match(c("reltol", "abstol"), namc)))) 
    warning("method L-BFGS-B uses 'factr' (and 'pgtol') instead of 'reltol' and 'abstol'")
  if (npar == 1 && method == "Nelder-Mead" && isTRUE(con$warn.1d.NelderMead)) 
    warning("one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly")
  if (npar > 1 && method == "Brent") 
    stop("method = \"Brent\" is only available for one-dimensional optimization")
  lower <- as.double(rep_len(lower, npar))
  upper <- as.double(rep_len(upper, npar))
  res <- if (method == "Brent") {
    if (any(!is.finite(c(upper, lower)))) 
      stop("'lower' and 'upper' must be finite values")
    res <- optimize(function(par) fn(par, ...)/con$fnscale, lower = lower, upper = upper, tol = con$reltol)
    names(res)[names(res) == c("minimum", "objective")] <- c("par", "value")
    res$value <- res$value * con$fnscale
    c(res, list(counts = c(`function` = NA, gradient = NA), convergence = 0, message = NULL))
  }
  else .External2(C_optim, par, fn1, gr1, method, con, lower, upper)
  if (hessian) 
    res$hessian <- .External2(C_optimhess, res$par, fn1, gr1, con)
  res
}, function (par, fn, gr = NULL, ..., method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), lower = -Inf, upper = Inf, control = list(), hessian = FALSE) 
{
  fn1 <- function(par) fn(par, ...)
  gr1 <- if (!is.null(gr)) 
    function(par) gr(par, ...)
  method <- match.arg(method)
  if ((any(lower > -Inf) || any(upper < Inf)) && !any(method == c("L-BFGS-B", "Brent"))) {
    warning("bounds can only be used with method L-BFGS-B (or Brent)")
    method <- "L-BFGS-B"
  }
  npar <- length(par)
  con <- list(trace = 0, fnscale = 1, parscale = rep.int(1, npar), ndeps = rep.int(0.001, npar), maxit = 100, abstol = -Inf, reltol = sqrt(.Machine$double.eps), alpha = 1, beta = 0.5, gamma = 2, REPORT = 10, warn.1d.NelderMead = TRUE, type = 1, lmm = 5, factr = 1e+07, pgtol = 0, tmax = 10, temp = 10)
  nmsC <- names(con)
  if (method == "Nelder-Mead") 
    con$maxit <- 500
  if (method == "SANN") {
    con$maxit <- 10000
    con$REPORT <- 100
  }
  con[(namc <- names(control))] <- control
  if (length(noNms <- namc[!namc %in% nmsC])) 
    warning("unknown names in control: ", paste(noNms, collapse = ", "))
  if (con$trace < 0) 
    warning("read the documentation for 'trace' more carefully")
  else if (method == "SANN" && con$trace && as.integer(con$REPORT) == 0) 
    stop("'trace != 0' needs 'REPORT >= 1'")
  if (method == "L-BFGS-B" && any(!is.na(match(c("reltol", "abstol"), namc)))) 
    warning("method L-BFGS-B uses 'factr' (and 'pgtol') instead of 'reltol' and 'abstol'")
  if (npar == 1 && method == "Nelder-Mead" && isTRUE(con$warn.1d.NelderMead)) 
    warning("one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly")
  if (npar > 1 && method == "Brent") 
    stop("method = \"Brent\" is only available for one-dimensional optimization")
  lower <- as.double(rep_len(lower, npar))
  upper <- as.double(rep_len(upper, npar))
  res <- if (method == "Brent") {
    if (any(!is.finite(c(upper, lower)))) 
      stop("'lower' and 'upper' must be finite values")
    res <- optimize(function(par) fn(par, ...)/con$fnscale, lower = lower, upper = upper, tol = con$reltol)
    names(res)[names(res) == c("minimum", "objective")] <- c("par", "value")
    res$value <- res$value * con$fnscale
    c(res, list(counts = c(`function` = NA, gradient = NA), convergence = 0, message = NULL))
  }
  else .External2(C_optim, par, fn1, gr1, method, con, lower, upper)
  if (hessian) 
    res$hessian <- .External2(C_optimhess, res$par, fn1, gr1, con)
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
optimHess
list(`package:stats` = function (par, fn, gr = NULL, ..., control = list()) 
{
  fn1 <- function(par) fn(par, ...)
  gr1 <- if (!is.null(gr)) 
    function(par) gr(par, ...)
  npar <- length(par)
  con <- list(fnscale = 1, parscale = rep.int(1, npar), ndeps = rep.int(0.001, npar))
  con[(names(control))] <- control
  .External2(C_optimhess, par, fn1, gr1, con)
}, function (par, fn, gr = NULL, ..., control = list()) 
{
  fn1 <- function(par) fn(par, ...)
  gr1 <- if (!is.null(gr)) 
    function(par) gr(par, ...)
  npar <- length(par)
  con <- list(fnscale = 1, parscale = rep.int(1, npar), ndeps = rep.int(0.001, npar))
  con[(names(control))] <- control
  .External2(C_optimhess, par, fn1, gr1, con)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
optimise
list(`package:stats` = function (f, interval, ..., lower = min(interval), upper = max(interval), maximum = FALSE, tol = .Machine$double.eps^0.25) 
{
  if (maximum) {
    val <- .External2(C_do_fmin, function(arg) -f(arg, ...), lower, upper, tol)
    list(maximum = val, objective = f(val, ...))
  }
  else {
    val <- .External2(C_do_fmin, function(arg) f(arg, ...), lower, upper, tol)
    list(minimum = val, objective = f(val, ...))
  }
}, function (f, interval, ..., lower = min(interval), upper = max(interval), maximum = FALSE, tol = .Machine$double.eps^0.25) 
{
  if (maximum) {
    val <- .External2(C_do_fmin, function(arg) -f(arg, ...), lower, upper, tol)
    list(maximum = val, objective = f(val, ...))
  }
  else {
    val <- .External2(C_do_fmin, function(arg) f(arg, ...), lower, upper, tol)
    list(minimum = val, objective = f(val, ...))
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
optimize
list(`package:stats` = function (f, interval, ..., lower = min(interval), upper = max(interval), maximum = FALSE, tol = .Machine$double.eps^0.25) 
{
  if (maximum) {
    val <- .External2(C_do_fmin, function(arg) -f(arg, ...), lower, upper, tol)
    list(maximum = val, objective = f(val, ...))
  }
  else {
    val <- .External2(C_do_fmin, function(arg) f(arg, ...), lower, upper, tol)
    list(minimum = val, objective = f(val, ...))
  }
}, function (f, interval, ..., lower = min(interval), upper = max(interval), maximum = FALSE, tol = .Machine$double.eps^0.25) 
{
  if (maximum) {
    val <- .External2(C_do_fmin, function(arg) -f(arg, ...), lower, upper, tol)
    list(maximum = val, objective = f(val, ...))
  }
  else {
    val <- .External2(C_do_fmin, function(arg) f(arg, ...), lower, upper, tol)
    list(minimum = val, objective = f(val, ...))
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
order.dendrogram
list(`package:stats` = function (x) 
{
  if (!inherits(x, "dendrogram")) 
    stop("'order.dendrogram' requires a dendrogram")
  if (is.list(x)) 
    unlist(x)
  else as.vector(x)
}, function (x) 
{
  if (!inherits(x, "dendrogram")) 
    stop("'order.dendrogram' requires a dendrogram")
  if (is.list(x)) 
    unlist(x)
  else as.vector(x)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
p.adjust
list(`package:stats` = function (p, method = p.adjust.methods, n = length(p)) 
{
  method <- match.arg(method)
  if (method == "fdr") 
    method <- "BH"
  nm <- names(p)
  p <- as.numeric(p)
  p0 <- setNames(p, nm)
  if (all(nna <- !is.na(p))) 
    nna <- TRUE
  else p <- p[nna]
  lp <- length(p)
  stopifnot(n >= lp)
  if (n <= 1) 
    return(p0)
  if (n == 2 && method == "hommel") 
    method <- "hochberg"
  p0[nna] <- switch(method, bonferroni = pmin(1, n * p), holm = {
    i <- seq_len(lp)
    o <- order(p)
    ro <- order(o)
    pmin(1, cummax((n + 1 - i) * p[o]))[ro]
  }, hommel = {
    if (n > lp) p <- c(p, rep.int(1, n - lp))
    i <- seq_len(n)
    o <- order(p)
    p <- p[o]
    ro <- order(o)
    q <- pa <- rep.int(min(n * p/i), n)
    for (j in (n - 1):2) {
      ij <- seq_len(n - j + 1)
      i2 <- (n - j + 2):n
      q1 <- min(j * p[i2]/(2:j))
      q[ij] <- pmin(j * p[ij], q1)
      q[i2] <- q[n - j + 1]
      pa <- pmax(pa, q)
    }
    pmax(pa, p)[if (lp < n) ro[1:lp] else ro]
  }, hochberg = {
    i <- lp:1
    o <- order(p, decreasing = TRUE)
    ro <- order(o)
    pmin(1, cummin((n + 1 - i) * p[o]))[ro]
  }, BH = {
    i <- lp:1
    o <- order(p, decreasing = TRUE)
    ro <- order(o)
    pmin(1, cummin(n/i * p[o]))[ro]
  }, BY = {
    i <- lp:1
    o <- order(p, decreasing = TRUE)
    ro <- order(o)
    q <- sum(1/(1:n))
    pmin(1, cummin(q * n/i * p[o]))[ro]
  }, none = p)
  p0
}, function (p, method = p.adjust.methods, n = length(p)) 
{
  method <- match.arg(method)
  if (method == "fdr") 
    method <- "BH"
  nm <- names(p)
  p <- as.numeric(p)
  p0 <- setNames(p, nm)
  if (all(nna <- !is.na(p))) 
    nna <- TRUE
  else p <- p[nna]
  lp <- length(p)
  stopifnot(n >= lp)
  if (n <= 1) 
    return(p0)
  if (n == 2 && method == "hommel") 
    method <- "hochberg"
  p0[nna] <- switch(method, bonferroni = pmin(1, n * p), holm = {
    i <- seq_len(lp)
    o <- order(p)
    ro <- order(o)
    pmin(1, cummax((n + 1 - i) * p[o]))[ro]
  }, hommel = {
    if (n > lp) p <- c(p, rep.int(1, n - lp))
    i <- seq_len(n)
    o <- order(p)
    p <- p[o]
    ro <- order(o)
    q <- pa <- rep.int(min(n * p/i), n)
    for (j in (n - 1):2) {
      ij <- seq_len(n - j + 1)
      i2 <- (n - j + 2):n
      q1 <- min(j * p[i2]/(2:j))
      q[ij] <- pmin(j * p[ij], q1)
      q[i2] <- q[n - j + 1]
      pa <- pmax(pa, q)
    }
    pmax(pa, p)[if (lp < n) ro[1:lp] else ro]
  }, hochberg = {
    i <- lp:1
    o <- order(p, decreasing = TRUE)
    ro <- order(o)
    pmin(1, cummin((n + 1 - i) * p[o]))[ro]
  }, BH = {
    i <- lp:1
    o <- order(p, decreasing = TRUE)
    ro <- order(o)
    pmin(1, cummin(n/i * p[o]))[ro]
  }, BY = {
    i <- lp:1
    o <- order(p, decreasing = TRUE)
    ro <- order(o)
    q <- sum(1/(1:n))
    pmin(1, cummin(q * n/i * p[o]))[ro]
  }, none = p)
  p0
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
p.adjust.methods
list(`package:stats` = c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"), c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pacf
list(`package:stats` = function (x, lag.max, plot, na.action, ...) 
  UseMethod("pacf"), function (x, lag.max, plot, na.action, ...) 
    UseMethod("pacf"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
Pair
list(`package:stats` = function (x, y) 
{
  pp <- cbind(x, y)
  class(pp) <- "Pair"
  pp
}, function (x, y) 
{
  pp <- cbind(x, y)
  class(pp) <- "Pair"
  pp
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pairwise.prop.test
list(`package:stats` = function (x, n, p.adjust.method = p.adjust.methods, ...) 
{
  p.adjust.method <- match.arg(p.adjust.method)
  METHOD <- "Pairwise comparison of proportions"
  DNAME <- deparse1(substitute(x))
  if (is.matrix(x)) {
    if (ncol(x) != 2) 
      stop("'x' must have 2 columns")
    n <- rowSums(x)
    x <- x[, 1]
  }
  else {
    DNAME <- paste(DNAME, "out of", deparse1(substitute(n)))
    if (length(x) != length(n)) 
      stop("'x' and 'n' must have the same length")
  }
  OK <- complete.cases(x, n)
  x <- x[OK]
  n <- n[OK]
  if (length(x) < 2) 
    stop("too few groups")
  compare.levels <- function(i, j) {
    prop.test(x[c(i, j)], n[c(i, j)], ...)$p.value
  }
  level.names <- names(x) %||% seq_along(x)
  PVAL <- pairwise.table(compare.levels, level.names, p.adjust.method)
  ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, p.adjust.method = p.adjust.method)
  class(ans) <- "pairwise.htest"
  ans
}, function (x, n, p.adjust.method = p.adjust.methods, ...) 
{
  p.adjust.method <- match.arg(p.adjust.method)
  METHOD <- "Pairwise comparison of proportions"
  DNAME <- deparse1(substitute(x))
  if (is.matrix(x)) {
    if (ncol(x) != 2) 
      stop("'x' must have 2 columns")
    n <- rowSums(x)
    x <- x[, 1]
  }
  else {
    DNAME <- paste(DNAME, "out of", deparse1(substitute(n)))
    if (length(x) != length(n)) 
      stop("'x' and 'n' must have the same length")
  }
  OK <- complete.cases(x, n)
  x <- x[OK]
  n <- n[OK]
  if (length(x) < 2) 
    stop("too few groups")
  compare.levels <- function(i, j) {
    prop.test(x[c(i, j)], n[c(i, j)], ...)$p.value
  }
  level.names <- names(x) %||% seq_along(x)
  PVAL <- pairwise.table(compare.levels, level.names, p.adjust.method)
  ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, p.adjust.method = p.adjust.method)
  class(ans) <- "pairwise.htest"
  ans
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pairwise.t.test
list(`package:stats` = function (x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, paired = FALSE, alternative = c("two.sided", "less", "greater"), ...) 
{
  if (paired && pool.sd) 
    stop("pooling of SD is incompatible with paired tests")
  DNAME <- paste(deparse1(substitute(x)), "and", deparse1(substitute(g)))
  g <- factor(g)
  p.adjust.method <- match.arg(p.adjust.method)
  alternative <- match.arg(alternative)
  if (pool.sd) {
    METHOD <- "t tests with pooled SD"
    xbar <- tapply(x, g, mean, na.rm = TRUE)
    s <- tapply(x, g, sd, na.rm = TRUE)
    n <- tapply(!is.na(x), g, sum)
    degf <- n - 1
    total.degf <- sum(degf)
    pooled.sd <- sqrt(sum(s^2 * degf)/total.degf)
    compare.levels <- function(i, j) {
      dif <- xbar[i] - xbar[j]
      se.dif <- pooled.sd * sqrt(1/n[i] + 1/n[j])
      t.val <- dif/se.dif
      if (alternative == "two.sided") 
        2 * pt(-abs(t.val), total.degf)
      else pt(t.val, total.degf, lower.tail = (alternative == "less"))
    }
  }
  else {
    METHOD <- if (paired) 
      "paired t tests"
    else "t tests with non-pooled SD"
    compare.levels <- function(i, j) {
      xi <- x[as.integer(g) == i]
      xj <- x[as.integer(g) == j]
      t.test(xi, xj, paired = paired, alternative = alternative, ...)$p.value
    }
  }
  PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
  ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, p.adjust.method = p.adjust.method)
  class(ans) <- "pairwise.htest"
  ans
}, function (x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, paired = FALSE, alternative = c("two.sided", "less", "greater"), ...) 
{
  if (paired && pool.sd) 
    stop("pooling of SD is incompatible with paired tests")
  DNAME <- paste(deparse1(substitute(x)), "and", deparse1(substitute(g)))
  g <- factor(g)
  p.adjust.method <- match.arg(p.adjust.method)
  alternative <- match.arg(alternative)
  if (pool.sd) {
    METHOD <- "t tests with pooled SD"
    xbar <- tapply(x, g, mean, na.rm = TRUE)
    s <- tapply(x, g, sd, na.rm = TRUE)
    n <- tapply(!is.na(x), g, sum)
    degf <- n - 1
    total.degf <- sum(degf)
    pooled.sd <- sqrt(sum(s^2 * degf)/total.degf)
    compare.levels <- function(i, j) {
      dif <- xbar[i] - xbar[j]
      se.dif <- pooled.sd * sqrt(1/n[i] + 1/n[j])
      t.val <- dif/se.dif
      if (alternative == "two.sided") 
        2 * pt(-abs(t.val), total.degf)
      else pt(t.val, total.degf, lower.tail = (alternative == "less"))
    }
  }
  else {
    METHOD <- if (paired) 
      "paired t tests"
    else "t tests with non-pooled SD"
    compare.levels <- function(i, j) {
      xi <- x[as.integer(g) == i]
      xj <- x[as.integer(g) == j]
      t.test(xi, xj, paired = paired, alternative = alternative, ...)$p.value
    }
  }
  PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
  ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, p.adjust.method = p.adjust.method)
  class(ans) <- "pairwise.htest"
  ans
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pairwise.table
list(`package:stats` = function (compare.levels, level.names, p.adjust.method) 
{
  ix <- setNames(seq_along(level.names), level.names)
  pp <- outer(ix[-1], ix[-length(ix)], function(ivec, jvec) vapply(seq_along(ivec), function(k) {
    i <- ivec[k]
    j <- jvec[k]
    if (i > j) 
      compare.levels(i, j)
    else NA
  }, 0.05))
  il.tri <- lower.tri(pp, TRUE)
  pp[il.tri] <- p.adjust(pp[il.tri], p.adjust.method)
  pp
}, function (compare.levels, level.names, p.adjust.method) 
{
  ix <- setNames(seq_along(level.names), level.names)
  pp <- outer(ix[-1], ix[-length(ix)], function(ivec, jvec) vapply(seq_along(ivec), function(k) {
    i <- ivec[k]
    j <- jvec[k]
    if (i > j) 
      compare.levels(i, j)
    else NA
  }, 0.05))
  il.tri <- lower.tri(pp, TRUE)
  pp[il.tri] <- p.adjust(pp[il.tri], p.adjust.method)
  pp
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pairwise.wilcox.test
list(`package:stats` = function (x, g, p.adjust.method = p.adjust.methods, paired = FALSE, ...) 
{
  p.adjust.method <- match.arg(p.adjust.method)
  DNAME <- paste(deparse1(substitute(x)), "and", deparse1(substitute(g)))
  g <- factor(g)
  METHOD <- NULL
  compare.levels <- function(i, j) {
    xi <- x[as.integer(g) == i]
    xj <- x[as.integer(g) == j]
    if (is.null(METHOD)) {
      wt <- wilcox.test(xi, xj, paired = paired, ...)
      METHOD <<- wt$method
      wt$p.value
    }
    else wilcox.test(xi, xj, paired = paired, ...)$p.value
  }
  PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
  ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, p.adjust.method = p.adjust.method)
  class(ans) <- "pairwise.htest"
  ans
}, function (x, g, p.adjust.method = p.adjust.methods, paired = FALSE, ...) 
{
  p.adjust.method <- match.arg(p.adjust.method)
  DNAME <- paste(deparse1(substitute(x)), "and", deparse1(substitute(g)))
  g <- factor(g)
  METHOD <- NULL
  compare.levels <- function(i, j) {
    xi <- x[as.integer(g) == i]
    xj <- x[as.integer(g) == j]
    if (is.null(METHOD)) {
      wt <- wilcox.test(xi, xj, paired = paired, ...)
      METHOD <<- wt$method
      wt$p.value
    }
    else wilcox.test(xi, xj, paired = paired, ...)$p.value
  }
  PVAL <- pairwise.table(compare.levels, levels(g), p.adjust.method)
  ans <- list(method = METHOD, data.name = DNAME, p.value = PVAL, p.adjust.method = p.adjust.method)
  class(ans) <- "pairwise.htest"
  ans
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pbeta
list(`package:stats` = function (q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_pbeta, q, shape1, shape2, lower.tail, log.p)
  else .Call(C_pnbeta, q, shape1, shape2, ncp, lower.tail, log.p)
}, function (q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_pbeta, q, shape1, shape2, lower.tail, log.p)
  else .Call(C_pnbeta, q, shape1, shape2, ncp, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pbinom
list(`package:stats` = function (q, size, prob, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_pbinom, q, size, prob, lower.tail, log.p), function (q, size, prob, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_pbinom, q, size, prob, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pbirthday
list(`package:stats` = function (n, classes = 365, coincident = 2) 
{
  k <- coincident
  c <- classes
  if (k < 2) 
    return(1)
  if (k == 2) 
    return(1 - prod((c:(c - n + 1))/rep(c, n)))
  if (k > n) 
    return(0)
  if (n > c * (k - 1)) 
    return(1)
  LHS <- n * exp(-n/(c * k))/(1 - n/(c * (k + 1)))^(1/k)
  lxx <- k * log(LHS) - (k - 1) * log(c) - lgamma(k + 1)
  -expm1(-exp(lxx))
}, function (n, classes = 365, coincident = 2) 
{
  k <- coincident
  c <- classes
  if (k < 2) 
    return(1)
  if (k == 2) 
    return(1 - prod((c:(c - n + 1))/rep(c, n)))
  if (k > n) 
    return(0)
  if (n > c * (k - 1)) 
    return(1)
  LHS <- n * exp(-n/(c * k))/(1 - n/(c * (k + 1)))^(1/k)
  lxx <- k * log(LHS) - (k - 1) * log(c) - lgamma(k + 1)
  -expm1(-exp(lxx))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pcauchy
list(`package:stats` = function (q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_pcauchy, q, location, scale, lower.tail, log.p), function (q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_pcauchy, q, location, scale, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pchisq
list(`package:stats` = function (q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_pchisq, q, df, lower.tail, log.p)
  else .Call(C_pnchisq, q, df, ncp, lower.tail, log.p)
}, function (q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_pchisq, q, df, lower.tail, log.p)
  else .Call(C_pnchisq, q, df, ncp, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pexp
list(`package:stats` = function (q, rate = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_pexp, q, 1/rate, lower.tail, log.p), function (q, rate = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_pexp, q, 1/rate, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pf
list(`package:stats` = function (q, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_pf, q, df1, df2, lower.tail, log.p)
  else .Call(C_pnf, q, df1, df2, ncp, lower.tail, log.p)
}, function (q, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_pf, q, df1, df2, lower.tail, log.p)
  else .Call(C_pnf, q, df1, df2, ncp, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pgamma
list(`package:stats` = function (q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) 
{
  if (!missing(rate) && !missing(scale)) {
    if (abs(rate * scale - 1) < 1e-15) 
      warning("specify 'rate' or 'scale' but not both")
    else stop("specify 'rate' or 'scale' but not both")
  }
  .Call(C_pgamma, q, shape, scale, lower.tail, log.p)
}, function (q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) 
{
  if (!missing(rate) && !missing(scale)) {
    if (abs(rate * scale - 1) < 1e-15) 
      warning("specify 'rate' or 'scale' but not both")
    else stop("specify 'rate' or 'scale' but not both")
  }
  .Call(C_pgamma, q, shape, scale, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pgeom
list(`package:stats` = function (q, prob, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_pgeom, q, prob, lower.tail, log.p), function (q, prob, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_pgeom, q, prob, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
phyper
list(`package:stats` = function (q, m, n, k, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_phyper, q, m, n, k, lower.tail, log.p), function (q, m, n, k, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_phyper, q, m, n, k, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
plclust
list(`package:stats` = function (tree, hang = 0.1, unit = FALSE, level = FALSE, hmin = 0, square = TRUE, labels = NULL, plot. = TRUE, axes = TRUE, frame.plot = FALSE, ann = TRUE, main = "", sub = NULL, xlab = NULL, ylab = "Height") 
{
  .Defunct("plot")
}, function (tree, hang = 0.1, unit = FALSE, level = FALSE, hmin = 0, square = TRUE, labels = NULL, plot. = TRUE, axes = TRUE, frame.plot = FALSE, ann = TRUE, main = "", sub = NULL, xlab = NULL, ylab = "Height") 
{
  .Defunct("plot")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
plnorm
list(`package:stats` = function (q, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_plnorm, q, meanlog, sdlog, lower.tail, log.p), function (q, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_plnorm, q, meanlog, sdlog, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
plogis
list(`package:stats` = function (q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_plogis, q, location, scale, lower.tail, log.p), function (q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_plogis, q, location, scale, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
plot.ecdf
list(`package:stats` = function (x, ..., ylab = "Fn(x)", verticals = FALSE, col.01line = "gray70", pch = 19) 
{
  plot.stepfun(x, ..., ylab = ylab, verticals = verticals, pch = pch)
  abline(h = c(0, 1), col = col.01line, lty = 2)
}, function (x, ..., ylab = "Fn(x)", verticals = FALSE, col.01line = "gray70", pch = 19) 
{
  plot.stepfun(x, ..., ylab = ylab, verticals = verticals, pch = pch)
  abline(h = c(0, 1), col = col.01line, lty = 2)
}, function (x, ..., ylab = "Fn(x)", verticals = FALSE, col.01line = "gray70", pch = 19) 
{
  plot.stepfun(x, ..., ylab = ylab, verticals = verticals, pch = pch)
  abline(h = c(0, 1), col = col.01line, lty = 2)
})
c("package:stats", "registered S3 method for plot from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
plot.spec.coherency
list(`package:stats` = function (x, ci = 0.95, xlab = "frequency", ylab = "squared coherency", ylim = c(0, 1), type = "l", main = NULL, ci.col = "blue", ci.lty = 3, ...) 
{
  nser <- NCOL(x$spec)
  gg <- 2/x$df
  se <- sqrt(gg/2)
  z <- -qnorm((1 - ci)/2)
  if (is.null(main)) 
    main <- paste(paste("Series:", x$series), "Squared Coherency", sep = " --  ")
  if (nser == 2) {
    plot(x$freq, x$coh, type = type, xlab = xlab, ylab = ylab, ylim = ylim, ...)
    coh <- pmin(0.99999, sqrt(x$coh))
    lines(x$freq, (tanh(atanh(coh) + z * se))^2, lty = ci.lty, col = ci.col)
    lines(x$freq, (pmax(0, tanh(atanh(coh) - z * se)))^2, lty = ci.lty, col = ci.col)
    title(main)
  }
  else {
    dev.hold()
    on.exit(dev.flush())
    opar <- par(mfrow = c(nser - 1, nser - 1), mar = c(1.5, 1.5, 0.5, 0.5), oma = c(4, 4, 6, 4))
    on.exit(par(opar), add = TRUE)
    plot.new()
    for (j in 2:nser) for (i in 1:(j - 1)) {
      par(mfg = c(j - 1, i, nser - 1, nser - 1))
      ind <- i + (j - 1) * (j - 2)/2
      plot(x$freq, x$coh[, ind], type = type, ylim = ylim, axes = FALSE, xlab = "", ylab = "", ...)
      coh <- pmin(0.99999, sqrt(x$coh[, ind]))
      lines(x$freq, (tanh(atanh(coh) + z * se))^2, lty = ci.lty, col = ci.col)
      lines(x$freq, (pmax(0, tanh(atanh(coh) - z * se)))^2, lty = ci.lty, col = ci.col)
      box()
      if (i == 1) {
        axis(2, xpd = NA)
        title(ylab = x$snames[j], xpd = NA)
      }
      if (j == nser) {
        axis(1, xpd = NA)
        title(xlab = x$snames[i], xpd = NA)
      }
      mtext(main, 3, 3, TRUE, 0.5, cex = par("cex.main"), font = par("font.main"))
    }
  }
  invisible()
}, function (x, ci = 0.95, xlab = "frequency", ylab = "squared coherency", ylim = c(0, 1), type = "l", main = NULL, ci.col = "blue", ci.lty = 3, ...) 
{
  nser <- NCOL(x$spec)
  gg <- 2/x$df
  se <- sqrt(gg/2)
  z <- -qnorm((1 - ci)/2)
  if (is.null(main)) 
    main <- paste(paste("Series:", x$series), "Squared Coherency", sep = " --  ")
  if (nser == 2) {
    plot(x$freq, x$coh, type = type, xlab = xlab, ylab = ylab, ylim = ylim, ...)
    coh <- pmin(0.99999, sqrt(x$coh))
    lines(x$freq, (tanh(atanh(coh) + z * se))^2, lty = ci.lty, col = ci.col)
    lines(x$freq, (pmax(0, tanh(atanh(coh) - z * se)))^2, lty = ci.lty, col = ci.col)
    title(main)
  }
  else {
    dev.hold()
    on.exit(dev.flush())
    opar <- par(mfrow = c(nser - 1, nser - 1), mar = c(1.5, 1.5, 0.5, 0.5), oma = c(4, 4, 6, 4))
    on.exit(par(opar), add = TRUE)
    plot.new()
    for (j in 2:nser) for (i in 1:(j - 1)) {
      par(mfg = c(j - 1, i, nser - 1, nser - 1))
      ind <- i + (j - 1) * (j - 2)/2
      plot(x$freq, x$coh[, ind], type = type, ylim = ylim, axes = FALSE, xlab = "", ylab = "", ...)
      coh <- pmin(0.99999, sqrt(x$coh[, ind]))
      lines(x$freq, (tanh(atanh(coh) + z * se))^2, lty = ci.lty, col = ci.col)
      lines(x$freq, (pmax(0, tanh(atanh(coh) - z * se)))^2, lty = ci.lty, col = ci.col)
      box()
      if (i == 1) {
        axis(2, xpd = NA)
        title(ylab = x$snames[j], xpd = NA)
      }
      if (j == nser) {
        axis(1, xpd = NA)
        title(xlab = x$snames[i], xpd = NA)
      }
      mtext(main, 3, 3, TRUE, 0.5, cex = par("cex.main"), font = par("font.main"))
    }
  }
  invisible()
}, function (x, ci = 0.95, xlab = "frequency", ylab = "squared coherency", ylim = c(0, 1), type = "l", main = NULL, ci.col = "blue", ci.lty = 3, ...) 
{
  nser <- NCOL(x$spec)
  gg <- 2/x$df
  se <- sqrt(gg/2)
  z <- -qnorm((1 - ci)/2)
  if (is.null(main)) 
    main <- paste(paste("Series:", x$series), "Squared Coherency", sep = " --  ")
  if (nser == 2) {
    plot(x$freq, x$coh, type = type, xlab = xlab, ylab = ylab, ylim = ylim, ...)
    coh <- pmin(0.99999, sqrt(x$coh))
    lines(x$freq, (tanh(atanh(coh) + z * se))^2, lty = ci.lty, col = ci.col)
    lines(x$freq, (pmax(0, tanh(atanh(coh) - z * se)))^2, lty = ci.lty, col = ci.col)
    title(main)
  }
  else {
    dev.hold()
    on.exit(dev.flush())
    opar <- par(mfrow = c(nser - 1, nser - 1), mar = c(1.5, 1.5, 0.5, 0.5), oma = c(4, 4, 6, 4))
    on.exit(par(opar), add = TRUE)
    plot.new()
    for (j in 2:nser) for (i in 1:(j - 1)) {
      par(mfg = c(j - 1, i, nser - 1, nser - 1))
      ind <- i + (j - 1) * (j - 2)/2
      plot(x$freq, x$coh[, ind], type = type, ylim = ylim, axes = FALSE, xlab = "", ylab = "", ...)
      coh <- pmin(0.99999, sqrt(x$coh[, ind]))
      lines(x$freq, (tanh(atanh(coh) + z * se))^2, lty = ci.lty, col = ci.col)
      lines(x$freq, (pmax(0, tanh(atanh(coh) - z * se)))^2, lty = ci.lty, col = ci.col)
      box()
      if (i == 1) {
        axis(2, xpd = NA)
        title(ylab = x$snames[j], xpd = NA)
      }
      if (j == nser) {
        axis(1, xpd = NA)
        title(xlab = x$snames[i], xpd = NA)
      }
      mtext(main, 3, 3, TRUE, 0.5, cex = par("cex.main"), font = par("font.main"))
    }
  }
  invisible()
})
c("package:stats", "registered S3 method for plot from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
plot.spec.phase
list(`package:stats` = function (x, ci = 0.95, xlab = "frequency", ylab = "phase", ylim = c(-pi, pi), type = "l", main = NULL, ci.col = "blue", ci.lty = 3, ...) 
{
  nser <- NCOL(x$spec)
  gg <- 2/x$df
  if (is.null(main)) 
    main <- paste(paste("Series:", x$series), "Phase spectrum", sep = "  -- ")
  if (nser == 2) {
    plot(x$freq, x$phase, type = type, xlab = xlab, ylab = ylab, ylim = ylim, ...)
    coh <- sqrt(x$coh)
    cl <- asin(pmin(0.9999, qt(ci, 2/gg - 2) * sqrt(gg * (coh^{
      -2
    } - 1)/(2 * (1 - gg)))))
    lines(x$freq, x$phase + cl, lty = ci.lty, col = ci.col)
    lines(x$freq, x$phase - cl, lty = ci.lty, col = ci.col)
    title(main)
  }
  else {
    dev.hold()
    on.exit(dev.flush())
    opar <- par(mfrow = c(nser - 1, nser - 1), mar = c(1.5, 1.5, 0.5, 0.5), oma = c(4, 4, 6, 4))
    on.exit(par(opar), add = TRUE)
    plot.new()
    for (j in 2:nser) for (i in 1:(j - 1)) {
      par(mfg = c(j - 1, i, nser - 1, nser - 1))
      ind <- i + (j - 1) * (j - 2)/2
      plot(x$freq, x$phase[, ind], type = type, ylim = ylim, axes = FALSE, xlab = "", ylab = "", ...)
      coh <- sqrt(x$coh[, ind])
      cl <- asin(pmin(0.9999, qt(ci, 2/gg - 2) * sqrt(gg * (coh^{
        -2
      } - 1)/(2 * (1 - gg)))))
      lines(x$freq, x$phase[, ind] + cl, lty = ci.lty, col = ci.col)
      lines(x$freq, x$phase[, ind] - cl, lty = ci.lty, col = ci.col)
      box()
      if (i == 1) {
        axis(2, xpd = NA)
        title(ylab = x$snames[j], xpd = NA)
      }
      if (j == nser) {
        axis(1, xpd = NA)
        title(xlab = x$snames[i], xpd = NA)
      }
      mtext(main, 3, 3, TRUE, 0.5, cex = par("cex.main"), font = par("font.main"))
    }
  }
  invisible()
}, function (x, ci = 0.95, xlab = "frequency", ylab = "phase", ylim = c(-pi, pi), type = "l", main = NULL, ci.col = "blue", ci.lty = 3, ...) 
{
  nser <- NCOL(x$spec)
  gg <- 2/x$df
  if (is.null(main)) 
    main <- paste(paste("Series:", x$series), "Phase spectrum", sep = "  -- ")
  if (nser == 2) {
    plot(x$freq, x$phase, type = type, xlab = xlab, ylab = ylab, ylim = ylim, ...)
    coh <- sqrt(x$coh)
    cl <- asin(pmin(0.9999, qt(ci, 2/gg - 2) * sqrt(gg * (coh^{
      -2
    } - 1)/(2 * (1 - gg)))))
    lines(x$freq, x$phase + cl, lty = ci.lty, col = ci.col)
    lines(x$freq, x$phase - cl, lty = ci.lty, col = ci.col)
    title(main)
  }
  else {
    dev.hold()
    on.exit(dev.flush())
    opar <- par(mfrow = c(nser - 1, nser - 1), mar = c(1.5, 1.5, 0.5, 0.5), oma = c(4, 4, 6, 4))
    on.exit(par(opar), add = TRUE)
    plot.new()
    for (j in 2:nser) for (i in 1:(j - 1)) {
      par(mfg = c(j - 1, i, nser - 1, nser - 1))
      ind <- i + (j - 1) * (j - 2)/2
      plot(x$freq, x$phase[, ind], type = type, ylim = ylim, axes = FALSE, xlab = "", ylab = "", ...)
      coh <- sqrt(x$coh[, ind])
      cl <- asin(pmin(0.9999, qt(ci, 2/gg - 2) * sqrt(gg * (coh^{
        -2
      } - 1)/(2 * (1 - gg)))))
      lines(x$freq, x$phase[, ind] + cl, lty = ci.lty, col = ci.col)
      lines(x$freq, x$phase[, ind] - cl, lty = ci.lty, col = ci.col)
      box()
      if (i == 1) {
        axis(2, xpd = NA)
        title(ylab = x$snames[j], xpd = NA)
      }
      if (j == nser) {
        axis(1, xpd = NA)
        title(xlab = x$snames[i], xpd = NA)
      }
      mtext(main, 3, 3, TRUE, 0.5, cex = par("cex.main"), font = par("font.main"))
    }
  }
  invisible()
}, function (x, ci = 0.95, xlab = "frequency", ylab = "phase", ylim = c(-pi, pi), type = "l", main = NULL, ci.col = "blue", ci.lty = 3, ...) 
{
  nser <- NCOL(x$spec)
  gg <- 2/x$df
  if (is.null(main)) 
    main <- paste(paste("Series:", x$series), "Phase spectrum", sep = "  -- ")
  if (nser == 2) {
    plot(x$freq, x$phase, type = type, xlab = xlab, ylab = ylab, ylim = ylim, ...)
    coh <- sqrt(x$coh)
    cl <- asin(pmin(0.9999, qt(ci, 2/gg - 2) * sqrt(gg * (coh^{
      -2
    } - 1)/(2 * (1 - gg)))))
    lines(x$freq, x$phase + cl, lty = ci.lty, col = ci.col)
    lines(x$freq, x$phase - cl, lty = ci.lty, col = ci.col)
    title(main)
  }
  else {
    dev.hold()
    on.exit(dev.flush())
    opar <- par(mfrow = c(nser - 1, nser - 1), mar = c(1.5, 1.5, 0.5, 0.5), oma = c(4, 4, 6, 4))
    on.exit(par(opar), add = TRUE)
    plot.new()
    for (j in 2:nser) for (i in 1:(j - 1)) {
      par(mfg = c(j - 1, i, nser - 1, nser - 1))
      ind <- i + (j - 1) * (j - 2)/2
      plot(x$freq, x$phase[, ind], type = type, ylim = ylim, axes = FALSE, xlab = "", ylab = "", ...)
      coh <- sqrt(x$coh[, ind])
      cl <- asin(pmin(0.9999, qt(ci, 2/gg - 2) * sqrt(gg * (coh^{
        -2
      } - 1)/(2 * (1 - gg)))))
      lines(x$freq, x$phase[, ind] + cl, lty = ci.lty, col = ci.col)
      lines(x$freq, x$phase[, ind] - cl, lty = ci.lty, col = ci.col)
      box()
      if (i == 1) {
        axis(2, xpd = NA)
        title(ylab = x$snames[j], xpd = NA)
      }
      if (j == nser) {
        axis(1, xpd = NA)
        title(xlab = x$snames[i], xpd = NA)
      }
      mtext(main, 3, 3, TRUE, 0.5, cex = par("cex.main"), font = par("font.main"))
    }
  }
  invisible()
})
c("package:stats", "registered S3 method for plot from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
plot.stepfun
list(`package:stats` = function (x, xval, xlim, ylim = range(c(y, Fn.kn)), xlab = "x", ylab = "f(x)", main = NULL, add = FALSE, verticals = TRUE, do.points = (n < 1000), pch = par("pch"), col = par("col"), col.points = col, cex.points = par("cex"), col.hor = col, col.vert = col, lty = par("lty"), lwd = par("lwd"), ...) 
{
  if (!is.stepfun(x)) {
    if (is.numeric(x)) {
      sarg <- substitute(x)
      x <- ecdf(x)
      attr(x, "call") <- call("ecdf", sarg)
    }
    else stop("'plot.stepfun' called with wrong type of argument 'x'")
  }
  if (missing(main)) 
    main <- deparse(attr(x, "call") %||% sys.call())
  knF <- knots(x)
  xval <- if (missing(xval)) 
    knF
  else sort(xval)
  if (missing(xlim)) {
    rx <- range(xval)
    dr <- if (length(xval) > 1) 
      max(0.08 * diff(rx), median(diff(xval)))
    else abs(xval)/16
    xlim <- rx + dr * c(-1, 1)
  }
  else dr <- diff(xlim)
  xval <- xval[xlim[1] - dr <= xval & xval <= xlim[2] + dr]
  ti <- c(xlim[1] - dr, xval, xlim[2] + dr)
  ti.l <- ti[-length(ti)]
  ti.r <- ti[-1]
  y <- x(0.5 * (ti.l + ti.r))
  n <- length(y)
  Fn.kn <- x(xval)
  dev.hold()
  on.exit(dev.flush())
  if (add) 
    segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, lwd = lwd, ...)
  else {
    if (missing(ylim)) 
      ylim <- range(c(y, Fn.kn))
    plot(NA, NA, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab, main = main, ...)
    segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, lwd = lwd)
  }
  if (do.points) 
    points(xval, Fn.kn, pch = pch, col = col.points, cex = cex.points)
  if (verticals) 
    segments(xval, y[-n], xval, y[-1], col = col.vert, lty = lty, lwd = lwd)
  invisible(list(t = ti, y = y))
}, function (x, xval, xlim, ylim = range(c(y, Fn.kn)), xlab = "x", ylab = "f(x)", main = NULL, add = FALSE, verticals = TRUE, do.points = (n < 1000), pch = par("pch"), col = par("col"), col.points = col, cex.points = par("cex"), col.hor = col, col.vert = col, lty = par("lty"), lwd = par("lwd"), ...) 
{
  if (!is.stepfun(x)) {
    if (is.numeric(x)) {
      sarg <- substitute(x)
      x <- ecdf(x)
      attr(x, "call") <- call("ecdf", sarg)
    }
    else stop("'plot.stepfun' called with wrong type of argument 'x'")
  }
  if (missing(main)) 
    main <- deparse(attr(x, "call") %||% sys.call())
  knF <- knots(x)
  xval <- if (missing(xval)) 
    knF
  else sort(xval)
  if (missing(xlim)) {
    rx <- range(xval)
    dr <- if (length(xval) > 1) 
      max(0.08 * diff(rx), median(diff(xval)))
    else abs(xval)/16
    xlim <- rx + dr * c(-1, 1)
  }
  else dr <- diff(xlim)
  xval <- xval[xlim[1] - dr <= xval & xval <= xlim[2] + dr]
  ti <- c(xlim[1] - dr, xval, xlim[2] + dr)
  ti.l <- ti[-length(ti)]
  ti.r <- ti[-1]
  y <- x(0.5 * (ti.l + ti.r))
  n <- length(y)
  Fn.kn <- x(xval)
  dev.hold()
  on.exit(dev.flush())
  if (add) 
    segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, lwd = lwd, ...)
  else {
    if (missing(ylim)) 
      ylim <- range(c(y, Fn.kn))
    plot(NA, NA, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab, main = main, ...)
    segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, lwd = lwd)
  }
  if (do.points) 
    points(xval, Fn.kn, pch = pch, col = col.points, cex = cex.points)
  if (verticals) 
    segments(xval, y[-n], xval, y[-1], col = col.vert, lty = lty, lwd = lwd)
  invisible(list(t = ti, y = y))
}, function (x, xval, xlim, ylim = range(c(y, Fn.kn)), xlab = "x", ylab = "f(x)", main = NULL, add = FALSE, verticals = TRUE, do.points = (n < 1000), pch = par("pch"), col = par("col"), col.points = col, cex.points = par("cex"), col.hor = col, col.vert = col, lty = par("lty"), lwd = par("lwd"), ...) 
{
  if (!is.stepfun(x)) {
    if (is.numeric(x)) {
      sarg <- substitute(x)
      x <- ecdf(x)
      attr(x, "call") <- call("ecdf", sarg)
    }
    else stop("'plot.stepfun' called with wrong type of argument 'x'")
  }
  if (missing(main)) 
    main <- deparse(attr(x, "call") %||% sys.call())
  knF <- knots(x)
  xval <- if (missing(xval)) 
    knF
  else sort(xval)
  if (missing(xlim)) {
    rx <- range(xval)
    dr <- if (length(xval) > 1) 
      max(0.08 * diff(rx), median(diff(xval)))
    else abs(xval)/16
    xlim <- rx + dr * c(-1, 1)
  }
  else dr <- diff(xlim)
  xval <- xval[xlim[1] - dr <= xval & xval <= xlim[2] + dr]
  ti <- c(xlim[1] - dr, xval, xlim[2] + dr)
  ti.l <- ti[-length(ti)]
  ti.r <- ti[-1]
  y <- x(0.5 * (ti.l + ti.r))
  n <- length(y)
  Fn.kn <- x(xval)
  dev.hold()
  on.exit(dev.flush())
  if (add) 
    segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, lwd = lwd, ...)
  else {
    if (missing(ylim)) 
      ylim <- range(c(y, Fn.kn))
    plot(NA, NA, type = "n", xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab, main = main, ...)
    segments(ti.l, y, ti.r, y, col = col.hor, lty = lty, lwd = lwd)
  }
  if (do.points) 
    points(xval, Fn.kn, pch = pch, col = col.points, cex = cex.points)
  if (verticals) 
    segments(xval, y[-n], xval, y[-1], col = col.vert, lty = lty, lwd = lwd)
  invisible(list(t = ti, y = y))
})
c("package:stats", "registered S3 method for plot from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
plot.ts
list(`package:stats` = function (x, y = NULL, plot.type = c("multiple", "single"), xy.labels, xy.lines, panel = lines, nc, yax.flip = FALSE, mar.multi = c(0, 5.1, 0, if (yax.flip) 5.1 else 2.1), oma.multi = c(6, 0, 5, 0), axes = TRUE, ...) 
{
  plotts <- function(x, y = NULL, plot.type = c("multiple", "single"), xy.labels, xy.lines, panel = lines, nc, xlabel, ylabel, type = "l", xlim = NULL, ylim = NULL, xlab = "Time", ylab, log = "", col = par("col"), bg = NA, pch = par("pch"), cex = par("cex"), lty = par("lty"), lwd = par("lwd"), axes = TRUE, frame.plot = axes, ann = par("ann"), cex.lab = par("cex.lab"), col.lab = par("col.lab"), font.lab = par("font.lab"), cex.axis = par("cex.axis"), col.axis = par("col.axis"), font.axis = par("font.axis"), 
                     main = NULL, ...) {
    plot.type <- match.arg(plot.type)
    nser <- NCOL(x)
    if (plot.type == "multiple" && nser > 1) {
      addmain <- function(main, cex.main = par("cex.main"), font.main = par("font.main"), col.main = par("col.main"), ...) mtext(main, side = 3, line = 3, cex = cex.main, font = font.main, col = col.main, ...)
      panel <- match.fun(panel)
      nser <- NCOL(x)
      if (nser > 10) 
        stop("cannot plot more than 10 series as \"multiple\"")
      if (is.null(main)) 
        main <- xlabel
      nm <- colnames(x) %||% paste("Series", 1:nser)
      if (missing(nc)) 
        nc <- if (nser > 4) 
          2
      else 1
      nr <- ceiling(nser/nc)
      oldpar <- par(mar = mar.multi, oma = oma.multi, mfcol = c(nr, nc))
      on.exit(par(oldpar))
      for (i in 1:nser) {
        plot.default(x[, i], axes = FALSE, xlab = "", ylab = "", log = log, col = col, bg = bg, pch = pch, ann = ann, type = "n", ...)
        panel(x[, i], col = col, bg = bg, pch = pch, cex = cex, lwd = lwd, lty = lty, type = type, ...)
        if (frame.plot) 
          box(...)
        y.side <- if (i%%2 || !yax.flip) 
          2
        else 4
        do.xax <- i%%nr == 0 || i == nser
        if (axes) {
          axis(y.side, xpd = NA, cex.axis = cex.axis, col.axis = col.axis, font.axis = font.axis, ...)
          if (do.xax) 
            axis(1, xpd = NA, cex.axis = cex.axis, col.axis = col.axis, font.axis = font.axis, ...)
        }
        if (ann) {
          mtext(nm[i], y.side, line = 3, cex = cex.lab, col = col.lab, font = font.lab, ...)
          if (do.xax) 
            mtext(xlab, side = 1, line = 3, cex = cex.lab, col = col.lab, font = font.lab, ...)
        }
      }
      if (ann && !is.null(main)) {
        par(mfcol = c(1, 1))
        addmain(main, ...)
      }
      return(invisible())
    }
    x <- as.ts(x)
    if (!is.null(y)) {
      y <- hasTsp(y)
      if (NCOL(x) > 1 || NCOL(y) > 1) 
        stop("scatter plots only for univariate time series")
      if (is.ts(x) && is.ts(y)) {
        xy <- ts.intersect(x, y)
        xy <- xy.coords(xy[, 1], xy[, 2], xlabel, ylabel, log)
      }
      else xy <- xy.coords(x, y, xlabel, ylabel, log)
      if (missing(xlab)) 
        xlab <- xy$xlab
      if (missing(ylab)) 
        ylab <- xy$ylab
      if (is.null(xlim)) 
        xlim <- range(xy$x[is.finite(xy$x)])
      if (is.null(ylim)) 
        ylim <- range(xy$y[is.finite(xy$y)])
      n <- length(xy$x)
      if (missing(xy.labels)) 
        xy.labels <- (n <= 150)
      do.lab <- if (is.logical(xy.labels)) 
        xy.labels
      else {
        if (!is.character(xy.labels)) 
          stop("'xy.labels' must be logical or character")
        TRUE
      }
      ptype <- if (do.lab) 
        "n"
      else if (missing(type)) 
        "p"
      else type
      dev.hold()
      on.exit(dev.flush())
      plot.default(xy, type = ptype, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, log = log, col = col, bg = bg, pch = pch, cex = cex, lty = lty, lwd = lwd, axes = axes, frame.plot = frame.plot, ann = ann, main = main, ...)
      if (missing(xy.lines)) 
        xy.lines <- do.lab
      if (do.lab) 
        text(xy, labels = if (is.character(xy.labels)) 
          xy.labels
          else if (all(tsp(x) == tsp(y))) 
            formatC(unclass(time(x)), width = 1)
          else seq_along(xy$x), col = col, cex = cex)
      if (xy.lines) 
        lines(xy, col = col, lty = lty, lwd = lwd, type = if (do.lab) 
          "c"
          else "l")
      return(invisible())
    }
    if (missing(ylab)) {
      ylab <- colnames(x)
      if (length(ylab) != 1) 
        ylab <- xlabel
    }
    if (is.matrix(x)) {
      k <- ncol(x)
      tx <- time(x)
      xy <- xy.coords(x = matrix(rep.int(tx, k), ncol = k), y = x, log = log, setLab = FALSE)
      xy$x <- tx
    }
    else xy <- xy.coords(x, NULL, log = log, setLab = FALSE)
    if (is.null(xlim)) 
      xlim <- range(xy$x)
    if (is.null(ylim)) 
      ylim <- range(xy$y[is.finite(xy$y)])
    plot.new()
    plot.window(xlim, ylim, log, ...)
    if (is.matrix(x)) {
      for (i in seq_len(k)) lines.default(xy$x, x[, i], col = col[(i - 1)%%length(col) + 1], lty = lty[(i - 1)%%length(lty) + 1], lwd = lwd[(i - 1)%%length(lwd) + 1], bg = bg[(i - 1)%%length(bg) + 1], pch = pch[(i - 1)%%length(pch) + 1], cex = cex[(i - 1)%%length(cex) + 1], type = type)
    }
    else {
      lines.default(xy$x, x, col = col[1], bg = bg, lty = lty[1], lwd = lwd[1], pch = pch[1], cex = cex[1], type = type)
    }
    if (ann) 
      title(main = main, xlab = xlab, ylab = ylab, ...)
    if (axes) {
      axis(1, ...)
      axis(2, ...)
    }
    if (frame.plot) 
      box(...)
  }
  xlabel <- if (!missing(x)) 
    deparse1(substitute(x))
  ylabel <- if (!missing(y)) 
    deparse1(substitute(y))
  plotts(x = x, y = y, plot.type = plot.type, xy.labels = xy.labels, xy.lines = xy.lines, panel = panel, nc = nc, xlabel = xlabel, ylabel = ylabel, axes = axes, ...)
}, function (x, y = NULL, plot.type = c("multiple", "single"), xy.labels, xy.lines, panel = lines, nc, yax.flip = FALSE, mar.multi = c(0, 5.1, 0, if (yax.flip) 5.1 else 2.1), oma.multi = c(6, 0, 5, 0), axes = TRUE, ...) 
{
  plotts <- function(x, y = NULL, plot.type = c("multiple", "single"), xy.labels, xy.lines, panel = lines, nc, xlabel, ylabel, type = "l", xlim = NULL, ylim = NULL, xlab = "Time", ylab, log = "", col = par("col"), bg = NA, pch = par("pch"), cex = par("cex"), lty = par("lty"), lwd = par("lwd"), axes = TRUE, frame.plot = axes, ann = par("ann"), cex.lab = par("cex.lab"), col.lab = par("col.lab"), font.lab = par("font.lab"), cex.axis = par("cex.axis"), col.axis = par("col.axis"), font.axis = par("font.axis"), 
                     main = NULL, ...) {
    plot.type <- match.arg(plot.type)
    nser <- NCOL(x)
    if (plot.type == "multiple" && nser > 1) {
      addmain <- function(main, cex.main = par("cex.main"), font.main = par("font.main"), col.main = par("col.main"), ...) mtext(main, side = 3, line = 3, cex = cex.main, font = font.main, col = col.main, ...)
      panel <- match.fun(panel)
      nser <- NCOL(x)
      if (nser > 10) 
        stop("cannot plot more than 10 series as \"multiple\"")
      if (is.null(main)) 
        main <- xlabel
      nm <- colnames(x) %||% paste("Series", 1:nser)
      if (missing(nc)) 
        nc <- if (nser > 4) 
          2
      else 1
      nr <- ceiling(nser/nc)
      oldpar <- par(mar = mar.multi, oma = oma.multi, mfcol = c(nr, nc))
      on.exit(par(oldpar))
      for (i in 1:nser) {
        plot.default(x[, i], axes = FALSE, xlab = "", ylab = "", log = log, col = col, bg = bg, pch = pch, ann = ann, type = "n", ...)
        panel(x[, i], col = col, bg = bg, pch = pch, cex = cex, lwd = lwd, lty = lty, type = type, ...)
        if (frame.plot) 
          box(...)
        y.side <- if (i%%2 || !yax.flip) 
          2
        else 4
        do.xax <- i%%nr == 0 || i == nser
        if (axes) {
          axis(y.side, xpd = NA, cex.axis = cex.axis, col.axis = col.axis, font.axis = font.axis, ...)
          if (do.xax) 
            axis(1, xpd = NA, cex.axis = cex.axis, col.axis = col.axis, font.axis = font.axis, ...)
        }
        if (ann) {
          mtext(nm[i], y.side, line = 3, cex = cex.lab, col = col.lab, font = font.lab, ...)
          if (do.xax) 
            mtext(xlab, side = 1, line = 3, cex = cex.lab, col = col.lab, font = font.lab, ...)
        }
      }
      if (ann && !is.null(main)) {
        par(mfcol = c(1, 1))
        addmain(main, ...)
      }
      return(invisible())
    }
    x <- as.ts(x)
    if (!is.null(y)) {
      y <- hasTsp(y)
      if (NCOL(x) > 1 || NCOL(y) > 1) 
        stop("scatter plots only for univariate time series")
      if (is.ts(x) && is.ts(y)) {
        xy <- ts.intersect(x, y)
        xy <- xy.coords(xy[, 1], xy[, 2], xlabel, ylabel, log)
      }
      else xy <- xy.coords(x, y, xlabel, ylabel, log)
      if (missing(xlab)) 
        xlab <- xy$xlab
      if (missing(ylab)) 
        ylab <- xy$ylab
      if (is.null(xlim)) 
        xlim <- range(xy$x[is.finite(xy$x)])
      if (is.null(ylim)) 
        ylim <- range(xy$y[is.finite(xy$y)])
      n <- length(xy$x)
      if (missing(xy.labels)) 
        xy.labels <- (n <= 150)
      do.lab <- if (is.logical(xy.labels)) 
        xy.labels
      else {
        if (!is.character(xy.labels)) 
          stop("'xy.labels' must be logical or character")
        TRUE
      }
      ptype <- if (do.lab) 
        "n"
      else if (missing(type)) 
        "p"
      else type
      dev.hold()
      on.exit(dev.flush())
      plot.default(xy, type = ptype, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, log = log, col = col, bg = bg, pch = pch, cex = cex, lty = lty, lwd = lwd, axes = axes, frame.plot = frame.plot, ann = ann, main = main, ...)
      if (missing(xy.lines)) 
        xy.lines <- do.lab
      if (do.lab) 
        text(xy, labels = if (is.character(xy.labels)) 
          xy.labels
          else if (all(tsp(x) == tsp(y))) 
            formatC(unclass(time(x)), width = 1)
          else seq_along(xy$x), col = col, cex = cex)
      if (xy.lines) 
        lines(xy, col = col, lty = lty, lwd = lwd, type = if (do.lab) 
          "c"
          else "l")
      return(invisible())
    }
    if (missing(ylab)) {
      ylab <- colnames(x)
      if (length(ylab) != 1) 
        ylab <- xlabel
    }
    if (is.matrix(x)) {
      k <- ncol(x)
      tx <- time(x)
      xy <- xy.coords(x = matrix(rep.int(tx, k), ncol = k), y = x, log = log, setLab = FALSE)
      xy$x <- tx
    }
    else xy <- xy.coords(x, NULL, log = log, setLab = FALSE)
    if (is.null(xlim)) 
      xlim <- range(xy$x)
    if (is.null(ylim)) 
      ylim <- range(xy$y[is.finite(xy$y)])
    plot.new()
    plot.window(xlim, ylim, log, ...)
    if (is.matrix(x)) {
      for (i in seq_len(k)) lines.default(xy$x, x[, i], col = col[(i - 1)%%length(col) + 1], lty = lty[(i - 1)%%length(lty) + 1], lwd = lwd[(i - 1)%%length(lwd) + 1], bg = bg[(i - 1)%%length(bg) + 1], pch = pch[(i - 1)%%length(pch) + 1], cex = cex[(i - 1)%%length(cex) + 1], type = type)
    }
    else {
      lines.default(xy$x, x, col = col[1], bg = bg, lty = lty[1], lwd = lwd[1], pch = pch[1], cex = cex[1], type = type)
    }
    if (ann) 
      title(main = main, xlab = xlab, ylab = ylab, ...)
    if (axes) {
      axis(1, ...)
      axis(2, ...)
    }
    if (frame.plot) 
      box(...)
  }
  xlabel <- if (!missing(x)) 
    deparse1(substitute(x))
  ylabel <- if (!missing(y)) 
    deparse1(substitute(y))
  plotts(x = x, y = y, plot.type = plot.type, xy.labels = xy.labels, xy.lines = xy.lines, panel = panel, nc = nc, xlabel = xlabel, ylabel = ylabel, axes = axes, ...)
}, function (x, y = NULL, plot.type = c("multiple", "single"), xy.labels, xy.lines, panel = lines, nc, yax.flip = FALSE, mar.multi = c(0, 5.1, 0, if (yax.flip) 5.1 else 2.1), oma.multi = c(6, 0, 5, 0), axes = TRUE, ...) 
{
  plotts <- function(x, y = NULL, plot.type = c("multiple", "single"), xy.labels, xy.lines, panel = lines, nc, xlabel, ylabel, type = "l", xlim = NULL, ylim = NULL, xlab = "Time", ylab, log = "", col = par("col"), bg = NA, pch = par("pch"), cex = par("cex"), lty = par("lty"), lwd = par("lwd"), axes = TRUE, frame.plot = axes, ann = par("ann"), cex.lab = par("cex.lab"), col.lab = par("col.lab"), font.lab = par("font.lab"), cex.axis = par("cex.axis"), col.axis = par("col.axis"), font.axis = par("font.axis"), 
                     main = NULL, ...) {
    plot.type <- match.arg(plot.type)
    nser <- NCOL(x)
    if (plot.type == "multiple" && nser > 1) {
      addmain <- function(main, cex.main = par("cex.main"), font.main = par("font.main"), col.main = par("col.main"), ...) mtext(main, side = 3, line = 3, cex = cex.main, font = font.main, col = col.main, ...)
      panel <- match.fun(panel)
      nser <- NCOL(x)
      if (nser > 10) 
        stop("cannot plot more than 10 series as \"multiple\"")
      if (is.null(main)) 
        main <- xlabel
      nm <- colnames(x) %||% paste("Series", 1:nser)
      if (missing(nc)) 
        nc <- if (nser > 4) 
          2
      else 1
      nr <- ceiling(nser/nc)
      oldpar <- par(mar = mar.multi, oma = oma.multi, mfcol = c(nr, nc))
      on.exit(par(oldpar))
      for (i in 1:nser) {
        plot.default(x[, i], axes = FALSE, xlab = "", ylab = "", log = log, col = col, bg = bg, pch = pch, ann = ann, type = "n", ...)
        panel(x[, i], col = col, bg = bg, pch = pch, cex = cex, lwd = lwd, lty = lty, type = type, ...)
        if (frame.plot) 
          box(...)
        y.side <- if (i%%2 || !yax.flip) 
          2
        else 4
        do.xax <- i%%nr == 0 || i == nser
        if (axes) {
          axis(y.side, xpd = NA, cex.axis = cex.axis, col.axis = col.axis, font.axis = font.axis, ...)
          if (do.xax) 
            axis(1, xpd = NA, cex.axis = cex.axis, col.axis = col.axis, font.axis = font.axis, ...)
        }
        if (ann) {
          mtext(nm[i], y.side, line = 3, cex = cex.lab, col = col.lab, font = font.lab, ...)
          if (do.xax) 
            mtext(xlab, side = 1, line = 3, cex = cex.lab, col = col.lab, font = font.lab, ...)
        }
      }
      if (ann && !is.null(main)) {
        par(mfcol = c(1, 1))
        addmain(main, ...)
      }
      return(invisible())
    }
    x <- as.ts(x)
    if (!is.null(y)) {
      y <- hasTsp(y)
      if (NCOL(x) > 1 || NCOL(y) > 1) 
        stop("scatter plots only for univariate time series")
      if (is.ts(x) && is.ts(y)) {
        xy <- ts.intersect(x, y)
        xy <- xy.coords(xy[, 1], xy[, 2], xlabel, ylabel, log)
      }
      else xy <- xy.coords(x, y, xlabel, ylabel, log)
      if (missing(xlab)) 
        xlab <- xy$xlab
      if (missing(ylab)) 
        ylab <- xy$ylab
      if (is.null(xlim)) 
        xlim <- range(xy$x[is.finite(xy$x)])
      if (is.null(ylim)) 
        ylim <- range(xy$y[is.finite(xy$y)])
      n <- length(xy$x)
      if (missing(xy.labels)) 
        xy.labels <- (n <= 150)
      do.lab <- if (is.logical(xy.labels)) 
        xy.labels
      else {
        if (!is.character(xy.labels)) 
          stop("'xy.labels' must be logical or character")
        TRUE
      }
      ptype <- if (do.lab) 
        "n"
      else if (missing(type)) 
        "p"
      else type
      dev.hold()
      on.exit(dev.flush())
      plot.default(xy, type = ptype, xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, log = log, col = col, bg = bg, pch = pch, cex = cex, lty = lty, lwd = lwd, axes = axes, frame.plot = frame.plot, ann = ann, main = main, ...)
      if (missing(xy.lines)) 
        xy.lines <- do.lab
      if (do.lab) 
        text(xy, labels = if (is.character(xy.labels)) 
          xy.labels
          else if (all(tsp(x) == tsp(y))) 
            formatC(unclass(time(x)), width = 1)
          else seq_along(xy$x), col = col, cex = cex)
      if (xy.lines) 
        lines(xy, col = col, lty = lty, lwd = lwd, type = if (do.lab) 
          "c"
          else "l")
      return(invisible())
    }
    if (missing(ylab)) {
      ylab <- colnames(x)
      if (length(ylab) != 1) 
        ylab <- xlabel
    }
    if (is.matrix(x)) {
      k <- ncol(x)
      tx <- time(x)
      xy <- xy.coords(x = matrix(rep.int(tx, k), ncol = k), y = x, log = log, setLab = FALSE)
      xy$x <- tx
    }
    else xy <- xy.coords(x, NULL, log = log, setLab = FALSE)
    if (is.null(xlim)) 
      xlim <- range(xy$x)
    if (is.null(ylim)) 
      ylim <- range(xy$y[is.finite(xy$y)])
    plot.new()
    plot.window(xlim, ylim, log, ...)
    if (is.matrix(x)) {
      for (i in seq_len(k)) lines.default(xy$x, x[, i], col = col[(i - 1)%%length(col) + 1], lty = lty[(i - 1)%%length(lty) + 1], lwd = lwd[(i - 1)%%length(lwd) + 1], bg = bg[(i - 1)%%length(bg) + 1], pch = pch[(i - 1)%%length(pch) + 1], cex = cex[(i - 1)%%length(cex) + 1], type = type)
    }
    else {
      lines.default(xy$x, x, col = col[1], bg = bg, lty = lty[1], lwd = lwd[1], pch = pch[1], cex = cex[1], type = type)
    }
    if (ann) 
      title(main = main, xlab = xlab, ylab = ylab, ...)
    if (axes) {
      axis(1, ...)
      axis(2, ...)
    }
    if (frame.plot) 
      box(...)
  }
  xlabel <- if (!missing(x)) 
    deparse1(substitute(x))
  ylabel <- if (!missing(y)) 
    deparse1(substitute(y))
  plotts(x = x, y = y, plot.type = plot.type, xy.labels = xy.labels, xy.lines = xy.lines, panel = panel, nc = nc, xlabel = xlabel, ylabel = ylabel, axes = axes, ...)
})
c("package:stats", "registered S3 method for plot from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
pnbinom
list(`package:stats` = function (q, size, prob, mu, lower.tail = TRUE, log.p = FALSE) 
{
  if (!missing(mu)) {
    if (!missing(prob)) 
      stop("'prob' and 'mu' both specified")
    .Call(C_pnbinom_mu, q, size, mu, lower.tail, log.p)
  }
  else .Call(C_pnbinom, q, size, prob, lower.tail, log.p)
}, function (q, size, prob, mu, lower.tail = TRUE, log.p = FALSE) 
{
  if (!missing(mu)) {
    if (!missing(prob)) 
      stop("'prob' and 'mu' both specified")
    .Call(C_pnbinom_mu, q, size, mu, lower.tail, log.p)
  }
  else .Call(C_pnbinom, q, size, prob, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pnorm
list(`package:stats` = function (q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_pnorm, q, mean, sd, lower.tail, log.p), function (q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_pnorm, q, mean, sd, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
poisson
list(`package:stats` = function (link = "log") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("log", "identity", "sqrt")
  family <- "poisson"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu
  validmu <- function(mu) all(is.finite(mu)) && all(mu > 0)
  dev.resids <- function(y, mu, wt) {
    r <- mu * wt
    p <- which(y > 0)
    r[p] <- (wt * (y * log(y/mu) - (y - mu)))[p]
    2 * r
  }
  aic <- function(y, n, mu, wt, dev) -2 * sum(dpois(y, mu, log = TRUE) * wt)
  initialize <- expression({
    if (any(y < 0)) stop("negative values not allowed for the 'Poisson' family")
    n <- rep.int(1, nobs)
    mustart <- y + 0.1
  })
  simfun <- function(object, nsim) {
    wts <- object$prior.weights
    if (any(wts != 1)) 
      warning("ignoring prior weights")
    ftd <- fitted(object)
    rpois(nsim * length(ftd), ftd)
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
}, function (link = "log") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("log", "identity", "sqrt")
  family <- "poisson"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu
  validmu <- function(mu) all(is.finite(mu)) && all(mu > 0)
  dev.resids <- function(y, mu, wt) {
    r <- mu * wt
    p <- which(y > 0)
    r[p] <- (wt * (y * log(y/mu) - (y - mu)))[p]
    2 * r
  }
  aic <- function(y, n, mu, wt, dev) -2 * sum(dpois(y, mu, log = TRUE) * wt)
  initialize <- expression({
    if (any(y < 0)) stop("negative values not allowed for the 'Poisson' family")
    n <- rep.int(1, nobs)
    mustart <- y + 0.1
  })
  simfun <- function(object, nsim) {
    wts <- object$prior.weights
    if (any(wts != 1)) 
      warning("ignoring prior weights")
    ftd <- fitted(object)
    rpois(nsim * length(ftd), ftd)
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, simulate = simfun), class = "family")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
poisson.test
list(`package:stats` = function (x, T = 1, r = 1, alternative = c("two.sided", "less", "greater"), conf.level = 0.95) 
{
  DNAME <- paste(deparse1(substitute(x)), "time base:", deparse1(substitute(T)))
  if ((l <- length(x)) != length(T)) 
    if (length(T) == 1) 
      T <- rep(T, l)
  else stop("'x' and 'T' have incompatible length")
  xr <- round(x)
  if (any(!is.finite(x) | (x < 0)) || max(abs(x - xr)) > 1e-07) 
    stop("'x' must be finite, nonnegative, and integer")
  x <- xr
  if (any(is.na(T) | (T < 0))) 
    stop("'T' must be nonnegative")
  if ((k <- length(x)) < 1) 
    stop("not enough data")
  if (k > 2) 
    stop("the case k > 2 is unimplemented")
  if (!missing(r) && (length(r) > 1 || is.na(r) || r < 0)) 
    stop("'r' must be a single positive number")
  alternative <- match.arg(alternative)
  if (k == 2) {
    RVAL <- binom.test(x, sum(x), r * T[1]/(r * T[1] + T[2]), alternative = alternative, conf.level = conf.level)
    RVAL$data.name <- DNAME
    RVAL$statistic <- c(count1 = x[1])
    RVAL$parameter <- c(`expected count1` = sum(x) * r * T[1]/sum(T * c(1, r)))
    RVAL$estimate <- c(`rate ratio` = (x[1]/T[1])/(x[2]/T[2]))
    pp <- RVAL$conf.int
    RVAL$conf.int <- pp/(1 - pp) * T[2]/T[1]
    names(r) <- "rate ratio"
    RVAL$null.value <- r
    RVAL$method <- "Comparison of Poisson rates"
    return(RVAL)
  }
  else {
    m <- r * T
    PVAL <- switch(alternative, less = ppois(x, m), greater = ppois(x - 1, m, lower.tail = FALSE), two.sided = {
      if (m == 0) (x == 0) else {
        relErr <- 1 + 1e-07
        d <- dpois(x, r * T)
        if (x == m) 1 else if (x < m) {
          N <- ceiling(2 * m - x)
          while (dpois(N, m) > d) N <- 2 * N
          i <- seq.int(from = ceiling(m), to = N)
          y <- sum(dpois(i, m) <= d * relErr)
          ppois(x, m) + ppois(N - y, m, lower.tail = FALSE)
        } else {
          i <- seq.int(from = 0, to = floor(m))
          y <- sum(dpois(i, m) <= d * relErr)
          ppois(y - 1, m) + ppois(x - 1, m, lower.tail = FALSE)
        }
      }
    })
    p.L <- function(x, alpha) {
      if (x == 0) 
        0
      else qgamma(alpha, x)
    }
    p.U <- function(x, alpha) qgamma(1 - alpha, x + 1)
    CINT <- switch(alternative, less = c(0, p.U(x, 1 - conf.level)), greater = c(p.L(x, 1 - conf.level), Inf), two.sided = {
      alpha <- (1 - conf.level)/2
      c(p.L(x, alpha), p.U(x, alpha))
    })/T
    attr(CINT, "conf.level") <- conf.level
    ESTIMATE <- x/T
    names(x) <- "number of events"
    names(T) <- "time base"
    names(ESTIMATE) <- names(r) <- "event rate"
    structure(list(statistic = x, parameter = T, p.value = PVAL, conf.int = CINT, estimate = ESTIMATE, null.value = r, alternative = alternative, method = "Exact Poisson test", data.name = DNAME), class = "htest")
  }
}, function (x, T = 1, r = 1, alternative = c("two.sided", "less", "greater"), conf.level = 0.95) 
{
  DNAME <- paste(deparse1(substitute(x)), "time base:", deparse1(substitute(T)))
  if ((l <- length(x)) != length(T)) 
    if (length(T) == 1) 
      T <- rep(T, l)
  else stop("'x' and 'T' have incompatible length")
  xr <- round(x)
  if (any(!is.finite(x) | (x < 0)) || max(abs(x - xr)) > 1e-07) 
    stop("'x' must be finite, nonnegative, and integer")
  x <- xr
  if (any(is.na(T) | (T < 0))) 
    stop("'T' must be nonnegative")
  if ((k <- length(x)) < 1) 
    stop("not enough data")
  if (k > 2) 
    stop("the case k > 2 is unimplemented")
  if (!missing(r) && (length(r) > 1 || is.na(r) || r < 0)) 
    stop("'r' must be a single positive number")
  alternative <- match.arg(alternative)
  if (k == 2) {
    RVAL <- binom.test(x, sum(x), r * T[1]/(r * T[1] + T[2]), alternative = alternative, conf.level = conf.level)
    RVAL$data.name <- DNAME
    RVAL$statistic <- c(count1 = x[1])
    RVAL$parameter <- c(`expected count1` = sum(x) * r * T[1]/sum(T * c(1, r)))
    RVAL$estimate <- c(`rate ratio` = (x[1]/T[1])/(x[2]/T[2]))
    pp <- RVAL$conf.int
    RVAL$conf.int <- pp/(1 - pp) * T[2]/T[1]
    names(r) <- "rate ratio"
    RVAL$null.value <- r
    RVAL$method <- "Comparison of Poisson rates"
    return(RVAL)
  }
  else {
    m <- r * T
    PVAL <- switch(alternative, less = ppois(x, m), greater = ppois(x - 1, m, lower.tail = FALSE), two.sided = {
      if (m == 0) (x == 0) else {
        relErr <- 1 + 1e-07
        d <- dpois(x, r * T)
        if (x == m) 1 else if (x < m) {
          N <- ceiling(2 * m - x)
          while (dpois(N, m) > d) N <- 2 * N
          i <- seq.int(from = ceiling(m), to = N)
          y <- sum(dpois(i, m) <= d * relErr)
          ppois(x, m) + ppois(N - y, m, lower.tail = FALSE)
        } else {
          i <- seq.int(from = 0, to = floor(m))
          y <- sum(dpois(i, m) <= d * relErr)
          ppois(y - 1, m) + ppois(x - 1, m, lower.tail = FALSE)
        }
      }
    })
    p.L <- function(x, alpha) {
      if (x == 0) 
        0
      else qgamma(alpha, x)
    }
    p.U <- function(x, alpha) qgamma(1 - alpha, x + 1)
    CINT <- switch(alternative, less = c(0, p.U(x, 1 - conf.level)), greater = c(p.L(x, 1 - conf.level), Inf), two.sided = {
      alpha <- (1 - conf.level)/2
      c(p.L(x, alpha), p.U(x, alpha))
    })/T
    attr(CINT, "conf.level") <- conf.level
    ESTIMATE <- x/T
    names(x) <- "number of events"
    names(T) <- "time base"
    names(ESTIMATE) <- names(r) <- "event rate"
    structure(list(statistic = x, parameter = T, p.value = PVAL, conf.int = CINT, estimate = ESTIMATE, null.value = r, alternative = alternative, method = "Exact Poisson test", data.name = DNAME), class = "htest")
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
poly
list(`package:stats` = function (x, ..., degree = 1, coefs = NULL, raw = FALSE, simple = FALSE) 
{
  dots <- list(...)
  if (nd <- length(dots)) {
    dots_deg <- nd == 1 && length(dots[[1]]) == 1
    if (dots_deg) 
      degree <- dots[[1]]
    else return(polym(x, ..., degree = degree, coefs = coefs, raw = raw))
  }
  if (is.matrix(x)) {
    m <- unclass(as.data.frame(if (nd && dots_deg) x else cbind(x, ...)))
    return(do.call(polym, c(m, degree = degree, raw = raw, list(coefs = coefs))))
  }
  if (degree < 1) 
    stop("'degree' must be at least 1")
  if (raw) {
    Z <- outer(x, 1:degree, `^`)
    colnames(Z) <- 1:degree
  }
  else {
    if (is.null(coefs)) {
      if (anyNA(x)) 
        stop("missing values are not allowed in 'poly'")
      if (degree >= length(unique(x))) 
        stop("'degree' must be less than number of unique points")
      xbar <- mean(x)
      x <- x - xbar
      X <- outer(x, 0:degree, `^`)
      QR <- qr(X)
      if (QR$rank < degree) 
        stop("'degree' must be less than number of unique points")
      z <- QR$qr
      z <- z * (row(z) == col(z))
      Z <- qr.qy(QR, z)
      norm2 <- colSums(Z^2)
      alpha <- (colSums(x * Z^2)/norm2 + xbar)[1:degree]
      norm2 <- c(1, norm2)
    }
    else {
      alpha <- coefs$alpha
      norm2 <- coefs$norm2
      Z <- matrix(1, length(x), degree + 1)
      Z[, 2] <- x - alpha[1]
      if (degree > 1) 
        for (i in 2:degree) Z[, i + 1] <- (x - alpha[i]) * Z[, i] - (norm2[i + 1]/norm2[i]) * Z[, i - 1]
    }
    Z <- Z/rep(sqrt(norm2[-1]), each = length(x))
    colnames(Z) <- 0:degree
    Z <- Z[, -1, drop = FALSE]
    if (!simple) 
      attr(Z, "coefs") <- list(alpha = alpha, norm2 = norm2)
  }
  if (simple) 
    Z
  else structure(Z, degree = 1:degree, class = c("poly", "matrix"))
}, function (x, ..., degree = 1, coefs = NULL, raw = FALSE, simple = FALSE) 
{
  dots <- list(...)
  if (nd <- length(dots)) {
    dots_deg <- nd == 1 && length(dots[[1]]) == 1
    if (dots_deg) 
      degree <- dots[[1]]
    else return(polym(x, ..., degree = degree, coefs = coefs, raw = raw))
  }
  if (is.matrix(x)) {
    m <- unclass(as.data.frame(if (nd && dots_deg) x else cbind(x, ...)))
    return(do.call(polym, c(m, degree = degree, raw = raw, list(coefs = coefs))))
  }
  if (degree < 1) 
    stop("'degree' must be at least 1")
  if (raw) {
    Z <- outer(x, 1:degree, `^`)
    colnames(Z) <- 1:degree
  }
  else {
    if (is.null(coefs)) {
      if (anyNA(x)) 
        stop("missing values are not allowed in 'poly'")
      if (degree >= length(unique(x))) 
        stop("'degree' must be less than number of unique points")
      xbar <- mean(x)
      x <- x - xbar
      X <- outer(x, 0:degree, `^`)
      QR <- qr(X)
      if (QR$rank < degree) 
        stop("'degree' must be less than number of unique points")
      z <- QR$qr
      z <- z * (row(z) == col(z))
      Z <- qr.qy(QR, z)
      norm2 <- colSums(Z^2)
      alpha <- (colSums(x * Z^2)/norm2 + xbar)[1:degree]
      norm2 <- c(1, norm2)
    }
    else {
      alpha <- coefs$alpha
      norm2 <- coefs$norm2
      Z <- matrix(1, length(x), degree + 1)
      Z[, 2] <- x - alpha[1]
      if (degree > 1) 
        for (i in 2:degree) Z[, i + 1] <- (x - alpha[i]) * Z[, i] - (norm2[i + 1]/norm2[i]) * Z[, i - 1]
    }
    Z <- Z/rep(sqrt(norm2[-1]), each = length(x))
    colnames(Z) <- 0:degree
    Z <- Z[, -1, drop = FALSE]
    if (!simple) 
      attr(Z, "coefs") <- list(alpha = alpha, norm2 = norm2)
  }
  if (simple) 
    Z
  else structure(Z, degree = 1:degree, class = c("poly", "matrix"))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
polym
list(`package:stats` = function (..., degree = 1, coefs = NULL, raw = FALSE) 
{
  dots <- list(...)
  nd <- length(coefs %||% dots)
  if (nd == 0) 
    stop("must supply one or more vectors")
  z <- do.call(expand.grid, c(rep.int(list(0:degree), nd), KEEP.OUT.ATTRS = FALSE))
  s <- rowSums(z)
  ind <- 0 < s & s <= degree
  z <- z[ind, , drop = FALSE]
  s <- s[ind]
  if (is.null(coefs)) {
    aPoly <- poly(dots[[1]], degree, raw = raw, simple = raw && nd > 1)
    if (nd == 1) 
      return(aPoly)
    n <- lengths(dots)
    if (any(n != n[1])) 
      stop("arguments must have the same length")
    res <- cbind(1, aPoly)[, 1 + z[, 1], drop = FALSE]
    if (!raw) 
      coefs <- list(attr(aPoly, "coefs"))
    for (i in 2:nd) {
      aPoly <- poly(dots[[i]], degree, raw = raw, simple = raw)
      res <- res * cbind(1, aPoly)[, 1 + z[, i], drop = FALSE]
      if (!raw) 
        coefs <- c(coefs, list(attr(aPoly, "coefs")))
    }
    colnames(res) <- apply(z, 1, function(x) paste(x, collapse = "."))
    structure(res, degree = as.vector(s), coefs = if (!raw) 
      coefs, class = c("poly", "matrix"))
  }
  else {
    newdata <- as.data.frame(dots)
    if (nd != ncol(newdata)) 
      stop("wrong number of columns in new data: ", deparse1(substitute(...)))
    res <- 1
    for (i in seq_len(nd)) res <- res * cbind(1, poly(newdata[[i]], degree = degree, coefs = coefs[[i]], simple = TRUE))[, 1 + z[, i], drop = FALSE]
    colnames(res) <- apply(z, 1, function(x) paste(x, collapse = "."))
    res
  }
}, function (..., degree = 1, coefs = NULL, raw = FALSE) 
{
  dots <- list(...)
  nd <- length(coefs %||% dots)
  if (nd == 0) 
    stop("must supply one or more vectors")
  z <- do.call(expand.grid, c(rep.int(list(0:degree), nd), KEEP.OUT.ATTRS = FALSE))
  s <- rowSums(z)
  ind <- 0 < s & s <= degree
  z <- z[ind, , drop = FALSE]
  s <- s[ind]
  if (is.null(coefs)) {
    aPoly <- poly(dots[[1]], degree, raw = raw, simple = raw && nd > 1)
    if (nd == 1) 
      return(aPoly)
    n <- lengths(dots)
    if (any(n != n[1])) 
      stop("arguments must have the same length")
    res <- cbind(1, aPoly)[, 1 + z[, 1], drop = FALSE]
    if (!raw) 
      coefs <- list(attr(aPoly, "coefs"))
    for (i in 2:nd) {
      aPoly <- poly(dots[[i]], degree, raw = raw, simple = raw)
      res <- res * cbind(1, aPoly)[, 1 + z[, i], drop = FALSE]
      if (!raw) 
        coefs <- c(coefs, list(attr(aPoly, "coefs")))
    }
    colnames(res) <- apply(z, 1, function(x) paste(x, collapse = "."))
    structure(res, degree = as.vector(s), coefs = if (!raw) 
      coefs, class = c("poly", "matrix"))
  }
  else {
    newdata <- as.data.frame(dots)
    if (nd != ncol(newdata)) 
      stop("wrong number of columns in new data: ", deparse1(substitute(...)))
    res <- 1
    for (i in seq_len(nd)) res <- res * cbind(1, poly(newdata[[i]], degree = degree, coefs = coefs[[i]], simple = TRUE))[, 1 + z[, i], drop = FALSE]
    colnames(res) <- apply(z, 1, function(x) paste(x, collapse = "."))
    res
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
power
list(`package:stats` = function (lambda = 1) 
{
  if (!is.numeric(lambda) || is.na(lambda)) 
    stop("invalid argument 'lambda'")
  if (lambda <= 0) 
    return(make.link("log"))
  if (lambda == 1) 
    return(make.link("identity"))
  linkfun <- function(mu) mu^lambda
  linkinv <- function(eta) pmax(eta^(1/lambda), .Machine$double.eps)
  mu.eta <- function(eta) pmax((1/lambda) * eta^(1/lambda - 1), .Machine$double.eps)
  valideta <- function(eta) all(is.finite(eta)) && all(eta > 0)
  link <- paste0("mu^", round(lambda, 3))
  structure(list(linkfun = linkfun, linkinv = linkinv, mu.eta = mu.eta, valideta = valideta, name = link), class = "link-glm")
}, function (lambda = 1) 
{
  if (!is.numeric(lambda) || is.na(lambda)) 
    stop("invalid argument 'lambda'")
  if (lambda <= 0) 
    return(make.link("log"))
  if (lambda == 1) 
    return(make.link("identity"))
  linkfun <- function(mu) mu^lambda
  linkinv <- function(eta) pmax(eta^(1/lambda), .Machine$double.eps)
  mu.eta <- function(eta) pmax((1/lambda) * eta^(1/lambda - 1), .Machine$double.eps)
  valideta <- function(eta) all(is.finite(eta)) && all(eta > 0)
  link <- paste0("mu^", round(lambda, 3))
  structure(list(linkfun = linkfun, linkinv = linkinv, mu.eta = mu.eta, valideta = valideta, name = link), class = "link-glm")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
power.anova.test
list(`package:stats` = function (groups = NULL, n = NULL, between.var = NULL, within.var = NULL, sig.level = 0.05, power = NULL) 
{
  if (sum(vapply(list(groups, n, between.var, within.var, power, sig.level), is.null, NA)) != 1) 
    stop("exactly one of 'groups', 'n', 'between.var', 'within.var', 'power', and 'sig.level' must be NULL")
  if (!is.null(groups) && groups < 2) 
    stop("number of groups must be at least 2")
  if (!is.null(n) && n < 2) 
    stop("number of observations in each group must be at least 2")
  assert_NULL_or_prob(sig.level)
  assert_NULL_or_prob(power)
  p.body <- quote({
    lambda <- (groups - 1) * n * (between.var/within.var)
    pf(qf(sig.level, groups - 1, (n - 1) * groups, lower.tail = FALSE), groups - 1, (n - 1) * groups, lambda, lower.tail = FALSE)
  })
  if (is.null(power)) 
    power <- eval(p.body)
  else if (is.null(groups)) 
    groups <- uniroot(function(groups) eval(p.body) - power, c(2, 100))$root
  else if (is.null(n)) 
    n <- uniroot(function(n) eval(p.body) - power, c(2, 1e+05))$root
  else if (is.null(within.var)) 
    within.var <- uniroot(function(within.var) eval(p.body) - power, between.var * c(1e-07, 1e+07))$root
  else if (is.null(between.var)) 
    between.var <- uniroot(function(between.var) eval(p.body) - power, within.var * c(1e-07, 1e+07))$root
  else if (is.null(sig.level)) 
    sig.level <- uniroot(function(sig.level) eval(p.body) - power, c(1e-10, 1 - 1e-10))$root
  else stop("internal error", domain = NA)
  NOTE <- "n is number in each group"
  METHOD <- "Balanced one-way analysis of variance power calculation"
  structure(list(groups = groups, n = n, between.var = between.var, within.var = within.var, sig.level = sig.level, power = power, note = NOTE, method = METHOD), class = "power.htest")
}, function (groups = NULL, n = NULL, between.var = NULL, within.var = NULL, sig.level = 0.05, power = NULL) 
{
  if (sum(vapply(list(groups, n, between.var, within.var, power, sig.level), is.null, NA)) != 1) 
    stop("exactly one of 'groups', 'n', 'between.var', 'within.var', 'power', and 'sig.level' must be NULL")
  if (!is.null(groups) && groups < 2) 
    stop("number of groups must be at least 2")
  if (!is.null(n) && n < 2) 
    stop("number of observations in each group must be at least 2")
  assert_NULL_or_prob(sig.level)
  assert_NULL_or_prob(power)
  p.body <- quote({
    lambda <- (groups - 1) * n * (between.var/within.var)
    pf(qf(sig.level, groups - 1, (n - 1) * groups, lower.tail = FALSE), groups - 1, (n - 1) * groups, lambda, lower.tail = FALSE)
  })
  if (is.null(power)) 
    power <- eval(p.body)
  else if (is.null(groups)) 
    groups <- uniroot(function(groups) eval(p.body) - power, c(2, 100))$root
  else if (is.null(n)) 
    n <- uniroot(function(n) eval(p.body) - power, c(2, 1e+05))$root
  else if (is.null(within.var)) 
    within.var <- uniroot(function(within.var) eval(p.body) - power, between.var * c(1e-07, 1e+07))$root
  else if (is.null(between.var)) 
    between.var <- uniroot(function(between.var) eval(p.body) - power, within.var * c(1e-07, 1e+07))$root
  else if (is.null(sig.level)) 
    sig.level <- uniroot(function(sig.level) eval(p.body) - power, c(1e-10, 1 - 1e-10))$root
  else stop("internal error", domain = NA)
  NOTE <- "n is number in each group"
  METHOD <- "Balanced one-way analysis of variance power calculation"
  structure(list(groups = groups, n = n, between.var = between.var, within.var = within.var, sig.level = sig.level, power = power, note = NOTE, method = METHOD), class = "power.htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
power.prop.test
list(`package:stats` = function (n = NULL, p1 = NULL, p2 = NULL, sig.level = 0.05, power = NULL, alternative = c("two.sided", "one.sided"), strict = FALSE, tol = .Machine$double.eps^0.25) 
{
  if (sum(vapply(list(n, p1, p2, power, sig.level), is.null, NA)) != 1) 
    stop("exactly one of 'n', 'p1', 'p2', 'power', and 'sig.level' must be NULL")
  assert_NULL_or_prob(sig.level)
  assert_NULL_or_prob(power)
  alternative <- match.arg(alternative)
  tside <- switch(alternative, one.sided = 1, two.sided = 2)
  p.body <- if (strict && tside == 2) 
    quote({
      qu <- qnorm(sig.level/tside, lower.tail = FALSE)
      d <- abs(p1 - p2)
      q1 <- 1 - p1
      q2 <- 1 - p2
      pbar <- (p1 + p2)/2
      qbar <- 1 - pbar
      v1 <- p1 * q1
      v2 <- p2 * q2
      vbar <- pbar * qbar
      pnorm((sqrt(n) * d - qu * sqrt(2 * vbar))/sqrt(v1 + v2)) + pnorm((sqrt(n) * d + qu * sqrt(2 * vbar))/sqrt(v1 + v2), lower.tail = FALSE)
    })
  else quote(pnorm((sqrt(n) * abs(p1 - p2) - (qnorm(sig.level/tside, lower.tail = FALSE) * sqrt((p1 + p2) * (1 - (p1 + p2)/2))))/sqrt(p1 * (1 - p1) + p2 * (1 - p2))))
  if (is.null(power)) 
    power <- eval(p.body)
  else if (is.null(n)) 
    n <- uniroot(function(n) eval(p.body) - power, c(1, 1e+07), tol = tol, extendInt = "upX")$root
  else if (is.null(p1)) {
    p1 <- uniroot(function(p1) eval(p.body) - power, c(0, p2), tol = tol, extendInt = "yes")$root
    if (p1 < 0) 
      warning("No p1 in [0, p2] can be found to achieve the desired power")
  }
  else if (is.null(p2)) {
    p2 <- uniroot(function(p2) eval(p.body) - power, c(p1, 1), tol = tol, extendInt = "yes")$root
    if (p2 > 1) 
      warning("No p2 in [p1, 1] can be found to achieve the desired power")
  }
  else if (is.null(sig.level)) {
    sig.level <- uniroot(function(sig.level) eval(p.body) - power, c(1e-10, 1 - 1e-10), tol = tol, extendInt = "upX")$root
    if (sig.level < 0 || sig.level > 1) 
      warning("No significance level [0, 1] can be found to achieve the desired power")
  }
  else stop("internal error", domain = NA)
  structure(list(n = n, p1 = p1, p2 = p2, sig.level = sig.level, power = power, alternative = alternative, note = "n is number in *each* group", method = "Two-sample comparison of proportions power calculation"), class = "power.htest")
}, function (n = NULL, p1 = NULL, p2 = NULL, sig.level = 0.05, power = NULL, alternative = c("two.sided", "one.sided"), strict = FALSE, tol = .Machine$double.eps^0.25) 
{
  if (sum(vapply(list(n, p1, p2, power, sig.level), is.null, NA)) != 1) 
    stop("exactly one of 'n', 'p1', 'p2', 'power', and 'sig.level' must be NULL")
  assert_NULL_or_prob(sig.level)
  assert_NULL_or_prob(power)
  alternative <- match.arg(alternative)
  tside <- switch(alternative, one.sided = 1, two.sided = 2)
  p.body <- if (strict && tside == 2) 
    quote({
      qu <- qnorm(sig.level/tside, lower.tail = FALSE)
      d <- abs(p1 - p2)
      q1 <- 1 - p1
      q2 <- 1 - p2
      pbar <- (p1 + p2)/2
      qbar <- 1 - pbar
      v1 <- p1 * q1
      v2 <- p2 * q2
      vbar <- pbar * qbar
      pnorm((sqrt(n) * d - qu * sqrt(2 * vbar))/sqrt(v1 + v2)) + pnorm((sqrt(n) * d + qu * sqrt(2 * vbar))/sqrt(v1 + v2), lower.tail = FALSE)
    })
  else quote(pnorm((sqrt(n) * abs(p1 - p2) - (qnorm(sig.level/tside, lower.tail = FALSE) * sqrt((p1 + p2) * (1 - (p1 + p2)/2))))/sqrt(p1 * (1 - p1) + p2 * (1 - p2))))
  if (is.null(power)) 
    power <- eval(p.body)
  else if (is.null(n)) 
    n <- uniroot(function(n) eval(p.body) - power, c(1, 1e+07), tol = tol, extendInt = "upX")$root
  else if (is.null(p1)) {
    p1 <- uniroot(function(p1) eval(p.body) - power, c(0, p2), tol = tol, extendInt = "yes")$root
    if (p1 < 0) 
      warning("No p1 in [0, p2] can be found to achieve the desired power")
  }
  else if (is.null(p2)) {
    p2 <- uniroot(function(p2) eval(p.body) - power, c(p1, 1), tol = tol, extendInt = "yes")$root
    if (p2 > 1) 
      warning("No p2 in [p1, 1] can be found to achieve the desired power")
  }
  else if (is.null(sig.level)) {
    sig.level <- uniroot(function(sig.level) eval(p.body) - power, c(1e-10, 1 - 1e-10), tol = tol, extendInt = "upX")$root
    if (sig.level < 0 || sig.level > 1) 
      warning("No significance level [0, 1] can be found to achieve the desired power")
  }
  else stop("internal error", domain = NA)
  structure(list(n = n, p1 = p1, p2 = p2, sig.level = sig.level, power = power, alternative = alternative, note = "n is number in *each* group", method = "Two-sample comparison of proportions power calculation"), class = "power.htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
power.t.test
list(`package:stats` = function (n = NULL, delta = NULL, sd = 1, sig.level = 0.05, power = NULL, type = c("two.sample", "one.sample", "paired"), alternative = c("two.sided", "one.sided"), strict = FALSE, tol = .Machine$double.eps^0.25) 
{
  if (sum(vapply(list(n, delta, sd, power, sig.level), is.null, NA)) != 1) 
    stop("exactly one of 'n', 'delta', 'sd', 'power', and 'sig.level' must be NULL")
  assert_NULL_or_prob(sig.level)
  assert_NULL_or_prob(power)
  type <- match.arg(type)
  alternative <- match.arg(alternative)
  tsample <- switch(type, one.sample = 1, two.sample = 2, paired = 1)
  force(tsample)
  tside <- switch(alternative, one.sided = 1, two.sided = 2)
  if (tside == 2 && !is.null(delta)) 
    delta <- abs(delta)
  p.body <- if (strict && tside == 2) 
    quote({
      nu <- pmax(1e-07, n - 1) * tsample
      qu <- qt(sig.level/tside, nu, lower.tail = FALSE)
      pt(qu, nu, ncp = sqrt(n/tsample) * delta/sd, lower.tail = FALSE) + pt(-qu, nu, ncp = sqrt(n/tsample) * delta/sd, lower.tail = TRUE)
    })
  else quote({
    nu <- pmax(1e-07, n - 1) * tsample
    pt(qt(sig.level/tside, nu, lower.tail = FALSE), nu, ncp = sqrt(n/tsample) * delta/sd, lower.tail = FALSE)
  })
  if (is.null(power)) 
    power <- eval(p.body)
  else if (is.null(n)) 
    n <- uniroot(function(n) eval(p.body) - power, c(2, 1e+07), tol = tol, extendInt = "upX")$root
  else if (is.null(sd)) 
    sd <- uniroot(function(sd) eval(p.body) - power, delta * c(1e-07, 1e+07), tol = tol, extendInt = "downX")$root
  else if (is.null(delta)) 
    delta <- uniroot(function(delta) eval(p.body) - power, sd * c(1e-07, 1e+07), tol = tol, extendInt = "upX")$root
  else if (is.null(sig.level)) 
    sig.level <- uniroot(function(sig.level) eval(p.body) - power, c(1e-10, 1 - 1e-10), tol = tol, extendInt = "yes")$root
  else stop("internal error", domain = NA)
  NOTE <- switch(type, paired = "n is number of *pairs*, sd is std.dev. of *differences* within pairs", two.sample = "n is number in *each* group", NULL)
  METHOD <- paste(switch(type, one.sample = "One-sample", two.sample = "Two-sample", paired = "Paired"), "t test power calculation")
  structure(list(n = n, delta = delta, sd = sd, sig.level = sig.level, power = power, alternative = alternative, note = NOTE, method = METHOD), class = "power.htest")
}, function (n = NULL, delta = NULL, sd = 1, sig.level = 0.05, power = NULL, type = c("two.sample", "one.sample", "paired"), alternative = c("two.sided", "one.sided"), strict = FALSE, tol = .Machine$double.eps^0.25) 
{
  if (sum(vapply(list(n, delta, sd, power, sig.level), is.null, NA)) != 1) 
    stop("exactly one of 'n', 'delta', 'sd', 'power', and 'sig.level' must be NULL")
  assert_NULL_or_prob(sig.level)
  assert_NULL_or_prob(power)
  type <- match.arg(type)
  alternative <- match.arg(alternative)
  tsample <- switch(type, one.sample = 1, two.sample = 2, paired = 1)
  force(tsample)
  tside <- switch(alternative, one.sided = 1, two.sided = 2)
  if (tside == 2 && !is.null(delta)) 
    delta <- abs(delta)
  p.body <- if (strict && tside == 2) 
    quote({
      nu <- pmax(1e-07, n - 1) * tsample
      qu <- qt(sig.level/tside, nu, lower.tail = FALSE)
      pt(qu, nu, ncp = sqrt(n/tsample) * delta/sd, lower.tail = FALSE) + pt(-qu, nu, ncp = sqrt(n/tsample) * delta/sd, lower.tail = TRUE)
    })
  else quote({
    nu <- pmax(1e-07, n - 1) * tsample
    pt(qt(sig.level/tside, nu, lower.tail = FALSE), nu, ncp = sqrt(n/tsample) * delta/sd, lower.tail = FALSE)
  })
  if (is.null(power)) 
    power <- eval(p.body)
  else if (is.null(n)) 
    n <- uniroot(function(n) eval(p.body) - power, c(2, 1e+07), tol = tol, extendInt = "upX")$root
  else if (is.null(sd)) 
    sd <- uniroot(function(sd) eval(p.body) - power, delta * c(1e-07, 1e+07), tol = tol, extendInt = "downX")$root
  else if (is.null(delta)) 
    delta <- uniroot(function(delta) eval(p.body) - power, sd * c(1e-07, 1e+07), tol = tol, extendInt = "upX")$root
  else if (is.null(sig.level)) 
    sig.level <- uniroot(function(sig.level) eval(p.body) - power, c(1e-10, 1 - 1e-10), tol = tol, extendInt = "yes")$root
  else stop("internal error", domain = NA)
  NOTE <- switch(type, paired = "n is number of *pairs*, sd is std.dev. of *differences* within pairs", two.sample = "n is number in *each* group", NULL)
  METHOD <- paste(switch(type, one.sample = "One-sample", two.sample = "Two-sample", paired = "Paired"), "t test power calculation")
  structure(list(n = n, delta = delta, sd = sd, sig.level = sig.level, power = power, alternative = alternative, note = NOTE, method = METHOD), class = "power.htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
PP.test
list(`package:stats` = function (x, lshort = TRUE) 
{
  if (NCOL(x) > 1) 
    stop("x is not a vector or univariate time series")
  DNAME <- deparse1(substitute(x))
  z <- embed(x, 2)
  yt <- z[, 1]
  yt1 <- z[, 2]
  n <- length(yt)
  u <- (1:n) - n/2
  res <- lm(yt ~ 1 + u + yt1)
  if (res$rank < 3) 
    stop("singularities in regression")
  cf <- coef(summary(res))
  tstat <- (cf[3, 1] - 1)/cf[3, 2]
  u <- residuals(res)
  ssqru <- sum(u^2)/n
  l <- if (lshort) 
    trunc(4 * (n/100)^0.25)
  else trunc(12 * (n/100)^0.25)
  ssqrtl <- ssqru + .Call(C_pp_sum, u, l)
  n2 <- n^2
  trm1 <- n2 * (n2 - 1) * sum(yt1^2)/12
  trm2 <- n * sum(yt1 * (1:n))^2
  trm3 <- n * (n + 1) * sum(yt1 * (1:n)) * sum(yt1)
  trm4 <- (n * (n + 1) * (2 * n + 1) * sum(yt1)^2)/6
  Dx <- trm1 - trm2 + trm3 - trm4
  STAT <- sqrt(ssqru)/sqrt(ssqrtl) * tstat - (n^3)/(4 * sqrt(3) * sqrt(Dx) * sqrt(ssqrtl)) * (ssqrtl - ssqru)
  table <- cbind(c(4.38, 4.15, 4.04, 3.99, 3.98, 3.96), c(3.95, 3.8, 3.73, 3.69, 3.68, 3.66), c(3.6, 3.5, 3.45, 3.43, 3.42, 3.41), c(3.24, 3.18, 3.15, 3.13, 3.13, 3.12), c(1.14, 1.19, 1.22, 1.23, 1.24, 1.25), c(0.8, 0.87, 0.9, 0.92, 0.93, 0.94), c(0.5, 0.58, 0.62, 0.64, 0.65, 0.66), c(0.15, 0.24, 0.28, 0.31, 0.32, 0.33))
  table <- -table
  tablen <- dim(table)[2]
  tableT <- c(25, 50, 100, 250, 500, 1e+05)
  tablep <- c(0.01, 0.025, 0.05, 0.1, 0.9, 0.95, 0.975, 0.99)
  tableipl <- numeric(tablen)
  for (i in (1:tablen)) tableipl[i] <- approx(tableT, table[, i], n, rule = 2)$y
  PVAL <- approx(tableipl, tablep, STAT, rule = 2)$y
  PARAMETER <- l
  METHOD <- "Phillips-Perron Unit Root Test"
  names(STAT) <- "Dickey-Fuller"
  names(PARAMETER) <- "Truncation lag parameter"
  structure(list(statistic = STAT, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME), class = "htest")
}, function (x, lshort = TRUE) 
{
  if (NCOL(x) > 1) 
    stop("x is not a vector or univariate time series")
  DNAME <- deparse1(substitute(x))
  z <- embed(x, 2)
  yt <- z[, 1]
  yt1 <- z[, 2]
  n <- length(yt)
  u <- (1:n) - n/2
  res <- lm(yt ~ 1 + u + yt1)
  if (res$rank < 3) 
    stop("singularities in regression")
  cf <- coef(summary(res))
  tstat <- (cf[3, 1] - 1)/cf[3, 2]
  u <- residuals(res)
  ssqru <- sum(u^2)/n
  l <- if (lshort) 
    trunc(4 * (n/100)^0.25)
  else trunc(12 * (n/100)^0.25)
  ssqrtl <- ssqru + .Call(C_pp_sum, u, l)
  n2 <- n^2
  trm1 <- n2 * (n2 - 1) * sum(yt1^2)/12
  trm2 <- n * sum(yt1 * (1:n))^2
  trm3 <- n * (n + 1) * sum(yt1 * (1:n)) * sum(yt1)
  trm4 <- (n * (n + 1) * (2 * n + 1) * sum(yt1)^2)/6
  Dx <- trm1 - trm2 + trm3 - trm4
  STAT <- sqrt(ssqru)/sqrt(ssqrtl) * tstat - (n^3)/(4 * sqrt(3) * sqrt(Dx) * sqrt(ssqrtl)) * (ssqrtl - ssqru)
  table <- cbind(c(4.38, 4.15, 4.04, 3.99, 3.98, 3.96), c(3.95, 3.8, 3.73, 3.69, 3.68, 3.66), c(3.6, 3.5, 3.45, 3.43, 3.42, 3.41), c(3.24, 3.18, 3.15, 3.13, 3.13, 3.12), c(1.14, 1.19, 1.22, 1.23, 1.24, 1.25), c(0.8, 0.87, 0.9, 0.92, 0.93, 0.94), c(0.5, 0.58, 0.62, 0.64, 0.65, 0.66), c(0.15, 0.24, 0.28, 0.31, 0.32, 0.33))
  table <- -table
  tablen <- dim(table)[2]
  tableT <- c(25, 50, 100, 250, 500, 1e+05)
  tablep <- c(0.01, 0.025, 0.05, 0.1, 0.9, 0.95, 0.975, 0.99)
  tableipl <- numeric(tablen)
  for (i in (1:tablen)) tableipl[i] <- approx(tableT, table[, i], n, rule = 2)$y
  PVAL <- approx(tableipl, tablep, STAT, rule = 2)$y
  PARAMETER <- l
  METHOD <- "Phillips-Perron Unit Root Test"
  names(STAT) <- "Dickey-Fuller"
  names(PARAMETER) <- "Truncation lag parameter"
  structure(list(statistic = STAT, parameter = PARAMETER, p.value = PVAL, method = METHOD, data.name = DNAME), class = "htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ppoints
list(`package:stats` = function (n, a = if (n <= 10) 3/8 else 1/2) 
{
  if (length(n) > 1) 
    n <- length(n)
  if (n > 0) 
    (1:n - a)/(n + 1 - 2 * a)
  else numeric()
}, function (n, a = if (n <= 10) 3/8 else 1/2) 
{
  if (length(n) > 1) 
    n <- length(n)
  if (n > 0) 
    (1:n - a)/(n + 1 - 2 * a)
  else numeric()
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ppois
list(`package:stats` = function (q, lambda, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_ppois, q, lambda, lower.tail, log.p), function (q, lambda, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_ppois, q, lambda, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ppr
list(`package:stats` = function (x, ...) 
  UseMethod("ppr"), function (x, ...) 
    UseMethod("ppr"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
prcomp
list(`package:stats` = function (x, ...) 
  UseMethod("prcomp"), function (x, ...) 
    UseMethod("prcomp"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
predict
list(`package:stats` = function (object, ...) 
  UseMethod("predict"), function (object, ...) 
    UseMethod("predict"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
predict.glm
list(`package:stats` = function (object, newdata = NULL, type = c("link", "response", "terms"), se.fit = FALSE, dispersion = NULL, terms = NULL, na.action = na.pass, ...) 
{
  type <- match.arg(type)
  na.act <- object$na.action
  object$na.action <- NULL
  if (!se.fit) {
    if (missing(newdata)) {
      pred <- switch(type, link = object$linear.predictors, response = object$fitted.values, terms = predict.lm(object, se.fit = se.fit, scale = 1, type = "terms", terms = terms))
      if (!is.null(na.act)) 
        pred <- napredict(na.act, pred)
    }
    else {
      pred <- predict.lm(object, newdata, se.fit, scale = 1, type = if (type == "link") 
        "response"
        else type, terms = terms, na.action = na.action)
      switch(type, response = {
        pred <- family(object)$linkinv(pred)
      }, link = , terms = )
    }
  }
  else {
    if (inherits(object, "survreg")) 
      dispersion <- 1
    if (is.null(dispersion) || dispersion == 0) 
      dispersion <- summary(object, dispersion = dispersion)$dispersion
    residual.scale <- as.vector(sqrt(dispersion))
    pred <- predict.lm(object, newdata, se.fit, scale = residual.scale, type = if (type == "link") 
      "response"
      else type, terms = terms, na.action = na.action)
    fit <- pred$fit
    se.fit <- pred$se.fit
    switch(type, response = {
      se.fit <- se.fit * abs(family(object)$mu.eta(fit))
      fit <- family(object)$linkinv(fit)
    }, link = , terms = )
    if (missing(newdata) && !is.null(na.act)) {
      fit <- napredict(na.act, fit)
      se.fit <- napredict(na.act, se.fit)
    }
    pred <- list(fit = fit, se.fit = se.fit, residual.scale = residual.scale)
  }
  pred
}, function (object, newdata = NULL, type = c("link", "response", "terms"), se.fit = FALSE, dispersion = NULL, terms = NULL, na.action = na.pass, ...) 
{
  type <- match.arg(type)
  na.act <- object$na.action
  object$na.action <- NULL
  if (!se.fit) {
    if (missing(newdata)) {
      pred <- switch(type, link = object$linear.predictors, response = object$fitted.values, terms = predict.lm(object, se.fit = se.fit, scale = 1, type = "terms", terms = terms))
      if (!is.null(na.act)) 
        pred <- napredict(na.act, pred)
    }
    else {
      pred <- predict.lm(object, newdata, se.fit, scale = 1, type = if (type == "link") 
        "response"
        else type, terms = terms, na.action = na.action)
      switch(type, response = {
        pred <- family(object)$linkinv(pred)
      }, link = , terms = )
    }
  }
  else {
    if (inherits(object, "survreg")) 
      dispersion <- 1
    if (is.null(dispersion) || dispersion == 0) 
      dispersion <- summary(object, dispersion = dispersion)$dispersion
    residual.scale <- as.vector(sqrt(dispersion))
    pred <- predict.lm(object, newdata, se.fit, scale = residual.scale, type = if (type == "link") 
      "response"
      else type, terms = terms, na.action = na.action)
    fit <- pred$fit
    se.fit <- pred$se.fit
    switch(type, response = {
      se.fit <- se.fit * abs(family(object)$mu.eta(fit))
      fit <- family(object)$linkinv(fit)
    }, link = , terms = )
    if (missing(newdata) && !is.null(na.act)) {
      fit <- napredict(na.act, fit)
      se.fit <- napredict(na.act, se.fit)
    }
    pred <- list(fit = fit, se.fit = se.fit, residual.scale = residual.scale)
  }
  pred
}, function (object, newdata = NULL, type = c("link", "response", "terms"), se.fit = FALSE, dispersion = NULL, terms = NULL, na.action = na.pass, ...) 
{
  type <- match.arg(type)
  na.act <- object$na.action
  object$na.action <- NULL
  if (!se.fit) {
    if (missing(newdata)) {
      pred <- switch(type, link = object$linear.predictors, response = object$fitted.values, terms = predict.lm(object, se.fit = se.fit, scale = 1, type = "terms", terms = terms))
      if (!is.null(na.act)) 
        pred <- napredict(na.act, pred)
    }
    else {
      pred <- predict.lm(object, newdata, se.fit, scale = 1, type = if (type == "link") 
        "response"
        else type, terms = terms, na.action = na.action)
      switch(type, response = {
        pred <- family(object)$linkinv(pred)
      }, link = , terms = )
    }
  }
  else {
    if (inherits(object, "survreg")) 
      dispersion <- 1
    if (is.null(dispersion) || dispersion == 0) 
      dispersion <- summary(object, dispersion = dispersion)$dispersion
    residual.scale <- as.vector(sqrt(dispersion))
    pred <- predict.lm(object, newdata, se.fit, scale = residual.scale, type = if (type == "link") 
      "response"
      else type, terms = terms, na.action = na.action)
    fit <- pred$fit
    se.fit <- pred$se.fit
    switch(type, response = {
      se.fit <- se.fit * abs(family(object)$mu.eta(fit))
      fit <- family(object)$linkinv(fit)
    }, link = , terms = )
    if (missing(newdata) && !is.null(na.act)) {
      fit <- napredict(na.act, fit)
      se.fit <- napredict(na.act, se.fit)
    }
    pred <- list(fit = fit, se.fit = se.fit, residual.scale = residual.scale)
  }
  pred
})
c("package:stats", "registered S3 method for predict from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
predict.lm
list(`package:stats` = function (object, newdata, se.fit = FALSE, scale = NULL, df = Inf, interval = c("none", "confidence", "prediction"), level = 0.95, type = c("response", "terms"), terms = NULL, na.action = na.pass, pred.var = res.var/weights, weights = 1, ...) 
{
  tt <- terms(object)
  if (!inherits(object, "lm")) 
    warning("calling predict.lm(<fake-lm-object>) ...")
  if (missing(newdata) || is.null(newdata)) {
    mm <- X <- model.matrix(object)
    mmDone <- TRUE
    offset <- object$offset
  }
  else {
    Terms <- delete.response(tt)
    m <- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels)
    if (!is.null(cl <- attr(Terms, "dataClasses"))) 
      .checkMFClasses(cl, m)
    X <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
    offset <- rep(0, nrow(X))
    if (!is.null(off.num <- attr(tt, "offset"))) 
      for (i in off.num) offset <- offset + eval(attr(tt, "variables")[[i + 1]], newdata)
    if (!is.null(object$call$offset)) 
      offset <- offset + eval(object$call$offset, newdata)
    mmDone <- FALSE
  }
  n <- length(object$residuals)
  p <- object$rank
  p1 <- seq_len(p)
  piv <- if (p) 
    qr.lm(object)$pivot[p1]
  if (p < ncol(X) && !(missing(newdata) || is.null(newdata))) 
    warning("prediction from a rank-deficient fit may be misleading")
  beta <- object$coefficients
  predictor <- drop(X[, piv, drop = FALSE] %*% beta[piv])
  if (!is.null(offset)) 
    predictor <- predictor + offset
  interval <- match.arg(interval)
  if (interval == "prediction") {
    if (missing(newdata)) 
      warning("predictions on current data refer to _future_ responses\n")
    if (missing(newdata) && missing(weights)) {
      w <- weights.default(object)
      if (!is.null(w)) {
        weights <- w
        warning("assuming prediction variance inversely proportional to weights used for fitting\n")
      }
    }
    if (!missing(newdata) && missing(weights) && !is.null(object$weights) && missing(pred.var)) 
      warning("Assuming constant prediction variance even though model fit is weighted\n")
    if (inherits(weights, "formula")) {
      if (length(weights) != 2) 
        stop("'weights' as formula should be one-sided")
      d <- if (missing(newdata) || is.null(newdata)) 
        model.frame(object)
      else newdata
      weights <- eval(weights[[2]], d, environment(weights))
    }
  }
  type <- match.arg(type)
  if (se.fit || interval != "none") {
    w <- object$weights
    res.var <- if (is.null(scale)) {
      r <- object$residuals
      rss <- sum(if (is.null(w)) r^2 else r^2 * w)
      df <- object$df.residual
      rss/df
    }
    else scale^2
    if (type != "terms") {
      if (p > 0) {
        XRinv <- if (missing(newdata) && is.null(w)) 
          qr.Q(qr.lm(object))[, p1, drop = FALSE]
        else X[, piv] %*% qr.solve(qr.R(qr.lm(object))[p1, p1])
        ip <- drop(XRinv^2 %*% rep(res.var, p))
      }
      else ip <- rep(0, n)
    }
  }
  if (type == "terms") {
    if (!mmDone) {
      mm <- model.matrix(object)
      mmDone <- TRUE
    }
    aa <- attr(mm, "assign")
    ll <- attr(tt, "term.labels")
    hasintercept <- attr(tt, "intercept") > 0
    if (hasintercept) 
      ll <- c("(Intercept)", ll)
    aaa <- factor(aa, labels = ll)
    asgn <- split(order(aa), aaa)
    if (hasintercept) {
      asgn$"(Intercept)" <- NULL
      avx <- colMeans(mm)
      termsconst <- sum(avx[piv] * beta[piv])
    }
    nterms <- length(asgn)
    if (nterms > 0) {
      predictor <- matrix(ncol = nterms, nrow = NROW(X))
      dimnames(predictor) <- list(rownames(X), names(asgn))
      if (se.fit || interval != "none") {
        ip <- matrix(ncol = nterms, nrow = NROW(X))
        dimnames(ip) <- list(rownames(X), names(asgn))
        Rinv <- qr.solve(qr.R(qr.lm(object))[p1, p1])
      }
      if (hasintercept) 
        X <- sweep(X, 2, avx, check.margin = FALSE)
      unpiv <- rep.int(0, NCOL(X))
      unpiv[piv] <- p1
      for (i in seq.int(1, nterms, length.out = nterms)) {
        iipiv <- asgn[[i]]
        ii <- unpiv[iipiv]
        iipiv[ii == 0] <- 0
        predictor[, i] <- if (any(iipiv > 0)) 
          X[, iipiv, drop = FALSE] %*% beta[iipiv]
        else 0
        if (se.fit || interval != "none") 
          ip[, i] <- if (any(iipiv > 0)) 
            as.matrix(X[, iipiv, drop = FALSE] %*% Rinv[ii, , drop = FALSE])^2 %*% rep.int(res.var, p)
        else 0
      }
      if (!is.null(terms)) {
        predictor <- predictor[, terms, drop = FALSE]
        if (se.fit) 
          ip <- ip[, terms, drop = FALSE]
      }
    }
    else {
      predictor <- ip <- matrix(0, n, 0)
    }
    attr(predictor, "constant") <- if (hasintercept) 
      termsconst
    else 0
  }
  if (interval != "none") {
    tfrac <- qt((1 - level)/2, df)
    hwid <- tfrac * switch(interval, confidence = sqrt(ip), prediction = sqrt(ip + pred.var))
    if (type != "terms") {
      predictor <- cbind(predictor, predictor + hwid %o% c(1, -1))
      colnames(predictor) <- c("fit", "lwr", "upr")
    }
    else {
      if (!is.null(terms)) 
        hwid <- hwid[, terms, drop = FALSE]
      lwr <- predictor + hwid
      upr <- predictor - hwid
    }
  }
  if (se.fit || interval != "none") {
    se <- sqrt(ip)
    if (type == "terms" && !is.null(terms) && !se.fit) 
      se <- se[, terms, drop = FALSE]
  }
  if (missing(newdata) && !is.null(na.act <- object$na.action)) {
    predictor <- napredict(na.act, predictor)
    if (se.fit) 
      se <- napredict(na.act, se)
  }
  if (type == "terms" && interval != "none") {
    if (missing(newdata) && !is.null(na.act)) {
      lwr <- napredict(na.act, lwr)
      upr <- napredict(na.act, upr)
    }
    list(fit = predictor, se.fit = se, lwr = lwr, upr = upr, df = df, residual.scale = sqrt(res.var))
  }
  else if (se.fit) 
    list(fit = predictor, se.fit = se, df = df, residual.scale = sqrt(res.var))
  else predictor
}, function (object, newdata, se.fit = FALSE, scale = NULL, df = Inf, interval = c("none", "confidence", "prediction"), level = 0.95, type = c("response", "terms"), terms = NULL, na.action = na.pass, pred.var = res.var/weights, weights = 1, ...) 
{
  tt <- terms(object)
  if (!inherits(object, "lm")) 
    warning("calling predict.lm(<fake-lm-object>) ...")
  if (missing(newdata) || is.null(newdata)) {
    mm <- X <- model.matrix(object)
    mmDone <- TRUE
    offset <- object$offset
  }
  else {
    Terms <- delete.response(tt)
    m <- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels)
    if (!is.null(cl <- attr(Terms, "dataClasses"))) 
      .checkMFClasses(cl, m)
    X <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
    offset <- rep(0, nrow(X))
    if (!is.null(off.num <- attr(tt, "offset"))) 
      for (i in off.num) offset <- offset + eval(attr(tt, "variables")[[i + 1]], newdata)
    if (!is.null(object$call$offset)) 
      offset <- offset + eval(object$call$offset, newdata)
    mmDone <- FALSE
  }
  n <- length(object$residuals)
  p <- object$rank
  p1 <- seq_len(p)
  piv <- if (p) 
    qr.lm(object)$pivot[p1]
  if (p < ncol(X) && !(missing(newdata) || is.null(newdata))) 
    warning("prediction from a rank-deficient fit may be misleading")
  beta <- object$coefficients
  predictor <- drop(X[, piv, drop = FALSE] %*% beta[piv])
  if (!is.null(offset)) 
    predictor <- predictor + offset
  interval <- match.arg(interval)
  if (interval == "prediction") {
    if (missing(newdata)) 
      warning("predictions on current data refer to _future_ responses\n")
    if (missing(newdata) && missing(weights)) {
      w <- weights.default(object)
      if (!is.null(w)) {
        weights <- w
        warning("assuming prediction variance inversely proportional to weights used for fitting\n")
      }
    }
    if (!missing(newdata) && missing(weights) && !is.null(object$weights) && missing(pred.var)) 
      warning("Assuming constant prediction variance even though model fit is weighted\n")
    if (inherits(weights, "formula")) {
      if (length(weights) != 2) 
        stop("'weights' as formula should be one-sided")
      d <- if (missing(newdata) || is.null(newdata)) 
        model.frame(object)
      else newdata
      weights <- eval(weights[[2]], d, environment(weights))
    }
  }
  type <- match.arg(type)
  if (se.fit || interval != "none") {
    w <- object$weights
    res.var <- if (is.null(scale)) {
      r <- object$residuals
      rss <- sum(if (is.null(w)) r^2 else r^2 * w)
      df <- object$df.residual
      rss/df
    }
    else scale^2
    if (type != "terms") {
      if (p > 0) {
        XRinv <- if (missing(newdata) && is.null(w)) 
          qr.Q(qr.lm(object))[, p1, drop = FALSE]
        else X[, piv] %*% qr.solve(qr.R(qr.lm(object))[p1, p1])
        ip <- drop(XRinv^2 %*% rep(res.var, p))
      }
      else ip <- rep(0, n)
    }
  }
  if (type == "terms") {
    if (!mmDone) {
      mm <- model.matrix(object)
      mmDone <- TRUE
    }
    aa <- attr(mm, "assign")
    ll <- attr(tt, "term.labels")
    hasintercept <- attr(tt, "intercept") > 0
    if (hasintercept) 
      ll <- c("(Intercept)", ll)
    aaa <- factor(aa, labels = ll)
    asgn <- split(order(aa), aaa)
    if (hasintercept) {
      asgn$"(Intercept)" <- NULL
      avx <- colMeans(mm)
      termsconst <- sum(avx[piv] * beta[piv])
    }
    nterms <- length(asgn)
    if (nterms > 0) {
      predictor <- matrix(ncol = nterms, nrow = NROW(X))
      dimnames(predictor) <- list(rownames(X), names(asgn))
      if (se.fit || interval != "none") {
        ip <- matrix(ncol = nterms, nrow = NROW(X))
        dimnames(ip) <- list(rownames(X), names(asgn))
        Rinv <- qr.solve(qr.R(qr.lm(object))[p1, p1])
      }
      if (hasintercept) 
        X <- sweep(X, 2, avx, check.margin = FALSE)
      unpiv <- rep.int(0, NCOL(X))
      unpiv[piv] <- p1
      for (i in seq.int(1, nterms, length.out = nterms)) {
        iipiv <- asgn[[i]]
        ii <- unpiv[iipiv]
        iipiv[ii == 0] <- 0
        predictor[, i] <- if (any(iipiv > 0)) 
          X[, iipiv, drop = FALSE] %*% beta[iipiv]
        else 0
        if (se.fit || interval != "none") 
          ip[, i] <- if (any(iipiv > 0)) 
            as.matrix(X[, iipiv, drop = FALSE] %*% Rinv[ii, , drop = FALSE])^2 %*% rep.int(res.var, p)
        else 0
      }
      if (!is.null(terms)) {
        predictor <- predictor[, terms, drop = FALSE]
        if (se.fit) 
          ip <- ip[, terms, drop = FALSE]
      }
    }
    else {
      predictor <- ip <- matrix(0, n, 0)
    }
    attr(predictor, "constant") <- if (hasintercept) 
      termsconst
    else 0
  }
  if (interval != "none") {
    tfrac <- qt((1 - level)/2, df)
    hwid <- tfrac * switch(interval, confidence = sqrt(ip), prediction = sqrt(ip + pred.var))
    if (type != "terms") {
      predictor <- cbind(predictor, predictor + hwid %o% c(1, -1))
      colnames(predictor) <- c("fit", "lwr", "upr")
    }
    else {
      if (!is.null(terms)) 
        hwid <- hwid[, terms, drop = FALSE]
      lwr <- predictor + hwid
      upr <- predictor - hwid
    }
  }
  if (se.fit || interval != "none") {
    se <- sqrt(ip)
    if (type == "terms" && !is.null(terms) && !se.fit) 
      se <- se[, terms, drop = FALSE]
  }
  if (missing(newdata) && !is.null(na.act <- object$na.action)) {
    predictor <- napredict(na.act, predictor)
    if (se.fit) 
      se <- napredict(na.act, se)
  }
  if (type == "terms" && interval != "none") {
    if (missing(newdata) && !is.null(na.act)) {
      lwr <- napredict(na.act, lwr)
      upr <- napredict(na.act, upr)
    }
    list(fit = predictor, se.fit = se, lwr = lwr, upr = upr, df = df, residual.scale = sqrt(res.var))
  }
  else if (se.fit) 
    list(fit = predictor, se.fit = se, df = df, residual.scale = sqrt(res.var))
  else predictor
}, function (object, newdata, se.fit = FALSE, scale = NULL, df = Inf, interval = c("none", "confidence", "prediction"), level = 0.95, type = c("response", "terms"), terms = NULL, na.action = na.pass, pred.var = res.var/weights, weights = 1, ...) 
{
  tt <- terms(object)
  if (!inherits(object, "lm")) 
    warning("calling predict.lm(<fake-lm-object>) ...")
  if (missing(newdata) || is.null(newdata)) {
    mm <- X <- model.matrix(object)
    mmDone <- TRUE
    offset <- object$offset
  }
  else {
    Terms <- delete.response(tt)
    m <- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels)
    if (!is.null(cl <- attr(Terms, "dataClasses"))) 
      .checkMFClasses(cl, m)
    X <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
    offset <- rep(0, nrow(X))
    if (!is.null(off.num <- attr(tt, "offset"))) 
      for (i in off.num) offset <- offset + eval(attr(tt, "variables")[[i + 1]], newdata)
    if (!is.null(object$call$offset)) 
      offset <- offset + eval(object$call$offset, newdata)
    mmDone <- FALSE
  }
  n <- length(object$residuals)
  p <- object$rank
  p1 <- seq_len(p)
  piv <- if (p) 
    qr.lm(object)$pivot[p1]
  if (p < ncol(X) && !(missing(newdata) || is.null(newdata))) 
    warning("prediction from a rank-deficient fit may be misleading")
  beta <- object$coefficients
  predictor <- drop(X[, piv, drop = FALSE] %*% beta[piv])
  if (!is.null(offset)) 
    predictor <- predictor + offset
  interval <- match.arg(interval)
  if (interval == "prediction") {
    if (missing(newdata)) 
      warning("predictions on current data refer to _future_ responses\n")
    if (missing(newdata) && missing(weights)) {
      w <- weights.default(object)
      if (!is.null(w)) {
        weights <- w
        warning("assuming prediction variance inversely proportional to weights used for fitting\n")
      }
    }
    if (!missing(newdata) && missing(weights) && !is.null(object$weights) && missing(pred.var)) 
      warning("Assuming constant prediction variance even though model fit is weighted\n")
    if (inherits(weights, "formula")) {
      if (length(weights) != 2) 
        stop("'weights' as formula should be one-sided")
      d <- if (missing(newdata) || is.null(newdata)) 
        model.frame(object)
      else newdata
      weights <- eval(weights[[2]], d, environment(weights))
    }
  }
  type <- match.arg(type)
  if (se.fit || interval != "none") {
    w <- object$weights
    res.var <- if (is.null(scale)) {
      r <- object$residuals
      rss <- sum(if (is.null(w)) r^2 else r^2 * w)
      df <- object$df.residual
      rss/df
    }
    else scale^2
    if (type != "terms") {
      if (p > 0) {
        XRinv <- if (missing(newdata) && is.null(w)) 
          qr.Q(qr.lm(object))[, p1, drop = FALSE]
        else X[, piv] %*% qr.solve(qr.R(qr.lm(object))[p1, p1])
        ip <- drop(XRinv^2 %*% rep(res.var, p))
      }
      else ip <- rep(0, n)
    }
  }
  if (type == "terms") {
    if (!mmDone) {
      mm <- model.matrix(object)
      mmDone <- TRUE
    }
    aa <- attr(mm, "assign")
    ll <- attr(tt, "term.labels")
    hasintercept <- attr(tt, "intercept") > 0
    if (hasintercept) 
      ll <- c("(Intercept)", ll)
    aaa <- factor(aa, labels = ll)
    asgn <- split(order(aa), aaa)
    if (hasintercept) {
      asgn$"(Intercept)" <- NULL
      avx <- colMeans(mm)
      termsconst <- sum(avx[piv] * beta[piv])
    }
    nterms <- length(asgn)
    if (nterms > 0) {
      predictor <- matrix(ncol = nterms, nrow = NROW(X))
      dimnames(predictor) <- list(rownames(X), names(asgn))
      if (se.fit || interval != "none") {
        ip <- matrix(ncol = nterms, nrow = NROW(X))
        dimnames(ip) <- list(rownames(X), names(asgn))
        Rinv <- qr.solve(qr.R(qr.lm(object))[p1, p1])
      }
      if (hasintercept) 
        X <- sweep(X, 2, avx, check.margin = FALSE)
      unpiv <- rep.int(0, NCOL(X))
      unpiv[piv] <- p1
      for (i in seq.int(1, nterms, length.out = nterms)) {
        iipiv <- asgn[[i]]
        ii <- unpiv[iipiv]
        iipiv[ii == 0] <- 0
        predictor[, i] <- if (any(iipiv > 0)) 
          X[, iipiv, drop = FALSE] %*% beta[iipiv]
        else 0
        if (se.fit || interval != "none") 
          ip[, i] <- if (any(iipiv > 0)) 
            as.matrix(X[, iipiv, drop = FALSE] %*% Rinv[ii, , drop = FALSE])^2 %*% rep.int(res.var, p)
        else 0
      }
      if (!is.null(terms)) {
        predictor <- predictor[, terms, drop = FALSE]
        if (se.fit) 
          ip <- ip[, terms, drop = FALSE]
      }
    }
    else {
      predictor <- ip <- matrix(0, n, 0)
    }
    attr(predictor, "constant") <- if (hasintercept) 
      termsconst
    else 0
  }
  if (interval != "none") {
    tfrac <- qt((1 - level)/2, df)
    hwid <- tfrac * switch(interval, confidence = sqrt(ip), prediction = sqrt(ip + pred.var))
    if (type != "terms") {
      predictor <- cbind(predictor, predictor + hwid %o% c(1, -1))
      colnames(predictor) <- c("fit", "lwr", "upr")
    }
    else {
      if (!is.null(terms)) 
        hwid <- hwid[, terms, drop = FALSE]
      lwr <- predictor + hwid
      upr <- predictor - hwid
    }
  }
  if (se.fit || interval != "none") {
    se <- sqrt(ip)
    if (type == "terms" && !is.null(terms) && !se.fit) 
      se <- se[, terms, drop = FALSE]
  }
  if (missing(newdata) && !is.null(na.act <- object$na.action)) {
    predictor <- napredict(na.act, predictor)
    if (se.fit) 
      se <- napredict(na.act, se)
  }
  if (type == "terms" && interval != "none") {
    if (missing(newdata) && !is.null(na.act)) {
      lwr <- napredict(na.act, lwr)
      upr <- napredict(na.act, upr)
    }
    list(fit = predictor, se.fit = se, lwr = lwr, upr = upr, df = df, residual.scale = sqrt(res.var))
  }
  else if (se.fit) 
    list(fit = predictor, se.fit = se, df = df, residual.scale = sqrt(res.var))
  else predictor
})
c("package:stats", "registered S3 method for predict from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
preplot
list(`package:stats` = function (object, ...) 
  UseMethod("preplot"), function (object, ...) 
    UseMethod("preplot"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
princomp
list(`package:stats` = function (x, ...) 
  UseMethod("princomp"), function (x, ...) 
    UseMethod("princomp"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
printCoefmat
list(`package:stats` = function (x, digits = max(3, getOption("digits") - 2), signif.stars = getOption("show.signif.stars"), signif.legend = signif.stars, dig.tst = max(1, min(5, digits - 1)), cs.ind = 1:k, tst.ind = k + 1, zap.ind = integer(), P.values = NULL, has.Pvalue = nc >= 4 && length(cn <- colnames(x)) && substr(cn[nc], 1, 3) %in% c("Pr(", "p-v"), eps.Pvalue = .Machine$double.eps, na.print = "NA", quote = FALSE, right = TRUE, ...) 
{
  if (is.null(d <- dim(x)) || length(d) != 2) 
    stop("'x' must be coefficient matrix/data frame")
  nc <- d[2]
  if (is.null(P.values)) {
    scp <- getOption("show.coef.Pvalues")
    if (!is.logical(scp) || is.na(scp)) {
      warning("option \"show.coef.Pvalues\" is invalid: assuming TRUE")
      scp <- TRUE
    }
    P.values <- has.Pvalue && scp
  }
  else if (P.values && !has.Pvalue) 
    stop("'P.values' is TRUE, but 'has.Pvalue' is not")
  if (has.Pvalue && !P.values) {
    d <- dim(xm <- data.matrix(x[, -nc, drop = FALSE]))
    nc <- nc - 1
    has.Pvalue <- FALSE
  }
  else xm <- data.matrix(x)
  k <- nc - has.Pvalue - (if (missing(tst.ind)) 
    1
    else length(tst.ind))
  if (!missing(cs.ind) && length(cs.ind) > k) 
    stop("wrong k / cs.ind")
  Cf <- array("", dim = d, dimnames = dimnames(xm))
  ok <- !(ina <- is.na(xm))
  for (i in zap.ind) xm[, i] <- zapsmall(xm[, i], digits)
  if (length(cs.ind)) {
    acs <- abs(coef.se <- xm[, cs.ind, drop = FALSE])
    if (any(ia <- is.finite(acs))) {
      digmin <- 1 + if (length(acs <- acs[ia & acs != 0])) 
        floor(log10(range(acs[acs != 0], finite = TRUE)))
      else 0
      Cf[, cs.ind] <- format(round(coef.se, max(1, digits - digmin)), digits = digits)
    }
  }
  if (length(tst.ind)) 
    Cf[, tst.ind] <- format(round(xm[, tst.ind], digits = dig.tst), digits = digits)
  if (any(r.ind <- !((1:nc) %in% c(cs.ind, tst.ind, if (has.Pvalue) nc)))) 
    for (i in which(r.ind)) Cf[, i] <- format(xm[, i], digits = digits)
  ok[, tst.ind] <- FALSE
  okP <- if (has.Pvalue) 
    ok[, -nc]
  else ok
  x1 <- Cf[okP]
  dec <- getOption("OutDec")
  if (dec != ".") 
    x1 <- chartr(dec, ".", x1)
  x0 <- (xm[okP] == 0) != (as.numeric(x1) == 0)
  if (length(not.both.0 <- which(x0 & !is.na(x0)))) {
    Cf[okP][not.both.0] <- format(xm[okP][not.both.0], digits = max(1, digits - 1))
  }
  if (any(ina)) 
    Cf[ina] <- na.print
  if (any(inan <- is.nan(xm))) 
    Cf[inan] <- "NaN"
  if (P.values) {
    if (!is.logical(signif.stars) || is.na(signif.stars)) {
      warning("option \"show.signif.stars\" is invalid: assuming TRUE")
      signif.stars <- TRUE
    }
    if (any(okP <- ok[, nc])) {
      pv <- as.vector(xm[, nc])
      Cf[okP, nc] <- format.pval(pv[okP], digits = dig.tst, eps = eps.Pvalue)
      signif.stars <- signif.stars && any(pv[okP] < 0.1)
      if (signif.stars) {
        Signif <- symnum(pv, corr = FALSE, na = FALSE, cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1), symbols = c("***", "**", "*", ".", " "))
        Cf <- cbind(Cf, format(Signif))
      }
    }
    else signif.stars <- FALSE
  }
  else signif.stars <- FALSE
  print.default(Cf, quote = quote, right = right, na.print = na.print, ...)
  if (signif.stars && signif.legend) {
    if ((w <- getOption("width")) < nchar(sleg <- attr(Signif, "legend"))) 
      sleg <- strwrap(sleg, width = w - 2, prefix = "  ")
    cat("---\nSignif. codes:  ", sleg, sep = "", fill = w + 4 + max(nchar(sleg, "bytes") - nchar(sleg)))
  }
  invisible(x)
}, function (x, digits = max(3, getOption("digits") - 2), signif.stars = getOption("show.signif.stars"), signif.legend = signif.stars, dig.tst = max(1, min(5, digits - 1)), cs.ind = 1:k, tst.ind = k + 1, zap.ind = integer(), P.values = NULL, has.Pvalue = nc >= 4 && length(cn <- colnames(x)) && substr(cn[nc], 1, 3) %in% c("Pr(", "p-v"), eps.Pvalue = .Machine$double.eps, na.print = "NA", quote = FALSE, right = TRUE, ...) 
{
  if (is.null(d <- dim(x)) || length(d) != 2) 
    stop("'x' must be coefficient matrix/data frame")
  nc <- d[2]
  if (is.null(P.values)) {
    scp <- getOption("show.coef.Pvalues")
    if (!is.logical(scp) || is.na(scp)) {
      warning("option \"show.coef.Pvalues\" is invalid: assuming TRUE")
      scp <- TRUE
    }
    P.values <- has.Pvalue && scp
  }
  else if (P.values && !has.Pvalue) 
    stop("'P.values' is TRUE, but 'has.Pvalue' is not")
  if (has.Pvalue && !P.values) {
    d <- dim(xm <- data.matrix(x[, -nc, drop = FALSE]))
    nc <- nc - 1
    has.Pvalue <- FALSE
  }
  else xm <- data.matrix(x)
  k <- nc - has.Pvalue - (if (missing(tst.ind)) 
    1
    else length(tst.ind))
  if (!missing(cs.ind) && length(cs.ind) > k) 
    stop("wrong k / cs.ind")
  Cf <- array("", dim = d, dimnames = dimnames(xm))
  ok <- !(ina <- is.na(xm))
  for (i in zap.ind) xm[, i] <- zapsmall(xm[, i], digits)
  if (length(cs.ind)) {
    acs <- abs(coef.se <- xm[, cs.ind, drop = FALSE])
    if (any(ia <- is.finite(acs))) {
      digmin <- 1 + if (length(acs <- acs[ia & acs != 0])) 
        floor(log10(range(acs[acs != 0], finite = TRUE)))
      else 0
      Cf[, cs.ind] <- format(round(coef.se, max(1, digits - digmin)), digits = digits)
    }
  }
  if (length(tst.ind)) 
    Cf[, tst.ind] <- format(round(xm[, tst.ind], digits = dig.tst), digits = digits)
  if (any(r.ind <- !((1:nc) %in% c(cs.ind, tst.ind, if (has.Pvalue) nc)))) 
    for (i in which(r.ind)) Cf[, i] <- format(xm[, i], digits = digits)
  ok[, tst.ind] <- FALSE
  okP <- if (has.Pvalue) 
    ok[, -nc]
  else ok
  x1 <- Cf[okP]
  dec <- getOption("OutDec")
  if (dec != ".") 
    x1 <- chartr(dec, ".", x1)
  x0 <- (xm[okP] == 0) != (as.numeric(x1) == 0)
  if (length(not.both.0 <- which(x0 & !is.na(x0)))) {
    Cf[okP][not.both.0] <- format(xm[okP][not.both.0], digits = max(1, digits - 1))
  }
  if (any(ina)) 
    Cf[ina] <- na.print
  if (any(inan <- is.nan(xm))) 
    Cf[inan] <- "NaN"
  if (P.values) {
    if (!is.logical(signif.stars) || is.na(signif.stars)) {
      warning("option \"show.signif.stars\" is invalid: assuming TRUE")
      signif.stars <- TRUE
    }
    if (any(okP <- ok[, nc])) {
      pv <- as.vector(xm[, nc])
      Cf[okP, nc] <- format.pval(pv[okP], digits = dig.tst, eps = eps.Pvalue)
      signif.stars <- signif.stars && any(pv[okP] < 0.1)
      if (signif.stars) {
        Signif <- symnum(pv, corr = FALSE, na = FALSE, cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1), symbols = c("***", "**", "*", ".", " "))
        Cf <- cbind(Cf, format(Signif))
      }
    }
    else signif.stars <- FALSE
  }
  else signif.stars <- FALSE
  print.default(Cf, quote = quote, right = right, na.print = na.print, ...)
  if (signif.stars && signif.legend) {
    if ((w <- getOption("width")) < nchar(sleg <- attr(Signif, "legend"))) 
      sleg <- strwrap(sleg, width = w - 2, prefix = "  ")
    cat("---\nSignif. codes:  ", sleg, sep = "", fill = w + 4 + max(nchar(sleg, "bytes") - nchar(sleg)))
  }
  invisible(x)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
profile
list(`package:stats` = function (fitted, ...) 
  UseMethod("profile"), function (fitted, ...) 
    UseMethod("profile"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
proj
list(`package:stats` = function (object, ...) 
  UseMethod("proj"), function (object, ...) 
    UseMethod("proj"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
promax
list(`package:stats` = function (x, m = 4) 
{
  if (ncol(x) < 2) 
    return(x)
  dn <- dimnames(x)
  xx <- varimax(x)
  x <- xx$loadings
  Q <- x * abs(x)^(m - 1)
  U <- lm.fit(x, Q)$coefficients
  d <- diag(solve(t(U) %*% U))
  U <- U %*% diag(sqrt(d))
  dimnames(U) <- NULL
  z <- x %*% U
  U <- xx$rotmat %*% U
  dimnames(z) <- dn
  class(z) <- "loadings"
  list(loadings = z, rotmat = U)
}, function (x, m = 4) 
{
  if (ncol(x) < 2) 
    return(x)
  dn <- dimnames(x)
  xx <- varimax(x)
  x <- xx$loadings
  Q <- x * abs(x)^(m - 1)
  U <- lm.fit(x, Q)$coefficients
  d <- diag(solve(t(U) %*% U))
  U <- U %*% diag(sqrt(d))
  dimnames(U) <- NULL
  z <- x %*% U
  U <- xx$rotmat %*% U
  dimnames(z) <- dn
  class(z) <- "loadings"
  list(loadings = z, rotmat = U)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
prop.test
list(`package:stats` = function (x, n, p = NULL, alternative = c("two.sided", "less", "greater"), conf.level = 0.95, correct = TRUE) 
{
  DNAME <- deparse1(substitute(x))
  if (is.table(x) && length(dim(x)) == 1) {
    if (dim(x) != 2) 
      stop("table 'x' should have 2 entries")
    l <- 1
    n <- sum(x)
    x <- x[1]
  }
  else if (is.matrix(x)) {
    if (ncol(x) != 2) 
      stop("'x' must have 2 columns")
    l <- nrow(x)
    n <- rowSums(x)
    x <- x[, 1]
  }
  else {
    DNAME <- paste(DNAME, "out of", deparse1(substitute(n)))
    if ((l <- length(x)) != length(n)) 
      stop("'x' and 'n' must have the same length")
  }
  OK <- complete.cases(x, n)
  x <- x[OK]
  n <- n[OK]
  if ((k <- length(x)) < 1) 
    stop("not enough data")
  if (any(n <= 0)) 
    stop("elements of 'n' must be positive")
  if (any(x < 0)) 
    stop("elements of 'x' must be nonnegative")
  if (any(x > n)) 
    stop("elements of 'x' must not be greater than those of 'n'")
  if (is.null(p) && (k == 1)) 
    p <- 0.5
  if (!is.null(p)) {
    DNAME <- paste0(DNAME, ", null ", if (k == 1) 
      "probability "
      else "probabilities ", deparse1(substitute(p)))
    if (length(p) != l) 
      stop("'p' must have the same length as 'x' and 'n'")
    p <- p[OK]
    if (any((p <= 0) | (p >= 1))) 
      stop("elements of 'p' must be in (0,1)")
  }
  alternative <- match.arg(alternative)
  if (k > 2 || (k == 2) && !is.null(p)) 
    alternative <- "two.sided"
  if ((length(conf.level) != 1) || is.na(conf.level) || (conf.level <= 0) || (conf.level >= 1)) 
    stop("'conf.level' must be a single number between 0 and 1")
  correct <- as.logical(correct)
  ESTIMATE <- setNames(x/n, if (k == 1) 
    "p"
    else paste("prop", 1:l)[OK])
  NVAL <- p
  CINT <- NULL
  YATES <- if (correct && (k <= 2)) 
    0.5
  else 0
  if (k == 1) {
    z <- qnorm(if (alternative == "two.sided") 
      (1 + conf.level)/2
      else conf.level)
    YATES <- min(YATES, abs(x - n * p))
    z22n <- z^2/(2 * n)
    p.c <- ESTIMATE + YATES/n
    p.u <- if (p.c >= 1) 
      1
    else (p.c + z22n + z * sqrt(p.c * (1 - p.c)/n + z22n/(2 * n)))/(1 + 2 * z22n)
    p.c <- ESTIMATE - YATES/n
    p.l <- if (p.c <= 0) 
      0
    else (p.c + z22n - z * sqrt(p.c * (1 - p.c)/n + z22n/(2 * n)))/(1 + 2 * z22n)
    CINT <- switch(alternative, two.sided = c(max(p.l, 0), min(p.u, 1)), greater = c(max(p.l, 0), 1), less = c(0, min(p.u, 1)))
  }
  else if ((k == 2) && is.null(p)) {
    DELTA <- ESTIMATE[1] - ESTIMATE[2]
    YATES <- min(YATES, abs(DELTA)/sum(1/n))
    WIDTH <- (switch(alternative, two.sided = qnorm((1 + conf.level)/2), qnorm(conf.level)) * sqrt(sum(ESTIMATE * (1 - ESTIMATE)/n)) + YATES * sum(1/n))
    CINT <- switch(alternative, two.sided = c(max(DELTA - WIDTH, -1), min(DELTA + WIDTH, 1)), greater = c(max(DELTA - WIDTH, -1), 1), less = c(-1, min(DELTA + WIDTH, 1)))
  }
  if (!is.null(CINT)) 
    attr(CINT, "conf.level") <- conf.level
  METHOD <- paste(if (k == 1) 
    "1-sample proportions test"
    else paste0(k, "-sample test for ", if (is.null(p)) 
      "equality of"
      else "given", " proportions"), if (YATES) 
        "with"
    else "without", "continuity correction")
  if (is.null(p)) {
    p <- sum(x)/sum(n)
    PARAMETER <- k - 1
  }
  else {
    PARAMETER <- k
    names(NVAL) <- names(ESTIMATE)
  }
  names(PARAMETER) <- "df"
  x <- cbind(x, n - x)
  E <- cbind(n * p, n * (1 - p))
  if (any(E < 5)) 
    warning("Chi-squared approximation may be incorrect")
  STATISTIC <- sum((abs(x - E) - YATES)^2/E)
  names(STATISTIC) <- "X-squared"
  if (alternative == "two.sided") 
    PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
  else {
    if (k == 1) 
      z <- sign(ESTIMATE - p) * sqrt(STATISTIC)
    else z <- sign(DELTA) * sqrt(STATISTIC)
    PVAL <- pnorm(z, lower.tail = (alternative == "less"))
  }
  RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = as.numeric(PVAL), estimate = ESTIMATE, null.value = NVAL, conf.int = CINT, alternative = alternative, method = METHOD, data.name = DNAME)
  class(RVAL) <- "htest"
  return(RVAL)
}, function (x, n, p = NULL, alternative = c("two.sided", "less", "greater"), conf.level = 0.95, correct = TRUE) 
{
  DNAME <- deparse1(substitute(x))
  if (is.table(x) && length(dim(x)) == 1) {
    if (dim(x) != 2) 
      stop("table 'x' should have 2 entries")
    l <- 1
    n <- sum(x)
    x <- x[1]
  }
  else if (is.matrix(x)) {
    if (ncol(x) != 2) 
      stop("'x' must have 2 columns")
    l <- nrow(x)
    n <- rowSums(x)
    x <- x[, 1]
  }
  else {
    DNAME <- paste(DNAME, "out of", deparse1(substitute(n)))
    if ((l <- length(x)) != length(n)) 
      stop("'x' and 'n' must have the same length")
  }
  OK <- complete.cases(x, n)
  x <- x[OK]
  n <- n[OK]
  if ((k <- length(x)) < 1) 
    stop("not enough data")
  if (any(n <= 0)) 
    stop("elements of 'n' must be positive")
  if (any(x < 0)) 
    stop("elements of 'x' must be nonnegative")
  if (any(x > n)) 
    stop("elements of 'x' must not be greater than those of 'n'")
  if (is.null(p) && (k == 1)) 
    p <- 0.5
  if (!is.null(p)) {
    DNAME <- paste0(DNAME, ", null ", if (k == 1) 
      "probability "
      else "probabilities ", deparse1(substitute(p)))
    if (length(p) != l) 
      stop("'p' must have the same length as 'x' and 'n'")
    p <- p[OK]
    if (any((p <= 0) | (p >= 1))) 
      stop("elements of 'p' must be in (0,1)")
  }
  alternative <- match.arg(alternative)
  if (k > 2 || (k == 2) && !is.null(p)) 
    alternative <- "two.sided"
  if ((length(conf.level) != 1) || is.na(conf.level) || (conf.level <= 0) || (conf.level >= 1)) 
    stop("'conf.level' must be a single number between 0 and 1")
  correct <- as.logical(correct)
  ESTIMATE <- setNames(x/n, if (k == 1) 
    "p"
    else paste("prop", 1:l)[OK])
  NVAL <- p
  CINT <- NULL
  YATES <- if (correct && (k <= 2)) 
    0.5
  else 0
  if (k == 1) {
    z <- qnorm(if (alternative == "two.sided") 
      (1 + conf.level)/2
      else conf.level)
    YATES <- min(YATES, abs(x - n * p))
    z22n <- z^2/(2 * n)
    p.c <- ESTIMATE + YATES/n
    p.u <- if (p.c >= 1) 
      1
    else (p.c + z22n + z * sqrt(p.c * (1 - p.c)/n + z22n/(2 * n)))/(1 + 2 * z22n)
    p.c <- ESTIMATE - YATES/n
    p.l <- if (p.c <= 0) 
      0
    else (p.c + z22n - z * sqrt(p.c * (1 - p.c)/n + z22n/(2 * n)))/(1 + 2 * z22n)
    CINT <- switch(alternative, two.sided = c(max(p.l, 0), min(p.u, 1)), greater = c(max(p.l, 0), 1), less = c(0, min(p.u, 1)))
  }
  else if ((k == 2) && is.null(p)) {
    DELTA <- ESTIMATE[1] - ESTIMATE[2]
    YATES <- min(YATES, abs(DELTA)/sum(1/n))
    WIDTH <- (switch(alternative, two.sided = qnorm((1 + conf.level)/2), qnorm(conf.level)) * sqrt(sum(ESTIMATE * (1 - ESTIMATE)/n)) + YATES * sum(1/n))
    CINT <- switch(alternative, two.sided = c(max(DELTA - WIDTH, -1), min(DELTA + WIDTH, 1)), greater = c(max(DELTA - WIDTH, -1), 1), less = c(-1, min(DELTA + WIDTH, 1)))
  }
  if (!is.null(CINT)) 
    attr(CINT, "conf.level") <- conf.level
  METHOD <- paste(if (k == 1) 
    "1-sample proportions test"
    else paste0(k, "-sample test for ", if (is.null(p)) 
      "equality of"
      else "given", " proportions"), if (YATES) 
        "with"
    else "without", "continuity correction")
  if (is.null(p)) {
    p <- sum(x)/sum(n)
    PARAMETER <- k - 1
  }
  else {
    PARAMETER <- k
    names(NVAL) <- names(ESTIMATE)
  }
  names(PARAMETER) <- "df"
  x <- cbind(x, n - x)
  E <- cbind(n * p, n * (1 - p))
  if (any(E < 5)) 
    warning("Chi-squared approximation may be incorrect")
  STATISTIC <- sum((abs(x - E) - YATES)^2/E)
  names(STATISTIC) <- "X-squared"
  if (alternative == "two.sided") 
    PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)
  else {
    if (k == 1) 
      z <- sign(ESTIMATE - p) * sqrt(STATISTIC)
    else z <- sign(DELTA) * sqrt(STATISTIC)
    PVAL <- pnorm(z, lower.tail = (alternative == "less"))
  }
  RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, p.value = as.numeric(PVAL), estimate = ESTIMATE, null.value = NVAL, conf.int = CINT, alternative = alternative, method = METHOD, data.name = DNAME)
  class(RVAL) <- "htest"
  return(RVAL)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
prop.trend.test
list(`package:stats` = function (x, n, score = seq_along(x)) 
{
  method <- "Chi-squared Test for Trend in Proportions"
  dname <- paste(deparse1(substitute(x)), "out of", deparse1(substitute(n)), ",\n using scores:", paste(score, collapse = " "))
  x <- as.vector(x)
  n <- as.vector(n)
  p <- sum(x)/sum(n)
  w <- n/p/(1 - p)
  a <- anova(lm(freq ~ score, data = list(freq = x/n, score = as.vector(score)), weights = w))
  chisq <- c(`X-squared` = a["score", "Sum Sq"])
  structure(list(statistic = chisq, parameter = c(df = 1), p.value = pchisq(as.numeric(chisq), 1, lower.tail = FALSE), method = method, data.name = dname), class = "htest")
}, function (x, n, score = seq_along(x)) 
{
  method <- "Chi-squared Test for Trend in Proportions"
  dname <- paste(deparse1(substitute(x)), "out of", deparse1(substitute(n)), ",\n using scores:", paste(score, collapse = " "))
  x <- as.vector(x)
  n <- as.vector(n)
  p <- sum(x)/sum(n)
  w <- n/p/(1 - p)
  a <- anova(lm(freq ~ score, data = list(freq = x/n, score = as.vector(score)), weights = w))
  chisq <- c(`X-squared` = a["score", "Sum Sq"])
  structure(list(statistic = chisq, parameter = c(df = 1), p.value = pchisq(as.numeric(chisq), 1, lower.tail = FALSE), method = method, data.name = dname), class = "htest")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
psignrank
list(`package:stats` = function (q, n, lower.tail = TRUE, log.p = FALSE) 
{
  on.exit(.External(C_signrank_free))
  .Call(C_psignrank, q, n, lower.tail, log.p)
}, function (q, n, lower.tail = TRUE, log.p = FALSE) 
{
  on.exit(.External(C_signrank_free))
  .Call(C_psignrank, q, n, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
psmirnov
list(`package:stats` = function (q, sizes, z = NULL, two.sided = TRUE, exact = TRUE, simulate = FALSE, B = 2000, lower.tail = TRUE, log.p = FALSE) 
{
  if (is.numeric(q)) 
    q <- as.double(q)
  else stop("argument 'q' must be numeric")
  ret <- rep.int(0, length(q))
  ret[is.na(q) | q < -1 | q > 1] <- NA
  IND <- which(!is.na(ret))
  if (!length(IND)) 
    return(ret)
  if (length(sizes) != 2) 
    stop("argument 'sizes' must be a vector of length 2")
  n.x <- sizes[1]
  n.y <- sizes[2]
  if (n.x < 1) 
    stop("not enough 'x' data")
  if (n.y < 1) 
    stop("not enough 'y' data")
  n.x <- floor(n.x)
  n.y <- floor(n.y)
  N <- n.x + n.y
  n <- n.x * n.y/(n.x + n.y)
  exact <- exact && !simulate
  if (!exact) {
    if (simulate) {
      Dsim <- rsmirnov(B, sizes = sizes, z = z, two.sided = two.sided)
      ret[IND] <- ecdf(Dsim)(q[IND] - sqrt(.Machine$double.eps))
      if (log.p & lower.tail) 
        return(log(ret))
      if (!log.p & lower.tail) 
        return(ret)
      if (log.p & !lower.tail) 
        return(log1p(-ret))
      if (!log.p & !lower.tail) 
        return(1 - ret)
    }
    if (two.sided) {
      ret[IND] <- .Call(C_pKS2, p = sqrt(n) * q[IND], tol = 1e-06)
      ret[q < .Machine$double.eps] <- 0
    }
    else {
      ret[IND] <- 1 - exp(-2 * n * q^2)
    }
    if (log.p & lower.tail) 
      return(log(ret))
    if (!log.p & lower.tail) 
      return(ret)
    if (log.p & !lower.tail) 
      return(log1p(-ret))
    if (!log.p & !lower.tail) 
      return(1 - ret)
  }
  if (is.null(z)) {
    ret[IND] <- sapply(q[IND], function(x) .Call(C_pSmirnov2x, x, n.x, n.y))
    if (log.p & lower.tail) 
      return(log(ret))
    if (!log.p & lower.tail) 
      return(ret)
    if (log.p & !lower.tail) 
      return(log1p(-ret))
    if (!log.p & !lower.tail) 
      return(1 - ret)
  }
  TIES <- if (!is.null(z)) 
    c(diff(sort(z)) != 0, TRUE)
  else rep.int(TRUE, N)
  stat <- (0.5 + floor(as.double(q) * n.x * n.y - 1e-07))/(n.x * n.y)
  pfun <- function(q) {
    k <- diag <- 1
    u <- 0
    repeat {
      u <- c(u, 1 + u[length(u)])
      v <- k - u
      diag_bit <- (u <= n.x) & (v <= n.y) & (u >= 0) & (v >= 0)
      u <- u[diag_bit]
      v <- v[diag_bit]
      d <- u/n.x - v/n.y
      if (two.sided) 
        d <- abs(d)
      diag <- (c(diag, 0) + c(0, diag))[diag_bit]
      if (TIES[k]) 
        diag <- diag * (q > d)
      k <- k + 1
      if (N < k) 
        break
    }
    diag
  }
  ret[IND] <- sapply(stat[IND], pfun)
  if (any(!is.finite(ret[IND]))) {
    warning("computation of exact probability failed, returning Monte Carlo approximation")
    return(psmirnov(q = q, sizes = c(n.x, n.y), z = z, two.sided = two.sided, exact = FALSE, simulate = TRUE, B = B, lower.tail = lower.tail, log.p = log.p))
  }
  logdenom <- lgamma(N + 1) - lgamma(n.x + 1) - lgamma(n.y + 1)
  if (log.p & lower.tail) 
    return(log(ret) - logdenom)
  if (!log.p & lower.tail) 
    return(ret/exp(logdenom))
  if (log.p & !lower.tail) 
    return(log1p(-ret/exp(logdenom)))
  if (!log.p & !lower.tail) 
    return(1 - ret/exp(logdenom))
}, function (q, sizes, z = NULL, two.sided = TRUE, exact = TRUE, simulate = FALSE, B = 2000, lower.tail = TRUE, log.p = FALSE) 
{
  if (is.numeric(q)) 
    q <- as.double(q)
  else stop("argument 'q' must be numeric")
  ret <- rep.int(0, length(q))
  ret[is.na(q) | q < -1 | q > 1] <- NA
  IND <- which(!is.na(ret))
  if (!length(IND)) 
    return(ret)
  if (length(sizes) != 2) 
    stop("argument 'sizes' must be a vector of length 2")
  n.x <- sizes[1]
  n.y <- sizes[2]
  if (n.x < 1) 
    stop("not enough 'x' data")
  if (n.y < 1) 
    stop("not enough 'y' data")
  n.x <- floor(n.x)
  n.y <- floor(n.y)
  N <- n.x + n.y
  n <- n.x * n.y/(n.x + n.y)
  exact <- exact && !simulate
  if (!exact) {
    if (simulate) {
      Dsim <- rsmirnov(B, sizes = sizes, z = z, two.sided = two.sided)
      ret[IND] <- ecdf(Dsim)(q[IND] - sqrt(.Machine$double.eps))
      if (log.p & lower.tail) 
        return(log(ret))
      if (!log.p & lower.tail) 
        return(ret)
      if (log.p & !lower.tail) 
        return(log1p(-ret))
      if (!log.p & !lower.tail) 
        return(1 - ret)
    }
    if (two.sided) {
      ret[IND] <- .Call(C_pKS2, p = sqrt(n) * q[IND], tol = 1e-06)
      ret[q < .Machine$double.eps] <- 0
    }
    else {
      ret[IND] <- 1 - exp(-2 * n * q^2)
    }
    if (log.p & lower.tail) 
      return(log(ret))
    if (!log.p & lower.tail) 
      return(ret)
    if (log.p & !lower.tail) 
      return(log1p(-ret))
    if (!log.p & !lower.tail) 
      return(1 - ret)
  }
  if (is.null(z)) {
    ret[IND] <- sapply(q[IND], function(x) .Call(C_pSmirnov2x, x, n.x, n.y))
    if (log.p & lower.tail) 
      return(log(ret))
    if (!log.p & lower.tail) 
      return(ret)
    if (log.p & !lower.tail) 
      return(log1p(-ret))
    if (!log.p & !lower.tail) 
      return(1 - ret)
  }
  TIES <- if (!is.null(z)) 
    c(diff(sort(z)) != 0, TRUE)
  else rep.int(TRUE, N)
  stat <- (0.5 + floor(as.double(q) * n.x * n.y - 1e-07))/(n.x * n.y)
  pfun <- function(q) {
    k <- diag <- 1
    u <- 0
    repeat {
      u <- c(u, 1 + u[length(u)])
      v <- k - u
      diag_bit <- (u <= n.x) & (v <= n.y) & (u >= 0) & (v >= 0)
      u <- u[diag_bit]
      v <- v[diag_bit]
      d <- u/n.x - v/n.y
      if (two.sided) 
        d <- abs(d)
      diag <- (c(diag, 0) + c(0, diag))[diag_bit]
      if (TIES[k]) 
        diag <- diag * (q > d)
      k <- k + 1
      if (N < k) 
        break
    }
    diag
  }
  ret[IND] <- sapply(stat[IND], pfun)
  if (any(!is.finite(ret[IND]))) {
    warning("computation of exact probability failed, returning Monte Carlo approximation")
    return(psmirnov(q = q, sizes = c(n.x, n.y), z = z, two.sided = two.sided, exact = FALSE, simulate = TRUE, B = B, lower.tail = lower.tail, log.p = log.p))
  }
  logdenom <- lgamma(N + 1) - lgamma(n.x + 1) - lgamma(n.y + 1)
  if (log.p & lower.tail) 
    return(log(ret) - logdenom)
  if (!log.p & lower.tail) 
    return(ret/exp(logdenom))
  if (log.p & !lower.tail) 
    return(log1p(-ret/exp(logdenom)))
  if (!log.p & !lower.tail) 
    return(1 - ret/exp(logdenom))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pt
list(`package:stats` = function (q, df, ncp, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_pt, q, df, lower.tail, log.p)
  else .Call(C_pnt, q, df, ncp, lower.tail, log.p)
}, function (q, df, ncp, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_pt, q, df, lower.tail, log.p)
  else .Call(C_pnt, q, df, ncp, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ptukey
list(`package:stats` = function (q, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_ptukey, q, nranges, nmeans, df, lower.tail, log.p), function (q, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_ptukey, q, nranges, nmeans, df, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
punif
list(`package:stats` = function (q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_punif, q, min, max, lower.tail, log.p), function (q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_punif, q, min, max, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pweibull
list(`package:stats` = function (q, shape, scale = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_pweibull, q, shape, scale, lower.tail, log.p), function (q, shape, scale = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_pweibull, q, shape, scale, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
pwilcox
list(`package:stats` = function (q, m, n, lower.tail = TRUE, log.p = FALSE) 
{
  on.exit(.External(C_wilcox_free))
  .Call(C_pwilcox, q, m, n, lower.tail, log.p)
}, function (q, m, n, lower.tail = TRUE, log.p = FALSE) 
{
  on.exit(.External(C_wilcox_free))
  .Call(C_pwilcox, q, m, n, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qbeta
list(`package:stats` = function (p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_qbeta, p, shape1, shape2, lower.tail, log.p)
  else .Call(C_qnbeta, p, shape1, shape2, ncp, lower.tail, log.p)
}, function (p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_qbeta, p, shape1, shape2, lower.tail, log.p)
  else .Call(C_qnbeta, p, shape1, shape2, ncp, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qbinom
list(`package:stats` = function (p, size, prob, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qbinom, p, size, prob, lower.tail, log.p), function (p, size, prob, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qbinom, p, size, prob, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qbirthday
list(`package:stats` = function (prob = 0.5, classes = 365, coincident = 2) 
{
  k <- coincident
  c <- classes
  p <- prob
  if (p <= 0) 
    return(1)
  if (p >= 1) 
    return(c * (k - 1) + 1)
  N <- exp(((k - 1) * log(c) + lgamma(k + 1) + log(-log1p(-p)))/k)
  N <- ceiling(N)
  if (pbirthday(N, c, k) < prob) {
    N <- N + 1
    while (pbirthday(N, c, k) < prob) N <- N + 1
  }
  else if (pbirthday(N - 1, c, k) >= prob) {
    N <- N - 1
    while (pbirthday(N - 1, c, k) >= prob) N <- N - 1
  }
  N
}, function (prob = 0.5, classes = 365, coincident = 2) 
{
  k <- coincident
  c <- classes
  p <- prob
  if (p <= 0) 
    return(1)
  if (p >= 1) 
    return(c * (k - 1) + 1)
  N <- exp(((k - 1) * log(c) + lgamma(k + 1) + log(-log1p(-p)))/k)
  N <- ceiling(N)
  if (pbirthday(N, c, k) < prob) {
    N <- N + 1
    while (pbirthday(N, c, k) < prob) N <- N + 1
  }
  else if (pbirthday(N - 1, c, k) >= prob) {
    N <- N - 1
    while (pbirthday(N - 1, c, k) >= prob) N <- N - 1
  }
  N
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qcauchy
list(`package:stats` = function (p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qcauchy, p, location, scale, lower.tail, log.p), function (p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qcauchy, p, location, scale, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qchisq
list(`package:stats` = function (p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_qchisq, p, df, lower.tail, log.p)
  else .Call(C_qnchisq, p, df, ncp, lower.tail, log.p)
}, function (p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_qchisq, p, df, lower.tail, log.p)
  else .Call(C_qnchisq, p, df, ncp, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qexp
list(`package:stats` = function (p, rate = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qexp, p, 1/rate, lower.tail, log.p), function (p, rate = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qexp, p, 1/rate, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qf
list(`package:stats` = function (p, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_qf, p, df1, df2, lower.tail, log.p)
  else .Call(C_qnf, p, df1, df2, ncp, lower.tail, log.p)
}, function (p, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_qf, p, df1, df2, lower.tail, log.p)
  else .Call(C_qnf, p, df1, df2, ncp, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qgamma
list(`package:stats` = function (p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) 
{
  if (!missing(rate) && !missing(scale)) {
    if (abs(rate * scale - 1) < 1e-15) 
      warning("specify 'rate' or 'scale' but not both")
    else stop("specify 'rate' or 'scale' but not both")
  }
  .Call(C_qgamma, p, shape, scale, lower.tail, log.p)
}, function (p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) 
{
  if (!missing(rate) && !missing(scale)) {
    if (abs(rate * scale - 1) < 1e-15) 
      warning("specify 'rate' or 'scale' but not both")
    else stop("specify 'rate' or 'scale' but not both")
  }
  .Call(C_qgamma, p, shape, scale, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qgeom
list(`package:stats` = function (p, prob, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qgeom, p, prob, lower.tail, log.p), function (p, prob, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qgeom, p, prob, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qhyper
list(`package:stats` = function (p, m, n, k, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qhyper, p, m, n, k, lower.tail, log.p), function (p, m, n, k, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qhyper, p, m, n, k, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qlnorm
list(`package:stats` = function (p, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qlnorm, p, meanlog, sdlog, lower.tail, log.p), function (p, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qlnorm, p, meanlog, sdlog, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qlogis
list(`package:stats` = function (p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qlogis, p, location, scale, lower.tail, log.p), function (p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qlogis, p, location, scale, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qnbinom
list(`package:stats` = function (p, size, prob, mu, lower.tail = TRUE, log.p = FALSE) 
{
  if (!missing(mu)) {
    if (!missing(prob)) 
      stop("'prob' and 'mu' both specified")
    .Call(C_qnbinom_mu, p, size, mu, lower.tail, log.p)
  }
  else .Call(C_qnbinom, p, size, prob, lower.tail, log.p)
}, function (p, size, prob, mu, lower.tail = TRUE, log.p = FALSE) 
{
  if (!missing(mu)) {
    if (!missing(prob)) 
      stop("'prob' and 'mu' both specified")
    .Call(C_qnbinom_mu, p, size, mu, lower.tail, log.p)
  }
  else .Call(C_qnbinom, p, size, prob, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qnorm
list(`package:stats` = function (p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qnorm, p, mean, sd, lower.tail, log.p), function (p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qnorm, p, mean, sd, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qpois
list(`package:stats` = function (p, lambda, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qpois, p, lambda, lower.tail, log.p), function (p, lambda, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qpois, p, lambda, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qqline
list(`package:stats` = function (y, datax = FALSE, distribution = qnorm, probs = c(0.25, 0.75), qtype = 7, ...) 
{
  stopifnot(length(probs) == 2, is.function(distribution))
  y <- as.vector(quantile(y, probs, names = FALSE, type = qtype, na.rm = TRUE))
  x <- distribution(probs)
  if (datax) {
    slope <- diff(x)/diff(y)
    int <- x[[1]] - slope * y[[1]]
  }
  else {
    slope <- diff(y)/diff(x)
    int <- y[[1]] - slope * x[[1]]
  }
  abline(int, slope, ...)
}, function (y, datax = FALSE, distribution = qnorm, probs = c(0.25, 0.75), qtype = 7, ...) 
{
  stopifnot(length(probs) == 2, is.function(distribution))
  y <- as.vector(quantile(y, probs, names = FALSE, type = qtype, na.rm = TRUE))
  x <- distribution(probs)
  if (datax) {
    slope <- diff(x)/diff(y)
    int <- x[[1]] - slope * y[[1]]
  }
  else {
    slope <- diff(y)/diff(x)
    int <- y[[1]] - slope * x[[1]]
  }
  abline(int, slope, ...)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qqnorm
list(`package:stats` = function (y, ...) 
  UseMethod("qqnorm"), function (y, ...) 
    UseMethod("qqnorm"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qqplot
list(`package:stats` = function (x, y, plot.it = TRUE, xlab = deparse1(substitute(x)), ylab = deparse1(substitute(y)), ...) 
{
  sx <- sort(x)
  sy <- sort(y)
  lenx <- length(sx)
  leny <- length(sy)
  if (leny < lenx) 
    sx <- approx(1:lenx, sx, n = leny)$y
  if (leny > lenx) 
    sy <- approx(1:leny, sy, n = lenx)$y
  if (plot.it) 
    plot(sx, sy, xlab = xlab, ylab = ylab, ...)
  invisible(list(x = sx, y = sy))
}, function (x, y, plot.it = TRUE, xlab = deparse1(substitute(x)), ylab = deparse1(substitute(y)), ...) 
{
  sx <- sort(x)
  sy <- sort(y)
  lenx <- length(sx)
  leny <- length(sy)
  if (leny < lenx) 
    sx <- approx(1:lenx, sx, n = leny)$y
  if (leny > lenx) 
    sy <- approx(1:leny, sy, n = lenx)$y
  if (plot.it) 
    plot(sx, sy, xlab = xlab, ylab = ylab, ...)
  invisible(list(x = sx, y = sy))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qsignrank
list(`package:stats` = function (p, n, lower.tail = TRUE, log.p = FALSE) 
{
  on.exit(.External(C_signrank_free))
  .Call(C_qsignrank, p, n, lower.tail, log.p)
}, function (p, n, lower.tail = TRUE, log.p = FALSE) 
{
  on.exit(.External(C_signrank_free))
  .Call(C_qsignrank, p, n, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qsmirnov
list(`package:stats` = function (p, sizes, z = NULL, two.sided = TRUE, exact = TRUE, simulate = FALSE, B = 2000) 
{
  n.x <- floor(sizes[1])
  n.y <- floor(sizes[2])
  if (n.x * n.y < 10000) {
    stat <- sort(unique(c(outer(0:n.x/n.x, 0:n.y/n.y, "-"))))
  }
  else {
    stat <- (-10000):10000/(10000 + 1)
  }
  if (two.sided) 
    stat <- abs(stat)
  prb <- psmirnov(stat, sizes = sizes, z = z, two.sided = two.sided, exact = exact, simulate = simulate, B = B, log.p = FALSE, lower.tail = TRUE)
  if (is.null(p)) 
    return(list(stat = stat, prob = prb))
  if (is.numeric(p)) 
    p <- as.double(p)
  else stop("argument 'p' must be numeric")
  ret <- rep.int(0, length(p))
  ret[is.na(p) | p < 0 | p > 1] <- NA
  IND <- which(!is.na(ret))
  if (!length(IND)) 
    return(ret)
  ret[IND] <- sapply(p[IND], function(u) min(stat[prb >= u]))
  ret
}, function (p, sizes, z = NULL, two.sided = TRUE, exact = TRUE, simulate = FALSE, B = 2000) 
{
  n.x <- floor(sizes[1])
  n.y <- floor(sizes[2])
  if (n.x * n.y < 10000) {
    stat <- sort(unique(c(outer(0:n.x/n.x, 0:n.y/n.y, "-"))))
  }
  else {
    stat <- (-10000):10000/(10000 + 1)
  }
  if (two.sided) 
    stat <- abs(stat)
  prb <- psmirnov(stat, sizes = sizes, z = z, two.sided = two.sided, exact = exact, simulate = simulate, B = B, log.p = FALSE, lower.tail = TRUE)
  if (is.null(p)) 
    return(list(stat = stat, prob = prb))
  if (is.numeric(p)) 
    p <- as.double(p)
  else stop("argument 'p' must be numeric")
  ret <- rep.int(0, length(p))
  ret[is.na(p) | p < 0 | p > 1] <- NA
  IND <- which(!is.na(ret))
  if (!length(IND)) 
    return(ret)
  ret[IND] <- sapply(p[IND], function(u) min(stat[prb >= u]))
  ret
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qt
list(`package:stats` = function (p, df, ncp, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_qt, p, df, lower.tail, log.p)
  else .Call(C_qnt, p, df, ncp, lower.tail, log.p)
}, function (p, df, ncp, lower.tail = TRUE, log.p = FALSE) 
{
  if (missing(ncp)) 
    .Call(C_qt, p, df, lower.tail, log.p)
  else .Call(C_qnt, p, df, ncp, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qtukey
list(`package:stats` = function (p, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qtukey, p, nranges, nmeans, df, lower.tail, log.p), function (p, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qtukey, p, nranges, nmeans, df, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
quade.test
list(`package:stats` = function (y, ...) 
  UseMethod("quade.test"), function (y, ...) 
    UseMethod("quade.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
quantile
list(`package:stats` = function (x, ...) 
  UseMethod("quantile"), function (x, ...) 
    UseMethod("quantile"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
quasi
list(`package:stats` = function (link = "identity", variance = "constant") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  if (linktemp %in% c("logit", "probit", "cloglog", "identity", "inverse", "log", "1/mu^2", "sqrt")) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    stats <- link
    linktemp <- stats$name %||% deparse(linktemp)
  }
  maybeV <- is.character(vtemp <- substitute(variance)) || (is.symbol(vtemp) && (vtemp == quote(mu) || vtemp == quote(constant))) || (is.call(vtemp) && (length(vtemp) == 2 && vtemp == quote(mu(1 - mu))) || (length(vtemp) == 3 && (vtemp == quote(mu^2) || vtemp == quote(mu^3))))
  if (!maybeV && (is.list(variance) && !anyNA(match(c("varfun", "validmu"), names(variance))))) 
    variance_nm <- NA
  else {
    if (!is.character(vtemp)) 
      vtemp <- deparse(vtemp)
    variance_nm <- vtemp <- gsub(" ", "", vtemp, fixed = TRUE)
    switch(vtemp, constant = {
      varfun <- function(mu) rep.int(1, length(mu))
      dev.resids <- function(y, mu, wt) wt * ((y - mu)^2)
      validmu <- function(mu) TRUE
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- y
      })
    }, `mu(1-mu)` = {
      varfun <- function(mu) mu * (1 - mu)
      validmu <- function(mu) all(mu > 0) && all(mu < 1)
      dev.resids <- function(y, mu, wt) .Call(C_binomial_dev_resids, y, mu, wt)
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- pmax(0.001, pmin(0.999, y))
      })
    }, mu = {
      varfun <- function(mu) mu
      validmu <- function(mu) all(mu > 0)
      dev.resids <- function(y, mu, wt) 2 * wt * (y * log(ifelse(y == 0, 1, y/mu)) - (y - mu))
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- y + 0.1 * (y == 0)
      })
    }, `mu^2` = {
      varfun <- function(mu) mu^2
      validmu <- function(mu) all(mu > 0)
      dev.resids <- function(y, mu, wt) pmax(-2 * wt * (log(ifelse(y == 0, 1, y)/mu) - (y - mu)/mu), 0)
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- y + 0.1 * (y == 0)
      })
    }, `mu^3` = {
      varfun <- function(mu) mu^3
      validmu <- function(mu) all(mu > 0)
      dev.resids <- function(y, mu, wt) wt * ((y - mu)^2)/(y * mu^2)
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- y + 0.1 * (y == 0)
      })
    }, variance_nm <- NA)
  }
  if (is.na(variance_nm)) {
    if (is.character(variance)) 
      stop(gettextf("'variance' \"%s\" is invalid: possible values are \"mu(1-mu)\", \"mu\", \"mu^2\", \"mu^3\" and \"constant\"", vtemp), domain = NA)
    varfun <- variance$varfun
    validmu <- variance$validmu
    dev.resids <- variance$dev.resids
    initialize <- variance$initialize
    variance_nm <- variance$name
  }
  aic <- function(y, n, mu, wt, dev) NA
  structure(list(family = "quasi", link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = varfun, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, varfun = variance_nm), class = "family")
}, function (link = "identity", variance = "constant") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  if (linktemp %in% c("logit", "probit", "cloglog", "identity", "inverse", "log", "1/mu^2", "sqrt")) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    stats <- link
    linktemp <- stats$name %||% deparse(linktemp)
  }
  maybeV <- is.character(vtemp <- substitute(variance)) || (is.symbol(vtemp) && (vtemp == quote(mu) || vtemp == quote(constant))) || (is.call(vtemp) && (length(vtemp) == 2 && vtemp == quote(mu(1 - mu))) || (length(vtemp) == 3 && (vtemp == quote(mu^2) || vtemp == quote(mu^3))))
  if (!maybeV && (is.list(variance) && !anyNA(match(c("varfun", "validmu"), names(variance))))) 
    variance_nm <- NA
  else {
    if (!is.character(vtemp)) 
      vtemp <- deparse(vtemp)
    variance_nm <- vtemp <- gsub(" ", "", vtemp, fixed = TRUE)
    switch(vtemp, constant = {
      varfun <- function(mu) rep.int(1, length(mu))
      dev.resids <- function(y, mu, wt) wt * ((y - mu)^2)
      validmu <- function(mu) TRUE
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- y
      })
    }, `mu(1-mu)` = {
      varfun <- function(mu) mu * (1 - mu)
      validmu <- function(mu) all(mu > 0) && all(mu < 1)
      dev.resids <- function(y, mu, wt) .Call(C_binomial_dev_resids, y, mu, wt)
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- pmax(0.001, pmin(0.999, y))
      })
    }, mu = {
      varfun <- function(mu) mu
      validmu <- function(mu) all(mu > 0)
      dev.resids <- function(y, mu, wt) 2 * wt * (y * log(ifelse(y == 0, 1, y/mu)) - (y - mu))
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- y + 0.1 * (y == 0)
      })
    }, `mu^2` = {
      varfun <- function(mu) mu^2
      validmu <- function(mu) all(mu > 0)
      dev.resids <- function(y, mu, wt) pmax(-2 * wt * (log(ifelse(y == 0, 1, y)/mu) - (y - mu)/mu), 0)
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- y + 0.1 * (y == 0)
      })
    }, `mu^3` = {
      varfun <- function(mu) mu^3
      validmu <- function(mu) all(mu > 0)
      dev.resids <- function(y, mu, wt) wt * ((y - mu)^2)/(y * mu^2)
      initialize <- expression({
        n <- rep.int(1, nobs)
        mustart <- y + 0.1 * (y == 0)
      })
    }, variance_nm <- NA)
  }
  if (is.na(variance_nm)) {
    if (is.character(variance)) 
      stop(gettextf("'variance' \"%s\" is invalid: possible values are \"mu(1-mu)\", \"mu\", \"mu^2\", \"mu^3\" and \"constant\"", vtemp), domain = NA)
    varfun <- variance$varfun
    validmu <- variance$validmu
    dev.resids <- variance$dev.resids
    initialize <- variance$initialize
    variance_nm <- variance$name
  }
  aic <- function(y, n, mu, wt, dev) NA
  structure(list(family = "quasi", link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = varfun, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta, varfun = variance_nm), class = "family")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
quasibinomial
list(`package:stats` = function (link = "logit") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("logit", "probit", "cloglog", "cauchit", "log")
  family <- "quasibinomial"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = function(mu) mu * (1 - mu), dev.resids = function(y, mu, wt) .Call(C_binomial_dev_resids, y, mu, wt), aic = function(y, n, mu, wt, dev) NA, mu.eta = stats$mu.eta, initialize = binomInitialize(family), validmu = function(mu) all(is.finite(mu)) && all(0 < mu & mu < 1), valideta = stats$valideta), class = "family")
}, function (link = "logit") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("logit", "probit", "cloglog", "cauchit", "log")
  family <- "quasibinomial"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = function(mu) mu * (1 - mu), dev.resids = function(y, mu, wt) .Call(C_binomial_dev_resids, y, mu, wt), aic = function(y, n, mu, wt, dev) NA, mu.eta = stats$mu.eta, initialize = binomInitialize(family), validmu = function(mu) all(is.finite(mu)) && all(0 < mu & mu < 1), valideta = stats$valideta), class = "family")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
quasipoisson
list(`package:stats` = function (link = "log") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("log", "identity", "sqrt")
  family <- "quasipoisson"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu
  validmu <- function(mu) all(is.finite(mu)) && all(mu > 0)
  dev.resids <- function(y, mu, wt) {
    r <- mu * wt
    p <- which(y > 0)
    r[p] <- (wt * (y * log(y/mu) - (y - mu)))[p]
    2 * r
  }
  aic <- function(y, n, mu, wt, dev) NA
  initialize <- expression({
    if (any(y < 0)) stop("negative values not allowed for the 'quasiPoisson' family")
    n <- rep.int(1, nobs)
    mustart <- y + 0.1
  })
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta), class = "family")
}, function (link = "log") 
{
  linktemp <- substitute(link)
  if (!is.character(linktemp)) 
    linktemp <- deparse(linktemp)
  okLinks <- c("log", "identity", "sqrt")
  family <- "quasipoisson"
  if (linktemp %in% okLinks) 
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name)) 
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for %s family; available links are %s", linktemp, family, paste(sQuote(okLinks), collapse = ", ")), domain = NA)
    }
  }
  variance <- function(mu) mu
  validmu <- function(mu) all(is.finite(mu)) && all(mu > 0)
  dev.resids <- function(y, mu, wt) {
    r <- mu * wt
    p <- which(y > 0)
    r[p] <- (wt * (y * log(y/mu) - (y - mu)))[p]
    2 * r
  }
  aic <- function(y, n, mu, wt, dev) NA
  initialize <- expression({
    if (any(y < 0)) stop("negative values not allowed for the 'quasiPoisson' family")
    n <- rep.int(1, nobs)
    mustart <- y + 0.1
  })
  structure(list(family = family, link = linktemp, linkfun = stats$linkfun, linkinv = stats$linkinv, variance = variance, dev.resids = dev.resids, aic = aic, mu.eta = stats$mu.eta, initialize = initialize, validmu = validmu, valideta = stats$valideta), class = "family")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qunif
list(`package:stats` = function (p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qunif, p, min, max, lower.tail, log.p), function (p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qunif, p, min, max, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qweibull
list(`package:stats` = function (p, shape, scale = 1, lower.tail = TRUE, log.p = FALSE) 
  .Call(C_qweibull, p, shape, scale, lower.tail, log.p), function (p, shape, scale = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qweibull, p, shape, scale, lower.tail, log.p))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
qwilcox
list(`package:stats` = function (p, m, n, lower.tail = TRUE, log.p = FALSE) 
{
  on.exit(.External(C_wilcox_free))
  .Call(C_qwilcox, p, m, n, lower.tail, log.p)
}, function (p, m, n, lower.tail = TRUE, log.p = FALSE) 
{
  on.exit(.External(C_wilcox_free))
  .Call(C_qwilcox, p, m, n, lower.tail, log.p)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
r2dtable
list(`package:stats` = function (n, r, c) 
{
  if (length(n <- as.integer(n)) == 0 || (n < 0) || is.na(n)) 
    stop("invalid argument 'n'")
  if (length(r <- as.integer(r)) <= 1 || any(r < 0) || anyNA(r)) 
    stop("invalid argument 'r'")
  if (length(c <- as.integer(c)) <= 1 || any(c < 0) || anyNA(c)) 
    stop("invalid argument 'c'")
  if (sum(r) != sum(c)) 
    stop("arguments 'r' and 'c' must have the same sums")
  .Call(C_r2dtable, n, r, c)
}, function (n, r, c) 
{
  if (length(n <- as.integer(n)) == 0 || (n < 0) || is.na(n)) 
    stop("invalid argument 'n'")
  if (length(r <- as.integer(r)) <= 1 || any(r < 0) || anyNA(r)) 
    stop("invalid argument 'r'")
  if (length(c <- as.integer(c)) <= 1 || any(c < 0) || anyNA(c)) 
    stop("invalid argument 'c'")
  if (sum(r) != sum(c)) 
    stop("arguments 'r' and 'c' must have the same sums")
  .Call(C_r2dtable, n, r, c)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rbeta
list(`package:stats` = function (n, shape1, shape2, ncp = 0) 
{
  if (missing(ncp)) 
    .Call(C_rbeta, n, shape1, shape2)
  else {
    X <- rchisq(n, 2 * shape1, ncp = ncp)
    X/(X + rchisq(n, 2 * shape2))
  }
}, function (n, shape1, shape2, ncp = 0) 
{
  if (missing(ncp)) 
    .Call(C_rbeta, n, shape1, shape2)
  else {
    X <- rchisq(n, 2 * shape1, ncp = ncp)
    X/(X + rchisq(n, 2 * shape2))
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rbinom
list(`package:stats` = function (n, size, prob) 
  .Call(C_rbinom, n, size, prob), function (n, size, prob) 
    .Call(C_rbinom, n, size, prob))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rcauchy
list(`package:stats` = function (n, location = 0, scale = 1) 
  .Call(C_rcauchy, n, location, scale), function (n, location = 0, scale = 1) 
    .Call(C_rcauchy, n, location, scale))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rchisq
list(`package:stats` = function (n, df, ncp = 0) 
{
  if (missing(ncp)) 
    .Call(C_rchisq, n, df)
  else .Call(C_rnchisq, n, df, ncp)
}, function (n, df, ncp = 0) 
{
  if (missing(ncp)) 
    .Call(C_rchisq, n, df)
  else .Call(C_rnchisq, n, df, ncp)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.ftable
list(`package:stats` = function (file, sep = "", quote = "\"", row.var.names, col.vars, skip = 0) 
{
  if (is.character(file)) {
    file <- file(file, "r")
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  if (!isSeekable(file)) {
    tmpf <- tempfile()
    cat(readLines(file), file = tmpf, sep = "\n")
    file <- file(tmpf, "r")
    on.exit({
      close(file)
      unlink(tmpf)
    }, add = TRUE)
  }
  z <- count.fields(file, sep, quote, skip)
  n.row.vars <- z[max(which(z == max(z)))] - z[length(z)] + 1
  seek(file, where = 0)
  if (skip > 0) 
    readLines(file, skip)
  lines <- readLines(file)
  seek(file, where = 0)
  if (skip > 0) 
    readLines(file, skip)
  i <- which(z == n.row.vars)
  j <- i[grep("^[^[:space:]]", lines[i])]
  if ((length(j) == 1) && (j > 1)) {
    n.col.vars <- j - 1
    col.vars <- vector("list", length = n.col.vars)
    n <- c(1, z[1:n.col.vars] - 1)
    for (k in seq.int(from = 1, to = n.col.vars)) {
      s <- scan(file, what = "", sep = sep, quote = quote, nlines = 1, quiet = TRUE)
      col.vars[[k]] <- s[-1]
      names(col.vars)[k] <- s[1]
    }
    row.vars <- setNames(vector("list", length = n.row.vars), scan(file, what = "", sep = sep, quote = quote, nlines = 1, quiet = TRUE))
    z <- z[-(1:(n.col.vars + 1))]
  }
  else {
    if ((z[1] == 1) && z[2] == max(z)) {
      n.col.vars <- 1
      col.vars <- vector("list", length = n.col.vars)
      s <- scan(file, what = "", sep = sep, quote = quote, nlines = 2, quiet = TRUE)
      names(col.vars) <- s[1]
      s <- s[-1]
      row.vars <- vector("list", length = n.row.vars)
      i <- 1:n.row.vars
      names(row.vars) <- s[i]
      col.vars[[1]] <- s[-i]
      z <- z[-(1:2)]
    }
    else {
      if (missing(row.var.names)) {
        stop("'row.var.names' missing")
      }
      n.row.vars <- length(row.var.names)
      row.vars <- setNames(vector("list", length = n.row.vars), as.character(row.var.names))
      if (missing(col.vars) || !is.list(col.vars)) {
        stop("'col.vars' missing or incorrect")
      }
      col.vars <- lapply(col.vars, as.character)
      n.col.vars <- length(col.vars)
      if (is.null(names(col.vars))) 
        names(col.vars) <- paste0("Factor.", seq_along(col.vars))
      else {
        nam <- names(col.vars)
        ind <- which(!nzchar(nam))
        names(col.vars)[ind] <- paste0("Factor.", ind)
      }
    }
  }
  p <- 1
  n <- integer(n.row.vars)
  for (k in seq.int(from = 1, to = n.row.vars)) {
    n[k] <- sum(z >= max(z) - k + 1)/p
    p <- p * n[k]
  }
  is.row.lab <- rep(rep(c(TRUE, FALSE), length(z)), c(rbind(z - min(z) + 1, min(z) - 1)))
  s <- scan(file, what = "", sep = sep, quote = quote, quiet = TRUE)
  values <- as.numeric(s[!is.row.lab])
  tmp <- s[is.row.lab]
  len <- length(tmp)
  for (k in seq.int(from = 1, to = n.row.vars)) {
    i <- seq.int(from = 1, to = len, by = len/n[k])
    row.vars[[k]] <- unique(tmp[i])
    tmp <- tmp[seq.int(from = 2, to = len/n[k])]
    len <- length(tmp)
  }
  values <- matrix(values, nrow = prod(lengths(row.vars)), ncol = prod(lengths(col.vars)), byrow = TRUE)
  structure(values, row.vars = row.vars, col.vars = col.vars, class = "ftable")
}, function (file, sep = "", quote = "\"", row.var.names, col.vars, skip = 0) 
{
  if (is.character(file)) {
    file <- file(file, "r")
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  if (!isSeekable(file)) {
    tmpf <- tempfile()
    cat(readLines(file), file = tmpf, sep = "\n")
    file <- file(tmpf, "r")
    on.exit({
      close(file)
      unlink(tmpf)
    }, add = TRUE)
  }
  z <- count.fields(file, sep, quote, skip)
  n.row.vars <- z[max(which(z == max(z)))] - z[length(z)] + 1
  seek(file, where = 0)
  if (skip > 0) 
    readLines(file, skip)
  lines <- readLines(file)
  seek(file, where = 0)
  if (skip > 0) 
    readLines(file, skip)
  i <- which(z == n.row.vars)
  j <- i[grep("^[^[:space:]]", lines[i])]
  if ((length(j) == 1) && (j > 1)) {
    n.col.vars <- j - 1
    col.vars <- vector("list", length = n.col.vars)
    n <- c(1, z[1:n.col.vars] - 1)
    for (k in seq.int(from = 1, to = n.col.vars)) {
      s <- scan(file, what = "", sep = sep, quote = quote, nlines = 1, quiet = TRUE)
      col.vars[[k]] <- s[-1]
      names(col.vars)[k] <- s[1]
    }
    row.vars <- setNames(vector("list", length = n.row.vars), scan(file, what = "", sep = sep, quote = quote, nlines = 1, quiet = TRUE))
    z <- z[-(1:(n.col.vars + 1))]
  }
  else {
    if ((z[1] == 1) && z[2] == max(z)) {
      n.col.vars <- 1
      col.vars <- vector("list", length = n.col.vars)
      s <- scan(file, what = "", sep = sep, quote = quote, nlines = 2, quiet = TRUE)
      names(col.vars) <- s[1]
      s <- s[-1]
      row.vars <- vector("list", length = n.row.vars)
      i <- 1:n.row.vars
      names(row.vars) <- s[i]
      col.vars[[1]] <- s[-i]
      z <- z[-(1:2)]
    }
    else {
      if (missing(row.var.names)) {
        stop("'row.var.names' missing")
      }
      n.row.vars <- length(row.var.names)
      row.vars <- setNames(vector("list", length = n.row.vars), as.character(row.var.names))
      if (missing(col.vars) || !is.list(col.vars)) {
        stop("'col.vars' missing or incorrect")
      }
      col.vars <- lapply(col.vars, as.character)
      n.col.vars <- length(col.vars)
      if (is.null(names(col.vars))) 
        names(col.vars) <- paste0("Factor.", seq_along(col.vars))
      else {
        nam <- names(col.vars)
        ind <- which(!nzchar(nam))
        names(col.vars)[ind] <- paste0("Factor.", ind)
      }
    }
  }
  p <- 1
  n <- integer(n.row.vars)
  for (k in seq.int(from = 1, to = n.row.vars)) {
    n[k] <- sum(z >= max(z) - k + 1)/p
    p <- p * n[k]
  }
  is.row.lab <- rep(rep(c(TRUE, FALSE), length(z)), c(rbind(z - min(z) + 1, min(z) - 1)))
  s <- scan(file, what = "", sep = sep, quote = quote, quiet = TRUE)
  values <- as.numeric(s[!is.row.lab])
  tmp <- s[is.row.lab]
  len <- length(tmp)
  for (k in seq.int(from = 1, to = n.row.vars)) {
    i <- seq.int(from = 1, to = len, by = len/n[k])
    row.vars[[k]] <- unique(tmp[i])
    tmp <- tmp[seq.int(from = 2, to = len/n[k])]
    len <- length(tmp)
  }
  values <- matrix(values, nrow = prod(lengths(row.vars)), ncol = prod(lengths(col.vars)), byrow = TRUE)
  structure(values, row.vars = row.vars, col.vars = col.vars, class = "ftable")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rect.hclust
list(`package:stats` = function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL) 
{
  if (length(h) > 1 || length(k) > 1) 
    stop("'k' and 'h' must be a scalar")
  if (!is.null(h)) {
    if (!is.null(k)) 
      stop("specify exactly one of 'k' and 'h'")
    k <- min(which(rev(tree$height) < h))
    k <- max(k, 2)
  }
  else if (is.null(k)) 
    stop("specify exactly one of 'k' and 'h'")
  if (k < 2 || k > length(tree$height)) 
    stop(gettextf("k must be between 2 and %d", length(tree$height)), domain = NA)
  if (is.null(cluster)) 
    cluster <- cutree(tree, k = k)
  clustab <- table(cluster)[unique(cluster[tree$order])]
  m <- c(0, cumsum(clustab))
  if (!is.null(x)) {
    if (!is.null(which)) 
      stop("specify exactly one of 'which' and 'x'")
    which <- x
    for (n in seq_along(x)) which[n] <- max(which(m < x[n]))
  }
  else if (is.null(which)) 
    which <- 1:k
  if (any(which > k)) 
    stop(gettextf("all elements of 'which' must be between 1 and %d", k), domain = NA)
  border <- rep_len(border, length(which))
  retval <- list()
  for (n in seq_along(which)) {
    rect(m[which[n]] + 0.66, par("usr")[3], m[which[n] + 1] + 0.33, mean(rev(tree$height)[(k - 1):k]), border = border[n])
    retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
  }
  invisible(retval)
}, function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL) 
{
  if (length(h) > 1 || length(k) > 1) 
    stop("'k' and 'h' must be a scalar")
  if (!is.null(h)) {
    if (!is.null(k)) 
      stop("specify exactly one of 'k' and 'h'")
    k <- min(which(rev(tree$height) < h))
    k <- max(k, 2)
  }
  else if (is.null(k)) 
    stop("specify exactly one of 'k' and 'h'")
  if (k < 2 || k > length(tree$height)) 
    stop(gettextf("k must be between 2 and %d", length(tree$height)), domain = NA)
  if (is.null(cluster)) 
    cluster <- cutree(tree, k = k)
  clustab <- table(cluster)[unique(cluster[tree$order])]
  m <- c(0, cumsum(clustab))
  if (!is.null(x)) {
    if (!is.null(which)) 
      stop("specify exactly one of 'which' and 'x'")
    which <- x
    for (n in seq_along(x)) which[n] <- max(which(m < x[n]))
  }
  else if (is.null(which)) 
    which <- 1:k
  if (any(which > k)) 
    stop(gettextf("all elements of 'which' must be between 1 and %d", k), domain = NA)
  border <- rep_len(border, length(which))
  retval <- list()
  for (n in seq_along(which)) {
    rect(m[which[n]] + 0.66, par("usr")[3], m[which[n] + 1] + 0.33, mean(rev(tree$height)[(k - 1):k]), border = border[n])
    retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
  }
  invisible(retval)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
reformulate
list(`package:stats` = function (termlabels, response = NULL, intercept = TRUE, env = parent.frame()) 
{
  if (!is.character(termlabels) || !length(termlabels)) 
    stop("'termlabels' must be a character vector of length at least one")
  termtext <- paste(termlabels, collapse = "+")
  if (!intercept) 
    termtext <- paste(termtext, "- 1")
  terms <- str2lang(termtext)
  fexpr <- if (is.null(response)) 
    call("~", terms)
  else call("~", if (is.character(response)) {
    if (length(response) != 1) stop(gettextf("'%s' must be a character string", "response"), domain = NA)
    tryCatch(str2lang(response), error = function(e) {
      sc <- sys.calls()
      sc1 <- lapply(sc, `[[`, 1)
      isF <- function(cl) is.symbol(cl) && cl == quote(reformulate)
      reformCall <- sc[[match(TRUE, vapply(sc1, isF, NA))]]
      warning(warningCondition(message = paste(sprintf("Unparseable 'response' \"%s\"; use is deprecated.  Use as.name(.) or `..`!", response), conditionMessage(e), sep = "\n"), class = c("reformulate", "deprecatedWarning"), call = reformCall))
      as.symbol(response)
    })
  } else response, terms)
  formula(fexpr, env)
}, function (termlabels, response = NULL, intercept = TRUE, env = parent.frame()) 
{
  if (!is.character(termlabels) || !length(termlabels)) 
    stop("'termlabels' must be a character vector of length at least one")
  termtext <- paste(termlabels, collapse = "+")
  if (!intercept) 
    termtext <- paste(termtext, "- 1")
  terms <- str2lang(termtext)
  fexpr <- if (is.null(response)) 
    call("~", terms)
  else call("~", if (is.character(response)) {
    if (length(response) != 1) stop(gettextf("'%s' must be a character string", "response"), domain = NA)
    tryCatch(str2lang(response), error = function(e) {
      sc <- sys.calls()
      sc1 <- lapply(sc, `[[`, 1)
      isF <- function(cl) is.symbol(cl) && cl == quote(reformulate)
      reformCall <- sc[[match(TRUE, vapply(sc1, isF, NA))]]
      warning(warningCondition(message = paste(sprintf("Unparseable 'response' \"%s\"; use is deprecated.  Use as.name(.) or `..`!", response), conditionMessage(e), sep = "\n"), class = c("reformulate", "deprecatedWarning"), call = reformCall))
      as.symbol(response)
    })
  } else response, terms)
  formula(fexpr, env)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
relevel
list(`package:stats` = function (x, ref, ...) 
  UseMethod("relevel"), function (x, ref, ...) 
    UseMethod("relevel"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
reorder
list(`package:stats` = function (x, ...) 
  UseMethod("reorder"), function (x, ...) 
    UseMethod("reorder"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
replications
list(`package:stats` = function (formula, data = NULL, na.action) 
{
  if (missing(data) && inherits(formula, "data.frame")) {
    data <- formula
    formula <- ~.
  }
  if (!inherits(formula, "terms")) {
    formula <- as.formula(formula)
    if (length(formula) < 3) {
      f <- y ~ x
      f[[3]] <- formula[[2]]
      formula <- f
    }
    formula <- terms(formula, data = data)
  }
  if (missing(na.action)) 
    if (!is.null(tj <- attr(data, "na.action")) && is.function(tj)) 
      na.action <- tj
  else {
    naa <- getOption("na.action")
    if (!is.null(naa)) 
      na.action <- match.fun(naa)
    else na.action <- na.fail
  }
  f <- attr(formula, "factors")
  o <- attr(formula, "order")
  labels <- attr(formula, "term.labels")
  vars <- as.character(attr(formula, "variables"))[-1]
  if (is.null(data)) {
    v <- c(quote(data.frame), attr(formula, "variables"))
    data <- eval(as.call(v), parent.frame())
  }
  if (!is.function(na.action)) 
    stop("na.action must be a function")
  data <- na.action(data)
  class(data) <- NULL
  n <- length(o)
  z <- setNames(vector("list", n), labels)
  dummy <- numeric(.row_names_info(data, 2))
  data <- lapply(data, function(x) if (is.character(x)) 
    as.factor(x)
    else x)
  notfactor <- !sapply(data, function(x) inherits(x, "factor"))
  balance <- TRUE
  for (i in seq_len(n)) {
    l <- labels[i]
    if (o[i] < 1 || startsWith(l, "Error")) {
      z[[l]] <- NULL
      next
    }
    select <- vars[f[, i] > 0]
    if (any(nn <- notfactor[select])) {
      warning(gettextf("non-factors ignored: %s", paste(names(nn), collapse = ", ")), domain = NA)
      next
    }
    if (length(select)) 
      tble <- tapply(dummy, unclass(data[select]), length)
    nrep <- unique(as.vector(tble))
    if (length(nrep) > 1) {
      balance <- FALSE
      tble[is.na(tble)] <- 0
      z[[l]] <- tble
    }
    else z[[l]] <- as.vector(nrep)
  }
  if (balance) 
    unlist(z)
  else z
}, function (formula, data = NULL, na.action) 
{
  if (missing(data) && inherits(formula, "data.frame")) {
    data <- formula
    formula <- ~.
  }
  if (!inherits(formula, "terms")) {
    formula <- as.formula(formula)
    if (length(formula) < 3) {
      f <- y ~ x
      f[[3]] <- formula[[2]]
      formula <- f
    }
    formula <- terms(formula, data = data)
  }
  if (missing(na.action)) 
    if (!is.null(tj <- attr(data, "na.action")) && is.function(tj)) 
      na.action <- tj
  else {
    naa <- getOption("na.action")
    if (!is.null(naa)) 
      na.action <- match.fun(naa)
    else na.action <- na.fail
  }
  f <- attr(formula, "factors")
  o <- attr(formula, "order")
  labels <- attr(formula, "term.labels")
  vars <- as.character(attr(formula, "variables"))[-1]
  if (is.null(data)) {
    v <- c(quote(data.frame), attr(formula, "variables"))
    data <- eval(as.call(v), parent.frame())
  }
  if (!is.function(na.action)) 
    stop("na.action must be a function")
  data <- na.action(data)
  class(data) <- NULL
  n <- length(o)
  z <- setNames(vector("list", n), labels)
  dummy <- numeric(.row_names_info(data, 2))
  data <- lapply(data, function(x) if (is.character(x)) 
    as.factor(x)
    else x)
  notfactor <- !sapply(data, function(x) inherits(x, "factor"))
  balance <- TRUE
  for (i in seq_len(n)) {
    l <- labels[i]
    if (o[i] < 1 || startsWith(l, "Error")) {
      z[[l]] <- NULL
      next
    }
    select <- vars[f[, i] > 0]
    if (any(nn <- notfactor[select])) {
      warning(gettextf("non-factors ignored: %s", paste(names(nn), collapse = ", ")), domain = NA)
      next
    }
    if (length(select)) 
      tble <- tapply(dummy, unclass(data[select]), length)
    nrep <- unique(as.vector(tble))
    if (length(nrep) > 1) {
      balance <- FALSE
      tble[is.na(tble)] <- 0
      z[[l]] <- tble
    }
    else z[[l]] <- as.vector(nrep)
  }
  if (balance) 
    unlist(z)
  else z
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
reshape
list(`package:stats` = function (data, varying = NULL, v.names = NULL, timevar = "time", idvar = "id", ids = 1:NROW(data), times = seq_along(varying[[1]]), drop = NULL, direction, new.row.names = NULL, sep = ".", split = if (sep == "") {
  list(regexp = "[A-Za-z][0-9]", include = TRUE)
} else {
  list(regexp = sep, include = FALSE, fixed = TRUE)
}) 
{
  if (!is.character(sep) || length(sep) != 1) 
    stop("'sep' must be a character string")
  ix2names <- function(ix) if (is.character(ix)) 
    ix
  else names(data)[ix]
  guess <- function(nms, re = split$regexp, drop = !split$include, fixed = split$fixed %||% FALSE) {
    if (drop) 
      nn <- do.call("rbind", strsplit(nms, re, fixed = fixed))
    else nn <- cbind(substr(nms, 1, regexpr(re, nms)), substr(nms, regexpr(re, nms) + 1, 10000))
    if (ncol(nn) != 2) 
      stop("failed to guess time-varying variables from their names")
    vn <- unique(nn[, 1])
    v.names <- split(nms, factor(nn[, 1], levels = vn))
    times <- unique(nn[, 2])
    attr(v.names, "v.names") <- vn
    tt <- tryCatch(as.numeric(times), warning = function(w) times)
    attr(v.names, "times") <- tt
    v.names
  }
  reshapeLong <- function(data, varying, v.names = NULL, timevar, idvar, ids = 1:NROW(data), times, drop = NULL, new.row.names = NULL) {
    ll <- unlist(lapply(varying, length))
    if (any(ll != ll[1])) 
      stop("'varying' arguments must be the same length")
    if (ll[1] != length(times)) 
      stop("'lengths(varying)' must all match 'length(times)'")
    if (!is.null(drop)) {
      if (is.character(drop)) 
        drop <- names(data) %in% drop
      data <- data[, if (is.logical(drop)) 
        !drop
        else -drop, drop = FALSE]
    }
    undoInfo <- list(varying = varying, v.names = v.names, idvar = idvar, timevar = timevar)
    if (is.null(new.row.names)) {
      if (length(idvar) > 1) {
        ids <- interaction(data[, idvar], drop = TRUE)
      }
      else if (idvar %in% names(data)) {
        ids <- data[, idvar]
      }
      if (anyDuplicated(ids)) 
        stop("'idvar' must uniquely identify records")
    }
    d <- data
    all.varying <- unlist(varying)
    d <- d[, !(names(data) %in% all.varying), drop = FALSE]
    if (is.null(v.names)) 
      v.names <- vapply(varying, `[`, 1, FUN.VALUE = character(1))
    rval <- do.call(rbind, lapply(seq_along(times), function(i) {
      d[, timevar] <- times[i]
      varying.i <- vapply(varying, `[`, i, FUN.VALUE = character(1))
      d[, v.names] <- data[, varying.i]
      if (is.null(new.row.names)) 
        attr(d, "row.names") <- paste(ids, times[i], sep = ".")
      else row.names(d) <- new.row.names[(i - 1) * NROW(d) + 1:NROW(d)]
      d
    }))
    if (length(idvar) == 1 && !(idvar %in% names(data))) {
      rval[, idvar] <- ids
    }
    attr(rval, "reshapeLong") <- undoInfo
    return(rval)
  }
  reshapeWide <- function(data, timevar, idvar, varying = NULL, v.names = NULL, drop = NULL, new.row.names = NULL) {
    if (!is.null(drop)) {
      if (is.character(drop)) 
        drop <- names(data) %in% drop
      data <- data[, if (is.logical(drop)) 
        !drop
        else -drop, drop = FALSE]
    }
    undoInfo <- list(v.names = v.names, timevar = timevar, idvar = idvar)
    orig.idvar <- idvar
    if (length(idvar) > 1) {
      repeat ({
        tempidname <- basename(tempfile("tempID"))
        if (!(tempidname %in% names(data))) 
          break
      })
      data[, tempidname] <- interaction(data[, idvar], drop = TRUE)
      idvar <- tempidname
      drop.idvar <- TRUE
    }
    else drop.idvar <- FALSE
    times <- unique(data[, timevar])
    if (anyNA(times)) 
      warning("there are records with missing times, which will be dropped.")
    undoInfo$times <- times
    if (is.null(v.names)) 
      v.names <- names(data)[!(names(data) %in% c(timevar, idvar, orig.idvar))]
    if (is.null(varying)) 
      varying <- outer(v.names, times, paste, sep = sep)
    else if (is.list(varying)) 
      varying <- do.call("rbind", varying)
    else if (is.vector(varying)) 
      varying <- matrix(varying, nrow = length(v.names))
    undoInfo$varying <- varying
    keep <- !(names(data) %in% c(timevar, v.names, idvar, orig.idvar))
    if (any(keep)) {
      rval <- data[keep]
      tmp <- data[, idvar]
      really.constant <- unlist(lapply(rval, function(a) all(tapply(a, as.vector(tmp), function(b) length(unique(b)) == 1))))
      if (!all(really.constant)) 
        warning(gettextf("some constant variables (%s) are really varying", paste(names(rval)[!really.constant], collapse = ",")), domain = NA)
    }
    rval <- data[!duplicated(data[, idvar]), !(names(data) %in% c(timevar, v.names)), drop = FALSE]
    for (i in seq_along(times)) {
      thistime <- data[data[, timevar] %in% times[i], ]
      tab <- table(thistime[, idvar])
      if (any(tab > 1)) 
        warning(sprintf("multiple rows match for %s=%s: first taken", timevar, times[i]), domain = NA)
      rval[, varying[, i]] <- thistime[match(rval[, idvar], thistime[, idvar]), v.names]
    }
    if (!is.null(new.row.names)) 
      row.names(rval) <- new.row.names
    if (drop.idvar) 
      rval[, idvar] <- NULL
    attr(rval, "reshapeWide") <- undoInfo
    rval
  }
  if (missing(direction)) {
    undo <- c("wide", "long")[c("reshapeLong", "reshapeWide") %in% names(attributes(data))]
    if (length(undo) == 1) 
      direction <- undo
  }
  direction <- match.arg(direction, c("wide", "long"))
  switch(direction, wide = {
    back <- attr(data, "reshapeLong")
    if (missing(timevar) && missing(idvar) && !is.null(back)) {
      reshapeWide(data, idvar = back$idvar, timevar = back$timevar, varying = back$varying, v.names = back$v.names, new.row.names = new.row.names)
    } else {
      reshapeWide(data, idvar = idvar, timevar = timevar, varying = varying, v.names = v.names, drop = drop, new.row.names = new.row.names)
    }
  }, long = {
    if (missing(varying)) {
      back <- attr(data, "reshapeWide")
      if (is.null(back)) stop("no 'reshapeWide' attribute, must specify 'varying'")
      varying <- back$varying
      idvar <- back$idvar
      timevar <- back$timevar
      v.names <- back$v.names
      times <- back$times
    }
    if (is.matrix(varying)) {
      varying <- split(c(varying), row(varying))
    }
    if (is.null(varying)) stop("'varying' must be nonempty list or vector")
    if (is.atomic(varying)) {
      varying <- ix2names(varying)
      if (missing(v.names)) varying <- guess(varying) else {
        if (length(varying)%%length(v.names)) stop("length of 'v.names' does not evenly divide length of 'varying'")
        ntimes <- length(varying)%/%length(v.names)
        if (missing(times)) times <- seq_len(ntimes) else if (length(times) != ntimes) stop("length of 'varying' must be the product of length of 'v.names' and length of 'times'")
        varying <- split(varying, rep(v.names, ntimes))
        attr(varying, "v.names") <- v.names
        attr(varying, "times") <- times
      }
    } else varying <- lapply(varying, ix2names)
    if (missing(v.names) && !is.null(attr(varying, "v.names"))) {
      v.names <- attr(varying, "v.names")
      times <- attr(varying, "times")
    }
    reshapeLong(data, idvar = idvar, timevar = timevar, varying = varying, v.names = v.names, drop = drop, times = times, ids = ids, new.row.names = new.row.names)
  })
}, function (data, varying = NULL, v.names = NULL, timevar = "time", idvar = "id", ids = 1:NROW(data), times = seq_along(varying[[1]]), drop = NULL, direction, new.row.names = NULL, sep = ".", split = if (sep == "") {
  list(regexp = "[A-Za-z][0-9]", include = TRUE)
} else {
  list(regexp = sep, include = FALSE, fixed = TRUE)
}) 
{
  if (!is.character(sep) || length(sep) != 1) 
    stop("'sep' must be a character string")
  ix2names <- function(ix) if (is.character(ix)) 
    ix
  else names(data)[ix]
  guess <- function(nms, re = split$regexp, drop = !split$include, fixed = split$fixed %||% FALSE) {
    if (drop) 
      nn <- do.call("rbind", strsplit(nms, re, fixed = fixed))
    else nn <- cbind(substr(nms, 1, regexpr(re, nms)), substr(nms, regexpr(re, nms) + 1, 10000))
    if (ncol(nn) != 2) 
      stop("failed to guess time-varying variables from their names")
    vn <- unique(nn[, 1])
    v.names <- split(nms, factor(nn[, 1], levels = vn))
    times <- unique(nn[, 2])
    attr(v.names, "v.names") <- vn
    tt <- tryCatch(as.numeric(times), warning = function(w) times)
    attr(v.names, "times") <- tt
    v.names
  }
  reshapeLong <- function(data, varying, v.names = NULL, timevar, idvar, ids = 1:NROW(data), times, drop = NULL, new.row.names = NULL) {
    ll <- unlist(lapply(varying, length))
    if (any(ll != ll[1])) 
      stop("'varying' arguments must be the same length")
    if (ll[1] != length(times)) 
      stop("'lengths(varying)' must all match 'length(times)'")
    if (!is.null(drop)) {
      if (is.character(drop)) 
        drop <- names(data) %in% drop
      data <- data[, if (is.logical(drop)) 
        !drop
        else -drop, drop = FALSE]
    }
    undoInfo <- list(varying = varying, v.names = v.names, idvar = idvar, timevar = timevar)
    if (is.null(new.row.names)) {
      if (length(idvar) > 1) {
        ids <- interaction(data[, idvar], drop = TRUE)
      }
      else if (idvar %in% names(data)) {
        ids <- data[, idvar]
      }
      if (anyDuplicated(ids)) 
        stop("'idvar' must uniquely identify records")
    }
    d <- data
    all.varying <- unlist(varying)
    d <- d[, !(names(data) %in% all.varying), drop = FALSE]
    if (is.null(v.names)) 
      v.names <- vapply(varying, `[`, 1, FUN.VALUE = character(1))
    rval <- do.call(rbind, lapply(seq_along(times), function(i) {
      d[, timevar] <- times[i]
      varying.i <- vapply(varying, `[`, i, FUN.VALUE = character(1))
      d[, v.names] <- data[, varying.i]
      if (is.null(new.row.names)) 
        attr(d, "row.names") <- paste(ids, times[i], sep = ".")
      else row.names(d) <- new.row.names[(i - 1) * NROW(d) + 1:NROW(d)]
      d
    }))
    if (length(idvar) == 1 && !(idvar %in% names(data))) {
      rval[, idvar] <- ids
    }
    attr(rval, "reshapeLong") <- undoInfo
    return(rval)
  }
  reshapeWide <- function(data, timevar, idvar, varying = NULL, v.names = NULL, drop = NULL, new.row.names = NULL) {
    if (!is.null(drop)) {
      if (is.character(drop)) 
        drop <- names(data) %in% drop
      data <- data[, if (is.logical(drop)) 
        !drop
        else -drop, drop = FALSE]
    }
    undoInfo <- list(v.names = v.names, timevar = timevar, idvar = idvar)
    orig.idvar <- idvar
    if (length(idvar) > 1) {
      repeat ({
        tempidname <- basename(tempfile("tempID"))
        if (!(tempidname %in% names(data))) 
          break
      })
      data[, tempidname] <- interaction(data[, idvar], drop = TRUE)
      idvar <- tempidname
      drop.idvar <- TRUE
    }
    else drop.idvar <- FALSE
    times <- unique(data[, timevar])
    if (anyNA(times)) 
      warning("there are records with missing times, which will be dropped.")
    undoInfo$times <- times
    if (is.null(v.names)) 
      v.names <- names(data)[!(names(data) %in% c(timevar, idvar, orig.idvar))]
    if (is.null(varying)) 
      varying <- outer(v.names, times, paste, sep = sep)
    else if (is.list(varying)) 
      varying <- do.call("rbind", varying)
    else if (is.vector(varying)) 
      varying <- matrix(varying, nrow = length(v.names))
    undoInfo$varying <- varying
    keep <- !(names(data) %in% c(timevar, v.names, idvar, orig.idvar))
    if (any(keep)) {
      rval <- data[keep]
      tmp <- data[, idvar]
      really.constant <- unlist(lapply(rval, function(a) all(tapply(a, as.vector(tmp), function(b) length(unique(b)) == 1))))
      if (!all(really.constant)) 
        warning(gettextf("some constant variables (%s) are really varying", paste(names(rval)[!really.constant], collapse = ",")), domain = NA)
    }
    rval <- data[!duplicated(data[, idvar]), !(names(data) %in% c(timevar, v.names)), drop = FALSE]
    for (i in seq_along(times)) {
      thistime <- data[data[, timevar] %in% times[i], ]
      tab <- table(thistime[, idvar])
      if (any(tab > 1)) 
        warning(sprintf("multiple rows match for %s=%s: first taken", timevar, times[i]), domain = NA)
      rval[, varying[, i]] <- thistime[match(rval[, idvar], thistime[, idvar]), v.names]
    }
    if (!is.null(new.row.names)) 
      row.names(rval) <- new.row.names
    if (drop.idvar) 
      rval[, idvar] <- NULL
    attr(rval, "reshapeWide") <- undoInfo
    rval
  }
  if (missing(direction)) {
    undo <- c("wide", "long")[c("reshapeLong", "reshapeWide") %in% names(attributes(data))]
    if (length(undo) == 1) 
      direction <- undo
  }
  direction <- match.arg(direction, c("wide", "long"))
  switch(direction, wide = {
    back <- attr(data, "reshapeLong")
    if (missing(timevar) && missing(idvar) && !is.null(back)) {
      reshapeWide(data, idvar = back$idvar, timevar = back$timevar, varying = back$varying, v.names = back$v.names, new.row.names = new.row.names)
    } else {
      reshapeWide(data, idvar = idvar, timevar = timevar, varying = varying, v.names = v.names, drop = drop, new.row.names = new.row.names)
    }
  }, long = {
    if (missing(varying)) {
      back <- attr(data, "reshapeWide")
      if (is.null(back)) stop("no 'reshapeWide' attribute, must specify 'varying'")
      varying <- back$varying
      idvar <- back$idvar
      timevar <- back$timevar
      v.names <- back$v.names
      times <- back$times
    }
    if (is.matrix(varying)) {
      varying <- split(c(varying), row(varying))
    }
    if (is.null(varying)) stop("'varying' must be nonempty list or vector")
    if (is.atomic(varying)) {
      varying <- ix2names(varying)
      if (missing(v.names)) varying <- guess(varying) else {
        if (length(varying)%%length(v.names)) stop("length of 'v.names' does not evenly divide length of 'varying'")
        ntimes <- length(varying)%/%length(v.names)
        if (missing(times)) times <- seq_len(ntimes) else if (length(times) != ntimes) stop("length of 'varying' must be the product of length of 'v.names' and length of 'times'")
        varying <- split(varying, rep(v.names, ntimes))
        attr(varying, "v.names") <- v.names
        attr(varying, "times") <- times
      }
    } else varying <- lapply(varying, ix2names)
    if (missing(v.names) && !is.null(attr(varying, "v.names"))) {
      v.names <- attr(varying, "v.names")
      times <- attr(varying, "times")
    }
    reshapeLong(data, idvar = idvar, timevar = timevar, varying = varying, v.names = v.names, drop = drop, times = times, ids = ids, new.row.names = new.row.names)
  })
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
resid
list(`package:stats` = function (object, ...) 
  UseMethod("residuals"), function (object, ...) 
    UseMethod("residuals"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
residuals
list(`package:stats` = function (object, ...) 
  UseMethod("residuals"), function (object, ...) 
    UseMethod("residuals"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
residuals.glm
list(`package:stats` = function (object, type = c("deviance", "pearson", "working", "response", "partial"), ...) 
{
  type <- match.arg(type)
  y <- object$y
  r <- object$residuals
  mu <- object$fitted.values
  wts <- object$prior.weights
  switch(type, deviance = , pearson = , response = if (is.null(y)) {
    mu.eta <- object$family$mu.eta
    eta <- object$linear.predictors
    y <- mu + r * mu.eta(eta)
  })
  res <- switch(type, deviance = if (object$df.residual > 0) {
    d.res <- sqrt(pmax((object$family$dev.resids)(y, mu, wts), 0))
    ifelse(y > mu, d.res, -d.res)
  } else rep.int(0, length(mu)), pearson = (y - mu) * sqrt(wts)/sqrt(object$family$variance(mu)), working = r, response = y - mu, partial = r)
  if (!is.null(object$na.action)) 
    res <- naresid(object$na.action, res)
  if (type == "partial") 
    res <- res + predict(object, type = "terms")
  res
}, function (object, type = c("deviance", "pearson", "working", "response", "partial"), ...) 
{
  type <- match.arg(type)
  y <- object$y
  r <- object$residuals
  mu <- object$fitted.values
  wts <- object$prior.weights
  switch(type, deviance = , pearson = , response = if (is.null(y)) {
    mu.eta <- object$family$mu.eta
    eta <- object$linear.predictors
    y <- mu + r * mu.eta(eta)
  })
  res <- switch(type, deviance = if (object$df.residual > 0) {
    d.res <- sqrt(pmax((object$family$dev.resids)(y, mu, wts), 0))
    ifelse(y > mu, d.res, -d.res)
  } else rep.int(0, length(mu)), pearson = (y - mu) * sqrt(wts)/sqrt(object$family$variance(mu)), working = r, response = y - mu, partial = r)
  if (!is.null(object$na.action)) 
    res <- naresid(object$na.action, res)
  if (type == "partial") 
    res <- res + predict(object, type = "terms")
  res
}, function (object, type = c("deviance", "pearson", "working", "response", "partial"), ...) 
{
  type <- match.arg(type)
  y <- object$y
  r <- object$residuals
  mu <- object$fitted.values
  wts <- object$prior.weights
  switch(type, deviance = , pearson = , response = if (is.null(y)) {
    mu.eta <- object$family$mu.eta
    eta <- object$linear.predictors
    y <- mu + r * mu.eta(eta)
  })
  res <- switch(type, deviance = if (object$df.residual > 0) {
    d.res <- sqrt(pmax((object$family$dev.resids)(y, mu, wts), 0))
    ifelse(y > mu, d.res, -d.res)
  } else rep.int(0, length(mu)), pearson = (y - mu) * sqrt(wts)/sqrt(object$family$variance(mu)), working = r, response = y - mu, partial = r)
  if (!is.null(object$na.action)) 
    res <- naresid(object$na.action, res)
  if (type == "partial") 
    res <- res + predict(object, type = "terms")
  res
})
c("package:stats", "registered S3 method for residuals from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
residuals.lm
list(`package:stats` = function (object, type = c("working", "response", "deviance", "pearson", "partial"), ...) 
{
  type <- match.arg(type)
  r <- object$residuals
  res <- switch(type, working = , response = r, deviance = , pearson = if (is.null(object$weights)) r else r * sqrt(object$weights), partial = r)
  res <- naresid(object$na.action, res)
  if (type == "partial") 
    res <- res + predict(object, type = "terms")
  res
}, function (object, type = c("working", "response", "deviance", "pearson", "partial"), ...) 
{
  type <- match.arg(type)
  r <- object$residuals
  res <- switch(type, working = , response = r, deviance = , pearson = if (is.null(object$weights)) r else r * sqrt(object$weights), partial = r)
  res <- naresid(object$na.action, res)
  if (type == "partial") 
    res <- res + predict(object, type = "terms")
  res
}, function (object, type = c("working", "response", "deviance", "pearson", "partial"), ...) 
{
  type <- match.arg(type)
  r <- object$residuals
  res <- switch(type, working = , response = r, deviance = , pearson = if (is.null(object$weights)) r else r * sqrt(object$weights), partial = r)
  res <- naresid(object$na.action, res)
  if (type == "partial") 
    res <- res + predict(object, type = "terms")
  res
})
c("package:stats", "registered S3 method for residuals from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
rexp
list(`package:stats` = function (n, rate = 1) 
  .Call(C_rexp, n, 1/rate), function (n, rate = 1) 
    .Call(C_rexp, n, 1/rate))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rf
list(`package:stats` = function (n, df1, df2, ncp) 
{
  if (missing(ncp)) 
    .Call(C_rf, n, df1, df2)
  else (rchisq(n, df1, ncp = ncp)/df1)/(rchisq(n, df2)/df2)
}, function (n, df1, df2, ncp) 
{
  if (missing(ncp)) 
    .Call(C_rf, n, df1, df2)
  else (rchisq(n, df1, ncp = ncp)/df1)/(rchisq(n, df2)/df2)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rgamma
list(`package:stats` = function (n, shape, rate = 1, scale = 1/rate) 
{
  if (!missing(rate) && !missing(scale)) {
    if (abs(rate * scale - 1) < 1e-15) 
      warning("specify 'rate' or 'scale' but not both")
    else stop("specify 'rate' or 'scale' but not both")
  }
  .Call(C_rgamma, n, shape, scale)
}, function (n, shape, rate = 1, scale = 1/rate) 
{
  if (!missing(rate) && !missing(scale)) {
    if (abs(rate * scale - 1) < 1e-15) 
      warning("specify 'rate' or 'scale' but not both")
    else stop("specify 'rate' or 'scale' but not both")
  }
  .Call(C_rgamma, n, shape, scale)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rgeom
list(`package:stats` = function (n, prob) 
  .Call(C_rgeom, n, prob), function (n, prob) 
    .Call(C_rgeom, n, prob))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rhyper
list(`package:stats` = function (nn, m, n, k) 
  .Call(C_rhyper, nn, m, n, k), function (nn, m, n, k) 
    .Call(C_rhyper, nn, m, n, k))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rlnorm
list(`package:stats` = function (n, meanlog = 0, sdlog = 1) 
  .Call(C_rlnorm, n, meanlog, sdlog), function (n, meanlog = 0, sdlog = 1) 
    .Call(C_rlnorm, n, meanlog, sdlog))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rlogis
list(`package:stats` = function (n, location = 0, scale = 1) 
  .Call(C_rlogis, n, location, scale), function (n, location = 0, scale = 1) 
    .Call(C_rlogis, n, location, scale))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rmultinom
list(`package:stats` = function (n, size, prob) 
  .Call(C_rmultinom, n, size, prob), function (n, size, prob) 
    .Call(C_rmultinom, n, size, prob))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rnbinom
list(`package:stats` = function (n, size, prob, mu) 
{
  if (!missing(mu)) {
    if (!missing(prob)) 
      stop("'prob' and 'mu' both specified")
    .Call(C_rnbinom_mu, n, size, mu)
  }
  else .Call(C_rnbinom, n, size, prob)
}, function (n, size, prob, mu) 
{
  if (!missing(mu)) {
    if (!missing(prob)) 
      stop("'prob' and 'mu' both specified")
    .Call(C_rnbinom_mu, n, size, mu)
  }
  else .Call(C_rnbinom, n, size, prob)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rnorm
list(`package:stats` = function (n, mean = 0, sd = 1) 
  .Call(C_rnorm, n, mean, sd), function (n, mean = 0, sd = 1) 
    .Call(C_rnorm, n, mean, sd))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rpois
list(`package:stats` = function (n, lambda) 
  .Call(C_rpois, n, lambda), function (n, lambda) 
    .Call(C_rpois, n, lambda))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rsignrank
list(`package:stats` = function (nn, n) 
  .Call(C_rsignrank, nn, n), function (nn, n) 
    .Call(C_rsignrank, nn, n))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rsmirnov
list(`package:stats` = function (n, sizes, z = NULL, two.sided = TRUE) 
{
  if (n < 0) 
    stop("invalid arguments")
  if (n == 0) 
    return(numeric(0))
  n <- floor(n)
  if (length(sizes) != 2) 
    stop("argument 'sizes' must be a vector of length 2")
  n.x <- sizes[1]
  n.y <- sizes[2]
  if (n.x < 1) 
    stop("not enough 'x' data")
  if (n.y < 1) 
    stop("not enough 'y' data")
  n.x <- floor(n.x)
  n.y <- floor(n.y)
  if (is.null(z)) {
    rt <- rep.int(1, n.x + n.y)
  }
  else {
    rt <- table(z)
  }
  ret <- .Call(C_Smirnov_sim, as.integer(rt), as.integer(c(n.x, n.y)), as.integer(n), as.integer(two.sided))
  return(ret)
}, function (n, sizes, z = NULL, two.sided = TRUE) 
{
  if (n < 0) 
    stop("invalid arguments")
  if (n == 0) 
    return(numeric(0))
  n <- floor(n)
  if (length(sizes) != 2) 
    stop("argument 'sizes' must be a vector of length 2")
  n.x <- sizes[1]
  n.y <- sizes[2]
  if (n.x < 1) 
    stop("not enough 'x' data")
  if (n.y < 1) 
    stop("not enough 'y' data")
  n.x <- floor(n.x)
  n.y <- floor(n.y)
  if (is.null(z)) {
    rt <- rep.int(1, n.x + n.y)
  }
  else {
    rt <- table(z)
  }
  ret <- .Call(C_Smirnov_sim, as.integer(rt), as.integer(c(n.x, n.y)), as.integer(n), as.integer(two.sided))
  return(ret)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rstandard
list(`package:stats` = function (model, ...) 
  UseMethod("rstandard"), function (model, ...) 
    UseMethod("rstandard"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rstudent
list(`package:stats` = function (model, ...) 
  UseMethod("rstudent"), function (model, ...) 
    UseMethod("rstudent"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rt
list(`package:stats` = function (n, df, ncp) 
{
  if (missing(ncp)) 
    .Call(C_rt, n, df)
  else rnorm(n, ncp)/sqrt(rchisq(n, df)/df)
}, function (n, df, ncp) 
{
  if (missing(ncp)) 
    .Call(C_rt, n, df)
  else rnorm(n, ncp)/sqrt(rchisq(n, df)/df)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
runif
list(`package:stats` = function (n, min = 0, max = 1) 
  .Call(C_runif, n, min, max), function (n, min = 0, max = 1) 
    .Call(C_runif, n, min, max))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
runmed
list(`package:stats` = function (x, k, endrule = c("median", "keep", "constant"), algorithm = NULL, na.action = c("+Big_alternate", "-Big_alternate", "na.omit", "fail"), print.level = 0) 
{
  n <- length(x)
  if (is.na(n)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  k <- as.integer(k)
  if (is.na(k)) 
    stop(gettextf("invalid value of %s", "'k'"), domain = NA)
  if (k < 0) 
    stop("'k' must be positive")
  if (k%%2 == 0) 
    warning(gettextf("'k' must be odd!  Changing 'k' to %d", k <- as.integer(1 + 2 * (k%/%2))), domain = NA)
  if (n == 0) {
    x <- double()
    attr(x, "k") <- k
    return(x)
  }
  if (k > n) 
    warning(gettextf("'k' is bigger than 'n'!  Changing 'k' to %d", k <- as.integer(1 + 2 * ((n - 1)%/%2))), domain = NA)
  algorithm <- if (missing(algorithm)) {
    if (k < 20 || n < 300) 
      "Stuetzle"
    else "Turlach"
  }
  else match.arg(algorithm, c("Stuetzle", "Turlach"))
  endrule <- match.arg(endrule)
  iend <- switch(endrule, median = , keep = 0, constant = 1)
  na.actions <- eval(formals()$na.action, NULL, baseenv())
  iNAct <- if (missing(na.action)) 
    1
  else pmatch(na.action, na.actions)
  if (print.level) 
    cat(sprintf(paste0("runmed(x, k=%d, endrule='%s' ( => iend=%d), algorithm='%s',\n", "       na.*='%s' ( => iNAct=%d))\n"), k, endrule, iend, algorithm, na.actions[[iNAct]], iNAct))
  res <- switch(algorithm, Turlach = .Call(C_runmed, as.double(x), 1, k, iend, iNAct, print.level), Stuetzle = .Call(C_runmed, as.double(x), 0, k, iend, iNAct, print.level))
  if (endrule == "median") 
    res <- smoothEnds(res, k = k)
  attr(res, "k") <- k
  res
}, function (x, k, endrule = c("median", "keep", "constant"), algorithm = NULL, na.action = c("+Big_alternate", "-Big_alternate", "na.omit", "fail"), print.level = 0) 
{
  n <- length(x)
  if (is.na(n)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  k <- as.integer(k)
  if (is.na(k)) 
    stop(gettextf("invalid value of %s", "'k'"), domain = NA)
  if (k < 0) 
    stop("'k' must be positive")
  if (k%%2 == 0) 
    warning(gettextf("'k' must be odd!  Changing 'k' to %d", k <- as.integer(1 + 2 * (k%/%2))), domain = NA)
  if (n == 0) {
    x <- double()
    attr(x, "k") <- k
    return(x)
  }
  if (k > n) 
    warning(gettextf("'k' is bigger than 'n'!  Changing 'k' to %d", k <- as.integer(1 + 2 * ((n - 1)%/%2))), domain = NA)
  algorithm <- if (missing(algorithm)) {
    if (k < 20 || n < 300) 
      "Stuetzle"
    else "Turlach"
  }
  else match.arg(algorithm, c("Stuetzle", "Turlach"))
  endrule <- match.arg(endrule)
  iend <- switch(endrule, median = , keep = 0, constant = 1)
  na.actions <- eval(formals()$na.action, NULL, baseenv())
  iNAct <- if (missing(na.action)) 
    1
  else pmatch(na.action, na.actions)
  if (print.level) 
    cat(sprintf(paste0("runmed(x, k=%d, endrule='%s' ( => iend=%d), algorithm='%s',\n", "       na.*='%s' ( => iNAct=%d))\n"), k, endrule, iend, algorithm, na.actions[[iNAct]], iNAct))
  res <- switch(algorithm, Turlach = .Call(C_runmed, as.double(x), 1, k, iend, iNAct, print.level), Stuetzle = .Call(C_runmed, as.double(x), 0, k, iend, iNAct, print.level))
  if (endrule == "median") 
    res <- smoothEnds(res, k = k)
  attr(res, "k") <- k
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rweibull
list(`package:stats` = function (n, shape, scale = 1) 
  .Call(C_rweibull, n, shape, scale), function (n, shape, scale = 1) 
    .Call(C_rweibull, n, shape, scale))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rwilcox
list(`package:stats` = function (nn, m, n) 
  .Call(C_rwilcox, nn, m, n), function (nn, m, n) 
    .Call(C_rwilcox, nn, m, n))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
rWishart
list(`package:stats` = function (n, df, Sigma) 
  .Call(C_rWishart, n, df, Sigma), function (n, df, Sigma) 
    .Call(C_rWishart, n, df, Sigma))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
scatter.smooth
list(`package:stats` = function (x, y = NULL, span = 2/3, degree = 1, family = c("symmetric", "gaussian"), xlab = NULL, ylab = NULL, ylim = range(y, pred$y, na.rm = TRUE), evaluation = 50, ..., lpars = list()) 
{
  xlabel <- if (!missing(x)) 
    deparse1(substitute(x))
  ylabel <- if (!missing(y)) 
    deparse1(substitute(y))
  xy <- xy.coords(x, y, xlabel, ylabel)
  x <- xy$x
  y <- xy$y
  xlab <- if (is.null(xlab)) 
    xy$xlab
  else xlab
  ylab <- if (is.null(ylab)) 
    xy$ylab
  else ylab
  pred <- loess.smooth(x, y, span, degree, family, evaluation)
  plot(x, y, ylim = ylim, xlab = xlab, ylab = ylab, ...)
  do.call(lines, c(list(pred), lpars))
  invisible()
}, function (x, y = NULL, span = 2/3, degree = 1, family = c("symmetric", "gaussian"), xlab = NULL, ylab = NULL, ylim = range(y, pred$y, na.rm = TRUE), evaluation = 50, ..., lpars = list()) 
{
  xlabel <- if (!missing(x)) 
    deparse1(substitute(x))
  ylabel <- if (!missing(y)) 
    deparse1(substitute(y))
  xy <- xy.coords(x, y, xlabel, ylabel)
  x <- xy$x
  y <- xy$y
  xlab <- if (is.null(xlab)) 
    xy$xlab
  else xlab
  ylab <- if (is.null(ylab)) 
    xy$ylab
  else ylab
  pred <- loess.smooth(x, y, span, degree, family, evaluation)
  plot(x, y, ylim = ylim, xlab = xlab, ylab = ylab, ...)
  do.call(lines, c(list(pred), lpars))
  invisible()
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
screeplot
list(`package:stats` = function (x, ...) 
  UseMethod("screeplot"), function (x, ...) 
    UseMethod("screeplot"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
sd
list(`package:stats` = function (x, na.rm = FALSE) 
  sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), na.rm = na.rm)), function (x, na.rm = FALSE) 
    sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), na.rm = na.rm)))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
se.contrast
list(`package:stats` = function (object, ...) 
  UseMethod("se.contrast"), function (object, ...) 
    UseMethod("se.contrast"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
selfStart
list(`package:stats` = function (model, initial, parameters, template) 
  UseMethod("selfStart"), function (model, initial, parameters, template) 
    UseMethod("selfStart"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
setNames
list(`package:stats` = function (object = nm, nm) 
{
  names(object) <- nm
  object
}, function (object = nm, nm) 
{
  names(object) <- nm
  object
}, function (object = nm, nm) 
{
  names(object) <- nm
  object
})
c("package:stats", "namespace:methods", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
shapiro.test
list(`package:stats` = function (x) 
{
  DNAME <- deparse1(substitute(x))
  stopifnot(is.numeric(x))
  x <- sort(x[complete.cases(x)])
  n <- length(x)
  if (is.na(n) || n < 3 || n > 5000) 
    stop("sample size must be between 3 and 5000")
  rng <- x[n] - x[1]
  if (rng == 0) 
    stop("all 'x' values are identical")
  if (rng < 1e-10) 
    x <- x/rng
  res <- .Call(C_SWilk, x)
  RVAL <- list(statistic = c(W = res[1]), p.value = res[2], method = "Shapiro-Wilk normality test", data.name = DNAME)
  class(RVAL) <- "htest"
  return(RVAL)
}, function (x) 
{
  DNAME <- deparse1(substitute(x))
  stopifnot(is.numeric(x))
  x <- sort(x[complete.cases(x)])
  n <- length(x)
  if (is.na(n) || n < 3 || n > 5000) 
    stop("sample size must be between 3 and 5000")
  rng <- x[n] - x[1]
  if (rng == 0) 
    stop("all 'x' values are identical")
  if (rng < 1e-10) 
    x <- x/rng
  res <- .Call(C_SWilk, x)
  RVAL <- list(statistic = c(W = res[1]), p.value = res[2], method = "Shapiro-Wilk normality test", data.name = DNAME)
  class(RVAL) <- "htest"
  return(RVAL)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
sigma
list(`package:stats` = function (object, ...) 
  UseMethod("sigma"), function (object, ...) 
    UseMethod("sigma"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
simulate
list(`package:stats` = function (object, nsim = 1, seed = NULL, ...) 
  UseMethod("simulate"), function (object, nsim = 1, seed = NULL, ...) 
    UseMethod("simulate"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
smooth
list(`package:stats` = function (x, kind = c("3RS3R", "3RSS", "3RSR", "3R", "3", "S"), twiceit = FALSE, endrule = c("Tukey", "copy"), do.ends = FALSE) 
{
  if (!is.numeric(x)) 
    stop("attempt to smooth non-numeric values")
  if (anyNA(x)) 
    stop("attempt to smooth NA values")
  endrule <- match.arg(endrule)
  rules <- c("copy", "Tukey")
  if (is.na(iend <- pmatch(endrule, rules))) 
    stop("invalid 'endrule' argument")
  kind <- match.arg(kind)
  if (startsWith(kind, "3RS") && !do.ends) 
    iend <- -iend
  else if (kind == "S") 
    iend <- as.logical(do.ends)
  type <- match(kind, c("3RS3R", "3RSS", "3RSR", "3R", "3", "S"))
  smo <- .Call(C_Rsm, as.double(x), type, iend)
  if (twiceit) {
    r <- smooth(x - smo$y, kind = kind, twiceit = FALSE, endrule = endrule, do.ends = do.ends)
    smo$y <- smo$y + r
    if (!is.null(smo$iter)) 
      smo$iter <- smo$iter + attr(r, "iter")
    if (!is.null(smo$changed)) 
      smo$changed <- smo$changed || attr(r, "changed")
  }
  if (is.ts(x)) 
    smo$y <- ts(smo$y, start = start(x), frequency = frequency(x))
  structure(smo$y, kind = kind, twiced = twiceit, iter = smo$iter, changed = smo$changed, endrule = if (startsWith(kind, "3")) 
    rules[iend], call = match.call(), class = c("tukeysmooth", if (is.ts(x)) "ts"))
}, function (x, kind = c("3RS3R", "3RSS", "3RSR", "3R", "3", "S"), twiceit = FALSE, endrule = c("Tukey", "copy"), do.ends = FALSE) 
{
  if (!is.numeric(x)) 
    stop("attempt to smooth non-numeric values")
  if (anyNA(x)) 
    stop("attempt to smooth NA values")
  endrule <- match.arg(endrule)
  rules <- c("copy", "Tukey")
  if (is.na(iend <- pmatch(endrule, rules))) 
    stop("invalid 'endrule' argument")
  kind <- match.arg(kind)
  if (startsWith(kind, "3RS") && !do.ends) 
    iend <- -iend
  else if (kind == "S") 
    iend <- as.logical(do.ends)
  type <- match(kind, c("3RS3R", "3RSS", "3RSR", "3R", "3", "S"))
  smo <- .Call(C_Rsm, as.double(x), type, iend)
  if (twiceit) {
    r <- smooth(x - smo$y, kind = kind, twiceit = FALSE, endrule = endrule, do.ends = do.ends)
    smo$y <- smo$y + r
    if (!is.null(smo$iter)) 
      smo$iter <- smo$iter + attr(r, "iter")
    if (!is.null(smo$changed)) 
      smo$changed <- smo$changed || attr(r, "changed")
  }
  if (is.ts(x)) 
    smo$y <- ts(smo$y, start = start(x), frequency = frequency(x))
  structure(smo$y, kind = kind, twiced = twiceit, iter = smo$iter, changed = smo$changed, endrule = if (startsWith(kind, "3")) 
    rules[iend], call = match.call(), class = c("tukeysmooth", if (is.ts(x)) "ts"))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
smooth.spline
list(`package:stats` = function (x, y = NULL, w = NULL, df, spar = NULL, lambda = NULL, cv = FALSE, all.knots = FALSE, nknots = .nknots.smspl, keep.data = TRUE, df.offset = 0, penalty = 1, control.spar = list(), tol = 1e-06 * IQR(x), keep.stuff = FALSE) 
{
  contr.sp <- list(low = -1.5, high = 1.5, tol = 1e-04, eps = 2e-08, maxit = 500, trace = getOption("verbose"))
  contr.sp[names(control.spar)] <- control.spar
  ctrl.Num <- contr.sp[1:4]
  if (!all(vapply(ctrl.Num, is.numeric, NA)) || contr.sp$tol < 0 || contr.sp$eps <= 0 || contr.sp$maxit <= 0) 
    stop("invalid 'control.spar'")
  xy <- xy.coords(x, y, setLab = FALSE)
  y <- xy$y
  x <- xy$x
  if (!all(is.finite(c(x, y)))) 
    stop("missing or infinite values in inputs are not allowed")
  n <- length(x)
  if (is.na(n)) 
    stop("invalid number of points")
  no.wgts <- is.null(w)
  w <- if (no.wgts) 
    1
  else {
    if (n != length(w)) 
      stop("lengths of 'x' and 'w' must match")
    if (any(w < 0)) 
      stop("all weights should be non-negative")
    if (all(w == 0)) 
      stop("some weights should be positive")
    (w * sum(w > 0))/sum(w)
  }
  if (!is.finite(tol) || tol <= 0) 
    stop("'tol' must be strictly positive and finite")
  if (!match(keep.stuff, c(FALSE, TRUE))) 
    stop("invalid 'keep.stuff'")
  xx <- round((x - mean(x))/tol)
  uns.x <- is.unsorted(x)
  iOx <- if (uns.x) 
    sort.list(x)
  else TRUE
  xxs <- xx[iOx]
  nd <- c(TRUE, xxs[-n] < xxs[-1])
  nx <- length(ux <- x[iOx][nd])
  if (nx <= 3) 
    stop("need at least four unique 'x' values")
  if (nx == n) {
    ox <- if (uns.x) 
      (function(p) {
        p[p] <- seq_along(p)
        p
      })(iOx)
    else TRUE
    tmp <- cbind(w, w * y, w * y^2)[iOx, ]
  }
  else {
    ox <- match(xx, xxs[nd])
    tapply1 <- function(X, INDEX, FUN = NULL, ..., simplify = TRUE) {
      sapply(X = unname(split(X, INDEX)), FUN = FUN, ..., simplify = simplify, USE.NAMES = FALSE)
    }
    tmp <- matrix(unlist(tapply1(seq_len(n), ox, if (length(w) == 1) 
      function(i) c(length(i), sum(y[i]), sum(y[i]^2))
      else function(i) c(sum(w[i]), sum(w[i] * y[i]), sum(w[i] * y[i]^2))), use.names = FALSE), ncol = 3, byrow = TRUE)
  }
  wbar <- tmp[, 1]
  ybar <- tmp[, 2]/ifelse(wbar > 0, wbar, 1)
  yssw <- sum(tmp[, 3] - wbar * ybar^2)
  rm(iOx, xx, xxs, nd, tmp)
  if (is.na(cv <- as.logical(cv)) && !missing(df)) 
    stop("'cv' must not be NA when 'df' is specified")
  CV <- !is.na(cv) && cv
  if (CV && nx < n) 
    warning("cross-validation with non-unique 'x' values seems doubtful")
  r.ux <- ux[nx] - ux[1]
  xbar <- (ux - ux[1])/r.ux
  if (is.numeric(all.knots)) {
    if (is.unsorted(all.knots, strictly = TRUE)) 
      stop("Numeric 'all.knots' must be strictly increasing")
    if (!missing(nknots) && !is.null(nknots)) 
      warning("'all.knots' is vector of knots; 'nknots' specification is disregarded")
    nknots <- length(all.knots)
    if (0 < all.knots[1] || all.knots[nknots] < 1) 
      stop("numeric 'all.knots' must cover [0,1] (= the transformed data-range)")
    knot <- c(rep(all.knots[1], 3), all.knots, rep(all.knots[nknots], 3))
  }
  else {
    if (all.knots) {
      if (!missing(nknots) && !is.null(nknots)) 
        warning("'all.knots' is TRUE; 'nknots' specification is disregarded")
      nknots <- nx
    }
    else if (is.null(nknots)) 
      nknots <- .nknots.smspl(nx)
    else {
      if (is.function(nknots)) 
        nknots <- nknots(nx)
      else if (!is.numeric(nknots)) 
        stop("'nknots' must be numeric (in {1,..,n})")
      if (nknots < 1) 
        stop("'nknots' must be at least 1")
      else if (nknots > nx) 
        stop("cannot use more inner knots than unique 'x' values")
    }
    knot <- c(rep(xbar[1], 3), if (all.knots) xbar else xbar[seq.int(1, nx, length.out = nknots)], rep(xbar[nx], 3))
  }
  nk <- nknots + 2
  spar.is.lambda <- !missing(lambda)
  if (spar.is.lambda <- !missing(lambda)) {
    if (!missing(spar)) 
      stop("must not specify both 'spar' and 'lambda'")
    ispar <- 1
  }
  else ispar <- if (is.null(spar) || missing(spar)) {
    if (contr.sp$trace) 
      -1
    else 0
  }
  else 1
  spar <- if (spar.is.lambda) 
    as.double(lambda)
  else if (ispar == 1) 
    as.double(spar)
  else double(1)
  if (length(spar) != 1) 
    stop("'spar' must be of length 1")
  icrit <- if (is.na(cv)) 
    0
  else if (cv) 
    2
  else 1
  dofoff <- df.offset
  if (!missing(df)) {
    if (df > 1 && df <= nx) {
      icrit <- 3
      dofoff <- df
    }
    else warning("not using invalid df; must have 1 < df <= n := #{unique x} = ", nx)
  }
  iparms <- c(icrit = icrit, ispar = ispar, iter = as.integer(contr.sp$maxit), spar.is.lambda)
  ans.names <- c("coef", "ty", "lev", "spar", "parms", "crit", "iparms", "ier", if (keep.stuff) "scratch")
  fit <- .Fortran(C_rbart, as.double(penalty), as.double(dofoff), x = as.double(xbar), y = as.double(ybar), w = as.double(wbar), ssw = as.double(yssw), as.integer(nx), as.double(knot), as.integer(nk), coef = double(nk), ty = double(nx), lev = double(if (is.na(cv)) 1 else nx), crit = double(1), iparms = iparms, spar = spar, parms = c(unlist(ctrl.Num), ratio = -1), scratch = double((17 + 1) * nk + 1), ld4 = 4, ldnk = 1, ier = integer(1))[ans.names]
  if (is.na(cv)) 
    lev <- df <- NA
  else {
    lev <- fit$lev
    df <- sum(lev)
    if (is.na(df)) 
      stop("NA lev[]; probably smoothing parameter 'spar' way too large!")
  }
  if (fit$ier > 0) {
    offKind <- if (spar.is.lambda) 
      "extreme"
    else if (sml <- fit$spar < 0.5) 
      "small"
    else "large"
    wtxt <- paste("smoothing parameter value too", offKind)
    if (spar.is.lambda || sml) {
      stop(wtxt)
    }
    else {
      fit$ty <- rep(mean(y), nx)
      df <- 1
      warning(wtxt, "\nsetting df = 1  __use with care!__")
    }
  }
  cv.crit <- if (is.na(cv)) 
    NA
  else {
    r <- y - fit$ty[ox]
    if (cv) {
      ww <- wbar
      ww[ww == 0] <- 1
      r <- r/(1 - (lev[ox] * w)/ww[ox])
      if (no.wgts) 
        mean(r^2)
      else weighted.mean(r^2, w)
    }
    else (if (no.wgts) 
      mean(r^2)
      else weighted.mean(r^2, w))/(1 - (df.offset + penalty * df)/n)^2
  }
  structure(list(x = ux, y = fit$ty, w = wbar, yin = ybar, tol = tol, data = if (keep.data) list(x = x, y = y, w = w), no.weights = no.wgts, n = n, lev = lev, cv = cv, cv.crit = cv.crit, pen.crit = sum(wbar * (ybar - fit$ty)^2), crit = fit$crit, df = df, spar = if (spar.is.lambda) NA else fit$spar, ratio = if (spar.is.lambda) NA else fit$parms[["ratio"]], lambda = fit$parms[["low"]], iparms = c(fit$iparms, errorI = if (fit$ier) fit$ier else NA), auxM = if (keep.stuff) list(XWy = fit$scratch[seq_len(nk)], 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              XWX = fit$scratch[nk + seq_len(4 * nk)], Sigma = fit$scratch[5 * nk + seq_len(4 * nk)], R = fit$scratch[9 * nk + seq_len(4 * nk)]), fit = structure(list(knot = knot, nk = nk, min = ux[1], range = r.ux, coef = fit$coef), class = "smooth.spline.fit"), call = match.call()), class = "smooth.spline")
}, function (x, y = NULL, w = NULL, df, spar = NULL, lambda = NULL, cv = FALSE, all.knots = FALSE, nknots = .nknots.smspl, keep.data = TRUE, df.offset = 0, penalty = 1, control.spar = list(), tol = 1e-06 * IQR(x), keep.stuff = FALSE) 
{
  contr.sp <- list(low = -1.5, high = 1.5, tol = 1e-04, eps = 2e-08, maxit = 500, trace = getOption("verbose"))
  contr.sp[names(control.spar)] <- control.spar
  ctrl.Num <- contr.sp[1:4]
  if (!all(vapply(ctrl.Num, is.numeric, NA)) || contr.sp$tol < 0 || contr.sp$eps <= 0 || contr.sp$maxit <= 0) 
    stop("invalid 'control.spar'")
  xy <- xy.coords(x, y, setLab = FALSE)
  y <- xy$y
  x <- xy$x
  if (!all(is.finite(c(x, y)))) 
    stop("missing or infinite values in inputs are not allowed")
  n <- length(x)
  if (is.na(n)) 
    stop("invalid number of points")
  no.wgts <- is.null(w)
  w <- if (no.wgts) 
    1
  else {
    if (n != length(w)) 
      stop("lengths of 'x' and 'w' must match")
    if (any(w < 0)) 
      stop("all weights should be non-negative")
    if (all(w == 0)) 
      stop("some weights should be positive")
    (w * sum(w > 0))/sum(w)
  }
  if (!is.finite(tol) || tol <= 0) 
    stop("'tol' must be strictly positive and finite")
  if (!match(keep.stuff, c(FALSE, TRUE))) 
    stop("invalid 'keep.stuff'")
  xx <- round((x - mean(x))/tol)
  uns.x <- is.unsorted(x)
  iOx <- if (uns.x) 
    sort.list(x)
  else TRUE
  xxs <- xx[iOx]
  nd <- c(TRUE, xxs[-n] < xxs[-1])
  nx <- length(ux <- x[iOx][nd])
  if (nx <= 3) 
    stop("need at least four unique 'x' values")
  if (nx == n) {
    ox <- if (uns.x) 
      (function(p) {
        p[p] <- seq_along(p)
        p
      })(iOx)
    else TRUE
    tmp <- cbind(w, w * y, w * y^2)[iOx, ]
  }
  else {
    ox <- match(xx, xxs[nd])
    tapply1 <- function(X, INDEX, FUN = NULL, ..., simplify = TRUE) {
      sapply(X = unname(split(X, INDEX)), FUN = FUN, ..., simplify = simplify, USE.NAMES = FALSE)
    }
    tmp <- matrix(unlist(tapply1(seq_len(n), ox, if (length(w) == 1) 
      function(i) c(length(i), sum(y[i]), sum(y[i]^2))
      else function(i) c(sum(w[i]), sum(w[i] * y[i]), sum(w[i] * y[i]^2))), use.names = FALSE), ncol = 3, byrow = TRUE)
  }
  wbar <- tmp[, 1]
  ybar <- tmp[, 2]/ifelse(wbar > 0, wbar, 1)
  yssw <- sum(tmp[, 3] - wbar * ybar^2)
  rm(iOx, xx, xxs, nd, tmp)
  if (is.na(cv <- as.logical(cv)) && !missing(df)) 
    stop("'cv' must not be NA when 'df' is specified")
  CV <- !is.na(cv) && cv
  if (CV && nx < n) 
    warning("cross-validation with non-unique 'x' values seems doubtful")
  r.ux <- ux[nx] - ux[1]
  xbar <- (ux - ux[1])/r.ux
  if (is.numeric(all.knots)) {
    if (is.unsorted(all.knots, strictly = TRUE)) 
      stop("Numeric 'all.knots' must be strictly increasing")
    if (!missing(nknots) && !is.null(nknots)) 
      warning("'all.knots' is vector of knots; 'nknots' specification is disregarded")
    nknots <- length(all.knots)
    if (0 < all.knots[1] || all.knots[nknots] < 1) 
      stop("numeric 'all.knots' must cover [0,1] (= the transformed data-range)")
    knot <- c(rep(all.knots[1], 3), all.knots, rep(all.knots[nknots], 3))
  }
  else {
    if (all.knots) {
      if (!missing(nknots) && !is.null(nknots)) 
        warning("'all.knots' is TRUE; 'nknots' specification is disregarded")
      nknots <- nx
    }
    else if (is.null(nknots)) 
      nknots <- .nknots.smspl(nx)
    else {
      if (is.function(nknots)) 
        nknots <- nknots(nx)
      else if (!is.numeric(nknots)) 
        stop("'nknots' must be numeric (in {1,..,n})")
      if (nknots < 1) 
        stop("'nknots' must be at least 1")
      else if (nknots > nx) 
        stop("cannot use more inner knots than unique 'x' values")
    }
    knot <- c(rep(xbar[1], 3), if (all.knots) xbar else xbar[seq.int(1, nx, length.out = nknots)], rep(xbar[nx], 3))
  }
  nk <- nknots + 2
  spar.is.lambda <- !missing(lambda)
  if (spar.is.lambda <- !missing(lambda)) {
    if (!missing(spar)) 
      stop("must not specify both 'spar' and 'lambda'")
    ispar <- 1
  }
  else ispar <- if (is.null(spar) || missing(spar)) {
    if (contr.sp$trace) 
      -1
    else 0
  }
  else 1
  spar <- if (spar.is.lambda) 
    as.double(lambda)
  else if (ispar == 1) 
    as.double(spar)
  else double(1)
  if (length(spar) != 1) 
    stop("'spar' must be of length 1")
  icrit <- if (is.na(cv)) 
    0
  else if (cv) 
    2
  else 1
  dofoff <- df.offset
  if (!missing(df)) {
    if (df > 1 && df <= nx) {
      icrit <- 3
      dofoff <- df
    }
    else warning("not using invalid df; must have 1 < df <= n := #{unique x} = ", nx)
  }
  iparms <- c(icrit = icrit, ispar = ispar, iter = as.integer(contr.sp$maxit), spar.is.lambda)
  ans.names <- c("coef", "ty", "lev", "spar", "parms", "crit", "iparms", "ier", if (keep.stuff) "scratch")
  fit <- .Fortran(C_rbart, as.double(penalty), as.double(dofoff), x = as.double(xbar), y = as.double(ybar), w = as.double(wbar), ssw = as.double(yssw), as.integer(nx), as.double(knot), as.integer(nk), coef = double(nk), ty = double(nx), lev = double(if (is.na(cv)) 1 else nx), crit = double(1), iparms = iparms, spar = spar, parms = c(unlist(ctrl.Num), ratio = -1), scratch = double((17 + 1) * nk + 1), ld4 = 4, ldnk = 1, ier = integer(1))[ans.names]
  if (is.na(cv)) 
    lev <- df <- NA
  else {
    lev <- fit$lev
    df <- sum(lev)
    if (is.na(df)) 
      stop("NA lev[]; probably smoothing parameter 'spar' way too large!")
  }
  if (fit$ier > 0) {
    offKind <- if (spar.is.lambda) 
      "extreme"
    else if (sml <- fit$spar < 0.5) 
      "small"
    else "large"
    wtxt <- paste("smoothing parameter value too", offKind)
    if (spar.is.lambda || sml) {
      stop(wtxt)
    }
    else {
      fit$ty <- rep(mean(y), nx)
      df <- 1
      warning(wtxt, "\nsetting df = 1  __use with care!__")
    }
  }
  cv.crit <- if (is.na(cv)) 
    NA
  else {
    r <- y - fit$ty[ox]
    if (cv) {
      ww <- wbar
      ww[ww == 0] <- 1
      r <- r/(1 - (lev[ox] * w)/ww[ox])
      if (no.wgts) 
        mean(r^2)
      else weighted.mean(r^2, w)
    }
    else (if (no.wgts) 
      mean(r^2)
      else weighted.mean(r^2, w))/(1 - (df.offset + penalty * df)/n)^2
  }
  structure(list(x = ux, y = fit$ty, w = wbar, yin = ybar, tol = tol, data = if (keep.data) list(x = x, y = y, w = w), no.weights = no.wgts, n = n, lev = lev, cv = cv, cv.crit = cv.crit, pen.crit = sum(wbar * (ybar - fit$ty)^2), crit = fit$crit, df = df, spar = if (spar.is.lambda) NA else fit$spar, ratio = if (spar.is.lambda) NA else fit$parms[["ratio"]], lambda = fit$parms[["low"]], iparms = c(fit$iparms, errorI = if (fit$ier) fit$ier else NA), auxM = if (keep.stuff) list(XWy = fit$scratch[seq_len(nk)], 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              XWX = fit$scratch[nk + seq_len(4 * nk)], Sigma = fit$scratch[5 * nk + seq_len(4 * nk)], R = fit$scratch[9 * nk + seq_len(4 * nk)]), fit = structure(list(knot = knot, nk = nk, min = ux[1], range = r.ux, coef = fit$coef), class = "smooth.spline.fit"), call = match.call()), class = "smooth.spline")
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
smoothEnds
list(`package:stats` = function (y, k = 3) 
{
  med3 <- function(a, b, c) {
    m <- b
    if (a < b) {
      if (c < b) 
        m <- if (a >= c) 
          a
      else c
    }
    else {
      if (c > b) 
        m <- if (a <= c) 
          a
      else c
    }
    m
  }
  med.3 <- function(x) {
    if (anyNA(x)) 
      mean.default(x[!is.na(x)], na.rm = TRUE)
    else med3(x[[1]], x[[2]], x[[3]])
  }
  med3i <- function(a, b, c) {
    if (anyNA(x <- c(a, b, c))) 
      mean.default(x[!is.na(x)], na.rm = TRUE)
    else med3(a, b, c)
  }
  med.odd <- function(x, n = length(x)) {
    if (anyNA(x)) 
      n <- length(x <- x[!is.na(x)])
    if (half <- (n + 1)%/%2) 
      sort(x, partial = half)[half]
    else x[1]
  }
  k <- as.integer(k)
  if (k < 0 || k%%2 == 0) 
    stop("bandwidth 'k' must be >= 1 and odd!")
  k <- k%/%2
  if (k < 1) 
    return(y)
  n <- length(y)
  n_1 <- n - 1
  n_2 <- n - 2
  sm <- y
  if (k >= 2) {
    sm[2] <- med.3(y[1:3])
    sm[n_1] <- med.3(y[c(n, n_1, n_2)])
    if (k >= 3) {
      for (i in 3:k) {
        j <- 2 * i - 1
        sm[i] <- med.odd(y[1:j], j)
        sm[n - i + 1] <- med.odd(y[(n + 1 - j):n], j)
      }
    }
  }
  sm[1] <- med3i(y[1], sm[2], sm[2] - 2 * (sm[3] - sm[2]))
  sm[n] <- med3i(y[n], sm[n_1], sm[n_1] - 2 * (sm[n_2] - sm[n_1]))
  sm
}, function (y, k = 3) 
{
  med3 <- function(a, b, c) {
    m <- b
    if (a < b) {
      if (c < b) 
        m <- if (a >= c) 
          a
      else c
    }
    else {
      if (c > b) 
        m <- if (a <= c) 
          a
      else c
    }
    m
  }
  med.3 <- function(x) {
    if (anyNA(x)) 
      mean.default(x[!is.na(x)], na.rm = TRUE)
    else med3(x[[1]], x[[2]], x[[3]])
  }
  med3i <- function(a, b, c) {
    if (anyNA(x <- c(a, b, c))) 
      mean.default(x[!is.na(x)], na.rm = TRUE)
    else med3(a, b, c)
  }
  med.odd <- function(x, n = length(x)) {
    if (anyNA(x)) 
      n <- length(x <- x[!is.na(x)])
    if (half <- (n + 1)%/%2) 
      sort(x, partial = half)[half]
    else x[1]
  }
  k <- as.integer(k)
  if (k < 0 || k%%2 == 0) 
    stop("bandwidth 'k' must be >= 1 and odd!")
  k <- k%/%2
  if (k < 1) 
    return(y)
  n <- length(y)
  n_1 <- n - 1
  n_2 <- n - 2
  sm <- y
  if (k >= 2) {
    sm[2] <- med.3(y[1:3])
    sm[n_1] <- med.3(y[c(n, n_1, n_2)])
    if (k >= 3) {
      for (i in 3:k) {
        j <- 2 * i - 1
        sm[i] <- med.odd(y[1:j], j)
        sm[n - i + 1] <- med.odd(y[(n + 1 - j):n], j)
      }
    }
  }
  sm[1] <- med3i(y[1], sm[2], sm[2] - 2 * (sm[3] - sm[2]))
  sm[n] <- med3i(y[n], sm[n_1], sm[n_1] - 2 * (sm[n_2] - sm[n_1]))
  sm
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
sortedXyData
list(`package:stats` = function (x, y, data) 
  UseMethod("sortedXyData"), function (x, y, data) 
    UseMethod("sortedXyData"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
spec.ar
list(`package:stats` = function (x, n.freq, order = NULL, plot = TRUE, na.action = na.fail, method = "yule-walker", ...) 
{
  if (!is.list(x)) {
    series <- deparse1(substitute(x))
    x <- na.action(as.ts(x))
    xfreq <- frequency(x)
    nser <- NCOL(x)
    x <- ar(x, is.null(order), order, na.action = na.action, method = method)
  }
  else {
    cn <- match(c("ar", "var.pred", "order"), names(x))
    if (anyNA(cn)) 
      stop("'x' must be a time series or an ar() fit")
    series <- x$series
    xfreq <- x$frequency
    if (is.array(x$ar)) 
      nser <- dim(x$ar)[2]
    else nser <- 1
  }
  order <- x$order
  if (missing(n.freq)) 
    n.freq <- 500
  freq <- seq.int(0, 0.5, length.out = n.freq)
  if (nser == 1) {
    coh <- phase <- NULL
    var.p <- as.vector(x$var.pred)
    spec <- if (order >= 1) {
      cs <- outer(freq, 1:order, function(x, y) cos(2 * pi * x * y)) %*% x$ar
      sn <- outer(freq, 1:order, function(x, y) sin(2 * pi * x * y)) %*% x$ar
      var.p/(xfreq * ((1 - cs)^2 + sn^2))
    }
    else rep.int(var.p/xfreq, length(freq))
  }
  else .NotYetImplemented()
  spg.out <- list(freq = freq * xfreq, spec = spec, coh = coh, phase = phase, n.used = nrow(x), series = series, method = paste0("AR (", order, ") spectrum "))
  class(spg.out) <- "spec"
  if (plot) {
    plot(spg.out, ci = 0, ...)
    invisible(spg.out)
  }
  else spg.out
}, function (x, n.freq, order = NULL, plot = TRUE, na.action = na.fail, method = "yule-walker", ...) 
{
  if (!is.list(x)) {
    series <- deparse1(substitute(x))
    x <- na.action(as.ts(x))
    xfreq <- frequency(x)
    nser <- NCOL(x)
    x <- ar(x, is.null(order), order, na.action = na.action, method = method)
  }
  else {
    cn <- match(c("ar", "var.pred", "order"), names(x))
    if (anyNA(cn)) 
      stop("'x' must be a time series or an ar() fit")
    series <- x$series
    xfreq <- x$frequency
    if (is.array(x$ar)) 
      nser <- dim(x$ar)[2]
    else nser <- 1
  }
  order <- x$order
  if (missing(n.freq)) 
    n.freq <- 500
  freq <- seq.int(0, 0.5, length.out = n.freq)
  if (nser == 1) {
    coh <- phase <- NULL
    var.p <- as.vector(x$var.pred)
    spec <- if (order >= 1) {
      cs <- outer(freq, 1:order, function(x, y) cos(2 * pi * x * y)) %*% x$ar
      sn <- outer(freq, 1:order, function(x, y) sin(2 * pi * x * y)) %*% x$ar
      var.p/(xfreq * ((1 - cs)^2 + sn^2))
    }
    else rep.int(var.p/xfreq, length(freq))
  }
  else .NotYetImplemented()
  spg.out <- list(freq = freq * xfreq, spec = spec, coh = coh, phase = phase, n.used = nrow(x), series = series, method = paste0("AR (", order, ") spectrum "))
  class(spg.out) <- "spec"
  if (plot) {
    plot(spg.out, ci = 0, ...)
    invisible(spg.out)
  }
  else spg.out
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
spec.pgram
list(`package:stats` = function (x, spans = NULL, kernel = NULL, taper = 0.1, pad = 0, fast = TRUE, demean = FALSE, detrend = TRUE, plot = TRUE, na.action = na.fail, ...) 
{
  series <- deparse1(substitute(x))
  x <- na.action(as.ts(x))
  xfreq <- frequency(x)
  x <- as.matrix(x)
  N <- N0 <- nrow(x)
  nser <- ncol(x)
  if (!is.null(spans)) 
    kernel <- {
      if (is.tskernel(spans)) 
        spans
      else kernel("modified.daniell", spans%/%2)
    }
  if (!is.null(kernel) && !is.tskernel(kernel)) 
    stop("must specify 'spans' or a valid kernel")
  if (detrend) {
    t <- 1:N - (N + 1)/2
    sumt2 <- N * (N^2 - 1)/12
    for (i in 1:ncol(x)) x[, i] <- x[, i] - mean(x[, i]) - sum(x[, i] * t) * t/sumt2
  }
  else if (demean) {
    x <- sweep(x, 2, colMeans(x), check.margin = FALSE)
  }
  x <- spec.taper(x, taper)
  u2 <- (1 - (5/8) * taper * 2)
  u4 <- (1 - (93/128) * taper * 2)
  if (pad > 0) {
    x <- rbind(x, matrix(0, nrow = N * pad, ncol = ncol(x)))
    N <- nrow(x)
  }
  NewN <- if (fast) 
    nextn(N)
  else N
  x <- rbind(x, matrix(0, nrow = (NewN - N), ncol = ncol(x)))
  N <- nrow(x)
  Nspec <- floor(N/2)
  freq <- seq.int(from = xfreq/N, by = xfreq/N, length.out = Nspec)
  xfft <- mvfft(x)
  pgram <- array(NA, dim = c(N, ncol(x), ncol(x)))
  for (i in 1:ncol(x)) {
    for (j in 1:ncol(x)) {
      pgram[, i, j] <- xfft[, i] * Conj(xfft[, j])/(N0 * xfreq)
      pgram[1, i, j] <- 0.5 * (pgram[2, i, j] + pgram[N, i, j])
    }
  }
  if (!is.null(kernel)) {
    for (i in 1:ncol(x)) for (j in 1:ncol(x)) pgram[, i, j] <- kernapply(pgram[, i, j], kernel, circular = TRUE)
    df <- df.kernel(kernel)
    bandwidth <- bandwidth.kernel(kernel)
  }
  else {
    df <- 2
    bandwidth <- sqrt(1/12)
  }
  df <- df/(u4/u2^2)
  df <- df * (N0/N)
  bandwidth <- bandwidth * xfreq/N
  pgram <- pgram[2:(Nspec + 1), , , drop = FALSE]
  spec <- matrix(NA, nrow = Nspec, ncol = nser)
  for (i in 1:nser) spec[, i] <- Re(pgram[1:Nspec, i, i])
  if (nser == 1) {
    coh <- phase <- NULL
  }
  else {
    coh <- phase <- matrix(NA, nrow = Nspec, ncol = nser * (nser - 1)/2)
    for (i in 1:(nser - 1)) {
      for (j in (i + 1):nser) {
        coh[, i + (j - 1) * (j - 2)/2] <- Mod(pgram[, i, j])^2/(spec[, i] * spec[, j])
        phase[, i + (j - 1) * (j - 2)/2] <- Arg(pgram[, i, j])
      }
    }
  }
  for (i in 1:nser) spec[, i] <- spec[, i]/u2
  spec <- drop(spec)
  spg.out <- list(freq = freq, spec = spec, coh = coh, phase = phase, kernel = kernel, df = df, bandwidth = bandwidth, n.used = N, orig.n = N0, series = series, snames = colnames(x), method = if (is.null(kernel)) "Raw Periodogram" else "Smoothed Periodogram", taper = taper, pad = pad, detrend = detrend, demean = demean)
  class(spg.out) <- "spec"
  if (plot) {
    plot(spg.out, ...)
    invisible(spg.out)
  }
  else spg.out
}, function (x, spans = NULL, kernel = NULL, taper = 0.1, pad = 0, fast = TRUE, demean = FALSE, detrend = TRUE, plot = TRUE, na.action = na.fail, ...) 
{
  series <- deparse1(substitute(x))
  x <- na.action(as.ts(x))
  xfreq <- frequency(x)
  x <- as.matrix(x)
  N <- N0 <- nrow(x)
  nser <- ncol(x)
  if (!is.null(spans)) 
    kernel <- {
      if (is.tskernel(spans)) 
        spans
      else kernel("modified.daniell", spans%/%2)
    }
  if (!is.null(kernel) && !is.tskernel(kernel)) 
    stop("must specify 'spans' or a valid kernel")
  if (detrend) {
    t <- 1:N - (N + 1)/2
    sumt2 <- N * (N^2 - 1)/12
    for (i in 1:ncol(x)) x[, i] <- x[, i] - mean(x[, i]) - sum(x[, i] * t) * t/sumt2
  }
  else if (demean) {
    x <- sweep(x, 2, colMeans(x), check.margin = FALSE)
  }
  x <- spec.taper(x, taper)
  u2 <- (1 - (5/8) * taper * 2)
  u4 <- (1 - (93/128) * taper * 2)
  if (pad > 0) {
    x <- rbind(x, matrix(0, nrow = N * pad, ncol = ncol(x)))
    N <- nrow(x)
  }
  NewN <- if (fast) 
    nextn(N)
  else N
  x <- rbind(x, matrix(0, nrow = (NewN - N), ncol = ncol(x)))
  N <- nrow(x)
  Nspec <- floor(N/2)
  freq <- seq.int(from = xfreq/N, by = xfreq/N, length.out = Nspec)
  xfft <- mvfft(x)
  pgram <- array(NA, dim = c(N, ncol(x), ncol(x)))
  for (i in 1:ncol(x)) {
    for (j in 1:ncol(x)) {
      pgram[, i, j] <- xfft[, i] * Conj(xfft[, j])/(N0 * xfreq)
      pgram[1, i, j] <- 0.5 * (pgram[2, i, j] + pgram[N, i, j])
    }
  }
  if (!is.null(kernel)) {
    for (i in 1:ncol(x)) for (j in 1:ncol(x)) pgram[, i, j] <- kernapply(pgram[, i, j], kernel, circular = TRUE)
    df <- df.kernel(kernel)
    bandwidth <- bandwidth.kernel(kernel)
  }
  else {
    df <- 2
    bandwidth <- sqrt(1/12)
  }
  df <- df/(u4/u2^2)
  df <- df * (N0/N)
  bandwidth <- bandwidth * xfreq/N
  pgram <- pgram[2:(Nspec + 1), , , drop = FALSE]
  spec <- matrix(NA, nrow = Nspec, ncol = nser)
  for (i in 1:nser) spec[, i] <- Re(pgram[1:Nspec, i, i])
  if (nser == 1) {
    coh <- phase <- NULL
  }
  else {
    coh <- phase <- matrix(NA, nrow = Nspec, ncol = nser * (nser - 1)/2)
    for (i in 1:(nser - 1)) {
      for (j in (i + 1):nser) {
        coh[, i + (j - 1) * (j - 2)/2] <- Mod(pgram[, i, j])^2/(spec[, i] * spec[, j])
        phase[, i + (j - 1) * (j - 2)/2] <- Arg(pgram[, i, j])
      }
    }
  }
  for (i in 1:nser) spec[, i] <- spec[, i]/u2
  spec <- drop(spec)
  spg.out <- list(freq = freq, spec = spec, coh = coh, phase = phase, kernel = kernel, df = df, bandwidth = bandwidth, n.used = N, orig.n = N0, series = series, snames = colnames(x), method = if (is.null(kernel)) "Raw Periodogram" else "Smoothed Periodogram", taper = taper, pad = pad, detrend = detrend, demean = demean)
  class(spg.out) <- "spec"
  if (plot) {
    plot(spg.out, ...)
    invisible(spg.out)
  }
  else spg.out
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
spec.taper
list(`package:stats` = function (x, p = 0.1) 
{
  if (any(p < 0) || any(p > 0.5)) 
    stop("'p' must be between 0 and 0.5")
  a <- attributes(x)
  x <- as.matrix(x)
  nc <- ncol(x)
  if (length(p) == 1) 
    p <- rep(p, nc)
  else if (length(p) != nc) 
    stop("length of 'p' must be 1 or equal the number of columns of 'x'")
  nr <- nrow(x)
  for (i in 1:nc) {
    m <- floor(nr * p[i])
    if (m == 0) 
      next
    w <- 0.5 * (1 - cos(pi * seq.int(1, 2 * m - 1, by = 2)/(2 * m)))
    x[, i] <- c(w, rep_len(1, nr - 2 * m), rev(w)) * x[, i]
  }
  attributes(x) <- a
  x
}, function (x, p = 0.1) 
{
  if (any(p < 0) || any(p > 0.5)) 
    stop("'p' must be between 0 and 0.5")
  a <- attributes(x)
  x <- as.matrix(x)
  nc <- ncol(x)
  if (length(p) == 1) 
    p <- rep(p, nc)
  else if (length(p) != nc) 
    stop("length of 'p' must be 1 or equal the number of columns of 'x'")
  nr <- nrow(x)
  for (i in 1:nc) {
    m <- floor(nr * p[i])
    if (m == 0) 
      next
    w <- 0.5 * (1 - cos(pi * seq.int(1, 2 * m - 1, by = 2)/(2 * m)))
    x[, i] <- c(w, rep_len(1, nr - 2 * m), rev(w)) * x[, i]
  }
  attributes(x) <- a
  x
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
spectrum
list(`package:stats` = function (x, ..., method = c("pgram", "ar")) 
{
  switch(match.arg(method), pgram = spec.pgram(x, ...), ar = spec.ar(x, ...))
}, function (x, ..., method = c("pgram", "ar")) 
{
  switch(match.arg(method), pgram = spec.pgram(x, ...), ar = spec.ar(x, ...))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
spline
list(`package:stats` = function (x, y = NULL, n = 3 * length(x), method = "fmm", xmin = min(x), xmax = max(x), xout, ties = mean) 
{
  method <- pmatch(method, c("periodic", "natural", "fmm", "hyman"))
  if (is.na(method)) 
    stop("invalid interpolation method")
  x <- regularize.values(x, y, ties, missing(ties))
  y <- x$y
  x <- x$x
  nx <- length(x)
  if (is.na(nx)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  if (nx == 0) 
    stop("zero non-NA points")
  if (method == 1 && y[1] != y[nx]) {
    warning("spline: first and last y values differ - using y[1] for both")
    y[nx] <- y[1]
  }
  if (method == 4) {
    dy <- diff(y)
    if (!(all(dy >= 0) || all(dy <= 0))) 
      stop("'y' must be increasing or decreasing")
  }
  if (missing(xout)) 
    xout <- seq.int(xmin, xmax, length.out = n)
  else n <- length(xout)
  if (n <= 0) 
    stop("'spline' requires n >= 1")
  xout <- as.double(xout)
  z <- .Call(C_SplineCoef, min(3, method), x, y)
  if (method == 4) 
    z <- spl_coef_conv(hyman_filter(z))
  list(x = xout, y = .Call(C_SplineEval, xout, z))
}, function (x, y = NULL, n = 3 * length(x), method = "fmm", xmin = min(x), xmax = max(x), xout, ties = mean) 
{
  method <- pmatch(method, c("periodic", "natural", "fmm", "hyman"))
  if (is.na(method)) 
    stop("invalid interpolation method")
  x <- regularize.values(x, y, ties, missing(ties))
  y <- x$y
  x <- x$x
  nx <- length(x)
  if (is.na(nx)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  if (nx == 0) 
    stop("zero non-NA points")
  if (method == 1 && y[1] != y[nx]) {
    warning("spline: first and last y values differ - using y[1] for both")
    y[nx] <- y[1]
  }
  if (method == 4) {
    dy <- diff(y)
    if (!(all(dy >= 0) || all(dy <= 0))) 
      stop("'y' must be increasing or decreasing")
  }
  if (missing(xout)) 
    xout <- seq.int(xmin, xmax, length.out = n)
  else n <- length(xout)
  if (n <= 0) 
    stop("'spline' requires n >= 1")
  xout <- as.double(xout)
  z <- .Call(C_SplineCoef, min(3, method), x, y)
  if (method == 4) 
    z <- spl_coef_conv(hyman_filter(z))
  list(x = xout, y = .Call(C_SplineEval, xout, z))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
splinefun
list(`package:stats` = function (x, y = NULL, method = c("fmm", "periodic", "natural", "monoH.FC", "hyman"), ties = mean) 
{
  x <- regularize.values(x, y, ties, missing(ties))
  y <- x$y
  x <- x$x
  nx <- length(x)
  if (is.na(nx)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  if (nx == 0) 
    stop("zero non-NA points")
  method <- match.arg(method)
  if (method == "periodic" && y[1] != y[nx]) {
    warning("spline: first and last y values differ - using y[1L] for both")
    y[nx] <- y[1]
  }
  if (method == "monoH.FC") {
    n1 <- nx - 1
    dy <- y[-1] - y[-nx]
    dx <- x[-1] - x[-nx]
    Sx <- dy/dx
    m <- c(Sx[1], (Sx[-1] + Sx[-n1])/2, Sx[n1])
    m <- .Call(C_monoFC_m, m, Sx)
    return(splinefunH0(x0 = x, y0 = y, m = m, dx = dx))
  }
  iMeth <- match(method, c("periodic", "natural", "fmm", "monoH.FC", "hyman"))
  if (iMeth == 5) {
    dy <- diff(y)
    if (!(all(dy >= 0) || all(dy <= 0))) 
      stop("'y' must be increasing or decreasing")
  }
  z <- .Call(C_SplineCoef, min(3, iMeth), x, y)
  if (iMeth == 5) 
    z <- spl_coef_conv(hyman_filter(z))
  rm(x, y, nx, method, iMeth, ties)
  function(x, deriv = 0) {
    deriv <- as.integer(deriv)
    if (deriv < 0 || deriv > 3) 
      stop("'deriv' must be between 0 and 3")
    if (deriv > 0) {
      z0 <- double(z$n)
      z[c("y", "b", "c")] <- switch(deriv, list(y = z$b, b = 2 * z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d, c = z0), list(y = 6 * z$d, b = z0, c = z0))
      z[["d"]] <- z0
    }
    res <- .splinefun(x, z)
    if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1])) 
      res[ind] <- ifelse(deriv == 1, z$y[1], 0)
    res
  }
}, function (x, y = NULL, method = c("fmm", "periodic", "natural", "monoH.FC", "hyman"), ties = mean) 
{
  x <- regularize.values(x, y, ties, missing(ties))
  y <- x$y
  x <- x$x
  nx <- length(x)
  if (is.na(nx)) 
    stop(gettextf("invalid value of %s", "length(x)"), domain = NA)
  if (nx == 0) 
    stop("zero non-NA points")
  method <- match.arg(method)
  if (method == "periodic" && y[1] != y[nx]) {
    warning("spline: first and last y values differ - using y[1L] for both")
    y[nx] <- y[1]
  }
  if (method == "monoH.FC") {
    n1 <- nx - 1
    dy <- y[-1] - y[-nx]
    dx <- x[-1] - x[-nx]
    Sx <- dy/dx
    m <- c(Sx[1], (Sx[-1] + Sx[-n1])/2, Sx[n1])
    m <- .Call(C_monoFC_m, m, Sx)
    return(splinefunH0(x0 = x, y0 = y, m = m, dx = dx))
  }
  iMeth <- match(method, c("periodic", "natural", "fmm", "monoH.FC", "hyman"))
  if (iMeth == 5) {
    dy <- diff(y)
    if (!(all(dy >= 0) || all(dy <= 0))) 
      stop("'y' must be increasing or decreasing")
  }
  z <- .Call(C_SplineCoef, min(3, iMeth), x, y)
  if (iMeth == 5) 
    z <- spl_coef_conv(hyman_filter(z))
  rm(x, y, nx, method, iMeth, ties)
  function(x, deriv = 0) {
    deriv <- as.integer(deriv)
    if (deriv < 0 || deriv > 3) 
      stop("'deriv' must be between 0 and 3")
    if (deriv > 0) {
      z0 <- double(z$n)
      z[c("y", "b", "c")] <- switch(deriv, list(y = z$b, b = 2 * z$c, c = 3 * z$d), list(y = 2 * z$c, b = 6 * z$d, c = z0), list(y = 6 * z$d, b = z0, c = z0))
      z[["d"]] <- z0
    }
    res <- .splinefun(x, z)
    if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1])) 
      res[ind] <- ifelse(deriv == 1, z$y[1], 0)
    res
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
splinefunH
list(`package:stats` = function (x, y, m) 
{
  n <- length(x)
  stopifnot(is.numeric(x), is.numeric(y), is.numeric(m), length(y) == n, length(m) == n)
  if (is.unsorted(x)) {
    i <- sort.list(x)
    x <- x[i]
    y <- y[i]
    m <- m[i]
  }
  dx <- x[-1] - x[-n]
  if (anyNA(dx) || any(dx == 0)) 
    stop("'x' must be *strictly* increasing (non - NA)")
  splinefunH0(x, y, m, dx = dx)
}, function (x, y, m) 
{
  n <- length(x)
  stopifnot(is.numeric(x), is.numeric(y), is.numeric(m), length(y) == n, length(m) == n)
  if (is.unsorted(x)) {
    i <- sort.list(x)
    x <- x[i]
    y <- y[i]
    m <- m[i]
  }
  dx <- x[-1] - x[-n]
  if (anyNA(dx) || any(dx == 0)) 
    stop("'x' must be *strictly* increasing (non - NA)")
  splinefunH0(x, y, m, dx = dx)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSasymp
list(`package:stats` = function (input, Asym, R0, lrc) 
{
  .expr1 <- R0 - Asym
  .expr2 <- exp(lrc)
  .expr5 <- exp(((-.expr2) * input))
  .value <- Asym + (.expr1 * .expr5)
  .actualArgs <- as.list(match.call()[c("Asym", "R0", "lrc")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 3), list(NULL, c("Asym", "R0", "lrc")))
    .grad[, "Asym"] <- 1 - .expr5
    .grad[, "R0"] <- .expr5
    .grad[, "lrc"] <- -(.expr1 * (.expr5 * (.expr2 * input)))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (input, Asym, R0, lrc) 
{
  .expr1 <- R0 - Asym
  .expr2 <- exp(lrc)
  .expr5 <- exp(((-.expr2) * input))
  .value <- Asym + (.expr1 * .expr5)
  .actualArgs <- as.list(match.call()[c("Asym", "R0", "lrc")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 3), list(NULL, c("Asym", "R0", "lrc")))
    .grad[, "Asym"] <- 1 - .expr5
    .grad[, "R0"] <- .expr5
    .grad[, "lrc"] <- -(.expr1 * (.expr5 * (.expr2 * input)))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSasympOff
list(`package:stats` = function (input, Asym, lrc, c0) 
{
  .expr1 <- exp(lrc)
  .expr3 <- input - c0
  .expr5 <- exp(((-.expr1) * .expr3))
  .expr6 <- 1 - .expr5
  .value <- Asym * .expr6
  .actualArgs <- as.list(match.call()[c("Asym", "lrc", "c0")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 3), list(NULL, c("Asym", "lrc", "c0")))
    .grad[, "Asym"] <- .expr6
    .grad[, "lrc"] <- Asym * (.expr5 * (.expr1 * .expr3))
    .grad[, "c0"] <- -(Asym * (.expr5 * .expr1))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (input, Asym, lrc, c0) 
{
  .expr1 <- exp(lrc)
  .expr3 <- input - c0
  .expr5 <- exp(((-.expr1) * .expr3))
  .expr6 <- 1 - .expr5
  .value <- Asym * .expr6
  .actualArgs <- as.list(match.call()[c("Asym", "lrc", "c0")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 3), list(NULL, c("Asym", "lrc", "c0")))
    .grad[, "Asym"] <- .expr6
    .grad[, "lrc"] <- Asym * (.expr5 * (.expr1 * .expr3))
    .grad[, "c0"] <- -(Asym * (.expr5 * .expr1))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSasympOrig
list(`package:stats` = function (input, Asym, lrc) 
{
  .expr1 <- exp(lrc)
  .expr4 <- exp(((-.expr1) * input))
  .expr5 <- 1 - .expr4
  .value <- Asym * .expr5
  .actualArgs <- as.list(match.call()[c("Asym", "lrc")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 2), list(NULL, c("Asym", "lrc")))
    .grad[, "Asym"] <- .expr5
    .grad[, "lrc"] <- Asym * (.expr4 * (.expr1 * input))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (input, Asym, lrc) 
{
  .expr1 <- exp(lrc)
  .expr4 <- exp(((-.expr1) * input))
  .expr5 <- 1 - .expr4
  .value <- Asym * .expr5
  .actualArgs <- as.list(match.call()[c("Asym", "lrc")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 2), list(NULL, c("Asym", "lrc")))
    .grad[, "Asym"] <- .expr5
    .grad[, "lrc"] <- Asym * (.expr4 * (.expr1 * input))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSbiexp
list(`package:stats` = function (input, A1, lrc1, A2, lrc2) 
{
  .expr1 <- exp(lrc1)
  .expr4 <- exp(((-.expr1) * input))
  .expr6 <- exp(lrc2)
  .expr9 <- exp(((-.expr6) * input))
  .value <- (A1 * .expr4) + (A2 * .expr9)
  .actualArgs <- as.list(match.call()[c("A1", "lrc1", "A2", "lrc2")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 4), list(NULL, c("A1", "lrc1", "A2", "lrc2")))
    .grad[, "A1"] <- .expr4
    .grad[, "lrc1"] <- -(A1 * (.expr4 * (.expr1 * input)))
    .grad[, "A2"] <- .expr9
    .grad[, "lrc2"] <- -(A2 * (.expr9 * (.expr6 * input)))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (input, A1, lrc1, A2, lrc2) 
{
  .expr1 <- exp(lrc1)
  .expr4 <- exp(((-.expr1) * input))
  .expr6 <- exp(lrc2)
  .expr9 <- exp(((-.expr6) * input))
  .value <- (A1 * .expr4) + (A2 * .expr9)
  .actualArgs <- as.list(match.call()[c("A1", "lrc1", "A2", "lrc2")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 4), list(NULL, c("A1", "lrc1", "A2", "lrc2")))
    .grad[, "A1"] <- .expr4
    .grad[, "lrc1"] <- -(A1 * (.expr4 * (.expr1 * input)))
    .grad[, "A2"] <- .expr9
    .grad[, "lrc2"] <- -(A2 * (.expr9 * (.expr6 * input)))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSD
list(`package:stats` = function (object, ...) 
  UseMethod("SSD"), function (object, ...) 
    UseMethod("SSD"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSfol
list(`package:stats` = function (Dose, input, lKe, lKa, lCl) 
{
  .expr4 <- Dose * exp((lKe + lKa) - lCl)
  .expr5 <- exp(lKe)
  .expr8 <- exp(-.expr5 * input)
  .expr9 <- exp(lKa)
  .expr12 <- exp(-.expr9 * input)
  .expr14 <- .expr4 * (.expr8 - .expr12)
  .expr15 <- .expr9 - .expr5
  .expr16 <- .expr14/.expr15
  .expr23 <- .expr15^2
  .value <- .expr16
  .actualArgs <- as.list(match.call()[c("lKe", "lKa", "lCl")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 3), list(NULL, c("lKe", "lKa", "lCl")))
    .grad[, "lKe"] <- (.expr14 - .expr4 * (.expr8 * (.expr5 * input)))/.expr15 + .expr14 * .expr5/.expr23
    .grad[, "lKa"] <- (.expr14 + .expr4 * (.expr12 * (.expr9 * input)))/.expr15 - .expr14 * .expr9/.expr23
    .grad[, "lCl"] <- -.expr16
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (Dose, input, lKe, lKa, lCl) 
{
  .expr4 <- Dose * exp((lKe + lKa) - lCl)
  .expr5 <- exp(lKe)
  .expr8 <- exp(-.expr5 * input)
  .expr9 <- exp(lKa)
  .expr12 <- exp(-.expr9 * input)
  .expr14 <- .expr4 * (.expr8 - .expr12)
  .expr15 <- .expr9 - .expr5
  .expr16 <- .expr14/.expr15
  .expr23 <- .expr15^2
  .value <- .expr16
  .actualArgs <- as.list(match.call()[c("lKe", "lKa", "lCl")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 3), list(NULL, c("lKe", "lKa", "lCl")))
    .grad[, "lKe"] <- (.expr14 - .expr4 * (.expr8 * (.expr5 * input)))/.expr15 + .expr14 * .expr5/.expr23
    .grad[, "lKa"] <- (.expr14 + .expr4 * (.expr12 * (.expr9 * input)))/.expr15 - .expr14 * .expr9/.expr23
    .grad[, "lCl"] <- -.expr16
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSfpl
list(`package:stats` = function (input, A, B, xmid, scal) 
{
  .expr1 <- B - A
  .expr2 <- xmid - input
  .expr4 <- exp(.e2 <- .expr2/scal)
  .expr5 <- 1 + .expr4
  .value <- A + .expr1/.expr5
  .actualArgs <- as.list(match.call()[c("A", "B", "xmid", "scal")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .expr8 <- 1/.expr5
    .expr13 <- .expr5^2
    .grad <- array(0, c(length(.value), 4), list(NULL, c("A", "B", "xmid", "scal")))
    .grad[, "A"] <- 1 - .expr8
    .grad[, "B"] <- .expr8
    .grad[, "xmid"] <- -(xm <- .expr1 * .expr4/scal/.expr13)
    .grad[, "scal"] <- xm * .e2
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (input, A, B, xmid, scal) 
{
  .expr1 <- B - A
  .expr2 <- xmid - input
  .expr4 <- exp(.e2 <- .expr2/scal)
  .expr5 <- 1 + .expr4
  .value <- A + .expr1/.expr5
  .actualArgs <- as.list(match.call()[c("A", "B", "xmid", "scal")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .expr8 <- 1/.expr5
    .expr13 <- .expr5^2
    .grad <- array(0, c(length(.value), 4), list(NULL, c("A", "B", "xmid", "scal")))
    .grad[, "A"] <- 1 - .expr8
    .grad[, "B"] <- .expr8
    .grad[, "xmid"] <- -(xm <- .expr1 * .expr4/scal/.expr13)
    .grad[, "scal"] <- xm * .e2
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSgompertz
list(`package:stats` = function (x, Asym, b2, b3) 
{
  .expr2 <- b3^x
  .expr4 <- exp(-b2 * .expr2)
  .value <- Asym * .expr4
  .actualArgs <- as.list(match.call()[c("Asym", "b2", "b3")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 3), list(NULL, c("Asym", "b2", "b3")))
    .grad[, "Asym"] <- .expr4
    .grad[, "b2"] <- -Asym * (.expr4 * .expr2)
    .grad[, "b3"] <- -Asym * (.expr4 * (b2 * (b3^(x - 1) * x)))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (x, Asym, b2, b3) 
{
  .expr2 <- b3^x
  .expr4 <- exp(-b2 * .expr2)
  .value <- Asym * .expr4
  .actualArgs <- as.list(match.call()[c("Asym", "b2", "b3")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 3), list(NULL, c("Asym", "b2", "b3")))
    .grad[, "Asym"] <- .expr4
    .grad[, "b2"] <- -Asym * (.expr4 * .expr2)
    .grad[, "b3"] <- -Asym * (.expr4 * (b2 * (b3^(x - 1) * x)))
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSlogis
list(`package:stats` = function (input, Asym, xmid, scal) 
{
  .expr1 <- xmid - input
  .expr3 <- exp(.e2 <- .expr1/scal)
  .expr4 <- 1 + .expr3
  .value <- Asym/.expr4
  .actualArgs <- as.list(match.call()[c("Asym", "xmid", "scal")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .expr10 <- .expr4^2
    .grad <- array(0, c(length(.value), 3), list(NULL, c("Asym", "xmid", "scal")))
    .grad[, "Asym"] <- 1/.expr4
    .grad[, "xmid"] <- -(xm <- Asym * .expr3/scal/.expr10)
    .grad[, "scal"] <- xm * .e2
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (input, Asym, xmid, scal) 
{
  .expr1 <- xmid - input
  .expr3 <- exp(.e2 <- .expr1/scal)
  .expr4 <- 1 + .expr3
  .value <- Asym/.expr4
  .actualArgs <- as.list(match.call()[c("Asym", "xmid", "scal")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .expr10 <- .expr4^2
    .grad <- array(0, c(length(.value), 3), list(NULL, c("Asym", "xmid", "scal")))
    .grad[, "Asym"] <- 1/.expr4
    .grad[, "xmid"] <- -(xm <- Asym * .expr3/scal/.expr10)
    .grad[, "scal"] <- xm * .e2
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSmicmen
list(`package:stats` = function (input, Vm, K) 
{
  .expr1 <- Vm * input
  .expr2 <- K + input
  .value <- .expr1/.expr2
  .actualArgs <- as.list(match.call()[c("Vm", "K")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 2), list(NULL, c("Vm", "K")))
    .grad[, "Vm"] <- input/.expr2
    .grad[, "K"] <- -(.expr1/.expr2^2)
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (input, Vm, K) 
{
  .expr1 <- Vm * input
  .expr2 <- K + input
  .value <- .expr1/.expr2
  .actualArgs <- as.list(match.call()[c("Vm", "K")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 2), list(NULL, c("Vm", "K")))
    .grad[, "Vm"] <- input/.expr2
    .grad[, "K"] <- -(.expr1/.expr2^2)
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
SSweibull
list(`package:stats` = function (x, Asym, Drop, lrc, pwr) 
{
  .expr1 <- exp(lrc)
  .expr3 <- x^pwr
  .expr5 <- exp(-(ee <- .expr1 * .expr3))
  .value <- Asym - (De <- Drop * .expr5)
  .actualArgs <- as.list(match.call()[c("Asym", "Drop", "lrc", "pwr")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 4), list(NULL, c("Asym", "Drop", "lrc", "pwr")))
    .grad[, "Asym"] <- 1
    .grad[, "Drop"] <- -.expr5
    .grad[, "lrc"] <- lrc <- De * ee
    .grad[, "pwr"] <- lrc * log(x)
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
}, function (x, Asym, Drop, lrc, pwr) 
{
  .expr1 <- exp(lrc)
  .expr3 <- x^pwr
  .expr5 <- exp(-(ee <- .expr1 * .expr3))
  .value <- Asym - (De <- Drop * .expr5)
  .actualArgs <- as.list(match.call()[c("Asym", "Drop", "lrc", "pwr")])
  if (all(vapply(.actualArgs, is.name, NA))) {
    .grad <- array(0, c(length(.value), 4), list(NULL, c("Asym", "Drop", "lrc", "pwr")))
    .grad[, "Asym"] <- 1
    .grad[, "Drop"] <- -.expr5
    .grad[, "lrc"] <- lrc <- De * ee
    .grad[, "pwr"] <- lrc * log(x)
    dimnames(.grad) <- list(NULL, .actualArgs)
    attr(.value, "gradient") <- .grad
  }
  .value
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
start
list(`package:stats` = function (x, ...) 
  UseMethod("start"), function (x, ...) 
    UseMethod("start"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
stat.anova
list(`package:stats` = function (table, test = c("Rao", "LRT", "Chisq", "F", "Cp"), scale, df.scale, n) 
{
  test <- match.arg(test)
  dev.col <- match("Deviance", colnames(table))
  if (test == "Rao") 
    dev.col <- match("Rao", colnames(table))
  if (is.na(dev.col)) 
    dev.col <- match("Sum of Sq", colnames(table))
  switch(test, Rao = , LRT = , Chisq = {
    dfs <- table[, "Df"]
    vals <- table[, dev.col]/scale * sign(dfs)
    vals[dfs %in% 0] <- NA
    vals[!is.na(vals) & vals < 0] <- NA
    cbind(table, `Pr(>Chi)` = pchisq(vals, abs(dfs), lower.tail = FALSE))
  }, F = {
    dfs <- table[, "Df"]
    Fvalue <- (table[, dev.col]/dfs)/scale
    Fvalue[dfs %in% 0] <- NA
    Fvalue[!is.na(Fvalue) & Fvalue < 0] <- NA
    cbind(table, F = Fvalue, `Pr(>F)` = pf(Fvalue, abs(dfs), df.scale, lower.tail = FALSE))
  }, Cp = {
    if ("RSS" %in% names(table)) {
      cbind(table, Cp = table[, "RSS"] + 2 * scale * (n - table[, "Res.Df"]))
    } else {
      cbind(table, Cp = table[, "Resid. Dev"] + 2 * scale * (n - table[, "Resid. Df"]))
    }
  })
}, function (table, test = c("Rao", "LRT", "Chisq", "F", "Cp"), scale, df.scale, n) 
{
  test <- match.arg(test)
  dev.col <- match("Deviance", colnames(table))
  if (test == "Rao") 
    dev.col <- match("Rao", colnames(table))
  if (is.na(dev.col)) 
    dev.col <- match("Sum of Sq", colnames(table))
  switch(test, Rao = , LRT = , Chisq = {
    dfs <- table[, "Df"]
    vals <- table[, dev.col]/scale * sign(dfs)
    vals[dfs %in% 0] <- NA
    vals[!is.na(vals) & vals < 0] <- NA
    cbind(table, `Pr(>Chi)` = pchisq(vals, abs(dfs), lower.tail = FALSE))
  }, F = {
    dfs <- table[, "Df"]
    Fvalue <- (table[, dev.col]/dfs)/scale
    Fvalue[dfs %in% 0] <- NA
    Fvalue[!is.na(Fvalue) & Fvalue < 0] <- NA
    cbind(table, F = Fvalue, `Pr(>F)` = pf(Fvalue, abs(dfs), df.scale, lower.tail = FALSE))
  }, Cp = {
    if ("RSS" %in% names(table)) {
      cbind(table, Cp = table[, "RSS"] + 2 * scale * (n - table[, "Res.Df"]))
    } else {
      cbind(table, Cp = table[, "Resid. Dev"] + 2 * scale * (n - table[, "Resid. Df"]))
    }
  })
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
step
list(`package:stats` = function (object, scope, scale = 0, direction = c("both", "backward", "forward"), trace = 1, keep = NULL, steps = 1000, k = 2, ...) 
{
  mydeviance <- function(x, ...) deviance(x) %||% extractAIC(x, k = 0)[2]
  cut.string <- function(string) {
    if (length(string) > 1) 
      string[-1] <- paste0("\n", string[-1])
    string
  }
  re.arrange <- function(keep) {
    namr <- names(k1 <- keep[[1]])
    namc <- names(keep)
    nc <- length(keep)
    nr <- length(k1)
    array(unlist(keep, recursive = FALSE), c(nr, nc), list(namr, namc))
  }
  step.results <- function(models, fit, object, usingCp = FALSE) {
    change <- sapply(models, `[[`, "change")
    rd <- sapply(models, `[[`, "deviance")
    dd <- c(NA, abs(diff(rd)))
    rdf <- sapply(models, `[[`, "df.resid")
    ddf <- c(NA, diff(rdf))
    AIC <- sapply(models, `[[`, "AIC")
    heading <- c("Stepwise Model Path \nAnalysis of Deviance Table", "\nInitial Model:", deparse(formula(object)), "\nFinal Model:", deparse(formula(fit)), "\n")
    aod <- data.frame(Step = I(change), Df = ddf, Deviance = dd, `Resid. Df` = rdf, `Resid. Dev` = rd, AIC = AIC, check.names = FALSE)
    if (usingCp) {
      cn <- colnames(aod)
      cn[cn == "AIC"] <- "Cp"
      colnames(aod) <- cn
    }
    attr(aod, "heading") <- heading
    fit$anova <- aod
    fit
  }
  Terms <- terms(object)
  object$call$formula <- object$formula <- Terms
  md <- missing(direction)
  direction <- match.arg(direction)
  backward <- direction == "both" | direction == "backward"
  forward <- direction == "both" | direction == "forward"
  if (missing(scope)) {
    fdrop <- numeric()
    fadd <- attr(Terms, "factors")
    if (md) 
      forward <- FALSE
  }
  else {
    if (is.list(scope)) {
      fdrop <- if (!is.null(fdrop <- scope$lower)) 
        attr(terms(update.formula(object, fdrop)), "factors")
      else numeric()
      fadd <- if (!is.null(fadd <- scope$upper)) 
        attr(terms(update.formula(object, fadd)), "factors")
    }
    else {
      fadd <- if (!is.null(fadd <- scope)) 
        attr(terms(update.formula(object, scope)), "factors")
      fdrop <- numeric()
    }
  }
  models <- vector("list", steps)
  if (!is.null(keep)) 
    keep.list <- vector("list", steps)
  n <- nobs(object, use.fallback = TRUE)
  fit <- object
  bAIC <- extractAIC(fit, scale, k = k, ...)
  edf <- bAIC[1]
  bAIC <- bAIC[2]
  if (is.na(bAIC)) 
    stop("AIC is not defined for this model, so 'step' cannot proceed")
  if (bAIC == -Inf) 
    stop("AIC is -infinity for this model, so 'step' cannot proceed")
  nm <- 1
  if (trace) {
    cat("Start:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), "\n\n", sep = "")
    flush.console()
  }
  models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - edf, change = "", AIC = bAIC)
  if (!is.null(keep)) 
    keep.list[[nm]] <- keep(fit, bAIC)
  usingCp <- FALSE
  while (steps > 0) {
    steps <- steps - 1
    AIC <- bAIC
    ffac <- attr(Terms, "factors")
    scope <- factor.scope(ffac, list(add = fadd, drop = fdrop))
    aod <- NULL
    change <- NULL
    if (backward && length(scope$drop)) {
      aod <- drop1(fit, scope$drop, scale = scale, trace = trace, k = k, ...)
      rn <- row.names(aod)
      row.names(aod) <- c(rn[1], paste("-", rn[-1]))
      if (any(aod$Df == 0, na.rm = TRUE)) {
        zdf <- aod$Df == 0 & !is.na(aod$Df)
        change <- rev(rownames(aod)[zdf])[1]
      }
    }
    if (is.null(change)) {
      if (forward && length(scope$add)) {
        aodf <- add1(fit, scope$add, scale = scale, trace = trace, k = k, ...)
        rn <- row.names(aodf)
        row.names(aodf) <- c(rn[1], paste("+", rn[-1]))
        aod <- if (is.null(aod)) 
          aodf
        else rbind(aod, aodf[-1, , drop = FALSE])
      }
      attr(aod, "heading") <- NULL
      nzdf <- if (!is.null(aod$Df)) 
        aod$Df != 0 | is.na(aod$Df)
      aod <- aod[nzdf, ]
      if (is.null(aod) || ncol(aod) == 0) 
        break
      nc <- match(c("Cp", "AIC"), names(aod))
      nc <- nc[!is.na(nc)][1]
      o <- order(aod[, nc])
      if (trace) 
        print(aod[o, ])
      if (o[1] == 1) 
        break
      change <- rownames(aod)[o[1]]
    }
    usingCp <- match("Cp", names(aod), 0) > 0
    fit <- update(fit, paste("~ .", change), evaluate = FALSE)
    fit <- eval.parent(fit)
    nnew <- nobs(fit, use.fallback = TRUE)
    if (all(is.finite(c(n, nnew))) && nnew != n) 
      stop("number of rows in use has changed: remove missing values?")
    Terms <- terms(fit)
    bAIC <- extractAIC(fit, scale, k = k, ...)
    edf <- bAIC[1]
    bAIC <- bAIC[2]
    if (trace) {
      cat("\nStep:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), "\n\n", sep = "")
      flush.console()
    }
    if (bAIC >= AIC + 1e-07) 
      break
    nm <- nm + 1
    models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - edf, change = change, AIC = bAIC)
    if (!is.null(keep)) 
      keep.list[[nm]] <- keep(fit, bAIC)
  }
  if (!is.null(keep)) 
    fit$keep <- re.arrange(keep.list[seq(nm)])
  step.results(models = models[seq(nm)], fit, object, usingCp)
}, function (object, scope, scale = 0, direction = c("both", "backward", "forward"), trace = 1, keep = NULL, steps = 1000, k = 2, ...) 
{
  mydeviance <- function(x, ...) deviance(x) %||% extractAIC(x, k = 0)[2]
  cut.string <- function(string) {
    if (length(string) > 1) 
      string[-1] <- paste0("\n", string[-1])
    string
  }
  re.arrange <- function(keep) {
    namr <- names(k1 <- keep[[1]])
    namc <- names(keep)
    nc <- length(keep)
    nr <- length(k1)
    array(unlist(keep, recursive = FALSE), c(nr, nc), list(namr, namc))
  }
  step.results <- function(models, fit, object, usingCp = FALSE) {
    change <- sapply(models, `[[`, "change")
    rd <- sapply(models, `[[`, "deviance")
    dd <- c(NA, abs(diff(rd)))
    rdf <- sapply(models, `[[`, "df.resid")
    ddf <- c(NA, diff(rdf))
    AIC <- sapply(models, `[[`, "AIC")
    heading <- c("Stepwise Model Path \nAnalysis of Deviance Table", "\nInitial Model:", deparse(formula(object)), "\nFinal Model:", deparse(formula(fit)), "\n")
    aod <- data.frame(Step = I(change), Df = ddf, Deviance = dd, `Resid. Df` = rdf, `Resid. Dev` = rd, AIC = AIC, check.names = FALSE)
    if (usingCp) {
      cn <- colnames(aod)
      cn[cn == "AIC"] <- "Cp"
      colnames(aod) <- cn
    }
    attr(aod, "heading") <- heading
    fit$anova <- aod
    fit
  }
  Terms <- terms(object)
  object$call$formula <- object$formula <- Terms
  md <- missing(direction)
  direction <- match.arg(direction)
  backward <- direction == "both" | direction == "backward"
  forward <- direction == "both" | direction == "forward"
  if (missing(scope)) {
    fdrop <- numeric()
    fadd <- attr(Terms, "factors")
    if (md) 
      forward <- FALSE
  }
  else {
    if (is.list(scope)) {
      fdrop <- if (!is.null(fdrop <- scope$lower)) 
        attr(terms(update.formula(object, fdrop)), "factors")
      else numeric()
      fadd <- if (!is.null(fadd <- scope$upper)) 
        attr(terms(update.formula(object, fadd)), "factors")
    }
    else {
      fadd <- if (!is.null(fadd <- scope)) 
        attr(terms(update.formula(object, scope)), "factors")
      fdrop <- numeric()
    }
  }
  models <- vector("list", steps)
  if (!is.null(keep)) 
    keep.list <- vector("list", steps)
  n <- nobs(object, use.fallback = TRUE)
  fit <- object
  bAIC <- extractAIC(fit, scale, k = k, ...)
  edf <- bAIC[1]
  bAIC <- bAIC[2]
  if (is.na(bAIC)) 
    stop("AIC is not defined for this model, so 'step' cannot proceed")
  if (bAIC == -Inf) 
    stop("AIC is -infinity for this model, so 'step' cannot proceed")
  nm <- 1
  if (trace) {
    cat("Start:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), "\n\n", sep = "")
    flush.console()
  }
  models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - edf, change = "", AIC = bAIC)
  if (!is.null(keep)) 
    keep.list[[nm]] <- keep(fit, bAIC)
  usingCp <- FALSE
  while (steps > 0) {
    steps <- steps - 1
    AIC <- bAIC
    ffac <- attr(Terms, "factors")
    scope <- factor.scope(ffac, list(add = fadd, drop = fdrop))
    aod <- NULL
    change <- NULL
    if (backward && length(scope$drop)) {
      aod <- drop1(fit, scope$drop, scale = scale, trace = trace, k = k, ...)
      rn <- row.names(aod)
      row.names(aod) <- c(rn[1], paste("-", rn[-1]))
      if (any(aod$Df == 0, na.rm = TRUE)) {
        zdf <- aod$Df == 0 & !is.na(aod$Df)
        change <- rev(rownames(aod)[zdf])[1]
      }
    }
    if (is.null(change)) {
      if (forward && length(scope$add)) {
        aodf <- add1(fit, scope$add, scale = scale, trace = trace, k = k, ...)
        rn <- row.names(aodf)
        row.names(aodf) <- c(rn[1], paste("+", rn[-1]))
        aod <- if (is.null(aod)) 
          aodf
        else rbind(aod, aodf[-1, , drop = FALSE])
      }
      attr(aod, "heading") <- NULL
      nzdf <- if (!is.null(aod$Df)) 
        aod$Df != 0 | is.na(aod$Df)
      aod <- aod[nzdf, ]
      if (is.null(aod) || ncol(aod) == 0) 
        break
      nc <- match(c("Cp", "AIC"), names(aod))
      nc <- nc[!is.na(nc)][1]
      o <- order(aod[, nc])
      if (trace) 
        print(aod[o, ])
      if (o[1] == 1) 
        break
      change <- rownames(aod)[o[1]]
    }
    usingCp <- match("Cp", names(aod), 0) > 0
    fit <- update(fit, paste("~ .", change), evaluate = FALSE)
    fit <- eval.parent(fit)
    nnew <- nobs(fit, use.fallback = TRUE)
    if (all(is.finite(c(n, nnew))) && nnew != n) 
      stop("number of rows in use has changed: remove missing values?")
    Terms <- terms(fit)
    bAIC <- extractAIC(fit, scale, k = k, ...)
    edf <- bAIC[1]
    bAIC <- bAIC[2]
    if (trace) {
      cat("\nStep:  AIC=", format(round(bAIC, 2)), "\n", cut.string(deparse(formula(fit))), "\n\n", sep = "")
      flush.console()
    }
    if (bAIC >= AIC + 1e-07) 
      break
    nm <- nm + 1
    models[[nm]] <- list(deviance = mydeviance(fit), df.resid = n - edf, change = change, AIC = bAIC)
    if (!is.null(keep)) 
      keep.list[[nm]] <- keep(fit, bAIC)
  }
  if (!is.null(keep)) 
    fit$keep <- re.arrange(keep.list[seq(nm)])
  step.results(models = models[seq(nm)], fit, object, usingCp)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
stepfun
list(`package:stats` = function (x, y, f = as.numeric(right), ties = "ordered", right = FALSE) 
{
  if (is.unsorted(x)) 
    stop("stepfun: 'x' must be ordered increasingly")
  n <- length(x)
  if (n < 1) 
    stop("'x' must have length >= 1")
  n1 <- n + 1
  if (length(y) != n1) 
    stop("'y' must be one longer than 'x'")
  rval <- approxfun(x, y[-if (right) 
    n1
    else 1], method = "constant", yleft = y[1], yright = y[n1], f = f, ties = ties)
  class(rval) <- c("stepfun", class(rval))
  attr(rval, "call") <- sys.call()
  rval
}, function (x, y, f = as.numeric(right), ties = "ordered", right = FALSE) 
{
  if (is.unsorted(x)) 
    stop("stepfun: 'x' must be ordered increasingly")
  n <- length(x)
  if (n < 1) 
    stop("'x' must have length >= 1")
  n1 <- n + 1
  if (length(y) != n1) 
    stop("'y' must be one longer than 'x'")
  rval <- approxfun(x, y[-if (right) 
    n1
    else 1], method = "constant", yleft = y[1], yright = y[n1], f = f, ties = ties)
  class(rval) <- c("stepfun", class(rval))
  attr(rval, "call") <- sys.call()
  rval
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
stl
list(`package:stats` = function (x, s.window, s.degree = 0, t.window = NULL, t.degree = 1, l.window = nextodd(period), l.degree = t.degree, s.jump = ceiling(s.window/10), t.jump = ceiling(t.window/10), l.jump = ceiling(l.window/10), robust = FALSE, inner = if (robust) 1 else 2, outer = if (robust) 15 else 0, na.action = na.fail) 
{
  nextodd <- function(x) {
    x <- round(x)
    if (x%%2 == 0) 
      x <- x + 1
    as.integer(x)
  }
  deg.check <- function(deg) {
    degname <- deparse1(substitute(deg))
    deg <- as.integer(deg)
    if (deg < 0 || deg > 1) 
      stop(gettextf("%s must be 0 or 1", degname), domain = NA)
    deg
  }
  x <- na.action(as.ts(x))
  if (is.matrix(x)) 
    stop("only univariate series are allowed")
  n <- as.integer(length(x))
  if (is.na(n)) 
    stop("invalid length(x)")
  period <- frequency(x)
  if (period < 2 || n <= 2 * period) 
    stop("series is not periodic or has less than two periods")
  periodic <- FALSE
  if (is.character(s.window)) {
    if (is.na(pmatch(s.window, "periodic"))) 
      stop("unknown string value for s.window")
    else {
      periodic <- TRUE
      s.window <- 10 * n + 1
      s.degree <- 0
    }
  }
  s.degree <- deg.check(s.degree)
  t.degree <- deg.check(t.degree)
  l.degree <- deg.check(l.degree)
  if (is.null(t.window)) 
    t.window <- nextodd(ceiling(1.5 * period/(1 - 1.5/s.window)))
  storage.mode(x) <- "double"
  z <- .Fortran(C_stl, x, n, as.integer(period), as.integer(s.window), as.integer(t.window), as.integer(l.window), s.degree, t.degree, l.degree, nsjump = as.integer(s.jump), ntjump = as.integer(t.jump), nljump = as.integer(l.jump), ni = as.integer(inner), no = as.integer(outer), weights = double(n), seasonal = double(n), trend = double(n), double((n + 2 * period) * 5))
  if (periodic) {
    which.cycle <- cycle(x)
    z$seasonal <- tapply(z$seasonal, which.cycle, mean)[which.cycle]
  }
  remainder <- as.vector(x) - z$seasonal - z$trend
  y <- cbind(seasonal = z$seasonal, trend = z$trend, remainder = remainder)
  res <- list(time.series = ts(y, start = start(x), frequency = period), weights = z$weights, call = match.call(), win = c(s = s.window, t = t.window, l = l.window), deg = c(s = s.degree, t = t.degree, l = l.degree), jump = c(s = s.jump, t = t.jump, l = l.jump), inner = z$ni, outer = z$no)
  class(res) <- "stl"
  res
}, function (x, s.window, s.degree = 0, t.window = NULL, t.degree = 1, l.window = nextodd(period), l.degree = t.degree, s.jump = ceiling(s.window/10), t.jump = ceiling(t.window/10), l.jump = ceiling(l.window/10), robust = FALSE, inner = if (robust) 1 else 2, outer = if (robust) 15 else 0, na.action = na.fail) 
{
  nextodd <- function(x) {
    x <- round(x)
    if (x%%2 == 0) 
      x <- x + 1
    as.integer(x)
  }
  deg.check <- function(deg) {
    degname <- deparse1(substitute(deg))
    deg <- as.integer(deg)
    if (deg < 0 || deg > 1) 
      stop(gettextf("%s must be 0 or 1", degname), domain = NA)
    deg
  }
  x <- na.action(as.ts(x))
  if (is.matrix(x)) 
    stop("only univariate series are allowed")
  n <- as.integer(length(x))
  if (is.na(n)) 
    stop("invalid length(x)")
  period <- frequency(x)
  if (period < 2 || n <= 2 * period) 
    stop("series is not periodic or has less than two periods")
  periodic <- FALSE
  if (is.character(s.window)) {
    if (is.na(pmatch(s.window, "periodic"))) 
      stop("unknown string value for s.window")
    else {
      periodic <- TRUE
      s.window <- 10 * n + 1
      s.degree <- 0
    }
  }
  s.degree <- deg.check(s.degree)
  t.degree <- deg.check(t.degree)
  l.degree <- deg.check(l.degree)
  if (is.null(t.window)) 
    t.window <- nextodd(ceiling(1.5 * period/(1 - 1.5/s.window)))
  storage.mode(x) <- "double"
  z <- .Fortran(C_stl, x, n, as.integer(period), as.integer(s.window), as.integer(t.window), as.integer(l.window), s.degree, t.degree, l.degree, nsjump = as.integer(s.jump), ntjump = as.integer(t.jump), nljump = as.integer(l.jump), ni = as.integer(inner), no = as.integer(outer), weights = double(n), seasonal = double(n), trend = double(n), double((n + 2 * period) * 5))
  if (periodic) {
    which.cycle <- cycle(x)
    z$seasonal <- tapply(z$seasonal, which.cycle, mean)[which.cycle]
  }
  remainder <- as.vector(x) - z$seasonal - z$trend
  y <- cbind(seasonal = z$seasonal, trend = z$trend, remainder = remainder)
  res <- list(time.series = ts(y, start = start(x), frequency = period), weights = z$weights, call = match.call(), win = c(s = s.window, t = t.window, l = l.window), deg = c(s = s.degree, t = t.degree, l = l.degree), jump = c(s = s.jump, t = t.jump, l = l.jump), inner = z$ni, outer = z$no)
  class(res) <- "stl"
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
StructTS
list(`package:stats` = function (x, type = c("level", "trend", "BSM"), init = NULL, fixed = NULL, optim.control = NULL) 
{
  makeLevel <- function(x) {
    T <- matrix(1, 1, 1)
    Z <- 1
    xm <- if (is.na(x[1])) 
      mean(x, na.rm = TRUE)
    else x[1]
    if (is.na(xm)) 
      stop("the series is entirely NA")
    a <- xm
    P <- Pn <- matrix(0, 1, 1)
    h <- 1
    V <- diag(1)
    return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, Pn = Pn))
  }
  makeTrend <- function(x) {
    T <- matrix(c(1, 0, 1, 1), 2, 2)
    Z <- c(1, 0)
    xm <- if (is.na(x[1])) 
      mean(x, na.rm = TRUE)
    else x[1]
    if (is.na(xm)) 
      stop("the series is entirely NA")
    a <- c(xm, 0)
    P <- Pn <- matrix(0, 2, 2)
    h <- 1
    V <- diag(2)
    return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, Pn = Pn))
  }
  makeBSM <- function(x, nf) {
    if (nf <= 1) 
      stop("frequency must be a positive integer >= 2 for BSM")
    T <- matrix(0, nf + 1, nf + 1)
    T[1:2, 1:2] <- c(1, 0, 1, 1)
    T[3, ] <- c(0, 0, rep(-1, nf - 1))
    if (nf >= 3) {
      ind <- 3:nf
      T[cbind(ind + 1, ind)] <- 1
    }
    Z <- c(1, 0, 1, rep(0, nf - 2))
    xm <- if (is.na(x[1])) 
      mean(x, na.rm = TRUE)
    else x[1]
    if (is.na(xm)) 
      stop("the series is entirely NA")
    a <- c(xm, rep(0, nf))
    P <- Pn <- matrix(0, nf + 1, nf + 1)
    h <- 1
    V <- diag(c(1, 1, 1, rep(0, nf - 2)))
    return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, Pn = Pn))
  }
  getLike <- function(par) {
    p <- cf
    p[mask] <- par
    if (all(p == 0)) 
      return(1000)
    Z$V[cbind(1:np, 1:np)] <- p[-(np + 1)] * vx
    Z$h <- p[np + 1] * vx
    z <- .Call(C_KalmanLike, y, Z, -1, FALSE, FALSE)
    0.5 * sum(z)
  }
  series <- deparse1(substitute(x))
  if (NCOL(x) > 1) 
    stop("only implemented for univariate time series")
  x <- as.ts(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  storage.mode(x) <- "double"
  if (is.na(x[1])) 
    stop("the first value of the time series must not be missing")
  type <- if (missing(type)) 
    if (frequency(x) > 1) 
      "BSM"
  else "trend"
  else match.arg(type)
  dim(x) <- NULL
  xtsp <- tsp(x)
  nf <- frequency(x)
  Z <- switch(type, level = makeLevel(x), trend = makeTrend(x), BSM = makeBSM(x, nf))
  vx <- var(x, na.rm = TRUE)/100
  Z$P[] <- 1e+06 * vx
  np <- switch(type, level = 1, trend = 2, BSM = 3)
  if (is.null(fixed)) 
    fixed <- rep(NA, np + 1)
  mask <- is.na(fixed)
  if (!any(mask)) 
    stop("all parameters were fixed")
  cf <- fixed/vx
  init <- if (is.null(init)) 
    rep(1, np + 1)
  else init/vx
  y <- x
  res <- optim(init[mask], getLike, method = "L-BFGS-B", lower = rep(0, np + 1), upper = rep(Inf, np + 1), control = optim.control)
  if (res$convergence > 0) 
    warning(gettextf("possible convergence problem: 'optim' gave code = %d and message %s", res$convergence, sQuote(res$message)), domain = NA)
  coef <- cf
  coef[mask] <- res$par
  Z$V[cbind(1:np, 1:np)] <- coef[1:np] * vx
  Z$h <- coef[np + 1] * vx
  z <- KalmanRun(y, Z, -1, update = TRUE)
  resid <- ts(z$resid)
  tsp(resid) <- xtsp
  cn <- switch(type, level = c("level"), trend = c("level", "slope"), BSM = c("level", "slope", "sea"))
  states <- z$states
  if (type == "BSM") 
    states <- states[, 1:3]
  dimnames(states) <- list(time(x), cn)
  states <- ts(states, start = xtsp[1], frequency = nf)
  coef <- pmax(coef * vx, 0)
  names(coef) <- switch(type, level = c("level", "epsilon"), trend = c("level", "slope", "epsilon"), BSM = c("level", "slope", "seas", "epsilon"))
  loglik <- -length(y) * res$value - 0.5 * sum(!is.na(y)) * log(2 * pi)
  loglik0 <- -length(y) * res$value + length(y) * log(2 * pi)
  res <- list(coef = coef, loglik = loglik, loglik0 = loglik0, data = y, residuals = resid, fitted = states, call = match.call(), series = series, code = res$convergence, model = attr(z, "mod"), model0 = Z, xtsp = xtsp)
  class(res) <- "StructTS"
  res
}, function (x, type = c("level", "trend", "BSM"), init = NULL, fixed = NULL, optim.control = NULL) 
{
  makeLevel <- function(x) {
    T <- matrix(1, 1, 1)
    Z <- 1
    xm <- if (is.na(x[1])) 
      mean(x, na.rm = TRUE)
    else x[1]
    if (is.na(xm)) 
      stop("the series is entirely NA")
    a <- xm
    P <- Pn <- matrix(0, 1, 1)
    h <- 1
    V <- diag(1)
    return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, Pn = Pn))
  }
  makeTrend <- function(x) {
    T <- matrix(c(1, 0, 1, 1), 2, 2)
    Z <- c(1, 0)
    xm <- if (is.na(x[1])) 
      mean(x, na.rm = TRUE)
    else x[1]
    if (is.na(xm)) 
      stop("the series is entirely NA")
    a <- c(xm, 0)
    P <- Pn <- matrix(0, 2, 2)
    h <- 1
    V <- diag(2)
    return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, Pn = Pn))
  }
  makeBSM <- function(x, nf) {
    if (nf <= 1) 
      stop("frequency must be a positive integer >= 2 for BSM")
    T <- matrix(0, nf + 1, nf + 1)
    T[1:2, 1:2] <- c(1, 0, 1, 1)
    T[3, ] <- c(0, 0, rep(-1, nf - 1))
    if (nf >= 3) {
      ind <- 3:nf
      T[cbind(ind + 1, ind)] <- 1
    }
    Z <- c(1, 0, 1, rep(0, nf - 2))
    xm <- if (is.na(x[1])) 
      mean(x, na.rm = TRUE)
    else x[1]
    if (is.na(xm)) 
      stop("the series is entirely NA")
    a <- c(xm, rep(0, nf))
    P <- Pn <- matrix(0, nf + 1, nf + 1)
    h <- 1
    V <- diag(c(1, 1, 1, rep(0, nf - 2)))
    return(list(Z = Z, a = a, P = P, T = T, V = V, h = h, Pn = Pn))
  }
  getLike <- function(par) {
    p <- cf
    p[mask] <- par
    if (all(p == 0)) 
      return(1000)
    Z$V[cbind(1:np, 1:np)] <- p[-(np + 1)] * vx
    Z$h <- p[np + 1] * vx
    z <- .Call(C_KalmanLike, y, Z, -1, FALSE, FALSE)
    0.5 * sum(z)
  }
  series <- deparse1(substitute(x))
  if (NCOL(x) > 1) 
    stop("only implemented for univariate time series")
  x <- as.ts(x)
  if (!is.numeric(x)) 
    stop("'x' must be numeric")
  storage.mode(x) <- "double"
  if (is.na(x[1])) 
    stop("the first value of the time series must not be missing")
  type <- if (missing(type)) 
    if (frequency(x) > 1) 
      "BSM"
  else "trend"
  else match.arg(type)
  dim(x) <- NULL
  xtsp <- tsp(x)
  nf <- frequency(x)
  Z <- switch(type, level = makeLevel(x), trend = makeTrend(x), BSM = makeBSM(x, nf))
  vx <- var(x, na.rm = TRUE)/100
  Z$P[] <- 1e+06 * vx
  np <- switch(type, level = 1, trend = 2, BSM = 3)
  if (is.null(fixed)) 
    fixed <- rep(NA, np + 1)
  mask <- is.na(fixed)
  if (!any(mask)) 
    stop("all parameters were fixed")
  cf <- fixed/vx
  init <- if (is.null(init)) 
    rep(1, np + 1)
  else init/vx
  y <- x
  res <- optim(init[mask], getLike, method = "L-BFGS-B", lower = rep(0, np + 1), upper = rep(Inf, np + 1), control = optim.control)
  if (res$convergence > 0) 
    warning(gettextf("possible convergence problem: 'optim' gave code = %d and message %s", res$convergence, sQuote(res$message)), domain = NA)
  coef <- cf
  coef[mask] <- res$par
  Z$V[cbind(1:np, 1:np)] <- coef[1:np] * vx
  Z$h <- coef[np + 1] * vx
  z <- KalmanRun(y, Z, -1, update = TRUE)
  resid <- ts(z$resid)
  tsp(resid) <- xtsp
  cn <- switch(type, level = c("level"), trend = c("level", "slope"), BSM = c("level", "slope", "sea"))
  states <- z$states
  if (type == "BSM") 
    states <- states[, 1:3]
  dimnames(states) <- list(time(x), cn)
  states <- ts(states, start = xtsp[1], frequency = nf)
  coef <- pmax(coef * vx, 0)
  names(coef) <- switch(type, level = c("level", "epsilon"), trend = c("level", "slope", "epsilon"), BSM = c("level", "slope", "seas", "epsilon"))
  loglik <- -length(y) * res$value - 0.5 * sum(!is.na(y)) * log(2 * pi)
  loglik0 <- -length(y) * res$value + length(y) * log(2 * pi)
  res <- list(coef = coef, loglik = loglik, loglik0 = loglik0, data = y, residuals = resid, fitted = states, call = match.call(), series = series, code = res$convergence, model = attr(z, "mod"), model0 = Z, xtsp = xtsp)
  class(res) <- "StructTS"
  res
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
summary.aov
list(`package:stats` = function (object, intercept = FALSE, split, expand.split = TRUE, keep.zero.df = TRUE, ...) 
{
  splitInteractions <- function(split, factors, names, asgn, df.names) {
    ns <- names(split)
    for (i in unique(asgn)) {
      if (i == 0 || names[i + 1] %in% ns) 
        next
      f <- rownames(factors)[factors[, i] > 0]
      sp <- f %in% ns
      if (any(sp)) {
        if (sum(sp) > 1) {
          old <- split[f[sp]]
          nn <- setNames(nm = f[sp])
          marg <- lapply(nn, function(x) df.names[asgn == (match(x, names) - 1)])
          term.coefs <- strsplit(df.names[asgn == i], ":", fixed = TRUE)
          ttc <- sapply(term.coefs, function(x) x[sp])
          rownames(ttc) <- nn
          splitnames <- setNames(nm = apply(expand.grid(lapply(old, names)), 1, function(x) paste(x, collapse = ".")))
          tmp <- sapply(nn, function(i) names(old[[i]])[match(ttc[i, ], marg[[i]])])
          tmp <- apply(tmp, 1, function(x) paste(x, collapse = "."))
          new <- lapply(splitnames, function(x) match(x, tmp))
          split[[names[i + 1]]] <- new[sapply(new, function(x) length(x) > 0)]
        }
        else {
          old <- split[[f[sp]]]
          marg.coefs <- df.names[asgn == (match(f[sp], names) - 1)]
          term.coefs <- strsplit(df.names[asgn == i], ":", fixed = TRUE)
          ttc <- sapply(term.coefs, function(x) x[sp])
          new <- lapply(old, function(x) seq_along(ttc)[ttc %in% marg.coefs[x]])
          split[[names[i + 1]]] <- new
        }
      }
    }
    split
  }
  asgn <- object$assign[object$qr$pivot[1:object$rank]]
  uasgn <- unique(asgn)
  nterms <- length(uasgn)
  effects <- object$effects
  if (!is.null(effects)) 
    effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
  rdf <- object$df.residual
  nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
  coef <- as.matrix(object$coefficients)
  resid <- as.matrix(object$residuals)
  wt <- object$weights
  if (!is.null(wt)) 
    resid <- resid * sqrt(wt)
  nresp <- NCOL(resid)
  ans <- vector("list", nresp)
  if (nresp > 1) {
    names(ans) <- character(nresp)
    for (y in 1:nresp) {
      cn <- colnames(resid)[y]
      if (is.null(cn) || cn == "") 
        cn <- y
      names(ans)[y] <- paste(" Response", cn)
    }
  }
  if (!is.null(effects) && !missing(split)) {
    ns <- names(split)
    if (!is.null(Terms <- object$terms)) {
      if (!is.list(split)) 
        stop("the 'split' argument must be a list")
      if (!all(ns %in% nmeffect)) {
        na <- sum(!ns %in% nmeffect)
        stop(sprintf(ngettext(na, "unknown name %s in the 'split' list", "unknown names %s in the 'split' list"), paste(sQuote(ns[na]), collapse = ", ")), domain = NA)
      }
    }
    if (expand.split) {
      df.names <- names(coef(object))
      split <- splitInteractions(split, attr(Terms, "factors"), nmeffect, asgn, df.names)
      ns <- names(split)
    }
  }
  for (y in 1:nresp) {
    if (is.null(effects)) {
      nterms <- 0
      df <- ss <- ms <- numeric()
      nmrows <- character()
    }
    else {
      df <- ss <- numeric()
      nmrows <- character()
      for (i in seq(nterms)) {
        ai <- (asgn == uasgn[i])
        df <- c(df, sum(ai))
        ss <- c(ss, sum(effects[ai, y]^2))
        nmi <- nmeffect[1 + uasgn[i]]
        nmrows <- c(nmrows, nmi)
        if (!missing(split) && !is.na(int <- match(nmi, ns))) {
          df <- c(df, lengths(split[[int]]))
          if (is.null(nms <- names(split[[int]]))) 
            nms <- paste0("C", seq_along(split[[int]]))
          ss <- c(ss, unlist(lapply(split[[int]], function(i, e) sum(e[i]^2), effects[ai, y])))
          nmrows <- c(nmrows, paste0("  ", nmi, ": ", nms))
        }
      }
    }
    if (rdf > 0) {
      df <- c(df, rdf)
      ss <- c(ss, sum(resid[, y]^2))
      nmrows <- c(nmrows, "Residuals")
    }
    nt <- length(df)
    ms <- ifelse(df > 0, ss/df, NA)
    x <- list(Df = df, `Sum Sq` = ss, `Mean Sq` = ms)
    if (rdf > 0) {
      TT <- ms/ms[nt]
      TP <- pf(TT, df, rdf, lower.tail = FALSE)
      TT[nt] <- TP[nt] <- NA
      x$"F value" <- TT
      x$"Pr(>F)" <- TP
    }
    class(x) <- c("anova", "data.frame")
    attr(x, "row.names") <- format(nmrows)
    if (!keep.zero.df) 
      x <- x[df > 0, ]
    pm <- pmatch("(Intercept)", row.names(x), 0)
    if (!intercept && pm > 0) 
      x <- x[-pm, ]
    ans[[y]] <- x
  }
  class(ans) <- c("summary.aov", "listof")
  attr(ans, "na.action") <- object$na.action
  ans
}, function (object, intercept = FALSE, split, expand.split = TRUE, keep.zero.df = TRUE, ...) 
{
  splitInteractions <- function(split, factors, names, asgn, df.names) {
    ns <- names(split)
    for (i in unique(asgn)) {
      if (i == 0 || names[i + 1] %in% ns) 
        next
      f <- rownames(factors)[factors[, i] > 0]
      sp <- f %in% ns
      if (any(sp)) {
        if (sum(sp) > 1) {
          old <- split[f[sp]]
          nn <- setNames(nm = f[sp])
          marg <- lapply(nn, function(x) df.names[asgn == (match(x, names) - 1)])
          term.coefs <- strsplit(df.names[asgn == i], ":", fixed = TRUE)
          ttc <- sapply(term.coefs, function(x) x[sp])
          rownames(ttc) <- nn
          splitnames <- setNames(nm = apply(expand.grid(lapply(old, names)), 1, function(x) paste(x, collapse = ".")))
          tmp <- sapply(nn, function(i) names(old[[i]])[match(ttc[i, ], marg[[i]])])
          tmp <- apply(tmp, 1, function(x) paste(x, collapse = "."))
          new <- lapply(splitnames, function(x) match(x, tmp))
          split[[names[i + 1]]] <- new[sapply(new, function(x) length(x) > 0)]
        }
        else {
          old <- split[[f[sp]]]
          marg.coefs <- df.names[asgn == (match(f[sp], names) - 1)]
          term.coefs <- strsplit(df.names[asgn == i], ":", fixed = TRUE)
          ttc <- sapply(term.coefs, function(x) x[sp])
          new <- lapply(old, function(x) seq_along(ttc)[ttc %in% marg.coefs[x]])
          split[[names[i + 1]]] <- new
        }
      }
    }
    split
  }
  asgn <- object$assign[object$qr$pivot[1:object$rank]]
  uasgn <- unique(asgn)
  nterms <- length(uasgn)
  effects <- object$effects
  if (!is.null(effects)) 
    effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
  rdf <- object$df.residual
  nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
  coef <- as.matrix(object$coefficients)
  resid <- as.matrix(object$residuals)
  wt <- object$weights
  if (!is.null(wt)) 
    resid <- resid * sqrt(wt)
  nresp <- NCOL(resid)
  ans <- vector("list", nresp)
  if (nresp > 1) {
    names(ans) <- character(nresp)
    for (y in 1:nresp) {
      cn <- colnames(resid)[y]
      if (is.null(cn) || cn == "") 
        cn <- y
      names(ans)[y] <- paste(" Response", cn)
    }
  }
  if (!is.null(effects) && !missing(split)) {
    ns <- names(split)
    if (!is.null(Terms <- object$terms)) {
      if (!is.list(split)) 
        stop("the 'split' argument must be a list")
      if (!all(ns %in% nmeffect)) {
        na <- sum(!ns %in% nmeffect)
        stop(sprintf(ngettext(na, "unknown name %s in the 'split' list", "unknown names %s in the 'split' list"), paste(sQuote(ns[na]), collapse = ", ")), domain = NA)
      }
    }
    if (expand.split) {
      df.names <- names(coef(object))
      split <- splitInteractions(split, attr(Terms, "factors"), nmeffect, asgn, df.names)
      ns <- names(split)
    }
  }
  for (y in 1:nresp) {
    if (is.null(effects)) {
      nterms <- 0
      df <- ss <- ms <- numeric()
      nmrows <- character()
    }
    else {
      df <- ss <- numeric()
      nmrows <- character()
      for (i in seq(nterms)) {
        ai <- (asgn == uasgn[i])
        df <- c(df, sum(ai))
        ss <- c(ss, sum(effects[ai, y]^2))
        nmi <- nmeffect[1 + uasgn[i]]
        nmrows <- c(nmrows, nmi)
        if (!missing(split) && !is.na(int <- match(nmi, ns))) {
          df <- c(df, lengths(split[[int]]))
          if (is.null(nms <- names(split[[int]]))) 
            nms <- paste0("C", seq_along(split[[int]]))
          ss <- c(ss, unlist(lapply(split[[int]], function(i, e) sum(e[i]^2), effects[ai, y])))
          nmrows <- c(nmrows, paste0("  ", nmi, ": ", nms))
        }
      }
    }
    if (rdf > 0) {
      df <- c(df, rdf)
      ss <- c(ss, sum(resid[, y]^2))
      nmrows <- c(nmrows, "Residuals")
    }
    nt <- length(df)
    ms <- ifelse(df > 0, ss/df, NA)
    x <- list(Df = df, `Sum Sq` = ss, `Mean Sq` = ms)
    if (rdf > 0) {
      TT <- ms/ms[nt]
      TP <- pf(TT, df, rdf, lower.tail = FALSE)
      TT[nt] <- TP[nt] <- NA
      x$"F value" <- TT
      x$"Pr(>F)" <- TP
    }
    class(x) <- c("anova", "data.frame")
    attr(x, "row.names") <- format(nmrows)
    if (!keep.zero.df) 
      x <- x[df > 0, ]
    pm <- pmatch("(Intercept)", row.names(x), 0)
    if (!intercept && pm > 0) 
      x <- x[-pm, ]
    ans[[y]] <- x
  }
  class(ans) <- c("summary.aov", "listof")
  attr(ans, "na.action") <- object$na.action
  ans
}, function (object, intercept = FALSE, split, expand.split = TRUE, keep.zero.df = TRUE, ...) 
{
  splitInteractions <- function(split, factors, names, asgn, df.names) {
    ns <- names(split)
    for (i in unique(asgn)) {
      if (i == 0 || names[i + 1] %in% ns) 
        next
      f <- rownames(factors)[factors[, i] > 0]
      sp <- f %in% ns
      if (any(sp)) {
        if (sum(sp) > 1) {
          old <- split[f[sp]]
          nn <- setNames(nm = f[sp])
          marg <- lapply(nn, function(x) df.names[asgn == (match(x, names) - 1)])
          term.coefs <- strsplit(df.names[asgn == i], ":", fixed = TRUE)
          ttc <- sapply(term.coefs, function(x) x[sp])
          rownames(ttc) <- nn
          splitnames <- setNames(nm = apply(expand.grid(lapply(old, names)), 1, function(x) paste(x, collapse = ".")))
          tmp <- sapply(nn, function(i) names(old[[i]])[match(ttc[i, ], marg[[i]])])
          tmp <- apply(tmp, 1, function(x) paste(x, collapse = "."))
          new <- lapply(splitnames, function(x) match(x, tmp))
          split[[names[i + 1]]] <- new[sapply(new, function(x) length(x) > 0)]
        }
        else {
          old <- split[[f[sp]]]
          marg.coefs <- df.names[asgn == (match(f[sp], names) - 1)]
          term.coefs <- strsplit(df.names[asgn == i], ":", fixed = TRUE)
          ttc <- sapply(term.coefs, function(x) x[sp])
          new <- lapply(old, function(x) seq_along(ttc)[ttc %in% marg.coefs[x]])
          split[[names[i + 1]]] <- new
        }
      }
    }
    split
  }
  asgn <- object$assign[object$qr$pivot[1:object$rank]]
  uasgn <- unique(asgn)
  nterms <- length(uasgn)
  effects <- object$effects
  if (!is.null(effects)) 
    effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
  rdf <- object$df.residual
  nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
  coef <- as.matrix(object$coefficients)
  resid <- as.matrix(object$residuals)
  wt <- object$weights
  if (!is.null(wt)) 
    resid <- resid * sqrt(wt)
  nresp <- NCOL(resid)
  ans <- vector("list", nresp)
  if (nresp > 1) {
    names(ans) <- character(nresp)
    for (y in 1:nresp) {
      cn <- colnames(resid)[y]
      if (is.null(cn) || cn == "") 
        cn <- y
      names(ans)[y] <- paste(" Response", cn)
    }
  }
  if (!is.null(effects) && !missing(split)) {
    ns <- names(split)
    if (!is.null(Terms <- object$terms)) {
      if (!is.list(split)) 
        stop("the 'split' argument must be a list")
      if (!all(ns %in% nmeffect)) {
        na <- sum(!ns %in% nmeffect)
        stop(sprintf(ngettext(na, "unknown name %s in the 'split' list", "unknown names %s in the 'split' list"), paste(sQuote(ns[na]), collapse = ", ")), domain = NA)
      }
    }
    if (expand.split) {
      df.names <- names(coef(object))
      split <- splitInteractions(split, attr(Terms, "factors"), nmeffect, asgn, df.names)
      ns <- names(split)
    }
  }
  for (y in 1:nresp) {
    if (is.null(effects)) {
      nterms <- 0
      df <- ss <- ms <- numeric()
      nmrows <- character()
    }
    else {
      df <- ss <- numeric()
      nmrows <- character()
      for (i in seq(nterms)) {
        ai <- (asgn == uasgn[i])
        df <- c(df, sum(ai))
        ss <- c(ss, sum(effects[ai, y]^2))
        nmi <- nmeffect[1 + uasgn[i]]
        nmrows <- c(nmrows, nmi)
        if (!missing(split) && !is.na(int <- match(nmi, ns))) {
          df <- c(df, lengths(split[[int]]))
          if (is.null(nms <- names(split[[int]]))) 
            nms <- paste0("C", seq_along(split[[int]]))
          ss <- c(ss, unlist(lapply(split[[int]], function(i, e) sum(e[i]^2), effects[ai, y])))
          nmrows <- c(nmrows, paste0("  ", nmi, ": ", nms))
        }
      }
    }
    if (rdf > 0) {
      df <- c(df, rdf)
      ss <- c(ss, sum(resid[, y]^2))
      nmrows <- c(nmrows, "Residuals")
    }
    nt <- length(df)
    ms <- ifelse(df > 0, ss/df, NA)
    x <- list(Df = df, `Sum Sq` = ss, `Mean Sq` = ms)
    if (rdf > 0) {
      TT <- ms/ms[nt]
      TP <- pf(TT, df, rdf, lower.tail = FALSE)
      TT[nt] <- TP[nt] <- NA
      x$"F value" <- TT
      x$"Pr(>F)" <- TP
    }
    class(x) <- c("anova", "data.frame")
    attr(x, "row.names") <- format(nmrows)
    if (!keep.zero.df) 
      x <- x[df > 0, ]
    pm <- pmatch("(Intercept)", row.names(x), 0)
    if (!intercept && pm > 0) 
      x <- x[-pm, ]
    ans[[y]] <- x
  }
  class(ans) <- c("summary.aov", "listof")
  attr(ans, "na.action") <- object$na.action
  ans
})
c("package:stats", "registered S3 method for summary from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.glm
list(`package:stats` = function (object, dispersion = NULL, correlation = FALSE, symbolic.cor = FALSE, ...) 
{
  est.disp <- FALSE
  df.r <- object$df.residual
  if (is.null(dispersion)) 
    dispersion <- if (object$family$family %in% c("poisson", "binomial")) 
      1
  else if (df.r > 0) {
    est.disp <- TRUE
    if (any(object$weights == 0)) 
      warning("observations with zero weight not used for calculating dispersion")
    sum((object$weights * object$residuals^2)[object$weights > 0])/df.r
  }
  else {
    est.disp <- TRUE
    NaN
  }
  aliased <- is.na(coef(object))
  p <- object$rank
  if (p > 0) {
    p1 <- 1:p
    Qr <- qr.lm(object)
    coef.p <- object$coefficients[Qr$pivot[p1]]
    covmat.unscaled <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
    dimnames(covmat.unscaled) <- list(names(coef.p), names(coef.p))
    covmat <- dispersion * covmat.unscaled
    var.cf <- diag(covmat)
    s.err <- sqrt(var.cf)
    tvalue <- coef.p/s.err
    dn <- c("Estimate", "Std. Error")
    if (!est.disp) {
      pvalue <- 2 * pnorm(-abs(tvalue))
      coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "z value", "Pr(>|z|)"))
    }
    else if (df.r > 0) {
      pvalue <- 2 * pt(-abs(tvalue), df.r)
      coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "t value", "Pr(>|t|)"))
    }
    else {
      coef.table <- cbind(coef.p, NaN, NaN, NaN)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "t value", "Pr(>|t|)"))
    }
    df.f <- NCOL(Qr$qr)
  }
  else {
    coef.table <- matrix(, 0, 4)
    dimnames(coef.table) <- list(NULL, c("Estimate", "Std. Error", "t value", "Pr(>|t|)"))
    covmat.unscaled <- covmat <- matrix(, 0, 0)
    df.f <- length(aliased)
  }
  keep <- match(c("call", "terms", "family", "deviance", "aic", "contrasts", "df.residual", "null.deviance", "df.null", "iter", "na.action"), names(object), 0)
  ans <- c(object[keep], list(deviance.resid = residuals(object, type = "deviance"), coefficients = coef.table, aliased = aliased, dispersion = dispersion, df = c(object$rank, df.r, df.f), cov.unscaled = covmat.unscaled, cov.scaled = covmat))
  if (correlation && p > 0) {
    dd <- sqrt(diag(covmat.unscaled))
    ans$correlation <- covmat.unscaled/outer(dd, dd)
    ans$symbolic.cor <- symbolic.cor
  }
  class(ans) <- "summary.glm"
  return(ans)
}, function (object, dispersion = NULL, correlation = FALSE, symbolic.cor = FALSE, ...) 
{
  est.disp <- FALSE
  df.r <- object$df.residual
  if (is.null(dispersion)) 
    dispersion <- if (object$family$family %in% c("poisson", "binomial")) 
      1
  else if (df.r > 0) {
    est.disp <- TRUE
    if (any(object$weights == 0)) 
      warning("observations with zero weight not used for calculating dispersion")
    sum((object$weights * object$residuals^2)[object$weights > 0])/df.r
  }
  else {
    est.disp <- TRUE
    NaN
  }
  aliased <- is.na(coef(object))
  p <- object$rank
  if (p > 0) {
    p1 <- 1:p
    Qr <- qr.lm(object)
    coef.p <- object$coefficients[Qr$pivot[p1]]
    covmat.unscaled <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
    dimnames(covmat.unscaled) <- list(names(coef.p), names(coef.p))
    covmat <- dispersion * covmat.unscaled
    var.cf <- diag(covmat)
    s.err <- sqrt(var.cf)
    tvalue <- coef.p/s.err
    dn <- c("Estimate", "Std. Error")
    if (!est.disp) {
      pvalue <- 2 * pnorm(-abs(tvalue))
      coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "z value", "Pr(>|z|)"))
    }
    else if (df.r > 0) {
      pvalue <- 2 * pt(-abs(tvalue), df.r)
      coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "t value", "Pr(>|t|)"))
    }
    else {
      coef.table <- cbind(coef.p, NaN, NaN, NaN)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "t value", "Pr(>|t|)"))
    }
    df.f <- NCOL(Qr$qr)
  }
  else {
    coef.table <- matrix(, 0, 4)
    dimnames(coef.table) <- list(NULL, c("Estimate", "Std. Error", "t value", "Pr(>|t|)"))
    covmat.unscaled <- covmat <- matrix(, 0, 0)
    df.f <- length(aliased)
  }
  keep <- match(c("call", "terms", "family", "deviance", "aic", "contrasts", "df.residual", "null.deviance", "df.null", "iter", "na.action"), names(object), 0)
  ans <- c(object[keep], list(deviance.resid = residuals(object, type = "deviance"), coefficients = coef.table, aliased = aliased, dispersion = dispersion, df = c(object$rank, df.r, df.f), cov.unscaled = covmat.unscaled, cov.scaled = covmat))
  if (correlation && p > 0) {
    dd <- sqrt(diag(covmat.unscaled))
    ans$correlation <- covmat.unscaled/outer(dd, dd)
    ans$symbolic.cor <- symbolic.cor
  }
  class(ans) <- "summary.glm"
  return(ans)
}, function (object, dispersion = NULL, correlation = FALSE, symbolic.cor = FALSE, ...) 
{
  est.disp <- FALSE
  df.r <- object$df.residual
  if (is.null(dispersion)) 
    dispersion <- if (object$family$family %in% c("poisson", "binomial")) 
      1
  else if (df.r > 0) {
    est.disp <- TRUE
    if (any(object$weights == 0)) 
      warning("observations with zero weight not used for calculating dispersion")
    sum((object$weights * object$residuals^2)[object$weights > 0])/df.r
  }
  else {
    est.disp <- TRUE
    NaN
  }
  aliased <- is.na(coef(object))
  p <- object$rank
  if (p > 0) {
    p1 <- 1:p
    Qr <- qr.lm(object)
    coef.p <- object$coefficients[Qr$pivot[p1]]
    covmat.unscaled <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
    dimnames(covmat.unscaled) <- list(names(coef.p), names(coef.p))
    covmat <- dispersion * covmat.unscaled
    var.cf <- diag(covmat)
    s.err <- sqrt(var.cf)
    tvalue <- coef.p/s.err
    dn <- c("Estimate", "Std. Error")
    if (!est.disp) {
      pvalue <- 2 * pnorm(-abs(tvalue))
      coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "z value", "Pr(>|z|)"))
    }
    else if (df.r > 0) {
      pvalue <- 2 * pt(-abs(tvalue), df.r)
      coef.table <- cbind(coef.p, s.err, tvalue, pvalue)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "t value", "Pr(>|t|)"))
    }
    else {
      coef.table <- cbind(coef.p, NaN, NaN, NaN)
      dimnames(coef.table) <- list(names(coef.p), c(dn, "t value", "Pr(>|t|)"))
    }
    df.f <- NCOL(Qr$qr)
  }
  else {
    coef.table <- matrix(, 0, 4)
    dimnames(coef.table) <- list(NULL, c("Estimate", "Std. Error", "t value", "Pr(>|t|)"))
    covmat.unscaled <- covmat <- matrix(, 0, 0)
    df.f <- length(aliased)
  }
  keep <- match(c("call", "terms", "family", "deviance", "aic", "contrasts", "df.residual", "null.deviance", "df.null", "iter", "na.action"), names(object), 0)
  ans <- c(object[keep], list(deviance.resid = residuals(object, type = "deviance"), coefficients = coef.table, aliased = aliased, dispersion = dispersion, df = c(object$rank, df.r, df.f), cov.unscaled = covmat.unscaled, cov.scaled = covmat))
  if (correlation && p > 0) {
    dd <- sqrt(diag(covmat.unscaled))
    ans$correlation <- covmat.unscaled/outer(dd, dd)
    ans$symbolic.cor <- symbolic.cor
  }
  class(ans) <- "summary.glm"
  return(ans)
})
c("package:stats", "registered S3 method for summary from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.lm
list(`package:stats` = function (object, correlation = FALSE, symbolic.cor = FALSE, ...) 
{
  z <- object
  p <- z$rank
  rdf <- z$df.residual
  if (p == 0) {
    r <- z$residuals
    n <- length(r)
    w <- z$weights
    if (is.null(w)) {
      rss <- sum(r^2)
    }
    else {
      rss <- sum(w * r^2)
      r <- sqrt(w) * r
    }
    resvar <- rss/rdf
    ans <- z[c("call", "terms", if (!is.null(z$weights)) "weights")]
    class(ans) <- "summary.lm"
    ans$aliased <- is.na(coef(object))
    ans$residuals <- r
    ans$df <- c(0, n, length(ans$aliased))
    ans$coefficients <- matrix(NA, 0, 4, dimnames = list(NULL, c("Estimate", "Std. Error", "t value", "Pr(>|t|)")))
    ans$sigma <- sqrt(resvar)
    ans$r.squared <- ans$adj.r.squared <- 0
    ans$cov.unscaled <- matrix(NA, 0, 0)
    if (correlation) 
      ans$correlation <- ans$cov.unscaled
    return(ans)
  }
  if (is.null(z$terms)) 
    stop("invalid 'lm' object:  no 'terms' component")
  if (!inherits(object, "lm")) 
    warning("calling summary.lm(<fake-lm-object>) ...")
  Qr <- qr.lm(object)
  n <- NROW(Qr$qr)
  if (is.na(z$df.residual) || n - p != z$df.residual) 
    warning("residual degrees of freedom in object suggest this is not an \"lm\" fit")
  r <- z$residuals
  f <- z$fitted.values
  w <- z$weights
  if (is.null(w)) {
    mss <- if (attr(z$terms, "intercept")) 
      sum((f - mean(f))^2)
    else sum(f^2)
    rss <- sum(r^2)
  }
  else {
    mss <- if (attr(z$terms, "intercept")) {
      m <- sum(w * f/sum(w))
      sum(w * (f - m)^2)
    }
    else sum(w * f^2)
    rss <- sum(w * r^2)
    r <- sqrt(w) * r
  }
  resvar <- rss/rdf
  if (is.finite(resvar) && resvar < (mean(f)^2 + var(c(f))) * 1e-30) 
    warning("essentially perfect fit: summary may be unreliable")
  p1 <- 1:p
  R <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
  se <- sqrt(diag(R) * resvar)
  est <- z$coefficients[Qr$pivot[p1]]
  tval <- est/se
  ans <- z[c("call", "terms", if (!is.null(z$weights)) "weights")]
  ans$residuals <- r
  ans$coefficients <- cbind(Estimate = est, `Std. Error` = se, `t value` = tval, `Pr(>|t|)` = 2 * pt(abs(tval), rdf, lower.tail = FALSE))
  ans$aliased <- is.na(z$coefficients)
  ans$sigma <- sqrt(resvar)
  ans$df <- c(p, rdf, NCOL(Qr$qr))
  if (p != attr(z$terms, "intercept")) {
    df.int <- if (attr(z$terms, "intercept")) 
      1
    else 0
    ans$r.squared <- mss/(mss + rss)
    ans$adj.r.squared <- 1 - (1 - ans$r.squared) * ((n - df.int)/rdf)
    ans$fstatistic <- c(value = (mss/(p - df.int))/resvar, numdf = p - df.int, dendf = rdf)
  }
  else ans$r.squared <- ans$adj.r.squared <- 0
  ans$cov.unscaled <- R
  dimnames(ans$cov.unscaled) <- dimnames(ans$coefficients)[c(1, 1)]
  if (correlation) {
    ans$correlation <- (R * resvar)/outer(se, se)
    dimnames(ans$correlation) <- dimnames(ans$cov.unscaled)
    ans$symbolic.cor <- symbolic.cor
  }
  if (!is.null(z$na.action)) 
    ans$na.action <- z$na.action
  class(ans) <- "summary.lm"
  ans
}, function (object, correlation = FALSE, symbolic.cor = FALSE, ...) 
{
  z <- object
  p <- z$rank
  rdf <- z$df.residual
  if (p == 0) {
    r <- z$residuals
    n <- length(r)
    w <- z$weights
    if (is.null(w)) {
      rss <- sum(r^2)
    }
    else {
      rss <- sum(w * r^2)
      r <- sqrt(w) * r
    }
    resvar <- rss/rdf
    ans <- z[c("call", "terms", if (!is.null(z$weights)) "weights")]
    class(ans) <- "summary.lm"
    ans$aliased <- is.na(coef(object))
    ans$residuals <- r
    ans$df <- c(0, n, length(ans$aliased))
    ans$coefficients <- matrix(NA, 0, 4, dimnames = list(NULL, c("Estimate", "Std. Error", "t value", "Pr(>|t|)")))
    ans$sigma <- sqrt(resvar)
    ans$r.squared <- ans$adj.r.squared <- 0
    ans$cov.unscaled <- matrix(NA, 0, 0)
    if (correlation) 
      ans$correlation <- ans$cov.unscaled
    return(ans)
  }
  if (is.null(z$terms)) 
    stop("invalid 'lm' object:  no 'terms' component")
  if (!inherits(object, "lm")) 
    warning("calling summary.lm(<fake-lm-object>) ...")
  Qr <- qr.lm(object)
  n <- NROW(Qr$qr)
  if (is.na(z$df.residual) || n - p != z$df.residual) 
    warning("residual degrees of freedom in object suggest this is not an \"lm\" fit")
  r <- z$residuals
  f <- z$fitted.values
  w <- z$weights
  if (is.null(w)) {
    mss <- if (attr(z$terms, "intercept")) 
      sum((f - mean(f))^2)
    else sum(f^2)
    rss <- sum(r^2)
  }
  else {
    mss <- if (attr(z$terms, "intercept")) {
      m <- sum(w * f/sum(w))
      sum(w * (f - m)^2)
    }
    else sum(w * f^2)
    rss <- sum(w * r^2)
    r <- sqrt(w) * r
  }
  resvar <- rss/rdf
  if (is.finite(resvar) && resvar < (mean(f)^2 + var(c(f))) * 1e-30) 
    warning("essentially perfect fit: summary may be unreliable")
  p1 <- 1:p
  R <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
  se <- sqrt(diag(R) * resvar)
  est <- z$coefficients[Qr$pivot[p1]]
  tval <- est/se
  ans <- z[c("call", "terms", if (!is.null(z$weights)) "weights")]
  ans$residuals <- r
  ans$coefficients <- cbind(Estimate = est, `Std. Error` = se, `t value` = tval, `Pr(>|t|)` = 2 * pt(abs(tval), rdf, lower.tail = FALSE))
  ans$aliased <- is.na(z$coefficients)
  ans$sigma <- sqrt(resvar)
  ans$df <- c(p, rdf, NCOL(Qr$qr))
  if (p != attr(z$terms, "intercept")) {
    df.int <- if (attr(z$terms, "intercept")) 
      1
    else 0
    ans$r.squared <- mss/(mss + rss)
    ans$adj.r.squared <- 1 - (1 - ans$r.squared) * ((n - df.int)/rdf)
    ans$fstatistic <- c(value = (mss/(p - df.int))/resvar, numdf = p - df.int, dendf = rdf)
  }
  else ans$r.squared <- ans$adj.r.squared <- 0
  ans$cov.unscaled <- R
  dimnames(ans$cov.unscaled) <- dimnames(ans$coefficients)[c(1, 1)]
  if (correlation) {
    ans$correlation <- (R * resvar)/outer(se, se)
    dimnames(ans$correlation) <- dimnames(ans$cov.unscaled)
    ans$symbolic.cor <- symbolic.cor
  }
  if (!is.null(z$na.action)) 
    ans$na.action <- z$na.action
  class(ans) <- "summary.lm"
  ans
}, function (object, correlation = FALSE, symbolic.cor = FALSE, ...) 
{
  z <- object
  p <- z$rank
  rdf <- z$df.residual
  if (p == 0) {
    r <- z$residuals
    n <- length(r)
    w <- z$weights
    if (is.null(w)) {
      rss <- sum(r^2)
    }
    else {
      rss <- sum(w * r^2)
      r <- sqrt(w) * r
    }
    resvar <- rss/rdf
    ans <- z[c("call", "terms", if (!is.null(z$weights)) "weights")]
    class(ans) <- "summary.lm"
    ans$aliased <- is.na(coef(object))
    ans$residuals <- r
    ans$df <- c(0, n, length(ans$aliased))
    ans$coefficients <- matrix(NA, 0, 4, dimnames = list(NULL, c("Estimate", "Std. Error", "t value", "Pr(>|t|)")))
    ans$sigma <- sqrt(resvar)
    ans$r.squared <- ans$adj.r.squared <- 0
    ans$cov.unscaled <- matrix(NA, 0, 0)
    if (correlation) 
      ans$correlation <- ans$cov.unscaled
    return(ans)
  }
  if (is.null(z$terms)) 
    stop("invalid 'lm' object:  no 'terms' component")
  if (!inherits(object, "lm")) 
    warning("calling summary.lm(<fake-lm-object>) ...")
  Qr <- qr.lm(object)
  n <- NROW(Qr$qr)
  if (is.na(z$df.residual) || n - p != z$df.residual) 
    warning("residual degrees of freedom in object suggest this is not an \"lm\" fit")
  r <- z$residuals
  f <- z$fitted.values
  w <- z$weights
  if (is.null(w)) {
    mss <- if (attr(z$terms, "intercept")) 
      sum((f - mean(f))^2)
    else sum(f^2)
    rss <- sum(r^2)
  }
  else {
    mss <- if (attr(z$terms, "intercept")) {
      m <- sum(w * f/sum(w))
      sum(w * (f - m)^2)
    }
    else sum(w * f^2)
    rss <- sum(w * r^2)
    r <- sqrt(w) * r
  }
  resvar <- rss/rdf
  if (is.finite(resvar) && resvar < (mean(f)^2 + var(c(f))) * 1e-30) 
    warning("essentially perfect fit: summary may be unreliable")
  p1 <- 1:p
  R <- chol2inv(Qr$qr[p1, p1, drop = FALSE])
  se <- sqrt(diag(R) * resvar)
  est <- z$coefficients[Qr$pivot[p1]]
  tval <- est/se
  ans <- z[c("call", "terms", if (!is.null(z$weights)) "weights")]
  ans$residuals <- r
  ans$coefficients <- cbind(Estimate = est, `Std. Error` = se, `t value` = tval, `Pr(>|t|)` = 2 * pt(abs(tval), rdf, lower.tail = FALSE))
  ans$aliased <- is.na(z$coefficients)
  ans$sigma <- sqrt(resvar)
  ans$df <- c(p, rdf, NCOL(Qr$qr))
  if (p != attr(z$terms, "intercept")) {
    df.int <- if (attr(z$terms, "intercept")) 
      1
    else 0
    ans$r.squared <- mss/(mss + rss)
    ans$adj.r.squared <- 1 - (1 - ans$r.squared) * ((n - df.int)/rdf)
    ans$fstatistic <- c(value = (mss/(p - df.int))/resvar, numdf = p - df.int, dendf = rdf)
  }
  else ans$r.squared <- ans$adj.r.squared <- 0
  ans$cov.unscaled <- R
  dimnames(ans$cov.unscaled) <- dimnames(ans$coefficients)[c(1, 1)]
  if (correlation) {
    ans$correlation <- (R * resvar)/outer(se, se)
    dimnames(ans$correlation) <- dimnames(ans$cov.unscaled)
    ans$symbolic.cor <- symbolic.cor
  }
  if (!is.null(z$na.action)) 
    ans$na.action <- z$na.action
  class(ans) <- "summary.lm"
  ans
})
c("package:stats", "registered S3 method for summary from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.manova
list(`package:stats` = function (object, test = c("Pillai", "Wilks", "Hotelling-Lawley", "Roy"), intercept = FALSE, tol = 1e-07, ...) 
{
  if (!inherits(object, "maov")) 
    stop(gettextf("object must be of class %s or %s", dQuote("manova"), dQuote("maov")), domain = NA)
  test <- match.arg(test)
  asgn <- object$assign[object$qr$pivot[1:object$rank]]
  uasgn <- unique(asgn)
  nterms <- length(uasgn)
  effects <- object$effects
  if (!is.null(effects)) 
    effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
  rdf <- object$df.residual
  nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
  resid <- as.matrix(object$residuals)
  wt <- object$weights
  if (!is.null(wt)) 
    resid <- resid * sqrt(wt)
  nresp <- NCOL(resid)
  if (nresp <= 1) 
    stop("need multiple responses")
  if (is.null(effects)) {
    df <- nterms <- 0
    ss <- list(0)
    nmrows <- character()
  }
  else {
    df <- numeric(nterms)
    ss <- list(nterms)
    nmrows <- character(nterms)
    for (i in seq(nterms)) {
      ai <- (asgn == uasgn[i])
      nmrows[i] <- nmeffect[1 + uasgn[i]]
      df[i] <- sum(ai)
      ss[[i]] <- crossprod(effects[ai, , drop = FALSE])
    }
  }
  pm <- pmatch("(Intercept)", nmrows, 0)
  if (!intercept && pm > 0) {
    nterms <- nterms - 1
    df <- df[-pm]
    nmrows <- nmrows[-pm]
    ss <- ss[-pm]
  }
  names(ss) <- nmrows
  nt <- nterms
  if (rdf > 0) {
    nt <- nterms + 1
    df[nt] <- rdf
    ss[[nt]] <- crossprod(resid)
    names(ss)[nt] <- nmrows[nt] <- "Residuals"
    ok <- df[-nt] > 0
    eigs <- array(NA, c(nterms, nresp), dimnames = list(nmrows[-nt], NULL))
    stats <- matrix(NA, nt, 5, dimnames = list(nmrows, c(test, "approx F", "num Df", "den Df", "Pr(>F)")))
    sc <- sqrt(sss <- diag(ss[[nt]]))
    for (i in seq_len(nterms)[ok]) sss <- sss + diag(ss[[i]])
    sc[sc < sqrt(sss) * 1e-06] <- 1
    D <- diag(1/sc)
    rss.qr <- qr(D %*% ss[[nt]] %*% D, tol = tol)
    if (rss.qr$rank < ncol(resid)) 
      stop(gettextf("residuals have rank %d < %d", rss.qr$rank, ncol(resid)), domain = NA)
    if (!is.null(rss.qr)) 
      for (i in seq_len(nterms)[ok]) {
        A1 <- qr.coef(rss.qr, D %*% ss[[i]] %*% D)
        eigs[i, ] <- Re(eigen(A1, symmetric = FALSE, only.values = TRUE)$values)
        stats[i, 1:4] <- switch(test, Pillai = Pillai(eigs[i, ], df[i], df[nt]), Wilks = Wilks(eigs[i, ], df[i], df[nt]), `Hotelling-Lawley` = HL(eigs[i, ], df[i], df[nt]), Roy = Roy(eigs[i, ], df[i], df[nt]))
        ok <- stats[, 2] >= 0 & stats[, 3] > 0 & stats[, 4] > 0
        ok <- !is.na(ok) & ok
        stats[ok, 5] <- pf(stats[ok, 2], stats[ok, 3], stats[ok, 4], lower.tail = FALSE)
      }
    x <- list(row.names = nmrows, SS = ss, Eigenvalues = eigs, stats = cbind(Df = df, stats = stats))
  }
  else x <- list(row.names = nmrows, SS = ss, Df = df)
  class(x) <- "summary.manova"
  x
}, function (object, test = c("Pillai", "Wilks", "Hotelling-Lawley", "Roy"), intercept = FALSE, tol = 1e-07, ...) 
{
  if (!inherits(object, "maov")) 
    stop(gettextf("object must be of class %s or %s", dQuote("manova"), dQuote("maov")), domain = NA)
  test <- match.arg(test)
  asgn <- object$assign[object$qr$pivot[1:object$rank]]
  uasgn <- unique(asgn)
  nterms <- length(uasgn)
  effects <- object$effects
  if (!is.null(effects)) 
    effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
  rdf <- object$df.residual
  nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
  resid <- as.matrix(object$residuals)
  wt <- object$weights
  if (!is.null(wt)) 
    resid <- resid * sqrt(wt)
  nresp <- NCOL(resid)
  if (nresp <= 1) 
    stop("need multiple responses")
  if (is.null(effects)) {
    df <- nterms <- 0
    ss <- list(0)
    nmrows <- character()
  }
  else {
    df <- numeric(nterms)
    ss <- list(nterms)
    nmrows <- character(nterms)
    for (i in seq(nterms)) {
      ai <- (asgn == uasgn[i])
      nmrows[i] <- nmeffect[1 + uasgn[i]]
      df[i] <- sum(ai)
      ss[[i]] <- crossprod(effects[ai, , drop = FALSE])
    }
  }
  pm <- pmatch("(Intercept)", nmrows, 0)
  if (!intercept && pm > 0) {
    nterms <- nterms - 1
    df <- df[-pm]
    nmrows <- nmrows[-pm]
    ss <- ss[-pm]
  }
  names(ss) <- nmrows
  nt <- nterms
  if (rdf > 0) {
    nt <- nterms + 1
    df[nt] <- rdf
    ss[[nt]] <- crossprod(resid)
    names(ss)[nt] <- nmrows[nt] <- "Residuals"
    ok <- df[-nt] > 0
    eigs <- array(NA, c(nterms, nresp), dimnames = list(nmrows[-nt], NULL))
    stats <- matrix(NA, nt, 5, dimnames = list(nmrows, c(test, "approx F", "num Df", "den Df", "Pr(>F)")))
    sc <- sqrt(sss <- diag(ss[[nt]]))
    for (i in seq_len(nterms)[ok]) sss <- sss + diag(ss[[i]])
    sc[sc < sqrt(sss) * 1e-06] <- 1
    D <- diag(1/sc)
    rss.qr <- qr(D %*% ss[[nt]] %*% D, tol = tol)
    if (rss.qr$rank < ncol(resid)) 
      stop(gettextf("residuals have rank %d < %d", rss.qr$rank, ncol(resid)), domain = NA)
    if (!is.null(rss.qr)) 
      for (i in seq_len(nterms)[ok]) {
        A1 <- qr.coef(rss.qr, D %*% ss[[i]] %*% D)
        eigs[i, ] <- Re(eigen(A1, symmetric = FALSE, only.values = TRUE)$values)
        stats[i, 1:4] <- switch(test, Pillai = Pillai(eigs[i, ], df[i], df[nt]), Wilks = Wilks(eigs[i, ], df[i], df[nt]), `Hotelling-Lawley` = HL(eigs[i, ], df[i], df[nt]), Roy = Roy(eigs[i, ], df[i], df[nt]))
        ok <- stats[, 2] >= 0 & stats[, 3] > 0 & stats[, 4] > 0
        ok <- !is.na(ok) & ok
        stats[ok, 5] <- pf(stats[ok, 2], stats[ok, 3], stats[ok, 4], lower.tail = FALSE)
      }
    x <- list(row.names = nmrows, SS = ss, Eigenvalues = eigs, stats = cbind(Df = df, stats = stats))
  }
  else x <- list(row.names = nmrows, SS = ss, Df = df)
  class(x) <- "summary.manova"
  x
}, function (object, test = c("Pillai", "Wilks", "Hotelling-Lawley", "Roy"), intercept = FALSE, tol = 1e-07, ...) 
{
  if (!inherits(object, "maov")) 
    stop(gettextf("object must be of class %s or %s", dQuote("manova"), dQuote("maov")), domain = NA)
  test <- match.arg(test)
  asgn <- object$assign[object$qr$pivot[1:object$rank]]
  uasgn <- unique(asgn)
  nterms <- length(uasgn)
  effects <- object$effects
  if (!is.null(effects)) 
    effects <- as.matrix(effects)[seq_along(asgn), , drop = FALSE]
  rdf <- object$df.residual
  nmeffect <- c("(Intercept)", attr(object$terms, "term.labels"))
  resid <- as.matrix(object$residuals)
  wt <- object$weights
  if (!is.null(wt)) 
    resid <- resid * sqrt(wt)
  nresp <- NCOL(resid)
  if (nresp <= 1) 
    stop("need multiple responses")
  if (is.null(effects)) {
    df <- nterms <- 0
    ss <- list(0)
    nmrows <- character()
  }
  else {
    df <- numeric(nterms)
    ss <- list(nterms)
    nmrows <- character(nterms)
    for (i in seq(nterms)) {
      ai <- (asgn == uasgn[i])
      nmrows[i] <- nmeffect[1 + uasgn[i]]
      df[i] <- sum(ai)
      ss[[i]] <- crossprod(effects[ai, , drop = FALSE])
    }
  }
  pm <- pmatch("(Intercept)", nmrows, 0)
  if (!intercept && pm > 0) {
    nterms <- nterms - 1
    df <- df[-pm]
    nmrows <- nmrows[-pm]
    ss <- ss[-pm]
  }
  names(ss) <- nmrows
  nt <- nterms
  if (rdf > 0) {
    nt <- nterms + 1
    df[nt] <- rdf
    ss[[nt]] <- crossprod(resid)
    names(ss)[nt] <- nmrows[nt] <- "Residuals"
    ok <- df[-nt] > 0
    eigs <- array(NA, c(nterms, nresp), dimnames = list(nmrows[-nt], NULL))
    stats <- matrix(NA, nt, 5, dimnames = list(nmrows, c(test, "approx F", "num Df", "den Df", "Pr(>F)")))
    sc <- sqrt(sss <- diag(ss[[nt]]))
    for (i in seq_len(nterms)[ok]) sss <- sss + diag(ss[[i]])
    sc[sc < sqrt(sss) * 1e-06] <- 1
    D <- diag(1/sc)
    rss.qr <- qr(D %*% ss[[nt]] %*% D, tol = tol)
    if (rss.qr$rank < ncol(resid)) 
      stop(gettextf("residuals have rank %d < %d", rss.qr$rank, ncol(resid)), domain = NA)
    if (!is.null(rss.qr)) 
      for (i in seq_len(nterms)[ok]) {
        A1 <- qr.coef(rss.qr, D %*% ss[[i]] %*% D)
        eigs[i, ] <- Re(eigen(A1, symmetric = FALSE, only.values = TRUE)$values)
        stats[i, 1:4] <- switch(test, Pillai = Pillai(eigs[i, ], df[i], df[nt]), Wilks = Wilks(eigs[i, ], df[i], df[nt]), `Hotelling-Lawley` = HL(eigs[i, ], df[i], df[nt]), Roy = Roy(eigs[i, ], df[i], df[nt]))
        ok <- stats[, 2] >= 0 & stats[, 3] > 0 & stats[, 4] > 0
        ok <- !is.na(ok) & ok
        stats[ok, 5] <- pf(stats[ok, 2], stats[ok, 3], stats[ok, 4], lower.tail = FALSE)
      }
    x <- list(row.names = nmrows, SS = ss, Eigenvalues = eigs, stats = cbind(Df = df, stats = stats))
  }
  else x <- list(row.names = nmrows, SS = ss, Df = df)
  class(x) <- "summary.manova"
  x
})
c("package:stats", "registered S3 method for summary from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
summary.stepfun
list(`package:stats` = function (object, ...) 
{
  n <- length(eval(expression(x), envir = environment(object)))
  if (!is.integer(n) || n < 1) 
    stop("not a valid step function")
  cat("Step function with continuity 'f'=", format(eval(expression(f), envir = environment(object))), ", ", n, if (n <= 6) 
    "knots at\n"
    else "knots with summary\n")
  summ <- if (n > 6) 
    summary
  else function(x) x
  print(summ(knots(object)))
  cat(if (n > 6) 
    "\n"
    else "  ", "and\t", n + 1, " plateau levels (y) ", if (n <= 6) 
      "at\n"
    else "with summary\n", sep = "")
  print(summ(eval(expression(c(yleft, y)), envir = environment(object))))
  invisible()
}, function (object, ...) 
{
  n <- length(eval(expression(x), envir = environment(object)))
  if (!is.integer(n) || n < 1) 
    stop("not a valid step function")
  cat("Step function with continuity 'f'=", format(eval(expression(f), envir = environment(object))), ", ", n, if (n <= 6) 
    "knots at\n"
    else "knots with summary\n")
  summ <- if (n > 6) 
    summary
  else function(x) x
  print(summ(knots(object)))
  cat(if (n > 6) 
    "\n"
    else "  ", "and\t", n + 1, " plateau levels (y) ", if (n <= 6) 
      "at\n"
    else "with summary\n", sep = "")
  print(summ(eval(expression(c(yleft, y)), envir = environment(object))))
  invisible()
}, function (object, ...) 
{
  n <- length(eval(expression(x), envir = environment(object)))
  if (!is.integer(n) || n < 1) 
    stop("not a valid step function")
  cat("Step function with continuity 'f'=", format(eval(expression(f), envir = environment(object))), ", ", n, if (n <= 6) 
    "knots at\n"
    else "knots with summary\n")
  summ <- if (n > 6) 
    summary
  else function(x) x
  print(summ(knots(object)))
  cat(if (n > 6) 
    "\n"
    else "  ", "and\t", n + 1, " plateau levels (y) ", if (n <= 6) 
      "at\n"
    else "with summary\n", sep = "")
  print(summ(eval(expression(c(yleft, y)), envir = environment(object))))
  invisible()
})
c("package:stats", "registered S3 method for summary from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
supsmu
list(`package:stats` = function (x, y, wt = rep(1, n), span = "cv", periodic = FALSE, bass = 0, trace = FALSE) 
{
  if (span == "cv") 
    span <- 0
  else if (span < 0 || span > 1) 
    stop("'span' must be between 0 and 1.")
  n <- length(y)
  if (!n || !is.numeric(y)) 
    stop("'y' must be numeric vector")
  if (length(x) != n) 
    stop("number of observations in 'x' and 'y' must match.")
  if (length(wt) != n) 
    stop("number of weights must match number of observations.")
  if (periodic) {
    iper <- 2
    xrange <- range(x)
    if (xrange[1] < 0 || xrange[2] > 1) 
      stop("'x' must be between 0 and 1 for periodic smooth")
  }
  else iper <- 1
  okay <- is.finite(x + y + wt)
  ord <- order(x[okay], y[okay])
  ord <- cumsum(!okay)[okay][ord] + ord
  xo <- x[ord]
  leno <- length(ord)
  if (leno == 0) 
    stop("no finite observations")
  if (diff <- n - leno) 
    warning(sprintf(ngettext(diff, "%d observation with NA, NaN or Inf deleted", "%d observations with NAs, NaNs and/or Infs deleted"), diff), domain = NA)
  .Fortran(C_setsmu, as.integer(trace))
  smo <- .Fortran(C_supsmu, as.integer(leno), as.double(xo), as.double(y[ord]), as.double(wt[ord]), as.integer(iper), as.double(span), as.double(bass), smo = double(leno), double(n * 7), double(1))$smo
  dupx <- duplicated(xo)
  list(x = xo[!dupx], y = smo[!dupx])
}, function (x, y, wt = rep(1, n), span = "cv", periodic = FALSE, bass = 0, trace = FALSE) 
{
  if (span == "cv") 
    span <- 0
  else if (span < 0 || span > 1) 
    stop("'span' must be between 0 and 1.")
  n <- length(y)
  if (!n || !is.numeric(y)) 
    stop("'y' must be numeric vector")
  if (length(x) != n) 
    stop("number of observations in 'x' and 'y' must match.")
  if (length(wt) != n) 
    stop("number of weights must match number of observations.")
  if (periodic) {
    iper <- 2
    xrange <- range(x)
    if (xrange[1] < 0 || xrange[2] > 1) 
      stop("'x' must be between 0 and 1 for periodic smooth")
  }
  else iper <- 1
  okay <- is.finite(x + y + wt)
  ord <- order(x[okay], y[okay])
  ord <- cumsum(!okay)[okay][ord] + ord
  xo <- x[ord]
  leno <- length(ord)
  if (leno == 0) 
    stop("no finite observations")
  if (diff <- n - leno) 
    warning(sprintf(ngettext(diff, "%d observation with NA, NaN or Inf deleted", "%d observations with NAs, NaNs and/or Infs deleted"), diff), domain = NA)
  .Fortran(C_setsmu, as.integer(trace))
  smo <- .Fortran(C_supsmu, as.integer(leno), as.double(xo), as.double(y[ord]), as.double(wt[ord]), as.integer(iper), as.double(span), as.double(bass), smo = double(leno), double(n * 7), double(1))$smo
  dupx <- duplicated(xo)
  list(x = xo[!dupx], y = smo[!dupx])
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
symnum
list(`package:stats` = function (x, cutpoints = c(0.3, 0.6, 0.8, 0.9, 0.95), symbols = if (numeric.x) c(" ", ".", ",", "+", "*", "B") else c(".", "|"), legend = length(symbols) >= 3, na = "?", eps = 1e-05, numeric.x = is.numeric(x), corr = missing(cutpoints) && numeric.x, show.max = if (corr) "1", show.min = NULL, abbr.colnames = has.colnames, lower.triangular = corr && is.numeric(x) && is.matrix(x), diag.lower.tri = corr && !is.null(show.max)) 
{
  if (length(x) == 0) 
    return(noquote(if (is.null(d <- dim(x))) character() else array("", dim = d)))
  has.na <- any(nax <- is.na(x))
  if (numeric.x) {
    force(corr)
    cutpoints <- sort(cutpoints)
    if (corr) 
      cutpoints <- c(0, cutpoints, 1)
    if (anyDuplicated(cutpoints) || (corr && (any(cutpoints > 1) || any(cutpoints < 0)))) 
      stop(if (corr) 
        gettext("'cutpoints' must be unique in 0 < cuts < 1, but are = ")
        else gettext("'cutpoints' must be unique, but are = "), paste(format(cutpoints), collapse = "|"), domain = NA)
    nc <- length(cutpoints)
    minc <- cutpoints[1]
    maxc <- cutpoints[nc]
    range.msg <- if (corr) 
      gettext("'x' must be between -1 and 1")
    else gettextf("'x' must be between %s and %s", format(minc), format(maxc))
    if (corr) 
      x <- abs(x)
    else if (any(x < minc - eps, na.rm = TRUE)) 
      stop(range.msg, domain = NA)
    if (any(x > maxc + eps, na.rm = TRUE)) 
      stop(range.msg, domain = NA)
    ns <- length(symbols)
    symbols <- as.character(symbols)
    if (anyDuplicated(symbols)) 
      stop("'symbols' must be unique, but are = ", paste(symbols, collapse = "|"), domain = NA)
    if (nc != ns + 1) 
      if (corr) 
        stop("number of 'cutpoints' must be one less than number of symbols")
    else stop("number of 'cutpoints' must be one more than number of symbols")
    iS <- cut(x, breaks = cutpoints, include.lowest = TRUE, labels = FALSE)
    if (any(ii <- is.na(iS))) {
      iS[which(ii)[!is.na(x[ii]) & (abs(x[ii] - minc) < eps)]] <- 1
    }
  }
  else {
    if (!missing(symbols) && length(symbols) != 2) 
      stop("must have 2 'symbols' for logical 'x' argument")
    iS <- x + 1
  }
  if (has.na) {
    ans <- character(length(iS))
    if ((has.na <- is.character(na))) 
      ans[nax] <- na
    ans[!nax] <- symbols[iS[!nax]]
  }
  else ans <- symbols[iS]
  if (numeric.x) {
    if (!is.null(show.max)) 
      ans[x >= maxc - eps] <- if (is.character(show.max)) 
        show.max
    else format(maxc, digits = 1)
    if (!is.null(show.min)) 
      ans[x <= minc + eps] <- if (is.character(show.min)) 
        show.min
    else format(minc, digits = 1)
  }
  if (lower.triangular && is.matrix(x)) 
    ans[!lower.tri(x, diag = diag.lower.tri)] <- ""
  attributes(ans) <- attributes(x)
  if (is.array(ans) && (rank <- length(dim(x))) >= 2) {
    has.colnames <- !is.null(dimnames(ans))
    if (!has.colnames) {
      dimnames(ans) <- vector("list", rank)
    }
    else {
      has.colnames <- length(dimnames(ans)[[2]]) > 0
    }
    if ((is.logical(abbr.colnames) || is.numeric(abbr.colnames)) && abbr.colnames) {
      dimnames(ans)[[2]] <- abbreviate(dimnames(ans)[[2]], minlength = abbr.colnames)
    }
    else if (is.null(abbr.colnames) || is.null(dimnames(ans)[[2]])) 
      dimnames(ans)[[2]] <- rep("", dim(ans)[2])
    else if (!is.logical(abbr.colnames)) 
      stop("invalid 'abbr.colnames'")
  }
  if (legend) {
    legend <- c(rbind(sapply(cutpoints, format), c(sQuote(symbols), "")), if (has.na) paste("\t    ## NA:", sQuote(na)))
    attr(ans, "legend") <- paste(legend[-2 * (ns + 1)], collapse = " ")
  }
  noquote(ans)
}, function (x, cutpoints = c(0.3, 0.6, 0.8, 0.9, 0.95), symbols = if (numeric.x) c(" ", ".", ",", "+", "*", "B") else c(".", "|"), legend = length(symbols) >= 3, na = "?", eps = 1e-05, numeric.x = is.numeric(x), corr = missing(cutpoints) && numeric.x, show.max = if (corr) "1", show.min = NULL, abbr.colnames = has.colnames, lower.triangular = corr && is.numeric(x) && is.matrix(x), diag.lower.tri = corr && !is.null(show.max)) 
{
  if (length(x) == 0) 
    return(noquote(if (is.null(d <- dim(x))) character() else array("", dim = d)))
  has.na <- any(nax <- is.na(x))
  if (numeric.x) {
    force(corr)
    cutpoints <- sort(cutpoints)
    if (corr) 
      cutpoints <- c(0, cutpoints, 1)
    if (anyDuplicated(cutpoints) || (corr && (any(cutpoints > 1) || any(cutpoints < 0)))) 
      stop(if (corr) 
        gettext("'cutpoints' must be unique in 0 < cuts < 1, but are = ")
        else gettext("'cutpoints' must be unique, but are = "), paste(format(cutpoints), collapse = "|"), domain = NA)
    nc <- length(cutpoints)
    minc <- cutpoints[1]
    maxc <- cutpoints[nc]
    range.msg <- if (corr) 
      gettext("'x' must be between -1 and 1")
    else gettextf("'x' must be between %s and %s", format(minc), format(maxc))
    if (corr) 
      x <- abs(x)
    else if (any(x < minc - eps, na.rm = TRUE)) 
      stop(range.msg, domain = NA)
    if (any(x > maxc + eps, na.rm = TRUE)) 
      stop(range.msg, domain = NA)
    ns <- length(symbols)
    symbols <- as.character(symbols)
    if (anyDuplicated(symbols)) 
      stop("'symbols' must be unique, but are = ", paste(symbols, collapse = "|"), domain = NA)
    if (nc != ns + 1) 
      if (corr) 
        stop("number of 'cutpoints' must be one less than number of symbols")
    else stop("number of 'cutpoints' must be one more than number of symbols")
    iS <- cut(x, breaks = cutpoints, include.lowest = TRUE, labels = FALSE)
    if (any(ii <- is.na(iS))) {
      iS[which(ii)[!is.na(x[ii]) & (abs(x[ii] - minc) < eps)]] <- 1
    }
  }
  else {
    if (!missing(symbols) && length(symbols) != 2) 
      stop("must have 2 'symbols' for logical 'x' argument")
    iS <- x + 1
  }
  if (has.na) {
    ans <- character(length(iS))
    if ((has.na <- is.character(na))) 
      ans[nax] <- na
    ans[!nax] <- symbols[iS[!nax]]
  }
  else ans <- symbols[iS]
  if (numeric.x) {
    if (!is.null(show.max)) 
      ans[x >= maxc - eps] <- if (is.character(show.max)) 
        show.max
    else format(maxc, digits = 1)
    if (!is.null(show.min)) 
      ans[x <= minc + eps] <- if (is.character(show.min)) 
        show.min
    else format(minc, digits = 1)
  }
  if (lower.triangular && is.matrix(x)) 
    ans[!lower.tri(x, diag = diag.lower.tri)] <- ""
  attributes(ans) <- attributes(x)
  if (is.array(ans) && (rank <- length(dim(x))) >= 2) {
    has.colnames <- !is.null(dimnames(ans))
    if (!has.colnames) {
      dimnames(ans) <- vector("list", rank)
    }
    else {
      has.colnames <- length(dimnames(ans)[[2]]) > 0
    }
    if ((is.logical(abbr.colnames) || is.numeric(abbr.colnames)) && abbr.colnames) {
      dimnames(ans)[[2]] <- abbreviate(dimnames(ans)[[2]], minlength = abbr.colnames)
    }
    else if (is.null(abbr.colnames) || is.null(dimnames(ans)[[2]])) 
      dimnames(ans)[[2]] <- rep("", dim(ans)[2])
    else if (!is.logical(abbr.colnames)) 
      stop("invalid 'abbr.colnames'")
  }
  if (legend) {
    legend <- c(rbind(sapply(cutpoints, format), c(sQuote(symbols), "")), if (has.na) paste("\t    ## NA:", sQuote(na)))
    attr(ans, "legend") <- paste(legend[-2 * (ns + 1)], collapse = " ")
  }
  noquote(ans)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
t.test
list(`package:stats` = function (x, ...) 
  UseMethod("t.test"), function (x, ...) 
    UseMethod("t.test"), function (x, ...) 
      UseMethod("t.test"))
c("package:stats", "registered S3 method for t from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
termplot
list(`package:stats` = function (model, data = NULL, envir = environment(formula(model)), partial.resid = FALSE, rug = FALSE, terms = NULL, se = FALSE, xlabs = NULL, ylabs = NULL, main = NULL, col.term = 2, lwd.term = 1.5, col.se = "orange", lty.se = 2, lwd.se = 1, col.res = "gray", cex = 1, pch = par("pch"), col.smth = "darkred", lty.smth = 2, span.smth = 2/3, ask = dev.interactive() && nb.fig < n.tms, use.factor.levels = TRUE, smooth = NULL, ylim = "common", plot = TRUE, transform.x = FALSE, ...) 
{
  which.terms <- terms
  terms <- if (is.null(terms)) 
    predict(model, type = "terms", se.fit = se)
  else predict(model, type = "terms", se.fit = se, terms = terms)
  n.tms <- ncol(tms <- as.matrix(if (se) 
    terms$fit
    else terms))
  transform.x <- rep_len(transform.x, n.tms)
  mf <- model.frame(model)
  if (is.null(data)) 
    data <- eval(model$call$data, envir)
  if (is.null(data)) 
    data <- mf
  use.rows <- if (NROW(tms) < NROW(data)) 
    match(rownames(tms), rownames(data))
  nmt <- colnames(tms)
  if (any(grepl(":", nmt, fixed = TRUE))) 
    warning("'model' appears to involve interactions: see the help page", domain = NA, immediate. = TRUE)
  cn <- str2expression(nmt)
  if (!is.null(smooth)) 
    smooth <- match.fun(smooth)
  if (is.null(ylabs)) 
    ylabs <- paste("Partial for", nmt)
  if (is.null(main)) 
    main <- ""
  else if (is.logical(main)) 
    main <- if (main) 
      deparse(model$call, 500)
  else ""
  else if (!is.character(main)) 
    stop("'main' must be TRUE, FALSE, NULL or character (vector).")
  main <- rep_len(main, n.tms)
  pf <- envir
  carrier <- function(term, transform) {
    if (length(term) > 1) {
      if (transform) 
        tms[, i]
      else carrier(term[[2]], transform)
    }
    else eval(term, data, enclos = pf)
  }
  carrier.name <- function(term) {
    if (length(term) > 1) 
      carrier.name(term[[2]])
    else as.character(term)
  }
  in.mf <- nmt %in% names(mf)
  is.fac <- sapply(nmt, function(i) i %in% names(mf) && is.factor(mf[, i]))
  if (!plot) {
    outlist <- vector("list", sum(in.mf))
    for (i in 1:n.tms) {
      if (!in.mf[i]) 
        next
      if (is.fac[i]) {
        xx <- mf[, nmt[i]]
        if (!is.null(use.rows)) 
          xx <- xx[use.rows]
        ww <- match(levels(xx), xx, nomatch = 0)
      }
      else {
        xx <- carrier(cn[[i]], transform.x[i])
        if (!is.null(use.rows)) 
          xx <- xx[use.rows]
        ww <- match(sort(unique(xx)), xx)
      }
      outlist[[i]] <- if (se) 
        data.frame(x = xx[ww], y = tms[ww, i], se = terms$se.fit[ww, i], row.names = NULL)
      else data.frame(x = xx[ww], y = tms[ww, i], row.names = NULL)
    }
    attr(outlist, "constant") <- attr(terms, "constant")
    if (se && is.null(attr(outlist, "constant"))) 
      attr(outlist, "constant") <- attr(terms$fit, "constant")
    names(outlist) <- sapply(cn, carrier.name)[in.mf]
    return(outlist)
  }
  if (!is.null(smooth)) 
    smooth <- match.fun(smooth)
  if (is.null(ylabs)) 
    ylabs <- paste("Partial for", nmt)
  if (is.null(main)) 
    main <- ""
  else if (is.logical(main)) 
    main <- if (main) 
      deparse(model$call, 500)
  else ""
  else if (!is.character(main)) 
    stop("'main' must be TRUE, FALSE, NULL or character (vector).")
  main <- rep_len(main, n.tms)
  if (is.null(xlabs)) {
    xlabs <- unlist(lapply(cn, carrier.name))
    if (any(transform.x)) 
      xlabs <- ifelse(transform.x, lapply(cn, deparse), xlabs)
  }
  if (partial.resid || !is.null(smooth)) {
    pres <- residuals(model, "partial")
    if (!is.null(which.terms)) 
      pres <- pres[, which.terms, drop = FALSE]
  }
  se.lines <- function(x, iy, i, ff = 2) {
    tt <- ff * terms$se.fit[iy, i]
    lines(x, tms[iy, i] + tt, lty = lty.se, lwd = lwd.se, col = col.se)
    lines(x, tms[iy, i] - tt, lty = lty.se, lwd = lwd.se, col = col.se)
  }
  nb.fig <- prod(par("mfcol"))
  if (ask) {
    oask <- devAskNewPage(TRUE)
    on.exit(devAskNewPage(oask))
  }
  ylims <- ylim
  if (identical(ylims, "common")) {
    ylims <- if (!se) 
      range(tms, na.rm = TRUE)
    else range(tms + 1.05 * 2 * terms$se.fit, tms - 1.05 * 2 * terms$se.fit, na.rm = TRUE)
    if (partial.resid) 
      ylims <- range(ylims, pres, na.rm = TRUE)
    if (rug) 
      ylims[1] <- ylims[1] - 0.07 * diff(ylims)
  }
  for (i in 1:n.tms) {
    if (identical(ylim, "free")) {
      ylims <- range(tms[, i], na.rm = TRUE)
      if (se) 
        ylims <- range(ylims, tms[, i] + 1.05 * 2 * terms$se.fit[, i], tms[, i] - 1.05 * 2 * terms$se.fit[, i], na.rm = TRUE)
      if (partial.resid) 
        ylims <- range(ylims, pres[, i], na.rm = TRUE)
      if (rug) 
        ylims[1] <- ylims[1] - 0.07 * diff(ylims)
    }
    if (!in.mf[i]) 
      next
    if (is.fac[i]) {
      ff <- mf[, nmt[i]]
      if (!is.null(model$na.action)) 
        ff <- naresid(model$na.action, ff)
      ll <- levels(ff)
      xlims <- range(seq_along(ll)) + c(-0.5, 0.5)
      xx <- as.numeric(ff)
      if (rug) {
        xlims[1] <- xlims[1] - 0.07 * diff(xlims)
        xlims[2] <- xlims[2] + 0.03 * diff(xlims)
      }
      plot(1, 0, type = "n", xlab = xlabs[i], ylab = ylabs[i], xlim = xlims, ylim = ylims, main = main[i], xaxt = "n", ...)
      if (use.factor.levels) 
        axis(1, at = seq_along(ll), labels = ll, ...)
      else axis(1)
      for (j in seq_along(ll)) {
        ww <- which(ff == ll[j])[c(1, 1)]
        jf <- j + c(-0.4, 0.4)
        lines(jf, tms[ww, i], col = col.term, lwd = lwd.term, ...)
        if (se) 
          se.lines(jf, iy = ww, i = i)
      }
    }
    else {
      xx <- carrier(cn[[i]], transform.x[i])
      if (!is.null(use.rows)) 
        xx <- xx[use.rows]
      xlims <- range(xx, na.rm = TRUE)
      if (rug) 
        xlims[1] <- xlims[1] - 0.07 * diff(xlims)
      oo <- order(xx)
      plot(xx[oo], tms[oo, i], type = "l", xlab = xlabs[i], ylab = ylabs[i], xlim = xlims, ylim = ylims, main = main[i], col = col.term, lwd = lwd.term, ...)
      if (se) 
        se.lines(xx[oo], iy = oo, i = i)
    }
    if (partial.resid) {
      if (!is.fac[i] && !is.null(smooth)) {
        smooth(xx, pres[, i], lty = lty.smth, cex = cex, pch = pch, col = col.res, col.smooth = col.smth, span = span.smth)
      }
      else points(xx, pres[, i], cex = cex, pch = pch, col = col.res)
    }
    if (rug) {
      n <- length(xx)
      lines(rep.int(jitter(xx), rep.int(3, n)), rep.int(ylims[1] + c(0, 0.05, NA) * diff(ylims), n))
      if (partial.resid) 
        lines(rep.int(xlims[1] + c(0, 0.05, NA) * diff(xlims), n), rep.int(pres[, i], rep.int(3, n)))
    }
  }
  invisible(n.tms)
}, function (model, data = NULL, envir = environment(formula(model)), partial.resid = FALSE, rug = FALSE, terms = NULL, se = FALSE, xlabs = NULL, ylabs = NULL, main = NULL, col.term = 2, lwd.term = 1.5, col.se = "orange", lty.se = 2, lwd.se = 1, col.res = "gray", cex = 1, pch = par("pch"), col.smth = "darkred", lty.smth = 2, span.smth = 2/3, ask = dev.interactive() && nb.fig < n.tms, use.factor.levels = TRUE, smooth = NULL, ylim = "common", plot = TRUE, transform.x = FALSE, ...) 
{
  which.terms <- terms
  terms <- if (is.null(terms)) 
    predict(model, type = "terms", se.fit = se)
  else predict(model, type = "terms", se.fit = se, terms = terms)
  n.tms <- ncol(tms <- as.matrix(if (se) 
    terms$fit
    else terms))
  transform.x <- rep_len(transform.x, n.tms)
  mf <- model.frame(model)
  if (is.null(data)) 
    data <- eval(model$call$data, envir)
  if (is.null(data)) 
    data <- mf
  use.rows <- if (NROW(tms) < NROW(data)) 
    match(rownames(tms), rownames(data))
  nmt <- colnames(tms)
  if (any(grepl(":", nmt, fixed = TRUE))) 
    warning("'model' appears to involve interactions: see the help page", domain = NA, immediate. = TRUE)
  cn <- str2expression(nmt)
  if (!is.null(smooth)) 
    smooth <- match.fun(smooth)
  if (is.null(ylabs)) 
    ylabs <- paste("Partial for", nmt)
  if (is.null(main)) 
    main <- ""
  else if (is.logical(main)) 
    main <- if (main) 
      deparse(model$call, 500)
  else ""
  else if (!is.character(main)) 
    stop("'main' must be TRUE, FALSE, NULL or character (vector).")
  main <- rep_len(main, n.tms)
  pf <- envir
  carrier <- function(term, transform) {
    if (length(term) > 1) {
      if (transform) 
        tms[, i]
      else carrier(term[[2]], transform)
    }
    else eval(term, data, enclos = pf)
  }
  carrier.name <- function(term) {
    if (length(term) > 1) 
      carrier.name(term[[2]])
    else as.character(term)
  }
  in.mf <- nmt %in% names(mf)
  is.fac <- sapply(nmt, function(i) i %in% names(mf) && is.factor(mf[, i]))
  if (!plot) {
    outlist <- vector("list", sum(in.mf))
    for (i in 1:n.tms) {
      if (!in.mf[i]) 
        next
      if (is.fac[i]) {
        xx <- mf[, nmt[i]]
        if (!is.null(use.rows)) 
          xx <- xx[use.rows]
        ww <- match(levels(xx), xx, nomatch = 0)
      }
      else {
        xx <- carrier(cn[[i]], transform.x[i])
        if (!is.null(use.rows)) 
          xx <- xx[use.rows]
        ww <- match(sort(unique(xx)), xx)
      }
      outlist[[i]] <- if (se) 
        data.frame(x = xx[ww], y = tms[ww, i], se = terms$se.fit[ww, i], row.names = NULL)
      else data.frame(x = xx[ww], y = tms[ww, i], row.names = NULL)
    }
    attr(outlist, "constant") <- attr(terms, "constant")
    if (se && is.null(attr(outlist, "constant"))) 
      attr(outlist, "constant") <- attr(terms$fit, "constant")
    names(outlist) <- sapply(cn, carrier.name)[in.mf]
    return(outlist)
  }
  if (!is.null(smooth)) 
    smooth <- match.fun(smooth)
  if (is.null(ylabs)) 
    ylabs <- paste("Partial for", nmt)
  if (is.null(main)) 
    main <- ""
  else if (is.logical(main)) 
    main <- if (main) 
      deparse(model$call, 500)
  else ""
  else if (!is.character(main)) 
    stop("'main' must be TRUE, FALSE, NULL or character (vector).")
  main <- rep_len(main, n.tms)
  if (is.null(xlabs)) {
    xlabs <- unlist(lapply(cn, carrier.name))
    if (any(transform.x)) 
      xlabs <- ifelse(transform.x, lapply(cn, deparse), xlabs)
  }
  if (partial.resid || !is.null(smooth)) {
    pres <- residuals(model, "partial")
    if (!is.null(which.terms)) 
      pres <- pres[, which.terms, drop = FALSE]
  }
  se.lines <- function(x, iy, i, ff = 2) {
    tt <- ff * terms$se.fit[iy, i]
    lines(x, tms[iy, i] + tt, lty = lty.se, lwd = lwd.se, col = col.se)
    lines(x, tms[iy, i] - tt, lty = lty.se, lwd = lwd.se, col = col.se)
  }
  nb.fig <- prod(par("mfcol"))
  if (ask) {
    oask <- devAskNewPage(TRUE)
    on.exit(devAskNewPage(oask))
  }
  ylims <- ylim
  if (identical(ylims, "common")) {
    ylims <- if (!se) 
      range(tms, na.rm = TRUE)
    else range(tms + 1.05 * 2 * terms$se.fit, tms - 1.05 * 2 * terms$se.fit, na.rm = TRUE)
    if (partial.resid) 
      ylims <- range(ylims, pres, na.rm = TRUE)
    if (rug) 
      ylims[1] <- ylims[1] - 0.07 * diff(ylims)
  }
  for (i in 1:n.tms) {
    if (identical(ylim, "free")) {
      ylims <- range(tms[, i], na.rm = TRUE)
      if (se) 
        ylims <- range(ylims, tms[, i] + 1.05 * 2 * terms$se.fit[, i], tms[, i] - 1.05 * 2 * terms$se.fit[, i], na.rm = TRUE)
      if (partial.resid) 
        ylims <- range(ylims, pres[, i], na.rm = TRUE)
      if (rug) 
        ylims[1] <- ylims[1] - 0.07 * diff(ylims)
    }
    if (!in.mf[i]) 
      next
    if (is.fac[i]) {
      ff <- mf[, nmt[i]]
      if (!is.null(model$na.action)) 
        ff <- naresid(model$na.action, ff)
      ll <- levels(ff)
      xlims <- range(seq_along(ll)) + c(-0.5, 0.5)
      xx <- as.numeric(ff)
      if (rug) {
        xlims[1] <- xlims[1] - 0.07 * diff(xlims)
        xlims[2] <- xlims[2] + 0.03 * diff(xlims)
      }
      plot(1, 0, type = "n", xlab = xlabs[i], ylab = ylabs[i], xlim = xlims, ylim = ylims, main = main[i], xaxt = "n", ...)
      if (use.factor.levels) 
        axis(1, at = seq_along(ll), labels = ll, ...)
      else axis(1)
      for (j in seq_along(ll)) {
        ww <- which(ff == ll[j])[c(1, 1)]
        jf <- j + c(-0.4, 0.4)
        lines(jf, tms[ww, i], col = col.term, lwd = lwd.term, ...)
        if (se) 
          se.lines(jf, iy = ww, i = i)
      }
    }
    else {
      xx <- carrier(cn[[i]], transform.x[i])
      if (!is.null(use.rows)) 
        xx <- xx[use.rows]
      xlims <- range(xx, na.rm = TRUE)
      if (rug) 
        xlims[1] <- xlims[1] - 0.07 * diff(xlims)
      oo <- order(xx)
      plot(xx[oo], tms[oo, i], type = "l", xlab = xlabs[i], ylab = ylabs[i], xlim = xlims, ylim = ylims, main = main[i], col = col.term, lwd = lwd.term, ...)
      if (se) 
        se.lines(xx[oo], iy = oo, i = i)
    }
    if (partial.resid) {
      if (!is.fac[i] && !is.null(smooth)) {
        smooth(xx, pres[, i], lty = lty.smth, cex = cex, pch = pch, col = col.res, col.smooth = col.smth, span = span.smth)
      }
      else points(xx, pres[, i], cex = cex, pch = pch, col = col.res)
    }
    if (rug) {
      n <- length(xx)
      lines(rep.int(jitter(xx), rep.int(3, n)), rep.int(ylims[1] + c(0, 0.05, NA) * diff(ylims), n))
      if (partial.resid) 
        lines(rep.int(xlims[1] + c(0, 0.05, NA) * diff(xlims), n), rep.int(pres[, i], rep.int(3, n)))
    }
  }
  invisible(n.tms)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
terms
list(`package:stats` = function (x, ...) 
  UseMethod("terms"), function (x, ...) 
    UseMethod("terms"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
terms.formula
list(`package:stats` = function (x, specials = NULL, abb = NULL, data = NULL, neg.out = TRUE, keep.order = FALSE, simplify = FALSE, ..., allowDotAsName = FALSE) 
{
  if (simplify) 
    fixFormulaObject <- function(object) {
      Terms <- terms(object)
      tmp <- attr(Terms, "term.labels")
      ind <- grep("|", tmp, fixed = TRUE)
      if (length(ind)) 
        tmp[ind] <- paste("(", tmp[ind], ")")
      if (length(ind <- attr(Terms, "offset"))) {
        tmp2 <- as.character(attr(Terms, "variables"))[-1]
        tmp <- c(tmp, tmp2[ind])
      }
      rhs <- if (length(tmp)) 
        paste(tmp, collapse = " + ")
      else "1"
      if (!attr(Terms, "intercept")) 
        rhs <- paste(rhs, "- 1")
      if (length(form <- formula(object)) > 2) {
        res <- formula(paste("lhs ~", rhs))
        res[[2]] <- form[[2]]
        res
      }
      else formula(paste("~", rhs))
    }
  if (!is.null(data) && !is.environment(data) && !is.data.frame(data)) 
    data <- as.data.frame(data, optional = TRUE)
  terms <- .External(C_termsform, x, specials, data, keep.order, allowDotAsName)
  if (simplify) {
    a <- attributes(terms)
    terms <- fixFormulaObject(terms)
    attributes(terms) <- a
  }
  environment(terms) <- environment(x)
  if (!inherits(terms, "formula")) 
    class(terms) <- c(oldClass(terms), "formula")
  terms
}, function (x, specials = NULL, abb = NULL, data = NULL, neg.out = TRUE, keep.order = FALSE, simplify = FALSE, ..., allowDotAsName = FALSE) 
{
  if (simplify) 
    fixFormulaObject <- function(object) {
      Terms <- terms(object)
      tmp <- attr(Terms, "term.labels")
      ind <- grep("|", tmp, fixed = TRUE)
      if (length(ind)) 
        tmp[ind] <- paste("(", tmp[ind], ")")
      if (length(ind <- attr(Terms, "offset"))) {
        tmp2 <- as.character(attr(Terms, "variables"))[-1]
        tmp <- c(tmp, tmp2[ind])
      }
      rhs <- if (length(tmp)) 
        paste(tmp, collapse = " + ")
      else "1"
      if (!attr(Terms, "intercept")) 
        rhs <- paste(rhs, "- 1")
      if (length(form <- formula(object)) > 2) {
        res <- formula(paste("lhs ~", rhs))
        res[[2]] <- form[[2]]
        res
      }
      else formula(paste("~", rhs))
    }
  if (!is.null(data) && !is.environment(data) && !is.data.frame(data)) 
    data <- as.data.frame(data, optional = TRUE)
  terms <- .External(C_termsform, x, specials, data, keep.order, allowDotAsName)
  if (simplify) {
    a <- attributes(terms)
    terms <- fixFormulaObject(terms)
    attributes(terms) <- a
  }
  environment(terms) <- environment(x)
  if (!inherits(terms, "formula")) 
    class(terms) <- c(oldClass(terms), "formula")
  terms
}, function (x, specials = NULL, abb = NULL, data = NULL, neg.out = TRUE, keep.order = FALSE, simplify = FALSE, ..., allowDotAsName = FALSE) 
{
  if (simplify) 
    fixFormulaObject <- function(object) {
      Terms <- terms(object)
      tmp <- attr(Terms, "term.labels")
      ind <- grep("|", tmp, fixed = TRUE)
      if (length(ind)) 
        tmp[ind] <- paste("(", tmp[ind], ")")
      if (length(ind <- attr(Terms, "offset"))) {
        tmp2 <- as.character(attr(Terms, "variables"))[-1]
        tmp <- c(tmp, tmp2[ind])
      }
      rhs <- if (length(tmp)) 
        paste(tmp, collapse = " + ")
      else "1"
      if (!attr(Terms, "intercept")) 
        rhs <- paste(rhs, "- 1")
      if (length(form <- formula(object)) > 2) {
        res <- formula(paste("lhs ~", rhs))
        res[[2]] <- form[[2]]
        res
      }
      else formula(paste("~", rhs))
    }
  if (!is.null(data) && !is.environment(data) && !is.data.frame(data)) 
    data <- as.data.frame(data, optional = TRUE)
  terms <- .External(C_termsform, x, specials, data, keep.order, allowDotAsName)
  if (simplify) {
    a <- attributes(terms)
    terms <- fixFormulaObject(terms)
    attributes(terms) <- a
  }
  environment(terms) <- environment(x)
  if (!inherits(terms, "formula")) 
    class(terms) <- c(oldClass(terms), "formula")
  terms
})
c("package:stats", "registered S3 method for terms from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
time
list(`package:stats` = function (x, ...) 
  UseMethod("time"), function (x, ...) 
    UseMethod("time"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
toeplitz
list(`package:stats` = function (x) 
{
  if (!is.vector(x)) 
    stop("'x' is not a vector")
  n <- length(x)
  A <- matrix(raw(), n, n)
  matrix(x[abs(col(A) - row(A)) + 1], n, n)
}, new("standardGeneric", .Data = function (x, ...) 
  standardGeneric("toeplitz"), generic = "toeplitz", package = "stats", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
    stats::toeplitz(x), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "toeplitz"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
      stats::toeplitz(x), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "toeplitz"))(x, ...)), function (x) 
      {
        if (!is.vector(x)) 
          stop("'x' is not a vector")
        n <- length(x)
        A <- matrix(raw(), n, n)
        matrix(x[abs(col(A) - row(A)) + 1], n, n)
      })
c("package:stats", "namespace:Matrix", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
ts
list(`package:stats` = function (data = NA, start = 1, end = numeric(), frequency = 1, deltat = 1, ts.eps = getOption("ts.eps"), class = if (nseries > 1) c("mts", "ts", "matrix") else "ts", names = if (!is.null(dimnames(data))) colnames(data) else paste("Series", seq(nseries))) 
{
  if (is.data.frame(data)) 
    data <- data.matrix(data)
  if (is.matrix(data)) {
    nseries <- ncol(data)
    ndata <- nrow(data)
    dimnames(data) <- list(NULL, names)
  }
  else {
    nseries <- 1
    ndata <- length(data)
  }
  if (ndata == 0) 
    stop("'ts' object must have one or more observations")
  if (missing(frequency)) 
    frequency <- 1/deltat
  else if (missing(deltat)) 
    deltat <- 1/frequency
  if (frequency > 1 && 0 < (d <- abs(frequency - round(frequency))) && d < ts.eps) 
    frequency <- round(frequency)
  if (!missing(start)) 
    start <- as.numeric(start)
  if (length(start) > 1) {
    start <- start[1] + (start[2] - 1)/frequency
  }
  if (!missing(end)) 
    end <- as.numeric(end)
  if (length(end) > 1) {
    end <- end[1] + (end[2] - 1)/frequency
  }
  if (missing(end)) 
    end <- start + (ndata - 1)/frequency
  else if (missing(start)) 
    start <- end - (ndata - 1)/frequency
  if (start > end) 
    stop("'start' cannot be after 'end'")
  cycles <- as.numeric((end - start) * frequency)
  if (abs(round(cycles) - cycles) > ts.eps * max(cycles, 1)) 
    stop("'end' must be a whole number of cycles after 'start'")
  nobs <- floor(cycles + 1.01)
  if (nobs != ndata) 
    data <- if (NCOL(data) == 1) {
      if (ndata < nobs) 
        rep_len(data, nobs)
      else if (ndata > nobs) 
        data[1:nobs]
    }
  else {
    if (ndata < nobs) 
      data[rep_len(1:ndata, nobs), ]
    else if (ndata > nobs) 
      data[1:nobs, ]
  }
  attr(data, "tsp") <- c(start, end, frequency)
  if (!is.null(class) && class[[1]] != "none") 
    attr(data, "class") <- class
  data
}, function (data = NA, start = 1, end = numeric(), frequency = 1, deltat = 1, ts.eps = getOption("ts.eps"), class = if (nseries > 1) c("mts", "ts", "matrix") else "ts", names = if (!is.null(dimnames(data))) colnames(data) else paste("Series", seq(nseries))) 
{
  if (is.data.frame(data)) 
    data <- data.matrix(data)
  if (is.matrix(data)) {
    nseries <- ncol(data)
    ndata <- nrow(data)
    dimnames(data) <- list(NULL, names)
  }
  else {
    nseries <- 1
    ndata <- length(data)
  }
  if (ndata == 0) 
    stop("'ts' object must have one or more observations")
  if (missing(frequency)) 
    frequency <- 1/deltat
  else if (missing(deltat)) 
    deltat <- 1/frequency
  if (frequency > 1 && 0 < (d <- abs(frequency - round(frequency))) && d < ts.eps) 
    frequency <- round(frequency)
  if (!missing(start)) 
    start <- as.numeric(start)
  if (length(start) > 1) {
    start <- start[1] + (start[2] - 1)/frequency
  }
  if (!missing(end)) 
    end <- as.numeric(end)
  if (length(end) > 1) {
    end <- end[1] + (end[2] - 1)/frequency
  }
  if (missing(end)) 
    end <- start + (ndata - 1)/frequency
  else if (missing(start)) 
    start <- end - (ndata - 1)/frequency
  if (start > end) 
    stop("'start' cannot be after 'end'")
  cycles <- as.numeric((end - start) * frequency)
  if (abs(round(cycles) - cycles) > ts.eps * max(cycles, 1)) 
    stop("'end' must be a whole number of cycles after 'start'")
  nobs <- floor(cycles + 1.01)
  if (nobs != ndata) 
    data <- if (NCOL(data) == 1) {
      if (ndata < nobs) 
        rep_len(data, nobs)
      else if (ndata > nobs) 
        data[1:nobs]
    }
  else {
    if (ndata < nobs) 
      data[rep_len(1:ndata, nobs), ]
    else if (ndata > nobs) 
      data[1:nobs, ]
  }
  attr(data, "tsp") <- c(start, end, frequency)
  if (!is.null(class) && class[[1]] != "none") 
    attr(data, "class") <- class
  data
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ts.intersect
list(`package:stats` = function (..., dframe = FALSE) 
  .cbind.ts(list(...), .makeNamesTs(...), dframe = dframe, union = FALSE), function (..., dframe = FALSE) 
    .cbind.ts(list(...), .makeNamesTs(...), dframe = dframe, union = FALSE))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ts.plot
list(`package:stats` = function (..., gpars = list()) 
{
  dots <- list(...)
  pars <- c("xlab", "ylab", "xlim", "ylim", "col", "lty", "lwd", "type", "main", "sub", "log")
  m <- names(dots) %in% pars
  if (length(m)) {
    gpars <- c(gpars, dots[m])
    dots <- dots[!m]
  }
  sers <- do.call("ts.union", dots)
  if (is.null(gpars$ylab)) 
    gpars$ylab <- if (NCOL(sers) > 1) 
      ""
  else deparse1(substitute(...))
  do.call("plot.ts", c(list(sers, plot.type = "single"), gpars))
}, function (..., gpars = list()) 
{
  dots <- list(...)
  pars <- c("xlab", "ylab", "xlim", "ylim", "col", "lty", "lwd", "type", "main", "sub", "log")
  m <- names(dots) %in% pars
  if (length(m)) {
    gpars <- c(gpars, dots[m])
    dots <- dots[!m]
  }
  sers <- do.call("ts.union", dots)
  if (is.null(gpars$ylab)) 
    gpars$ylab <- if (NCOL(sers) > 1) 
      ""
  else deparse1(substitute(...))
  do.call("plot.ts", c(list(sers, plot.type = "single"), gpars))
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
ts.union
list(`package:stats` = function (..., dframe = FALSE) 
  .cbind.ts(list(...), .makeNamesTs(...), dframe = dframe, union = TRUE), function (..., dframe = FALSE) 
    .cbind.ts(list(...), .makeNamesTs(...), dframe = dframe, union = TRUE))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
tsdiag
list(`package:stats` = function (object, gof.lag, ...) 
  UseMethod("tsdiag"), function (object, gof.lag, ...) 
    UseMethod("tsdiag"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
tsp
list(`package:stats` = function (x) 
  attr(x, "tsp"), function (x) 
    attr(x, "tsp"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
tsp<-
  list(`package:stats` = function (x, value) 
  {
    cl <- oldClass(x)
    attr(x, "tsp") <- value
    if (is.null(value)) {
      if (inherits(x, "ts")) 
        cl <- cl["ts" != cl]
      if (inherits(x, "mts")) 
        cl <- cl["mts" != cl]
      class(x) <- cl
    }
    x
  }, function (x, value) 
  {
    cl <- oldClass(x)
    attr(x, "tsp") <- value
    if (is.null(value)) {
      if (inherits(x, "ts")) 
        cl <- cl["ts" != cl]
      if (inherits(x, "mts")) 
        cl <- cl["mts" != cl]
      class(x) <- cl
    }
    x
  })
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
tsSmooth
list(`package:stats` = function (object, ...) 
  UseMethod("tsSmooth"), function (object, ...) 
    UseMethod("tsSmooth"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
TukeyHSD
list(`package:stats` = function (x, which, ordered = FALSE, conf.level = 0.95, ...) 
  UseMethod("TukeyHSD"), function (x, which, ordered = FALSE, conf.level = 0.95, ...) 
    UseMethod("TukeyHSD"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
uniroot
list(`package:stats` = function (f, interval, ..., lower = min(interval), upper = max(interval), f.lower = f(lower, ...), f.upper = f(upper, ...), extendInt = c("no", "yes", "downX", "upX"), check.conv = FALSE, tol = .Machine$double.eps^0.25, maxiter = 1000, trace = 0) 
{
  if (!missing(interval) && length(interval) != 2) 
    stop("'interval' must be a vector of length 2")
  if (!is.numeric(lower) || !is.numeric(upper) || lower >= upper) 
    stop("lower < upper  is not fulfilled")
  if (is.na(f.lower)) 
    stop("f.lower = f(lower) is NA")
  if (is.na(f.upper)) 
    stop("f.upper = f(upper) is NA")
  Sig <- switch(match.arg(extendInt), yes = NULL, downX = -1, no = 0, upX = 1, stop("invalid 'extendInt'; please report"))
  truncate <- function(x) pmax.int(pmin(x, .Machine$double.xmax), -.Machine$double.xmax)
  f.low. <- truncate(f.lower)
  f.upp. <- truncate(f.upper)
  doX <- (is.null(Sig) && f.low. * f.upp. > 0 || is.numeric(Sig) && (Sig * f.low. > 0 || Sig * f.upp. < 0))
  if (doX) {
    if (trace) 
      cat(sprintf("search in [%g,%g]%s", lower, upper, if (trace >= 2) 
        "\n"
        else " ... "))
    Delta <- function(u) 0.01 * pmax(1e-04, abs(u))
    it <- 0
    if (is.null(Sig)) {
      delta <- Delta(c(lower, upper))
      while (isTRUE(f.lower * f.upper > 0) && any(iF <- is.finite(c(lower, upper)))) {
        if ((it <- it + 1) > maxiter) 
          stop(gettextf("no sign change found in %d iterations", it - 1), domain = NA)
        if (iF[1]) {
          ol <- lower
          of <- f.lower
          if (is.na(f.lower <- f(lower <- lower - delta[1], ...))) {
            lower <- ol
            f.lower <- of
            delta[1] <- delta[1]/4
          }
        }
        if (iF[2]) {
          ol <- upper
          of <- f.upper
          if (is.na(f.upper <- f(upper <- upper + delta[2], ...))) {
            upper <- ol
            f.upper <- of
            delta[2] <- delta[2]/4
          }
        }
        if (trace >= 2) 
          cat(sprintf(" .. modified lower,upper: (%15g,%15g)\n", lower, upper))
        delta <- 2 * delta
      }
    }
    else {
      delta <- Delta(lower)
      while (isTRUE(Sig * f.lower > 0)) {
        if ((it <- it + 1) > maxiter) 
          stop(gettextf("no sign change found in %d iterations", it - 1), domain = NA)
        f.lower <- f(lower <- lower - delta, ...)
        if (trace >= 2) 
          cat(sprintf(" .. modified lower: %g\n", lower))
        delta <- 2 * delta
      }
      delta <- Delta(upper)
      while (isTRUE(Sig * f.upper < 0)) {
        if ((it <- it + 1) > maxiter) 
          stop(gettextf("no sign change found in %d iterations", it - 1), domain = NA)
        f.upper <- f(upper <- upper + delta, ...)
        if (trace >= 2) 
          cat(sprintf(" .. modified upper: %g\n", upper))
        delta <- 2 * delta
      }
    }
    if (trace && trace < 2) 
      cat(sprintf("extended to [%g, %g] in %d steps\n", lower, upper, it))
  }
  if (!isTRUE(as.vector(sign(f.lower) * sign(f.upper) <= 0))) 
    stop(if (doX) 
      "did not succeed extending the interval endpoints for f(lower) * f(upper) <= 0"
      else "f() values at end points not of opposite sign")
  if (check.conv) {
    val <- tryCatch(.External2(C_zeroin2, function(arg) f(arg, ...), lower, upper, f.lower, f.upper, tol, as.integer(maxiter)), warning = function(w) w)
    if (inherits(val, "warning")) 
      stop("convergence problem in zero finding: ", conditionMessage(val))
  }
  else {
    val <- .External2(C_zeroin2, function(arg) f(arg, ...), lower, upper, f.lower, f.upper, tol, as.integer(maxiter))
  }
  iter <- as.integer(val[2])
  if (iter < 0) {
    (if (check.conv) 
      stop
     else warning)(sprintf(ngettext(maxiter, "_NOT_ converged in %d iteration", "_NOT_ converged in %d iterations"), maxiter), domain = NA)
    iter <- maxiter
  }
  if (doX) 
    iter <- iter + it
  else it <- NA
  list(root = val[1], f.root = f(val[1], ...), iter = iter, init.it = it, estim.prec = val[3])
}, function (f, interval, ..., lower = min(interval), upper = max(interval), f.lower = f(lower, ...), f.upper = f(upper, ...), extendInt = c("no", "yes", "downX", "upX"), check.conv = FALSE, tol = .Machine$double.eps^0.25, maxiter = 1000, trace = 0) 
{
  if (!missing(interval) && length(interval) != 2) 
    stop("'interval' must be a vector of length 2")
  if (!is.numeric(lower) || !is.numeric(upper) || lower >= upper) 
    stop("lower < upper  is not fulfilled")
  if (is.na(f.lower)) 
    stop("f.lower = f(lower) is NA")
  if (is.na(f.upper)) 
    stop("f.upper = f(upper) is NA")
  Sig <- switch(match.arg(extendInt), yes = NULL, downX = -1, no = 0, upX = 1, stop("invalid 'extendInt'; please report"))
  truncate <- function(x) pmax.int(pmin(x, .Machine$double.xmax), -.Machine$double.xmax)
  f.low. <- truncate(f.lower)
  f.upp. <- truncate(f.upper)
  doX <- (is.null(Sig) && f.low. * f.upp. > 0 || is.numeric(Sig) && (Sig * f.low. > 0 || Sig * f.upp. < 0))
  if (doX) {
    if (trace) 
      cat(sprintf("search in [%g,%g]%s", lower, upper, if (trace >= 2) 
        "\n"
        else " ... "))
    Delta <- function(u) 0.01 * pmax(1e-04, abs(u))
    it <- 0
    if (is.null(Sig)) {
      delta <- Delta(c(lower, upper))
      while (isTRUE(f.lower * f.upper > 0) && any(iF <- is.finite(c(lower, upper)))) {
        if ((it <- it + 1) > maxiter) 
          stop(gettextf("no sign change found in %d iterations", it - 1), domain = NA)
        if (iF[1]) {
          ol <- lower
          of <- f.lower
          if (is.na(f.lower <- f(lower <- lower - delta[1], ...))) {
            lower <- ol
            f.lower <- of
            delta[1] <- delta[1]/4
          }
        }
        if (iF[2]) {
          ol <- upper
          of <- f.upper
          if (is.na(f.upper <- f(upper <- upper + delta[2], ...))) {
            upper <- ol
            f.upper <- of
            delta[2] <- delta[2]/4
          }
        }
        if (trace >= 2) 
          cat(sprintf(" .. modified lower,upper: (%15g,%15g)\n", lower, upper))
        delta <- 2 * delta
      }
    }
    else {
      delta <- Delta(lower)
      while (isTRUE(Sig * f.lower > 0)) {
        if ((it <- it + 1) > maxiter) 
          stop(gettextf("no sign change found in %d iterations", it - 1), domain = NA)
        f.lower <- f(lower <- lower - delta, ...)
        if (trace >= 2) 
          cat(sprintf(" .. modified lower: %g\n", lower))
        delta <- 2 * delta
      }
      delta <- Delta(upper)
      while (isTRUE(Sig * f.upper < 0)) {
        if ((it <- it + 1) > maxiter) 
          stop(gettextf("no sign change found in %d iterations", it - 1), domain = NA)
        f.upper <- f(upper <- upper + delta, ...)
        if (trace >= 2) 
          cat(sprintf(" .. modified upper: %g\n", upper))
        delta <- 2 * delta
      }
    }
    if (trace && trace < 2) 
      cat(sprintf("extended to [%g, %g] in %d steps\n", lower, upper, it))
  }
  if (!isTRUE(as.vector(sign(f.lower) * sign(f.upper) <= 0))) 
    stop(if (doX) 
      "did not succeed extending the interval endpoints for f(lower) * f(upper) <= 0"
      else "f() values at end points not of opposite sign")
  if (check.conv) {
    val <- tryCatch(.External2(C_zeroin2, function(arg) f(arg, ...), lower, upper, f.lower, f.upper, tol, as.integer(maxiter)), warning = function(w) w)
    if (inherits(val, "warning")) 
      stop("convergence problem in zero finding: ", conditionMessage(val))
  }
  else {
    val <- .External2(C_zeroin2, function(arg) f(arg, ...), lower, upper, f.lower, f.upper, tol, as.integer(maxiter))
  }
  iter <- as.integer(val[2])
  if (iter < 0) {
    (if (check.conv) 
      stop
     else warning)(sprintf(ngettext(maxiter, "_NOT_ converged in %d iteration", "_NOT_ converged in %d iterations"), maxiter), domain = NA)
    iter <- maxiter
  }
  if (doX) 
    iter <- iter + it
  else it <- NA
  list(root = val[1], f.root = f(val[1], ...), iter = iter, init.it = it, estim.prec = val[3])
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
update
list(`package:stats` = function (object, ...) 
  UseMethod("update"), new("standardGeneric", .Data = function (object, ...) 
    standardGeneric("update"), generic = "update", package = "stats", group = list(), valueClass = character(0), signature = "object", default = new("derivedDefaultMethod", .Data = function (object, ...) 
      UseMethod("update"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "update"), skeleton = (new("derivedDefaultMethod", .Data = function (object, ...) 
        UseMethod("update"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "update"))(object, ...)), function (original, new) 
        {
          if (length(new)) {
            assert_named(original)
            assert_named(new)
            original[names(new)] <- new
          }
          original
        }, function (object, ...) 
          UseMethod("update"))
c("package:stats", "namespace:Matrix", "namespace:webdriver", "namespace:stats")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE)
update.default
list(`package:stats` = function (object, formula., ..., evaluate = TRUE) 
{
  if (is.null(call <- getCall(object))) 
    stop("need an object with call component")
  extras <- match.call(expand.dots = FALSE)$...
  if (!missing(formula.)) 
    call$formula <- update(formula(object), formula.)
  if (length(extras)) {
    existing <- !is.na(match(names(extras), names(call)))
    for (a in names(extras)[existing]) call[[a]] <- extras[[a]]
    if (any(!existing)) {
      call <- c(as.list(call), extras[!existing])
      call <- as.call(call)
    }
  }
  if (evaluate) 
    eval(call, parent.frame())
  else call
}, function (object, formula., ..., evaluate = TRUE) 
{
  if (is.null(call <- getCall(object))) 
    stop("need an object with call component")
  extras <- match.call(expand.dots = FALSE)$...
  if (!missing(formula.)) 
    call$formula <- update(formula(object), formula.)
  if (length(extras)) {
    existing <- !is.na(match(names(extras), names(call)))
    for (a in names(extras)[existing]) call[[a]] <- extras[[a]]
    if (any(!existing)) {
      call <- c(as.list(call), extras[!existing])
      call <- as.call(call)
    }
  }
  if (evaluate) 
    eval(call, parent.frame())
  else call
}, function (object, formula., ..., evaluate = TRUE) 
{
  if (is.null(call <- getCall(object))) 
    stop("need an object with call component")
  extras <- match.call(expand.dots = FALSE)$...
  if (!missing(formula.)) 
    call$formula <- update(formula(object), formula.)
  if (length(extras)) {
    existing <- !is.na(match(names(extras), names(call)))
    for (a in names(extras)[existing]) call[[a]] <- extras[[a]]
    if (any(!existing)) {
      call <- c(as.list(call), extras[!existing])
      call <- as.call(call)
    }
  }
  if (evaluate) 
    eval(call, parent.frame())
  else call
})
c("package:stats", "registered S3 method for update from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
update.formula
list(`package:stats` = function (old, new, ...) 
{
  tmp <- .Call(C_updateform, as.formula(old), as.formula(new))
  formula(terms.formula(tmp, simplify = TRUE))
}, function (old, new, ...) 
{
  tmp <- .Call(C_updateform, as.formula(old), as.formula(new))
  formula(terms.formula(tmp, simplify = TRUE))
}, function (old, new, ...) 
{
  tmp <- .Call(C_updateform, as.formula(old), as.formula(new))
  formula(terms.formula(tmp, simplify = TRUE))
})
c("package:stats", "registered S3 method for update from namespace stats", "namespace:stats")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
var
list(`package:stats` = function (x, y = NULL, na.rm = FALSE, use) 
{
  if (missing(use)) 
    use <- if (na.rm) 
      "na.or.complete"
  else "everything"
  na.method <- pmatch(use, c("all.obs", "complete.obs", "pairwise.complete.obs", "everything", "na.or.complete"))
  if (is.na(na.method)) 
    stop("invalid 'use' argument")
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  else stopifnot(is.atomic(x))
  if (is.data.frame(y)) 
    y <- as.matrix(y)
  else stopifnot(is.atomic(y))
  .Call(C_cov, x, y, na.method, FALSE)
}, function (x, y = NULL, na.rm = FALSE, use) 
{
  if (missing(use)) 
    use <- if (na.rm) 
      "na.or.complete"
  else "everything"
  na.method <- pmatch(use, c("all.obs", "complete.obs", "pairwise.complete.obs", "everything", "na.or.complete"))
  if (is.na(na.method)) 
    stop("invalid 'use' argument")
  if (is.data.frame(x)) 
    x <- as.matrix(x)
  else stopifnot(is.atomic(x))
  if (is.data.frame(y)) 
    y <- as.matrix(y)
  else stopifnot(is.atomic(y))
  .Call(C_cov, x, y, na.method, FALSE)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
var.test
list(`package:stats` = function (x, ...) 
  UseMethod("var.test"), function (x, ...) 
    UseMethod("var.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
variable.names
list(`package:stats` = function (object, ...) 
  UseMethod("variable.names"), function (object, ...) 
    UseMethod("variable.names"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
varimax
list(`package:stats` = function (x, normalize = TRUE, eps = 1e-05) 
{
  nc <- ncol(x)
  if (nc < 2) 
    return(x)
  if (normalize) {
    sc <- sqrt(drop(apply(x, 1, function(x) sum(x^2))))
    x <- x/sc
  }
  p <- nrow(x)
  TT <- diag(nc)
  d <- 0
  for (i in 1:1000) {
    z <- x %*% TT
    B <- t(x) %*% (z^3 - z %*% diag(drop(rep(1, p) %*% z^2))/p)
    sB <- La.svd(B)
    TT <- sB$u %*% sB$vt
    dpast <- d
    d <- sum(sB$d)
    if (d < dpast * (1 + eps)) 
      break
  }
  z <- x %*% TT
  if (normalize) 
    z <- z * sc
  dimnames(z) <- dimnames(x)
  class(z) <- "loadings"
  list(loadings = z, rotmat = TT)
}, function (x, normalize = TRUE, eps = 1e-05) 
{
  nc <- ncol(x)
  if (nc < 2) 
    return(x)
  if (normalize) {
    sc <- sqrt(drop(apply(x, 1, function(x) sum(x^2))))
    x <- x/sc
  }
  p <- nrow(x)
  TT <- diag(nc)
  d <- 0
  for (i in 1:1000) {
    z <- x %*% TT
    B <- t(x) %*% (z^3 - z %*% diag(drop(rep(1, p) %*% z^2))/p)
    sB <- La.svd(B)
    TT <- sB$u %*% sB$vt
    dpast <- d
    d <- sum(sB$d)
    if (d < dpast * (1 + eps)) 
      break
  }
  z <- x %*% TT
  if (normalize) 
    z <- z * sc
  dimnames(z) <- dimnames(x)
  class(z) <- "loadings"
  list(loadings = z, rotmat = TT)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
vcov
list(`package:stats` = function (object, ...) 
  UseMethod("vcov"), function (object, ...) 
    UseMethod("vcov"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
weighted.mean
list(`package:stats` = function (x, w, ...) 
  UseMethod("weighted.mean"), function (x, w, ...) 
    UseMethod("weighted.mean"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
weighted.residuals
list(`package:stats` = function (obj, drop0 = TRUE) 
{
  w <- weights(obj)
  r <- residuals(obj, type = "deviance")
  if (drop0 && !is.null(w)) {
    if (is.matrix(r)) 
      r[w != 0, , drop = FALSE]
    else r[w != 0]
  }
  else r
}, function (obj, drop0 = TRUE) 
{
  w <- weights(obj)
  r <- residuals(obj, type = "deviance")
  if (drop0 && !is.null(w)) {
    if (is.matrix(r)) 
      r[w != 0, , drop = FALSE]
    else r[w != 0]
  }
  else r
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
weights
list(`package:stats` = function (object, ...) 
  UseMethod("weights"), function (object, ...) 
    UseMethod("weights"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
wilcox.test
list(`package:stats` = function (x, ...) 
  UseMethod("wilcox.test"), function (x, ...) 
    UseMethod("wilcox.test"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
window
list(`package:stats` = function (x, ...) 
  UseMethod("window"), function (x, ...) 
    UseMethod("window"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
window<-
  list(`package:stats` = function (x, ..., value) 
    UseMethod("window<-"), function (x, ..., value) 
      UseMethod("window<-"))
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
write.ftable
list(`package:stats` = function (x, file = "", quote = TRUE, append = FALSE, digits = getOption("digits"), sep = " ", ...) 
{
  r <- format.ftable(x, quote = quote, digits = digits, ...)
  cat(t(r), file = file, append = append, sep = c(rep(sep, ncol(r) - 1), "\n"))
  invisible(x)
}, function (x, file = "", quote = TRUE, append = FALSE, digits = getOption("digits"), sep = " ", ...) 
{
  r <- format.ftable(x, quote = quote, digits = digits, ...)
  cat(t(r), file = file, append = append, sep = c(rep(sep, ncol(r) - 1), "\n"))
  invisible(x)
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)
xtabs
list(`package:stats` = function (formula = ~., data = parent.frame(), subset, sparse = FALSE, na.action, addNA = FALSE, exclude = if (!addNA) c(NA, NaN), drop.unused.levels = FALSE) 
{
  if (missing(formula) && missing(data)) 
    stop("must supply either 'formula' or 'data'")
  if (!missing(formula)) {
    formula <- as.formula(formula)
    if (!inherits(formula, "formula")) 
      stop("'formula' missing or incorrect")
  }
  if (any(attr(terms(formula, data = data), "order") > 1)) 
    stop("interactions are not allowed")
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$... <- m$exclude <- m$drop.unused.levels <- m$sparse <- m$addNA <- NULL
  if (addNA && missing(na.action)) 
    m$na.action <- quote(na.pass)
  m[[1]] <- quote(stats::model.frame)
  mf <- eval(m, parent.frame())
  if (length(formula) == 2) {
    by <- mf
    y <- NULL
  }
  else {
    i <- attr(attr(mf, "terms"), "response")
    by <- mf[-i]
    y <- mf[[i]]
  }
  has.exclude <- !missing(exclude)
  by <- lapply(by, function(u) {
    if (!is.factor(u)) 
      u <- factor(u, exclude = exclude)
    else if (has.exclude) 
      u <- factor(as.character(u), levels = setdiff(levels(u), exclude), exclude = NULL)
    if (addNA) 
      u <- addNA(u, ifany = TRUE)
    u[, drop = drop.unused.levels]
  })
  naAct <- m$na.action %||% getOption("na.action", default = quote(na.omit))
  na.rm <- identical(naAct, quote(na.omit)) || identical(naAct, na.omit) || identical(naAct, "na.omit")
  if (!sparse) {
    x <- if (is.null(y)) 
      table(by, dnn = names(by))
    else if (NCOL(y) == 1) 
      tapply(y, by, sum, na.rm = na.rm, default = 0)
    else {
      z <- lapply(as.data.frame(y), tapply, by, sum, na.rm = na.rm, default = 0)
      array(unlist(z), dim = c(dim(z[[1]]), length(z)), dimnames = c(dimnames(z[[1]]), list(names(z))))
    }
    class(x) <- c("xtabs", "table")
    attr(x, "call") <- match.call()
    x
  }
  else {
    if (length(by) != 2) 
      stop(gettextf("%s applies only to two-way tables", "xtabs(*, sparse=TRUE)"), domain = NA)
    if (is.null(tryCatch(loadNamespace("Matrix"), error = function(e) NULL))) 
      stop(gettextf("%s needs package 'Matrix' correctly installed", "xtabs(*, sparse=TRUE)"), domain = NA)
    if (length(i.ex <- unique(unlist(lapply(by, function(f) which(is.na(f))))))) {
      by <- lapply(by, `[`, -i.ex)
      if (!is.null(y)) 
        y <- y[-i.ex]
    }
    if (na.rm && !is.null(y) && any(isN <- is.na(y))) {
      ok <- !isN
      by <- lapply(by, `[`, ok)
      y <- y[ok]
    }
    rows <- by[[1]]
    cols <- by[[2]]
    dnms <- lapply(by, levels)
    x <- if (is.null(y)) 
      rep.int(1, length(rows))
    else as.double(y)
    methods::as(methods::new("dgTMatrix", x = x, Dimnames = dnms, i = as.integer(rows) - 1, j = as.integer(cols) - 1, Dim = lengths(dnms, use.names = FALSE)), "CsparseMatrix")
  }
}, function (formula = ~., data = parent.frame(), subset, sparse = FALSE, na.action, addNA = FALSE, exclude = if (!addNA) c(NA, NaN), drop.unused.levels = FALSE) 
{
  if (missing(formula) && missing(data)) 
    stop("must supply either 'formula' or 'data'")
  if (!missing(formula)) {
    formula <- as.formula(formula)
    if (!inherits(formula, "formula")) 
      stop("'formula' missing or incorrect")
  }
  if (any(attr(terms(formula, data = data), "order") > 1)) 
    stop("interactions are not allowed")
  m <- match.call(expand.dots = FALSE)
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$... <- m$exclude <- m$drop.unused.levels <- m$sparse <- m$addNA <- NULL
  if (addNA && missing(na.action)) 
    m$na.action <- quote(na.pass)
  m[[1]] <- quote(stats::model.frame)
  mf <- eval(m, parent.frame())
  if (length(formula) == 2) {
    by <- mf
    y <- NULL
  }
  else {
    i <- attr(attr(mf, "terms"), "response")
    by <- mf[-i]
    y <- mf[[i]]
  }
  has.exclude <- !missing(exclude)
  by <- lapply(by, function(u) {
    if (!is.factor(u)) 
      u <- factor(u, exclude = exclude)
    else if (has.exclude) 
      u <- factor(as.character(u), levels = setdiff(levels(u), exclude), exclude = NULL)
    if (addNA) 
      u <- addNA(u, ifany = TRUE)
    u[, drop = drop.unused.levels]
  })
  naAct <- m$na.action %||% getOption("na.action", default = quote(na.omit))
  na.rm <- identical(naAct, quote(na.omit)) || identical(naAct, na.omit) || identical(naAct, "na.omit")
  if (!sparse) {
    x <- if (is.null(y)) 
      table(by, dnn = names(by))
    else if (NCOL(y) == 1) 
      tapply(y, by, sum, na.rm = na.rm, default = 0)
    else {
      z <- lapply(as.data.frame(y), tapply, by, sum, na.rm = na.rm, default = 0)
      array(unlist(z), dim = c(dim(z[[1]]), length(z)), dimnames = c(dimnames(z[[1]]), list(names(z))))
    }
    class(x) <- c("xtabs", "table")
    attr(x, "call") <- match.call()
    x
  }
  else {
    if (length(by) != 2) 
      stop(gettextf("%s applies only to two-way tables", "xtabs(*, sparse=TRUE)"), domain = NA)
    if (is.null(tryCatch(loadNamespace("Matrix"), error = function(e) NULL))) 
      stop(gettextf("%s needs package 'Matrix' correctly installed", "xtabs(*, sparse=TRUE)"), domain = NA)
    if (length(i.ex <- unique(unlist(lapply(by, function(f) which(is.na(f))))))) {
      by <- lapply(by, `[`, -i.ex)
      if (!is.null(y)) 
        y <- y[-i.ex]
    }
    if (na.rm && !is.null(y) && any(isN <- is.na(y))) {
      ok <- !isN
      by <- lapply(by, `[`, ok)
      y <- y[ok]
    }
    rows <- by[[1]]
    cols <- by[[2]]
    dnms <- lapply(by, levels)
    x <- if (is.null(y)) 
      rep.int(1, length(rows))
    else as.double(y)
    methods::as(methods::new("dgTMatrix", x = x, Dimnames = dnms, i = as.integer(rows) - 1, j = as.integer(cols) - 1, Dim = lengths(dnms, use.names = FALSE)), "CsparseMatrix")
  }
})
c("package:stats", "namespace:stats")
c(TRUE, FALSE)
c(FALSE, TRUE)



######################################################################################################
library(stringr)
%>%
  list(`package:stringr` = function (lhs, rhs) 
  {
    lhs <- substitute(lhs)
    rhs <- substitute(rhs)
    kind <- 1
    env <- parent.frame()
    lazy <- TRUE
    .External2(magrittr_pipe)
  }, `package:purrr` = function (lhs, rhs) 
  {
    lhs <- substitute(lhs)
    rhs <- substitute(rhs)
    kind <- 1
    env <- parent.frame()
    lazy <- TRUE
    .External2(magrittr_pipe)
  }, `package:multicolor` = function (lhs, rhs) 
  {
    lhs <- substitute(lhs)
    rhs <- substitute(rhs)
    kind <- 1
    env <- parent.frame()
    lazy <- TRUE
    .External2(magrittr_pipe)
  }, function (lhs, rhs) 
  {
    lhs <- substitute(lhs)
    rhs <- substitute(rhs)
    kind <- 1
    env <- parent.frame()
    lazy <- TRUE
    .External2(magrittr_pipe)
  })
c("package:stringr", "package:purrr", "package:multicolor", "namespace:magrittr")
c(TRUE, TRUE, TRUE, FALSE)
c(FALSE, TRUE, TRUE, TRUE)
boundary
list(`package:stringr` = function (type = c("character", "line_break", "sentence", "word"), skip_word_none = NA, ...) 
{
  type <- match.arg(type)
  if (identical(skip_word_none, NA)) {
    skip_word_none <- type == "word"
  }
  options <- stri_opts_brkiter(type = type, skip_word_none = skip_word_none, ...)
  structure(character(), options = options, class = c("boundary", "pattern", "character"))
}, function (type = c("character", "line_break", "sentence", "word"), skip_word_none = NA, ...) 
{
  type <- match.arg(type)
  if (identical(skip_word_none, NA)) {
    skip_word_none <- type == "word"
  }
  options <- stri_opts_brkiter(type = type, skip_word_none = skip_word_none, ...)
  structure(character(), options = options, class = c("boundary", "pattern", "character"))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
coll
list(`package:stringr` = function (pattern, ignore_case = FALSE, locale = "en", ...) 
{
  pattern <- as_bare_character(pattern)
  options <- stri_opts_collator(strength = if (ignore_case) 
    2
    else 3, locale = locale, ...)
  structure(pattern, options = options, class = c("coll", "pattern", "character"))
}, function (pattern, ignore_case = FALSE, locale = "en", ...) 
{
  pattern <- as_bare_character(pattern)
  options <- stri_opts_collator(strength = if (ignore_case) 
    2
    else 3, locale = locale, ...)
  structure(pattern, options = options, class = c("coll", "pattern", "character"))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
fixed
list(`package:stringr` = function (pattern, ignore_case = FALSE) 
{
  pattern <- as_bare_character(pattern)
  options <- stri_opts_fixed(case_insensitive = ignore_case)
  structure(pattern, options = options, class = c("fixed", "pattern", "character"))
}, function (pattern, ignore_case = FALSE) 
{
  pattern <- as_bare_character(pattern)
  options <- stri_opts_fixed(case_insensitive = ignore_case)
  structure(pattern, options = options, class = c("fixed", "pattern", "character"))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
fruit
list(`package:stringr` = c("apple", "apricot", "avocado", "banana", "bell pepper", "bilberry", "blackberry", "blackcurrant", "blood orange", "blueberry", "boysenberry", "breadfruit", "canary melon", "cantaloupe", "cherimoya", "cherry", "chili pepper", "clementine", "cloudberry", "coconut", "cranberry", "cucumber", "currant", "damson", "date", "dragonfruit", "durian", "eggplant", "elderberry", "feijoa", "fig", "goji berry", "gooseberry", "grape", "grapefruit", "guava", "honeydew", "huckleberry", "jackfruit", 
                           "jambul", "jujube", "kiwi fruit", "kumquat", "lemon", "lime", "loquat", "lychee", "mandarine", "mango", "mulberry", "nectarine", "nut", "olive", "orange", "pamelo", "papaya", "passionfruit", "peach", "pear", "persimmon", "physalis", "pineapple", "plum", "pomegranate", "pomelo", "purple mangosteen", "quince", "raisin", "rambutan", "raspberry", "redcurrant", "rock melon", "salal berry", "satsuma", "star fruit", "strawberry", "tamarillo", "tangerine", "ugli fruit", "watermelon"))
package:stringr
TRUE
FALSE
invert_match
list(`package:stringr` = function (loc) 
{
  cbind(start = c(0, loc[, "end"] + 1), end = c(loc[, "start"] - 1, -1))
}, function (loc) 
{
  cbind(start = c(0, loc[, "end"] + 1), end = c(loc[, "start"] - 1, -1))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
regex
list(`package:stringr` = function (pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE, dotall = FALSE, ...) 
{
  pattern <- as_bare_character(pattern)
  options <- stri_opts_regex(case_insensitive = ignore_case, multiline = multiline, comments = comments, dotall = dotall, ...)
  structure(pattern, options = options, class = c("regex", "pattern", "character"))
}, function (pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE, dotall = FALSE, ...) 
{
  pattern <- as_bare_character(pattern)
  options <- stri_opts_regex(case_insensitive = ignore_case, multiline = multiline, comments = comments, dotall = dotall, ...)
  structure(pattern, options = options, class = c("regex", "pattern", "character"))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
sentences
list(`package:stringr` = c("The birch canoe slid on the smooth planks.", "Glue the sheet to the dark blue background.", "It's easy to tell the depth of a well.", "These days a chicken leg is a rare dish.", "Rice is often served in round bowls.", "The juice of lemons makes fine punch.", "The box was thrown beside the parked truck.", "The hogs were fed chopped corn and garbage.", "Four hours of steady work faced us.", "Large size in stockings is hard to sell.", "The boy was there when the sun rose.", 
                           "A rod is used to catch pink salmon.", "The source of the huge river is the clear spring.", "Kick the ball straight and follow through.", "Help the woman get back to her feet.", "A pot of tea helps to pass the evening.", "Smoky fires lack flame and heat.", "The soft cushion broke the man's fall.", "The salt breeze came across from the sea.", "The girl at the booth sold fifty bonds.", "The small pup gnawed a hole in the sock.", "The fish twisted and turned on the bent hook.", "Press the pants and sew a button on the vest.", 
                           "The swan dive was far short of perfect.", "The beauty of the view stunned the young boy.", "Two blue fish swam in the tank.", "Her purse was full of useless trash.", "The colt reared and threw the tall rider.", "It snowed, rained, and hailed the same morning.", "Read verse out loud for pleasure.", "Hoist the load to your left shoulder.", "Take the winding path to reach the lake.", "Note closely the size of the gas tank.", "Wipe the grease off his dirty face.", "Mend the coat before you go out.", 
                           "The wrist was badly strained and hung limp.", "The stray cat gave birth to kittens.", "The young girl gave no clear response.", "The meal was cooked before the bell rang.", "What joy there is in living.", "A king ruled the state in the early days.", "The ship was torn apart on the sharp reef.", "Sickness kept him home the third week.", "The wide road shimmered in the hot sun.", "The lazy cow lay in the cool grass.", "Lift the square stone over the fence.", "The rope will bind the seven books at once.", 
                           "Hop over the fence and plunge in.", "The friendly gang left the drug store.", "Mesh mire keeps chicks inside.", "The frosty air passed through the coat.", "The crooked maze failed to fool the mouse.", "Adding fast leads to wrong sums.", "The show was a flop from the very start.", "A saw is a tool used for making boards.", "The wagon moved on well oiled wheels.", "March the soldiers past the next hill.", "A cup of sugar makes sweet fudge.", "Place a rosebush near the porch steps.", "Both lost their lives in the raging storm.", 
                           "We talked of the slide show in the circus.", "Use a pencil to write the first draft.", "He ran half way to the hardware store.", "The clock struck to mark the third period.", "A small creek cut across the field.", "Cars and busses stalled in snow drifts.", "The set of china hit, the floor with a crash.", "This is a grand season for hikes on the road.", "The dune rose from the edge of the water.", "Those words were the cue for the actor to leave.", "A yacht slid around the point into the bay.", "The two met while playing on the sand.", 
                           "The ink stain dried on the finished page.", "The walled town was seized without a fight.", "The lease ran out in sixteen weeks.", "A tame squirrel makes a nice pet.", "The horn of the car woke the sleeping cop.", "The heart beat strongly and with firm strokes.", "The pearl was worn in a thin silver ring.", "The fruit peel was cut in thick slices.", "The Navy attacked the big task force.", "See the cat glaring at the scared mouse.", "There are more than two factors here.", "The hat brim was wide and too droopy.", 
                           "The lawyer tried to lose his case.", "The grass curled around the fence post.", "Cut the pie into large parts.", "Men strive but seldom get rich.", "Always close the barn door tight.", "He lay prone and hardly moved a limb.", "The slush lay deep along the street.", "A wisp of cloud hung in the blue air.", "A pound of sugar costs more than eggs.", "The fin was sharp and cut the clear water.", "The play seems dull and quite stupid.", "Bail the boat, to stop it from sinking.", "The term ended in late June that year.", 
                           "A tusk is used to make costly gifts.", "Ten pins were set in order.", "The bill as paid every third week.", "Oak is strong and also gives shade.", "Cats and dogs each hate the other.", "The pipe began to rust while new.", "Open the crate but don't break the glass.", "Add the sum to the product of these three.", "Thieves who rob friends deserve jail.", "The ripe taste of cheese improves with age.", "Act on these orders with great speed.", "The hog crawled under the high fence.", "Move the vat over the hot fire.", 
                           "The bark of the pine tree was shiny and dark.", "Leaves turn brown and yellow in the fall.", "The pennant waved when the wind blew.", "Split the log with a quick, sharp blow.", "Burn peat after the logs give out.", "He ordered peach pie with ice cream.", "Weave the carpet on the right hand side.", "Hemp is a weed found in parts of the tropics.", "A lame back kept his score low.", "We find joy in the simplest things.", "Type out three lists of orders.", "The harder he tried the less he got done.", 
                           "The boss ran the show with a watchful eye.", "The cup cracked and spilled its contents.", "Paste can cleanse the most dirty brass.", "The slang word for raw whiskey is booze.", "It caught its hind paw in a rusty trap.", "The wharf could be seen at the farther shore.", "Feel the heat of the weak dying flame.", "The tiny girl took off her hat.", "A cramp is no small danger on a swim.", "He said the same phrase thirty times.", "Pluck the bright rose without leaves.", "Two plus seven is less than ten.", 
                           "The glow deepened in the eyes of the sweet girl.", "Bring your problems to the wise chief.", "Write a fond note to the friend you cherish.", "Clothes and lodging are free to new men.", "We frown when events take a bad turn.", "Port is a strong wine with s smoky taste.", "The young kid jumped the rusty gate.", "Guess the results from the first scores.", "A salt pickle tastes fine with ham.", "The just claim got the right verdict.", "These thistles bend in a high wind.", "Pure bred poodles have curls.", 
                           "The tree top waved in a graceful way.", "The spot on the blotter was made by green ink.", "Mud was spattered on the front of his white shirt.", "The cigar burned a hole in the desk top.", "The empty flask stood on the tin tray.", "A speedy man can beat this track mark.", "He broke a new shoelace that day.", "The coffee stand is too high for the couch.", "The urge to write short stories is rare.", "The pencils have all been used.", "The pirates seized the crew of the lost ship.", "We tried to replace the coin but failed.", 
                           "She sewed the torn coat quite neatly.", "The sofa cushion is red and of light weight.", "The jacket hung on the back of the wide chair.", "At that high level the air is pure.", "Drop the two when you add the figures.", "A filing case is now hard to buy.", "An abrupt start does not win the prize.", "Wood is best for making toys and blocks.", "The office paint was a dull sad tan.", "He knew the skill of the great young actress.", "A rag will soak up spilled water.", "A shower of dirt fell from the hot pipes.", 
                           "Steam hissed from the broken valve.", "The child almost hurt the small dog.", "There was a sound of dry leaves outside.", "The sky that morning was clear and bright blue.", "Torn scraps littered the stone floor.", "Sunday is the best part of the week.", "The doctor cured him with these pills.", "The new girl was fired today at noon.", "They felt gay when the ship arrived in port.", "Add the store's account to the last cent.", "Acid burns holes in wool cloth.", "Fairy tales should be fun to write.", 
                           "Eight miles of woodland burned to waste.", "The third act was dull and tired the players.", "A young child should not suffer fright.", "Add the column and put the sum here.", "We admire and love a good cook.", "There the flood mark is ten inches.", "He carved a head from the round block of marble.", "She has st smart way of wearing clothes.", "The fruit of a fig tree is apple-shaped.", "Corn cobs can be used to kindle a fire.", "Where were they when the noise started.", "The paper box is full of thumb tacks.", 
                           "Sell your gift to a buyer at a good gain.", "The tongs lay beside the ice pail.", "The petals fall with the next puff of wind.", "Bring your best compass to the third class.", "They could laugh although they were sad.", "Farmers came in to thresh the oat crop.", "The brown house was on fire to the attic.", "The lure is used to catch trout and flounder.", "Float the soap on top of the bath water.", "A blue crane is a tall wading bird.", "A fresh start will work such wonders.", "The club rented the rink for the fifth night.", 
                           "After the dance they went straight home.", "The hostess taught the new maid to serve.", "He wrote his last novel there at the inn.", "Even the worst will beat his low score.", "The cement had dried when he moved it.", "The loss of the second ship was hard to take.", "The fly made its way along the wall.", "Do that with a wooden stick.", "Lire wires should be kept covered.", "The large house had hot water taps.", "It is hard to erase blue or red ink.", "Write at once or you may forget it.", "The doorknob was made of bright clean brass.", 
                           "The wreck occurred by the bank on Main Street.", "A pencil with black lead writes best.", "Coax a young calf to drink from a bucket.", "Schools for ladies teach charm and grace.", "The lamp shone with a steady green flame.", "They took the axe and the saw to the forest.", "The ancient coin was quite dull and worn.", "The shaky barn fell with a loud crash.", "Jazz and swing fans like fast music.", "Rake the rubbish up and then burn it.", "Slash the gold cloth into fine ribbons.", "Try to have the court decide the case.", 
                           "They are pushed back each time they attack.", "He broke his ties with groups of former friends.", "They floated on the raft to sun their white backs.", "The map had an X that meant nothing.", "Whitings are small fish caught in nets.", "Some ads serve to cheat buyers.", "Jerk the rope and the bell rings weakly.", "A waxed floor makes us lose balance.", "Madam, this is the best brand of corn.", "On the islands the sea breeze is soft and mild.", "The play began as soon as we sat down.", "This will lead the world to more sound and fury", 
                           "Add salt before you fry the egg.", "The rush for funds reached its peak Tuesday.", "The birch looked stark white and lonesome.", "The box is held by a bright red snapper.", "To make pure ice, you freeze water.", "The first worm gets snapped early.", "Jump the fence and hurry up the bank.", "Yell and clap as the curtain slides back.", "They are men nho walk the middle of the road.", "Both brothers wear the same size.", "In some forin or other we need fun.", "The prince ordered his head chopped off.", 
                           "The houses are built of red clay bricks.", "Ducks fly north but lack a compass.", "Fruit flavors are used in fizz drinks.", "These pills do less good than others.", "Canned pears lack full flavor.", "The dark pot hung in the front closet.", "Carry the pail to the wall and spill it there.", "The train brought our hero to the big town.", "We are sure that one war is enough.", "Gray paint stretched for miles around.", "The rude laugh filled the empty room.", "High seats are best for football fans.", 
                           "Tea served from the brown jug is tasty.", "A dash of pepper spoils beef stew.", "A zestful food is the hot-cross bun.", "The horse trotted around the field at a brisk pace.", "Find the twin who stole the pearl necklace.", "Cut the cord that binds the box tightly.", "The red tape bound the smuggled food.", "Look in the corner to find the tan shirt.", "The cold drizzle will halt the bond drive.", "Nine men were hired to dig the ruins.", "The junk yard had a mouldy smell.", "The flint sputtered and lit a pine torch.", 
                           "Soak the cloth and drown the sharp odor.", "The shelves were bare of both jam or crackers.", "A joy to every child is the swan boat.", "All sat frozen and watched the screen.", "ii cloud of dust stung his tender eyes.", "To reach the end he needs much courage.", "Shape the clay gently into block form.", "The ridge on a smooth surface is a bump or flaw.", "Hedge apples may stain your hands green.", "Quench your thirst, then eat the crackers.", "Tight curls get limp on rainy days.", "The mute muffled the high tones of the horn.", 
                           "The gold ring fits only a pierced ear.", "The old pan was covered with hard fudge.", "Watch the log float in the wide river.", "The node on the stalk of wheat grew daily.", "The heap of fallen leaves was set on fire.", "Write fast, if you want to finish early.", "His shirt was clean but one button was gone.", "The barrel of beer was a brew of malt and hops.", "Tin cans are absent from store shelves.", "Slide the box into that empty space.", "The plant grew large and green in the window.", "The beam dropped down on the workmen's head.", 
                           "Pink clouds floated JTith the breeze.", "She danced like a swan, tall and graceful.", "The tube was blown and the tire flat and useless.", "It is late morning on the old wall clock.", "Let's all join as we sing the last chorus.", "The last switch cannot be turned off.", "The fight will end in just six minutes.", "The store walls were lined with colored frocks.", "The peace league met to discuss their plans.", "The rise to fame of a person takes luck.", "Paper is scarce, so write with much care.", 
                           "The quick fox jumped on the sleeping cat.", "The nozzle of the fire hose was bright brass.", "Screw the round cap on as tight as needed.", "Time brings us many changes.", "The purple tie was ten years old.", "Men think and plan and sometimes act.", "Fill the ink jar with sticky glue.", "He smoke a big pipe with strong contents.", "We need grain to keep our mules healthy.", "Pack the records in a neat thin case.", "The crunch of feet in the snow was the only sound.", "The copper bowl shone in the sun's rays.", 
                           "Boards will warp unless kept dry.", "The plush chair leaned against the wall.", "Glass will clink when struck by metal.", "Bathe and relax in the cool green grass.", "Nine rows of soldiers stood in line.", "The beach is dry and shallow at low tide.", "The idea is to sew both edges straight.", "The kitten chased the dog down the street.", "Pages bound in cloth make a book.", "Try to trace the fine lines of the painting.", "Women form less than half of the group.", "The zones merge in the central part of town.", 
                           "A gem in the rough needs work to polish.", "Code is used when secrets are sent.", "Most of the new is easy for us to hear.", "He used the lathe to make brass objects.", "The vane on top of the pole revolved in the wind.", "Mince pie is a dish served to children.", "The clan gathered on each dull night.", "Let it burn, it gives us warmth and comfort.", "A castle built from sand fails to endure.", "A child's wit saved the day for us.", "Tack the strip of carpet to the worn floor.", "Next Tuesday we must vote.", 
                           "Pour the stew from the pot into the plate.", "Each penny shone like new.", "The man went to the woods to gather sticks.", "The dirt piles were lines along the road.", "The logs fell and tumbled into the clear stream.", "Just hoist it up and take it away,", "A ripe plum is fit for a king's palate.", "Our plans right now are hazy.", "Brass rings are sold by these natives.", "It takes a good trap to capture a bear.", "Feed the white mouse some flower seeds.", "The thaw came early and freed the stream.", 
                           "He took the lead and kept it the whole distance.", "The key you designed will fit the lock.", "Plead to the council to free the poor thief.", "Better hash is made of rare beef.", "This plank was made for walking on.", "The lake sparkled in the red hot sun.", "He crawled with care along the ledge.", "Tend the sheep while the dog wanders.", "It takes a lot of help to finish these.", "Mark the spot with a sign painted red.", "Take two shares as a fair profit.", "The fur of cats goes by many names.", 
                           "North winds bring colds and fevers.", "He asks no person to vouch for him.", "Go now and come here later.", "A sash of gold silk will trim her dress.", "Soap can wash most dirt away.", "That move means the game is over.", "He wrote down a long list of items.", "A siege will crack the strong defense.", "Grape juice and water mix well.", "Roads are paved with sticky tar.", "Fake &ones shine but cost little.", "The drip of the rain made a pleasant sound.", "Smoke poured out of every crack.", "Serve the hot rum to the tired heroes.", 
                           "Much of the story makes good sense.", "The sun came up to light the eastern sky.", "Heave the line over the port side.", "A lathe cuts and trims any wood.", "It's a dense crowd in two distinct ways.", "His hip struck the knee of the next player.", "The stale smell of old beer lingers.", "The desk was firm on the shaky floor.", "It takes heat to bring out the odor.", "Beef is scarcer than some lamb.", "Raise the sail and steer the ship northward.", "The cone costs five cents on Mondays.", "A pod is what peas always grow in.", 
                           "Jerk the dart from the cork target.", "No cement will hold hard wood.", "We now have a new base for shipping.", "The list of names is carved around the base.", "The sheep were led home by a dog.", "Three for a dime, the young peddler cried.", "The sense of smell is better than that of touch.", "No hardship seemed to keep him sad.", "Grace makes up for lack of beauty.", "Nudge gently but wake her now.", "The news struck doubt into restless minds.", "Once we stood beside the shore.", "A chink in the wall allowed a draft to blow.", 
                           "Fasten two pins on each side.", "A cold dip restores health and zest.", "He takes the oath of office each March.", "The sand drifts over the sill of the old house.", "The point of the steel pen was bent and twisted.", "There is a lag between thought and act.", "Seed is needed to plant the spring corn.", "Draw the chart with heavy black lines.", "The boy owed his pal thirty cents.", "The chap slipped into the crowd and was lost.", "Hats are worn to tea and not to dinner.", "The ramp led up to the wide highway.", 
                           "Beat the dust from the rug onto the lawn.", "Say it slow!y but make it ring clear.", "The straw nest housed five robins.", "Screen the porch with woven straw mats.", "This horse will nose his way to the finish.", "The dry wax protects the deep scratch.", "He picked up the dice for a second roll.", "These coins will be needed to pay his debt.", "The nag pulled the frail cart along.", "Twist the valve and release hot steam.", "The vamp of the shoe had a gold buckle.", "The smell of burned rags itches my nose.", 
                           "Xew pants lack cuffs and pockets.", "The marsh will freeze when cold enough.", "They slice the sausage thin with a knife.", "The bloom of the rose lasts a few days.", "A gray mare walked before the colt.", "Breakfast buns are fine with a hot drink.", "Bottles hold four kinds of rum.", "The man wore a feather in his felt hat.", "He wheeled the bike past. the winding road.", "Drop the ashes on the worn old rug.", "The desk and both chairs were painted tan.", "Throw out the used paper cup and plate.", 
                           "A clean neck means a neat collar.", "The couch cover and hall drapes were blue.", "The stems of the tall glasses cracked and broke.", "The wall phone rang loud and often.", "The clothes dried on a thin wooden rack.", "Turn on the lantern which gives us light.", "The cleat sank deeply into the soft turf.", "The bills were mailed promptly on the tenth of the month.", "To have is better than to wait and hope.", "The price is fair for a good antique clock.", "The music played on while they talked.", 
                           "Dispense with a vest on a day like this.", "The bunch of grapes was pressed into wine.", "He sent the figs, but kept the ripe cherries.", "The hinge on the door creaked with old age.", "The screen before the fire kept in the sparks.", "Fly by night, and you waste little time.", "Thick glasses helped him read the print.", "Birth and death mark the limits of life.", "The chair looked strong but had no bottom.", "The kite flew wildly in the high wind.", "A fur muff is stylish once more.", "The tin box held priceless stones.", 
                           "We need an end of all such matter.", "The case was puzzling to the old and wise.", "The bright lanterns were gay on the dark lawn.", "We don't get much money but we have fun.", "The youth drove with zest, but little skill.", "Five years he lived with a shaggy dog.", "A fence cuts through the corner lot.", "The way to save money is not to spend much.", "Shut the hatch before the waves push it in.", "The odor of spring makes young hearts jump.", "Crack the walnut with your sharp side teeth.", "He offered proof in the form of a lsrge chart.", 
                           "Send the stuff in a thick paper bag.", "A quart of milk is water for the most part.", "They told wild tales to frighten him.", "The three story house was built of stone.", "In the rear of the ground floor was a large passage.", "A man in a blue sweater sat at the desk.", "Oats are a food eaten by horse and man.", "Their eyelids droop for want. of sleep.", "The sip of tea revives his tired friend.", "There are many ways to do these things.", "Tuck the sheet under the edge of the mat.", "A force equal to that would move the earth.", 
                           "We like to see clear weather.", "The work of the tailor is seen on each side.", "Take a chance and win a china doll.", "Shake the dust from your shoes, stranger.", "She was kind to sick old people.", "The dusty bench stood by the stone wall.", "The square wooden crate was packed to be shipped.", "We dress to suit the weather of most days.", "Smile when you say nasty words.", "A bowl of rice is free with chicken stew.", "The water in this well is a source of good health.", "Take shelter in this tent, but keep still.", 
                           "That guy is the writer of a few banned books.", "The little tales they tell are false.", "The door was barred, locked, and bolted as well.", "Ripe pears are fit for a queen's table.", "A big wet stain was on the round carpet.", "The kite dipped and swayed, but stayed aloft.", "The pleasant hours fly by much too soon.", "The room was crowded with a wild mob.", "This strong arm shall shield your honor.", "She blushed when he gave her a white orchid.", "The beetle droned in the hot June sun.", "Press the pedal with your left foot.", 
                           "Neat plans fail without luck.", "The black trunk fell from the landing.", "The bank pressed for payment of the debt.", "The theft of the pearl pin was kept secret.", "Shake hands with this friendly child.", "The vast space stretched into the far distance.", "A rich farm is rare in this sandy waste.", "His wide grin earned many friends.", "Flax makes a fine brand of paper.", "Hurdle the pit with the aid of a long pole.", "A strong bid may scare your partner stiff.", "Even a just cause needs power to win.", 
                           "Peep under the tent and see the clowns.", "The leaf drifts along with a slow spin.", "Cheap clothes are flashy but don??????t last.", "A thing of small note can cause despair.", "Flood the mails with requests for this book.", "A thick coat of black paint covered all.", "The pencil was cut to be sharp at both ends.", "Those last words were a strong statement.", "He wrote his name boldly at the top of tile sheet.", "Dill pickles are sour but taste fine.", "Down that road is the way to the grain farmer.", 
                           "Either mud or dust are found at all times.", "The best method is to fix it in place with clips.", "If you mumble your speech will be lost.", "At night the alarm roused him from a deep sleep.", "Read just what the meter says.", "Fill your pack with bright trinkets for the poor.", "The small red neon lamp went out.", "Clams are small, round, soft, and tasty.", "The fan whirled its round blades softly.", "The line where the edges join was clean.", "Breathe deep and smell the piny air.", "It matters not if he reads these words or those.", 
                           "A brown leather bag hung from its strap.", "A toad and a frog are hard to tell apart.", "A white silk jacket goes with any shoes.", "A break in the dam almost caused a flood.", "Paint the sockets in the wall dull green.", "The child crawled into the dense grass.", "Bribes fail where honest men work.", "Trample the spark, else the flames will spread.", "The hilt. of the sword was carved with fine designs.", "A round hole was drilled through the thin board.", "Footprints showed the path he took up the beach.", 
                           "She was waiting at my front lawn.", "A vent near the edge brought in fresh air.", "Prod the old mule with a crooked stick.", "It is a band of steel three inches wide.", "The pipe ran almost the length of the ditch.", "It was hidden from sight by a mass of leaves and shrubs.", "The weight. of the package was seen on the high scale.", "Wake and rise, and step into the green outdoors.", "The green light in the brown box flickered.", "The brass tube circled the high wall.", "The lobes of her ears were pierced to hold rings.", 
                           "Hold the hammer near the end to drive the nail.", "Next Sunday is the twelfth of the month.", "Every word and phrase he speaks is true.", "He put his last cartridge into the gun and fired.", "They took their kids from the public school.", "Drive the screw straight into the wood.", "Keep the hatch tight and the watch constant.", "Sever the twine with a quick snip of the knife.", "Paper will dry out when wet.", "Slide the catch back and open the desk.", "Help the weak to preserve their strength.", 
                           "A sullen smile gets few friends.", "Stop whistling and watch the boys march.", "Jerk the cord, and out tumbles the gold.", "Slidc the tray across the glass top.", "The cloud moved in a stately way and was gone.", "Light maple makes for a swell room.", "Set the piece here and say nothing.", "Dull stories make her laugh.", "A stiff cord will do to fasten your shoe.", "Get the trust fund to the bank early.", "Choose between the high road and the low.", "A plea for funds seems to come again.", "He lent his coat to the tall gaunt stranger.", 
                           "There is a strong chance it will happen once more.", "The duke left the park in a silver coach.", "Greet the new guests and leave quickly.", "When the frost has come it is time for turkey.", "Sweet words work better than fierce.", "A thin stripe runs down the middle.", "A six comes up more often than a ten.", "Lush fern grow on the lofty rocks.", "The ram scared the school children off.", "The team with the best timing looks good.", "The farmer swapped his horse for a brown ox.", "Sit on the perch and tell the others what to do.", 
                           "A steep trail is painful for our feet.", "The early phase of life moves fast.", "Green moss grows on the northern side.", "Tea in thin china has a sweet taste.", "Pitch the straw through the door of the stable.", "The latch on the beck gate needed a nail.", "The goose was brought straight from the old market.", "The sink is the thing in which we pile dishes.", "A whiff of it will cure the most stubborn cold.", "The facts don\u0092t always show who is right.", "She flaps her cape as she parades the street.", 
                           "The loss of the cruiser was a blow to the fleet.", "Loop the braid to the left and then over.", "Plead with the lawyer to drop the lost cause.", "Calves thrive on tender spring grass.", "Post no bills on this office wall.", "Tear a thin sheet from the yellow pad.", "A cruise in warm waters in a sleek yacht is fun.", "A streak of color ran down the left edge.", "It was done before the boy could see it.", "Crouch before you jump or miss the mark.", "Pack the kits and don\u0092t forget the salt.", 
                           "The square peg will settle in the round hole.", "Fine soap saves tender skin.", "Poached eggs and tea must suffice.", "Bad nerves are jangled by a door slam.", "Ship maps are different from those for planes.", "Dimes showered down from all sides.", "They sang the same tunes at each party.", "The sky in the west is tinged with orange red.", "The pods of peas ferment in bare fields.", "The horse balked and threw the tall rider.", "The hitch between the horse and cart broke.", "Pile the coal high in the shed corner.", 
                           "The gold vase is both rare and costly.", "The knife was hung inside its bright sheath.", "The rarest spice comes from the far East.", "The roof should be tilted at a sharp slant.", "A smatter of French is worse than none.", "The mule trod the treadmill day and night.", "The aim of the contest is to raise a great fund.", "To send it. now in large amounts is bad.", "There is a fine hard tang in salty air.", "Cod is the main business of the north shore.", "The slab was hewn from heavy blocks of slat\u0092e.", 
                           "Dunk the stale biscuits into strong drink.", "Hang tinsel from both branches.", "Cap the jar with a tight brass cover.", "The poor boy missed the boat again.", "Be sure to set the lamp firmly in the hole.", "Pick a card and slip it. under the pack.", "A round mat will cover the dull spot.", "The first part of the plan needs changing.", "The good book informs of what we ought to know.", "The mail comes in three batches per day.", "You cannot brew tea in a cold pot.", "Dots of light betrayed the black cat.", 
                           "Put the chart on the mantel and tack it down.", "The night shift men rate extra pay.", "The red paper brightened the dim stage.", "See the player scoot to third base.", "Slide the bill between the two leaves.", "Many hands help get the job done.", "We don't like to admit our small faults.", "No doubt about the way the wind blows.", "Dig deep in the earth for pirate's gold.", "The steady drip is worse than a drenching rain.", "A flat pack takes less luggage space.", "Green ice frosted the punch bowl.", 
                           "A stuffed chair slipped from the moving van.", "The stitch will serve but needs to be shortened.", "A thin book fits in the side pocket.", "The gloss on top made it unfit to read.", "The hail pattered on the burnt brown grass.", "Seven seals were stamped on great sheets.", "Our troops are set to strike heavy blows.", "The store was jammed before the sale could start.", "It was a bad error on the part of the new judge.", "One step more and the board will collapse.", "Take the match and strike it against your shoe.", 
                           "The pot boiled, but the contents failed to jell.", "The baby puts his right foot in his mouth.", "The bombs left most of the town in ruins.", "Stop and stare at the hard working man.", "The streets are narrow and full of sharp turns.", "The pup jerked the leash as he saw a feline shape.", "Open your book to the first page.", "Fish evade the net, and swim off.", "Dip the pail once and let it settle.", "Will you please answer that phone.", "The big red apple fell to the ground.", "The curtain rose and the show was on.", 
                           "The young prince became heir to the throne.", "He sent the boy on a short errand.", "Leave now and you will arrive on time.", "The corner store was robbed last night.", "A gold ring will please most any girl.", "The long journey home took a year.", "She saw a cat in the neighbor's house.", "A pink shell was found on the sandy beach.", "Small children came to see him.", "The grass and bushes were wet with dew.", "The blind man counted his old coins.", "A severe storm tore down the barn.", "She called his name many times.", 
                           "When you hear the bell, come quickly."))
package:stringr
TRUE
FALSE
str_c
list(`package:stringr` = function (..., sep = "", collapse = NULL) 
{
  stri_c(..., sep = sep, collapse = collapse, ignore_null = TRUE)
}, function (..., sep = "", collapse = NULL) 
{
  stri_c(..., sep = sep, collapse = collapse, ignore_null = TRUE)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_conv
list(`package:stringr` = function (string, encoding) 
{
  stri_conv(string, encoding, "UTF-8")
}, function (string, encoding) 
{
  stri_conv(string, encoding, "UTF-8")
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_count
list(`package:stringr` = function (string, pattern = "") 
{
  switch(type(pattern), empty = stri_count_boundaries(string, opts_brkiter = opts(pattern)), bound = stri_count_boundaries(string, opts_brkiter = opts(pattern)), fixed = stri_count_fixed(string, pattern, opts_fixed = opts(pattern)), coll = stri_count_coll(string, pattern, opts_collator = opts(pattern)), regex = stri_count_regex(string, pattern, opts_regex = opts(pattern)))
}, function (string, pattern = "") 
{
  switch(type(pattern), empty = stri_count_boundaries(string, opts_brkiter = opts(pattern)), bound = stri_count_boundaries(string, opts_brkiter = opts(pattern)), fixed = stri_count_fixed(string, pattern, opts_fixed = opts(pattern)), coll = stri_count_coll(string, pattern, opts_collator = opts(pattern)), regex = stri_count_regex(string, pattern, opts_regex = opts(pattern)))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_detect
list(`package:stringr` = function (string, pattern, negate = FALSE) 
{
  switch(type(pattern), empty = , bound = str_count(string, pattern) > 0 & !negate, fixed = stri_detect_fixed(string, pattern, negate = negate, opts_fixed = opts(pattern)), coll = stri_detect_coll(string, pattern, negate = negate, opts_collator = opts(pattern)), regex = stri_detect_regex(string, pattern, negate = negate, opts_regex = opts(pattern)))
}, function (string, pattern) 
{
  grepl(pattern, string)
}, function (string, pattern, negate = FALSE) 
{
  switch(type(pattern), empty = , bound = str_count(string, pattern) > 0 & !negate, fixed = stri_detect_fixed(string, pattern, negate = negate, opts_fixed = opts(pattern)), coll = stri_detect_coll(string, pattern, negate = negate, opts_collator = opts(pattern)), regex = stri_detect_regex(string, pattern, negate = negate, opts_regex = opts(pattern)))
})
c("package:stringr", "namespace:httr", "namespace:stringr")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
str_dup
list(`package:stringr` = function (string, times) 
{
  stri_dup(string, times)
}, function (string, times) 
{
  stri_dup(string, times)
}, function (x, times) 
{
  paste0(rep(x, times = times), collapse = "")
})
c("package:stringr", "namespace:stringr", "namespace:vctrs")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
str_ends
list(`package:stringr` = function (string, pattern, negate = FALSE) 
{
  switch(type(pattern), empty = , bound = stop("boundary() patterns are not supported."), fixed = stri_endswith_fixed(string, pattern, negate = negate, opts_fixed = opts(pattern)), coll = stri_endswith_coll(string, pattern, negate = negate, opts_collator = opts(pattern)), regex = {
    pattern2 <- paste0(pattern, "$")
    attributes(pattern2) <- attributes(pattern)
    str_detect(string, pattern2, negate)
  })
}, function (string, pattern, negate = FALSE) 
{
  switch(type(pattern), empty = , bound = stop("boundary() patterns are not supported."), fixed = stri_endswith_fixed(string, pattern, negate = negate, opts_fixed = opts(pattern)), coll = stri_endswith_coll(string, pattern, negate = negate, opts_collator = opts(pattern)), regex = {
    pattern2 <- paste0(pattern, "$")
    attributes(pattern2) <- attributes(pattern)
    str_detect(string, pattern2, negate)
  })
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_extract
list(`package:stringr` = function (string, pattern) 
{
  switch(type(pattern), empty = stri_extract_first_boundaries(string, pattern, opts_brkiter = opts(pattern)), bound = stri_extract_first_boundaries(string, pattern, opts_brkiter = opts(pattern)), fixed = stri_extract_first_fixed(string, pattern, opts_fixed = opts(pattern)), coll = stri_extract_first_coll(string, pattern, opts_collator = opts(pattern)), regex = stri_extract_first_regex(string, pattern, opts_regex = opts(pattern)))
}, function (string, pattern) 
{
  m <- regexpr(pattern, string)
  res <- substr(string, m, attr(m, "match.length") + m - 1)
  res[m == -1] <- NA
  res
}, function (string, pattern) 
{
  switch(type(pattern), empty = stri_extract_first_boundaries(string, pattern, opts_brkiter = opts(pattern)), bound = stri_extract_first_boundaries(string, pattern, opts_brkiter = opts(pattern)), fixed = stri_extract_first_fixed(string, pattern, opts_fixed = opts(pattern)), coll = stri_extract_first_coll(string, pattern, opts_collator = opts(pattern)), regex = stri_extract_first_regex(string, pattern, opts_regex = opts(pattern)))
}, function (x, into, regex, convert = FALSE) 
{
  check_not_stringr_pattern(regex, "regex")
  stopifnot(is_string(regex), is_character(into))
  out <- str_match_first(x, regex)
  if (length(out) != length(into)) {
    stop("`regex` should define ", length(into), " groups; ", length(out), " found.", call. = FALSE)
  }
  if (anyDuplicated(into)) {
    pieces <- split(out, into)
    into <- names(pieces)
    out <- map(pieces, pmap_chr, vec_paste0)
  }
  into <- as_utf8_character(into)
  non_na_into <- !is.na(into)
  out <- out[non_na_into]
  names(out) <- into[non_na_into]
  out <- as_tibble(out)
  if (convert) {
    out[] <- map(out, type.convert, as.is = TRUE)
  }
  out
})
c("package:stringr", "namespace:httr", "namespace:stringr", "namespace:tidyr")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, FALSE)
str_extract_all
list(`package:stringr` = function (string, pattern, simplify = FALSE) 
{
  switch(type(pattern), empty = stri_extract_all_boundaries(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_brkiter = opts(pattern)), bound = stri_extract_all_boundaries(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_brkiter = opts(pattern)), fixed = stri_extract_all_fixed(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_fixed = opts(pattern)), coll = stri_extract_all_coll(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_collator = opts(pattern)), 
         regex = stri_extract_all_regex(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_regex = opts(pattern)))
}, function (string, pattern, simplify = FALSE) 
{
  switch(type(pattern), empty = stri_extract_all_boundaries(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_brkiter = opts(pattern)), bound = stri_extract_all_boundaries(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_brkiter = opts(pattern)), fixed = stri_extract_all_fixed(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_fixed = opts(pattern)), coll = stri_extract_all_coll(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_collator = opts(pattern)), 
         regex = stri_extract_all_regex(string, pattern, simplify = simplify, omit_no_match = TRUE, opts_regex = opts(pattern)))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_flatten
list(`package:stringr` = function (string, collapse = "") 
{
  stri_flatten(string, collapse = collapse)
}, function (string, collapse = "") 
{
  stri_flatten(string, collapse = collapse)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_glue
list(`package:stringr` = function (..., .sep = "", .envir = parent.frame()) 
{
  glue::glue(..., .sep = .sep, .envir = .envir)
}, function (..., .sep = "", .envir = parent.frame()) 
{
  glue::glue(..., .sep = .sep, .envir = .envir)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_glue_data
list(`package:stringr` = function (.x, ..., .sep = "", .envir = parent.frame(), .na = "NA") 
{
  glue::glue_data(.x, ..., .sep = .sep, .envir = .envir, .na = .na)
}, function (.x, ..., .sep = "", .envir = parent.frame(), .na = "NA") 
{
  glue::glue_data(.x, ..., .sep = .sep, .envir = .envir, .na = .na)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_interp
list(`package:stringr` = function (string, env = parent.frame()) 
{
  if (!is.character(string)) {
    stop("string argument is not character.", call. = FALSE)
  }
  string <- str_c(string, collapse = "")
  matches <- interp_placeholders(string)
  if (matches$indices[1] <= 0) {
    string
  }
  else {
    replacements <- eval_interp_matches(matches$matches, env)
    `regmatches<-`(string, list(matches$indices), FALSE, list(replacements))
  }
}, function (string, env = parent.frame()) 
{
  if (!is.character(string)) {
    stop("string argument is not character.", call. = FALSE)
  }
  string <- str_c(string, collapse = "")
  matches <- interp_placeholders(string)
  if (matches$indices[1] <= 0) {
    string
  }
  else {
    replacements <- eval_interp_matches(matches$matches, env)
    `regmatches<-`(string, list(matches$indices), FALSE, list(replacements))
  }
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_length
list(`package:stringr` = function (string) 
{
  stri_length(string)
}, function (string) 
{
  stri_length(string)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_locate
list(`package:stringr` = function (string, pattern) 
{
  switch(type(pattern), empty = stri_locate_first_boundaries(string, opts_brkiter = opts(pattern)), bound = stri_locate_first_boundaries(string, opts_brkiter = opts(pattern)), fixed = stri_locate_first_fixed(string, pattern, opts_fixed = opts(pattern)), coll = stri_locate_first_coll(string, pattern, opts_collator = opts(pattern)), regex = stri_locate_first_regex(string, pattern, opts_regex = opts(pattern)))
}, function (string, pattern) 
{
  switch(type(pattern), empty = stri_locate_first_boundaries(string, opts_brkiter = opts(pattern)), bound = stri_locate_first_boundaries(string, opts_brkiter = opts(pattern)), fixed = stri_locate_first_fixed(string, pattern, opts_fixed = opts(pattern)), coll = stri_locate_first_coll(string, pattern, opts_collator = opts(pattern)), regex = stri_locate_first_regex(string, pattern, opts_regex = opts(pattern)))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_locate_all
list(`package:stringr` = function (string, pattern) 
{
  opts <- opts(pattern)
  switch(type(pattern), empty = stri_locate_all_boundaries(string, omit_no_match = TRUE, opts_brkiter = opts), bound = stri_locate_all_boundaries(string, omit_no_match = TRUE, opts_brkiter = opts), fixed = stri_locate_all_fixed(string, pattern, omit_no_match = TRUE, opts_fixed = opts), regex = stri_locate_all_regex(string, pattern, omit_no_match = TRUE, opts_regex = opts), coll = stri_locate_all_coll(string, pattern, omit_no_match = TRUE, opts_collator = opts))
}, function (string, pattern) 
{
  opts <- opts(pattern)
  switch(type(pattern), empty = stri_locate_all_boundaries(string, omit_no_match = TRUE, opts_brkiter = opts), bound = stri_locate_all_boundaries(string, omit_no_match = TRUE, opts_brkiter = opts), fixed = stri_locate_all_fixed(string, pattern, omit_no_match = TRUE, opts_fixed = opts), regex = stri_locate_all_regex(string, pattern, omit_no_match = TRUE, opts_regex = opts), coll = stri_locate_all_coll(string, pattern, omit_no_match = TRUE, opts_collator = opts))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_match
list(`package:stringr` = function (string, pattern) 
{
  if (type(pattern) != "regex") {
    stop("Can only match regular expressions", call. = FALSE)
  }
  stri_match_first_regex(string, pattern, opts_regex = opts(pattern))
}, function (string, pattern) 
{
  m <- regexpr(pattern, string, perl = TRUE)
  cbind(substr(string, m, attr(m, "match.length") + m - 1), substr(string, attr(m, "capture.start"), attr(m, "capture.length") + attr(m, "capture.start") - 1))
}, function (string, pattern) 
{
  if (type(pattern) != "regex") {
    stop("Can only match regular expressions", call. = FALSE)
  }
  stri_match_first_regex(string, pattern, opts_regex = opts(pattern))
})
c("package:stringr", "namespace:httr", "namespace:stringr")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
str_match_all
list(`package:stringr` = function (string, pattern) 
{
  if (type(pattern) != "regex") {
    stop("Can only match regular expressions", call. = FALSE)
  }
  stri_match_all_regex(string, pattern, omit_no_match = TRUE, opts_regex = opts(pattern))
}, function (string, pattern) 
{
  if (type(pattern) != "regex") {
    stop("Can only match regular expressions", call. = FALSE)
  }
  stri_match_all_regex(string, pattern, omit_no_match = TRUE, opts_regex = opts(pattern))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_order
list(`package:stringr` = function (x, decreasing = FALSE, na_last = TRUE, locale = "en", numeric = FALSE, ...) 
{
  stri_order(x, decreasing = decreasing, na_last = na_last, opts_collator = stri_opts_collator(locale, numeric = numeric, ...))
}, function (x, decreasing = FALSE, na_last = TRUE, locale = "en", numeric = FALSE, ...) 
{
  stri_order(x, decreasing = decreasing, na_last = na_last, opts_collator = stri_opts_collator(locale, numeric = numeric, ...))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_pad
list(`package:stringr` = function (string, width, side = c("left", "right", "both"), pad = " ") 
{
  side <- match.arg(side)
  switch(side, left = stri_pad_left(string, width, pad = pad), right = stri_pad_right(string, width, pad = pad), both = stri_pad_both(string, width, pad = pad))
}, function (string, width, side = c("left", "right", "both"), pad = " ") 
{
  side <- match.arg(side)
  switch(side, left = stri_pad_left(string, width, pad = pad), right = stri_pad_right(string, width, pad = pad), both = stri_pad_both(string, width, pad = pad))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_remove
list(`package:stringr` = function (string, pattern) 
{
  str_replace(string, pattern, "")
}, function (string, pattern) 
{
  str_replace(string, pattern, "")
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_remove_all
list(`package:stringr` = function (string, pattern) 
{
  str_replace_all(string, pattern, "")
}, function (string, pattern) 
{
  str_replace_all(string, pattern, "")
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_replace
list(`package:stringr` = function (string, pattern, replacement) 
{
  if (!missing(replacement) && is.function(replacement)) {
    return(str_transform(string, pattern, replacement))
  }
  switch(type(pattern), empty = stop("Empty `pattern` not supported", call. = FALSE), bound = stop("Boundary `pattern` not supported", call. = FALSE), fixed = stri_replace_first_fixed(string, pattern, replacement, opts_fixed = opts(pattern)), coll = stri_replace_first_coll(string, pattern, replacement, opts_collator = opts(pattern)), regex = stri_replace_first_regex(string, pattern, fix_replacement(replacement), opts_regex = opts(pattern)))
}, function (string, pattern, replace) 
{
  m <- regexpr(pattern, string)
  regmatches(string, m) <- replace
  string
}, function (string, pattern, replacement) 
{
  if (!missing(replacement) && is.function(replacement)) {
    return(str_transform(string, pattern, replacement))
  }
  switch(type(pattern), empty = stop("Empty `pattern` not supported", call. = FALSE), bound = stop("Boundary `pattern` not supported", call. = FALSE), fixed = stri_replace_first_fixed(string, pattern, replacement, opts_fixed = opts(pattern)), coll = stri_replace_first_coll(string, pattern, replacement, opts_collator = opts(pattern)), regex = stri_replace_first_regex(string, pattern, fix_replacement(replacement), opts_regex = opts(pattern)))
})
c("package:stringr", "namespace:httr", "namespace:stringr")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
str_replace_all
list(`package:stringr` = function (string, pattern, replacement) 
{
  if (!missing(replacement) && is.function(replacement)) {
    return(str_transform_all(string, pattern, replacement))
  }
  if (!is.null(names(pattern))) {
    vec <- FALSE
    replacement <- unname(pattern)
    pattern[] <- names(pattern)
  }
  else {
    vec <- TRUE
  }
  switch(type(pattern), empty = stop("Empty `pattern`` not supported", call. = FALSE), bound = stop("Boundary `pattern` not supported", call. = FALSE), fixed = stri_replace_all_fixed(string, pattern, replacement, vectorize_all = vec, opts_fixed = opts(pattern)), coll = stri_replace_all_coll(string, pattern, replacement, vectorize_all = vec, opts_collator = opts(pattern)), regex = stri_replace_all_regex(string, pattern, fix_replacement(replacement), vectorize_all = vec, opts_regex = opts(pattern)))
}, function (string, pattern, replacement) 
{
  if (!missing(replacement) && is.function(replacement)) {
    return(str_transform_all(string, pattern, replacement))
  }
  if (!is.null(names(pattern))) {
    vec <- FALSE
    replacement <- unname(pattern)
    pattern[] <- names(pattern)
  }
  else {
    vec <- TRUE
  }
  switch(type(pattern), empty = stop("Empty `pattern`` not supported", call. = FALSE), bound = stop("Boundary `pattern` not supported", call. = FALSE), fixed = stri_replace_all_fixed(string, pattern, replacement, vectorize_all = vec, opts_fixed = opts(pattern)), coll = stri_replace_all_coll(string, pattern, replacement, vectorize_all = vec, opts_collator = opts(pattern)), regex = stri_replace_all_regex(string, pattern, fix_replacement(replacement), vectorize_all = vec, opts_regex = opts(pattern)))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_replace_na
list(`package:stringr` = function (string, replacement = "NA") 
{
  stri_replace_na(string, replacement)
}, function (string, replacement = "NA") 
{
  stri_replace_na(string, replacement)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_sort
list(`package:stringr` = function (x, decreasing = FALSE, na_last = TRUE, locale = "en", numeric = FALSE, ...) 
{
  stri_sort(x, decreasing = decreasing, na_last = na_last, opts_collator = stri_opts_collator(locale, numeric = numeric, ...))
}, function (x, decreasing = FALSE, na_last = TRUE, locale = "en", numeric = FALSE, ...) 
{
  stri_sort(x, decreasing = decreasing, na_last = na_last, opts_collator = stri_opts_collator(locale, numeric = numeric, ...))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_split
list(`package:stringr` = function (string, pattern, n = Inf, simplify = FALSE) 
{
  if (identical(n, Inf)) 
    n <- -1
  switch(type(pattern), empty = stri_split_boundaries(string, n = n, simplify = simplify, opts_brkiter = opts(pattern)), bound = stri_split_boundaries(string, n = n, simplify = simplify, opts_brkiter = opts(pattern)), fixed = stri_split_fixed(string, pattern, n = n, simplify = simplify, opts_fixed = opts(pattern)), regex = stri_split_regex(string, pattern, n = n, simplify = simplify, opts_regex = opts(pattern)), coll = stri_split_coll(string, pattern, n = n, simplify = simplify, opts_collator = opts(pattern)))
}, function (string, pattern, n = Inf) 
{
  res <- strsplit(string, pattern)
  if (is.finite(n)) {
    res[seq_len(n)]
  }
  else {
    res
  }
}, function (string, pattern, n = Inf, simplify = FALSE) 
{
  if (identical(n, Inf)) 
    n <- -1
  switch(type(pattern), empty = stri_split_boundaries(string, n = n, simplify = simplify, opts_brkiter = opts(pattern)), bound = stri_split_boundaries(string, n = n, simplify = simplify, opts_brkiter = opts(pattern)), fixed = stri_split_fixed(string, pattern, n = n, simplify = simplify, opts_fixed = opts(pattern)), regex = stri_split_regex(string, pattern, n = n, simplify = simplify, opts_regex = opts(pattern)), coll = stri_split_coll(string, pattern, n = n, simplify = simplify, opts_collator = opts(pattern)))
})
c("package:stringr", "namespace:httr", "namespace:stringr")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
str_split_fixed
list(`package:stringr` = function (string, pattern, n) 
{
  out <- str_split(string, pattern, n = n, simplify = TRUE)
  out[is.na(out)] <- ""
  out
}, function (string, pattern, n) 
{
  if (length(string) == 0) 
    return(matrix(character(), nrow = 1, ncol = n))
  m <- gregexpr(pattern, string)[[1]]
  if (length(m) == 1 && m == -1) {
    res <- string
  }
  else {
    m_starts <- m
    m_ends <- m + attr(m, "match.length") - 1
    starts <- c(1, m_ends + 1)[seq_len(n)]
    ends <- c((m_starts - 1)[seq_len(n - 1)], nchar(string))
    res <- lapply(string, function(x) unlist(Map(substr, x, starts, ends, USE.NAMES = FALSE)))
  }
  mat <- matrix("", nrow = length(res), ncol = n, byrow = TRUE)
  mat[seq_along(unlist(res))] <- unlist(res)
  mat[, seq_len(n), drop = FALSE]
}, function (string, pattern, n) 
{
  out <- str_split(string, pattern, n = n, simplify = TRUE)
  out[is.na(out)] <- ""
  out
}, function (value, sep, n, extra = "warn", fill = "warn") 
{
  if (extra == "error") {
    warn(glue("`extra = \"error\"` is deprecated. \\\n       Please use `extra = \"warn\"` instead"))
    extra <- "warn"
  }
  extra <- arg_match(extra, c("warn", "merge", "drop"))
  fill <- arg_match(fill, c("warn", "left", "right"))
  n_max <- if (extra == "merge") 
    n
  else -1
  pieces <- str_split_n(value, sep, n_max = n_max)
  simp <- simplifyPieces(pieces, n, fill == "left")
  n_big <- length(simp$too_big)
  if (extra == "warn" && n_big > 0) {
    idx <- list_indices(simp$too_big)
    warn(glue("Expected {n} pieces. Additional pieces discarded in {n_big} rows [{idx}]."))
  }
  n_sml <- length(simp$too_sml)
  if (fill == "warn" && n_sml > 0) {
    idx <- list_indices(simp$too_sml)
    warn(glue("Expected {n} pieces. Missing pieces filled with `NA` in {n_sml} rows [{idx}]."))
  }
  simp$strings
})
c("package:stringr", "namespace:httr", "namespace:stringr", "namespace:tidyr")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, TRUE, FALSE)
str_squish
list(`package:stringr` = function (string) 
{
  stri_trim_both(str_replace_all(string, "\\s+", " "))
}, function (string) 
{
  stri_trim_both(str_replace_all(string, "\\s+", " "))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_starts
list(`package:stringr` = function (string, pattern, negate = FALSE) 
{
  switch(type(pattern), empty = , bound = stop("boundary() patterns are not supported."), fixed = stri_startswith_fixed(string, pattern, negate = negate, opts_fixed = opts(pattern)), coll = stri_startswith_coll(string, pattern, negate = negate, opts_collator = opts(pattern)), regex = {
    pattern2 <- paste0("^", pattern)
    attributes(pattern2) <- attributes(pattern)
    str_detect(string, pattern2, negate)
  })
}, function (string, pattern, negate = FALSE) 
{
  switch(type(pattern), empty = , bound = stop("boundary() patterns are not supported."), fixed = stri_startswith_fixed(string, pattern, negate = negate, opts_fixed = opts(pattern)), coll = stri_startswith_coll(string, pattern, negate = negate, opts_collator = opts(pattern)), regex = {
    pattern2 <- paste0("^", pattern)
    attributes(pattern2) <- attributes(pattern)
    str_detect(string, pattern2, negate)
  })
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_sub
list(`package:stringr` = function (string, start = 1, end = -1) 
{
  if (is.matrix(start)) {
    stri_sub(string, from = start)
  }
  else {
    stri_sub(string, from = start, to = end)
  }
}, function (string, start = 1, end = -1) 
{
  if (is.matrix(start)) {
    stri_sub(string, from = start)
  }
  else {
    stri_sub(string, from = start, to = end)
  }
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_sub<-
  list(`package:stringr` = function (string, start = 1, end = -1, omit_na = FALSE, value) 
  {
    if (is.matrix(start)) {
      stri_sub(string, from = start, omit_na = omit_na) <- value
    }
    else {
      stri_sub(string, from = start, to = end, omit_na = omit_na) <- value
    }
    string
  }, function (string, start = 1, end = -1, omit_na = FALSE, value) 
  {
    if (is.matrix(start)) {
      stri_sub(string, from = start, omit_na = omit_na) <- value
    }
    else {
      stri_sub(string, from = start, to = end, omit_na = omit_na) <- value
    }
    string
  })
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_subset
list(`package:stringr` = function (string, pattern, negate = FALSE) 
{
  switch(type(pattern), empty = , bound = string[str_detect(string, pattern) & !negate], fixed = stri_subset_fixed(string, pattern, omit_na = TRUE, negate = negate, opts_fixed = opts(pattern)), coll = stri_subset_coll(string, pattern, omit_na = TRUE, negate = negate, opts_collator = opts(pattern)), regex = stri_subset_regex(string, pattern, omit_na = TRUE, negate = negate, opts_regex = opts(pattern)))
}, function (string, pattern, negate = FALSE) 
{
  switch(type(pattern), empty = , bound = string[str_detect(string, pattern) & !negate], fixed = stri_subset_fixed(string, pattern, omit_na = TRUE, negate = negate, opts_fixed = opts(pattern)), coll = stri_subset_coll(string, pattern, omit_na = TRUE, negate = negate, opts_collator = opts(pattern)), regex = stri_subset_regex(string, pattern, omit_na = TRUE, negate = negate, opts_regex = opts(pattern)))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_to_lower
list(`package:stringr` = function (string, locale = "en") 
{
  stri_trans_tolower(string, locale = locale)
}, function (string, locale = "en") 
{
  stri_trans_tolower(string, locale = locale)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_to_sentence
list(`package:stringr` = function (string, locale = "en") 
{
  stri_trans_totitle(string, opts_brkiter = stri_opts_brkiter(type = "sentence", locale = locale))
}, function (string, locale = "en") 
{
  stri_trans_totitle(string, opts_brkiter = stri_opts_brkiter(type = "sentence", locale = locale))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_to_title
list(`package:stringr` = function (string, locale = "en") 
{
  stri_trans_totitle(string, opts_brkiter = stri_opts_brkiter(locale = locale))
}, function (string, locale = "en") 
{
  stri_trans_totitle(string, opts_brkiter = stri_opts_brkiter(locale = locale))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_to_upper
list(`package:stringr` = function (string, locale = "en") 
{
  stri_trans_toupper(string, locale = locale)
}, function (string, locale = "en") 
{
  stri_trans_toupper(string, locale = locale)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_trim
list(`package:stringr` = function (string, side = c("both", "left", "right")) 
{
  side <- match.arg(side)
  switch(side, left = stri_trim_left(string), right = stri_trim_right(string), both = stri_trim_both(string))
}, function (x) 
{
  gsub("(^\\s+)|(\\s+$)", "", x)
}, function (x) 
{
  sub("^\\s+", "", sub("\\s+$", "", x))
}, function (x) 
{
  sub("^\\s+", "", sub("\\s+$", "", x))
}, function (string, side = c("both", "left", "right")) 
{
  side <- match.arg(side)
  switch(side, left = stri_trim_left(string), right = stri_trim_right(string), both = stri_trim_both(string))
})
c("package:stringr", "namespace:httr", "namespace:processx", "namespace:cli", "namespace:stringr")
c(TRUE, FALSE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE, TRUE)
str_trunc
list(`package:stringr` = function (string, width, side = c("right", "left", "center"), ellipsis = "...") 
{
  side <- match.arg(side)
  too_long <- !is.na(string) & str_length(string) > width
  width... <- width - str_length(ellipsis)
  if (width... < 0) 
    stop("`width` is shorter than `ellipsis`", .call = FALSE)
  string[too_long] <- switch(side, right = str_c(str_sub(string[too_long], 1, width...), ellipsis), left = str_c(ellipsis, str_sub(string[too_long], -width..., -1)), center = str_c(str_sub(string[too_long], 1, ceiling(width.../2)), ellipsis, str_sub(string[too_long], -floor(width.../2), -1)))
  string
}, function (str, width = 0.9 * getOption("width"), ellipsis = "[...]") 
{
  str = as.character(str)
  ellipsis = assert_string(ellipsis)
  nc_ellipsis = nchar(ellipsis)
  width = assert_int(width, lower = nc_ellipsis)
  ind = (!is.na(str) & nchar(str) > width)
  replace(str, ind, paste0(substr(str[ind], 1, width - nc_ellipsis), ellipsis))
}, function (x, width) 
{
  if (nchar(x) <= width) {
    x
  }
  else {
    paste0(substr(x, 1, width - 3), "...")
  }
}, function (string, width, side = c("right", "left", "center"), ellipsis = "...") 
{
  side <- match.arg(side)
  too_long <- !is.na(string) & str_length(string) > width
  width... <- width - str_length(ellipsis)
  if (width... < 0) 
    stop("`width` is shorter than `ellipsis`", .call = FALSE)
  string[too_long] <- switch(side, right = str_c(str_sub(string[too_long], 1, width...), ellipsis), left = str_c(ellipsis, str_sub(string[too_long], -width..., -1)), center = str_c(str_sub(string[too_long], 1, ceiling(width.../2)), ellipsis, str_sub(string[too_long], -floor(width.../2), -1)))
  string
}, function (x, width, shorten = NULL) 
{
  if (all(is.infinite(width))) {
    return(x)
  }
  str_width <- get_extent(x)
  too_wide <- which(!is.na(x) & str_width > width)
  if (any(too_wide)) {
    x[too_wide] <- str_add_ellipsis(x[too_wide], str_width[too_wide], width, shorten)
  }
  x
})
c("package:stringr", "namespace:mlr3misc", "namespace:rvest", "namespace:stringr", "namespace:pillar")
c(TRUE, FALSE, FALSE, FALSE, FALSE)
c(FALSE, FALSE, FALSE, TRUE, FALSE)
str_view
list(`package:stringr` = function (string, pattern, match = NA) 
{
  if (identical(match, TRUE)) {
    string <- string[str_detect(string, pattern)]
  }
  else if (identical(match, FALSE)) {
    string <- string[!str_detect(string, pattern)]
  }
  loc <- str_locate(string, pattern)
  has_match <- !is.na(loc[, "start"])
  str_sub(string[has_match], loc[has_match, , drop = FALSE]) <- paste0("<span class='match'>", str_sub(string[has_match], loc[has_match, , drop = FALSE]), "</span>")
  str_view_widget(string)
}, function (string, pattern, match = NA) 
{
  if (identical(match, TRUE)) {
    string <- string[str_detect(string, pattern)]
  }
  else if (identical(match, FALSE)) {
    string <- string[!str_detect(string, pattern)]
  }
  loc <- str_locate(string, pattern)
  has_match <- !is.na(loc[, "start"])
  str_sub(string[has_match], loc[has_match, , drop = FALSE]) <- paste0("<span class='match'>", str_sub(string[has_match], loc[has_match, , drop = FALSE]), "</span>")
  str_view_widget(string)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_view_all
list(`package:stringr` = function (string, pattern, match = NA) 
{
  if (identical(match, TRUE)) {
    string <- string[str_detect(string, pattern)]
  }
  else if (identical(match, FALSE)) {
    string <- string[!str_detect(string, pattern)]
  }
  loc <- str_locate_all(string, pattern)
  string_list <- Map(loc = loc, string = string, function(loc, string) {
    if (nrow(loc) == 0) 
      return(string)
    for (i in rev(seq_len(nrow(loc)))) {
      str_sub(string, loc[i, , drop = FALSE]) <- paste0("<span class='match'>", str_sub(string, loc[i, , drop = FALSE]), "</span>")
    }
    string
  })
  string <- unlist(string_list)
  str_view_widget(string)
}, function (string, pattern, match = NA) 
{
  if (identical(match, TRUE)) {
    string <- string[str_detect(string, pattern)]
  }
  else if (identical(match, FALSE)) {
    string <- string[!str_detect(string, pattern)]
  }
  loc <- str_locate_all(string, pattern)
  string_list <- Map(loc = loc, string = string, function(loc, string) {
    if (nrow(loc) == 0) 
      return(string)
    for (i in rev(seq_len(nrow(loc)))) {
      str_sub(string, loc[i, , drop = FALSE]) <- paste0("<span class='match'>", str_sub(string, loc[i, , drop = FALSE]), "</span>")
    }
    string
  })
  string <- unlist(string_list)
  str_view_widget(string)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_which
list(`package:stringr` = function (string, pattern, negate = FALSE) 
{
  which(str_detect(string, pattern, negate = negate))
}, function (string, pattern, negate = FALSE) 
{
  which(str_detect(string, pattern, negate = negate))
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
str_wrap
list(`package:stringr` = function (string, width = 80, indent = 0, exdent = 0) 
{
  if (width <= 0) 
    width <- 1
  out <- stri_wrap(string, width = width, indent = indent, exdent = exdent, simplify = FALSE)
  vapply(out, str_c, collapse = "\n", character(1))
}, function (str, width = FALSE) 
{
  if (isFALSE(width)) {
    return(str)
  }
  if (isTRUE(width)) {
    width = as.integer(0.9 * getOption("width"))
  }
  else {
    assert_count(width)
  }
  paste0(strwrap(gsub("[[:space:]]+", " ", str), width = width), collapse = "\n")
}, function (string, width = 80, indent = 0, exdent = 0) 
{
  if (width <= 0) 
    width <- 1
  out <- stri_wrap(string, width = width, indent = indent, exdent = exdent, simplify = FALSE)
  vapply(out, str_c, collapse = "\n", character(1))
})
c("package:stringr", "namespace:mlr3misc", "namespace:stringr")
c(TRUE, FALSE, FALSE)
c(FALSE, FALSE, TRUE)
word
list(`package:stringr` = function (string, start = 1, end = start, sep = fixed(" ")) 
{
  n <- max(length(string), length(start), length(end))
  string <- rep(string, length.out = n)
  start <- rep(start, length.out = n)
  end <- rep(end, length.out = n)
  breaks <- str_locate_all(string, sep)
  words <- lapply(breaks, invert_match)
  len <- vapply(words, nrow, integer(1))
  neg_start <- !is.na(start) & start < 0
  start[neg_start] <- start[neg_start] + len[neg_start] + 1
  neg_end <- !is.na(end) & end < 0
  end[neg_end] <- end[neg_end] + len[neg_end] + 1
  start[start > len] <- NA
  end[end > len] <- NA
  starts <- mapply(function(word, loc) word[loc, "start"], words, start)
  ends <- mapply(function(word, loc) word[loc, "end"], words, end)
  str_sub(string, starts, ends)
}, function (string, start = 1, end = start, sep = fixed(" ")) 
{
  n <- max(length(string), length(start), length(end))
  string <- rep(string, length.out = n)
  start <- rep(start, length.out = n)
  end <- rep(end, length.out = n)
  breaks <- str_locate_all(string, sep)
  words <- lapply(breaks, invert_match)
  len <- vapply(words, nrow, integer(1))
  neg_start <- !is.na(start) & start < 0
  start[neg_start] <- start[neg_start] + len[neg_start] + 1
  neg_end <- !is.na(end) & end < 0
  end[neg_end] <- end[neg_end] + len[neg_end] + 1
  start[start > len] <- NA
  end[end > len] <- NA
  starts <- mapply(function(word, loc) word[loc, "start"], words, start)
  ends <- mapply(function(word, loc) word[loc, "end"], words, end)
  str_sub(string, starts, ends)
})
c("package:stringr", "namespace:stringr")
c(TRUE, FALSE)
c(FALSE, TRUE)
words
list(`package:stringr` = c("a", "able", "about", "absolute", "accept", "account", "achieve", "across", "act", "active", "actual", "add", "address", "admit", "advertise", "affect", "afford", "after", "afternoon", "again", "against", "age", "agent", "ago", "agree", "air", "all", "allow", "almost", "along", "already", "alright", "also", "although", "always", "america", "amount", "and", "another", "answer", "any", "apart", "apparent", "appear", "apply", "appoint", "approach", "appropriate", "area", "argue", 
                           "arm", "around", "arrange", "art", "as", "ask", "associate", "assume", "at", "attend", "authority", "available", "aware", "away", "awful", "baby", "back", "bad", "bag", "balance", "ball", "bank", "bar", "base", "basis", "be", "bear", "beat", "beauty", "because", "become", "bed", "before", "begin", "behind", "believe", "benefit", "best", "bet", "between", "big", "bill", "birth", "bit", "black", "bloke", "blood", "blow", "blue", "board", "boat", "body", "book", "both", "bother", "bottle", "bottom", 
                           "box", "boy", "break", "brief", "brilliant", "bring", "britain", "brother", "budget", "build", "bus", "business", "busy", "but", "buy", "by", "cake", "call", "can", "car", "card", "care", "carry", "case", "cat", "catch", "cause", "cent", "centre", "certain", "chair", "chairman", "chance", "change", "chap", "character", "charge", "cheap", "check", "child", "choice", "choose", "Christ", "Christmas", "church", "city", "claim", "class", "clean", "clear", "client", "clock", "close", "closes", "clothe", 
                           "club", "coffee", "cold", "colleague", "collect", "college", "colour", "come", "comment", "commit", "committee", "common", "community", "company", "compare", "complete", "compute", "concern", "condition", "confer", "consider", "consult", "contact", "continue", "contract", "control", "converse", "cook", "copy", "corner", "correct", "cost", "could", "council", "count", "country", "county", "couple", "course", "court", "cover", "create", "cross", "cup", "current", "cut", "dad", "danger", "date", "day", 
                           "dead", "deal", "dear", "debate", "decide", "decision", "deep", "definite", "degree", "department", "depend", "describe", "design", "detail", "develop", "die", "difference", "difficult", "dinner", "direct", "discuss", "district", "divide", "do", "doctor", "document", "dog", "door", "double", "doubt", "down", "draw", "dress", "drink", "drive", "drop", "dry", "due", "during", "each", "early", "east", "easy", "eat", "economy", "educate", "effect", "egg", "eight", "either", "elect", "electric", "eleven", 
                           "else", "employ", "encourage", "end", "engine", "english", "enjoy", "enough", "enter", "environment", "equal", "especial", "europe", "even", "evening", "ever", "every", "evidence", "exact", "example", "except", "excuse", "exercise", "exist", "expect", "expense", "experience", "explain", "express", "extra", "eye", "face", "fact", "fair", "fall", "family", "far", "farm", "fast", "father", "favour", "feed", "feel", "few", "field", "fight", "figure", "file", "fill", "film", "final", "finance", "find", 
                           "fine", "finish", "fire", "first", "fish", "fit", "five", "flat", "floor", "fly", "follow", "food", "foot", "for", "force", "forget", "form", "fortune", "forward", "four", "france", "free", "friday", "friend", "from", "front", "full", "fun", "function", "fund", "further", "future", "game", "garden", "gas", "general", "germany", "get", "girl", "give", "glass", "go", "god", "good", "goodbye", "govern", "grand", "grant", "great", "green", "ground", "group", "grow", "guess", "guy", "hair", "half", "hall", 
                           "hand", "hang", "happen", "happy", "hard", "hate", "have", "he", "head", "health", "hear", "heart", "heat", "heavy", "hell", "help", "here", "high", "history", "hit", "hold", "holiday", "home", "honest", "hope", "horse", "hospital", "hot", "hour", "house", "how", "however", "hullo", "hundred", "husband", "idea", "identify", "if", "imagine", "important", "improve", "in", "include", "income", "increase", "indeed", "individual", "industry", "inform", "inside", "instead", "insure", "interest", "into", 
                           "introduce", "invest", "involve", "issue", "it", "item", "jesus", "job", "join", "judge", "jump", "just", "keep", "key", "kid", "kill", "kind", "king", "kitchen", "knock", "know", "labour", "lad", "lady", "land", "language", "large", "last", "late", "laugh", "law", "lay", "lead", "learn", "leave", "left", "leg", "less", "let", "letter", "level", "lie", "life", "light", "like", "likely", "limit", "line", "link", "list", "listen", "little", "live", "load", "local", "lock", "london", "long", "look", 
                           "lord", "lose", "lot", "love", "low", "luck", "lunch", "machine", "main", "major", "make", "man", "manage", "many", "mark", "market", "marry", "match", "matter", "may", "maybe", "mean", "meaning", "measure", "meet", "member", "mention", "middle", "might", "mile", "milk", "million", "mind", "minister", "minus", "minute", "miss", "mister", "moment", "monday", "money", "month", "more", "morning", "most", "mother", "motion", "move", "mrs", "much", "music", "must", "name", "nation", "nature", "near", 
                           "necessary", "need", "never", "new", "news", "next", "nice", "night", "nine", "no", "non", "none", "normal", "north", "not", "note", "notice", "now", "number", "obvious", "occasion", "odd", "of", "off", "offer", "office", "often", "okay", "old", "on", "once", "one", "only", "open", "operate", "opportunity", "oppose", "or", "order", "organize", "original", "other", "otherwise", "ought", "out", "over", "own", "pack", "page", "paint", "pair", "paper", "paragraph", "pardon", "parent", "park", "part", 
                           "particular", "party", "pass", "past", "pay", "pence", "pension", "people", "per", "percent", "perfect", "perhaps", "period", "person", "photograph", "pick", "picture", "piece", "place", "plan", "play", "please", "plus", "point", "police", "policy", "politic", "poor", "position", "positive", "possible", "post", "pound", "power", "practise", "prepare", "present", "press", "pressure", "presume", "pretty", "previous", "price", "print", "private", "probable", "problem", "proceed", "process", "produce", 
                           "product", "programme", "project", "proper", "propose", "protect", "provide", "public", "pull", "purpose", "push", "put", "quality", "quarter", "question", "quick", "quid", "quiet", "quite", "radio", "rail", "raise", "range", "rate", "rather", "read", "ready", "real", "realise", "really", "reason", "receive", "recent", "reckon", "recognize", "recommend", "record", "red", "reduce", "refer", "regard", "region", "relation", "remember", "report", "represent", "require", "research", "resource", "respect", 
                           "responsible", "rest", "result", "return", "rid", "right", "ring", "rise", "road", "role", "roll", "room", "round", "rule", "run", "safe", "sale", "same", "saturday", "save", "say", "scheme", "school", "science", "score", "scotland", "seat", "second", "secretary", "section", "secure", "see", "seem", "self", "sell", "send", "sense", "separate", "serious", "serve", "service", "set", "settle", "seven", "sex", "shall", "share", "she", "sheet", "shoe", "shoot", "shop", "short", "should", "show", "shut", 
                           "sick", "side", "sign", "similar", "simple", "since", "sing", "single", "sir", "sister", "sit", "site", "situate", "six", "size", "sleep", "slight", "slow", "small", "smoke", "so", "social", "society", "some", "son", "soon", "sorry", "sort", "sound", "south", "space", "speak", "special", "specific", "speed", "spell", "spend", "square", "staff", "stage", "stairs", "stand", "standard", "start", "state", "station", "stay", "step", "stick", "still", "stop", "story", "straight", "strategy", "street", 
                           "strike", "strong", "structure", "student", "study", "stuff", "stupid", "subject", "succeed", "such", "sudden", "suggest", "suit", "summer", "sun", "sunday", "supply", "support", "suppose", "sure", "surprise", "switch", "system", "table", "take", "talk", "tape", "tax", "tea", "teach", "team", "telephone", "television", "tell", "ten", "tend", "term", "terrible", "test", "than", "thank", "the", "then", "there", "therefore", "they", "thing", "think", "thirteen", "thirty", "this", "thou", "though", "thousand", 
                           "three", "through", "throw", "thursday", "tie", "time", "to", "today", "together", "tomorrow", "tonight", "too", "top", "total", "touch", "toward", "town", "trade", "traffic", "train", "transport", "travel", "treat", "tree", "trouble", "true", "trust", "try", "tuesday", "turn", "twelve", "twenty", "two", "type", "under", "understand", "union", "unit", "unite", "university", "unless", "until", "up", "upon", "use", "usual", "value", "various", "very", "video", "view", "village", "visit", "vote", "wage", 
                           "wait", "walk", "wall", "want", "war", "warm", "wash", "waste", "watch", "water", "way", "we", "wear", "wednesday", "wee", "week", "weigh", "welcome", "well", "west", "what", "when", "where", "whether", "which", "while", "white", "who", "whole", "why", "wide", "wife", "will", "win", "wind", "window", "wish", "with", "within", "without", "woman", "wonder", "wood", "word", "work", "world", "worry", "worse", "worth", "would", "write", "wrong", "year", "yes", "yesterday", "yet", "you", "young"))
package:stringr
TRUE
FALSE

#################################################################################################
library(stringi)
%s!=%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_nequiv(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_nequiv(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s!==%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_neq(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_neq(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s$%
  list(`package:stringi` = function (e1, e2) 
  {
    if (!is.list(e2)) 
      e2 <- list(e2)
    na_string <- NA
    .Call(C_stri_sprintf, e1, e2, na_string, "Inf", "NaN", FALSE)
  }, function (e1, e2) 
  {
    if (!is.list(e2)) 
      e2 <- list(e2)
    na_string <- NA
    .Call(C_stri_sprintf, e1, e2, na_string, "Inf", "NaN", FALSE)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s*%
  list(`package:stringi` = function (e1, e2) 
  {
    .Call(C_stri_dup, e1, e2)
  }, function (e1, e2) 
  {
    .Call(C_stri_dup, e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s+%
  list(`package:stringi` = function (e1, e2) 
  {
    .Call(C_stri_join2, e1, e2)
  }, function (e1, e2) 
  {
    .Call(C_stri_join2, e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s<%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_lt(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_lt(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s<=%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_le(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_le(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s==%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_equiv(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_equiv(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s===%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_eq(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_eq(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s>%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_gt(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_gt(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%s>=%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_ge(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_ge(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri!=%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_nequiv(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_nequiv(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri!==%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_neq(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_neq(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri$%
  list(`package:stringi` = function (e1, e2) 
  {
    if (!is.list(e2)) 
      e2 <- list(e2)
    na_string <- NA
    .Call(C_stri_sprintf, e1, e2, na_string, "Inf", "NaN", FALSE)
  }, function (e1, e2) 
  {
    if (!is.list(e2)) 
      e2 <- list(e2)
    na_string <- NA
    .Call(C_stri_sprintf, e1, e2, na_string, "Inf", "NaN", FALSE)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri*%
  list(`package:stringi` = function (e1, e2) 
  {
    .Call(C_stri_dup, e1, e2)
  }, function (e1, e2) 
  {
    .Call(C_stri_dup, e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri+%
  list(`package:stringi` = function (e1, e2) 
  {
    .Call(C_stri_join2, e1, e2)
  }, function (e1, e2) 
  {
    .Call(C_stri_join2, e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri<%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_lt(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_lt(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri<=%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_le(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_le(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri==%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_equiv(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_equiv(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri===%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_eq(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_eq(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri>%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_gt(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_gt(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
%stri>=%
  list(`package:stringi` = function (e1, e2) 
  {
    stri_cmp_ge(e1, e2)
  }, function (e1, e2) 
  {
    stri_cmp_ge(e1, e2)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_c
list(`package:stringi` = function (..., sep = "", collapse = NULL, ignore_null = FALSE) 
{
  .Call(C_stri_join, list(...), sep, collapse, ignore_null)
}, function (..., sep = "", collapse = NULL, ignore_null = FALSE) 
{
  .Call(C_stri_join, list(...), sep, collapse, ignore_null)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_c_list
list(`package:stringi` = function (x, sep = "", collapse = NULL) 
{
  .Call(C_stri_join_list, x, sep, collapse)
}, function (x, sep = "", collapse = NULL) 
{
  .Call(C_stri_join_list, x, sep, collapse)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp
list(`package:stringi` = function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp, e1, e2, opts_collator)
}, function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp, e1, e2, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp_eq
list(`package:stringi` = function (e1, e2) 
{
  .Call(C_stri_cmp_eq, e1, e2)
}, function (e1, e2) 
{
  .Call(C_stri_cmp_eq, e1, e2)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp_equiv
list(`package:stringi` = function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_equiv, e1, e2, opts_collator)
}, function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_equiv, e1, e2, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp_ge
list(`package:stringi` = function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_ge, e1, e2, opts_collator)
}, function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_ge, e1, e2, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp_gt
list(`package:stringi` = function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_gt, e1, e2, opts_collator)
}, function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_gt, e1, e2, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp_le
list(`package:stringi` = function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_le, e1, e2, opts_collator)
}, function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_le, e1, e2, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp_lt
list(`package:stringi` = function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_lt, e1, e2, opts_collator)
}, function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_lt, e1, e2, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp_neq
list(`package:stringi` = function (e1, e2) 
{
  .Call(C_stri_cmp_neq, e1, e2)
}, function (e1, e2) 
{
  .Call(C_stri_cmp_neq, e1, e2)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_cmp_nequiv
list(`package:stringi` = function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_nequiv, e1, e2, opts_collator)
}, function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp_nequiv, e1, e2, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_coll
list(`package:stringi` = function (locale = NULL, strength = 3, alternate_shifted = FALSE, french = FALSE, uppercase_first = NA, case_level = FALSE, normalization = FALSE, normalisation = normalization, numeric = FALSE, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_collator`.")
  opts <- list()
  if (!missing(locale)) 
    opts["locale"] <- locale
  if (!missing(strength)) 
    opts["strength"] <- strength
  if (!missing(alternate_shifted)) 
    opts["alternate_shifted"] <- alternate_shifted
  if (!missing(french)) 
    opts["french"] <- french
  if (!missing(uppercase_first)) 
    opts["uppercase_first"] <- uppercase_first
  if (!missing(case_level)) 
    opts["case_level"] <- case_level
  if (!missing(numeric)) 
    opts["numeric"] <- numeric
  if (!missing(normalization)) 
    opts["normalization"] <- normalization
  else if (!missing(normalisation)) 
    opts["normalization"] <- normalisation
  opts
}, function (locale = NULL, strength = 3, alternate_shifted = FALSE, french = FALSE, uppercase_first = NA, case_level = FALSE, normalization = FALSE, normalisation = normalization, numeric = FALSE, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_collator`.")
  opts <- list()
  if (!missing(locale)) 
    opts["locale"] <- locale
  if (!missing(strength)) 
    opts["strength"] <- strength
  if (!missing(alternate_shifted)) 
    opts["alternate_shifted"] <- alternate_shifted
  if (!missing(french)) 
    opts["french"] <- french
  if (!missing(uppercase_first)) 
    opts["uppercase_first"] <- uppercase_first
  if (!missing(case_level)) 
    opts["case_level"] <- case_level
  if (!missing(numeric)) 
    opts["numeric"] <- numeric
  if (!missing(normalization)) 
    opts["normalization"] <- normalization
  else if (!missing(normalisation)) 
    opts["normalization"] <- normalisation
  opts
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_compare
list(`package:stringi` = function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp, e1, e2, opts_collator)
}, function (e1, e2, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_cmp, e1, e2, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_conv
list(`package:stringi` = function (str, from = NULL, to = NULL, to_raw = FALSE) 
{
  .Call(C_stri_encode, str, from, to, to_raw)
}, function (str, from = NULL, to = NULL, to_raw = FALSE) 
{
  .Call(C_stri_encode, str, from, to, to_raw)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_count
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_count_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_count_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_count_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_count_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_count_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_count_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_count_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_count_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_count_boundaries
list(`package:stringi` = function (str, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_count_boundaries, str, opts_brkiter)
}, function (str, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_count_boundaries, str, opts_brkiter)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_count_charclass
list(`package:stringi` = function (str, pattern) 
{
  .Call(C_stri_count_charclass, str, pattern)
}, function (str, pattern) 
{
  .Call(C_stri_count_charclass, str, pattern)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_count_coll
list(`package:stringi` = function (str, pattern, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_count_coll, str, pattern, opts_collator)
}, function (str, pattern, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_count_coll, str, pattern, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_count_fixed
list(`package:stringi` = function (str, pattern, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_count_fixed, str, pattern, opts_fixed)
}, function (str, pattern, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_count_fixed, str, pattern, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_count_regex
list(`package:stringi` = function (str, pattern, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_count_regex, str, pattern, opts_regex)
}, function (str, pattern, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_count_regex, str, pattern, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_count_words
list(`package:stringi` = function (str, locale = NULL) 
{
  stri_count_boundaries(str, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
}, function (str, locale = NULL) 
{
  stri_count_boundaries(str, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_add
list(`package:stringi` = function (time, value = 1, units = "seconds", tz = NULL, locale = NULL) 
{
  .Call(C_stri_datetime_add, time, value, units, tz, locale)
}, function (time, value = 1, units = "seconds", tz = NULL, locale = NULL) 
{
  .Call(C_stri_datetime_add, time, value, units, tz, locale)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_add<-
  list(`package:stringi` = function (time, units = "seconds", tz = NULL, locale = NULL, value) 
  {
    .Call(C_stri_datetime_add, time, value, units, tz, locale)
  }, function (time, units = "seconds", tz = NULL, locale = NULL, value) 
  {
    .Call(C_stri_datetime_add, time, value, units, tz, locale)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_create
list(`package:stringi` = function (year, month, day, hour = 12, minute = 0, second = 0, lenient = FALSE, tz = NULL, locale = NULL) 
{
  .Call(C_stri_datetime_create, year, month, day, hour, minute, second, lenient, tz, locale)
}, function (year, month, day, hour = 12, minute = 0, second = 0, lenient = FALSE, tz = NULL, locale = NULL) 
{
  .Call(C_stri_datetime_create, year, month, day, hour, minute, second, lenient, tz, locale)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_fields
list(`package:stringi` = function (time, tz = attr(time, "tzone"), locale = NULL) 
{
  as.data.frame(.Call(C_stri_datetime_fields, time, tz, locale))
}, function (time, tz = attr(time, "tzone"), locale = NULL) 
{
  as.data.frame(.Call(C_stri_datetime_fields, time, tz, locale))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_format
list(`package:stringi` = function (time, format = "uuuu-MM-dd HH:mm:ss", tz = NULL, locale = NULL) 
{
  .Call(C_stri_datetime_format, time, format, tz, locale)
}, function (time, format = "uuuu-MM-dd HH:mm:ss", tz = NULL, locale = NULL) 
{
  .Call(C_stri_datetime_format, time, format, tz, locale)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_fstr
list(`package:stringi` = function (x, ignore_special = TRUE) 
{
  x <- .Call(C_stri_datetime_fstr, x)
  ignore_special <- (is.logical(ignore_special) && length(ignore_special) == 1 && !is.na(ignore_special) && ignore_special)
  if (length(x) > 0 && !ignore_special) {
    formats <- outer(c("date", "time", "datetime", "date_relative", "datetime_relative"), c("full", "long", "medium", "short"), stri_paste, sep = "_")
    which_p <- match(x, stringi::stri_sprintf("'%s'", formats))
    x[which(!is.na(which_p))] <- formats[which_p[!is.na(which_p)]]
  }
  x
}, function (x, ignore_special = TRUE) 
{
  x <- .Call(C_stri_datetime_fstr, x)
  ignore_special <- (is.logical(ignore_special) && length(ignore_special) == 1 && !is.na(ignore_special) && ignore_special)
  if (length(x) > 0 && !ignore_special) {
    formats <- outer(c("date", "time", "datetime", "date_relative", "datetime_relative"), c("full", "long", "medium", "short"), stri_paste, sep = "_")
    which_p <- match(x, stringi::stri_sprintf("'%s'", formats))
    x[which(!is.na(which_p))] <- formats[which_p[!is.na(which_p)]]
  }
  x
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_now
list(`package:stringi` = function () 
{
  .Call(C_stri_datetime_now)
}, function () 
{
  .Call(C_stri_datetime_now)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_parse
list(`package:stringi` = function (str, format = "uuuu-MM-dd HH:mm:ss", lenient = FALSE, tz = NULL, locale = NULL) 
{
  .Call(C_stri_datetime_parse, str, format, lenient, tz, locale)
}, function (str, format = "uuuu-MM-dd HH:mm:ss", lenient = FALSE, tz = NULL, locale = NULL) 
{
  .Call(C_stri_datetime_parse, str, format, lenient, tz, locale)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_datetime_symbols
list(`package:stringi` = function (locale = NULL, context = "standalone", width = "wide") 
{
  .Call(C_stri_datetime_symbols, locale, context, width)
}, function (locale = NULL, context = "standalone", width = "wide") 
{
  .Call(C_stri_datetime_symbols, locale, context, width)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_detect
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify one of: `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_detect_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_detect_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_detect_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_detect_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify one of: `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_detect_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_detect_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_detect_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_detect_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_detect_charclass
list(`package:stringi` = function (str, pattern, negate = FALSE, max_count = -1) 
{
  .Call(C_stri_detect_charclass, str, pattern, negate, max_count)
}, function (str, pattern, negate = FALSE, max_count = -1) 
{
  .Call(C_stri_detect_charclass, str, pattern, negate, max_count)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_detect_coll
list(`package:stringi` = function (str, pattern, negate = FALSE, max_count = -1, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_detect_coll, str, pattern, negate, max_count, opts_collator)
}, function (str, pattern, negate = FALSE, max_count = -1, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_detect_coll, str, pattern, negate, max_count, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_detect_fixed
list(`package:stringi` = function (str, pattern, negate = FALSE, max_count = -1, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_detect_fixed, str, pattern, negate, max_count, opts_fixed)
}, function (str, pattern, negate = FALSE, max_count = -1, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_detect_fixed, str, pattern, negate, max_count, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_detect_regex
list(`package:stringi` = function (str, pattern, negate = FALSE, max_count = -1, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_detect_regex, str, pattern, negate, max_count, opts_regex)
}, function (str, pattern, negate = FALSE, max_count = -1, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_detect_regex, str, pattern, negate, max_count, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_dup
list(`package:stringi` = function (str, times) 
{
  .Call(C_stri_dup, str, times)
}, function (str, times) 
{
  .Call(C_stri_dup, str, times)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_duplicated
list(`package:stringi` = function (str, from_last = FALSE, fromLast = from_last, ..., opts_collator = NULL) 
{
  if (!missing(fromLast)) 
    from_last <- fromLast
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_duplicated, str, from_last, opts_collator)
}, function (str, from_last = FALSE, fromLast = from_last, ..., opts_collator = NULL) 
{
  if (!missing(fromLast)) 
    from_last <- fromLast
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_duplicated, str, from_last, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_duplicated_any
list(`package:stringi` = function (str, from_last = FALSE, fromLast = from_last, ..., opts_collator = NULL) 
{
  if (!missing(fromLast)) 
    from_last <- fromLast
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_duplicated_any, str, from_last, opts_collator)
}, function (str, from_last = FALSE, fromLast = from_last, ..., opts_collator = NULL) 
{
  if (!missing(fromLast)) 
    from_last <- fromLast
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_duplicated_any, str, from_last, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_detect
list(`package:stringi` = function (str, filter_angle_brackets = FALSE) 
{
  lapply(.Call(C_stri_enc_detect, str, filter_angle_brackets), as.data.frame, stringsAsFactors = FALSE)
}, function (str, filter_angle_brackets = FALSE) 
{
  lapply(.Call(C_stri_enc_detect, str, filter_angle_brackets), as.data.frame, stringsAsFactors = FALSE)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_detect2
list(`package:stringi` = function (str, locale = NULL) 
{
  suppressWarnings(lapply(.Call(C_stri_enc_detect2, str, locale), as.data.frame, stringsAsFactors = FALSE))
}, function (str, locale = NULL) 
{
  suppressWarnings(lapply(.Call(C_stri_enc_detect2, str, locale), as.data.frame, stringsAsFactors = FALSE))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_fromutf32
list(`package:stringi` = function (vec) 
{
  .Call(C_stri_enc_fromutf32, vec)
}, function (vec) 
{
  .Call(C_stri_enc_fromutf32, vec)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_get
list(`package:stringi` = function () 
{
  stri_enc_info(NULL)$Name.friendly
}, function () 
{
  stri_enc_info(NULL)$Name.friendly
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_info
list(`package:stringi` = function (enc = NULL) 
{
  .Call(C_stri_enc_info, enc)
}, function (enc = NULL) 
{
  .Call(C_stri_enc_info, enc)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_isascii
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_isascii, str)
}, function (str) 
{
  .Call(C_stri_enc_isascii, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_isutf16be
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_isutf16be, str)
}, function (str) 
{
  .Call(C_stri_enc_isutf16be, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_isutf16le
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_isutf16le, str)
}, function (str) 
{
  .Call(C_stri_enc_isutf16le, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_isutf32be
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_isutf32be, str)
}, function (str) 
{
  .Call(C_stri_enc_isutf32be, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_isutf32le
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_isutf32le, str)
}, function (str) 
{
  .Call(C_stri_enc_isutf32le, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_isutf8
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_isutf8, str)
}, function (str) 
{
  .Call(C_stri_enc_isutf8, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_list
list(`package:stringi` = function (simplify = TRUE) 
{
  simplify <- (is.logical(simplify) && length(simplify) == 1 && !is.na(simplify) && simplify)
  ret <- .Call(C_stri_enc_list)
  if (simplify) {
    stri_sort(unique(unlist(ret)), locale = "en_US", numeric = TRUE, strength = 1)
  }
  else {
    lapply(ret[stri_order(names(ret), locale = "en_US", numeric = TRUE, strength = 1)], stri_sort, locale = "en_US", numeric = TRUE, strength = 1)
  }
}, function (simplify = TRUE) 
{
  simplify <- (is.logical(simplify) && length(simplify) == 1 && !is.na(simplify) && simplify)
  ret <- .Call(C_stri_enc_list)
  if (simplify) {
    stri_sort(unique(unlist(ret)), locale = "en_US", numeric = TRUE, strength = 1)
  }
  else {
    lapply(ret[stri_order(names(ret), locale = "en_US", numeric = TRUE, strength = 1)], stri_sort, locale = "en_US", numeric = TRUE, strength = 1)
  }
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_mark
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_mark, str)
}, function (str) 
{
  .Call(C_stri_enc_mark, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_set
list(`package:stringi` = function (enc) 
{
  previous <- stri_enc_get()
  .Call(C_stri_enc_set, enc)
  message(stri_paste("New settings: ", stri_info(short = TRUE)))
  invisible(previous)
}, function (enc) 
{
  previous <- stri_enc_get()
  .Call(C_stri_enc_set, enc)
  message(stri_paste("New settings: ", stri_info(short = TRUE)))
  invisible(previous)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_toascii
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_toascii, str)
}, function (str) 
{
  .Call(C_stri_enc_toascii, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_tonative
list(`package:stringi` = function (str) 
{
  stri_encode(str, NULL, NULL)
}, function (str) 
{
  stri_encode(str, NULL, NULL)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_toutf32
list(`package:stringi` = function (str) 
{
  .Call(C_stri_enc_toutf32, str)
}, function (str) 
{
  .Call(C_stri_enc_toutf32, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_enc_toutf8
list(`package:stringi` = function (str, is_unknown_8bit = FALSE, validate = FALSE) 
{
  .Call(C_stri_enc_toutf8, str, is_unknown_8bit, validate)
}, function (str, is_unknown_8bit = FALSE, validate = FALSE) 
{
  .Call(C_stri_enc_toutf8, str, is_unknown_8bit, validate)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_encode
list(`package:stringi` = function (str, from = NULL, to = NULL, to_raw = FALSE) 
{
  .Call(C_stri_encode, str, from, to, to_raw)
}, function (str, from = NULL, to = NULL, to_raw = FALSE) 
{
  .Call(C_stri_encode, str, from, to, to_raw)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_endswith
list(`package:stringi` = function (str, ..., fixed, coll, charclass) 
{
  providedarg <- c(fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `fixed`, `coll`, or `charclass`")
  if (providedarg["fixed"]) 
    stri_endswith_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_endswith_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_endswith_charclass(str, charclass, ...)
}, function (str, ..., fixed, coll, charclass) 
{
  providedarg <- c(fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `fixed`, `coll`, or `charclass`")
  if (providedarg["fixed"]) 
    stri_endswith_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_endswith_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_endswith_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_endswith_charclass
list(`package:stringi` = function (str, pattern, to = -1, negate = FALSE) 
{
  .Call(C_stri_endswith_charclass, str, pattern, to, negate)
}, function (str, pattern, to = -1, negate = FALSE) 
{
  .Call(C_stri_endswith_charclass, str, pattern, to, negate)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_endswith_coll
list(`package:stringi` = function (str, pattern, to = -1, negate = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_endswith_coll, str, pattern, to, negate, opts_collator)
}, function (str, pattern, to = -1, negate = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_endswith_coll, str, pattern, to, negate, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_endswith_fixed
list(`package:stringi` = function (str, pattern, to = -1, negate = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_endswith_fixed, str, pattern, to, negate, opts_fixed)
}, function (str, pattern, to = -1, negate = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_endswith_fixed, str, pattern, to, negate, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_escape_unicode
list(`package:stringi` = function (str) 
{
  .Call(C_stri_escape_unicode, str)
}, function (str) 
{
  .Call(C_stri_escape_unicode, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass, mode = c("first", "all", "last")) 
{
  mode <- match.arg(mode)
  switch(mode, first = stri_extract_first(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), last = stri_extract_last(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), all = stri_extract_all(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass))
}, function (str, ..., regex, fixed, coll, charclass, mode = c("first", "all", "last")) 
{
  mode <- match.arg(mode)
  switch(mode, first = stri_extract_first(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), last = stri_extract_last(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), all = stri_extract_all(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_all
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_extract_all_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_extract_all_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_extract_all_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_extract_all_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_extract_all_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_extract_all_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_extract_all_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_extract_all_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_all_boundaries
list(`package:stringi` = function (str, simplify = FALSE, omit_no_match = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_extract_all_boundaries, str, simplify, omit_no_match, opts_brkiter)
}, function (str, simplify = FALSE, omit_no_match = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_extract_all_boundaries, str, simplify, omit_no_match, opts_brkiter)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_all_charclass
list(`package:stringi` = function (str, pattern, merge = TRUE, simplify = FALSE, omit_no_match = FALSE) 
{
  .Call(C_stri_extract_all_charclass, str, pattern, merge, simplify, omit_no_match)
}, function (str, pattern, merge = TRUE, simplify = FALSE, omit_no_match = FALSE) 
{
  .Call(C_stri_extract_all_charclass, str, pattern, merge, simplify, omit_no_match)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_all_coll
list(`package:stringi` = function (str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_extract_all_coll, str, pattern, simplify, omit_no_match, opts_collator)
}, function (str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_extract_all_coll, str, pattern, simplify, omit_no_match, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_all_fixed
list(`package:stringi` = function (str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_extract_all_fixed, str, pattern, simplify, omit_no_match, opts_fixed)
}, function (str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_extract_all_fixed, str, pattern, simplify, omit_no_match, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_all_regex
list(`package:stringi` = function (str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_extract_all_regex, str, pattern, simplify, omit_no_match, opts_regex)
}, function (str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_extract_all_regex, str, pattern, simplify, omit_no_match, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_all_words
list(`package:stringi` = function (str, simplify = FALSE, omit_no_match = FALSE, locale = NULL) 
{
  stri_extract_all_boundaries(str, simplify, omit_no_match, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
}, function (str, simplify = FALSE, omit_no_match = FALSE, locale = NULL) 
{
  stri_extract_all_boundaries(str, simplify, omit_no_match, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_first
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_extract_first_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_extract_first_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_extract_first_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_extract_first_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_extract_first_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_extract_first_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_extract_first_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_extract_first_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_first_boundaries
list(`package:stringi` = function (str, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_extract_first_boundaries, str, opts_brkiter)
}, function (str, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_extract_first_boundaries, str, opts_brkiter)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_first_charclass
list(`package:stringi` = function (str, pattern) 
{
  .Call(C_stri_extract_first_charclass, str, pattern)
}, function (str, pattern) 
{
  .Call(C_stri_extract_first_charclass, str, pattern)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_first_coll
list(`package:stringi` = function (str, pattern, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_extract_first_coll, str, pattern, opts_collator)
}, function (str, pattern, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_extract_first_coll, str, pattern, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_first_fixed
list(`package:stringi` = function (str, pattern, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_extract_first_fixed, str, pattern, opts_fixed)
}, function (str, pattern, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_extract_first_fixed, str, pattern, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_first_regex
list(`package:stringi` = function (str, pattern, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_extract_first_regex, str, pattern, opts_regex)
}, function (str, pattern, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_extract_first_regex, str, pattern, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_first_words
list(`package:stringi` = function (str, locale = NULL) 
{
  stri_extract_first_boundaries(str, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
}, function (str, locale = NULL) 
{
  stri_extract_first_boundaries(str, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_last
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_extract_last_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_extract_last_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_extract_last_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_extract_last_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_extract_last_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_extract_last_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_extract_last_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_extract_last_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_last_boundaries
list(`package:stringi` = function (str, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_extract_last_boundaries, str, opts_brkiter)
}, function (str, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_extract_last_boundaries, str, opts_brkiter)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_last_charclass
list(`package:stringi` = function (str, pattern) 
{
  .Call(C_stri_extract_last_charclass, str, pattern)
}, function (str, pattern) 
{
  .Call(C_stri_extract_last_charclass, str, pattern)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_last_coll
list(`package:stringi` = function (str, pattern, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_extract_last_coll, str, pattern, opts_collator)
}, function (str, pattern, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_extract_last_coll, str, pattern, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_last_fixed
list(`package:stringi` = function (str, pattern, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_extract_last_fixed, str, pattern, opts_fixed)
}, function (str, pattern, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_extract_last_fixed, str, pattern, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_last_regex
list(`package:stringi` = function (str, pattern, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_extract_last_regex, str, pattern, opts_regex)
}, function (str, pattern, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_extract_last_regex, str, pattern, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_extract_last_words
list(`package:stringi` = function (str, locale = NULL) 
{
  stri_extract_last_boundaries(str, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
}, function (str, locale = NULL) 
{
  stri_extract_last_boundaries(str, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_flatten
list(`package:stringi` = function (str, collapse = "", na_empty = FALSE, omit_empty = FALSE) 
{
  .Call(C_stri_flatten, str, collapse, na_empty, omit_empty)
}, function (str, collapse = "", na_empty = FALSE, omit_empty = FALSE) 
{
  .Call(C_stri_flatten, str, collapse, na_empty, omit_empty)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_info
list(`package:stringi` = function (short = FALSE) 
{
  stopifnot(is.logical(short), length(short) == 1)
  info <- .Call(C_stri_info)
  if (info$Charset.native$Name.friendly != "UTF-8") {
    if (!identical(info$Charset.native$ASCII.subset, TRUE)) 
      warning(stri_paste("Your native charset is not a superset of US-ASCII. ", "This may cause serious problems. Consider switching to UTF-8."))
    else if (!identical(info$Charset.native$Unicode.1to1, TRUE)) 
      warning(stri_paste("Your native charset does not map to Unicode well. ", "This may cause serious problems. Consider switching to UTF-8."))
  }
  loclist <- stri_locale_list()
  if (!(info$Locale$Name %in% loclist)) 
    warning(stri_paste("Your current locale is not in the list of available ", "locales. Some functions may not work properly. ", "Refer to stri_locale_list() for more details ", "on known locale specifiers."))
  if (!short) 
    return(info)
  else {
    locale <- info$Locale$Name
    charset <- info$Charset.native$Name.friendly
    return(sprintf("stringi_%s (%s.%s; ICU4C %s [%s%s]; Unicode %s)", as.character(packageVersion("stringi")), locale, charset, info$ICU.version, if (info$ICU.system) "system" else "bundle", if (info$ICU.UTF8) "#U_CHARSET_IS_UTF8" else "", info$Unicode.version))
  }
}, function (short = FALSE) 
{
  stopifnot(is.logical(short), length(short) == 1)
  info <- .Call(C_stri_info)
  if (info$Charset.native$Name.friendly != "UTF-8") {
    if (!identical(info$Charset.native$ASCII.subset, TRUE)) 
      warning(stri_paste("Your native charset is not a superset of US-ASCII. ", "This may cause serious problems. Consider switching to UTF-8."))
    else if (!identical(info$Charset.native$Unicode.1to1, TRUE)) 
      warning(stri_paste("Your native charset does not map to Unicode well. ", "This may cause serious problems. Consider switching to UTF-8."))
  }
  loclist <- stri_locale_list()
  if (!(info$Locale$Name %in% loclist)) 
    warning(stri_paste("Your current locale is not in the list of available ", "locales. Some functions may not work properly. ", "Refer to stri_locale_list() for more details ", "on known locale specifiers."))
  if (!short) 
    return(info)
  else {
    locale <- info$Locale$Name
    charset <- info$Charset.native$Name.friendly
    return(sprintf("stringi_%s (%s.%s; ICU4C %s [%s%s]; Unicode %s)", as.character(packageVersion("stringi")), locale, charset, info$ICU.version, if (info$ICU.system) "system" else "bundle", if (info$ICU.UTF8) "#U_CHARSET_IS_UTF8" else "", info$Unicode.version))
  }
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_isempty
list(`package:stringi` = function (str) 
{
  .Call(C_stri_isempty, str)
}, function (str) 
{
  .Call(C_stri_isempty, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_join
list(`package:stringi` = function (..., sep = "", collapse = NULL, ignore_null = FALSE) 
{
  .Call(C_stri_join, list(...), sep, collapse, ignore_null)
}, function (..., sep = "", collapse = NULL, ignore_null = FALSE) 
{
  .Call(C_stri_join, list(...), sep, collapse, ignore_null)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_join_list
list(`package:stringi` = function (x, sep = "", collapse = NULL) 
{
  .Call(C_stri_join_list, x, sep, collapse)
}, function (x, sep = "", collapse = NULL) 
{
  .Call(C_stri_join_list, x, sep, collapse)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_length
list(`package:stringi` = function (str) 
{
  .Call(C_stri_length, str)
}, function (str) 
{
  .Call(C_stri_length, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_list2matrix
list(`package:stringi` = function (x, byrow = FALSE, fill = NA, n_min = 0, by_row = byrow) 
{
  if (!missing(by_row)) 
    byrow <- by_row
  .Call(C_stri_list2matrix, x, byrow, stri_enc_toutf8(fill), n_min)
}, function (x, byrow = FALSE, fill = NA, n_min = 0, by_row = byrow) 
{
  if (!missing(by_row)) 
    byrow <- by_row
  .Call(C_stri_list2matrix, x, byrow, stri_enc_toutf8(fill), n_min)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locale_get
list(`package:stringi` = function () 
{
  stri_locale_info(NULL)$Name
}, function () 
{
  stri_locale_info(NULL)$Name
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locale_info
list(`package:stringi` = function (locale = NULL) 
{
  .Call(C_stri_locale_info, locale)
}, function (locale = NULL) 
{
  .Call(C_stri_locale_info, locale)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locale_list
list(`package:stringi` = function () 
{
  stri_sort(.Call(C_stri_locale_list), locale = "en_US", numeric = TRUE, strength = 1)
}, function () 
{
  stri_sort(.Call(C_stri_locale_list), locale = "en_US", numeric = TRUE, strength = 1)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locale_set
list(`package:stringi` = function (locale) 
{
  previous <- stri_locale_get()
  .Call(C_stri_locale_set, locale)
  message(stri_paste("You are now working with ", stri_info(short = TRUE)))
  invisible(previous)
}, function (locale) 
{
  previous <- stri_locale_get()
  .Call(C_stri_locale_set, locale)
  message(stri_paste("You are now working with ", stri_info(short = TRUE)))
  invisible(previous)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass, mode = c("first", "all", "last")) 
{
  mode <- match.arg(mode)
  switch(mode, first = stri_locate_first(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), last = stri_locate_last(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), all = stri_locate_all(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass))
}, function (str, ..., regex, fixed, coll, charclass, mode = c("first", "all", "last")) 
{
  mode <- match.arg(mode)
  switch(mode, first = stri_locate_first(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), last = stri_locate_last(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), all = stri_locate_all(str, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_all
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_locate_all_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_locate_all_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_locate_all_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_locate_all_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_locate_all_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_locate_all_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_locate_all_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_locate_all_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_all_boundaries
list(`package:stringi` = function (str, omit_no_match = FALSE, get_length = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_locate_all_boundaries, str, omit_no_match, opts_brkiter, get_length)
}, function (str, omit_no_match = FALSE, get_length = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_locate_all_boundaries, str, omit_no_match, opts_brkiter, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_all_charclass
list(`package:stringi` = function (str, pattern, merge = TRUE, omit_no_match = FALSE, get_length = FALSE) 
{
  .Call(C_stri_locate_all_charclass, str, pattern, merge, omit_no_match, get_length)
}, function (str, pattern, merge = TRUE, omit_no_match = FALSE, get_length = FALSE) 
{
  .Call(C_stri_locate_all_charclass, str, pattern, merge, omit_no_match, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_all_coll
list(`package:stringi` = function (str, pattern, omit_no_match = FALSE, get_length = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_locate_all_coll, str, pattern, omit_no_match, opts_collator, get_length)
}, function (str, pattern, omit_no_match = FALSE, get_length = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_locate_all_coll, str, pattern, omit_no_match, opts_collator, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_all_fixed
list(`package:stringi` = function (str, pattern, omit_no_match = FALSE, get_length = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_locate_all_fixed, str, pattern, omit_no_match, opts_fixed, get_length)
}, function (str, pattern, omit_no_match = FALSE, get_length = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_locate_all_fixed, str, pattern, omit_no_match, opts_fixed, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_all_regex
list(`package:stringi` = function (str, pattern, omit_no_match = FALSE, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_locate_all_regex, str, pattern, omit_no_match, opts_regex, capture_groups, get_length)
}, function (str, pattern, omit_no_match = FALSE, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_locate_all_regex, str, pattern, omit_no_match, opts_regex, capture_groups, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_all_words
list(`package:stringi` = function (str, omit_no_match = FALSE, locale = NULL, get_length = FALSE) 
{
  stri_locate_all_boundaries(str, omit_no_match = omit_no_match, get_length = get_length, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
}, function (str, omit_no_match = FALSE, locale = NULL, get_length = FALSE) 
{
  stri_locate_all_boundaries(str, omit_no_match = omit_no_match, get_length = get_length, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_first
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_locate_first_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_locate_first_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_locate_first_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_locate_first_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_locate_first_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_locate_first_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_locate_first_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_locate_first_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_first_boundaries
list(`package:stringi` = function (str, get_length = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_locate_first_boundaries, str, opts_brkiter, get_length)
}, function (str, get_length = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_locate_first_boundaries, str, opts_brkiter, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_first_charclass
list(`package:stringi` = function (str, pattern, get_length = FALSE) 
{
  .Call(C_stri_locate_first_charclass, str, pattern, get_length)
}, function (str, pattern, get_length = FALSE) 
{
  .Call(C_stri_locate_first_charclass, str, pattern, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_first_coll
list(`package:stringi` = function (str, pattern, get_length = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_locate_first_coll, str, pattern, opts_collator, get_length)
}, function (str, pattern, get_length = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_locate_first_coll, str, pattern, opts_collator, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_first_fixed
list(`package:stringi` = function (str, pattern, get_length = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_locate_first_fixed, str, pattern, opts_fixed, get_length)
}, function (str, pattern, get_length = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_locate_first_fixed, str, pattern, opts_fixed, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_first_regex
list(`package:stringi` = function (str, pattern, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_locate_first_regex, str, pattern, opts_regex, capture_groups, get_length)
}, function (str, pattern, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_locate_first_regex, str, pattern, opts_regex, capture_groups, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_first_words
list(`package:stringi` = function (str, locale = NULL, get_length = FALSE) 
{
  stri_locate_first_boundaries(str, get_length = get_length, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
}, function (str, locale = NULL, get_length = FALSE) 
{
  stri_locate_first_boundaries(str, get_length = get_length, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_last
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_locate_last_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_locate_last_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_locate_last_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_locate_last_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_locate_last_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_locate_last_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_locate_last_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_locate_last_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_last_boundaries
list(`package:stringi` = function (str, get_length = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_locate_last_boundaries, str, opts_brkiter, get_length)
}, function (str, get_length = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_locate_last_boundaries, str, opts_brkiter, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_last_charclass
list(`package:stringi` = function (str, pattern, get_length = FALSE) 
{
  .Call(C_stri_locate_last_charclass, str, pattern, get_length)
}, function (str, pattern, get_length = FALSE) 
{
  .Call(C_stri_locate_last_charclass, str, pattern, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_last_coll
list(`package:stringi` = function (str, pattern, get_length = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_locate_last_coll, str, pattern, opts_collator, get_length)
}, function (str, pattern, get_length = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_locate_last_coll, str, pattern, opts_collator, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_last_fixed
list(`package:stringi` = function (str, pattern, get_length = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_locate_last_fixed, str, pattern, opts_fixed, get_length)
}, function (str, pattern, get_length = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_locate_last_fixed, str, pattern, opts_fixed, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_last_regex
list(`package:stringi` = function (str, pattern, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_locate_last_regex, str, pattern, opts_regex, capture_groups, get_length)
}, function (str, pattern, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_locate_last_regex, str, pattern, opts_regex, capture_groups, get_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_locate_last_words
list(`package:stringi` = function (str, locale = NULL, get_length = FALSE) 
{
  stri_locate_last_boundaries(str, get_length = get_length, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
}, function (str, locale = NULL, get_length = FALSE) 
{
  stri_locate_last_boundaries(str, get_length = get_length, opts_brkiter = stri_opts_brkiter(type = "word", skip_word_none = TRUE, locale = locale))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_match
list(`package:stringi` = function (str, ..., regex, mode = c("first", "all", "last")) 
{
  mode <- match.arg(mode)
  switch(mode, first = stri_match_first_regex(str, regex, ...), last = stri_match_last_regex(str, regex, ...), all = stri_match_all_regex(str, regex, ...))
}, function (str, ..., regex, mode = c("first", "all", "last")) 
{
  mode <- match.arg(mode)
  switch(mode, first = stri_match_first_regex(str, regex, ...), last = stri_match_last_regex(str, regex, ...), all = stri_match_all_regex(str, regex, ...))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_match_all
list(`package:stringi` = function (str, ..., regex) 
{
  stri_match_all_regex(str, regex, ...)
}, function (str, ..., regex) 
{
  stri_match_all_regex(str, regex, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_match_all_regex
list(`package:stringi` = function (str, pattern, omit_no_match = FALSE, cg_missing = NA, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_match_all_regex, str, pattern, omit_no_match, cg_missing, opts_regex)
}, function (str, pattern, omit_no_match = FALSE, cg_missing = NA, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_match_all_regex, str, pattern, omit_no_match, cg_missing, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_match_first
list(`package:stringi` = function (str, ..., regex) 
{
  stri_match_first_regex(str, regex, ...)
}, function (str, ..., regex) 
{
  stri_match_first_regex(str, regex, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_match_first_regex
list(`package:stringi` = function (str, pattern, cg_missing = NA, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_match_first_regex, str, pattern, cg_missing, opts_regex)
}, function (str, pattern, cg_missing = NA, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_match_first_regex, str, pattern, cg_missing, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_match_last
list(`package:stringi` = function (str, ..., regex) 
{
  stri_match_last_regex(str, regex, ...)
}, function (str, ..., regex) 
{
  stri_match_last_regex(str, regex, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_match_last_regex
list(`package:stringi` = function (str, pattern, cg_missing = NA, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_match_last_regex, str, pattern, cg_missing, opts_regex)
}, function (str, pattern, cg_missing = NA, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_match_last_regex, str, pattern, cg_missing, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_na2empty
list(`package:stringi` = function (x) 
{
  x <- stri_enc_toutf8(x)
  x[is.na(x)] <- ""
  x
}, function (x) 
{
  x <- stri_enc_toutf8(x)
  x[is.na(x)] <- ""
  x
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_numbytes
list(`package:stringi` = function (str) 
{
  .Call(C_stri_numbytes, str)
}, function (str) 
{
  .Call(C_stri_numbytes, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_omit_empty
list(`package:stringi` = function (x, na_empty = FALSE) 
{
  x <- stri_enc_toutf8(x)
  if (identical(na_empty, TRUE)) 
    x[!is.na(x) & !stri_isempty(x)]
  else x[!stri_isempty(x)]
}, function (x, na_empty = FALSE) 
{
  x <- stri_enc_toutf8(x)
  if (identical(na_empty, TRUE)) 
    x[!is.na(x) & !stri_isempty(x)]
  else x[!stri_isempty(x)]
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_omit_empty_na
list(`package:stringi` = function (x) 
{
  stri_remove_empty(x, TRUE)
}, function (x) 
{
  stri_remove_empty(x, TRUE)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_omit_na
list(`package:stringi` = function (x) 
{
  x <- stri_enc_toutf8(x)
  x[!is.na(x)]
}, function (x) 
{
  x <- stri_enc_toutf8(x)
  x[!is.na(x)]
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_opts_brkiter
list(`package:stringi` = function (type, locale, skip_word_none, skip_word_number, skip_word_letter, skip_word_kana, skip_word_ideo, skip_line_soft, skip_line_hard, skip_sentence_term, skip_sentence_sep, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_brkiter`.")
  opts <- list()
  if (!missing(type)) 
    opts["type"] <- type
  if (!missing(locale)) 
    opts["locale"] <- locale
  if (!missing(skip_word_none)) 
    opts["skip_word_none"] <- skip_word_none
  if (!missing(skip_word_number)) 
    opts["skip_word_number"] <- skip_word_number
  if (!missing(skip_word_letter)) 
    opts["skip_word_letter"] <- skip_word_letter
  if (!missing(skip_word_kana)) 
    opts["skip_word_kana"] <- skip_word_kana
  if (!missing(skip_word_ideo)) 
    opts["skip_word_ideo"] <- skip_word_ideo
  if (!missing(skip_line_soft)) 
    opts["skip_line_soft"] <- skip_line_soft
  if (!missing(skip_line_hard)) 
    opts["skip_line_hard"] <- skip_line_hard
  if (!missing(skip_sentence_term)) 
    opts["skip_sentence_term"] <- skip_sentence_term
  if (!missing(skip_sentence_sep)) 
    opts["skip_sentence_sep"] <- skip_sentence_sep
  opts
}, function (type, locale, skip_word_none, skip_word_number, skip_word_letter, skip_word_kana, skip_word_ideo, skip_line_soft, skip_line_hard, skip_sentence_term, skip_sentence_sep, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_brkiter`.")
  opts <- list()
  if (!missing(type)) 
    opts["type"] <- type
  if (!missing(locale)) 
    opts["locale"] <- locale
  if (!missing(skip_word_none)) 
    opts["skip_word_none"] <- skip_word_none
  if (!missing(skip_word_number)) 
    opts["skip_word_number"] <- skip_word_number
  if (!missing(skip_word_letter)) 
    opts["skip_word_letter"] <- skip_word_letter
  if (!missing(skip_word_kana)) 
    opts["skip_word_kana"] <- skip_word_kana
  if (!missing(skip_word_ideo)) 
    opts["skip_word_ideo"] <- skip_word_ideo
  if (!missing(skip_line_soft)) 
    opts["skip_line_soft"] <- skip_line_soft
  if (!missing(skip_line_hard)) 
    opts["skip_line_hard"] <- skip_line_hard
  if (!missing(skip_sentence_term)) 
    opts["skip_sentence_term"] <- skip_sentence_term
  if (!missing(skip_sentence_sep)) 
    opts["skip_sentence_sep"] <- skip_sentence_sep
  opts
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_opts_collator
list(`package:stringi` = function (locale = NULL, strength = 3, alternate_shifted = FALSE, french = FALSE, uppercase_first = NA, case_level = FALSE, normalization = FALSE, normalisation = normalization, numeric = FALSE, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_collator`.")
  opts <- list()
  if (!missing(locale)) 
    opts["locale"] <- locale
  if (!missing(strength)) 
    opts["strength"] <- strength
  if (!missing(alternate_shifted)) 
    opts["alternate_shifted"] <- alternate_shifted
  if (!missing(french)) 
    opts["french"] <- french
  if (!missing(uppercase_first)) 
    opts["uppercase_first"] <- uppercase_first
  if (!missing(case_level)) 
    opts["case_level"] <- case_level
  if (!missing(numeric)) 
    opts["numeric"] <- numeric
  if (!missing(normalization)) 
    opts["normalization"] <- normalization
  else if (!missing(normalisation)) 
    opts["normalization"] <- normalisation
  opts
}, function (locale = NULL, strength = 3, alternate_shifted = FALSE, french = FALSE, uppercase_first = NA, case_level = FALSE, normalization = FALSE, normalisation = normalization, numeric = FALSE, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_collator`.")
  opts <- list()
  if (!missing(locale)) 
    opts["locale"] <- locale
  if (!missing(strength)) 
    opts["strength"] <- strength
  if (!missing(alternate_shifted)) 
    opts["alternate_shifted"] <- alternate_shifted
  if (!missing(french)) 
    opts["french"] <- french
  if (!missing(uppercase_first)) 
    opts["uppercase_first"] <- uppercase_first
  if (!missing(case_level)) 
    opts["case_level"] <- case_level
  if (!missing(numeric)) 
    opts["numeric"] <- numeric
  if (!missing(normalization)) 
    opts["normalization"] <- normalization
  else if (!missing(normalisation)) 
    opts["normalization"] <- normalisation
  opts
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_opts_fixed
list(`package:stringi` = function (case_insensitive = FALSE, overlap = FALSE, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_fixed`.")
  opts <- list()
  if (!missing(case_insensitive)) 
    opts["case_insensitive"] <- case_insensitive
  if (!missing(overlap)) 
    opts["overlap"] <- overlap
  opts
}, function (case_insensitive = FALSE, overlap = FALSE, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_fixed`.")
  opts <- list()
  if (!missing(case_insensitive)) 
    opts["case_insensitive"] <- case_insensitive
  if (!missing(overlap)) 
    opts["overlap"] <- overlap
  opts
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_opts_regex
list(`package:stringi` = function (case_insensitive, comments, dotall, dot_all = dotall, literal, multiline, multi_line = multiline, unix_lines, uword, error_on_unknown_escapes, time_limit = 0, stack_limit = 0, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_regex`.")
  opts <- list()
  if (!missing(case_insensitive)) 
    opts["case_insensitive"] <- case_insensitive
  if (!missing(comments)) 
    opts["comments"] <- comments
  if (!missing(literal)) 
    opts["literal"] <- literal
  if (!missing(unix_lines)) 
    opts["unix_lines"] <- unix_lines
  if (!missing(uword)) 
    opts["uword"] <- uword
  if (!missing(error_on_unknown_escapes)) 
    opts["error_on_unknown_escapes"] <- error_on_unknown_escapes
  if (!missing(stack_limit)) 
    opts["stack_limit"] <- stack_limit
  if (!missing(time_limit)) 
    opts["time_limit"] <- time_limit
  if (!missing(dotall)) 
    opts["dotall"] <- dotall
  else if (!missing(dot_all)) 
    opts["dotall"] <- dot_all
  if (!missing(multiline)) 
    opts["multiline"] <- multiline
  else if (!missing(multi_line)) 
    opts["multiline"] <- multi_line
  opts
}, function (case_insensitive, comments, dotall, dot_all = dotall, literal, multiline, multi_line = multiline, unix_lines, uword, error_on_unknown_escapes, time_limit = 0, stack_limit = 0, ...) 
{
  if (!missing(...)) 
    warning("Unknown option to `stri_opts_regex`.")
  opts <- list()
  if (!missing(case_insensitive)) 
    opts["case_insensitive"] <- case_insensitive
  if (!missing(comments)) 
    opts["comments"] <- comments
  if (!missing(literal)) 
    opts["literal"] <- literal
  if (!missing(unix_lines)) 
    opts["unix_lines"] <- unix_lines
  if (!missing(uword)) 
    opts["uword"] <- uword
  if (!missing(error_on_unknown_escapes)) 
    opts["error_on_unknown_escapes"] <- error_on_unknown_escapes
  if (!missing(stack_limit)) 
    opts["stack_limit"] <- stack_limit
  if (!missing(time_limit)) 
    opts["time_limit"] <- time_limit
  if (!missing(dotall)) 
    opts["dotall"] <- dotall
  else if (!missing(dot_all)) 
    opts["dotall"] <- dot_all
  if (!missing(multiline)) 
    opts["multiline"] <- multiline
  else if (!missing(multi_line)) 
    opts["multiline"] <- multi_line
  opts
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_order
list(`package:stringi` = function (str, decreasing = FALSE, na_last = TRUE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_order, str, decreasing, na_last, opts_collator)
}, function (str, decreasing = FALSE, na_last = TRUE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_order, str, decreasing, na_last, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_pad
list(`package:stringi` = function (str, width = floor(0.9 * getOption("width")), side = c("left", "right", "both"), pad = " ", use_length = FALSE) 
{
  side <- match.arg(side)
  switch(side, both = stri_pad_both(str, width, pad, use_length), left = stri_pad_left(str, width, pad, use_length), right = stri_pad_right(str, width, pad, use_length))
}, function (str, width = floor(0.9 * getOption("width")), side = c("left", "right", "both"), pad = " ", use_length = FALSE) 
{
  side <- match.arg(side)
  switch(side, both = stri_pad_both(str, width, pad, use_length), left = stri_pad_left(str, width, pad, use_length), right = stri_pad_right(str, width, pad, use_length))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_pad_both
list(`package:stringi` = function (str, width = floor(0.9 * getOption("width")), pad = " ", use_length = FALSE) 
{
  .Call(C_stri_pad, str, width, 2, pad, use_length)
}, function (str, width = floor(0.9 * getOption("width")), pad = " ", use_length = FALSE) 
{
  .Call(C_stri_pad, str, width, 2, pad, use_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_pad_left
list(`package:stringi` = function (str, width = floor(0.9 * getOption("width")), pad = " ", use_length = FALSE) 
{
  .Call(C_stri_pad, str, width, 0, pad, use_length)
}, function (str, width = floor(0.9 * getOption("width")), pad = " ", use_length = FALSE) 
{
  .Call(C_stri_pad, str, width, 0, pad, use_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_pad_right
list(`package:stringi` = function (str, width = floor(0.9 * getOption("width")), pad = " ", use_length = FALSE) 
{
  .Call(C_stri_pad, str, width, 1, pad, use_length)
}, function (str, width = floor(0.9 * getOption("width")), pad = " ", use_length = FALSE) 
{
  .Call(C_stri_pad, str, width, 1, pad, use_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_paste
list(`package:stringi` = function (..., sep = "", collapse = NULL, ignore_null = FALSE) 
{
  .Call(C_stri_join, list(...), sep, collapse, ignore_null)
}, function (..., sep = "", collapse = NULL, ignore_null = FALSE) 
{
  .Call(C_stri_join, list(...), sep, collapse, ignore_null)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_paste_list
list(`package:stringi` = function (x, sep = "", collapse = NULL) 
{
  .Call(C_stri_join_list, x, sep, collapse)
}, function (x, sep = "", collapse = NULL) 
{
  .Call(C_stri_join_list, x, sep, collapse)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_printf
list(`package:stringi` = function (format, ..., file = "", sep = "\n", append = FALSE, na_string = "NA", inf_string = "Inf", nan_string = "NaN", use_length = FALSE) 
{
  str <- .Call(C_stri_sprintf, format, list(...), na_string, inf_string, nan_string, use_length)
  cat(str, file = file, sep = sep, append = append)
}, function (format, ..., file = "", sep = "\n", append = FALSE, na_string = "NA", inf_string = "Inf", nan_string = "NaN", use_length = FALSE) 
{
  str <- .Call(C_stri_sprintf, format, list(...), na_string, inf_string, nan_string, use_length)
  cat(str, file = file, sep = sep, append = append)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_rand_lipsum
list(`package:stringi` = function (n_paragraphs, start_lipsum = TRUE, nparagraphs = n_paragraphs) 
{
  if (!missing(nparagraphs) && missing(n_paragraphs)) {
    n_paragraphs <- nparagraphs
  }
  n_paragraphs <- as.integer(n_paragraphs)
  stopifnot(is.finite(n_paragraphs), n_paragraphs >= 1)
  start_lipsum <- identical(start_lipsum, TRUE)
  rwords <- function(n) {
    words <- c("SED", "IN", "UT", "ET", "AC", "EU", "NON", "NEC", "AMET", "SIT", "VEL", "AT", "MAURIS", "A", "VITAE", "EGET", "QUIS", "NUNC", "NULLA", "ID", "VESTIBULUM", "PELLENTESQUE", "TINCIDUNT", "ALIQUAM", "IPSUM", "DONEC", "TURPIS", "LIGULA", "EGESTAS", "NIBH", "SAPIEN", "ANTE", "NISL", "VELIT", "ERAT", "EROS", "LEO", "MAGNA", "JUSTO", "ENIM", "MI", "PURUS", "EST", "LACUS", "LOREM", "QUAM", "DIAM", "RISUS", "DOLOR", "SEM", "AUGUE", "NEQUE", "TEMPOR", "DUI", "ARCU", "METUS", "TORTOR", "URNA", 
               "LIBERO", "PHARETRA", "TEMPUS", "FAUCIBUS", "LECTUS", "SUSPENDISSE", "FELIS", "ODIO", "ORCI", "VARIUS", "MASSA", "TELLUS", "VOLUTPAT", "BLANDIT", "INTERDUM", "LOBORTIS", "MAXIMUS", "NISI", "LUCTUS", "PORTTITOR", "AUCTOR", "ELEMENTUM", "EX", "MAECENAS", "MALESUADA", "TRISTIQUE", "ULLAMCORPER", "ULTRICES", "NULLAM", "CONSEQUAT", "LACINIA", "PHASELLUS", "ACCUMSAN", "DAPIBUS", "ELEIFEND", "COMMODO", "DUIS", "EFFICITUR", "ELIT", "IMPERDIET", "AENEAN", "IACULIS", "NAM", "CONSECTETUR", "FERMENTUM", 
               "PORTA", "SCELERISQUE", "SODALES", "FEUGIAT", "LAOREET", "VULPUTATE", "DICTUM", "QUISQUE", "FACILISIS", "FINIBUS", "ORNARE", "PULVINAR", "RHONCUS", "CONDIMENTUM", "MOLLIS", "PRETIUM", "ALIQUET", "CONGUE", "POSUERE", "SUSCIPIT", "ULTRICIES", "CURABITUR", "GRAVIDA", "MATTIS", "VIVERRA", "CURSUS", "EUISMOD", "RUTRUM", "VENENATIS", "CONVALLIS", "PROIN", "VEHICULA", "PLACERAT", "SAGITTIS", "CRAS", "INTEGER", "MORBI", "VIVAMUS", "PRAESENT", "BIBENDUM", "MOLESTIE", "SEMPER", "FRINGILLA", "FUSCE", 
               "DIGNISSIM", "ETIAM", "HENDRERIT", "SOLLICITUDIN", "PER", "FAMES", "POTENTI", "AD", "APTENT", "CLASS", "CONUBIA", "HIMENAEOS", "INCEPTOS", "LITORA", "NOSTRA", "SOCIOSQU", "TACITI", "TORQUENT", "HABITANT", "NETUS", "SENECTUS", "PRIMIS", "CUM", "DIS", "MAGNIS", "MONTES", "MUS", "NASCETUR", "NATOQUE", "PARTURIENT", "PENATIBUS", "RIDICULUS", "SOCIIS", "ADIPISCING", "FACILISI", "CUBILIA", "CURAE", "DICTUMST", "HABITASSE", "HAC", "PLATEA")
    dzipf <- function(k, N, s) 1/k^s/sum(1/(1:N)^s)
    pzipf.y <- c(0, cumsum(dzipf(1:length(words), length(words), 0.5)))
    robs <- findInterval(runif(n), pzipf.y)
    words[robs]
  }
  rtruncnorm <- function(n, a, b, mu, sd) {
    x <- round(rnorm(n, mu, sd))
    while (any(x < a | x > b)) x[x < a | x > b] <- round(rnorm(sum(x < a | x > b), mu, sd))
    x
  }
  sent_para <- rtruncnorm(n_paragraphs, 7, 20, 11, 3)
  word_sent <- lapply(sent_para, function(numsent) rtruncnorm(numsent, 2, Inf, 8, 3))
  totwords <- sum(unlist(word_sent))
  words <- rwords(totwords)
  seps <- sample(c(" ", ", "), replace = TRUE, size = totwords, prob = c(0.9, 0.1))
  seps[cumsum(unlist(word_sent))] <- sample(c(". ", "? ", "! "), size = length(unlist(word_sent)), replace = TRUE, prob = c(0.95, 0.025, 0.025))
  seps[cumsum(sapply(word_sent, sum))] <- ".\n"
  seps[totwords] <- "."
  if (start_lipsum) {
    words <- c("LOREM", "IPSUM", "DOLOR", "SIT", "AMET", words)
    seps <- c(" ", " ", " ", " ", ", ", seps)
  }
  ret <- stri_split_charclass(stri_paste(words, seps, collapse = ""), "[\\n]")[[1]]
  ret <- stri_trans_totitle(ret, opts_brkiter = stri_opts_brkiter(type = "sentence"))
  ret
}, function (n_paragraphs, start_lipsum = TRUE, nparagraphs = n_paragraphs) 
{
  if (!missing(nparagraphs) && missing(n_paragraphs)) {
    n_paragraphs <- nparagraphs
  }
  n_paragraphs <- as.integer(n_paragraphs)
  stopifnot(is.finite(n_paragraphs), n_paragraphs >= 1)
  start_lipsum <- identical(start_lipsum, TRUE)
  rwords <- function(n) {
    words <- c("SED", "IN", "UT", "ET", "AC", "EU", "NON", "NEC", "AMET", "SIT", "VEL", "AT", "MAURIS", "A", "VITAE", "EGET", "QUIS", "NUNC", "NULLA", "ID", "VESTIBULUM", "PELLENTESQUE", "TINCIDUNT", "ALIQUAM", "IPSUM", "DONEC", "TURPIS", "LIGULA", "EGESTAS", "NIBH", "SAPIEN", "ANTE", "NISL", "VELIT", "ERAT", "EROS", "LEO", "MAGNA", "JUSTO", "ENIM", "MI", "PURUS", "EST", "LACUS", "LOREM", "QUAM", "DIAM", "RISUS", "DOLOR", "SEM", "AUGUE", "NEQUE", "TEMPOR", "DUI", "ARCU", "METUS", "TORTOR", "URNA", 
               "LIBERO", "PHARETRA", "TEMPUS", "FAUCIBUS", "LECTUS", "SUSPENDISSE", "FELIS", "ODIO", "ORCI", "VARIUS", "MASSA", "TELLUS", "VOLUTPAT", "BLANDIT", "INTERDUM", "LOBORTIS", "MAXIMUS", "NISI", "LUCTUS", "PORTTITOR", "AUCTOR", "ELEMENTUM", "EX", "MAECENAS", "MALESUADA", "TRISTIQUE", "ULLAMCORPER", "ULTRICES", "NULLAM", "CONSEQUAT", "LACINIA", "PHASELLUS", "ACCUMSAN", "DAPIBUS", "ELEIFEND", "COMMODO", "DUIS", "EFFICITUR", "ELIT", "IMPERDIET", "AENEAN", "IACULIS", "NAM", "CONSECTETUR", "FERMENTUM", 
               "PORTA", "SCELERISQUE", "SODALES", "FEUGIAT", "LAOREET", "VULPUTATE", "DICTUM", "QUISQUE", "FACILISIS", "FINIBUS", "ORNARE", "PULVINAR", "RHONCUS", "CONDIMENTUM", "MOLLIS", "PRETIUM", "ALIQUET", "CONGUE", "POSUERE", "SUSCIPIT", "ULTRICIES", "CURABITUR", "GRAVIDA", "MATTIS", "VIVERRA", "CURSUS", "EUISMOD", "RUTRUM", "VENENATIS", "CONVALLIS", "PROIN", "VEHICULA", "PLACERAT", "SAGITTIS", "CRAS", "INTEGER", "MORBI", "VIVAMUS", "PRAESENT", "BIBENDUM", "MOLESTIE", "SEMPER", "FRINGILLA", "FUSCE", 
               "DIGNISSIM", "ETIAM", "HENDRERIT", "SOLLICITUDIN", "PER", "FAMES", "POTENTI", "AD", "APTENT", "CLASS", "CONUBIA", "HIMENAEOS", "INCEPTOS", "LITORA", "NOSTRA", "SOCIOSQU", "TACITI", "TORQUENT", "HABITANT", "NETUS", "SENECTUS", "PRIMIS", "CUM", "DIS", "MAGNIS", "MONTES", "MUS", "NASCETUR", "NATOQUE", "PARTURIENT", "PENATIBUS", "RIDICULUS", "SOCIIS", "ADIPISCING", "FACILISI", "CUBILIA", "CURAE", "DICTUMST", "HABITASSE", "HAC", "PLATEA")
    dzipf <- function(k, N, s) 1/k^s/sum(1/(1:N)^s)
    pzipf.y <- c(0, cumsum(dzipf(1:length(words), length(words), 0.5)))
    robs <- findInterval(runif(n), pzipf.y)
    words[robs]
  }
  rtruncnorm <- function(n, a, b, mu, sd) {
    x <- round(rnorm(n, mu, sd))
    while (any(x < a | x > b)) x[x < a | x > b] <- round(rnorm(sum(x < a | x > b), mu, sd))
    x
  }
  sent_para <- rtruncnorm(n_paragraphs, 7, 20, 11, 3)
  word_sent <- lapply(sent_para, function(numsent) rtruncnorm(numsent, 2, Inf, 8, 3))
  totwords <- sum(unlist(word_sent))
  words <- rwords(totwords)
  seps <- sample(c(" ", ", "), replace = TRUE, size = totwords, prob = c(0.9, 0.1))
  seps[cumsum(unlist(word_sent))] <- sample(c(". ", "? ", "! "), size = length(unlist(word_sent)), replace = TRUE, prob = c(0.95, 0.025, 0.025))
  seps[cumsum(sapply(word_sent, sum))] <- ".\n"
  seps[totwords] <- "."
  if (start_lipsum) {
    words <- c("LOREM", "IPSUM", "DOLOR", "SIT", "AMET", words)
    seps <- c(" ", " ", " ", " ", ", ", seps)
  }
  ret <- stri_split_charclass(stri_paste(words, seps, collapse = ""), "[\\n]")[[1]]
  ret <- stri_trans_totitle(ret, opts_brkiter = stri_opts_brkiter(type = "sentence"))
  ret
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_rand_shuffle
list(`package:stringi` = function (str) 
{
  .Call(C_stri_rand_shuffle, str)
}, function (str) 
{
  .Call(C_stri_rand_shuffle, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_rand_strings
list(`package:stringi` = function (n, length, pattern = "[A-Za-z0-9]") 
{
  .Call(C_stri_rand_strings, n, length, pattern)
}, function (n, length, pattern = "[A-Za-z0-9]") 
{
  .Call(C_stri_rand_strings, n, length, pattern)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_rank
list(`package:stringi` = function (str, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_rank, str, opts_collator)
}, function (str, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_rank, str, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_read_lines
list(`package:stringi` = function (con, encoding = NULL, fname = con, fallback_encoding = NULL) 
{
  if (!missing(fname) && missing(con)) {
    con <- fname
  }
  if (!missing(fallback_encoding)) {
    warning("`fallback_encoding` is no longer used and has been scheduled for removal")
  }
  stopifnot(is.null(encoding) || is.character(encoding))
  if (is.null(encoding) || encoding == "") 
    encoding <- stri_enc_get()
  if (encoding == "auto") 
    stop("encoding `auto` is no longer supported")
  txt <- stri_read_raw(con)
  txt <- stri_encode(txt, encoding, "UTF-8")
  stri_split_lines1(txt)
}, function (con, encoding = NULL, fname = con, fallback_encoding = NULL) 
{
  if (!missing(fname) && missing(con)) {
    con <- fname
  }
  if (!missing(fallback_encoding)) {
    warning("`fallback_encoding` is no longer used and has been scheduled for removal")
  }
  stopifnot(is.null(encoding) || is.character(encoding))
  if (is.null(encoding) || encoding == "") 
    encoding <- stri_enc_get()
  if (encoding == "auto") 
    stop("encoding `auto` is no longer supported")
  txt <- stri_read_raw(con)
  txt <- stri_encode(txt, encoding, "UTF-8")
  stri_split_lines1(txt)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_read_raw
list(`package:stringi` = function (con, fname = con) 
{
  if (!missing(fname) && missing(con)) {
    con <- fname
  }
  if (is.character(con)) {
    con <- file(con, "rb")
    on.exit(close(con))
  }
  bufsize <- 4194304
  data <- list()
  n <- 1
  repeat {
    buf <- readBin(con, what = "raw", size = 1, n = bufsize)
    data[[n]] <- buf
    n <- n + 1
    if (length(buf) < bufsize) 
      break
  }
  do.call(c, data)
}, function (con, fname = con) 
{
  if (!missing(fname) && missing(con)) {
    con <- fname
  }
  if (is.character(con)) {
    con <- file(con, "rb")
    on.exit(close(con))
  }
  bufsize <- 4194304
  data <- list()
  n <- 1
  repeat {
    buf <- readBin(con, what = "raw", size = 1, n = bufsize)
    data[[n]] <- buf
    n <- n + 1
    if (length(buf) < bufsize) 
      break
  }
  do.call(c, data)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_remove_empty
list(`package:stringi` = function (x, na_empty = FALSE) 
{
  x <- stri_enc_toutf8(x)
  if (identical(na_empty, TRUE)) 
    x[!is.na(x) & !stri_isempty(x)]
  else x[!stri_isempty(x)]
}, function (x, na_empty = FALSE) 
{
  x <- stri_enc_toutf8(x)
  if (identical(na_empty, TRUE)) 
    x[!is.na(x) & !stri_isempty(x)]
  else x[!stri_isempty(x)]
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_remove_empty_na
list(`package:stringi` = function (x) 
{
  stri_remove_empty(x, TRUE)
}, function (x) 
{
  stri_remove_empty(x, TRUE)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_remove_na
list(`package:stringi` = function (x) 
{
  x <- stri_enc_toutf8(x)
  x[!is.na(x)]
}, function (x) 
{
  x <- stri_enc_toutf8(x)
  x[!is.na(x)]
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace
list(`package:stringi` = function (str, replacement, ..., regex, fixed, coll, charclass, mode = c("first", "all", "last")) 
{
  mode <- match.arg(mode)
  switch(mode, first = stri_replace_first(str, replacement, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), last = stri_replace_last(str, replacement, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), all = stri_replace_all(str, replacement, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass))
}, function (str, replacement, ..., regex, fixed, coll, charclass, mode = c("first", "all", "last")) 
{
  mode <- match.arg(mode)
  switch(mode, first = stri_replace_first(str, replacement, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), last = stri_replace_last(str, replacement, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass), all = stri_replace_all(str, replacement, ..., regex = regex, fixed = fixed, coll = coll, charclass = charclass))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_all
list(`package:stringi` = function (str, replacement, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_replace_all_regex(str, regex, replacement, ...)
  else if (providedarg["fixed"]) 
    stri_replace_all_fixed(str, fixed, replacement, ...)
  else if (providedarg["coll"]) 
    stri_replace_all_coll(str, coll, replacement, ...)
  else if (providedarg["charclass"]) 
    stri_replace_all_charclass(str, charclass, replacement, ...)
}, function (str, replacement, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_replace_all_regex(str, regex, replacement, ...)
  else if (providedarg["fixed"]) 
    stri_replace_all_fixed(str, fixed, replacement, ...)
  else if (providedarg["coll"]) 
    stri_replace_all_coll(str, coll, replacement, ...)
  else if (providedarg["charclass"]) 
    stri_replace_all_charclass(str, charclass, replacement, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_all_charclass
list(`package:stringi` = function (str, pattern, replacement, merge = FALSE, vectorize_all = TRUE, vectorise_all = vectorize_all) 
{
  if (!missing(vectorise_all)) 
    vectorize_all <- vectorise_all
  .Call(C_stri_replace_all_charclass, str, pattern, replacement, merge, vectorize_all)
}, function (str, pattern, replacement, merge = FALSE, vectorize_all = TRUE, vectorise_all = vectorize_all) 
{
  if (!missing(vectorise_all)) 
    vectorize_all <- vectorise_all
  .Call(C_stri_replace_all_charclass, str, pattern, replacement, merge, vectorize_all)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_all_coll
list(`package:stringi` = function (str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_collator = NULL) 
{
  if (!missing(vectorise_all)) 
    vectorize_all <- vectorise_all
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_replace_all_coll, str, pattern, replacement, vectorize_all, opts_collator)
}, function (str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_collator = NULL) 
{
  if (!missing(vectorise_all)) 
    vectorize_all <- vectorise_all
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_replace_all_coll, str, pattern, replacement, vectorize_all, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_all_fixed
list(`package:stringi` = function (str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_fixed = NULL) 
{
  if (!missing(vectorise_all)) 
    vectorize_all <- vectorise_all
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_replace_all_fixed, str, pattern, replacement, vectorize_all, opts_fixed)
}, function (str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_fixed = NULL) 
{
  if (!missing(vectorise_all)) 
    vectorize_all <- vectorise_all
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_replace_all_fixed, str, pattern, replacement, vectorize_all, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_all_regex
list(`package:stringi` = function (str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_regex = NULL) 
{
  if (!missing(vectorise_all)) 
    vectorize_all <- vectorise_all
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_replace_all_regex, str, pattern, replacement, vectorize_all, opts_regex)
}, function (str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_regex = NULL) 
{
  if (!missing(vectorise_all)) 
    vectorize_all <- vectorise_all
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_replace_all_regex, str, pattern, replacement, vectorize_all, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_first
list(`package:stringi` = function (str, replacement, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_replace_first_regex(str, regex, replacement, ...)
  else if (providedarg["fixed"]) 
    stri_replace_first_fixed(str, fixed, replacement, ...)
  else if (providedarg["coll"]) 
    stri_replace_first_coll(str, coll, replacement, ...)
  else if (providedarg["charclass"]) 
    stri_replace_first_charclass(str, charclass, replacement, ...)
}, function (str, replacement, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_replace_first_regex(str, regex, replacement, ...)
  else if (providedarg["fixed"]) 
    stri_replace_first_fixed(str, fixed, replacement, ...)
  else if (providedarg["coll"]) 
    stri_replace_first_coll(str, coll, replacement, ...)
  else if (providedarg["charclass"]) 
    stri_replace_first_charclass(str, charclass, replacement, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_first_charclass
list(`package:stringi` = function (str, pattern, replacement) 
{
  .Call(C_stri_replace_first_charclass, str, pattern, replacement)
}, function (str, pattern, replacement) 
{
  .Call(C_stri_replace_first_charclass, str, pattern, replacement)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_first_coll
list(`package:stringi` = function (str, pattern, replacement, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_replace_first_coll, str, pattern, replacement, opts_collator)
}, function (str, pattern, replacement, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_replace_first_coll, str, pattern, replacement, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_first_fixed
list(`package:stringi` = function (str, pattern, replacement, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_replace_first_fixed, str, pattern, replacement, opts_fixed)
}, function (str, pattern, replacement, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_replace_first_fixed, str, pattern, replacement, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_first_regex
list(`package:stringi` = function (str, pattern, replacement, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_replace_first_regex, str, pattern, replacement, opts_regex)
}, function (str, pattern, replacement, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_replace_first_regex, str, pattern, replacement, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_last
list(`package:stringi` = function (str, replacement, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_replace_last_regex(str, regex, replacement, ...)
  else if (providedarg["fixed"]) 
    stri_replace_last_fixed(str, fixed, replacement, ...)
  else if (providedarg["coll"]) 
    stri_replace_last_coll(str, coll, replacement, ...)
  else if (providedarg["charclass"]) 
    stri_replace_last_charclass(str, charclass, replacement, ...)
}, function (str, replacement, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_replace_last_regex(str, regex, replacement, ...)
  else if (providedarg["fixed"]) 
    stri_replace_last_fixed(str, fixed, replacement, ...)
  else if (providedarg["coll"]) 
    stri_replace_last_coll(str, coll, replacement, ...)
  else if (providedarg["charclass"]) 
    stri_replace_last_charclass(str, charclass, replacement, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_last_charclass
list(`package:stringi` = function (str, pattern, replacement) 
{
  .Call(C_stri_replace_last_charclass, str, pattern, replacement)
}, function (str, pattern, replacement) 
{
  .Call(C_stri_replace_last_charclass, str, pattern, replacement)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_last_coll
list(`package:stringi` = function (str, pattern, replacement, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_replace_last_coll, str, pattern, replacement, opts_collator)
}, function (str, pattern, replacement, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_replace_last_coll, str, pattern, replacement, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_last_fixed
list(`package:stringi` = function (str, pattern, replacement, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_replace_last_fixed, str, pattern, replacement, opts_fixed)
}, function (str, pattern, replacement, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_replace_last_fixed, str, pattern, replacement, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_last_regex
list(`package:stringi` = function (str, pattern, replacement, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_replace_last_regex, str, pattern, replacement, opts_regex)
}, function (str, pattern, replacement, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_replace_last_regex, str, pattern, replacement, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_na
list(`package:stringi` = function (str, replacement = "NA") 
{
  .Call(C_stri_replace_na, str, replacement)
}, function (str, replacement = "NA") 
{
  .Call(C_stri_replace_na, str, replacement)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_replace_rstr
list(`package:stringi` = function (x) 
{
  .Call(C_stri_replace_rstr, x)
}, function (x) 
{
  .Call(C_stri_replace_rstr, x)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_reverse
list(`package:stringi` = function (str) 
{
  .Call(C_stri_reverse, str)
}, function (str) 
{
  .Call(C_stri_reverse, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sort
list(`package:stringi` = function (str, decreasing = FALSE, na_last = NA, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_sort, str, decreasing, na_last, opts_collator)
}, function (str, decreasing = FALSE, na_last = NA, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_sort, str, decreasing, na_last, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sort_key
list(`package:stringi` = function (str, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_sort_key, str, opts_collator)
}, function (str, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_sort_key, str, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_split
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_split_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_split_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_split_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_split_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_split_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_split_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_split_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_split_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_split_boundaries
list(`package:stringi` = function (str, n = -1, tokens_only = FALSE, simplify = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_split_boundaries, str, n, tokens_only, simplify, opts_brkiter)
}, function (str, n = -1, tokens_only = FALSE, simplify = FALSE, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_split_boundaries, str, n, tokens_only, simplify, opts_brkiter)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_split_charclass
list(`package:stringi` = function (str, pattern, n = -1, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE) 
{
  .Call(C_stri_split_charclass, str, pattern, n, omit_empty, tokens_only, simplify)
}, function (str, pattern, n = -1, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE) 
{
  .Call(C_stri_split_charclass, str, pattern, n, omit_empty, tokens_only, simplify)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_split_coll
list(`package:stringi` = function (str, pattern, n = -1, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_split_coll, str, pattern, n, omit_empty, tokens_only, simplify, opts_collator)
}, function (str, pattern, n = -1, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_split_coll, str, pattern, n, omit_empty, tokens_only, simplify, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_split_fixed
list(`package:stringi` = function (str, pattern, n = -1, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_split_fixed, str, pattern, n, omit_empty, tokens_only, simplify, opts_fixed)
}, function (str, pattern, n = -1, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_split_fixed, str, pattern, n, omit_empty, tokens_only, simplify, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_split_lines
list(`package:stringi` = function (str, omit_empty = FALSE) 
{
  .Call(C_stri_split_lines, str, omit_empty)
}, function (str, omit_empty = FALSE) 
{
  .Call(C_stri_split_lines, str, omit_empty)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_split_lines1
list(`package:stringi` = function (str) 
{
  .Call(C_stri_split_lines1, str)
}, function (str) 
{
  .Call(C_stri_split_lines1, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_split_regex
list(`package:stringi` = function (str, pattern, n = -1, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_split_regex, str, pattern, n, omit_empty, tokens_only, simplify, opts_regex)
}, function (str, pattern, n = -1, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_split_regex, str, pattern, n, omit_empty, tokens_only, simplify, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sprintf
list(`package:stringi` = function (format, ..., na_string = NA, inf_string = "Inf", nan_string = "NaN", use_length = FALSE) 
{
  .Call(C_stri_sprintf, format, list(...), na_string, inf_string, nan_string, use_length)
}, function (format, ..., na_string = NA, inf_string = "Inf", nan_string = "NaN", use_length = FALSE) 
{
  .Call(C_stri_sprintf, format, list(...), na_string, inf_string, nan_string, use_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_startswith
list(`package:stringi` = function (str, ..., fixed, coll, charclass) 
{
  providedarg <- c(fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `fixed`, `coll`, or `charclass`")
  if (providedarg["fixed"]) 
    stri_startswith_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_startswith_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_startswith_charclass(str, charclass, ...)
}, function (str, ..., fixed, coll, charclass) 
{
  providedarg <- c(fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `fixed`, `coll`, or `charclass`")
  if (providedarg["fixed"]) 
    stri_startswith_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_startswith_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_startswith_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_startswith_charclass
list(`package:stringi` = function (str, pattern, from = 1, negate = FALSE) 
{
  .Call(C_stri_startswith_charclass, str, pattern, from, negate)
}, function (str, pattern, from = 1, negate = FALSE) 
{
  .Call(C_stri_startswith_charclass, str, pattern, from, negate)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_startswith_coll
list(`package:stringi` = function (str, pattern, from = 1, negate = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_startswith_coll, str, pattern, from, negate, opts_collator)
}, function (str, pattern, from = 1, negate = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_startswith_coll, str, pattern, from, negate, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_startswith_fixed
list(`package:stringi` = function (str, pattern, from = 1, negate = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_startswith_fixed, str, pattern, from, negate, opts_fixed)
}, function (str, pattern, from = 1, negate = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_startswith_fixed, str, pattern, from, negate, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_stats_general
list(`package:stringi` = function (str) 
{
  .Call(C_stri_stats_general, str)
}, function (str) 
{
  .Call(C_stri_stats_general, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_stats_latex
list(`package:stringi` = function (str) 
{
  .Call(C_stri_stats_latex, str)
}, function (str) 
{
  .Call(C_stri_stats_latex, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_string_format
list(`package:stringi` = function (format, ..., na_string = NA, inf_string = "Inf", nan_string = "NaN", use_length = FALSE) 
{
  .Call(C_stri_sprintf, format, list(...), na_string, inf_string, nan_string, use_length)
}, function (format, ..., na_string = NA, inf_string = "Inf", nan_string = "NaN", use_length = FALSE) 
{
  .Call(C_stri_sprintf, format, list(...), na_string, inf_string, nan_string, use_length)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sub
list(`package:stringi` = function (str, from = 1, to = -1, length, use_matrix = TRUE, ignore_negative_length = FALSE) 
{
  use_matrix <- (is.logical(use_matrix) && base::length(use_matrix) == 1 && !is.na(use_matrix) && use_matrix)
  if (missing(length)) {
    if (use_matrix && is.matrix(from) && !missing(to)) {
      warning("argument `to` is ignored in the current context")
      to <- NULL
    }
    .Call(C_stri_sub, str, from, to, NULL, use_matrix, ignore_negative_length)
  }
  else {
    if (!missing(to)) 
      warning("argument `to` is ignored in the current context")
    if (use_matrix && is.matrix(from)) {
      warning("argument `length` is ignored in the current context")
      length <- NULL
    }
    .Call(C_stri_sub, str, from, NULL, length, use_matrix, ignore_negative_length)
  }
}, function (str, from = 1, to = -1, length, use_matrix = TRUE, ignore_negative_length = FALSE) 
{
  use_matrix <- (is.logical(use_matrix) && base::length(use_matrix) == 1 && !is.na(use_matrix) && use_matrix)
  if (missing(length)) {
    if (use_matrix && is.matrix(from) && !missing(to)) {
      warning("argument `to` is ignored in the current context")
      to <- NULL
    }
    .Call(C_stri_sub, str, from, to, NULL, use_matrix, ignore_negative_length)
  }
  else {
    if (!missing(to)) 
      warning("argument `to` is ignored in the current context")
    if (use_matrix && is.matrix(from)) {
      warning("argument `length` is ignored in the current context")
      length <- NULL
    }
    .Call(C_stri_sub, str, from, NULL, length, use_matrix, ignore_negative_length)
  }
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sub_all
list(`package:stringi` = function (str, from = list(1), to = list(-1), length, use_matrix = TRUE, ignore_negative_length = TRUE) 
{
  if (!is.list(from)) 
    from <- list(from)
  if (missing(length)) {
    if (!missing(to) && !is.list(to)) {
      to <- list(to)
    }
    .Call(C_stri_sub_all, str, from, to, NULL, use_matrix, ignore_negative_length)
  }
  else {
    if (!missing(to)) 
      warning("argument `to` is ignored in this context")
    if (!is.list(length)) {
      length <- list(length)
    }
    .Call(C_stri_sub_all, str, from, NULL, length, use_matrix, ignore_negative_length)
  }
}, function (str, from = list(1), to = list(-1), length, use_matrix = TRUE, ignore_negative_length = TRUE) 
{
  if (!is.list(from)) 
    from <- list(from)
  if (missing(length)) {
    if (!missing(to) && !is.list(to)) {
      to <- list(to)
    }
    .Call(C_stri_sub_all, str, from, to, NULL, use_matrix, ignore_negative_length)
  }
  else {
    if (!missing(to)) 
      warning("argument `to` is ignored in this context")
    if (!is.list(length)) {
      length <- list(length)
    }
    .Call(C_stri_sub_all, str, from, NULL, length, use_matrix, ignore_negative_length)
  }
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sub_all_replace
list(`package:stringi` = function (..., replacement, value = replacement) 
  `stri_sub_all<-`(..., value = value), function (..., replacement, value = replacement) 
    `stri_sub_all<-`(..., value = value))
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sub_all<-
  list(`package:stringi` = function (str, from = list(1), to = list(-1), length, omit_na = FALSE, use_matrix = TRUE, value) 
  {
    if (!is.list(from)) 
      from <- list(from)
    if (!is.list(value)) 
      value <- list(value)
    if (missing(length)) {
      if (!missing(to) && !is.list(to)) {
        to <- list(to)
      }
      .Call(C_stri_sub_replacement_all, str, from, to, NULL, omit_na, value, use_matrix)
    }
    else {
      if (!missing(to)) 
        warning("argument `to` is ignored in this context")
      if (!is.list(length)) {
        length <- list(length)
      }
      .Call(C_stri_sub_replacement_all, str, from, NULL, length, omit_na, value, use_matrix)
    }
  }, function (str, from = list(1), to = list(-1), length, omit_na = FALSE, use_matrix = TRUE, value) 
  {
    if (!is.list(from)) 
      from <- list(from)
    if (!is.list(value)) 
      value <- list(value)
    if (missing(length)) {
      if (!missing(to) && !is.list(to)) {
        to <- list(to)
      }
      .Call(C_stri_sub_replacement_all, str, from, to, NULL, omit_na, value, use_matrix)
    }
    else {
      if (!missing(to)) 
        warning("argument `to` is ignored in this context")
      if (!is.list(length)) {
        length <- list(length)
      }
      .Call(C_stri_sub_replacement_all, str, from, NULL, length, omit_na, value, use_matrix)
    }
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sub_replace
list(`package:stringi` = function (..., replacement, value = replacement) 
  `stri_sub<-`(..., value = value), function (..., replacement, value = replacement) 
    `stri_sub<-`(..., value = value))
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sub_replace_all
list(`package:stringi` = function (..., replacement, value = replacement) 
  `stri_sub_all<-`(..., value = value), function (..., replacement, value = replacement) 
    `stri_sub_all<-`(..., value = value))
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_sub<-
  list(`package:stringi` = function (str, from = 1, to = -1, length, omit_na = FALSE, use_matrix = TRUE, value) 
  {
    use_matrix <- (is.logical(use_matrix) && base::length(use_matrix) == 1 && !is.na(use_matrix) && use_matrix)
    if (missing(length)) {
      if (use_matrix && is.matrix(from) && !missing(to)) {
        warning("argument `to` is ignored in this context")
        to <- NULL
      }
      .Call(C_stri_sub_replacement, str, from, to, NULL, omit_na, value, use_matrix)
    }
    else {
      if (!missing(to)) 
        warning("argument `to` is ignored in this context")
      if (use_matrix && is.matrix(from)) {
        warning("argument `length` is ignored in this context")
        length <- NULL
      }
      .Call(C_stri_sub_replacement, str, from, NULL, length, omit_na, value, use_matrix)
    }
  }, function (str, from = 1, to = -1, length, omit_na = FALSE, use_matrix = TRUE, value) 
  {
    use_matrix <- (is.logical(use_matrix) && base::length(use_matrix) == 1 && !is.na(use_matrix) && use_matrix)
    if (missing(length)) {
      if (use_matrix && is.matrix(from) && !missing(to)) {
        warning("argument `to` is ignored in this context")
        to <- NULL
      }
      .Call(C_stri_sub_replacement, str, from, to, NULL, omit_na, value, use_matrix)
    }
    else {
      if (!missing(to)) 
        warning("argument `to` is ignored in this context")
      if (use_matrix && is.matrix(from)) {
        warning("argument `length` is ignored in this context")
        length <- NULL
      }
      .Call(C_stri_sub_replacement, str, from, NULL, length, omit_na, value, use_matrix)
    }
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset
list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_subset_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_subset_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_subset_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_subset_charclass(str, charclass, ...)
}, function (str, ..., regex, fixed, coll, charclass) 
{
  providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
  if (sum(providedarg) != 1) 
    stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
  if (providedarg["regex"]) 
    stri_subset_regex(str, regex, ...)
  else if (providedarg["fixed"]) 
    stri_subset_fixed(str, fixed, ...)
  else if (providedarg["coll"]) 
    stri_subset_coll(str, coll, ...)
  else if (providedarg["charclass"]) 
    stri_subset_charclass(str, charclass, ...)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset_charclass
list(`package:stringi` = function (str, pattern, omit_na = FALSE, negate = FALSE) 
{
  .Call(C_stri_subset_charclass, str, pattern, omit_na, negate)
}, function (str, pattern, omit_na = FALSE, negate = FALSE) 
{
  .Call(C_stri_subset_charclass, str, pattern, omit_na, negate)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset_charclass<-
  list(`package:stringi` = function (str, pattern, negate = FALSE, value) 
  {
    .Call(C_stri_subset_charclass_replacement, str, pattern, negate, value)
  }, function (str, pattern, negate = FALSE, value) 
  {
    .Call(C_stri_subset_charclass_replacement, str, pattern, negate, value)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset_coll
list(`package:stringi` = function (str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_subset_coll, str, pattern, omit_na, negate, opts_collator)
}, function (str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_subset_coll, str, pattern, omit_na, negate, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset_coll<-
  list(`package:stringi` = function (str, pattern, negate = FALSE, ..., opts_collator = NULL, value) 
  {
    if (!missing(...)) 
      opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
    .Call(C_stri_subset_coll_replacement, str, pattern, negate, opts_collator, value)
  }, function (str, pattern, negate = FALSE, ..., opts_collator = NULL, value) 
  {
    if (!missing(...)) 
      opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
    .Call(C_stri_subset_coll_replacement, str, pattern, negate, opts_collator, value)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset_fixed
list(`package:stringi` = function (str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_subset_fixed, str, pattern, omit_na, negate, opts_fixed)
}, function (str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_fixed = NULL) 
{
  if (!missing(...)) 
    opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
  .Call(C_stri_subset_fixed, str, pattern, omit_na, negate, opts_fixed)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset_fixed<-
  list(`package:stringi` = function (str, pattern, negate = FALSE, ..., opts_fixed = NULL, value) 
  {
    if (!missing(...)) 
      opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
    .Call(C_stri_subset_fixed_replacement, str, pattern, negate, opts_fixed, value)
  }, function (str, pattern, negate = FALSE, ..., opts_fixed = NULL, value) 
  {
    if (!missing(...)) 
      opts_fixed <- do.call(stri_opts_fixed, as.list(c(opts_fixed, ...)))
    .Call(C_stri_subset_fixed_replacement, str, pattern, negate, opts_fixed, value)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset_regex
list(`package:stringi` = function (str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_subset_regex, str, pattern, omit_na, negate, opts_regex)
}, function (str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_regex = NULL) 
{
  if (!missing(...)) 
    opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
  .Call(C_stri_subset_regex, str, pattern, omit_na, negate, opts_regex)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset_regex<-
  list(`package:stringi` = function (str, pattern, negate = FALSE, ..., opts_regex = NULL, value) 
  {
    if (!missing(...)) 
      opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
    .Call(C_stri_subset_regex_replacement, str, pattern, negate, opts_regex, value)
  }, function (str, pattern, negate = FALSE, ..., opts_regex = NULL, value) 
  {
    if (!missing(...)) 
      opts_regex <- do.call(stri_opts_regex, as.list(c(opts_regex, ...)))
    .Call(C_stri_subset_regex_replacement, str, pattern, negate, opts_regex, value)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_subset<-
  list(`package:stringi` = function (str, ..., regex, fixed, coll, charclass, value) 
  {
    providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
    if (sum(providedarg) != 1) 
      stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
    if (providedarg["regex"]) 
      `stri_subset_regex<-`(str, regex, ..., value = value)
    else if (providedarg["fixed"]) 
      `stri_subset_fixed<-`(str, fixed, ..., value = value)
    else if (providedarg["coll"]) 
      `stri_subset_coll<-`(str, coll, ..., value = value)
    else if (providedarg["charclass"]) 
      `stri_subset_charclass<-`(str, charclass, ..., value = value)
  }, function (str, ..., regex, fixed, coll, charclass, value) 
  {
    providedarg <- c(regex = !missing(regex), fixed = !missing(fixed), coll = !missing(coll), charclass = !missing(charclass))
    if (sum(providedarg) != 1) 
      stop("you have to specify either `regex`, `fixed`, `coll`, or `charclass`")
    if (providedarg["regex"]) 
      `stri_subset_regex<-`(str, regex, ..., value = value)
    else if (providedarg["fixed"]) 
      `stri_subset_fixed<-`(str, fixed, ..., value = value)
    else if (providedarg["coll"]) 
      `stri_subset_coll<-`(str, coll, ..., value = value)
    else if (providedarg["charclass"]) 
      `stri_subset_charclass<-`(str, charclass, ..., value = value)
  })
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_timezone_get
list(`package:stringi` = function () 
{
  stri_timezone_info()$ID
}, function () 
{
  stri_timezone_info()$ID
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_timezone_info
list(`package:stringi` = function (tz = NULL, locale = NULL, display_type = "long") 
{
  .Call(C_stri_timezone_info, tz, locale, display_type)
}, function (tz = NULL, locale = NULL, display_type = "long") 
{
  .Call(C_stri_timezone_info, tz, locale, display_type)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_timezone_list
list(`package:stringi` = function (region = NA, offset = NA) 
{
  stri_sort(.Call(C_stri_timezone_list, region, offset), locale = "en_US", numeric = TRUE, strength = 1)
}, function (region = NA, offset = NA) 
{
  stri_sort(.Call(C_stri_timezone_list, region, offset), locale = "en_US", numeric = TRUE, strength = 1)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_timezone_set
list(`package:stringi` = function (tz) 
{
  previous <- stri_timezone_get()
  .Call(C_stri_timezone_set, tz)
  invisible(previous)
}, function (tz) 
{
  previous <- stri_timezone_get()
  .Call(C_stri_timezone_set, tz)
  invisible(previous)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_casefold
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_casefold, str)
}, function (str) 
{
  .Call(C_stri_trans_casefold, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_char
list(`package:stringi` = function (str, pattern, replacement) 
{
  .Call(C_stri_trans_char, str, pattern, replacement)
}, function (str, pattern, replacement) 
{
  .Call(C_stri_trans_char, str, pattern, replacement)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_general
list(`package:stringi` = function (str, id, rules = FALSE, forward = TRUE) 
{
  .Call(C_stri_trans_general, str, id, rules, forward)
}, function (str, id, rules = FALSE, forward = TRUE) 
{
  .Call(C_stri_trans_general, str, id, rules, forward)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_isnfc
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_isnfc, str)
}, function (str) 
{
  .Call(C_stri_trans_isnfc, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_isnfd
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_isnfd, str)
}, function (str) 
{
  .Call(C_stri_trans_isnfd, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_isnfkc
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_isnfkc, str)
}, function (str) 
{
  .Call(C_stri_trans_isnfkc, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_isnfkc_casefold
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_isnfkc_casefold, str)
}, function (str) 
{
  .Call(C_stri_trans_isnfkc_casefold, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_isnfkd
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_isnfkd, str)
}, function (str) 
{
  .Call(C_stri_trans_isnfkd, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_list
list(`package:stringi` = function () 
{
  stri_sort(.Call(C_stri_trans_list), locale = "en_US", numeric = TRUE, strength = 1)
}, function () 
{
  stri_sort(.Call(C_stri_trans_list), locale = "en_US", numeric = TRUE, strength = 1)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_nfc
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_nfc, str)
}, function (str) 
{
  .Call(C_stri_trans_nfc, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_nfd
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_nfd, str)
}, function (str) 
{
  .Call(C_stri_trans_nfd, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_nfkc
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_nfkc, str)
}, function (str) 
{
  .Call(C_stri_trans_nfkc, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_nfkc_casefold
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_nfkc_casefold, str)
}, function (str) 
{
  .Call(C_stri_trans_nfkc_casefold, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_nfkd
list(`package:stringi` = function (str) 
{
  .Call(C_stri_trans_nfkd, str)
}, function (str) 
{
  .Call(C_stri_trans_nfkd, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_tolower
list(`package:stringi` = function (str, locale = NULL) 
{
  .Call(C_stri_trans_tolower, str, locale)
}, function (str, locale = NULL) 
{
  .Call(C_stri_trans_tolower, str, locale)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_totitle
list(`package:stringi` = function (str, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_trans_totitle, str, opts_brkiter)
}, function (str, ..., opts_brkiter = NULL) 
{
  if (!missing(...)) 
    opts_brkiter <- do.call(stri_opts_brkiter, as.list(c(opts_brkiter, ...)))
  .Call(C_stri_trans_totitle, str, opts_brkiter)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trans_toupper
list(`package:stringi` = function (str, locale = NULL) 
{
  .Call(C_stri_trans_toupper, str, locale)
}, function (str, locale = NULL) 
{
  .Call(C_stri_trans_toupper, str, locale)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trim
list(`package:stringi` = function (str, side = c("both", "left", "right"), pattern = "\\P{Wspace}", negate = FALSE) 
{
  side <- match.arg(side)
  switch(side, both = stri_trim_both(str, pattern, negate), left = stri_trim_left(str, pattern, negate), right = stri_trim_right(str, pattern, negate))
}, function (str, side = c("both", "left", "right"), pattern = "\\P{Wspace}", negate = FALSE) 
{
  side <- match.arg(side)
  switch(side, both = stri_trim_both(str, pattern, negate), left = stri_trim_left(str, pattern, negate), right = stri_trim_right(str, pattern, negate))
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trim_both
list(`package:stringi` = function (str, pattern = "\\P{Wspace}", negate = FALSE) 
{
  .Call(C_stri_trim_both, str, pattern, negate)
}, function (str, pattern = "\\P{Wspace}", negate = FALSE) 
{
  .Call(C_stri_trim_both, str, pattern, negate)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trim_left
list(`package:stringi` = function (str, pattern = "\\P{Wspace}", negate = FALSE) 
{
  .Call(C_stri_trim_left, str, pattern, negate)
}, function (str, pattern = "\\P{Wspace}", negate = FALSE) 
{
  .Call(C_stri_trim_left, str, pattern, negate)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_trim_right
list(`package:stringi` = function (str, pattern = "\\P{Wspace}", negate = FALSE) 
{
  .Call(C_stri_trim_right, str, pattern, negate)
}, function (str, pattern = "\\P{Wspace}", negate = FALSE) 
{
  .Call(C_stri_trim_right, str, pattern, negate)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_unescape_unicode
list(`package:stringi` = function (str) 
{
  .Call(C_stri_unescape_unicode, str)
}, function (str) 
{
  .Call(C_stri_unescape_unicode, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_unique
list(`package:stringi` = function (str, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_unique, str, opts_collator)
}, function (str, ..., opts_collator = NULL) 
{
  if (!missing(...)) 
    opts_collator <- do.call(stri_opts_collator, as.list(c(opts_collator, ...)))
  .Call(C_stri_unique, str, opts_collator)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_width
list(`package:stringi` = function (str) 
{
  .Call(C_stri_width, str)
}, function (str) 
{
  .Call(C_stri_width, str)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_wrap
list(`package:stringi` = function (str, width = floor(0.9 * getOption("width")), cost_exponent = 2, simplify = TRUE, normalize = TRUE, normalise = normalize, indent = 0, exdent = 0, prefix = "", initial = prefix, whitespace_only = FALSE, use_length = FALSE, locale = NULL) 
{
  simplify <- as.logical(simplify)
  if (!missing(normalise)) 
    normalize <- normalise
  normalize <- as.logical(normalize)
  if (normalize) {
    str <- sapply(stri_split_lines(str), function(s) stri_flatten(s, collapse = " "))
    str <- stri_trim(stri_replace_all_charclass(str, "[\\u0020\\r\\n\\t]", " ", merge = TRUE))
    str <- stri_trans_nfc(str)
  }
  ret <- .Call(C_stri_wrap, str, width, cost_exponent, indent, exdent, prefix, initial, whitespace_only, use_length, locale)
  if (simplify) {
    as.character(unlist(ret))
  }
  else ret
}, function (str, width = floor(0.9 * getOption("width")), cost_exponent = 2, simplify = TRUE, normalize = TRUE, normalise = normalize, indent = 0, exdent = 0, prefix = "", initial = prefix, whitespace_only = FALSE, use_length = FALSE, locale = NULL) 
{
  simplify <- as.logical(simplify)
  if (!missing(normalise)) 
    normalize <- normalise
  normalize <- as.logical(normalize)
  if (normalize) {
    str <- sapply(stri_split_lines(str), function(s) stri_flatten(s, collapse = " "))
    str <- stri_trim(stri_replace_all_charclass(str, "[\\u0020\\r\\n\\t]", " ", merge = TRUE))
    str <- stri_trans_nfc(str)
  }
  ret <- .Call(C_stri_wrap, str, width, cost_exponent, indent, exdent, prefix, initial, whitespace_only, use_length, locale)
  if (simplify) {
    as.character(unlist(ret))
  }
  else ret
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)
stri_write_lines
list(`package:stringi` = function (str, con, encoding = "UTF-8", sep = ifelse(.Platform$OS.type == "windows", "\r\n", "\n"), fname = con) 
{
  if (!missing(fname) && missing(con)) {
    con <- fname
  }
  stopifnot(is.character(sep), length(sep) == 1)
  str <- stri_join(str, sep, collapse = "")
  str <- stri_encode(str, "", encoding, to_raw = TRUE)[[1]]
  writeBin(str, con, useBytes = TRUE)
  invisible(NULL)
}, function (str, con, encoding = "UTF-8", sep = ifelse(.Platform$OS.type == "windows", "\r\n", "\n"), fname = con) 
{
  if (!missing(fname) && missing(con)) {
    con <- fname
  }
  stopifnot(is.character(sep), length(sep) == 1)
  str <- stri_join(str, sep, collapse = "")
  str <- stri_encode(str, "", encoding, to_raw = TRUE)[[1]]
  writeBin(str, con, useBytes = TRUE)
  invisible(NULL)
})
c("package:stringi", "namespace:stringi")
c(TRUE, FALSE)
c(FALSE, TRUE)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "\r\n", "\n"), fname = con)
##################################################################################################
library(utils)
.DollarNames
list(`package:utils` = function (x, pattern) 
  UseMethod(".DollarNames"), function (x, pattern) 
    UseMethod(".DollarNames"), new("standardGeneric", .Data = function (x, pattern) 
      standardGeneric(".DollarNames"), generic = ".DollarNames", package = "utils", group = list(), valueClass = character(0), signature = c("x", "pattern"), default = new("derivedDefaultMethod", .Data = function (x, pattern) 
        UseMethod(".DollarNames"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = ".DollarNames"), skeleton = (new("derivedDefaultMethod", .Data = function (x, pattern) 
          UseMethod(".DollarNames"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = ".DollarNames"))(x, pattern)))
c("package:utils", "namespace:utils", "namespace:Rcpp")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
.romans
list(`package:utils` = c(M = 1000, CM = 900, D = 500, CD = 400, C = 100, XC = 90, L = 50, XL = 40, X = 10, IX = 9, V = 5, IV = 4, I = 1), c(M = 1000, CM = 900, D = 500, CD = 400, C = 100, XC = 90, L = 50, XL = 40, X = 10, IX = 9, V = 5, IV = 4, I = 1))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
.RtangleCodeLabel
list(`package:utils` = function (chunk) 
{
  if (length(lnos <- grep("^#line ", chunk, value = TRUE))) {
    srclines <- attr(chunk, "srclines")
    lno <- if (length(srclines)) 
      paste(min(srclines), max(srclines), sep = "-")
    else srclines
    fn <- sub("[^\"]*\"([^\"]+).*", "\\1", lnos[1])
    paste(fn, lno, sep = ":")
  }
  else "(missing #line/file info)"
}, function (chunk) 
{
  if (length(lnos <- grep("^#line ", chunk, value = TRUE))) {
    srclines <- attr(chunk, "srclines")
    lno <- if (length(srclines)) 
      paste(min(srclines), max(srclines), sep = "-")
    else srclines
    fn <- sub("[^\"]*\"([^\"]+).*", "\\1", lnos[1])
    paste(fn, lno, sep = ":")
  }
  else "(missing #line/file info)"
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
.S3methods
list(`package:utils` = function (generic.function, class, envir = parent.frame()) 
{
  rbindSome <- function(df, nms, msg) {
    nms <- unique(nms)
    n2 <- length(nms)
    dnew <- data.frame(visible = rep.int(FALSE, n2), from = rep.int(msg, n2), row.names = nms)
    n <- nrow(df)
    if (n == 0) 
      return(dnew)
    keep <- !duplicated(c(rownames(df), rownames(dnew)))
    rbind(df[keep[1:n], ], dnew[keep[(n + 1):(n + n2)], ])
  }
  S3MethodsStopList <- tools::nonS3methods(NULL)
  knownGenerics <- getKnownS3generics()
  sp <- search()
  if (nzchar(lookup <- Sys.getenv("_R_S3_METHOD_LOOKUP_BASEENV_AFTER_GLOBALENV_"))) {
    lookup <- tools:::config_val_to_logical(lookup)
    if (lookup) 
      sp <- sp[c(1, length(sp))]
  }
  methods.called <- identical(sys.call(-1)[[1]], as.symbol("methods"))
  an <- lapply(seq_along(sp), ls)
  lens <- lengths(an)
  an <- unlist(an, use.names = FALSE)
  names(an) <- rep.int(sp, lens)
  an <- an[!duplicated(an)]
  info <- data.frame(visible = rep.int(TRUE, length(an)), from = .rmpkg(names(an)), row.names = an)
  if (!missing(generic.function)) {
    if (!is.character(generic.function)) 
      generic.function <- deparse1(substitute(generic.function))
    if (!exists(generic.function, mode = "function", envir = envir) && !any(generic.function == c("Math", "Ops", "Complex", "Summary"))) 
      stop(gettextf("no function '%s' is visible", generic.function), domain = NA)
    warn.not.generic <- FALSE
    if (!any(generic.function == knownGenerics)) {
      truegf <- findGeneric(generic.function, envir, warnS4only = !methods.called)
      if (truegf == "") 
        warn.not.generic <- TRUE
      else if (truegf != generic.function) {
        warning(gettextf("generic function '%s' dispatches methods for generic '%s'", generic.function, truegf), domain = NA)
        generic.function <- truegf
      }
    }
    info <- info[startsWith(row.names(info), paste0(generic.function, ".")), ]
    info <- info[!row.names(info) %in% S3MethodsStopList, ]
    if (nrow(info)) {
      keep <- vapply(row.names(info), exists, logical(1), mode = "function")
      info <- info[keep, ]
    }
    if (warn.not.generic && nrow(info)) 
      warning(gettextf("function '%s' appears not to be S3 generic; found functions that look like S3 methods", generic.function), domain = NA)
    defenv <- if (!is.na(w <- .knownS3Generics[generic.function])) 
      asNamespace(w)
    else {
      genfun <- get(generic.function, mode = "function", envir = envir)
      if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
        genfun <- methods::finalDefaultMethod(genfun@default)
      .defenv_for_S3_registry(genfun)
    }
    S3reg <- names(get(".__S3MethodsTable__.", envir = defenv))
    S3reg <- S3reg[startsWith(S3reg, paste0(generic.function, "."))]
    if (length(S3reg)) 
      info <- rbindSome(info, S3reg, msg = paste("registered S3method for", generic.function))
    if (generic.function == "all") 
      info <- info[-grep("^all\\.equal", row.names(info)), ]
  }
  else if (!missing(class)) {
    if (!is.character(class)) 
      class <- deparse1(substitute(class))
    if (length(class) > 1) {
      warning("'class' is of length > 1; only the first element will be used")
      class <- class[1]
    }
    name <- paste0(".", class, "$")
    name <- gsub("([.[])", "\\\\\\1", name)
    info <- info[grep(name, row.names(info)), ]
    info <- info[!row.names(info) %in% S3MethodsStopList, ]
    if (nrow(info)) {
      possible.generics <- gsub(name, "", row.names(info))
      keep <- vapply(possible.generics, function(nm) {
        if (nm %in% knownGenerics) 
          return(TRUE)
        where <- find(nm, mode = "function")
        if (length(where)) 
          any(vapply(where, function(w) nzchar(findGeneric(nm, envir = as.environment(w))), logical(1)))
        else FALSE
      }, logical(1))
      info <- info[keep, ]
    }
    S3reg <- unlist(lapply(loadedNamespaces(), function(i) ls(get(".__S3MethodsTable__.", envir = asNamespace(i)), pattern = name)))
    if (length(S3reg)) 
      S3reg <- S3reg[vapply(gsub(name, "", S3reg), exists, NA)]
    if (length(S3reg)) 
      info <- rbindSome(info, S3reg, msg = "registered S3method")
  }
  else stop("must supply 'generic.function' or 'class'")
  info$generic <- if (!missing(generic.function)) 
    rep.int(generic.function, nrow(info))
  else sub(paste0("\\.", class, "$"), "", row.names(info))
  info$isS4 <- rep.int(FALSE, nrow(info))
  info <- info[sort.list(row.names(info)), , drop = FALSE]
  res <- row.names(info)
  class(res) <- "MethodsFunction"
  attr(res, "info") <- info
  attr(res, "byclass") <- missing(generic.function)
  res
}, function (generic.function, class, envir = parent.frame()) 
{
  rbindSome <- function(df, nms, msg) {
    nms <- unique(nms)
    n2 <- length(nms)
    dnew <- data.frame(visible = rep.int(FALSE, n2), from = rep.int(msg, n2), row.names = nms)
    n <- nrow(df)
    if (n == 0) 
      return(dnew)
    keep <- !duplicated(c(rownames(df), rownames(dnew)))
    rbind(df[keep[1:n], ], dnew[keep[(n + 1):(n + n2)], ])
  }
  S3MethodsStopList <- tools::nonS3methods(NULL)
  knownGenerics <- getKnownS3generics()
  sp <- search()
  if (nzchar(lookup <- Sys.getenv("_R_S3_METHOD_LOOKUP_BASEENV_AFTER_GLOBALENV_"))) {
    lookup <- tools:::config_val_to_logical(lookup)
    if (lookup) 
      sp <- sp[c(1, length(sp))]
  }
  methods.called <- identical(sys.call(-1)[[1]], as.symbol("methods"))
  an <- lapply(seq_along(sp), ls)
  lens <- lengths(an)
  an <- unlist(an, use.names = FALSE)
  names(an) <- rep.int(sp, lens)
  an <- an[!duplicated(an)]
  info <- data.frame(visible = rep.int(TRUE, length(an)), from = .rmpkg(names(an)), row.names = an)
  if (!missing(generic.function)) {
    if (!is.character(generic.function)) 
      generic.function <- deparse1(substitute(generic.function))
    if (!exists(generic.function, mode = "function", envir = envir) && !any(generic.function == c("Math", "Ops", "Complex", "Summary"))) 
      stop(gettextf("no function '%s' is visible", generic.function), domain = NA)
    warn.not.generic <- FALSE
    if (!any(generic.function == knownGenerics)) {
      truegf <- findGeneric(generic.function, envir, warnS4only = !methods.called)
      if (truegf == "") 
        warn.not.generic <- TRUE
      else if (truegf != generic.function) {
        warning(gettextf("generic function '%s' dispatches methods for generic '%s'", generic.function, truegf), domain = NA)
        generic.function <- truegf
      }
    }
    info <- info[startsWith(row.names(info), paste0(generic.function, ".")), ]
    info <- info[!row.names(info) %in% S3MethodsStopList, ]
    if (nrow(info)) {
      keep <- vapply(row.names(info), exists, logical(1), mode = "function")
      info <- info[keep, ]
    }
    if (warn.not.generic && nrow(info)) 
      warning(gettextf("function '%s' appears not to be S3 generic; found functions that look like S3 methods", generic.function), domain = NA)
    defenv <- if (!is.na(w <- .knownS3Generics[generic.function])) 
      asNamespace(w)
    else {
      genfun <- get(generic.function, mode = "function", envir = envir)
      if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
        genfun <- methods::finalDefaultMethod(genfun@default)
      .defenv_for_S3_registry(genfun)
    }
    S3reg <- names(get(".__S3MethodsTable__.", envir = defenv))
    S3reg <- S3reg[startsWith(S3reg, paste0(generic.function, "."))]
    if (length(S3reg)) 
      info <- rbindSome(info, S3reg, msg = paste("registered S3method for", generic.function))
    if (generic.function == "all") 
      info <- info[-grep("^all\\.equal", row.names(info)), ]
  }
  else if (!missing(class)) {
    if (!is.character(class)) 
      class <- deparse1(substitute(class))
    if (length(class) > 1) {
      warning("'class' is of length > 1; only the first element will be used")
      class <- class[1]
    }
    name <- paste0(".", class, "$")
    name <- gsub("([.[])", "\\\\\\1", name)
    info <- info[grep(name, row.names(info)), ]
    info <- info[!row.names(info) %in% S3MethodsStopList, ]
    if (nrow(info)) {
      possible.generics <- gsub(name, "", row.names(info))
      keep <- vapply(possible.generics, function(nm) {
        if (nm %in% knownGenerics) 
          return(TRUE)
        where <- find(nm, mode = "function")
        if (length(where)) 
          any(vapply(where, function(w) nzchar(findGeneric(nm, envir = as.environment(w))), logical(1)))
        else FALSE
      }, logical(1))
      info <- info[keep, ]
    }
    S3reg <- unlist(lapply(loadedNamespaces(), function(i) ls(get(".__S3MethodsTable__.", envir = asNamespace(i)), pattern = name)))
    if (length(S3reg)) 
      S3reg <- S3reg[vapply(gsub(name, "", S3reg), exists, NA)]
    if (length(S3reg)) 
      info <- rbindSome(info, S3reg, msg = "registered S3method")
  }
  else stop("must supply 'generic.function' or 'class'")
  info$generic <- if (!missing(generic.function)) 
    rep.int(generic.function, nrow(info))
  else sub(paste0("\\.", class, "$"), "", row.names(info))
  info$isS4 <- rep.int(FALSE, nrow(info))
  info <- info[sort.list(row.names(info)), , drop = FALSE]
  res <- row.names(info)
  class(res) <- "MethodsFunction"
  attr(res, "info") <- info
  attr(res, "byclass") <- missing(generic.function)
  res
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
?
  list(`package:utils` = function (e1, e2) 
  {
    if (missing(e2)) {
      type <- NULL
      topicExpr <- substitute(e1)
    }
    else {
      type <- substitute(e1)
      topicExpr <- substitute(e2)
    }
    search <- (is.call(topicExpr) && topicExpr[[1]] == "?")
    if (search) {
      topicExpr <- topicExpr[[2]]
      if (is.call(te <- topicExpr) && te[[1]] == "?" && is.call(te <- topicExpr[[2]]) && te[[1]] == "?") {
        cat("Contacting Delphi...")
        flush.console()
        Sys.sleep(2 + stats::rpois(1, 2))
        cat("the oracle is unavailable.\nWe apologize for any inconvenience.\n")
        return(invisible())
      }
    }
    if (is.call(topicExpr) && (topicExpr[[1]] == "::" || topicExpr[[1]] == ":::")) {
      package <- as.character(topicExpr[[2]])
      topicExpr <- topicExpr[[3]]
    }
    else package <- NULL
    if (search) {
      if (is.null(type)) 
        return(eval(substitute(help.search(TOPIC, package = PACKAGE), list(TOPIC = as.character(topicExpr), PACKAGE = package))))
      else return(eval(substitute(help.search(TOPIC, fields = FIELD, package = PACKAGE), list(TOPIC = as.character(topicExpr), FIELD = as.character(type), PACKAGE = package))))
    }
    else {
      if (is.null(type)) {
        if (is.call(topicExpr)) 
          return(.helpForCall(topicExpr, parent.frame()))
        topic <- if (is.name(topicExpr)) 
          as.character(topicExpr)
        else e1
        return(eval(substitute(help(TOPIC, package = PACKAGE), list(TOPIC = topic, PACKAGE = package))))
      }
      else {
        type <- if (is.name(type)) 
          as.character(type)
        else e1
        topic <- if (is.name(topicExpr)) 
          as.character(topicExpr)
        else {
          if (is.call(topicExpr) && identical(type, "method")) 
            return(.helpForCall(topicExpr, parent.frame(), FALSE))
          e2
        }
        if (type == "package") 
          package <- topic
        h <- .tryHelp(topicName(type, topic), package = package)
        if (is.null(h)) {
          if (is.language(topicExpr)) 
            topicExpr <- deparse(topicExpr)
          stop(gettextf("no documentation of type %s and topic %s (or error in processing help)", sQuote(type), sQuote(topicExpr)), domain = NA)
        }
        h
      }
    }
  }, function (e1, e2) 
  {
    if (missing(e2)) {
      type <- NULL
      topicExpr <- substitute(e1)
    }
    else {
      type <- substitute(e1)
      topicExpr <- substitute(e2)
    }
    search <- (is.call(topicExpr) && topicExpr[[1]] == "?")
    if (search) {
      topicExpr <- topicExpr[[2]]
      if (is.call(te <- topicExpr) && te[[1]] == "?" && is.call(te <- topicExpr[[2]]) && te[[1]] == "?") {
        cat("Contacting Delphi...")
        flush.console()
        Sys.sleep(2 + stats::rpois(1, 2))
        cat("the oracle is unavailable.\nWe apologize for any inconvenience.\n")
        return(invisible())
      }
    }
    if (is.call(topicExpr) && (topicExpr[[1]] == "::" || topicExpr[[1]] == ":::")) {
      package <- as.character(topicExpr[[2]])
      topicExpr <- topicExpr[[3]]
    }
    else package <- NULL
    if (search) {
      if (is.null(type)) 
        return(eval(substitute(help.search(TOPIC, package = PACKAGE), list(TOPIC = as.character(topicExpr), PACKAGE = package))))
      else return(eval(substitute(help.search(TOPIC, fields = FIELD, package = PACKAGE), list(TOPIC = as.character(topicExpr), FIELD = as.character(type), PACKAGE = package))))
    }
    else {
      if (is.null(type)) {
        if (is.call(topicExpr)) 
          return(.helpForCall(topicExpr, parent.frame()))
        topic <- if (is.name(topicExpr)) 
          as.character(topicExpr)
        else e1
        return(eval(substitute(help(TOPIC, package = PACKAGE), list(TOPIC = topic, PACKAGE = package))))
      }
      else {
        type <- if (is.name(type)) 
          as.character(type)
        else e1
        topic <- if (is.name(topicExpr)) 
          as.character(topicExpr)
        else {
          if (is.call(topicExpr) && identical(type, "method")) 
            return(.helpForCall(topicExpr, parent.frame(), FALSE))
          e2
        }
        if (type == "package") 
          package <- topic
        h <- .tryHelp(topicName(type, topic), package = package)
        if (is.null(h)) {
          if (is.language(topicExpr)) 
            topicExpr <- deparse(topicExpr)
          stop(gettextf("no documentation of type %s and topic %s (or error in processing help)", sQuote(type), sQuote(topicExpr)), domain = NA)
        }
        h
      }
    }
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
adist
list(`package:utils` = function (x, y = NULL, costs = NULL, counts = FALSE, fixed = TRUE, partial = !fixed, ignore.case = FALSE, useBytes = FALSE) 
{
  bytesToInt <- function(x) {
    if (is.na(x)) 
      return(NA)
    as.integer(charToRaw(x))
  }
  costs <- .amatch_costs(costs)
  nmx <- names(x)
  x <- as.character(x)
  names(x) <- nmx
  if (!is.null(y)) {
    nmy <- names(y)
    y <- as.character(y)
    names(y) <- nmy
  }
  if (!isFALSE(fixed) && !isTRUE(partial)) {
    ex <- Encoding(x)
    useBytes <- isTRUE(useBytes) || any(ex == "bytes")
    if (!is.null(y)) {
      ey <- Encoding(y)
      useBytes <- useBytes || any(ey == "bytes")
    }
    if (useBytes) {
      x <- lapply(x, bytesToInt)
      y <- if (is.null(y)) {
        x
      }
      else {
        lapply(y, bytesToInt)
      }
    }
    else {
      ignore.case <- isTRUE(ignore.case)
      x <- if (ignore.case) {
        lapply(tolower(enc2utf8(x)), utf8ToInt)
      }
      else {
        lapply(enc2utf8(x), utf8ToInt)
      }
      y <- if (is.null(y)) {
        x
      }
      else if (ignore.case) {
        lapply(tolower(enc2utf8(y)), utf8ToInt)
      }
      else {
        lapply(enc2utf8(y), utf8ToInt)
      }
    }
  }
  else {
    if (is.null(y)) {
      y <- x
    }
    costs <- as.integer(costs)
  }
  .Internal(adist(x, y, costs, counts, fixed, partial, ignore.case, useBytes))
}, function (x, y = NULL, costs = NULL, counts = FALSE, fixed = TRUE, partial = !fixed, ignore.case = FALSE, useBytes = FALSE) 
{
  bytesToInt <- function(x) {
    if (is.na(x)) 
      return(NA)
    as.integer(charToRaw(x))
  }
  costs <- .amatch_costs(costs)
  nmx <- names(x)
  x <- as.character(x)
  names(x) <- nmx
  if (!is.null(y)) {
    nmy <- names(y)
    y <- as.character(y)
    names(y) <- nmy
  }
  if (!isFALSE(fixed) && !isTRUE(partial)) {
    ex <- Encoding(x)
    useBytes <- isTRUE(useBytes) || any(ex == "bytes")
    if (!is.null(y)) {
      ey <- Encoding(y)
      useBytes <- useBytes || any(ey == "bytes")
    }
    if (useBytes) {
      x <- lapply(x, bytesToInt)
      y <- if (is.null(y)) {
        x
      }
      else {
        lapply(y, bytesToInt)
      }
    }
    else {
      ignore.case <- isTRUE(ignore.case)
      x <- if (ignore.case) {
        lapply(tolower(enc2utf8(x)), utf8ToInt)
      }
      else {
        lapply(enc2utf8(x), utf8ToInt)
      }
      y <- if (is.null(y)) {
        x
      }
      else if (ignore.case) {
        lapply(tolower(enc2utf8(y)), utf8ToInt)
      }
      else {
        lapply(enc2utf8(y), utf8ToInt)
      }
    }
  }
  else {
    if (is.null(y)) {
      y <- x
    }
    costs <- as.integer(costs)
  }
  .Internal(adist(x, y, costs, counts, fixed, partial, ignore.case, useBytes))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
alarm
list(`package:utils` = function () 
{
  cat("\a")
  flush.console()
}, function () 
{
  cat("\a")
  flush.console()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
apropos
list(`package:utils` = function (what, where = FALSE, ignore.case = TRUE, mode = "any") 
{
  stopifnot(is.character(what))
  x <- character(0)
  check.mode <- mode != "any"
  for (i in seq_along(sp <- search())) {
    li <- if (ignore.case) 
      grep(what, ls(pos = i, all.names = TRUE), ignore.case = TRUE, value = TRUE)
    else ls(pos = i, pattern = what, all.names = TRUE)
    li <- grep("^[.](__|C_|F_)", li, invert = TRUE, value = TRUE)
    if (sp[i] == "package:base") 
      li <- li[!li %in% .dot_internals]
    if (length(li)) {
      if (check.mode) 
        li <- li[vapply(li, exists, NA, where = i, mode = mode, inherits = FALSE)]
      x <- c(x, if (where) structure(li, names = rep.int(i, length(li))) else li)
    }
  }
  sort(x)
}, function (what, where = FALSE, ignore.case = TRUE, mode = "any") 
{
  stopifnot(is.character(what))
  x <- character(0)
  check.mode <- mode != "any"
  for (i in seq_along(sp <- search())) {
    li <- if (ignore.case) 
      grep(what, ls(pos = i, all.names = TRUE), ignore.case = TRUE, value = TRUE)
    else ls(pos = i, pattern = what, all.names = TRUE)
    li <- grep("^[.](__|C_|F_)", li, invert = TRUE, value = TRUE)
    if (sp[i] == "package:base") 
      li <- li[!li %in% .dot_internals]
    if (length(li)) {
      if (check.mode) 
        li <- li[vapply(li, exists, NA, where = i, mode = mode, inherits = FALSE)]
      x <- c(x, if (where) structure(li, names = rep.int(i, length(li))) else li)
    }
  }
  sort(x)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
aregexec
list(`package:utils` = function (pattern, text, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  costs <- as.integer(.amatch_costs(costs))
  bounds <- .amatch_bounds(max.distance)
  .Internal(aregexec(as.character(pattern), as.character(text), bounds, costs, ignore.case, fixed, useBytes))
}, function (pattern, text, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = FALSE, useBytes = FALSE) 
{
  costs <- as.integer(.amatch_costs(costs))
  bounds <- .amatch_bounds(max.distance)
  .Internal(aregexec(as.character(pattern), as.character(text), bounds, costs, ignore.case, fixed, useBytes))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
argsAnywhere
list(`package:utils` = function (x) 
{
  if (tryCatch(!is.character(x), error = function(e) TRUE)) 
    x <- as.character(substitute(x))
  fs <- getAnywhere(x)
  if (sum(!fs$dups) == 0) 
    return(NULL)
  if (sum(!fs$dups) > 1) 
    sapply(fs$objs[!fs$dups], function(f) if (is.function(f)) 
      args(f))
  else args(fs$objs[[1]])
}, function (x) 
{
  if (tryCatch(!is.character(x), error = function(e) TRUE)) 
    x <- as.character(substitute(x))
  fs <- getAnywhere(x)
  if (sum(!fs$dups) == 0) 
    return(NULL)
  if (sum(!fs$dups) > 1) 
    sapply(fs$objs[!fs$dups], function(f) if (is.function(f)) 
      args(f))
  else args(fs$objs[[1]])
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
arrangeWindows
list(`package:utils` = function (action = c("vertical", "horizontal", "cascade", "minimize", "restore"), windows, preserve = TRUE, outer = FALSE) 
{
  action <- match.arg(action)
  action <- which(action == c("cascade", "horizontal", "vertical", "minimize", "restore"))
  stopifnot(length(action) == 1 && !is.na(action))
  if (missing(windows)) {
    args <- if (!is.null(a <- get0(".arrangeWindowsDefaults", globalenv()))) 
      a
    else list()
    if (action == 5) 
      args$minimized <- TRUE
    windows <- do.call(getWindowsHandles, args)
  }
  .External2(C_arrangeWindows, windows, action, preserve, outer)
}, function (action = c("vertical", "horizontal", "cascade", "minimize", "restore"), windows, preserve = TRUE, outer = FALSE) 
{
  action <- match.arg(action)
  action <- which(action == c("cascade", "horizontal", "vertical", "minimize", "restore"))
  stopifnot(length(action) == 1 && !is.na(action))
  if (missing(windows)) {
    args <- if (!is.null(a <- get0(".arrangeWindowsDefaults", globalenv()))) 
      a
    else list()
    if (action == 5) 
      args$minimized <- TRUE
    windows <- do.call(getWindowsHandles, args)
  }
  .External2(C_arrangeWindows, windows, action, preserve, outer)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.person
list(`package:utils` = function (x) 
  UseMethod("as.person"), function (x) 
    UseMethod("as.person"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.personList
list(`package:utils` = function (x) 
  UseMethod("as.personList"), function (x) 
    UseMethod("as.personList"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.relistable
list(`package:utils` = function (x) 
{
  if (!inherits(x, "relistable")) 
    class(x) <- c("relistable", class(x))
  x
}, function (x) 
{
  if (!inherits(x, "relistable")) 
    class(x) <- c("relistable", class(x))
  x
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
as.roman
list(`package:utils` = function (x) 
  .as.roman(x, check.range = TRUE), function (x) 
    .as.roman(x, check.range = TRUE))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
asDateBuilt
list(`package:utils` = function (built) 
{
  as.Date(strsplit(built, split = "; ", fixed = TRUE)[[1]][[3]], format = "%Y-%m-%d")
}, function (built) 
{
  as.Date(strsplit(built, split = "; ", fixed = TRUE)[[1]][[3]], format = "%Y-%m-%d")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
askYesNo
list(`package:utils` = function (msg, default = TRUE, prompts = getOption("askYesNo", gettext(c("Yes", "No", "Cancel"))), ...) 
{
  if (is.character(prompts) && length(prompts) == 1) 
    prompts <- strsplit(prompts, "/")[[1]]
  if (!is.character(prompts) || length(prompts) != 3) {
    fn <- match.fun(prompts)
    return(fn(msg = msg, default = default, prompts = prompts, ...))
  }
  choices <- tolower(prompts)
  if (is.na(default)) 
    choices[3] <- prompts[3]
  else if (default) 
    choices[1] <- prompts[1]
  else choices[2] <- prompts[2]
  msg1 <- paste0("(", paste(choices, collapse = "/"), ") ")
  if (nchar(paste0(msg, msg1)) > 250) {
    cat(msg, "\n")
    msg <- msg1
  }
  else msg <- paste0(msg, " ", msg1)
  ans <- readline(msg)
  match <- pmatch(tolower(ans), tolower(choices))
  if (!nzchar(ans)) 
    default
  else if (is.na(match)) 
    stop("Unrecognized response ", dQuote(ans))
  else c(TRUE, FALSE, NA)[match]
}, function (msg, default = TRUE, prompts = getOption("askYesNo", gettext(c("Yes", "No", "Cancel"))), ...) 
{
  if (is.character(prompts) && length(prompts) == 1) 
    prompts <- strsplit(prompts, "/")[[1]]
  if (!is.character(prompts) || length(prompts) != 3) {
    fn <- match.fun(prompts)
    return(fn(msg = msg, default = default, prompts = prompts, ...))
  }
  choices <- tolower(prompts)
  if (is.na(default)) 
    choices[3] <- prompts[3]
  else if (default) 
    choices[1] <- prompts[1]
  else choices[2] <- prompts[2]
  msg1 <- paste0("(", paste(choices, collapse = "/"), ") ")
  if (nchar(paste0(msg, msg1)) > 250) {
    cat(msg, "\n")
    msg <- msg1
  }
  else msg <- paste0(msg, " ", msg1)
  ans <- readline(msg)
  match <- pmatch(tolower(ans), tolower(choices))
  if (!nzchar(ans)) 
    default
  else if (is.na(match)) 
    stop("Unrecognized response ", dQuote(ans))
  else c(TRUE, FALSE, NA)[match]
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
aspell
list(`package:utils` = function (files, filter, control = list(), encoding = "unknown", program = NULL, dictionaries = character()) 
{
  program <- aspell_find_program(program)
  if (is.na(program)) 
    stop("No suitable spell-checker program found")
  if (inherits(files, "Rd")) 
    files <- list(files)
  files_are_names <- is.character(files)
  filter_args <- list()
  if (missing(filter) || is.null(filter)) {
    filter <- if (!files_are_names) {
      function(ifile, encoding) {
        if (inherits(ifile, "srcfile")) 
          readLines(ifile$filename, encoding = encoding, warn = FALSE)
        else if (inherits(ifile, "connection")) 
          readLines(ifile, encoding = encoding, warn = FALSE)
        else {
          as.character(ifile)
        }
      }
    }
    else NULL
  }
  else if (is.character(filter)) {
    filter_name <- filter[1]
    filter <- aspell_filter_db[[filter_name]]
    if (is.null(filter)) 
      warning(gettextf("Filter '%s' is not available.", filter_name), domain = NA)
  }
  else if (is.list(filter)) {
    filter_name <- filter[[1]][1]
    filter_args <- filter[-1]
    filter <- aspell_filter_db[[filter_name]]
    if (is.null(filter)) 
      warning(gettextf("Filter '%s' is not available.", filter_name), domain = NA)
  }
  else if (!is.function(filter)) 
    stop("Invalid 'filter' argument.")
  encoding <- rep_len(encoding, length(files))
  verbose <- getOption("verbose")
  db <- data.frame(Original = character(), File = character(), Line = integer(), Column = integer(), stringsAsFactors = FALSE)
  db$Suggestions <- list()
  tfile <- tempfile("aspell")
  on.exit(unlink(tfile))
  if (length(dictionaries)) {
    paths <- aspell_find_dictionaries(dictionaries)
    ind <- paths == ""
    if (any(ind)) {
      warning(gettextf("The following dictionaries were not found:\n%s", paste(sprintf("  %s", dictionaries[ind]), collapse = "\n")), domain = NA)
      paths <- paths[!ind]
    }
    if (length(paths)) {
      words <- unlist(lapply(paths, readRDS), use.names = FALSE)
      personal <- tempfile("aspell_personal")
      on.exit(unlink(personal), add = TRUE)
      aspell_write_personal_dictionary_file(words, personal, program = program)
      control <- c(control, "-p", shQuote(personal))
    }
  }
  control <- as.character(control)
  fnames <- names(files)
  files <- as.list(files)
  for (i in seq_along(files)) {
    file <- files[[i]]
    if (files_are_names) 
      fname <- file
    else {
      fname <- if (inherits(file, "srcfile")) 
        file$filename
      else attr(attr(file, "srcref"), "srcfile")$filename
      if (is.null(fname)) 
        fname <- fnames[i]
      if (is.null(fname)) 
        fname <- "<unknown>"
    }
    enc <- encoding[i]
    if (verbose) 
      message(gettextf("Processing file %s", fname), domain = NA)
    lines <- if (is.null(filter)) 
      readLines(file, encoding = enc, warn = FALSE)
    else {
      do.call(filter, c(list(file, encoding = enc), filter_args))
    }
    control <- c(control, attr(lines, "control"))
    writeLines(paste0("^", lines), tfile)
    out <- tools:::.system_with_capture(program, c("-a", control), stdin = tfile)
    if (out$status != 0) 
      stop(gettextf("Running aspell failed with diagnostics:\n%s", paste(out$stderr, collapse = "\n")), domain = NA)
    lines <- out$stdout[-1]
    pos <- cumsum(lines == "") + 1
    if (any(ind <- startsWith(lines, "&"))) {
      info <- strsplit(lines[ind], ": ", fixed = TRUE)
      one <- strsplit(sapply(info, `[`, 1), " ", fixed = TRUE)
      two <- strsplit(sapply(info, `[`, 2), ", ", fixed = TRUE)
      db1 <- list2DF(list(Original = vapply(one, `[`, "", 2), File = rep_len(fname, length(one)), Line = pos[ind], Column = as.integer(vapply(one, `[`, "", 4)), Suggestions = two))
      db <- rbind(db, db1)
    }
    if (any(ind <- startsWith(lines, "#"))) {
      one <- strsplit(lines[ind], " ", fixed = TRUE)
      db1 <- list2DF(list(Original = vapply(one, `[`, "", 2), File = rep_len(fname, length(one)), Line = pos[ind], Column = as.integer(vapply(one, `[`, "", 3)), Suggestions = vector("list", length(one))))
      db <- rbind(db, db1)
    }
  }
  class(db) <- c("aspell", "data.frame")
  db
}, function (files, filter, control = list(), encoding = "unknown", program = NULL, dictionaries = character()) 
{
  program <- aspell_find_program(program)
  if (is.na(program)) 
    stop("No suitable spell-checker program found")
  if (inherits(files, "Rd")) 
    files <- list(files)
  files_are_names <- is.character(files)
  filter_args <- list()
  if (missing(filter) || is.null(filter)) {
    filter <- if (!files_are_names) {
      function(ifile, encoding) {
        if (inherits(ifile, "srcfile")) 
          readLines(ifile$filename, encoding = encoding, warn = FALSE)
        else if (inherits(ifile, "connection")) 
          readLines(ifile, encoding = encoding, warn = FALSE)
        else {
          as.character(ifile)
        }
      }
    }
    else NULL
  }
  else if (is.character(filter)) {
    filter_name <- filter[1]
    filter <- aspell_filter_db[[filter_name]]
    if (is.null(filter)) 
      warning(gettextf("Filter '%s' is not available.", filter_name), domain = NA)
  }
  else if (is.list(filter)) {
    filter_name <- filter[[1]][1]
    filter_args <- filter[-1]
    filter <- aspell_filter_db[[filter_name]]
    if (is.null(filter)) 
      warning(gettextf("Filter '%s' is not available.", filter_name), domain = NA)
  }
  else if (!is.function(filter)) 
    stop("Invalid 'filter' argument.")
  encoding <- rep_len(encoding, length(files))
  verbose <- getOption("verbose")
  db <- data.frame(Original = character(), File = character(), Line = integer(), Column = integer(), stringsAsFactors = FALSE)
  db$Suggestions <- list()
  tfile <- tempfile("aspell")
  on.exit(unlink(tfile))
  if (length(dictionaries)) {
    paths <- aspell_find_dictionaries(dictionaries)
    ind <- paths == ""
    if (any(ind)) {
      warning(gettextf("The following dictionaries were not found:\n%s", paste(sprintf("  %s", dictionaries[ind]), collapse = "\n")), domain = NA)
      paths <- paths[!ind]
    }
    if (length(paths)) {
      words <- unlist(lapply(paths, readRDS), use.names = FALSE)
      personal <- tempfile("aspell_personal")
      on.exit(unlink(personal), add = TRUE)
      aspell_write_personal_dictionary_file(words, personal, program = program)
      control <- c(control, "-p", shQuote(personal))
    }
  }
  control <- as.character(control)
  fnames <- names(files)
  files <- as.list(files)
  for (i in seq_along(files)) {
    file <- files[[i]]
    if (files_are_names) 
      fname <- file
    else {
      fname <- if (inherits(file, "srcfile")) 
        file$filename
      else attr(attr(file, "srcref"), "srcfile")$filename
      if (is.null(fname)) 
        fname <- fnames[i]
      if (is.null(fname)) 
        fname <- "<unknown>"
    }
    enc <- encoding[i]
    if (verbose) 
      message(gettextf("Processing file %s", fname), domain = NA)
    lines <- if (is.null(filter)) 
      readLines(file, encoding = enc, warn = FALSE)
    else {
      do.call(filter, c(list(file, encoding = enc), filter_args))
    }
    control <- c(control, attr(lines, "control"))
    writeLines(paste0("^", lines), tfile)
    out <- tools:::.system_with_capture(program, c("-a", control), stdin = tfile)
    if (out$status != 0) 
      stop(gettextf("Running aspell failed with diagnostics:\n%s", paste(out$stderr, collapse = "\n")), domain = NA)
    lines <- out$stdout[-1]
    pos <- cumsum(lines == "") + 1
    if (any(ind <- startsWith(lines, "&"))) {
      info <- strsplit(lines[ind], ": ", fixed = TRUE)
      one <- strsplit(sapply(info, `[`, 1), " ", fixed = TRUE)
      two <- strsplit(sapply(info, `[`, 2), ", ", fixed = TRUE)
      db1 <- list2DF(list(Original = vapply(one, `[`, "", 2), File = rep_len(fname, length(one)), Line = pos[ind], Column = as.integer(vapply(one, `[`, "", 4)), Suggestions = two))
      db <- rbind(db, db1)
    }
    if (any(ind <- startsWith(lines, "#"))) {
      one <- strsplit(lines[ind], " ", fixed = TRUE)
      db1 <- list2DF(list(Original = vapply(one, `[`, "", 2), File = rep_len(fname, length(one)), Line = pos[ind], Column = as.integer(vapply(one, `[`, "", 3)), Suggestions = vector("list", length(one))))
      db <- rbind(db, db1)
    }
  }
  class(db) <- c("aspell", "data.frame")
  db
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
aspell_package_C_files
list(`package:utils` = function (dir, ignore = character(), control = list(), program = NULL, dictionaries = character()) 
{
  dir <- tools::file_path_as_absolute(dir)
  files <- file.path(dir, "po", paste(basename(dir), "pot", collapse = "."))
  files <- files[file_test("-f", files)]
  meta <- tools:::.get_package_metadata(dir, installed = FALSE)
  if (is.na(encoding <- meta["Encoding"])) 
    encoding <- "unknown"
  defaults <- .aspell_package_defaults(dir, encoding)$C_files
  if (!is.null(defaults)) {
    if (!is.null(d <- defaults$ignore)) 
      ignore <- d
    if (!is.null(d <- defaults$control)) 
      control <- d
    if (!is.null(d <- defaults$program)) 
      program <- d
    if (!is.null(d <- defaults$dictionaries)) {
      dictionaries <- aspell_find_dictionaries(d, file.path(dir, ".aspell"))
    }
  }
  program <- aspell_find_program(program)
  aspell(files, filter = list("pot", ignore = ignore), control = control, encoding = encoding, program = program, dictionaries = dictionaries)
}, function (dir, ignore = character(), control = list(), program = NULL, dictionaries = character()) 
{
  dir <- tools::file_path_as_absolute(dir)
  files <- file.path(dir, "po", paste(basename(dir), "pot", collapse = "."))
  files <- files[file_test("-f", files)]
  meta <- tools:::.get_package_metadata(dir, installed = FALSE)
  if (is.na(encoding <- meta["Encoding"])) 
    encoding <- "unknown"
  defaults <- .aspell_package_defaults(dir, encoding)$C_files
  if (!is.null(defaults)) {
    if (!is.null(d <- defaults$ignore)) 
      ignore <- d
    if (!is.null(d <- defaults$control)) 
      control <- d
    if (!is.null(d <- defaults$program)) 
      program <- d
    if (!is.null(d <- defaults$dictionaries)) {
      dictionaries <- aspell_find_dictionaries(d, file.path(dir, ".aspell"))
    }
  }
  program <- aspell_find_program(program)
  aspell(files, filter = list("pot", ignore = ignore), control = control, encoding = encoding, program = program, dictionaries = dictionaries)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
aspell_package_R_files
list(`package:utils` = function (dir, ignore = character(), control = list(), program = NULL, dictionaries = character()) 
{
  dir <- tools::file_path_as_absolute(dir)
  subdir <- file.path(dir, "R")
  files <- if (dir.exists(subdir)) 
    tools::list_files_with_type(subdir, "code", OS_subdirs = c("unix", "windows"))
  else character()
  meta <- tools:::.get_package_metadata(dir, installed = FALSE)
  if (is.na(encoding <- meta["Encoding"])) 
    encoding <- "unknown"
  defaults <- .aspell_package_defaults(dir, encoding)$R_files
  if (!is.null(defaults)) {
    if (!is.null(d <- defaults$ignore)) 
      ignore <- d
    if (!is.null(d <- defaults$control)) 
      control <- d
    if (!is.null(d <- defaults$program)) 
      program <- d
    if (!is.null(d <- defaults$dictionaries)) {
      dictionaries <- aspell_find_dictionaries(d, file.path(dir, ".aspell"))
    }
  }
  program <- aspell_find_program(program)
  aspell(files, filter = list("R", ignore = ignore), control = control, encoding = encoding, program = program, dictionaries = dictionaries)
}, function (dir, ignore = character(), control = list(), program = NULL, dictionaries = character()) 
{
  dir <- tools::file_path_as_absolute(dir)
  subdir <- file.path(dir, "R")
  files <- if (dir.exists(subdir)) 
    tools::list_files_with_type(subdir, "code", OS_subdirs = c("unix", "windows"))
  else character()
  meta <- tools:::.get_package_metadata(dir, installed = FALSE)
  if (is.na(encoding <- meta["Encoding"])) 
    encoding <- "unknown"
  defaults <- .aspell_package_defaults(dir, encoding)$R_files
  if (!is.null(defaults)) {
    if (!is.null(d <- defaults$ignore)) 
      ignore <- d
    if (!is.null(d <- defaults$control)) 
      control <- d
    if (!is.null(d <- defaults$program)) 
      program <- d
    if (!is.null(d <- defaults$dictionaries)) {
      dictionaries <- aspell_find_dictionaries(d, file.path(dir, ".aspell"))
    }
  }
  program <- aspell_find_program(program)
  aspell(files, filter = list("R", ignore = ignore), control = control, encoding = encoding, program = program, dictionaries = dictionaries)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
aspell_package_Rd_files
list(`package:utils` = function (dir, drop = c("\\author", "\\references"), control = list(), program = NULL, dictionaries = character()) 
{
  dir <- normalizePath(dir, "/")
  subdir <- file.path(dir, "man")
  files <- if (dir.exists(subdir)) 
    tools::list_files_with_type(subdir, "docs", OS_subdirs = c("unix", "windows"))
  else character()
  meta <- tools:::.get_package_metadata(dir, installed = FALSE)
  if (is.na(encoding <- meta["Encoding"])) 
    encoding <- "unknown"
  defaults <- .aspell_package_defaults(dir, encoding)$Rd_files
  if (!is.null(defaults)) {
    if (!is.null(d <- defaults$drop)) 
      drop <- d
    if (!is.null(d <- defaults$control)) 
      control <- d
    if (!is.null(d <- defaults$program)) 
      program <- d
    if (!is.null(d <- defaults$dictionaries)) {
      dictionaries <- aspell_find_dictionaries(d, file.path(dir, ".aspell"))
    }
    if (!is.null(d <- defaults$personal)) 
      control <- c(control, sprintf("-p %s", shQuote(file.path(dir, ".aspell", d))))
  }
  macros <- tools::loadPkgRdMacros(dir, macros = file.path(R.home("share"), "Rd", "macros", "system.Rd"))
  aspell(files, filter = list("Rd", drop = drop, macros = macros), control = control, encoding = encoding, program = program, dictionaries = dictionaries)
}, function (dir, drop = c("\\author", "\\references"), control = list(), program = NULL, dictionaries = character()) 
{
  dir <- normalizePath(dir, "/")
  subdir <- file.path(dir, "man")
  files <- if (dir.exists(subdir)) 
    tools::list_files_with_type(subdir, "docs", OS_subdirs = c("unix", "windows"))
  else character()
  meta <- tools:::.get_package_metadata(dir, installed = FALSE)
  if (is.na(encoding <- meta["Encoding"])) 
    encoding <- "unknown"
  defaults <- .aspell_package_defaults(dir, encoding)$Rd_files
  if (!is.null(defaults)) {
    if (!is.null(d <- defaults$drop)) 
      drop <- d
    if (!is.null(d <- defaults$control)) 
      control <- d
    if (!is.null(d <- defaults$program)) 
      program <- d
    if (!is.null(d <- defaults$dictionaries)) {
      dictionaries <- aspell_find_dictionaries(d, file.path(dir, ".aspell"))
    }
    if (!is.null(d <- defaults$personal)) 
      control <- c(control, sprintf("-p %s", shQuote(file.path(dir, ".aspell", d))))
  }
  macros <- tools::loadPkgRdMacros(dir, macros = file.path(R.home("share"), "Rd", "macros", "system.Rd"))
  aspell(files, filter = list("Rd", drop = drop, macros = macros), control = control, encoding = encoding, program = program, dictionaries = dictionaries)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
aspell_package_vignettes
list(`package:utils` = function (dir, control = list(), program = NULL, dictionaries = character()) 
{
  dir <- tools::file_path_as_absolute(dir)
  vinfo <- tools::pkgVignettes(dir = dir)
  files <- vinfo$docs
  if (!length(files)) 
    return(aspell(character()))
  meta <- tools:::.get_package_metadata(dir, installed = FALSE)
  if (is.na(encoding <- meta["Encoding"])) 
    encoding <- "unknown"
  defaults <- .aspell_package_defaults(dir, encoding)$vignettes
  if (!is.null(defaults)) {
    if (!is.null(d <- defaults$control)) 
      control <- d
    if (!is.null(d <- defaults$program)) 
      program <- d
    if (!is.null(d <- defaults$dictionaries)) {
      dictionaries <- aspell_find_dictionaries(d, file.path(dir, ".aspell"))
    }
    if (!is.null(d <- defaults$personal)) 
      control <- c(control, sprintf("-p %s", shQuote(file.path(dir, ".aspell", d))))
  }
  program <- aspell_find_program(program)
  fgroups <- split(files, vinfo$engines)
  egroups <- split(vinfo$encodings, vinfo$engines)
  do.call(rbind, Map(function(fgroup, egroup, engine) {
    engine <- tools::vignetteEngine(engine)
    aspell(fgroup, filter = engine$aspell$filter, control = c(engine$aspell$control, aspell_control_package_vignettes[[names(program)]], control), encoding = egroup, program = program, dictionaries = dictionaries)
  }, fgroups, egroups, names(fgroups)))
}, function (dir, control = list(), program = NULL, dictionaries = character()) 
{
  dir <- tools::file_path_as_absolute(dir)
  vinfo <- tools::pkgVignettes(dir = dir)
  files <- vinfo$docs
  if (!length(files)) 
    return(aspell(character()))
  meta <- tools:::.get_package_metadata(dir, installed = FALSE)
  if (is.na(encoding <- meta["Encoding"])) 
    encoding <- "unknown"
  defaults <- .aspell_package_defaults(dir, encoding)$vignettes
  if (!is.null(defaults)) {
    if (!is.null(d <- defaults$control)) 
      control <- d
    if (!is.null(d <- defaults$program)) 
      program <- d
    if (!is.null(d <- defaults$dictionaries)) {
      dictionaries <- aspell_find_dictionaries(d, file.path(dir, ".aspell"))
    }
    if (!is.null(d <- defaults$personal)) 
      control <- c(control, sprintf("-p %s", shQuote(file.path(dir, ".aspell", d))))
  }
  program <- aspell_find_program(program)
  fgroups <- split(files, vinfo$engines)
  egroups <- split(vinfo$encodings, vinfo$engines)
  do.call(rbind, Map(function(fgroup, egroup, engine) {
    engine <- tools::vignetteEngine(engine)
    aspell(fgroup, filter = engine$aspell$filter, control = c(engine$aspell$control, aspell_control_package_vignettes[[names(program)]], control), encoding = egroup, program = program, dictionaries = dictionaries)
  }, fgroups, egroups, names(fgroups)))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
aspell_write_personal_dictionary_file
list(`package:utils` = function (x, out, language = "en", program = NULL) 
{
  if (inherits(x, "aspell")) 
    x <- sort(unique(x$Original))
  program <- aspell_find_program(program)
  if (is.na(program)) 
    stop("No suitable spell check program found.")
  if (names(program) == "aspell") {
    header <- sprintf("personal_ws-1.1 %s %d UTF-8", language, length(x))
    x <- enc2utf8(x)
  }
  else {
    header <- NULL
  }
  writeLines(c(header, x), out, useBytes = TRUE)
}, function (x, out, language = "en", program = NULL) 
{
  if (inherits(x, "aspell")) 
    x <- sort(unique(x$Original))
  program <- aspell_find_program(program)
  if (is.na(program)) 
    stop("No suitable spell check program found.")
  if (names(program) == "aspell") {
    header <- sprintf("personal_ws-1.1 %s %d UTF-8", language, length(x))
    x <- enc2utf8(x)
  }
  else {
    header <- NULL
  }
  writeLines(c(header, x), out, useBytes = TRUE)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
assignInMyNamespace
list(`package:utils` = function (x, value) 
{
  f <- sys.function(-1)
  ns <- environment(f)
  if (isS4(f)) 
    while (!isNamespace(ns)) ns <- parent.env(ns)
  if (bindingIsLocked(x, ns)) {
    unlockBinding(x, ns)
    assign(x, value, envir = ns, inherits = FALSE)
    w <- options("warn")
    on.exit(options(w))
    options(warn = -1)
    lockBinding(x, ns)
  }
  else assign(x, value, envir = ns, inherits = FALSE)
  if (!isBaseNamespace(ns)) {
    S3 <- getNamespaceInfo(ns, "S3methods")
    if (!length(S3)) 
      return(invisible(NULL))
    S3names <- S3[, 3]
    if (x %in% S3names) {
      i <- match(x, S3names)
      genfun <- get(S3[i, 1], mode = "function", envir = parent.frame())
      if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
        genfun <- methods::slot(genfun, "default")@methods$ANY
      defenv <- .defenv_for_S3_registry(genfun)
      S3Table <- get(".__S3MethodsTable__.", envir = defenv)
      remappedName <- paste(S3[i, 1], S3[i, 2], sep = ".")
      if (exists(remappedName, envir = S3Table, inherits = FALSE)) 
        assign(remappedName, value, S3Table)
    }
  }
  invisible(NULL)
}, function (x, value) 
{
  f <- sys.function(-1)
  ns <- environment(f)
  if (isS4(f)) 
    while (!isNamespace(ns)) ns <- parent.env(ns)
  if (bindingIsLocked(x, ns)) {
    unlockBinding(x, ns)
    assign(x, value, envir = ns, inherits = FALSE)
    w <- options("warn")
    on.exit(options(w))
    options(warn = -1)
    lockBinding(x, ns)
  }
  else assign(x, value, envir = ns, inherits = FALSE)
  if (!isBaseNamespace(ns)) {
    S3 <- getNamespaceInfo(ns, "S3methods")
    if (!length(S3)) 
      return(invisible(NULL))
    S3names <- S3[, 3]
    if (x %in% S3names) {
      i <- match(x, S3names)
      genfun <- get(S3[i, 1], mode = "function", envir = parent.frame())
      if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
        genfun <- methods::slot(genfun, "default")@methods$ANY
      defenv <- .defenv_for_S3_registry(genfun)
      S3Table <- get(".__S3MethodsTable__.", envir = defenv)
      remappedName <- paste(S3[i, 1], S3[i, 2], sep = ".")
      if (exists(remappedName, envir = S3Table, inherits = FALSE)) 
        assign(remappedName, value, S3Table)
    }
  }
  invisible(NULL)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
assignInNamespace
list(`package:utils` = function (x, value, ns, pos = -1, envir = as.environment(pos)) 
{
  nf <- sys.nframe()
  if (missing(ns)) {
    nm <- attr(envir, "name", exact = TRUE)
    if (is.null(nm) || !startsWith(nm, "package:")) 
      stop("environment specified is not a package")
    ns <- asNamespace(substring(nm, 9))
  }
  else ns <- asNamespace(ns)
  ns_name <- getNamespaceName(ns)
  if (nf > 1) {
    if (ns_name %in% tools:::.get_standard_package_names()$base) 
      stop("locked binding of ", sQuote(x), " cannot be changed", domain = NA)
  }
  if (bindingIsLocked(x, ns)) {
    in_load <- Sys.getenv("_R_NS_LOAD_")
    if (nzchar(in_load)) {
      if (in_load != ns_name) {
        msg <- gettextf("changing locked binding for %s in %s whilst loading %s", sQuote(x), sQuote(ns_name), sQuote(in_load))
        if (!in_load %in% c("Matrix", "SparseM")) 
          warning(msg, call. = FALSE, domain = NA, immediate. = TRUE)
      }
    }
    else if (nzchar(Sys.getenv("_R_WARN_ON_LOCKED_BINDINGS_"))) {
      warning(gettextf("changing locked binding for %s in %s", sQuote(x), sQuote(ns_name)), call. = FALSE, domain = NA, immediate. = TRUE)
    }
    unlockBinding(x, ns)
    assign(x, value, envir = ns, inherits = FALSE)
    w <- options("warn")
    on.exit(options(w))
    options(warn = -1)
    lockBinding(x, ns)
  }
  else {
    assign(x, value, envir = ns, inherits = FALSE)
  }
  if (!isBaseNamespace(ns)) {
    S3 <- .getNamespaceInfo(ns, "S3methods")
    if (!length(S3)) 
      return(invisible(NULL))
    S3names <- S3[, 3]
    if (x %in% S3names) {
      i <- match(x, S3names)
      genfun <- get(S3[i, 1], mode = "function", envir = parent.frame())
      if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
        genfun <- methods::slot(genfun, "default")@methods$ANY
      defenv <- .defenv_for_S3_registry(genfun)
      S3Table <- get(".__S3MethodsTable__.", envir = defenv)
      remappedName <- paste(S3[i, 1], S3[i, 2], sep = ".")
      if (exists(remappedName, envir = S3Table, inherits = FALSE)) 
        assign(remappedName, value, S3Table)
    }
  }
  invisible(NULL)
}, function (x, value, ns, pos = -1, envir = as.environment(pos)) 
{
  nf <- sys.nframe()
  if (missing(ns)) {
    nm <- attr(envir, "name", exact = TRUE)
    if (is.null(nm) || !startsWith(nm, "package:")) 
      stop("environment specified is not a package")
    ns <- asNamespace(substring(nm, 9))
  }
  else ns <- asNamespace(ns)
  ns_name <- getNamespaceName(ns)
  if (nf > 1) {
    if (ns_name %in% tools:::.get_standard_package_names()$base) 
      stop("locked binding of ", sQuote(x), " cannot be changed", domain = NA)
  }
  if (bindingIsLocked(x, ns)) {
    in_load <- Sys.getenv("_R_NS_LOAD_")
    if (nzchar(in_load)) {
      if (in_load != ns_name) {
        msg <- gettextf("changing locked binding for %s in %s whilst loading %s", sQuote(x), sQuote(ns_name), sQuote(in_load))
        if (!in_load %in% c("Matrix", "SparseM")) 
          warning(msg, call. = FALSE, domain = NA, immediate. = TRUE)
      }
    }
    else if (nzchar(Sys.getenv("_R_WARN_ON_LOCKED_BINDINGS_"))) {
      warning(gettextf("changing locked binding for %s in %s", sQuote(x), sQuote(ns_name)), call. = FALSE, domain = NA, immediate. = TRUE)
    }
    unlockBinding(x, ns)
    assign(x, value, envir = ns, inherits = FALSE)
    w <- options("warn")
    on.exit(options(w))
    options(warn = -1)
    lockBinding(x, ns)
  }
  else {
    assign(x, value, envir = ns, inherits = FALSE)
  }
  if (!isBaseNamespace(ns)) {
    S3 <- .getNamespaceInfo(ns, "S3methods")
    if (!length(S3)) 
      return(invisible(NULL))
    S3names <- S3[, 3]
    if (x %in% S3names) {
      i <- match(x, S3names)
      genfun <- get(S3[i, 1], mode = "function", envir = parent.frame())
      if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
        genfun <- methods::slot(genfun, "default")@methods$ANY
      defenv <- .defenv_for_S3_registry(genfun)
      S3Table <- get(".__S3MethodsTable__.", envir = defenv)
      remappedName <- paste(S3[i, 1], S3[i, 2], sep = ".")
      if (exists(remappedName, envir = S3Table, inherits = FALSE)) 
        assign(remappedName, value, S3Table)
    }
  }
  invisible(NULL)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
available.packages
list(`package:utils` = function (contriburl = contrib.url(repos, type), method, fields = NULL, type = getOption("pkgType"), filters = NULL, repos = getOption("repos"), ignore_repo_cache = FALSE, max_repo_cache_age, quiet = TRUE, ...) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  requiredFields <- c(tools:::.get_standard_repository_db_fields(), "File")
  if (is.null(fields)) 
    fields <- requiredFields
  else {
    stopifnot(is.character(fields))
    fields <- unique(c(requiredFields, fields))
  }
  if (missing(max_repo_cache_age)) 
    max_repo_cache_age <- as.numeric(Sys.getenv("R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE", "3600"))
  timestamp <- Sys.time()
  res <- matrix(NA, 0, length(fields) + 1, dimnames = list(NULL, c(fields, "Repository")))
  for (repos in contriburl) {
    localcran <- startsWith(repos, "file:")
    if (localcran) {
      if (startsWith(repos, "file:///")) {
        tmpf <- paste0(substring(repos, 8), "/PACKAGES")
        if (.Platform$OS.type == "windows") {
          if (length(grep("^/[A-Za-z]:", tmpf))) 
            tmpf <- substring(tmpf, 2)
        }
      }
      else {
        tmpf <- paste0(substring(repos, 6), "/PACKAGES")
      }
      res0 <- if (file.exists(dest <- paste0(tmpf, ".rds"))) 
        readRDS(dest)
      else read.dcf(file = tmpf)
      if (length(res0)) 
        rownames(res0) <- res0[, "Package"]
    }
    else {
      used_dest <- FALSE
      if (ignore_repo_cache) {
        dest <- tempfile()
      }
      else {
        dest <- file.path(tempdir(), paste0("repos_", URLencode(repos, TRUE), ".rds"))
        if (file.exists(dest)) {
          age <- difftime(timestamp, file.mtime(dest), units = "secs")
          if (isTRUE(age < max_repo_cache_age)) {
            res0 <- readRDS(dest)
            used_dest <- TRUE
            if (length(res0)) 
              rownames(res0) <- res0[, "Package"]
          }
          else unlink(dest)
        }
      }
      if (!used_dest) {
        need_dest <- FALSE
        op <- options(warn = -1)
        z <- tryCatch({
          download.file(url = paste0(repos, "/PACKAGES.rds"), destfile = dest, method = method, cacheOK = FALSE, quiet = quiet, mode = "wb", ...)
        }, error = identity)
        options(op)
        if (!inherits(z, "error")) {
          z <- res0 <- tryCatch(readRDS(dest), error = identity)
          if (ignore_repo_cache) 
            unlink(dest)
        }
        if (inherits(z, "error")) {
          if (!ignore_repo_cache) 
            need_dest <- TRUE
          tmpf <- tempfile()
          on.exit(unlink(tmpf))
          op <- options(warn = -1)
          z <- tryCatch({
            download.file(url = paste0(repos, "/PACKAGES.gz"), destfile = tmpf, method = method, cacheOK = FALSE, quiet = quiet, mode = "wb", ...)
          }, error = identity)
          if (inherits(z, "error")) 
            z <- tryCatch({
              download.file(url = paste0(repos, "/PACKAGES"), destfile = tmpf, method = method, cacheOK = FALSE, quiet = quiet, mode = "wb", ...)
            }, error = identity)
          options(op)
          if (!inherits(z, "error")) 
            z <- res0 <- tryCatch(read.dcf(file = tmpf), error = identity)
          unlink(tmpf)
          on.exit()
        }
        if (inherits(z, "error")) {
          warning(gettextf("unable to access index for repository %s", repos), ":\n  ", conditionMessage(z), call. = FALSE, immediate. = TRUE, domain = NA)
          unlink(dest)
          next
        }
        if (length(res0)) {
          rownames(res0) <- res0[, "Package"]
          if (need_dest) 
            saveRDS(res0, dest, compress = TRUE)
        }
        else if (!need_dest) {
          unlink(dest)
        }
      }
    }
    if (length(res0)) {
      missingFields <- fields[!(fields %in% colnames(res0))]
      if (length(missingFields)) {
        toadd <- matrix(NA, nrow = nrow(res0), ncol = length(missingFields), dimnames = list(NULL, missingFields))
        res0 <- cbind(res0, toadd)
      }
      if ("Path" %in% colnames(res0)) {
        rp <- rep.int(repos, nrow(res0))
        path <- res0[, "Path"]
        rp[!is.na(path)] <- paste(repos, path[!is.na(path)], sep = "/")
      }
      else rp <- repos
      res0 <- cbind(res0[, fields, drop = FALSE], Repository = rp)
      res <- rbind(res, res0, deparse.level = 0)
    }
  }
  if (!length(res)) 
    return(res)
  if (is.null(filters)) {
    filters <- getOption("available_packages_filters")
    if (is.null(filters)) 
      filters <- available_packages_filters_default
  }
  if (is.list(filters)) {
    if (isTRUE(filters$add)) {
      filters$add <- NULL
      filters <- c(available_packages_filters_default, filters)
    }
  }
  for (f in filters) {
    if (!length(res)) 
      break
    if (is.character(f)) {
      f <- available_packages_filters_db[[f[1]]]
    }
    if (!is.function(f)) 
      stop("invalid 'filters' argument.")
    res <- f(res)
  }
  res
}, function (contriburl = contrib.url(repos, type), method, fields = NULL, type = getOption("pkgType"), filters = NULL, repos = getOption("repos"), ignore_repo_cache = FALSE, max_repo_cache_age, quiet = TRUE, ...) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  requiredFields <- c(tools:::.get_standard_repository_db_fields(), "File")
  if (is.null(fields)) 
    fields <- requiredFields
  else {
    stopifnot(is.character(fields))
    fields <- unique(c(requiredFields, fields))
  }
  if (missing(max_repo_cache_age)) 
    max_repo_cache_age <- as.numeric(Sys.getenv("R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE", "3600"))
  timestamp <- Sys.time()
  res <- matrix(NA, 0, length(fields) + 1, dimnames = list(NULL, c(fields, "Repository")))
  for (repos in contriburl) {
    localcran <- startsWith(repos, "file:")
    if (localcran) {
      if (startsWith(repos, "file:///")) {
        tmpf <- paste0(substring(repos, 8), "/PACKAGES")
        if (.Platform$OS.type == "windows") {
          if (length(grep("^/[A-Za-z]:", tmpf))) 
            tmpf <- substring(tmpf, 2)
        }
      }
      else {
        tmpf <- paste0(substring(repos, 6), "/PACKAGES")
      }
      res0 <- if (file.exists(dest <- paste0(tmpf, ".rds"))) 
        readRDS(dest)
      else read.dcf(file = tmpf)
      if (length(res0)) 
        rownames(res0) <- res0[, "Package"]
    }
    else {
      used_dest <- FALSE
      if (ignore_repo_cache) {
        dest <- tempfile()
      }
      else {
        dest <- file.path(tempdir(), paste0("repos_", URLencode(repos, TRUE), ".rds"))
        if (file.exists(dest)) {
          age <- difftime(timestamp, file.mtime(dest), units = "secs")
          if (isTRUE(age < max_repo_cache_age)) {
            res0 <- readRDS(dest)
            used_dest <- TRUE
            if (length(res0)) 
              rownames(res0) <- res0[, "Package"]
          }
          else unlink(dest)
        }
      }
      if (!used_dest) {
        need_dest <- FALSE
        op <- options(warn = -1)
        z <- tryCatch({
          download.file(url = paste0(repos, "/PACKAGES.rds"), destfile = dest, method = method, cacheOK = FALSE, quiet = quiet, mode = "wb", ...)
        }, error = identity)
        options(op)
        if (!inherits(z, "error")) {
          z <- res0 <- tryCatch(readRDS(dest), error = identity)
          if (ignore_repo_cache) 
            unlink(dest)
        }
        if (inherits(z, "error")) {
          if (!ignore_repo_cache) 
            need_dest <- TRUE
          tmpf <- tempfile()
          on.exit(unlink(tmpf))
          op <- options(warn = -1)
          z <- tryCatch({
            download.file(url = paste0(repos, "/PACKAGES.gz"), destfile = tmpf, method = method, cacheOK = FALSE, quiet = quiet, mode = "wb", ...)
          }, error = identity)
          if (inherits(z, "error")) 
            z <- tryCatch({
              download.file(url = paste0(repos, "/PACKAGES"), destfile = tmpf, method = method, cacheOK = FALSE, quiet = quiet, mode = "wb", ...)
            }, error = identity)
          options(op)
          if (!inherits(z, "error")) 
            z <- res0 <- tryCatch(read.dcf(file = tmpf), error = identity)
          unlink(tmpf)
          on.exit()
        }
        if (inherits(z, "error")) {
          warning(gettextf("unable to access index for repository %s", repos), ":\n  ", conditionMessage(z), call. = FALSE, immediate. = TRUE, domain = NA)
          unlink(dest)
          next
        }
        if (length(res0)) {
          rownames(res0) <- res0[, "Package"]
          if (need_dest) 
            saveRDS(res0, dest, compress = TRUE)
        }
        else if (!need_dest) {
          unlink(dest)
        }
      }
    }
    if (length(res0)) {
      missingFields <- fields[!(fields %in% colnames(res0))]
      if (length(missingFields)) {
        toadd <- matrix(NA, nrow = nrow(res0), ncol = length(missingFields), dimnames = list(NULL, missingFields))
        res0 <- cbind(res0, toadd)
      }
      if ("Path" %in% colnames(res0)) {
        rp <- rep.int(repos, nrow(res0))
        path <- res0[, "Path"]
        rp[!is.na(path)] <- paste(repos, path[!is.na(path)], sep = "/")
      }
      else rp <- repos
      res0 <- cbind(res0[, fields, drop = FALSE], Repository = rp)
      res <- rbind(res, res0, deparse.level = 0)
    }
  }
  if (!length(res)) 
    return(res)
  if (is.null(filters)) {
    filters <- getOption("available_packages_filters")
    if (is.null(filters)) 
      filters <- available_packages_filters_default
  }
  if (is.list(filters)) {
    if (isTRUE(filters$add)) {
      filters$add <- NULL
      filters <- c(available_packages_filters_default, filters)
    }
  }
  for (f in filters) {
    if (!length(res)) 
      break
    if (is.character(f)) {
      f <- available_packages_filters_db[[f[1]]]
    }
    if (!is.function(f)) 
      stop("invalid 'filters' argument.")
    res <- f(res)
  }
  res
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
bibentry
list(`package:utils` = function (bibtype, textVersion = NULL, header = NULL, footer = NULL, key = NULL, ..., other = list(), mheader = NULL, mfooter = NULL) 
{
  BibTeX_names <- names(tools:::BibTeX_entry_field_db)
  args <- c(list(...), other)
  if (!length(args)) 
    return(.bibentry())
  if (any(vapply(names(args), .is_not_nonempty_text, NA))) 
    stop("all fields have to be named")
  args <- c(list(bibtype = bibtype, textVersion = textVersion, header = header, footer = footer, key = key), list(...))
  args <- lapply(args, .listify)
  other <- lapply(other, .listify)
  max_length <- max(lengths(c(args, other)))
  args_length <- lengths(args)
  if (!all(args_length_ok <- args_length %in% c(1, max_length))) 
    warning(gettextf("Not all arguments are of the same length, the following need to be recycled: %s", paste(names(args)[!args_length_ok], collapse = ", ")), domain = NA)
  args <- lapply(args, function(x) rep_len(x, max_length))
  other_length <- lengths(other)
  if (!all(other_length_ok <- other_length %in% c(1, max_length))) 
    warning(gettextf("Not all arguments are of the same length, the following need to be recycled: %s", paste(names(other)[!other_length_ok], collapse = ", ")), domain = NA)
  other <- lapply(other, function(x) rep_len(x, max_length))
  bibentry1 <- function(bibtype, textVersion, header = NULL, footer = NULL, key = NULL, ..., other = list()) {
    bibtype <- as.character(bibtype)
    stopifnot(length(bibtype) == 1)
    pos <- match(tolower(bibtype), tolower(BibTeX_names))
    if (is.na(pos)) 
      stop(gettextf("%s has to be one of %s", sQuote("bibtype"), paste(BibTeX_names, collapse = ", ")), domain = NA)
    bibtype <- BibTeX_names[pos]
    rval <- c(list(...), other)
    rval <- rval[!vapply(rval, .is_not_nonempty_text, NA)]
    fields <- tolower(names(rval))
    names(rval) <- fields
    attr(rval, "bibtype") <- bibtype
    .bibentry_check_bibentry1(rval)
    pos <- fields %in% c("author", "editor")
    if (any(pos)) {
      for (i in which(pos)) rval[[i]] <- as.person(rval[[i]])
    }
    if (any(!pos)) {
      for (i in which(!pos)) rval[[i]] <- as.character(rval[[i]])
    }
    attr(rval, "key") <- if (is.null(key)) 
      NULL
    else as.character(key)
    if (!is.null(textVersion)) 
      attr(rval, "textVersion") <- as.character(textVersion)
    if (!.is_not_nonempty_text(header)) 
      attr(rval, "header") <- paste(header, collapse = "\n")
    if (!.is_not_nonempty_text(footer)) 
      attr(rval, "footer") <- paste(footer, collapse = "\n")
    return(rval)
  }
  rval <- lapply(seq_along(args$bibtype), function(i) do.call(bibentry1, c(lapply(args, `[[`, i), list(other = lapply(other, `[[`, i)))))
  if (!.is_not_nonempty_text(mheader)) 
    attr(rval, "mheader") <- paste(mheader, collapse = "\n")
  if (!.is_not_nonempty_text(mfooter)) 
    attr(rval, "mfooter") <- paste(mfooter, collapse = "\n")
  .bibentry(rval)
}, function (bibtype, textVersion = NULL, header = NULL, footer = NULL, key = NULL, ..., other = list(), mheader = NULL, mfooter = NULL) 
{
  BibTeX_names <- names(tools:::BibTeX_entry_field_db)
  args <- c(list(...), other)
  if (!length(args)) 
    return(.bibentry())
  if (any(vapply(names(args), .is_not_nonempty_text, NA))) 
    stop("all fields have to be named")
  args <- c(list(bibtype = bibtype, textVersion = textVersion, header = header, footer = footer, key = key), list(...))
  args <- lapply(args, .listify)
  other <- lapply(other, .listify)
  max_length <- max(lengths(c(args, other)))
  args_length <- lengths(args)
  if (!all(args_length_ok <- args_length %in% c(1, max_length))) 
    warning(gettextf("Not all arguments are of the same length, the following need to be recycled: %s", paste(names(args)[!args_length_ok], collapse = ", ")), domain = NA)
  args <- lapply(args, function(x) rep_len(x, max_length))
  other_length <- lengths(other)
  if (!all(other_length_ok <- other_length %in% c(1, max_length))) 
    warning(gettextf("Not all arguments are of the same length, the following need to be recycled: %s", paste(names(other)[!other_length_ok], collapse = ", ")), domain = NA)
  other <- lapply(other, function(x) rep_len(x, max_length))
  bibentry1 <- function(bibtype, textVersion, header = NULL, footer = NULL, key = NULL, ..., other = list()) {
    bibtype <- as.character(bibtype)
    stopifnot(length(bibtype) == 1)
    pos <- match(tolower(bibtype), tolower(BibTeX_names))
    if (is.na(pos)) 
      stop(gettextf("%s has to be one of %s", sQuote("bibtype"), paste(BibTeX_names, collapse = ", ")), domain = NA)
    bibtype <- BibTeX_names[pos]
    rval <- c(list(...), other)
    rval <- rval[!vapply(rval, .is_not_nonempty_text, NA)]
    fields <- tolower(names(rval))
    names(rval) <- fields
    attr(rval, "bibtype") <- bibtype
    .bibentry_check_bibentry1(rval)
    pos <- fields %in% c("author", "editor")
    if (any(pos)) {
      for (i in which(pos)) rval[[i]] <- as.person(rval[[i]])
    }
    if (any(!pos)) {
      for (i in which(!pos)) rval[[i]] <- as.character(rval[[i]])
    }
    attr(rval, "key") <- if (is.null(key)) 
      NULL
    else as.character(key)
    if (!is.null(textVersion)) 
      attr(rval, "textVersion") <- as.character(textVersion)
    if (!.is_not_nonempty_text(header)) 
      attr(rval, "header") <- paste(header, collapse = "\n")
    if (!.is_not_nonempty_text(footer)) 
      attr(rval, "footer") <- paste(footer, collapse = "\n")
    return(rval)
  }
  rval <- lapply(seq_along(args$bibtype), function(i) do.call(bibentry1, c(lapply(args, `[[`, i), list(other = lapply(other, `[[`, i)))))
  if (!.is_not_nonempty_text(mheader)) 
    attr(rval, "mheader") <- paste(mheader, collapse = "\n")
  if (!.is_not_nonempty_text(mfooter)) 
    attr(rval, "mfooter") <- paste(mfooter, collapse = "\n")
  .bibentry(rval)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
browseEnv
list(`package:utils` = function (envir = .GlobalEnv, pattern, excludepatt = "^last\\.warning", html = .Platform$GUI != "AQUA", expanded = TRUE, properties = NULL, main = NULL, debugMe = FALSE) 
{
  objlist <- ls(envir = envir, pattern = pattern)
  if (length(iX <- grep(excludepatt, objlist))) 
    objlist <- objlist[-iX]
  if (debugMe) {
    cat("envir= ")
    print(envir)
    cat("objlist =\n")
    print(objlist)
  }
  n <- length(objlist)
  if (n == 0) {
    cat("Empty environment, nothing to do!\n")
    return(invisible())
  }
  str1 <- function(obj) {
    md <- mode(obj)
    lg <- length(obj)
    objdim <- dim(obj)
    if (length(objdim) == 0) 
      dim.field <- paste("length:", lg)
    else {
      dim.field <- "dim:"
      for (i in seq_along(objdim)) dim.field <- paste(dim.field, objdim[i])
      if (is.matrix(obj)) 
        md <- "matrix"
    }
    obj.class <- oldClass(obj)
    if (!is.null(obj.class)) {
      md <- obj.class[1]
      if (inherits(obj, "factor")) 
        dim.field <- paste("levels:", length(levels(obj)))
    }
    list(type = md, dim.field = dim.field)
  }
  N <- 0
  M <- n
  IDS <- rep.int(NA, n)
  NAMES <- rep.int(NA, n)
  TYPES <- rep.int(NA, n)
  DIMS <- rep.int(NA, n)
  IsRoot <- rep.int(TRUE, n)
  Container <- rep.int(FALSE, n)
  ItemsPerContainer <- rep.int(0, n)
  ParentID <- rep.int(-1, n)
  for (objNam in objlist) {
    N <- N + 1
    if (debugMe) 
      cat("  ", N, ":", objNam)
    obj <- get(objNam, envir = envir)
    sOb <- str1(obj)
    if (debugMe) 
      cat(", type=", sOb$type, ",", sOb$dim.field, "\n")
    IDS[N] <- N
    NAMES[N] <- objNam
    TYPES[N] <- sOb$type
    DIMS[N] <- sOb$dim.field
    if (is.recursive(obj) && !is.function(obj) && !is.environment(obj) && (lg <- length(obj))) {
      Container[N] <- TRUE
      ItemsPerContainer[N] <- lg
      nm <- names(obj)
      if (is.null(nm)) 
        nm <- paste0("[[", format(1:lg), "]]")
      for (i in 1:lg) {
        M <- M + 1
        ParentID[M] <- N
        if (nm[i] == "") 
          nm[i] <- paste0("[[", i, "]]")
        s.l <- str1(obj[[i]])
        IDS <- c(IDS, M)
        NAMES <- c(NAMES, nm[i])
        TYPES <- c(TYPES, s.l$type)
        DIMS <- c(DIMS, s.l$dim.field)
      }
    }
    else if (!is.null(class(obj))) {
      if (inherits(obj, "table")) {
        obj.nms <- attr(obj, "dimnames")
        lg <- length(obj.nms)
        if (length(names(obj.nms)) > 0) 
          nm <- names(obj.nms)
        else nm <- rep.int("", lg)
        Container[N] <- TRUE
        ItemsPerContainer[N] <- lg
        for (i in seq_len(lg)) {
          M <- M + 1
          ParentID[M] <- N
          if (nm[i] == "") 
            nm[i] <- paste0("[[", i, "]]")
          md.l <- mode(obj.nms[[i]])
          objdim.l <- dim(obj.nms[[i]])
          if (length(objdim.l) == 0) 
            dim.field.l <- paste("length:", length(obj.nms[[i]]))
          else {
            dim.field.l <- "dim:"
            for (j in seq_along(objdim.l)) dim.field.l <- paste(dim.field.l, objdim.l[i])
          }
          IDS <- c(IDS, M)
          NAMES <- c(NAMES, nm[i])
          TYPES <- c(TYPES, md.l)
          DIMS <- c(DIMS, dim.field.l)
        }
      }
      else if (inherits(obj, "mts")) {
        nm <- dimnames(obj)[[2]]
        lg <- length(nm)
        Container[N] <- TRUE
        ItemsPerContainer[N] <- lg
        for (i in seq_len(lg)) {
          M <- M + 1
          ParentID[M] <- N
          md.l <- mode(obj[[i]])
          dim.field.l <- paste("length:", dim(obj)[1])
          md.l <- "ts"
          IDS <- c(IDS, M)
          NAMES <- c(NAMES, nm[i])
          TYPES <- c(TYPES, md.l)
          DIMS <- c(DIMS, dim.field.l)
        }
      }
    }
  }
  if (debugMe) 
    cat(" __end {for}\n ")
  Container <- c(Container, rep.int(FALSE, M - N))
  IsRoot <- c(IsRoot, rep.int(FALSE, M - N))
  ItemsPerContainer <- c(ItemsPerContainer, rep.int(0, M - N))
  if (is.null(main)) 
    main <- paste("R objects in", deparse1(substitute(envir)))
  if (is.null(properties)) {
    properties <- as.list(c(date = format(Sys.time(), "%Y-%b-%d %H:%M"), local({
      si <- Sys.info()
      si[c("user", "nodename", "sysname")]
    })))
  }
  if (html) 
    wsbrowser(IDS, IsRoot, Container, ItemsPerContainer, ParentID, NAMES, TYPES, DIMS, kind = "HTML", main = main, properties = properties, expanded)
  else if (.Platform$GUI == "AQUA") {
    awsbrowser <- get("wsbrowser", envir = as.environment("tools:RGUI"))
    awsbrowser(as.integer(IDS), IsRoot, Container, as.integer(ItemsPerContainer), as.integer(ParentID), NAMES, TYPES, DIMS)
  }
  else stop("only 'html = TRUE' is supported on this platform")
}, function (envir = .GlobalEnv, pattern, excludepatt = "^last\\.warning", html = .Platform$GUI != "AQUA", expanded = TRUE, properties = NULL, main = NULL, debugMe = FALSE) 
{
  objlist <- ls(envir = envir, pattern = pattern)
  if (length(iX <- grep(excludepatt, objlist))) 
    objlist <- objlist[-iX]
  if (debugMe) {
    cat("envir= ")
    print(envir)
    cat("objlist =\n")
    print(objlist)
  }
  n <- length(objlist)
  if (n == 0) {
    cat("Empty environment, nothing to do!\n")
    return(invisible())
  }
  str1 <- function(obj) {
    md <- mode(obj)
    lg <- length(obj)
    objdim <- dim(obj)
    if (length(objdim) == 0) 
      dim.field <- paste("length:", lg)
    else {
      dim.field <- "dim:"
      for (i in seq_along(objdim)) dim.field <- paste(dim.field, objdim[i])
      if (is.matrix(obj)) 
        md <- "matrix"
    }
    obj.class <- oldClass(obj)
    if (!is.null(obj.class)) {
      md <- obj.class[1]
      if (inherits(obj, "factor")) 
        dim.field <- paste("levels:", length(levels(obj)))
    }
    list(type = md, dim.field = dim.field)
  }
  N <- 0
  M <- n
  IDS <- rep.int(NA, n)
  NAMES <- rep.int(NA, n)
  TYPES <- rep.int(NA, n)
  DIMS <- rep.int(NA, n)
  IsRoot <- rep.int(TRUE, n)
  Container <- rep.int(FALSE, n)
  ItemsPerContainer <- rep.int(0, n)
  ParentID <- rep.int(-1, n)
  for (objNam in objlist) {
    N <- N + 1
    if (debugMe) 
      cat("  ", N, ":", objNam)
    obj <- get(objNam, envir = envir)
    sOb <- str1(obj)
    if (debugMe) 
      cat(", type=", sOb$type, ",", sOb$dim.field, "\n")
    IDS[N] <- N
    NAMES[N] <- objNam
    TYPES[N] <- sOb$type
    DIMS[N] <- sOb$dim.field
    if (is.recursive(obj) && !is.function(obj) && !is.environment(obj) && (lg <- length(obj))) {
      Container[N] <- TRUE
      ItemsPerContainer[N] <- lg
      nm <- names(obj)
      if (is.null(nm)) 
        nm <- paste0("[[", format(1:lg), "]]")
      for (i in 1:lg) {
        M <- M + 1
        ParentID[M] <- N
        if (nm[i] == "") 
          nm[i] <- paste0("[[", i, "]]")
        s.l <- str1(obj[[i]])
        IDS <- c(IDS, M)
        NAMES <- c(NAMES, nm[i])
        TYPES <- c(TYPES, s.l$type)
        DIMS <- c(DIMS, s.l$dim.field)
      }
    }
    else if (!is.null(class(obj))) {
      if (inherits(obj, "table")) {
        obj.nms <- attr(obj, "dimnames")
        lg <- length(obj.nms)
        if (length(names(obj.nms)) > 0) 
          nm <- names(obj.nms)
        else nm <- rep.int("", lg)
        Container[N] <- TRUE
        ItemsPerContainer[N] <- lg
        for (i in seq_len(lg)) {
          M <- M + 1
          ParentID[M] <- N
          if (nm[i] == "") 
            nm[i] <- paste0("[[", i, "]]")
          md.l <- mode(obj.nms[[i]])
          objdim.l <- dim(obj.nms[[i]])
          if (length(objdim.l) == 0) 
            dim.field.l <- paste("length:", length(obj.nms[[i]]))
          else {
            dim.field.l <- "dim:"
            for (j in seq_along(objdim.l)) dim.field.l <- paste(dim.field.l, objdim.l[i])
          }
          IDS <- c(IDS, M)
          NAMES <- c(NAMES, nm[i])
          TYPES <- c(TYPES, md.l)
          DIMS <- c(DIMS, dim.field.l)
        }
      }
      else if (inherits(obj, "mts")) {
        nm <- dimnames(obj)[[2]]
        lg <- length(nm)
        Container[N] <- TRUE
        ItemsPerContainer[N] <- lg
        for (i in seq_len(lg)) {
          M <- M + 1
          ParentID[M] <- N
          md.l <- mode(obj[[i]])
          dim.field.l <- paste("length:", dim(obj)[1])
          md.l <- "ts"
          IDS <- c(IDS, M)
          NAMES <- c(NAMES, nm[i])
          TYPES <- c(TYPES, md.l)
          DIMS <- c(DIMS, dim.field.l)
        }
      }
    }
  }
  if (debugMe) 
    cat(" __end {for}\n ")
  Container <- c(Container, rep.int(FALSE, M - N))
  IsRoot <- c(IsRoot, rep.int(FALSE, M - N))
  ItemsPerContainer <- c(ItemsPerContainer, rep.int(0, M - N))
  if (is.null(main)) 
    main <- paste("R objects in", deparse1(substitute(envir)))
  if (is.null(properties)) {
    properties <- as.list(c(date = format(Sys.time(), "%Y-%b-%d %H:%M"), local({
      si <- Sys.info()
      si[c("user", "nodename", "sysname")]
    })))
  }
  if (html) 
    wsbrowser(IDS, IsRoot, Container, ItemsPerContainer, ParentID, NAMES, TYPES, DIMS, kind = "HTML", main = main, properties = properties, expanded)
  else if (.Platform$GUI == "AQUA") {
    awsbrowser <- get("wsbrowser", envir = as.environment("tools:RGUI"))
    awsbrowser(as.integer(IDS), IsRoot, Container, as.integer(ItemsPerContainer), as.integer(ParentID), NAMES, TYPES, DIMS)
  }
  else stop("only 'html = TRUE' is supported on this platform")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
browseURL
list(`package:utils` = function (url, browser = getOption("browser"), encodeIfNeeded = FALSE) 
{
  WINDOWS <- .Platform$OS.type == "windows"
  if (!is.character(url) || length(url) != 1 || !nzchar(url)) 
    stop("'url' must be a non-empty character string")
  if (identical(browser, "false")) 
    return(invisible())
  if (WINDOWS && is.null(browser)) 
    return(shell.exec(url))
  if (is.function(browser)) 
    return(invisible(browser(if (encodeIfNeeded) URLencode(url) else url)))
  if (!is.character(browser) || length(browser) != 1 || !nzchar(browser)) 
    stop("'browser' must be a non-empty character string")
  if (WINDOWS) {
    return(system(paste0("\"", browser, "\" ", if (encodeIfNeeded) URLencode(url) else url), wait = FALSE))
  }
  if (.Platform$GUI == "AQUA" || length(grep("^(localhost|):", Sys.getenv("DISPLAY")))) 
    isLocal <- TRUE
  else isLocal <- FALSE
  .shQuote <- function(string) paste0("\"", gsub("$", "\\$", string, fixed = TRUE), "\"")
  quotedUrl <- .shQuote(if (encodeIfNeeded) 
    URLencode(url)
    else url)
  remoteCmd <- if (isLocal) 
    switch(basename(browser), `gnome-moz-remote` = , open = quotedUrl, galeon = paste("-x", quotedUrl), kfmclient = paste("openURL", quotedUrl), mozilla = , opera = {
      paste0("-remote \"openURL(", gsub("([,)$])", "%\\1", url), ")\"")
    }, quotedUrl)
  else quotedUrl
  system(paste(browser, remoteCmd, "> /dev/null 2>&1 ||", browser, quotedUrl, "&"))
}, function (url, browser = getOption("browser"), encodeIfNeeded = FALSE) 
{
  WINDOWS <- .Platform$OS.type == "windows"
  if (!is.character(url) || length(url) != 1 || !nzchar(url)) 
    stop("'url' must be a non-empty character string")
  if (identical(browser, "false")) 
    return(invisible())
  if (WINDOWS && is.null(browser)) 
    return(shell.exec(url))
  if (is.function(browser)) 
    return(invisible(browser(if (encodeIfNeeded) URLencode(url) else url)))
  if (!is.character(browser) || length(browser) != 1 || !nzchar(browser)) 
    stop("'browser' must be a non-empty character string")
  if (WINDOWS) {
    return(system(paste0("\"", browser, "\" ", if (encodeIfNeeded) URLencode(url) else url), wait = FALSE))
  }
  if (.Platform$GUI == "AQUA" || length(grep("^(localhost|):", Sys.getenv("DISPLAY")))) 
    isLocal <- TRUE
  else isLocal <- FALSE
  .shQuote <- function(string) paste0("\"", gsub("$", "\\$", string, fixed = TRUE), "\"")
  quotedUrl <- .shQuote(if (encodeIfNeeded) 
    URLencode(url)
    else url)
  remoteCmd <- if (isLocal) 
    switch(basename(browser), `gnome-moz-remote` = , open = quotedUrl, galeon = paste("-x", quotedUrl), kfmclient = paste("openURL", quotedUrl), mozilla = , opera = {
      paste0("-remote \"openURL(", gsub("([,)$])", "%\\1", url), ")\"")
    }, quotedUrl)
  else quotedUrl
  system(paste(browser, remoteCmd, "> /dev/null 2>&1 ||", browser, quotedUrl, "&"))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
browseVignettes
list(`package:utils` = function (package = NULL, lib.loc = NULL, all = TRUE) 
{
  vinfo <- tools::getVignetteInfo(package, lib.loc, all)
  pkgs <- unique(vinfo[, "Package"])
  db <- lapply(pkgs, function(p) vinfo[vinfo[, "Package"] == p, , drop = FALSE])
  names(db) <- pkgs
  attr(db, "call") <- sys.call()
  attr(db, "footer") <- if (all) 
    ""
  else sprintf(gettext("Use <code> %s </code> \n to list the vignettes in all <strong>available</strong> packages."), "browseVignettes(all = TRUE)")
  class(db) <- "browseVignettes"
  return(db)
}, function (package = NULL, lib.loc = NULL, all = TRUE) 
{
  vinfo <- tools::getVignetteInfo(package, lib.loc, all)
  pkgs <- unique(vinfo[, "Package"])
  db <- lapply(pkgs, function(p) vinfo[vinfo[, "Package"] == p, , drop = FALSE])
  names(db) <- pkgs
  attr(db, "call") <- sys.call()
  attr(db, "footer") <- if (all) 
    ""
  else sprintf(gettext("Use <code> %s </code> \n to list the vignettes in all <strong>available</strong> packages."), "browseVignettes(all = TRUE)")
  class(db) <- "browseVignettes"
  return(db)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
bug.report
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (subject = "", address, file = "R.bug.report", package = NULL, lib.loc = NULL, ...) 
  {
    baseR <- function() {
      writeLines(c("  Bug reports on R and the base packages need to be submitted", "  to the tracker at <https://bugs.R-project.org/>.", "", "  We will now try to open that website in a browser"))
      flush.console()
      Sys.sleep(2)
      browseURL("https://bugs.r-project.org/index.cgi")
    }
    if (is.null(package)) 
      return(baseR())
    DESC <- packageDescription(package, lib.loc)
    if (!inherits(DESC, "packageDescription")) 
      stop(gettextf("Package %s: DESCRIPTION file not found", sQuote(package)), domain = NA)
    info <- paste0(c("Package", " Version", " Maintainer", " Built"), ": ", c(DESC$Package, DESC$Version, DESC$Maintainer, DESC$Built))
    info <- c(info, "", bug.report.info())
    if (identical(DESC$Priority, "base")) 
      return(baseR())
    findEmail2 <- function(x) {
      x <- paste(x, collapse = " ")
      if (grepl("mailto:", x)) 
        sub(".*mailto:([^ ]+).*", "\\1", x)
      else if (grepl("[^<]*<([^>]+)", x)) 
        sub("[^<]*<([^>]+)>.*", "\\1", x)
      else if (grepl("(^|.* )[^ ]+@[[:alnum:]._]+", x)) 
        sub("(^|.* )([^ ]+@[[:alnum:]._]+).*", "\\2", x)
      else NA
    }
    BR <- DESC$BugReports
    if (!is.null(BR) && nzchar(BR)) {
      BR <- trimws(BR)
      if (grepl("^https?://", BR)) {
        writeLines(info)
        cat("\nThis package has a bug submission web page, which we will now attempt\n", "to open.  The information above may be useful in your report.\n", "If the web page does not work, you should send email to the maintainer,\n", DESC$Maintainer, ".\n", sep = "")
        flush.console()
        Sys.sleep(2)
        browseURL(BR)
        return(invisible())
      }
      else {
        cat("This package has a BugReports field which is not the URL of a web page:\n\n", "  BugReports: ", BR, "\n\n", sep = "")
        em <- findEmail2(BR)
        if (!is.na(em)) {
          cat("It appears to contain an email address, so we will try that.\n\n")
          address <- em
        }
        else cat("We will ignore it and email the maintainer.\n\n")
        flush.console()
        Sys.sleep(2)
      }
    }
    CT <- DESC$Contact
    if (!is.null(CT) && nzchar(CT)) {
      cat("This package has a Contact field:\n\n", "  Contact: ", CT, "\n\n", sep = "")
      em <- findEmail2(CT)
      if (!is.na(em)) {
        cat("That appears to contain an email address, so we will try that\n")
        address <- em
      }
      else cat("We cannot make sense of that, so will ignore it.\n\n")
      flush.console()
      Sys.sleep(2)
    }
    if (missing(address)) {
      findEmail <- function(x) {
        x <- paste(x, collapse = " ")
        sub("[^<]*<([^>]+)>.*", "\\1", x)
      }
      address <- findEmail(DESC$Maintainer)
    }
    create.post(instructions = c("", "<<insert bug report here>>", rep.int("", 3)), description = "bug report", subject = subject, address = address, filename = file, info = info, ...)
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
capture.output
list(`package:utils` = function (..., file = NULL, append = FALSE, type = c("output", "message"), split = FALSE) 
{
  type <- match.arg(type)
  rval <- NULL
  closeit <- TRUE
  if (is.null(file)) 
    file <- textConnection("rval", "w", local = TRUE)
  else if (is.character(file)) 
    file <- file(file, if (append) 
      "a"
      else "w")
  else if (inherits(file, "connection")) {
    if (!isOpen(file)) 
      open(file, if (append) 
        "a"
        else "w")
    else closeit <- FALSE
  }
  else stop("'file' must be NULL, a character string or a connection")
  sink(file, type = type, split = split)
  on.exit({
    sink(type = type, split = split)
    if (closeit) close(file)
  })
  for (i in seq_len(...length())) {
    out <- withVisible(...elt(i))
    if (out$visible) 
      print(out$value)
  }
  on.exit()
  sink(type = type, split = split)
  if (closeit) 
    close(file)
  if (is.null(rval)) 
    invisible(NULL)
  else rval
}, function (..., file = NULL, append = FALSE, type = c("output", "message"), split = FALSE) 
{
  type <- match.arg(type)
  rval <- NULL
  closeit <- TRUE
  if (is.null(file)) 
    file <- textConnection("rval", "w", local = TRUE)
  else if (is.character(file)) 
    file <- file(file, if (append) 
      "a"
      else "w")
  else if (inherits(file, "connection")) {
    if (!isOpen(file)) 
      open(file, if (append) 
        "a"
        else "w")
    else closeit <- FALSE
  }
  else stop("'file' must be NULL, a character string or a connection")
  sink(file, type = type, split = split)
  on.exit({
    sink(type = type, split = split)
    if (closeit) close(file)
  })
  for (i in seq_len(...length())) {
    out <- withVisible(...elt(i))
    if (out$visible) 
      print(out$value)
  }
  on.exit()
  sink(type = type, split = split)
  if (closeit) 
    close(file)
  if (is.null(rval)) 
    invisible(NULL)
  else rval
}, function (..., file = NULL, append = FALSE, type = c("output", "message"), split = FALSE) 
{
  args <- substitute(list(...))[-1]
  type <- match.arg(type)
  rval <- NULL
  closeit <- TRUE
  if (is.null(file)) 
    file <- textConnection("rval", "w", local = TRUE)
  else if (is.character(file)) 
    file <- file(file, if (append) 
      "a"
      else "w")
  else if (inherits(file, "connection")) {
    if (!isOpen(file)) 
      open(file, if (append) 
        "a"
        else "w")
    else closeit <- FALSE
  }
  else {
    stop("'file' must be NULL, a character string or a connection")
  }
  sink(file, type = type, split = split)
  on.exit({
    sink(type = type, split = split)
    if (closeit) close(file)
  })
  pf <- parent.frame()
  evalVis <- function(expr) withVisible(eval(expr, pf))
  for (i in seq_along(args)) {
    expr <- args[[i]]
    tmp <- switch(mode(expr), expression = lapply(expr, evalVis), call = , name = list(evalVis(expr)), stop("bad argument"))
    for (item in tmp) if (item$visible) 
      print(item$value)
  }
  on.exit()
  sink(type = type, split = split)
  if (closeit) 
    close(file)
  if (is.null(rval)) 
    invisible(NULL)
  else rval
})
c("package:utils", "namespace:utils", "namespace:backports")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
changedFiles
list(`package:utils` = function (before, after, path = before$path, timestamp = before$timestamp, check.file.info = c("size", "isdir", "mode", "mtime"), md5sum = before$md5sum, digest = before$digest, full.names = before$full.names, ...) 
{
  stopifnot(inherits(before, "fileSnapshot"))
  if (missing(after)) {
    get.file.info <- length(check.file.info) > 0 && before$file.info
    args <- before$args
    newargs <- list(...)
    args[names(newargs)] <- newargs
    after <- do.call(fileSnapshot, c(list(path = path, timestamp = NULL, file.info = get.file.info, md5sum = md5sum, digest = digest, full.names = full.names), args))
  }
  stopifnot(inherits(after, "fileSnapshot"))
  preinfo <- before$info
  postinfo <- after$info
  prenames <- rownames(preinfo)
  postnames <- rownames(postinfo)
  added <- setdiff(postnames, prenames)
  deleted <- setdiff(prenames, postnames)
  common <- intersect(prenames, postnames)
  if (!before$file.info || !after$file.info) 
    check.file.info <- NULL
  if (length(check.file.info)) {
    pre <- preinfo[common, check.file.info, drop = FALSE]
    post <- postinfo[common, check.file.info, drop = FALSE]
    changes <- pre != post
  }
  else changes <- matrix(logical(0), nrow = length(common), ncol = 0, dimnames = list(common, character(0)))
  if (length(timestamp)) 
    if (file.exists(timestamp)) {
      fullnames <- if (after$full.names) 
        common
      else file.path(after$path, common)
      changes <- cbind(changes, Newer = file_test("-nt", fullnames, timestamp))
    }
  else warning("Timestamp file no longer exists.")
  if (md5sum) {
    pre <- preinfo[common, "md5sum"]
    post <- postinfo[common, "md5sum"]
    changes <- cbind(changes, md5sum = pre != post)
  }
  if (!is.null(digest)) {
    pre <- preinfo[common, "digest"]
    post <- postinfo[common, "digest"]
    changes <- cbind(changes, digest = pre != post)
  }
  changed <- rownames(changes)[rowSums(changes, na.rm = TRUE) > 0]
  structure(list(added = added, deleted = deleted, changed = changed, unchanged = setdiff(common, changed), changes = changes), class = "changedFiles")
}, function (before, after, path = before$path, timestamp = before$timestamp, check.file.info = c("size", "isdir", "mode", "mtime"), md5sum = before$md5sum, digest = before$digest, full.names = before$full.names, ...) 
{
  stopifnot(inherits(before, "fileSnapshot"))
  if (missing(after)) {
    get.file.info <- length(check.file.info) > 0 && before$file.info
    args <- before$args
    newargs <- list(...)
    args[names(newargs)] <- newargs
    after <- do.call(fileSnapshot, c(list(path = path, timestamp = NULL, file.info = get.file.info, md5sum = md5sum, digest = digest, full.names = full.names), args))
  }
  stopifnot(inherits(after, "fileSnapshot"))
  preinfo <- before$info
  postinfo <- after$info
  prenames <- rownames(preinfo)
  postnames <- rownames(postinfo)
  added <- setdiff(postnames, prenames)
  deleted <- setdiff(prenames, postnames)
  common <- intersect(prenames, postnames)
  if (!before$file.info || !after$file.info) 
    check.file.info <- NULL
  if (length(check.file.info)) {
    pre <- preinfo[common, check.file.info, drop = FALSE]
    post <- postinfo[common, check.file.info, drop = FALSE]
    changes <- pre != post
  }
  else changes <- matrix(logical(0), nrow = length(common), ncol = 0, dimnames = list(common, character(0)))
  if (length(timestamp)) 
    if (file.exists(timestamp)) {
      fullnames <- if (after$full.names) 
        common
      else file.path(after$path, common)
      changes <- cbind(changes, Newer = file_test("-nt", fullnames, timestamp))
    }
  else warning("Timestamp file no longer exists.")
  if (md5sum) {
    pre <- preinfo[common, "md5sum"]
    post <- postinfo[common, "md5sum"]
    changes <- cbind(changes, md5sum = pre != post)
  }
  if (!is.null(digest)) {
    pre <- preinfo[common, "digest"]
    post <- postinfo[common, "digest"]
    changes <- cbind(changes, digest = pre != post)
  }
  changed <- rownames(changes)[rowSums(changes, na.rm = TRUE) > 0]
  structure(list(added = added, deleted = deleted, changed = changed, unchanged = setdiff(common, changed), changes = changes), class = "changedFiles")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
charClass
list(`package:utils` = function (x, class) 
  .Call(C_charClass, x, class), function (x, class) 
    .Call(C_charClass, x, class))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
checkCRAN
list(`package:utils` = function (method) 
{
  master <- available.packages(contrib.url("https://CRAN.R-project.org"), method = method)
  m <- getCRANmirrors()
  z <- list()
  for (url in as.character(m$URL)) z[[url]] <- available.packages(contrib.url(url), method = method)
  lapply(z, function(a) all.equal(a, master))
}, function (method) 
{
  master <- available.packages(contrib.url("https://CRAN.R-project.org"), method = method)
  m <- getCRANmirrors()
  z <- list()
  for (url in as.character(m$URL)) z[[url]] <- available.packages(contrib.url(url), method = method)
  lapply(z, function(a) all.equal(a, master))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
choose.dir
list(`package:utils` = function (default = "", caption = "Select folder") 
  .Call(C_chooseDir, default, caption), function (default = "", caption = "Select folder") 
    .Call(C_chooseDir, default, caption))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
choose.files
list(`package:utils` = function (default = "", caption = "Select files", multi = TRUE, filters = Filters, index = nrow(Filters)) 
  .Call(C_chooseFiles, default, caption, multi, filters, index), function (default = "", caption = "Select files", multi = TRUE, filters = Filters, index = nrow(Filters)) 
    .Call(C_chooseFiles, default, caption, multi, filters, index))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
chooseBioCmirror
list(`package:utils` = function (graphics = getOption("menu.graphics"), ind = NULL, local.only = FALSE) 
{
  m <- .getMirrors("https://bioconductor.org/BioC_mirrors.csv", file.path(R.home("doc"), "BioC_mirrors.csv"), all = FALSE, local.only = local.only)
  url <- .chooseMirror(m, "BioC", graphics, ind)
  if (length(url)) 
    options(BioC_mirror = url)
  invisible()
}, function (graphics = getOption("menu.graphics"), ind = NULL, local.only = FALSE) 
{
  m <- .getMirrors("https://bioconductor.org/BioC_mirrors.csv", file.path(R.home("doc"), "BioC_mirrors.csv"), all = FALSE, local.only = local.only)
  url <- .chooseMirror(m, "BioC", graphics, ind)
  if (length(url)) 
    options(BioC_mirror = url)
  invisible()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
chooseCRANmirror
list(`package:utils` = function (graphics = getOption("menu.graphics"), ind = NULL, local.only = FALSE) 
{
  m <- getCRANmirrors(all = FALSE, local.only = local.only)
  url <- .chooseMirror(m, "CRAN", graphics, ind)
  if (length(url)) {
    repos <- getOption("repos")
    repos["CRAN"] <- url
    options(repos = repos)
  }
  invisible()
}, function (graphics = getOption("menu.graphics"), ind = NULL, local.only = FALSE) 
{
  m <- getCRANmirrors(all = FALSE, local.only = local.only)
  url <- .chooseMirror(m, "CRAN", graphics, ind)
  if (length(url)) {
    repos <- getOption("repos")
    repos["CRAN"] <- url
    options(repos = repos)
  }
  invisible()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
citation
list(`package:utils` = function (package = "base", lib.loc = NULL, auto = NULL) 
{
  if (!is.null(auto) && !is.logical(auto) && !anyNA(match(c("Package", "Version", "Title"), names(meta <- as.list(auto)))) && !all(is.na(match(c("Authors@R", "Author"), names(meta))))) {
    auto_was_meta <- TRUE
    package <- meta$Package
  }
  else {
    auto_was_meta <- FALSE
    dir <- system.file(package = package, lib.loc = lib.loc)
    if (dir == "") 
      stop(packageNotFoundError(package, lib.loc, sys.call()))
    meta <- packageDescription(pkg = package, lib.loc = dirname(dir))
    citfile <- file.path(dir, "CITATION")
    test <- file_test("-f", citfile)
    if (!test) {
      citfile <- file.path(dir, "inst", "CITATION")
      test <- file_test("-f", citfile)
    }
    if (is.null(auto)) 
      auto <- !test
    if (!auto) {
      return(readCitationFile(citfile, meta))
    }
  }
  if ((!is.null(meta$Priority)) && (meta$Priority == "base")) {
    cit <- citation("base", auto = FALSE)
    attr(cit, "mheader")[1] <- paste0("The ", sQuote(package), " package is part of R.  ", attr(cit, "mheader")[1])
    return(.citation(cit, package))
  }
  year <- sub("-.*", "", meta$`Date/Publication`)
  if (!length(year)) {
    if (is.null(meta$Date)) {
      warning(gettextf("no date field in DESCRIPTION file of package %s", sQuote(package)), domain = NA)
    }
    else {
      date <- trimws(as.vector(meta$Date))[1]
      date <- strptime(date, "%Y-%m-%d", tz = "GMT")
      if (!is.na(date)) 
        year <- format(date, "%Y")
    }
  }
  if (!length(year)) {
    date <- as.POSIXlt(sub(";.*", "", trimws(meta$Packaged)[1]))
    if (!is.na(date)) 
      year <- format(date, "%Y")
  }
  if (!length(year)) {
    warning(gettextf("could not determine year for %s from package DESCRIPTION file", sQuote(package)), domain = NA)
    year <- NA
  }
  author <- meta$`Authors@R`
  if (length(author)) {
    aar <- .read_authors_at_R_field(author)
    author <- Filter(function(e) {
      !(is.null(e$given) && is.null(e$family)) && !is.na(match("aut", e$role))
    }, aar)
    if (!length(author)) 
      author <- Filter(function(e) {
        !(is.null(e$given) && is.null(e$family)) && !is.na(match("cre", e$role))
      }, aar)
  }
  if (length(author)) {
    has_authors_at_R_field <- TRUE
  }
  else {
    has_authors_at_R_field <- FALSE
    author <- as.personList(meta$Author)
  }
  z <- list(title = paste0(package, ": ", meta$Title), author = author, year = year, note = paste("R package version", meta$Version))
  if (identical(meta$Repository, "CRAN")) 
    z$url <- sprintf("https://CRAN.R-project.org/package=%s", package)
  if (identical(meta$Repository, "R-Forge")) {
    z$url <- if (!is.null(rfp <- meta$"Repository/R-Forge/Project")) 
      sprintf("https://R-Forge.R-project.org/projects/%s/", rfp)
    else "https://R-Forge.R-project.org/"
    if (!is.null(rfr <- meta$"Repository/R-Forge/Revision")) 
      z$note <- paste(z$note, rfr, sep = "/r")
  }
  if (!length(z$url) && !is.null(url <- meta$URL)) {
    if (grepl("[, ]", url)) 
      z$note <- url
    else z$url <- url
  }
  header <- if (!auto_was_meta) {
    gettextf("To cite package %s in publications use:", sQuote(package))
  }
  else NULL
  footer <- if (!has_authors_at_R_field && !auto_was_meta) {
    gettextf("ATTENTION: This citation information has been auto-generated from the package DESCRIPTION file and may need manual editing, see %s.", sQuote("help(\"citation\")"))
  }
  else NULL
  author <- format(z$author, include = c("given", "family"))
  if (length(author) > 1) 
    author <- paste(paste(head(author, -1), collapse = ", "), tail(author, 1), sep = " and ")
  rval <- bibentry(bibtype = "Manual", header = header, footer = footer, other = z)
  .citation(rval, package)
}, function (package = "base", lib.loc = NULL, auto = NULL) 
{
  if (!is.null(auto) && !is.logical(auto) && !anyNA(match(c("Package", "Version", "Title"), names(meta <- as.list(auto)))) && !all(is.na(match(c("Authors@R", "Author"), names(meta))))) {
    auto_was_meta <- TRUE
    package <- meta$Package
  }
  else {
    auto_was_meta <- FALSE
    dir <- system.file(package = package, lib.loc = lib.loc)
    if (dir == "") 
      stop(packageNotFoundError(package, lib.loc, sys.call()))
    meta <- packageDescription(pkg = package, lib.loc = dirname(dir))
    citfile <- file.path(dir, "CITATION")
    test <- file_test("-f", citfile)
    if (!test) {
      citfile <- file.path(dir, "inst", "CITATION")
      test <- file_test("-f", citfile)
    }
    if (is.null(auto)) 
      auto <- !test
    if (!auto) {
      return(readCitationFile(citfile, meta))
    }
  }
  if ((!is.null(meta$Priority)) && (meta$Priority == "base")) {
    cit <- citation("base", auto = FALSE)
    attr(cit, "mheader")[1] <- paste0("The ", sQuote(package), " package is part of R.  ", attr(cit, "mheader")[1])
    return(.citation(cit, package))
  }
  year <- sub("-.*", "", meta$`Date/Publication`)
  if (!length(year)) {
    if (is.null(meta$Date)) {
      warning(gettextf("no date field in DESCRIPTION file of package %s", sQuote(package)), domain = NA)
    }
    else {
      date <- trimws(as.vector(meta$Date))[1]
      date <- strptime(date, "%Y-%m-%d", tz = "GMT")
      if (!is.na(date)) 
        year <- format(date, "%Y")
    }
  }
  if (!length(year)) {
    date <- as.POSIXlt(sub(";.*", "", trimws(meta$Packaged)[1]))
    if (!is.na(date)) 
      year <- format(date, "%Y")
  }
  if (!length(year)) {
    warning(gettextf("could not determine year for %s from package DESCRIPTION file", sQuote(package)), domain = NA)
    year <- NA
  }
  author <- meta$`Authors@R`
  if (length(author)) {
    aar <- .read_authors_at_R_field(author)
    author <- Filter(function(e) {
      !(is.null(e$given) && is.null(e$family)) && !is.na(match("aut", e$role))
    }, aar)
    if (!length(author)) 
      author <- Filter(function(e) {
        !(is.null(e$given) && is.null(e$family)) && !is.na(match("cre", e$role))
      }, aar)
  }
  if (length(author)) {
    has_authors_at_R_field <- TRUE
  }
  else {
    has_authors_at_R_field <- FALSE
    author <- as.personList(meta$Author)
  }
  z <- list(title = paste0(package, ": ", meta$Title), author = author, year = year, note = paste("R package version", meta$Version))
  if (identical(meta$Repository, "CRAN")) 
    z$url <- sprintf("https://CRAN.R-project.org/package=%s", package)
  if (identical(meta$Repository, "R-Forge")) {
    z$url <- if (!is.null(rfp <- meta$"Repository/R-Forge/Project")) 
      sprintf("https://R-Forge.R-project.org/projects/%s/", rfp)
    else "https://R-Forge.R-project.org/"
    if (!is.null(rfr <- meta$"Repository/R-Forge/Revision")) 
      z$note <- paste(z$note, rfr, sep = "/r")
  }
  if (!length(z$url) && !is.null(url <- meta$URL)) {
    if (grepl("[, ]", url)) 
      z$note <- url
    else z$url <- url
  }
  header <- if (!auto_was_meta) {
    gettextf("To cite package %s in publications use:", sQuote(package))
  }
  else NULL
  footer <- if (!has_authors_at_R_field && !auto_was_meta) {
    gettextf("ATTENTION: This citation information has been auto-generated from the package DESCRIPTION file and may need manual editing, see %s.", sQuote("help(\"citation\")"))
  }
  else NULL
  author <- format(z$author, include = c("given", "family"))
  if (length(author) > 1) 
    author <- paste(paste(head(author, -1), collapse = ", "), tail(author, 1), sep = " and ")
  rval <- bibentry(bibtype = "Manual", header = header, footer = footer, other = z)
  .citation(rval, package)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
cite
list(`package:utils` = function (keys, bib, ...) 
{
  fn <- tools::bibstyle()$cite
  if (is.null(fn)) 
    fn <- citeNatbib
  fn(keys, bib, ...)
}, function (keys, bib, ...) 
{
  fn <- tools::bibstyle()$cite
  if (is.null(fn)) 
    fn <- citeNatbib
  fn(keys, bib, ...)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
citeNatbib
list(`package:utils` = function (keys, bib, textual = FALSE, before = NULL, after = NULL, mode = c("authoryear", "numbers", "super"), abbreviate = TRUE, longnamesfirst = TRUE, bibpunct = c("(", ")", ";", "a", "", ","), previous) 
{
  shortName <- function(person) {
    if (length(person$family)) 
      paste(tools:::cleanupLatex(person$family), collapse = " ")
    else paste(tools:::cleanupLatex(person$given), collapse = " ")
  }
  authorList <- function(paper) sapply(paper$author, shortName)
  if (!missing(previous)) 
    cited <<- previous
  if (!missing(mode)) 
    mode <- match.arg(mode)
  else mode <- switch(bibpunct[4], n = "numbers", s = "super", "authoryear")
  numeric <- mode %in% c("numbers", "super")
  if (numeric) 
    bib <- sort(bib)
  keys <- unlist(strsplit(keys, " *, *"))
  if (!length(keys)) 
    return("")
  n <- length(keys)
  first <- !(keys %in% cited)
  cited <<- unique(c(cited, keys))
  bibkeys <- unlist(bib$key)
  year <- match(keys, bibkeys)
  papers <- bib[year]
  if (textual || !numeric) {
    auth <- character(n)
    if (!numeric) 
      year <- unlist(papers$year)
    authorLists <- lapply(papers, authorList)
    lastAuthors <- NULL
    for (i in seq_along(keys)) {
      authors <- authorLists[[i]]
      if (identical(lastAuthors, authors)) 
        auth[i] <- ""
      else {
        if (length(authors) > 1) 
          authors[length(authors)] <- paste("and", authors[length(authors)])
        if (length(authors) > 2) {
          if (!abbreviate || (first[i] && longnamesfirst)) 
            auth[i] <- paste(authors, collapse = ", ")
          else auth[i] <- paste(authors[1], "et al.")
        }
        else auth[i] <- paste(authors, collapse = " ")
      }
      lastAuthors <- authors
    }
    suppressauth <- which(!nzchar(auth))
    if (length(suppressauth)) {
      for (i in suppressauth) year[i - 1] <- paste0(year[i - 1], bibpunct[6], " ", year[i])
      auth <- auth[-suppressauth]
      year <- year[-suppressauth]
    }
  }
  if (!is.null(before)) 
    before <- paste0(before, " ")
  if (!is.null(after)) 
    after <- paste0(" ", after)
  if (textual) {
    result <- paste0(bibpunct[1], before, year, after, bibpunct[2])
    if (mode == "super") 
      result <- paste0(auth, "^{", result, "}")
    else result <- paste0(auth, " ", result)
    result <- paste(result, collapse = paste0(bibpunct[3], " "))
  }
  else if (numeric) {
    result <- paste(year, collapse = paste0(bibpunct[3], " "))
    result <- paste0(bibpunct[1], before, result, after, bibpunct[2])
    if (mode == "super") 
      result <- paste0("^{", result, "}")
  }
  else {
    result <- paste0(auth, bibpunct[5], " ", year)
    result <- paste(result, collapse = paste0(bibpunct[3], " "))
    result <- paste0(bibpunct[1], before, result, after, bibpunct[2])
  }
  result
}, function (keys, bib, textual = FALSE, before = NULL, after = NULL, mode = c("authoryear", "numbers", "super"), abbreviate = TRUE, longnamesfirst = TRUE, bibpunct = c("(", ")", ";", "a", "", ","), previous) 
{
  shortName <- function(person) {
    if (length(person$family)) 
      paste(tools:::cleanupLatex(person$family), collapse = " ")
    else paste(tools:::cleanupLatex(person$given), collapse = " ")
  }
  authorList <- function(paper) sapply(paper$author, shortName)
  if (!missing(previous)) 
    cited <<- previous
  if (!missing(mode)) 
    mode <- match.arg(mode)
  else mode <- switch(bibpunct[4], n = "numbers", s = "super", "authoryear")
  numeric <- mode %in% c("numbers", "super")
  if (numeric) 
    bib <- sort(bib)
  keys <- unlist(strsplit(keys, " *, *"))
  if (!length(keys)) 
    return("")
  n <- length(keys)
  first <- !(keys %in% cited)
  cited <<- unique(c(cited, keys))
  bibkeys <- unlist(bib$key)
  year <- match(keys, bibkeys)
  papers <- bib[year]
  if (textual || !numeric) {
    auth <- character(n)
    if (!numeric) 
      year <- unlist(papers$year)
    authorLists <- lapply(papers, authorList)
    lastAuthors <- NULL
    for (i in seq_along(keys)) {
      authors <- authorLists[[i]]
      if (identical(lastAuthors, authors)) 
        auth[i] <- ""
      else {
        if (length(authors) > 1) 
          authors[length(authors)] <- paste("and", authors[length(authors)])
        if (length(authors) > 2) {
          if (!abbreviate || (first[i] && longnamesfirst)) 
            auth[i] <- paste(authors, collapse = ", ")
          else auth[i] <- paste(authors[1], "et al.")
        }
        else auth[i] <- paste(authors, collapse = " ")
      }
      lastAuthors <- authors
    }
    suppressauth <- which(!nzchar(auth))
    if (length(suppressauth)) {
      for (i in suppressauth) year[i - 1] <- paste0(year[i - 1], bibpunct[6], " ", year[i])
      auth <- auth[-suppressauth]
      year <- year[-suppressauth]
    }
  }
  if (!is.null(before)) 
    before <- paste0(before, " ")
  if (!is.null(after)) 
    after <- paste0(" ", after)
  if (textual) {
    result <- paste0(bibpunct[1], before, year, after, bibpunct[2])
    if (mode == "super") 
      result <- paste0(auth, "^{", result, "}")
    else result <- paste0(auth, " ", result)
    result <- paste(result, collapse = paste0(bibpunct[3], " "))
  }
  else if (numeric) {
    result <- paste(year, collapse = paste0(bibpunct[3], " "))
    result <- paste0(bibpunct[1], before, result, after, bibpunct[2])
    if (mode == "super") 
      result <- paste0("^{", result, "}")
  }
  else {
    result <- paste0(auth, bibpunct[5], " ", year)
    result <- paste(result, collapse = paste0(bibpunct[3], " "))
    result <- paste0(bibpunct[1], before, result, after, bibpunct[2])
  }
  result
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
citEntry
list(`package:utils` = function (entry, textVersion, header = NULL, footer = NULL, ...) 
  bibentry(bibtype = entry, textVersion = textVersion, header = header, footer = footer, ...), function (entry, textVersion, header = NULL, footer = NULL, ...) 
    bibentry(bibtype = entry, textVersion = textVersion, header = header, footer = footer, ...))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
citFooter
list(`package:utils` = function (...) 
{
  rval <- paste(...)
  class(rval) <- "citationFooter"
  rval
}, function (...) 
{
  rval <- paste(...)
  class(rval) <- "citationFooter"
  rval
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
citHeader
list(`package:utils` = function (...) 
{
  rval <- paste(...)
  class(rval) <- "citationHeader"
  rval
}, function (...) 
{
  rval <- paste(...)
  class(rval) <- "citationHeader"
  rval
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
close.socket
list(`package:utils` = function (socket, ...) 
  .Call(C_sockclose, socket$socket), function (socket, ...) 
    .Call(C_sockclose, socket$socket), function (socket, ...) 
      .Call(C_sockclose, socket$socket))
c("package:utils", "registered S3 method for close from namespace utils", "namespace:utils")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
clrhash
list(`package:utils` = function (h) 
  invisible(.External(C_clrhash_Ext, h)), function (h) 
    invisible(.External(C_clrhash_Ext, h)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
combn
list(`package:utils` = function (x, m, FUN = NULL, simplify = TRUE, ...) 
{
  stopifnot(length(m) == 1, is.numeric(m))
  if (m < 0) 
    stop("m < 0", domain = NA)
  if (is.numeric(x) && length(x) == 1 && x > 0 && trunc(x) == x) 
    x <- seq_len(x)
  n <- length(x)
  if (n < m) 
    stop("n < m", domain = NA)
  x0 <- x
  if (simplify) {
    if (is.factor(x)) 
      x <- as.integer(x)
  }
  m <- as.integer(m)
  e <- 0
  h <- m
  a <- seq_len(m)
  nofun <- is.null(FUN)
  if (!nofun && !is.function(FUN)) 
    stop("'FUN' must be a function or NULL")
  len.r <- length(r <- if (nofun) x[a] else FUN(x[a], ...))
  count <- as.integer(round(choose(n, m)))
  if (simplify) {
    dim.use <- if (nofun) 
      c(m, count)
    else {
      d <- dim(r)
      if (length(d) > 1) 
        c(d, count)
      else if (len.r != 1) 
        c(len.r, count)
      else c(d, count)
    }
  }
  if (simplify) 
    out <- matrix(r, nrow = len.r, ncol = count)
  else {
    out <- vector("list", count)
    out[[1]] <- r
  }
  if (m > 0) {
    i <- 2
    nmmp1 <- n - m + 1
    while (a[1] != nmmp1) {
      if (e < n - h) {
        h <- 1
        e <- a[m]
        j <- 1
      }
      else {
        e <- a[m - h]
        h <- h + 1
        j <- 1:h
      }
      a[m - h + j] <- e + j
      r <- if (nofun) 
        x[a]
      else FUN(x[a], ...)
      if (simplify) 
        out[, i] <- r
      else out[[i]] <- r
      i <- i + 1
    }
  }
  if (simplify) {
    if (is.factor(x0)) {
      levels(out) <- levels(x0)
      class(out) <- class(x0)
    }
    dim(out) <- dim.use
  }
  out
}, function (x, m, FUN = NULL, simplify = TRUE, ...) 
{
  stopifnot(length(m) == 1, is.numeric(m))
  if (m < 0) 
    stop("m < 0", domain = NA)
  if (is.numeric(x) && length(x) == 1 && x > 0 && trunc(x) == x) 
    x <- seq_len(x)
  n <- length(x)
  if (n < m) 
    stop("n < m", domain = NA)
  x0 <- x
  if (simplify) {
    if (is.factor(x)) 
      x <- as.integer(x)
  }
  m <- as.integer(m)
  e <- 0
  h <- m
  a <- seq_len(m)
  nofun <- is.null(FUN)
  if (!nofun && !is.function(FUN)) 
    stop("'FUN' must be a function or NULL")
  len.r <- length(r <- if (nofun) x[a] else FUN(x[a], ...))
  count <- as.integer(round(choose(n, m)))
  if (simplify) {
    dim.use <- if (nofun) 
      c(m, count)
    else {
      d <- dim(r)
      if (length(d) > 1) 
        c(d, count)
      else if (len.r != 1) 
        c(len.r, count)
      else c(d, count)
    }
  }
  if (simplify) 
    out <- matrix(r, nrow = len.r, ncol = count)
  else {
    out <- vector("list", count)
    out[[1]] <- r
  }
  if (m > 0) {
    i <- 2
    nmmp1 <- n - m + 1
    while (a[1] != nmmp1) {
      if (e < n - h) {
        h <- 1
        e <- a[m]
        j <- 1
      }
      else {
        e <- a[m - h]
        h <- h + 1
        j <- 1:h
      }
      a[m - h + j] <- e + j
      r <- if (nofun) 
        x[a]
      else FUN(x[a], ...)
      if (simplify) 
        out[, i] <- r
      else out[[i]] <- r
      i <- i + 1
    }
  }
  if (simplify) {
    if (is.factor(x0)) {
      levels(out) <- levels(x0)
      class(out) <- class(x0)
    }
    dim(out) <- dim.use
  }
  out
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
compareVersion
list(`package:utils` = function (a, b) 
{
  if (is.na(a)) 
    return(-1)
  if (is.na(b)) 
    return(1)
  a <- as.integer(strsplit(a, "[.-]")[[1]])
  b <- as.integer(strsplit(b, "[.-]")[[1]])
  for (k in seq_along(a)) if (k <= length(b)) {
    if (a[k] > b[k]) 
      return(1)
    else if (a[k] < b[k]) 
      return(-1)
  }
  else return(1)
  if (length(b) > length(a)) 
    return(-1)
  else return(0)
}, function (a, b) 
{
  if (is.na(a)) 
    return(-1)
  if (is.na(b)) 
    return(1)
  a <- as.integer(strsplit(a, "[.-]")[[1]])
  b <- as.integer(strsplit(b, "[.-]")[[1]])
  for (k in seq_along(a)) if (k <= length(b)) {
    if (a[k] > b[k]) 
      return(1)
    else if (a[k] < b[k]) 
      return(-1)
  }
  else return(1)
  if (length(b) > length(a)) 
    return(-1)
  else return(0)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
contrib.url
list(`package:utils` = function (repos, type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  type <- resolvePkgType(type)
  if (is.null(repos)) 
    return(NULL)
  if ("@CRAN@" %in% repos && interactive()) {
    cat(gettext("--- Please select a CRAN mirror for use in this session ---"), "\n", sep = "")
    flush.console()
    chooseCRANmirror()
    m <- match("@CRAN@", repos)
    nm <- names(repos)
    repos[m] <- getOption("repos")["CRAN"]
    if (is.null(nm)) 
      nm <- rep.int("", length(repos))
    nm[m] <- "CRAN"
    names(repos) <- nm
  }
  if ("@CRAN@" %in% repos) 
    stop("trying to use CRAN without setting a mirror")
  ver <- paste(R.version$major, strsplit(R.version$minor, ".", fixed = TRUE)[[1]][1], sep = ".")
  mac.path <- "macosx"
  if (substr(type, 1, 11) == "mac.binary.") {
    mac.path <- paste(mac.path, substring(type, 12), sep = "/")
    type <- "mac.binary"
  }
  res <- switch(type, source = paste(gsub("/$", "", repos), "src", "contrib", sep = "/"), mac.binary = paste(gsub("/$", "", repos), "bin", mac.path, "contrib", ver, sep = "/"), win.binary = paste(gsub("/$", "", repos), "bin", "windows", "contrib", ver, sep = "/"), stop("invalid 'type'"))
  res
}, function (repos, type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  type <- resolvePkgType(type)
  if (is.null(repos)) 
    return(NULL)
  if ("@CRAN@" %in% repos && interactive()) {
    cat(gettext("--- Please select a CRAN mirror for use in this session ---"), "\n", sep = "")
    flush.console()
    chooseCRANmirror()
    m <- match("@CRAN@", repos)
    nm <- names(repos)
    repos[m] <- getOption("repos")["CRAN"]
    if (is.null(nm)) 
      nm <- rep.int("", length(repos))
    nm[m] <- "CRAN"
    names(repos) <- nm
  }
  if ("@CRAN@" %in% repos) 
    stop("trying to use CRAN without setting a mirror")
  ver <- paste(R.version$major, strsplit(R.version$minor, ".", fixed = TRUE)[[1]][1], sep = ".")
  mac.path <- "macosx"
  if (substr(type, 1, 11) == "mac.binary.") {
    mac.path <- paste(mac.path, substring(type, 12), sep = "/")
    type <- "mac.binary"
  }
  res <- switch(type, source = paste(gsub("/$", "", repos), "src", "contrib", sep = "/"), mac.binary = paste(gsub("/$", "", repos), "bin", mac.path, "contrib", ver, sep = "/"), win.binary = paste(gsub("/$", "", repos), "bin", "windows", "contrib", ver, sep = "/"), stop("invalid 'type'"))
  res
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
count.fields
list(`package:utils` = function (file, sep = "", quote = "\"'", skip = 0, blank.lines.skip = TRUE, comment.char = "#") 
{
  if (is.character(file)) {
    file <- file(file)
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  .External(C_countfields, file, sep, quote, skip, blank.lines.skip, comment.char)
}, function (file, sep = "", quote = "\"'", skip = 0, blank.lines.skip = TRUE, comment.char = "#") 
{
  if (is.character(file)) {
    file <- file(file)
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  .External(C_countfields, file, sep, quote, skip, blank.lines.skip, comment.char)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
create.post
list(`package:utils` = function (instructions = character(), description = "post", subject = "", method = getOption("mailer"), address = "the relevant mailing list", ccaddress = getOption("ccaddress", ""), filename = "R.post", info = character()) 
{
  method <- if (is.null(method)) 
    "none"
  else match.arg(method, c("mailto", "mailx", "gnudoit", "none", "ess"))
  body <- c(instructions, "--please do not edit the information below--", "", info)
  none_method <- function() {
    disclaimer <- paste0("# Your mailer is set to \"none\",\n", "# hence we cannot send the, ", description, " directly from R.\n", "# Please copy the ", description, " (after finishing it) to\n", "# your favorite email program and send it to\n#\n", "#       ", address, "\n#\n", "######################################################\n", "\n\n")
    cat(c(disclaimer, body), file = filename, sep = "\n")
    cat("The", description, "is being opened for you to edit.\n")
    flush.console()
    file.edit(filename)
    cat("The unsent ", description, " can be found in file\n", normalizePath(filename), "\n", sep = "")
  }
  if (method == "none") 
    none_method()
  else if (method == "ess") 
    cat(body, sep = "\n")
  else if (method == "gnudoit") {
    cmd <- paste0("gnudoit -q '", "(mail nil \"", address, "\")", "(insert \"", paste(body, collapse = "\\n"), "\")", "(search-backward \"Subject:\")", "(end-of-line)'")
    system(cmd)
  }
  else if (method == "mailto") {
    if (missing(address)) 
      stop("must specify 'address'")
    if (!nzchar(subject)) 
      subject <- "<<Enter Meaningful Subject>>"
    if (length(ccaddress) != 1) 
      stop("'ccaddress' must be of length 1")
    cat("The", description, "is being opened in your default mail program\nfor you to complete and send.\n")
    uri <- paste0("mailto:", address, "?subject=", subject, if (is.character(ccaddress) && nzchar(ccaddress)) 
      paste0("&cc=", ccaddress), "&body=", paste(body, collapse = "\r\n"))
    tryCatch(shell.exec(URLencode(uri)), error = function(e) {
      cat("opening the mailer failed, so reverting to 'mailer=\"none\"'\n")
      flush.console()
      Sys.sleep(5)
      none_method()
    })
  }
  else if (method == "mailx") 
    stop("method 'mailx' is Unix-only")
  invisible()
}, function (instructions = character(), description = "post", subject = "", method = getOption("mailer"), address = "the relevant mailing list", ccaddress = getOption("ccaddress", ""), filename = "R.post", info = character()) 
{
  method <- if (is.null(method)) 
    "none"
  else match.arg(method, c("mailto", "mailx", "gnudoit", "none", "ess"))
  body <- c(instructions, "--please do not edit the information below--", "", info)
  none_method <- function() {
    disclaimer <- paste0("# Your mailer is set to \"none\",\n", "# hence we cannot send the, ", description, " directly from R.\n", "# Please copy the ", description, " (after finishing it) to\n", "# your favorite email program and send it to\n#\n", "#       ", address, "\n#\n", "######################################################\n", "\n\n")
    cat(c(disclaimer, body), file = filename, sep = "\n")
    cat("The", description, "is being opened for you to edit.\n")
    flush.console()
    file.edit(filename)
    cat("The unsent ", description, " can be found in file\n", normalizePath(filename), "\n", sep = "")
  }
  if (method == "none") 
    none_method()
  else if (method == "ess") 
    cat(body, sep = "\n")
  else if (method == "gnudoit") {
    cmd <- paste0("gnudoit -q '", "(mail nil \"", address, "\")", "(insert \"", paste(body, collapse = "\\n"), "\")", "(search-backward \"Subject:\")", "(end-of-line)'")
    system(cmd)
  }
  else if (method == "mailto") {
    if (missing(address)) 
      stop("must specify 'address'")
    if (!nzchar(subject)) 
      subject <- "<<Enter Meaningful Subject>>"
    if (length(ccaddress) != 1) 
      stop("'ccaddress' must be of length 1")
    cat("The", description, "is being opened in your default mail program\nfor you to complete and send.\n")
    uri <- paste0("mailto:", address, "?subject=", subject, if (is.character(ccaddress) && nzchar(ccaddress)) 
      paste0("&cc=", ccaddress), "&body=", paste(body, collapse = "\r\n"))
    tryCatch(shell.exec(URLencode(uri)), error = function(e) {
      cat("opening the mailer failed, so reverting to 'mailer=\"none\"'\n")
      flush.console()
      Sys.sleep(5)
      none_method()
    })
  }
  else if (method == "mailx") 
    stop("method 'mailx' is Unix-only")
  invisible()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
data
list(`package:utils` = function (..., list = character(), package = NULL, lib.loc = NULL, verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE) 
{
  fileExt <- function(x) {
    db <- grepl("\\.[^.]+\\.(gz|bz2|xz)$", x)
    ans <- sub(".*\\.", "", x)
    ans[db] <- sub(".*\\.([^.]+\\.)(gz|bz2|xz)$", "\\1\\2", x[db])
    ans
  }
  my_read_table <- function(...) {
    lcc <- Sys.getlocale("LC_COLLATE")
    on.exit(Sys.setlocale("LC_COLLATE", lcc))
    Sys.setlocale("LC_COLLATE", "C")
    read.table(...)
  }
  stopifnot(is.character(list))
  names <- c(as.character(substitute(list(...))[-1]), list)
  if (!is.null(package)) {
    if (!is.character(package)) 
      stop("'package' must be a character vector or NULL")
  }
  paths <- find.package(package, lib.loc, verbose = verbose)
  if (is.null(lib.loc)) 
    paths <- c(path.package(package, TRUE), if (!length(package)) getwd(), paths)
  paths <- unique(normalizePath(paths[file.exists(paths)]))
  paths <- paths[dir.exists(file.path(paths, "data"))]
  dataExts <- tools:::.make_file_exts("data")
  if (length(names) == 0) {
    db <- matrix(character(), nrow = 0, ncol = 4)
    for (path in paths) {
      entries <- NULL
      packageName <- if (file_test("-f", file.path(path, "DESCRIPTION"))) 
        basename(path)
      else "."
      if (file_test("-f", INDEX <- file.path(path, "Meta", "data.rds"))) {
        entries <- readRDS(INDEX)
      }
      else {
        dataDir <- file.path(path, "data")
        entries <- tools::list_files_with_type(dataDir, "data")
        if (length(entries)) {
          entries <- unique(tools::file_path_sans_ext(basename(entries)))
          entries <- cbind(entries, "")
        }
      }
      if (NROW(entries)) {
        if (is.matrix(entries) && ncol(entries) == 2) 
          db <- rbind(db, cbind(packageName, dirname(path), entries))
        else warning(gettextf("data index for package %s is invalid and will be ignored", sQuote(packageName)), domain = NA, call. = FALSE)
      }
    }
    colnames(db) <- c("Package", "LibPath", "Item", "Title")
    footer <- if (missing(package)) 
      paste0("Use ", sQuote(paste("data(package =", ".packages(all.available = TRUE))")), "\n", "to list the data sets in all *available* packages.")
    else NULL
    y <- list(title = "Data sets", header = NULL, results = db, footer = footer)
    class(y) <- "packageIQR"
    return(y)
  }
  paths <- file.path(paths, "data")
  for (name in names) {
    found <- FALSE
    for (p in paths) {
      tmp_env <- if (overwrite) 
        envir
      else new.env()
      if (file_test("-f", file.path(p, "Rdata.rds"))) {
        rds <- readRDS(file.path(p, "Rdata.rds"))
        if (name %in% names(rds)) {
          found <- TRUE
          if (verbose) 
            message(sprintf("name=%s:\t found in Rdata.rds", name), domain = NA)
          thispkg <- sub(".*/([^/]*)/data$", "\\1", p)
          thispkg <- sub("_.*$", "", thispkg)
          thispkg <- paste0("package:", thispkg)
          objs <- rds[[name]]
          lazyLoad(file.path(p, "Rdata"), envir = tmp_env, filter = function(x) x %in% objs)
          break
        }
        else if (verbose) 
          message(sprintf("name=%s:\t NOT found in names() of Rdata.rds, i.e.,\n\t%s\n", name, paste(names(rds), collapse = ",")), domain = NA)
      }
      if (file_test("-f", file.path(p, "Rdata.zip"))) {
        warning("zipped data found for package ", sQuote(basename(dirname(p))), ".\nThat is defunct, so please re-install the package.", domain = NA)
        if (file_test("-f", fp <- file.path(p, "filelist"))) 
          files <- file.path(p, scan(fp, what = "", quiet = TRUE))
        else {
          warning(gettextf("file 'filelist' is missing for directory %s", sQuote(p)), domain = NA)
          next
        }
      }
      else {
        files <- list.files(p, full.names = TRUE)
      }
      files <- files[grep(name, files, fixed = TRUE)]
      if (length(files) > 1) {
        o <- match(fileExt(files), dataExts, nomatch = 100)
        paths0 <- dirname(files)
        paths0 <- factor(paths0, levels = unique(paths0))
        files <- files[order(paths0, o)]
      }
      if (length(files)) {
        for (file in files) {
          if (verbose) 
            message("name=", name, ":\t file= ...", .Platform$file.sep, basename(file), "::\t", appendLF = FALSE, domain = NA)
          ext <- fileExt(file)
          if (basename(file) != paste0(name, ".", ext)) 
            found <- FALSE
          else {
            found <- TRUE
            zfile <- file
            zipname <- file.path(dirname(file), "Rdata.zip")
            if (file.exists(zipname)) {
              Rdatadir <- tempfile("Rdata")
              dir.create(Rdatadir, showWarnings = FALSE)
              topic <- basename(file)
              rc <- .External(C_unzip, zipname, topic, Rdatadir, FALSE, TRUE, FALSE, FALSE)
              if (rc == 0) 
                zfile <- file.path(Rdatadir, topic)
            }
            if (zfile != file) 
              on.exit(unlink(zfile))
            switch(ext, R = , r = {
              library("utils")
              sys.source(zfile, chdir = TRUE, envir = tmp_env)
            }, RData = , rdata = , rda = load(zfile, envir = tmp_env), TXT = , txt = , tab = , tab.gz = , tab.bz2 = , tab.xz = , txt.gz = , txt.bz2 = , txt.xz = assign(name, my_read_table(zfile, header = TRUE, as.is = FALSE), envir = tmp_env), CSV = , csv = , csv.gz = , csv.bz2 = , csv.xz = assign(name, my_read_table(zfile, header = TRUE, sep = ";", as.is = FALSE), envir = tmp_env), found <- FALSE)
          }
          if (found) 
            break
        }
        if (verbose) 
          message(if (!found) 
            "*NOT* ", "found", domain = NA)
      }
      if (found) 
        break
    }
    if (!found) {
      warning(gettextf("data set %s not found", sQuote(name)), domain = NA)
    }
    else if (!overwrite) {
      for (o in ls(envir = tmp_env, all.names = TRUE)) {
        if (exists(o, envir = envir, inherits = FALSE)) 
          warning(gettextf("an object named %s already exists and will not be overwritten", sQuote(o)))
        else assign(o, get(o, envir = tmp_env, inherits = FALSE), envir = envir)
      }
      rm(tmp_env)
    }
  }
  invisible(names)
}, function (..., list = character(), package = NULL, lib.loc = NULL, verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE) 
{
  fileExt <- function(x) {
    db <- grepl("\\.[^.]+\\.(gz|bz2|xz)$", x)
    ans <- sub(".*\\.", "", x)
    ans[db] <- sub(".*\\.([^.]+\\.)(gz|bz2|xz)$", "\\1\\2", x[db])
    ans
  }
  my_read_table <- function(...) {
    lcc <- Sys.getlocale("LC_COLLATE")
    on.exit(Sys.setlocale("LC_COLLATE", lcc))
    Sys.setlocale("LC_COLLATE", "C")
    read.table(...)
  }
  stopifnot(is.character(list))
  names <- c(as.character(substitute(list(...))[-1]), list)
  if (!is.null(package)) {
    if (!is.character(package)) 
      stop("'package' must be a character vector or NULL")
  }
  paths <- find.package(package, lib.loc, verbose = verbose)
  if (is.null(lib.loc)) 
    paths <- c(path.package(package, TRUE), if (!length(package)) getwd(), paths)
  paths <- unique(normalizePath(paths[file.exists(paths)]))
  paths <- paths[dir.exists(file.path(paths, "data"))]
  dataExts <- tools:::.make_file_exts("data")
  if (length(names) == 0) {
    db <- matrix(character(), nrow = 0, ncol = 4)
    for (path in paths) {
      entries <- NULL
      packageName <- if (file_test("-f", file.path(path, "DESCRIPTION"))) 
        basename(path)
      else "."
      if (file_test("-f", INDEX <- file.path(path, "Meta", "data.rds"))) {
        entries <- readRDS(INDEX)
      }
      else {
        dataDir <- file.path(path, "data")
        entries <- tools::list_files_with_type(dataDir, "data")
        if (length(entries)) {
          entries <- unique(tools::file_path_sans_ext(basename(entries)))
          entries <- cbind(entries, "")
        }
      }
      if (NROW(entries)) {
        if (is.matrix(entries) && ncol(entries) == 2) 
          db <- rbind(db, cbind(packageName, dirname(path), entries))
        else warning(gettextf("data index for package %s is invalid and will be ignored", sQuote(packageName)), domain = NA, call. = FALSE)
      }
    }
    colnames(db) <- c("Package", "LibPath", "Item", "Title")
    footer <- if (missing(package)) 
      paste0("Use ", sQuote(paste("data(package =", ".packages(all.available = TRUE))")), "\n", "to list the data sets in all *available* packages.")
    else NULL
    y <- list(title = "Data sets", header = NULL, results = db, footer = footer)
    class(y) <- "packageIQR"
    return(y)
  }
  paths <- file.path(paths, "data")
  for (name in names) {
    found <- FALSE
    for (p in paths) {
      tmp_env <- if (overwrite) 
        envir
      else new.env()
      if (file_test("-f", file.path(p, "Rdata.rds"))) {
        rds <- readRDS(file.path(p, "Rdata.rds"))
        if (name %in% names(rds)) {
          found <- TRUE
          if (verbose) 
            message(sprintf("name=%s:\t found in Rdata.rds", name), domain = NA)
          thispkg <- sub(".*/([^/]*)/data$", "\\1", p)
          thispkg <- sub("_.*$", "", thispkg)
          thispkg <- paste0("package:", thispkg)
          objs <- rds[[name]]
          lazyLoad(file.path(p, "Rdata"), envir = tmp_env, filter = function(x) x %in% objs)
          break
        }
        else if (verbose) 
          message(sprintf("name=%s:\t NOT found in names() of Rdata.rds, i.e.,\n\t%s\n", name, paste(names(rds), collapse = ",")), domain = NA)
      }
      if (file_test("-f", file.path(p, "Rdata.zip"))) {
        warning("zipped data found for package ", sQuote(basename(dirname(p))), ".\nThat is defunct, so please re-install the package.", domain = NA)
        if (file_test("-f", fp <- file.path(p, "filelist"))) 
          files <- file.path(p, scan(fp, what = "", quiet = TRUE))
        else {
          warning(gettextf("file 'filelist' is missing for directory %s", sQuote(p)), domain = NA)
          next
        }
      }
      else {
        files <- list.files(p, full.names = TRUE)
      }
      files <- files[grep(name, files, fixed = TRUE)]
      if (length(files) > 1) {
        o <- match(fileExt(files), dataExts, nomatch = 100)
        paths0 <- dirname(files)
        paths0 <- factor(paths0, levels = unique(paths0))
        files <- files[order(paths0, o)]
      }
      if (length(files)) {
        for (file in files) {
          if (verbose) 
            message("name=", name, ":\t file= ...", .Platform$file.sep, basename(file), "::\t", appendLF = FALSE, domain = NA)
          ext <- fileExt(file)
          if (basename(file) != paste0(name, ".", ext)) 
            found <- FALSE
          else {
            found <- TRUE
            zfile <- file
            zipname <- file.path(dirname(file), "Rdata.zip")
            if (file.exists(zipname)) {
              Rdatadir <- tempfile("Rdata")
              dir.create(Rdatadir, showWarnings = FALSE)
              topic <- basename(file)
              rc <- .External(C_unzip, zipname, topic, Rdatadir, FALSE, TRUE, FALSE, FALSE)
              if (rc == 0) 
                zfile <- file.path(Rdatadir, topic)
            }
            if (zfile != file) 
              on.exit(unlink(zfile))
            switch(ext, R = , r = {
              library("utils")
              sys.source(zfile, chdir = TRUE, envir = tmp_env)
            }, RData = , rdata = , rda = load(zfile, envir = tmp_env), TXT = , txt = , tab = , tab.gz = , tab.bz2 = , tab.xz = , txt.gz = , txt.bz2 = , txt.xz = assign(name, my_read_table(zfile, header = TRUE, as.is = FALSE), envir = tmp_env), CSV = , csv = , csv.gz = , csv.bz2 = , csv.xz = assign(name, my_read_table(zfile, header = TRUE, sep = ";", as.is = FALSE), envir = tmp_env), found <- FALSE)
          }
          if (found) 
            break
        }
        if (verbose) 
          message(if (!found) 
            "*NOT* ", "found", domain = NA)
      }
      if (found) 
        break
    }
    if (!found) {
      warning(gettextf("data set %s not found", sQuote(name)), domain = NA)
    }
    else if (!overwrite) {
      for (o in ls(envir = tmp_env, all.names = TRUE)) {
        if (exists(o, envir = envir, inherits = FALSE)) 
          warning(gettextf("an object named %s already exists and will not be overwritten", sQuote(o)))
        else assign(o, get(o, envir = tmp_env, inherits = FALSE), envir = envir)
      }
      rm(tmp_env)
    }
  }
  invisible(names)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
data.entry
list(`package:utils` = function (..., Modes = NULL, Names = NULL) 
{
  tmp1 <- de(..., Modes = Modes, Names = Names)
  j <- 1
  nn <- names(tmp1)
  for (i in nn) {
    assign(i, tmp1[[j]], envir = .GlobalEnv)
    j <- j + 1
  }
  if (j == 1) 
    warning("did not assign() anything")
  invisible(nn)
}, function (..., Modes = NULL, Names = NULL) 
{
  tmp1 <- de(..., Modes = Modes, Names = Names)
  j <- 1
  nn <- names(tmp1)
  for (i in nn) {
    assign(i, tmp1[[j]], envir = .GlobalEnv)
    j <- j + 1
  }
  if (j == 1) 
    warning("did not assign() anything")
  invisible(nn)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
dataentry
list(`package:utils` = function (data, modes) 
{
  check <- Sys.getenv("_R_CHECK_SCREEN_DEVICE_", "")
  msg <- "dataentry() should not be used in examples etc"
  if (identical(check, "stop")) 
    stop(msg, domain = NA)
  else if (identical(check, "warn")) 
    warning(msg, immediate. = TRUE, noBreaks. = TRUE, domain = NA)
  if (!is.list(data) || !length(data) || !all(sapply(data, is.vector))) 
    stop("invalid 'data' argument")
  if (!is.list(modes) || (length(modes) && !all(sapply(modes, is.character)))) 
    stop("invalid 'modes' argument")
  if (grepl("darwin", R.version$os)) 
    check_for_XQuartz()
  .External2(C_dataentry, data, modes)
}, function (data, modes) 
{
  check <- Sys.getenv("_R_CHECK_SCREEN_DEVICE_", "")
  msg <- "dataentry() should not be used in examples etc"
  if (identical(check, "stop")) 
    stop(msg, domain = NA)
  else if (identical(check, "warn")) 
    warning(msg, immediate. = TRUE, noBreaks. = TRUE, domain = NA)
  if (!is.list(data) || !length(data) || !all(sapply(data, is.vector))) 
    stop("invalid 'data' argument")
  if (!is.list(modes) || (length(modes) && !all(sapply(modes, is.character)))) 
    stop("invalid 'modes' argument")
  if (grepl("darwin", R.version$os)) 
    check_for_XQuartz()
  .External2(C_dataentry, data, modes)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
de
list(`package:utils` = function (..., Modes = list(), Names = NULL) 
{
  sdata <- list(...)
  snames <- as.character(substitute(list(...))[-1])
  if (is.null(sdata)) {
    if (is.null(Names)) {
      odata <- vector("list", length = max(1, length(Modes)))
    }
    else {
      if ((length(Names) != length(Modes)) && length(Modes)) {
        warning("'modes' argument ignored")
        Modes <- list()
      }
      odata <- vector("list", length = length(Names))
      names(odata) <- Names
    }
    ncols <- rep.int(1, length(odata))
    coltypes <- rep.int(1, length(odata))
  }
  else {
    ncols <- de.ncols(sdata)
    coltypes <- ncols[, 2]
    ncols <- ncols[, 1]
    odata <- de.setup(sdata, snames, ncols)
    if (length(Names)) 
      if (length(Names) != length(odata)) 
        warning("'names' argument ignored")
    else names(odata) <- Names
    if (length(Modes)) 
      if (length(Modes) != length(odata)) {
        warning("'modes' argument ignored")
        Modes <- list()
      }
  }
  rdata <- dataentry(odata, as.list(Modes))
  if (any(coltypes != 1)) {
    if (length(rdata) == sum(ncols)) 
      rdata <- de.restore(rdata, ncols, coltypes, snames, sdata)
    else warning("could not restore variables properly")
  }
  return(rdata)
}, function (..., Modes = list(), Names = NULL) 
{
  sdata <- list(...)
  snames <- as.character(substitute(list(...))[-1])
  if (is.null(sdata)) {
    if (is.null(Names)) {
      odata <- vector("list", length = max(1, length(Modes)))
    }
    else {
      if ((length(Names) != length(Modes)) && length(Modes)) {
        warning("'modes' argument ignored")
        Modes <- list()
      }
      odata <- vector("list", length = length(Names))
      names(odata) <- Names
    }
    ncols <- rep.int(1, length(odata))
    coltypes <- rep.int(1, length(odata))
  }
  else {
    ncols <- de.ncols(sdata)
    coltypes <- ncols[, 2]
    ncols <- ncols[, 1]
    odata <- de.setup(sdata, snames, ncols)
    if (length(Names)) 
      if (length(Names) != length(odata)) 
        warning("'names' argument ignored")
    else names(odata) <- Names
    if (length(Modes)) 
      if (length(Modes) != length(odata)) {
        warning("'modes' argument ignored")
        Modes <- list()
      }
  }
  rdata <- dataentry(odata, as.list(Modes))
  if (any(coltypes != 1)) {
    if (length(rdata) == sum(ncols)) 
      rdata <- de.restore(rdata, ncols, coltypes, snames, sdata)
    else warning("could not restore variables properly")
  }
  return(rdata)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
de.ncols
list(`package:utils` = function (inlist) 
{
  ncols <- matrix(0, nrow = length(inlist), ncol = 2)
  i <- 1
  for (telt in inlist) {
    if (is.matrix(telt)) {
      ncols[i, 1] <- ncol(telt)
      ncols[i, 2] <- 2
    }
    else if (is.list(telt)) {
      for (telt2 in telt) if (!is.vector(telt2)) 
        stop("wrong argument to 'dataentry'")
      ncols[i, 1] <- length(telt)
      ncols[i, 2] <- 3
    }
    else if (is.vector(telt)) {
      ncols[i, 1] <- 1
      ncols[i, 2] <- 1
    }
    else stop("wrong argument to 'dataentry'")
    i <- i + 1
  }
  return(ncols)
}, function (inlist) 
{
  ncols <- matrix(0, nrow = length(inlist), ncol = 2)
  i <- 1
  for (telt in inlist) {
    if (is.matrix(telt)) {
      ncols[i, 1] <- ncol(telt)
      ncols[i, 2] <- 2
    }
    else if (is.list(telt)) {
      for (telt2 in telt) if (!is.vector(telt2)) 
        stop("wrong argument to 'dataentry'")
      ncols[i, 1] <- length(telt)
      ncols[i, 2] <- 3
    }
    else if (is.vector(telt)) {
      ncols[i, 1] <- 1
      ncols[i, 2] <- 1
    }
    else stop("wrong argument to 'dataentry'")
    i <- i + 1
  }
  return(ncols)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
de.restore
list(`package:utils` = function (inlist, ncols, coltypes, argnames, args) 
{
  p <- length(ncols)
  rlist <- vector("list", length = p)
  rnames <- vector("character", length = p)
  j <- 1
  lnames <- names(inlist)
  if (p) 
    for (i in seq_len(p)) {
      if (coltypes[i] == 2) {
        tlen <- length(inlist[[j]])
        x <- matrix(0, nrow = tlen, ncol = ncols[i])
        cnames <- vector("character", ncol(x))
        for (ind1 in seq_len(ncols[i])) {
          if (tlen != length(inlist[[j]])) {
            warning("could not restore type information")
            return(inlist)
          }
          x[, ind1] <- inlist[[j]]
          cnames[ind1] <- lnames[j]
          j <- j + 1
        }
        if (nrow(x) == nrow(args[[i]])) 
          rn <- dimnames(args[[i]])[[1]]
        else rn <- NULL
        if (any(cnames != "")) 
          dimnames(x) <- list(rn, cnames)
        rlist[[i]] <- x
        rnames[i] <- argnames[i]
      }
      else if (coltypes[i] == 3) {
        x <- vector("list", length = ncols[i])
        cnames <- vector("character", ncols[i])
        for (ind1 in seq_len(ncols[i])) {
          x[[ind1]] <- inlist[[j]]
          cnames[ind1] <- lnames[j]
          j <- j + 1
        }
        if (any(cnames != "")) 
          names(x) <- cnames
        rlist[[i]] <- x
        rnames[i] <- argnames[i]
      }
      else {
        rlist[[i]] <- inlist[[j]]
        j <- j + 1
        rnames[i] <- argnames[i]
      }
    }
  names(rlist) <- rnames
  return(rlist)
}, function (inlist, ncols, coltypes, argnames, args) 
{
  p <- length(ncols)
  rlist <- vector("list", length = p)
  rnames <- vector("character", length = p)
  j <- 1
  lnames <- names(inlist)
  if (p) 
    for (i in seq_len(p)) {
      if (coltypes[i] == 2) {
        tlen <- length(inlist[[j]])
        x <- matrix(0, nrow = tlen, ncol = ncols[i])
        cnames <- vector("character", ncol(x))
        for (ind1 in seq_len(ncols[i])) {
          if (tlen != length(inlist[[j]])) {
            warning("could not restore type information")
            return(inlist)
          }
          x[, ind1] <- inlist[[j]]
          cnames[ind1] <- lnames[j]
          j <- j + 1
        }
        if (nrow(x) == nrow(args[[i]])) 
          rn <- dimnames(args[[i]])[[1]]
        else rn <- NULL
        if (any(cnames != "")) 
          dimnames(x) <- list(rn, cnames)
        rlist[[i]] <- x
        rnames[i] <- argnames[i]
      }
      else if (coltypes[i] == 3) {
        x <- vector("list", length = ncols[i])
        cnames <- vector("character", ncols[i])
        for (ind1 in seq_len(ncols[i])) {
          x[[ind1]] <- inlist[[j]]
          cnames[ind1] <- lnames[j]
          j <- j + 1
        }
        if (any(cnames != "")) 
          names(x) <- cnames
        rlist[[i]] <- x
        rnames[i] <- argnames[i]
      }
      else {
        rlist[[i]] <- inlist[[j]]
        j <- j + 1
        rnames[i] <- argnames[i]
      }
    }
  names(rlist) <- rnames
  return(rlist)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
de.setup
list(`package:utils` = function (ilist, list.names, incols) 
{
  ilen <- sum(incols)
  ivec <- vector("list", ilen)
  inames <- vector("list", ilen)
  i <- 1
  k <- 0
  for (telt in ilist) {
    k <- k + 1
    if (is.list(telt)) {
      y <- names(telt)
      for (j in seq_along(telt)) {
        ivec[[i]] <- telt[[j]]
        if (is.null(y) || y[j] == "") 
          inames[[i]] <- paste0("var", i)
        else inames[[i]] <- y[j]
        i <- i + 1
      }
    }
    else if (is.vector(telt)) {
      ivec[[i]] <- telt
      inames[[i]] <- list.names[[k]]
      i <- i + 1
    }
    else if (is.matrix(telt)) {
      y <- dimnames(telt)[[2]]
      for (j in seq_len(ncol(telt))) {
        ivec[[i]] <- telt[, j]
        if (is.null(y) || y[j] == "") 
          inames[[i]] <- paste0("var", i)
        else inames[[i]] <- y[j]
        i <- i + 1
      }
    }
    else stop("wrong argument to 'dataentry'")
  }
  names(ivec) <- inames
  return(ivec)
}, function (ilist, list.names, incols) 
{
  ilen <- sum(incols)
  ivec <- vector("list", ilen)
  inames <- vector("list", ilen)
  i <- 1
  k <- 0
  for (telt in ilist) {
    k <- k + 1
    if (is.list(telt)) {
      y <- names(telt)
      for (j in seq_along(telt)) {
        ivec[[i]] <- telt[[j]]
        if (is.null(y) || y[j] == "") 
          inames[[i]] <- paste0("var", i)
        else inames[[i]] <- y[j]
        i <- i + 1
      }
    }
    else if (is.vector(telt)) {
      ivec[[i]] <- telt
      inames[[i]] <- list.names[[k]]
      i <- i + 1
    }
    else if (is.matrix(telt)) {
      y <- dimnames(telt)[[2]]
      for (j in seq_len(ncol(telt))) {
        ivec[[i]] <- telt[, j]
        if (is.null(y) || y[j] == "") 
          inames[[i]] <- paste0("var", i)
        else inames[[i]] <- y[j]
        i <- i + 1
      }
    }
    else stop("wrong argument to 'dataentry'")
  }
  names(ivec) <- inames
  return(ivec)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
debugcall
list(`package:utils` = function (call, once = FALSE) 
{
  stopifnot(length(once) == 1, is.logical(once), !is.na(once))
  call <- substitute(call)
  .debugcall(call, if (once) 
    debugonce
    else debug)
  invisible(call)
}, function (call, once = FALSE) 
{
  stopifnot(length(once) == 1, is.logical(once), !is.na(once))
  call <- substitute(call)
  .debugcall(call, if (once) 
    debugonce
    else debug)
  invisible(call)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
debugger
list(`package:utils` = function (dump = last.dump) 
{
  debugger.look <- function(.selection) {
    for (.obj in ls(envir = dump[[.selection]], all.names = TRUE)) tryCatch(assign(.obj, get(.obj, envir = dump[[.selection]])), error = function(e) {
    })
    cat(gettext("Browsing in the environment with call:\n   "), calls[.selection], "\n", sep = "")
    rm(.obj, .selection)
    browser()
  }
  if (!inherits(dump, "dump.frames")) {
    cat(gettextf("'dump' is not an object of class %s\n", dQuote("dump.frames")))
    return(invisible())
  }
  err.action <- getOption("error")
  on.exit(options(error = err.action))
  if (length(msg <- attr(dump, "error.message"))) 
    cat(gettext("Message: "), msg)
  n <- length(dump)
  if (!n) {
    cat(gettextf("'dump' is empty\n"))
    return(invisible())
  }
  calls <- names(dump)
  repeat {
    cat(gettext("Available environments had calls:\n"))
    cat(paste0(1:n, ": ", calls), sep = "\n")
    cat(gettext("\nEnter an environment number, or 0 to exit  "))
    repeat {
      ind <- .Call(C_menu, as.character(calls))
      if (ind <= n) 
        break
    }
    if (ind == 0) 
      return(invisible())
    debugger.look(ind)
  }
}, function (dump = last.dump) 
{
  debugger.look <- function(.selection) {
    for (.obj in ls(envir = dump[[.selection]], all.names = TRUE)) tryCatch(assign(.obj, get(.obj, envir = dump[[.selection]])), error = function(e) {
    })
    cat(gettext("Browsing in the environment with call:\n   "), calls[.selection], "\n", sep = "")
    rm(.obj, .selection)
    browser()
  }
  if (!inherits(dump, "dump.frames")) {
    cat(gettextf("'dump' is not an object of class %s\n", dQuote("dump.frames")))
    return(invisible())
  }
  err.action <- getOption("error")
  on.exit(options(error = err.action))
  if (length(msg <- attr(dump, "error.message"))) 
    cat(gettext("Message: "), msg)
  n <- length(dump)
  if (!n) {
    cat(gettextf("'dump' is empty\n"))
    return(invisible())
  }
  calls <- names(dump)
  repeat {
    cat(gettext("Available environments had calls:\n"))
    cat(paste0(1:n, ": ", calls), sep = "\n")
    cat(gettext("\nEnter an environment number, or 0 to exit  "))
    repeat {
      ind <- .Call(C_menu, as.character(calls))
      if (ind <= n) 
        break
    }
    if (ind == 0) 
      return(invisible())
    debugger.look(ind)
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
demo
list(`package:utils` = function (topic, package = NULL, lib.loc = NULL, character.only = FALSE, verbose = getOption("verbose"), type = c("console", "html"), echo = TRUE, ask = getOption("demo.ask"), encoding = getOption("encoding")) 
{
  type <- match.arg(type)
  html <- type == "html"
  if (html) {
    enhancedHTML <- str2logical(Sys.getenv("_R_HELP_ENABLE_ENHANCED_HTML_", "TRUE"))
    if (!interactive() || !enhancedHTML || !requireNamespace("knitr", quietly = TRUE)) 
      html <- FALSE
  }
  if (html) {
    port <- tools::startDynamicHelp(NA)
    if (port <= 0) 
      html <- FALSE
    else {
      if (!is.null(lib.loc)) 
        lib.loc <- NULL
      browser <- if (.Platform$GUI == "AQUA") {
        get("aqua.browser", envir = as.environment("tools:RGUI"))
      }
      else getOption("browser")
    }
  }
  paths <- find.package(package, lib.loc, verbose = verbose)
  paths <- paths[dir.exists(file.path(paths, "demo"))]
  if (missing(topic)) {
    if (html) {
      browseURL(paste0("http://127.0.0.1:", port, "/doc/html/Search?package=", paste(unique(basename(paths)), collapse = ";"), "&agrep=0&types.demo=1&pattern="), browser)
      return(invisible())
    }
    db <- matrix(character(), nrow = 0, ncol = 4)
    for (path in paths) {
      entries <- NULL
      if (file_test("-f", INDEX <- file.path(path, "Meta", "demo.rds"))) {
        entries <- readRDS(INDEX)
      }
      if (NROW(entries)) {
        db <- rbind(db, cbind(basename(path), dirname(path), entries))
      }
    }
    colnames(db) <- c("Package", "LibPath", "Item", "Title")
    footer <- if (missing(package)) 
      paste0("Use ", sQuote(paste("demo(package =", ".packages(all.available = TRUE))")), "\n", "to list the demos in all *available* packages.")
    else NULL
    y <- list(title = "Demos", header = NULL, results = db, footer = footer)
    class(y) <- "packageIQR"
    return(y)
  }
  if (!character.only) {
    topic <- substitute(topic)
    if (is.call(topic) && (topic[[1]] == "::" || topic[[1]] == ":::")) {
      package <- as.character(topic[[2]])
      topic <- as.character(topic[[3]])
    }
    else topic <- as.character(topic)
  }
  available <- character()
  paths <- file.path(paths, "demo")
  for (p in paths) {
    files <- basename(tools::list_files_with_type(p, "demo"))
    files <- files[topic == tools::file_path_sans_ext(files)]
    if (length(files)) 
      available <- c(available, file.path(p, files))
  }
  if (length(available) == 0) 
    stop(gettextf("No demo found for topic %s", sQuote(topic)), domain = NA)
  if (length(available) > 1) {
    available <- available[1]
    warning(gettextf("Demo for topic %s' found more than once,\nusing the one found in %s", sQuote(topic), sQuote(dirname(available[1]))), domain = NA)
  }
  pkgpath <- dirname(dirname(available))
  if (html) {
    browseURL(paste0("http://127.0.0.1:", port, "/library/", basename(pkgpath), "/Demo/", tools::file_path_sans_ext(basename(available))), browser)
    return(invisible())
  }
  if (file.exists(file <- file.path(pkgpath, "Meta", "package.rds"))) {
    desc <- readRDS(file)$DESCRIPTION
    if (length(desc) == 1) {
      enc <- as.list(desc)[["Encoding"]]
      !if (!is.null(enc)) 
        encoding <- enc
    }
  }
  if (ask == "default") 
    ask <- echo && grDevices::dev.interactive(orNone = TRUE)
  if (.Device != "null device") {
    oldask <- grDevices::devAskNewPage(ask = ask)
    on.exit(grDevices::devAskNewPage(oldask), add = TRUE)
  }
  op <- options(device.ask.default = ask)
  on.exit(options(op), add = TRUE)
  if (echo) {
    cat("\n\n", "\tdemo(", topic, ")\n", "\t---- ", rep.int("~", nchar(topic, type = "w")), "\n", sep = "")
    if (ask && interactive()) 
      readline("\nType  <Return>\t to start : ")
  }
  source(available, echo = echo, max.deparse.length = Inf, keep.source = TRUE, encoding = encoding)
}, function (topic, package = NULL, lib.loc = NULL, character.only = FALSE, verbose = getOption("verbose"), type = c("console", "html"), echo = TRUE, ask = getOption("demo.ask"), encoding = getOption("encoding")) 
{
  type <- match.arg(type)
  html <- type == "html"
  if (html) {
    enhancedHTML <- str2logical(Sys.getenv("_R_HELP_ENABLE_ENHANCED_HTML_", "TRUE"))
    if (!interactive() || !enhancedHTML || !requireNamespace("knitr", quietly = TRUE)) 
      html <- FALSE
  }
  if (html) {
    port <- tools::startDynamicHelp(NA)
    if (port <= 0) 
      html <- FALSE
    else {
      if (!is.null(lib.loc)) 
        lib.loc <- NULL
      browser <- if (.Platform$GUI == "AQUA") {
        get("aqua.browser", envir = as.environment("tools:RGUI"))
      }
      else getOption("browser")
    }
  }
  paths <- find.package(package, lib.loc, verbose = verbose)
  paths <- paths[dir.exists(file.path(paths, "demo"))]
  if (missing(topic)) {
    if (html) {
      browseURL(paste0("http://127.0.0.1:", port, "/doc/html/Search?package=", paste(unique(basename(paths)), collapse = ";"), "&agrep=0&types.demo=1&pattern="), browser)
      return(invisible())
    }
    db <- matrix(character(), nrow = 0, ncol = 4)
    for (path in paths) {
      entries <- NULL
      if (file_test("-f", INDEX <- file.path(path, "Meta", "demo.rds"))) {
        entries <- readRDS(INDEX)
      }
      if (NROW(entries)) {
        db <- rbind(db, cbind(basename(path), dirname(path), entries))
      }
    }
    colnames(db) <- c("Package", "LibPath", "Item", "Title")
    footer <- if (missing(package)) 
      paste0("Use ", sQuote(paste("demo(package =", ".packages(all.available = TRUE))")), "\n", "to list the demos in all *available* packages.")
    else NULL
    y <- list(title = "Demos", header = NULL, results = db, footer = footer)
    class(y) <- "packageIQR"
    return(y)
  }
  if (!character.only) {
    topic <- substitute(topic)
    if (is.call(topic) && (topic[[1]] == "::" || topic[[1]] == ":::")) {
      package <- as.character(topic[[2]])
      topic <- as.character(topic[[3]])
    }
    else topic <- as.character(topic)
  }
  available <- character()
  paths <- file.path(paths, "demo")
  for (p in paths) {
    files <- basename(tools::list_files_with_type(p, "demo"))
    files <- files[topic == tools::file_path_sans_ext(files)]
    if (length(files)) 
      available <- c(available, file.path(p, files))
  }
  if (length(available) == 0) 
    stop(gettextf("No demo found for topic %s", sQuote(topic)), domain = NA)
  if (length(available) > 1) {
    available <- available[1]
    warning(gettextf("Demo for topic %s' found more than once,\nusing the one found in %s", sQuote(topic), sQuote(dirname(available[1]))), domain = NA)
  }
  pkgpath <- dirname(dirname(available))
  if (html) {
    browseURL(paste0("http://127.0.0.1:", port, "/library/", basename(pkgpath), "/Demo/", tools::file_path_sans_ext(basename(available))), browser)
    return(invisible())
  }
  if (file.exists(file <- file.path(pkgpath, "Meta", "package.rds"))) {
    desc <- readRDS(file)$DESCRIPTION
    if (length(desc) == 1) {
      enc <- as.list(desc)[["Encoding"]]
      !if (!is.null(enc)) 
        encoding <- enc
    }
  }
  if (ask == "default") 
    ask <- echo && grDevices::dev.interactive(orNone = TRUE)
  if (.Device != "null device") {
    oldask <- grDevices::devAskNewPage(ask = ask)
    on.exit(grDevices::devAskNewPage(oldask), add = TRUE)
  }
  op <- options(device.ask.default = ask)
  on.exit(options(op), add = TRUE)
  if (echo) {
    cat("\n\n", "\tdemo(", topic, ")\n", "\t---- ", rep.int("~", nchar(topic, type = "w")), "\n", sep = "")
    if (ask && interactive()) 
      readline("\nType  <Return>\t to start : ")
  }
  source(available, echo = echo, max.deparse.length = Inf, keep.source = TRUE, encoding = encoding)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
DLL.version
list(`package:utils` = function (path) 
  .Call(C_dllversion, path), function (path) 
    .Call(C_dllversion, path))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
download.file
list(`package:utils` = function (url, destfile, method, quiet = FALSE, mode = "w", cacheOK = TRUE, extra = getOption("download.file.extra"), headers = NULL, ...) 
{
  destfile
  method <- if (missing(method)) 
    getOption("download.file.method", default = "auto")
  else match.arg(method, c("auto", "internal", "wininet", "libcurl", "wget", "curl", "lynx"))
  if (missing(mode) && length(grep("\\.(gz|bz2|xz|tgz|zip|jar|rd[as]|RData)$", URLdecode(url)))) 
    mode <- "wb"
  if (method == "auto") {
    if (length(url) != 1 || typeof(url) != "character") 
      stop("'url' must be a length-one character vector")
    method <- if (startsWith(url, "file:")) 
      "wininet"
    else "libcurl"
  }
  nh <- names(headers)
  if (length(nh) != length(headers) || any(nh == "") || anyNA(headers) || anyNA(nh)) 
    stop("'headers' must have names and must not be NA")
  switch(method, internal = , wininet = {
    headers <- if (length(headers)) paste0(nh, ": ", headers, "\r\n", collapse = "")
    status <- .External(C_download, url, destfile, quiet, mode, cacheOK, headers, method == "wininet")
  }, libcurl = {
    headers <- if (length(headers)) paste0(nh, ": ", headers)
    status <- .Internal(curlDownload(url, destfile, quiet, mode, cacheOK, headers))
  }, wget = {
    if (length(url) != 1 || typeof(url) != "character") stop("'url' must be a length-one character vector")
    if (length(destfile) != 1 || typeof(destfile) != "character") stop("'destfile' must be a length-one character vector")
    if (quiet) extra <- c(extra, "--quiet")
    if (!cacheOK) extra <- c(extra, "--cache=off")
    status <- system(paste("wget", paste(extra, collapse = " "), shQuote(url), "-O", shQuote(path.expand(destfile))))
    if (status) stop("'wget' call had nonzero exit status")
  }, curl = {
    if (length(url) != 1 || typeof(url) != "character") stop("'url' must be a length-one character vector")
    if (length(destfile) != 1 || typeof(url) != "character") stop("'destfile' must be a length-one character vector")
    if (quiet) extra <- c(extra, "-s -S")
    if (!cacheOK) extra <- c(extra, paste("-H", shQuote("Pragma: no-cache")))
    status <- system(paste("curl", paste(extra, collapse = " "), shQuote(url), " -o", shQuote(path.expand(destfile))))
    if (status) stop("'curl' call had nonzero exit status")
  }, lynx = stop("method 'lynx' is defunct", domain = NA))
  if (status > 0) 
    warning("download had nonzero exit status")
  invisible(status)
}, function (url, destfile, method, quiet = FALSE, mode = "w", cacheOK = TRUE, extra = getOption("download.file.extra"), headers = NULL, ...) 
{
  destfile
  method <- if (missing(method)) 
    getOption("download.file.method", default = "auto")
  else match.arg(method, c("auto", "internal", "wininet", "libcurl", "wget", "curl", "lynx"))
  if (missing(mode) && length(grep("\\.(gz|bz2|xz|tgz|zip|jar|rd[as]|RData)$", URLdecode(url)))) 
    mode <- "wb"
  if (method == "auto") {
    if (length(url) != 1 || typeof(url) != "character") 
      stop("'url' must be a length-one character vector")
    method <- if (startsWith(url, "file:")) 
      "wininet"
    else "libcurl"
  }
  nh <- names(headers)
  if (length(nh) != length(headers) || any(nh == "") || anyNA(headers) || anyNA(nh)) 
    stop("'headers' must have names and must not be NA")
  switch(method, internal = , wininet = {
    headers <- if (length(headers)) paste0(nh, ": ", headers, "\r\n", collapse = "")
    status <- .External(C_download, url, destfile, quiet, mode, cacheOK, headers, method == "wininet")
  }, libcurl = {
    headers <- if (length(headers)) paste0(nh, ": ", headers)
    status <- .Internal(curlDownload(url, destfile, quiet, mode, cacheOK, headers))
  }, wget = {
    if (length(url) != 1 || typeof(url) != "character") stop("'url' must be a length-one character vector")
    if (length(destfile) != 1 || typeof(destfile) != "character") stop("'destfile' must be a length-one character vector")
    if (quiet) extra <- c(extra, "--quiet")
    if (!cacheOK) extra <- c(extra, "--cache=off")
    status <- system(paste("wget", paste(extra, collapse = " "), shQuote(url), "-O", shQuote(path.expand(destfile))))
    if (status) stop("'wget' call had nonzero exit status")
  }, curl = {
    if (length(url) != 1 || typeof(url) != "character") stop("'url' must be a length-one character vector")
    if (length(destfile) != 1 || typeof(url) != "character") stop("'destfile' must be a length-one character vector")
    if (quiet) extra <- c(extra, "-s -S")
    if (!cacheOK) extra <- c(extra, paste("-H", shQuote("Pragma: no-cache")))
    status <- system(paste("curl", paste(extra, collapse = " "), shQuote(url), " -o", shQuote(path.expand(destfile))))
    if (status) stop("'curl' call had nonzero exit status")
  }, lynx = stop("method 'lynx' is defunct", domain = NA))
  if (status > 0) 
    warning("download had nonzero exit status")
  invisible(status)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
download.packages
list(`package:utils` = function (pkgs, destdir, available = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), method, type = getOption("pkgType"), ...) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  nonlocalcran <- !all(startsWith(contriburl, "file:"))
  if (nonlocalcran && !dir.exists(destdir)) 
    stop("'destdir' is not a directory")
  type <- resolvePkgType(type)
  if (is.null(available)) 
    available <- available.packages(contriburl = contriburl, method = method, ...)
  retval <- matrix(character(), 0, 2)
  for (p in unique(pkgs)) {
    ok <- (available[, "Package"] == p)
    ok <- ok & !is.na(ok)
    if (!any(ok)) 
      warning(gettextf("no package %s at the repositories", sQuote(p)), domain = NA, immediate. = TRUE)
    else {
      if (sum(ok) > 1) {
        vers <- package_version(available[ok, "Version"])
        keep <- vers == max(vers)
        keep[duplicated(keep)] <- FALSE
        ok[ok][!keep] <- FALSE
      }
      if (startsWith(type, "mac.binary")) 
        type <- "mac.binary"
      File <- available[ok, "File"]
      fn <- paste0(p, "_", available[ok, "Version"], switch(type, source = ".tar.gz", mac.binary = ".tgz", win.binary = ".zip", stop("invalid 'type'")))
      have_fn <- !is.na(File)
      fn[have_fn] <- File[have_fn]
      repos <- available[ok, "Repository"]
      if (startsWith(repos, "file:")) {
        if (startsWith(repos, "file:///")) {
          fn <- paste(substring(repos, 8), fn, sep = "/")
          if (.Platform$OS.type == "windows") {
            if (length(grep("^/[A-Za-z]:", fn))) 
              fn <- substring(fn, 2)
          }
        }
        else {
          fn <- paste(substring(repos, 6), fn, sep = "/")
        }
        if (file.exists(fn)) 
          retval <- rbind(retval, c(p, fn))
        else warning(gettextf("package %s does not exist on the local repository", sQuote(p)), domain = NA, immediate. = TRUE)
      }
      else {
        url <- paste(repos, fn, sep = "/")
        destfile <- file.path(destdir, fn)
        res <- try(download.file(url, destfile, method, mode = "wb", ...))
        if (!inherits(res, "try-error") && res == 0) 
          retval <- rbind(retval, c(p, destfile))
        else warning(gettextf("download of package %s failed", sQuote(p)), domain = NA, immediate. = TRUE)
      }
    }
  }
  retval
}, function (pkgs, destdir, available = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), method, type = getOption("pkgType"), ...) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  nonlocalcran <- !all(startsWith(contriburl, "file:"))
  if (nonlocalcran && !dir.exists(destdir)) 
    stop("'destdir' is not a directory")
  type <- resolvePkgType(type)
  if (is.null(available)) 
    available <- available.packages(contriburl = contriburl, method = method, ...)
  retval <- matrix(character(), 0, 2)
  for (p in unique(pkgs)) {
    ok <- (available[, "Package"] == p)
    ok <- ok & !is.na(ok)
    if (!any(ok)) 
      warning(gettextf("no package %s at the repositories", sQuote(p)), domain = NA, immediate. = TRUE)
    else {
      if (sum(ok) > 1) {
        vers <- package_version(available[ok, "Version"])
        keep <- vers == max(vers)
        keep[duplicated(keep)] <- FALSE
        ok[ok][!keep] <- FALSE
      }
      if (startsWith(type, "mac.binary")) 
        type <- "mac.binary"
      File <- available[ok, "File"]
      fn <- paste0(p, "_", available[ok, "Version"], switch(type, source = ".tar.gz", mac.binary = ".tgz", win.binary = ".zip", stop("invalid 'type'")))
      have_fn <- !is.na(File)
      fn[have_fn] <- File[have_fn]
      repos <- available[ok, "Repository"]
      if (startsWith(repos, "file:")) {
        if (startsWith(repos, "file:///")) {
          fn <- paste(substring(repos, 8), fn, sep = "/")
          if (.Platform$OS.type == "windows") {
            if (length(grep("^/[A-Za-z]:", fn))) 
              fn <- substring(fn, 2)
          }
        }
        else {
          fn <- paste(substring(repos, 6), fn, sep = "/")
        }
        if (file.exists(fn)) 
          retval <- rbind(retval, c(p, fn))
        else warning(gettextf("package %s does not exist on the local repository", sQuote(p)), domain = NA, immediate. = TRUE)
      }
      else {
        url <- paste(repos, fn, sep = "/")
        destfile <- file.path(destdir, fn)
        res <- try(download.file(url, destfile, method, mode = "wb", ...))
        if (!inherits(res, "try-error") && res == 0) 
          retval <- rbind(retval, c(p, destfile))
        else warning(gettextf("download of package %s failed", sQuote(p)), domain = NA, immediate. = TRUE)
      }
    }
  }
  retval
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
dump.frames
list(`package:utils` = function (dumpto = "last.dump", to.file = FALSE, include.GlobalEnv = FALSE) 
{
  calls <- sys.calls()
  last.dump <- sys.frames()
  names(last.dump) <- limitedLabels(calls)
  if (include.GlobalEnv) {
    last.dump <- c(.GlobalEnv = as.environment(as.list(.GlobalEnv, all.names = TRUE)), last.dump)
  }
  last.dump <- last.dump[-length(last.dump)]
  attr(last.dump, "error.message") <- geterrmessage()
  class(last.dump) <- "dump.frames"
  if (dumpto != "last.dump") 
    assign(dumpto, last.dump)
  if (to.file) 
    save(list = dumpto, file = paste0(dumpto, ".rda"))
  else assign(dumpto, last.dump, envir = .GlobalEnv)
  invisible()
}, function (dumpto = "last.dump", to.file = FALSE, include.GlobalEnv = FALSE) 
{
  calls <- sys.calls()
  last.dump <- sys.frames()
  names(last.dump) <- limitedLabels(calls)
  if (include.GlobalEnv) {
    last.dump <- c(.GlobalEnv = as.environment(as.list(.GlobalEnv, all.names = TRUE)), last.dump)
  }
  last.dump <- last.dump[-length(last.dump)]
  attr(last.dump, "error.message") <- geterrmessage()
  class(last.dump) <- "dump.frames"
  if (dumpto != "last.dump") 
    assign(dumpto, last.dump)
  if (to.file) 
    save(list = dumpto, file = paste0(dumpto, ".rda"))
  else assign(dumpto, last.dump, envir = .GlobalEnv)
  invisible()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
edit
list(`package:utils` = function (name, ...) 
  UseMethod("edit"), function (name, ...) 
    UseMethod("edit"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
emacs
list(`package:utils` = function (name = NULL, file = "") 
  edit.default(name, file, editor = "emacs"), function (name = NULL, file = "") 
    edit.default(name, file, editor = "emacs"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
example
list(`package:utils` = function (topic, package = NULL, lib.loc = NULL, character.only = FALSE, give.lines = FALSE, local = FALSE, type = c("console", "html"), echo = TRUE, verbose = getOption("verbose"), setRNG = FALSE, ask = getOption("example.ask"), prompt.prefix = abbreviate(topic, 6), run.dontrun = FALSE, run.donttest = interactive()) 
{
  type <- match.arg(type)
  html <- type == "html"
  if (html) {
    enhancedHTML <- str2logical(Sys.getenv("_R_HELP_ENABLE_ENHANCED_HTML_", "TRUE"))
    if (!interactive() || !enhancedHTML || !requireNamespace("knitr", quietly = TRUE)) 
      html <- FALSE
  }
  if (html) {
    port <- tools::startDynamicHelp(NA)
    if (port <= 0) 
      html <- FALSE
    else {
      if (!is.null(lib.loc)) 
        lib.loc <- NULL
      browser <- if (.Platform$GUI == "AQUA") {
        get("aqua.browser", envir = as.environment("tools:RGUI"))
      }
      else getOption("browser")
    }
  }
  if (!character.only) {
    topic <- substitute(topic)
    if (!is.character(topic)) 
      topic <- deparse(topic)[1]
  }
  pkgpaths <- find.package(package, lib.loc, verbose = verbose)
  file <- index.search(topic, pkgpaths, firstOnly = TRUE)
  if (!length(file)) {
    warning(gettextf("no help found for %s", sQuote(topic)), domain = NA)
    return(invisible())
  }
  if (verbose) 
    cat("Found file =", sQuote(file), "\n")
  packagePath <- dirname(dirname(file))
  pkgname <- basename(packagePath)
  if (html) {
    query <- if (local) 
      ""
    else "?local=FALSE"
    browseURL(paste0("http://127.0.0.1:", port, "/library/", pkgname, "/Example/", topic, query), browser)
    return(invisible())
  }
  lib <- dirname(packagePath)
  tf <- tempfile("Rex")
  tools::Rd2ex(.getHelpFile(file), tf, commentDontrun = !run.dontrun, commentDonttest = !run.donttest)
  if (!file.exists(tf)) {
    if (give.lines) 
      return(character())
    warning(gettextf("%s has a help file but no examples", sQuote(topic)), domain = NA)
    return(invisible())
  }
  on.exit(unlink(tf))
  if (give.lines) 
    return(readLines(tf))
  if (pkgname != "base") 
    library(pkgname, lib.loc = lib, character.only = TRUE)
  if (!is.logical(setRNG) || setRNG) {
    if ((exists(".Random.seed", envir = .GlobalEnv))) {
      oldSeed <- get(".Random.seed", envir = .GlobalEnv)
      on.exit(assign(".Random.seed", oldSeed, envir = .GlobalEnv), add = TRUE)
    }
    else {
      oldRNG <- RNGkind()
      on.exit(RNGkind(oldRNG[1], oldRNG[2], oldRNG[3]), add = TRUE)
    }
    if (is.logical(setRNG)) {
      RNGkind("default", "default", "default")
      set.seed(1)
    }
    else eval(setRNG)
  }
  zz <- readLines(tf, n = 1)
  skips <- 0
  if (echo) {
    zcon <- file(tf, open = "rt")
    while (length(zz) && !length(grep("^### \\*\\*", zz))) {
      skips <- skips + 1
      zz <- readLines(zcon, n = 1)
    }
    close(zcon)
  }
  if (ask == "default") 
    ask <- echo && grDevices::dev.interactive(orNone = TRUE)
  if (ask) {
    if (.Device != "null device") {
      oldask <- grDevices::devAskNewPage(ask = TRUE)
      if (!oldask) 
        on.exit(grDevices::devAskNewPage(oldask), add = TRUE)
    }
    op <- options(device.ask.default = TRUE)
    on.exit(options(op), add = TRUE)
  }
  source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")), continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose, max.deparse.length = Inf, encoding = "UTF-8", skip.echo = skips, keep.source = TRUE)
}, function (topic, package = NULL, lib.loc = NULL, character.only = FALSE, give.lines = FALSE, local = FALSE, type = c("console", "html"), echo = TRUE, verbose = getOption("verbose"), setRNG = FALSE, ask = getOption("example.ask"), prompt.prefix = abbreviate(topic, 6), run.dontrun = FALSE, run.donttest = interactive()) 
{
  type <- match.arg(type)
  html <- type == "html"
  if (html) {
    enhancedHTML <- str2logical(Sys.getenv("_R_HELP_ENABLE_ENHANCED_HTML_", "TRUE"))
    if (!interactive() || !enhancedHTML || !requireNamespace("knitr", quietly = TRUE)) 
      html <- FALSE
  }
  if (html) {
    port <- tools::startDynamicHelp(NA)
    if (port <= 0) 
      html <- FALSE
    else {
      if (!is.null(lib.loc)) 
        lib.loc <- NULL
      browser <- if (.Platform$GUI == "AQUA") {
        get("aqua.browser", envir = as.environment("tools:RGUI"))
      }
      else getOption("browser")
    }
  }
  if (!character.only) {
    topic <- substitute(topic)
    if (!is.character(topic)) 
      topic <- deparse(topic)[1]
  }
  pkgpaths <- find.package(package, lib.loc, verbose = verbose)
  file <- index.search(topic, pkgpaths, firstOnly = TRUE)
  if (!length(file)) {
    warning(gettextf("no help found for %s", sQuote(topic)), domain = NA)
    return(invisible())
  }
  if (verbose) 
    cat("Found file =", sQuote(file), "\n")
  packagePath <- dirname(dirname(file))
  pkgname <- basename(packagePath)
  if (html) {
    query <- if (local) 
      ""
    else "?local=FALSE"
    browseURL(paste0("http://127.0.0.1:", port, "/library/", pkgname, "/Example/", topic, query), browser)
    return(invisible())
  }
  lib <- dirname(packagePath)
  tf <- tempfile("Rex")
  tools::Rd2ex(.getHelpFile(file), tf, commentDontrun = !run.dontrun, commentDonttest = !run.donttest)
  if (!file.exists(tf)) {
    if (give.lines) 
      return(character())
    warning(gettextf("%s has a help file but no examples", sQuote(topic)), domain = NA)
    return(invisible())
  }
  on.exit(unlink(tf))
  if (give.lines) 
    return(readLines(tf))
  if (pkgname != "base") 
    library(pkgname, lib.loc = lib, character.only = TRUE)
  if (!is.logical(setRNG) || setRNG) {
    if ((exists(".Random.seed", envir = .GlobalEnv))) {
      oldSeed <- get(".Random.seed", envir = .GlobalEnv)
      on.exit(assign(".Random.seed", oldSeed, envir = .GlobalEnv), add = TRUE)
    }
    else {
      oldRNG <- RNGkind()
      on.exit(RNGkind(oldRNG[1], oldRNG[2], oldRNG[3]), add = TRUE)
    }
    if (is.logical(setRNG)) {
      RNGkind("default", "default", "default")
      set.seed(1)
    }
    else eval(setRNG)
  }
  zz <- readLines(tf, n = 1)
  skips <- 0
  if (echo) {
    zcon <- file(tf, open = "rt")
    while (length(zz) && !length(grep("^### \\*\\*", zz))) {
      skips <- skips + 1
      zz <- readLines(zcon, n = 1)
    }
    close(zcon)
  }
  if (ask == "default") 
    ask <- echo && grDevices::dev.interactive(orNone = TRUE)
  if (ask) {
    if (.Device != "null device") {
      oldask <- grDevices::devAskNewPage(ask = TRUE)
      if (!oldask) 
        on.exit(grDevices::devAskNewPage(oldask), add = TRUE)
    }
    op <- options(device.ask.default = TRUE)
    on.exit(options(op), add = TRUE)
  }
  source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")), continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose, max.deparse.length = Inf, encoding = "UTF-8", skip.echo = skips, keep.source = TRUE)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
file.edit
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (..., title = file, editor = getOption("editor"), fileEncoding = "") 
  {
    file <- path.expand(c(...))
    title <- rep_len(as.character(title), length(file))
    if (nzchar(fileEncoding) && fileEncoding != "native.enc") {
      tfile <- file
      for (i in seq_along(file)) {
        tfile <- tempfile()
        con <- file(file[i], encoding = fileEncoding)
        writeLines(readLines(con), tfile)
        close(con)
        file[i] <- tfile
      }
    }
    if (is.function(editor)) 
      invisible(editor(file = file, title = title))
    else invisible(.External2(C_fileedit, file, title, editor))
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
file_test
list(`package:utils` = function (op, x, y) 
{
  switch(op, `-f` = !is.na(isdir <- file.info(x, extra_cols = FALSE)$isdir) & !isdir, `-d` = dir.exists(x), `-h` = (!is.na(y <- Sys.readlink(x)) & nzchar(y)), `-L` = (!is.na(y <- Sys.readlink(x)) & nzchar(y)), `-nt` = (!is.na(mt.x <- file.mtime(x)) & !is.na(mt.y <- file.mtime(y)) & (mt.x > mt.y)), `-ot` = (!is.na(mt.x <- file.mtime(x)) & !is.na(mt.y <- file.mtime(y)) & (mt.x < mt.y)), `-x` = (file.access(x, 1) == 0), `-w` = (file.access(x, 2) == 0), `-r` = (file.access(x, 4) == 0), stop(gettextf("test '%s' is not available", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     op), domain = NA))
}, function (op, x, y) 
{
  switch(op, `-f` = !is.na(isdir <- file.info(x, extra_cols = FALSE)$isdir) & !isdir, `-d` = dir.exists(x), `-h` = (!is.na(y <- Sys.readlink(x)) & nzchar(y)), `-L` = (!is.na(y <- Sys.readlink(x)) & nzchar(y)), `-nt` = (!is.na(mt.x <- file.mtime(x)) & !is.na(mt.y <- file.mtime(y)) & (mt.x > mt.y)), `-ot` = (!is.na(mt.x <- file.mtime(x)) & !is.na(mt.y <- file.mtime(y)) & (mt.x < mt.y)), `-x` = (file.access(x, 1) == 0), `-w` = (file.access(x, 2) == 0), `-r` = (file.access(x, 4) == 0), stop(gettextf("test '%s' is not available", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     op), domain = NA))
}, function (op, x, y) 
{
  switch(op, `-f` = !is.na(isdir <- file.info(x, extra_cols = FALSE)$isdir) & !isdir, `-d` = dir.exists(x), `-h` = (!is.na(y <- Sys.readlink(x)) & nzchar(y)), `-L` = (!is.na(y <- Sys.readlink(x)) & nzchar(y)), `-nt` = (!is.na(mt.x <- file.mtime(x)) & !is.na(mt.y <- file.mtime(y)) & (mt.x > mt.y)), `-ot` = (!is.na(mt.x <- file.mtime(x)) & !is.na(mt.y <- file.mtime(y)) & (mt.x < mt.y)), `-x` = (file.access(x, 1) == 0), `-w` = (file.access(x, 2) == 0), `-r` = (file.access(x, 4) == 0), stop(gettextf("test '%s' is not available", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     op), domain = NA))
})
c("package:utils", "namespace:utils", "namespace:tools")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
fileSnapshot
list(`package:utils` = function (path = ".", file.info = TRUE, timestamp = NULL, md5sum = FALSE, digest = NULL, full.names = length(path) > 1, ...) 
{
  if (length(path) > 1 && !full.names) 
    stop("'full.names' must be TRUE for multiple paths.")
  if (length(timestamp) == 1) 
    file.create(timestamp)
  path <- normalizePath(path)
  args <- list(...)
  fullnames <- names <- character(0)
  for (i in seq_along(path)) {
    newnames <- do.call(list.files, c(path = path[i], full.names = full.names, args))
    names <- c(names, newnames)
    if (full.names) 
      fullnames <- names
    else fullnames <- c(fullnames, file.path(path[i], newnames))
  }
  if (file.info) {
    info <- file.info(fullnames)
    if (!full.names) 
      rownames(info) <- names
  }
  else info <- data.frame(row.names = names)
  if (md5sum) 
    info <- data.frame(info, md5sum = suppressWarnings(tools::md5sum(fullnames)), stringsAsFactors = FALSE)
  if (!is.null(digest)) 
    info <- data.frame(info, digest = digest(fullnames), stringsAsFactors = FALSE)
  structure(list(info = info, path = path, timestamp = timestamp, file.info = file.info, md5sum = md5sum, digest = digest, full.names = full.names, args = args), class = "fileSnapshot")
}, function (path = ".", file.info = TRUE, timestamp = NULL, md5sum = FALSE, digest = NULL, full.names = length(path) > 1, ...) 
{
  if (length(path) > 1 && !full.names) 
    stop("'full.names' must be TRUE for multiple paths.")
  if (length(timestamp) == 1) 
    file.create(timestamp)
  path <- normalizePath(path)
  args <- list(...)
  fullnames <- names <- character(0)
  for (i in seq_along(path)) {
    newnames <- do.call(list.files, c(path = path[i], full.names = full.names, args))
    names <- c(names, newnames)
    if (full.names) 
      fullnames <- names
    else fullnames <- c(fullnames, file.path(path[i], newnames))
  }
  if (file.info) {
    info <- file.info(fullnames)
    if (!full.names) 
      rownames(info) <- names
  }
  else info <- data.frame(row.names = names)
  if (md5sum) 
    info <- data.frame(info, md5sum = suppressWarnings(tools::md5sum(fullnames)), stringsAsFactors = FALSE)
  if (!is.null(digest)) 
    info <- data.frame(info, digest = digest(fullnames), stringsAsFactors = FALSE)
  structure(list(info = info, path = path, timestamp = timestamp, file.info = file.info, md5sum = md5sum, digest = digest, full.names = full.names, args = args), class = "fileSnapshot")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
Filters
list(`package:utils` = c("R or S files (*.R,*.q,*.ssc,*.S)", "Enhanced metafiles (*.emf)", "Postscript files (*.ps)", "PDF files (*.pdf)", "Png files (*.png)", "Windows bitmap files (*.bmp)", "Jpeg files (*.jpeg,*.jpg)", "Text files (*.txt)", "R images (*.RData,*.rda)", "Zip files (*.zip)", "Package tarballs (*.tar.gz)", "All files (*.*)", "*.R;*.q;*.ssc;*.S", "*.emf", "*.ps", "*.pdf", "*.png", "*.bmp", "*.jpeg;*.jpg", "*.txt", "*.RData;*.rda", "*.zip", "*.tar.gz", "*.*"), c("R or S files (*.R,*.q,*.ssc,*.S)", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "Enhanced metafiles (*.emf)", "Postscript files (*.ps)", "PDF files (*.pdf)", "Png files (*.png)", "Windows bitmap files (*.bmp)", "Jpeg files (*.jpeg,*.jpg)", "Text files (*.txt)", "R images (*.RData,*.rda)", "Zip files (*.zip)", "Package tarballs (*.tar.gz)", "All files (*.*)", "*.R;*.q;*.ssc;*.S", "*.emf", "*.ps", "*.pdf", "*.png", "*.bmp", "*.jpeg;*.jpg", "*.txt", "*.RData;*.rda", "*.zip", "*.tar.gz", "*.*"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
find
list(`package:utils` = function (what, mode = "any", numeric = FALSE, simple.words = TRUE) 
{
  stopifnot(is.character(what))
  if (length(what) > 1) {
    warning("elements of 'what' after the first will be ignored")
    what <- what[1]
  }
  len.s <- length(sp <- search())
  ind <- logical(len.s)
  check.mode <- mode != "any"
  for (i in 1:len.s) {
    if (simple.words) {
      found <- what %in% ls(pos = i, all.names = TRUE)
      if (found && check.mode) 
        found <- exists(what, where = i, mode = mode, inherits = FALSE)
      ind[i] <- found
    }
    else {
      li <- ls(pos = i, pattern = what, all.names = TRUE)
      li <- grep("^[.](__|C_|F_)", li, invert = TRUE, value = TRUE)
      if (sp[i] == "package:base") 
        li <- li[!li %in% .dot_internals]
      ll <- length(li)
      if (ll > 0 && check.mode) {
        mode.ok <- vapply(li, exists, NA, where = i, mode = mode, inherits = FALSE)
        ll <- sum(mode.ok)
        if (ll >= 2) 
          warning(sprintf(ngettext(ll, "%d occurrence in %s", "%d occurrences in %s"), ll, sp[i]), domain = NA)
      }
      ind[i] <- ll > 0
    }
  }
  if (numeric) 
    structure(which(ind), names = sp[ind])
  else sp[ind]
}, function (what, mode = "any", numeric = FALSE, simple.words = TRUE) 
{
  stopifnot(is.character(what))
  if (length(what) > 1) {
    warning("elements of 'what' after the first will be ignored")
    what <- what[1]
  }
  len.s <- length(sp <- search())
  ind <- logical(len.s)
  check.mode <- mode != "any"
  for (i in 1:len.s) {
    if (simple.words) {
      found <- what %in% ls(pos = i, all.names = TRUE)
      if (found && check.mode) 
        found <- exists(what, where = i, mode = mode, inherits = FALSE)
      ind[i] <- found
    }
    else {
      li <- ls(pos = i, pattern = what, all.names = TRUE)
      li <- grep("^[.](__|C_|F_)", li, invert = TRUE, value = TRUE)
      if (sp[i] == "package:base") 
        li <- li[!li %in% .dot_internals]
      ll <- length(li)
      if (ll > 0 && check.mode) {
        mode.ok <- vapply(li, exists, NA, where = i, mode = mode, inherits = FALSE)
        ll <- sum(mode.ok)
        if (ll >= 2) 
          warning(sprintf(ngettext(ll, "%d occurrence in %s", "%d occurrences in %s"), ll, sp[i]), domain = NA)
      }
      ind[i] <- ll > 0
    }
  }
  if (numeric) 
    structure(which(ind), names = sp[ind])
  else sp[ind]
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
findCRANmirror
list(`package:utils` = function (type = c("src", "web")) 
{
  e <- paste0("R_CRAN_", toupper(type))
  Sys.getenv(e, tools:::.get_CRAN_repository_URL())
}, function (type = c("src", "web")) 
{
  e <- paste0("R_CRAN_", toupper(type))
  Sys.getenv(e, tools:::.get_CRAN_repository_URL())
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
findLineNum
list(`package:utils` = function (srcfile, line, nameonly = TRUE, envir = parent.frame(), lastenv) 
{
  count <- 0
  result <- list()
  if (!inherits(srcfile, "srcfile")) {
    if (missing(line)) {
      line <- as.numeric(sub(".*#", "", srcfile))
      if (is.na(line)) 
        stop("Line number missing")
      srcfile <- sub("#[^#]*", "", srcfile)
    }
    srcfile <- srcfile(srcfile)
  }
  if (missing(lastenv)) {
    if (missing(envir)) 
      lastenv <- globalenv()
    else lastenv <- emptyenv()
  }
  if (!is.environment(envir)) 
    envir <- environment(envir)
  fns <- character()
  envirs <- list()
  e <- envir
  repeat {
    fns <- c(fns, lsf.str(envir = e, all = TRUE))
    oldlen <- length(envirs)
    length(envirs) <- length(fns)
    if (length(envirs) > oldlen) 
      for (i in seq.int(oldlen + 1, length(envirs))) envirs[[i]] <- e
    if (identical(e, lastenv) || identical(e, emptyenv())) 
      break
    e <- parent.env(e)
  }
  for (i in seq_along(fns)) {
    functionName <- fns[i]
    fn <- get(functionName, envir = envirs[[i]])
    loc <- fnLineNum(fn, srcfile = srcfile, line = line, nameonly = nameonly)
    if (!is.null(loc)) {
      count <- count + 1
      result[[count]] <- c(list(name = functionName, env = envirs[[i]]), loc)
    }
    gen <- tryCatch(methods::isGeneric(functionName, envirs[[i]], fdef = fn), error = identity)
    if (isTRUE(gen)) {
      e1 <- environment(fn)$.AllMTable
      if (!is.null(e1)) {
        sigs <- ls(e1)
        for (j in seq_along(sigs)) {
          sig <- sigs[j]
          fn <- get(sig, e1)
          if (typeof(fn) != "closure") 
            next
          loc <- fnLineNum(fn, srcfile = srcfile, line = line, nameonly = nameonly)
          if (is.null(loc) && length(body(fn)) > 1 && length(body(fn)[[2]]) > 2 && typeof(body(fn)[[c(2, 3)]]) == "closure") {
            fn2 <- body(fn)[[c(2, 3)]]
            loc <- fnLineNum(fn2, srcfile = srcfile, line = line, nameonly = nameonly)
            if (!is.null(loc)) 
              loc$at <- c(2, 3)
          }
          if (!is.null(loc)) {
            count <- count + 1
            result[[count]] <- c(list(name = functionName, env = envirs[[i]], signature = strsplit(sig, "#")[[1]]), loc)
          }
        }
      }
    }
  }
  return(structure(result, class = "findLineNumResult"))
}, function (srcfile, line, nameonly = TRUE, envir = parent.frame(), lastenv) 
{
  count <- 0
  result <- list()
  if (!inherits(srcfile, "srcfile")) {
    if (missing(line)) {
      line <- as.numeric(sub(".*#", "", srcfile))
      if (is.na(line)) 
        stop("Line number missing")
      srcfile <- sub("#[^#]*", "", srcfile)
    }
    srcfile <- srcfile(srcfile)
  }
  if (missing(lastenv)) {
    if (missing(envir)) 
      lastenv <- globalenv()
    else lastenv <- emptyenv()
  }
  if (!is.environment(envir)) 
    envir <- environment(envir)
  fns <- character()
  envirs <- list()
  e <- envir
  repeat {
    fns <- c(fns, lsf.str(envir = e, all = TRUE))
    oldlen <- length(envirs)
    length(envirs) <- length(fns)
    if (length(envirs) > oldlen) 
      for (i in seq.int(oldlen + 1, length(envirs))) envirs[[i]] <- e
    if (identical(e, lastenv) || identical(e, emptyenv())) 
      break
    e <- parent.env(e)
  }
  for (i in seq_along(fns)) {
    functionName <- fns[i]
    fn <- get(functionName, envir = envirs[[i]])
    loc <- fnLineNum(fn, srcfile = srcfile, line = line, nameonly = nameonly)
    if (!is.null(loc)) {
      count <- count + 1
      result[[count]] <- c(list(name = functionName, env = envirs[[i]]), loc)
    }
    gen <- tryCatch(methods::isGeneric(functionName, envirs[[i]], fdef = fn), error = identity)
    if (isTRUE(gen)) {
      e1 <- environment(fn)$.AllMTable
      if (!is.null(e1)) {
        sigs <- ls(e1)
        for (j in seq_along(sigs)) {
          sig <- sigs[j]
          fn <- get(sig, e1)
          if (typeof(fn) != "closure") 
            next
          loc <- fnLineNum(fn, srcfile = srcfile, line = line, nameonly = nameonly)
          if (is.null(loc) && length(body(fn)) > 1 && length(body(fn)[[2]]) > 2 && typeof(body(fn)[[c(2, 3)]]) == "closure") {
            fn2 <- body(fn)[[c(2, 3)]]
            loc <- fnLineNum(fn2, srcfile = srcfile, line = line, nameonly = nameonly)
            if (!is.null(loc)) 
              loc$at <- c(2, 3)
          }
          if (!is.null(loc)) {
            count <- count + 1
            result[[count]] <- c(list(name = functionName, env = envirs[[i]], signature = strsplit(sig, "#")[[1]]), loc)
          }
        }
      }
    }
  }
  return(structure(result, class = "findLineNumResult"))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
fix
list(`package:utils` = function (x, ...) 
{
  subx <- substitute(x)
  if (is.name(subx)) 
    subx <- deparse(subx)
  if (!is.character(subx) || length(subx) != 1) 
    stop("'fix' requires a name")
  parent <- parent.frame()
  if (exists(subx, envir = parent, inherits = TRUE)) 
    x <- edit(get(subx, envir = parent), title = subx, ...)
  else {
    x <- edit(function() {
    }, title = subx, ...)
    environment(x) <- .GlobalEnv
  }
  assign(subx, x, envir = .GlobalEnv)
}, function (x, ...) 
{
  subx <- substitute(x)
  if (is.name(subx)) 
    subx <- deparse(subx)
  if (!is.character(subx) || length(subx) != 1) 
    stop("'fix' requires a name")
  parent <- parent.frame()
  if (exists(subx, envir = parent, inherits = TRUE)) 
    x <- edit(get(subx, envir = parent), title = subx, ...)
  else {
    x <- edit(function() {
    }, title = subx, ...)
    environment(x) <- .GlobalEnv
  }
  assign(subx, x, envir = .GlobalEnv)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
fixInNamespace
list(`package:utils` = function (x, ns, pos = -1, envir = as.environment(pos), ...) 
{
  subx <- substitute(x)
  if (is.name(subx)) 
    subx <- deparse(subx)
  if (!is.character(subx) || length(subx) != 1) 
    stop("'fixInNamespace' requires a name")
  if (missing(ns)) {
    nm <- attr(envir, "name", exact = TRUE)
    if (is.null(nm) || !startsWith(nm, "package:")) 
      stop("environment specified is not a package")
    ns <- asNamespace(substring(nm, 9))
  }
  else ns <- asNamespace(ns)
  x <- edit(get(subx, envir = ns, inherits = FALSE), ...)
  assignInNamespace(subx, x, ns)
}, function (x, ns, pos = -1, envir = as.environment(pos), ...) 
{
  subx <- substitute(x)
  if (is.name(subx)) 
    subx <- deparse(subx)
  if (!is.character(subx) || length(subx) != 1) 
    stop("'fixInNamespace' requires a name")
  if (missing(ns)) {
    nm <- attr(envir, "name", exact = TRUE)
    if (is.null(nm) || !startsWith(nm, "package:")) 
      stop("environment specified is not a package")
    ns <- asNamespace(substring(nm, 9))
  }
  else ns <- asNamespace(ns)
  x <- edit(get(subx, envir = ns, inherits = FALSE), ...)
  assignInNamespace(subx, x, ns)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
flush.console
list(`package:utils` = function () 
  invisible(.Call(C_flushconsole)), function () 
    invisible(.Call(C_flushconsole)), function () 
      invisible(.Call(C_flushconsole)))
c("package:utils", "registered S3 method for flush from namespace utils", "namespace:utils")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
formatOL
list(`package:utils` = function (x, type = "arabic", offset = 0, start = 1, width = 0.9 * getOption("width")) 
{
  if (!length(x)) 
    return(character())
  type_tokens <- c("1", "A", "a", "I", "i")
  type_full_names <- c("arabic", "Alph", "alph", "Roman", "roman")
  type <- match.arg(type, c(type_tokens, type_full_names))
  if (nchar(type, "b") > 1) 
    type <- type_tokens[match(type, type_full_names)]
  len <- length(x)
  labels <- seq.int(start[1], length.out = len)
  upper <- labels[len]
  if (type %in% c("A", "a")) {
    if (upper > 26) 
      stop(gettextf("too many list items (at most up to %d)", 26), domain = NA)
    labels <- if (type == "A") 
      LETTERS[labels]
    else letters[labels]
  }
  else if (type %in% c("I", "i")) {
    if (upper > 3899) 
      stop(gettextf("too many list items (at most up to %d)", 3899), domain = NA)
    labels <- as.character(as.roman(labels))
    if (type == "i") 
      labels <- tolower(labels)
  }
  .format_rl_table(sprintf("%s.", labels), x, offset, width)
}, function (x, type = "arabic", offset = 0, start = 1, width = 0.9 * getOption("width")) 
{
  if (!length(x)) 
    return(character())
  type_tokens <- c("1", "A", "a", "I", "i")
  type_full_names <- c("arabic", "Alph", "alph", "Roman", "roman")
  type <- match.arg(type, c(type_tokens, type_full_names))
  if (nchar(type, "b") > 1) 
    type <- type_tokens[match(type, type_full_names)]
  len <- length(x)
  labels <- seq.int(start[1], length.out = len)
  upper <- labels[len]
  if (type %in% c("A", "a")) {
    if (upper > 26) 
      stop(gettextf("too many list items (at most up to %d)", 26), domain = NA)
    labels <- if (type == "A") 
      LETTERS[labels]
    else letters[labels]
  }
  else if (type %in% c("I", "i")) {
    if (upper > 3899) 
      stop(gettextf("too many list items (at most up to %d)", 3899), domain = NA)
    labels <- as.character(as.roman(labels))
    if (type == "i") 
      labels <- tolower(labels)
  }
  .format_rl_table(sprintf("%s.", labels), x, offset, width)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
formatUL
list(`package:utils` = function (x, label = "*", offset = 0, width = 0.9 * getOption("width")) 
{
  if (!length(x)) 
    return(character())
  .format_rl_table(label, x, offset, width)
}, function (x, label = "*", offset = 0, width = 0.9 * getOption("width")) 
{
  if (!length(x)) 
    return(character())
  .format_rl_table(label, x, offset, width)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getAnywhere
list(`package:utils` = function (x) 
{
  if (tryCatch(!is.character(x), error = function(e) TRUE)) 
    x <- as.character(substitute(x))
  objs <- list()
  where <- character()
  visible <- logical()
  if (length(pos <- find(x, numeric = TRUE))) {
    objs <- lapply(pos, function(pos, x) get(x, pos = pos), x = x)
    where <- names(pos)
    visible <- rep.int(TRUE, length(pos))
  }
  if (length(grep(".", x, fixed = TRUE))) {
    np <- length(parts <- strsplit(x, ".", fixed = TRUE)[[1]])
    for (i in 2:np) {
      gen <- paste(parts[1:(i - 1)], collapse = ".")
      cl <- paste(parts[i:np], collapse = ".")
      if (gen == "" || cl == "") 
        next
      Call <- substitute(getS3method(gen, cl, TRUE), list(gen = gen, cl = cl))
      f <- eval.parent(Call)
      if (!is.null(f) && !is.null(environment(f))) {
        ev <- topenv(environment(f), baseenv())
        nmev <- if (isNamespace(ev)) 
          getNamespaceName(ev)
        else NULL
        objs <- c(objs, list(f))
        msg <- paste("registered S3 method for", gen)
        if (!is.null(nmev)) 
          msg <- paste(msg, "from namespace", nmev)
        where <- c(where, msg)
        visible <- c(visible, FALSE)
      }
    }
  }
  for (i in loadedNamespaces()) {
    ns <- asNamespace(i)
    if (exists(x, envir = ns, inherits = FALSE)) {
      f <- get(x, envir = ns, inherits = FALSE)
      objs <- c(objs, list(f))
      where <- c(where, paste0("namespace:", i))
      visible <- c(visible, FALSE)
    }
  }
  ln <- length(objs)
  dups <- rep.int(FALSE, ln)
  if (ln > 1) 
    for (i in 2:ln) for (j in 1:(i - 1)) if (identical(objs[[i]], objs[[j]], ignore.environment = TRUE)) {
      dups[i] <- TRUE
      break
    }
  structure(list(name = x, objs = objs, where = where, visible = visible, dups = dups), class = "getAnywhere")
}, function (x) 
{
  if (tryCatch(!is.character(x), error = function(e) TRUE)) 
    x <- as.character(substitute(x))
  objs <- list()
  where <- character()
  visible <- logical()
  if (length(pos <- find(x, numeric = TRUE))) {
    objs <- lapply(pos, function(pos, x) get(x, pos = pos), x = x)
    where <- names(pos)
    visible <- rep.int(TRUE, length(pos))
  }
  if (length(grep(".", x, fixed = TRUE))) {
    np <- length(parts <- strsplit(x, ".", fixed = TRUE)[[1]])
    for (i in 2:np) {
      gen <- paste(parts[1:(i - 1)], collapse = ".")
      cl <- paste(parts[i:np], collapse = ".")
      if (gen == "" || cl == "") 
        next
      Call <- substitute(getS3method(gen, cl, TRUE), list(gen = gen, cl = cl))
      f <- eval.parent(Call)
      if (!is.null(f) && !is.null(environment(f))) {
        ev <- topenv(environment(f), baseenv())
        nmev <- if (isNamespace(ev)) 
          getNamespaceName(ev)
        else NULL
        objs <- c(objs, list(f))
        msg <- paste("registered S3 method for", gen)
        if (!is.null(nmev)) 
          msg <- paste(msg, "from namespace", nmev)
        where <- c(where, msg)
        visible <- c(visible, FALSE)
      }
    }
  }
  for (i in loadedNamespaces()) {
    ns <- asNamespace(i)
    if (exists(x, envir = ns, inherits = FALSE)) {
      f <- get(x, envir = ns, inherits = FALSE)
      objs <- c(objs, list(f))
      where <- c(where, paste0("namespace:", i))
      visible <- c(visible, FALSE)
    }
  }
  ln <- length(objs)
  dups <- rep.int(FALSE, ln)
  if (ln > 1) 
    for (i in 2:ln) for (j in 1:(i - 1)) if (identical(objs[[i]], objs[[j]], ignore.environment = TRUE)) {
      dups[i] <- TRUE
      break
    }
  structure(list(name = x, objs = objs, where = where, visible = visible, dups = dups), class = "getAnywhere")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getClipboardFormats
list(`package:utils` = function (numeric = FALSE) 
{
  known <- c("text", "bitmap", "metafile PICT", "SYLK", "DIF", "TIFF", "OEM text", "DIB", "palette", "pendata", "RIFF", "audio", "Unicode text", "enhanced metafile", "drag-and-drop", "locale", "shell")
  ans <- sort(.Call(C_getClipboardFormats))
  if (numeric) 
    ans
  else {
    res <- known[ans]
    res[is.na(res)] <- ans[is.na(res)]
    res
  }
}, function (numeric = FALSE) 
{
  known <- c("text", "bitmap", "metafile PICT", "SYLK", "DIF", "TIFF", "OEM text", "DIB", "palette", "pendata", "RIFF", "audio", "Unicode text", "enhanced metafile", "drag-and-drop", "locale", "shell")
  ans <- sort(.Call(C_getClipboardFormats))
  if (numeric) 
    ans
  else {
    res <- known[ans]
    res[is.na(res)] <- ans[is.na(res)]
    res
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getCRANmirrors
list(`package:utils` = function (all = FALSE, local.only = FALSE) 
{
  .getMirrors("https://cran.r-project.org/CRAN_mirrors.csv", file.path(R.home("doc"), "CRAN_mirrors.csv"), all = all, local.only = local.only)
}, function (all = FALSE, local.only = FALSE) 
{
  .getMirrors("https://cran.r-project.org/CRAN_mirrors.csv", file.path(R.home("doc"), "CRAN_mirrors.csv"), all = all, local.only = local.only)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getFromNamespace
list(`package:utils` = function (x, ns, pos = -1, envir = as.environment(pos)) 
{
  if (missing(ns)) {
    nm <- attr(envir, "name", exact = TRUE)
    if (is.null(nm) || !startsWith(nm, "package:")) 
      stop("environment specified is not a package")
    ns <- asNamespace(substring(nm, 9))
  }
  else ns <- asNamespace(ns)
  get(x, envir = ns, inherits = FALSE)
}, function (x, ns, pos = -1, envir = as.environment(pos)) 
{
  if (missing(ns)) {
    nm <- attr(envir, "name", exact = TRUE)
    if (is.null(nm) || !startsWith(nm, "package:")) 
      stop("environment specified is not a package")
    ns <- asNamespace(substring(nm, 9))
  }
  else ns <- asNamespace(ns)
  get(x, envir = ns, inherits = FALSE)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
gethash
list(`package:utils` = function (h, key, nomatch = NULL) 
  .External(C_gethash_Ext, h, key, nomatch), function (h, key, nomatch = NULL) 
    .External(C_gethash_Ext, h, key, nomatch))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getIdentification
list(`package:utils` = function () 
  .Call(C_getIdentification), function () 
    .Call(C_getIdentification))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getParseData
list(`package:utils` = function (x, includeText = NA) 
{
  srcfile <- if (inherits(x, "srcfile")) 
    x
  else getSrcfile(x)
  if (is.null(srcfile)) 
    return(NULL)
  else data <- srcfile$parseData
  if (!is.null(data)) {
    tokens <- attr(data, "tokens")
    data <- t(unclass(data))
    colnames(data) <- c("line1", "col1", "line2", "col2", "terminal", "token.num", "id", "parent")
    data <- data.frame(data[, -c(5, 6), drop = FALSE], token = tokens, terminal = as.logical(data[, "terminal"]), text = attr(data, "text"), stringsAsFactors = FALSE)
    o <- order(data[, 1], data[, 2], -data[, 3], -data[, 4])
    data <- data[o, ]
    rownames(data) <- data$id
    attr(data, "srcfile") <- srcfile
    gettext <- if (isTRUE(includeText)) 
      which(!nzchar(data$text))
    else if (is.na(includeText)) 
      which(!nzchar(data$text) & data$terminal)
    else {
      data$text <- NULL
      integer(0)
    }
    if (length(gettext)) 
      data$text[gettext] <- getParseText(data, data$id[gettext])
  }
  data
}, function (x, includeText = NA) 
{
  srcfile <- if (inherits(x, "srcfile")) 
    x
  else getSrcfile(x)
  if (is.null(srcfile)) 
    return(NULL)
  else data <- srcfile$parseData
  if (!is.null(data)) {
    tokens <- attr(data, "tokens")
    data <- t(unclass(data))
    colnames(data) <- c("line1", "col1", "line2", "col2", "terminal", "token.num", "id", "parent")
    data <- data.frame(data[, -c(5, 6), drop = FALSE], token = tokens, terminal = as.logical(data[, "terminal"]), text = attr(data, "text"), stringsAsFactors = FALSE)
    o <- order(data[, 1], data[, 2], -data[, 3], -data[, 4])
    data <- data[o, ]
    rownames(data) <- data$id
    attr(data, "srcfile") <- srcfile
    gettext <- if (isTRUE(includeText)) 
      which(!nzchar(data$text))
    else if (is.na(includeText)) 
      which(!nzchar(data$text) & data$terminal)
    else {
      data$text <- NULL
      integer(0)
    }
    if (length(gettext)) 
      data$text[gettext] <- getParseText(data, data$id[gettext])
  }
  data
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getParseText
list(`package:utils` = function (parseData, id) 
{
  srcfile <- attr(parseData, "srcfile")
  d <- parseData[as.character(id), ]
  text <- d$text
  if (is.null(text)) {
    text <- character(nrow(d))
    blank <- seq_along(text)
  }
  else blank <- which(!nzchar(text) | (d$token == "STR_CONST" & startsWith(text, "[")))
  for (i in blank) {
    lines <- getSrcLines(srcfile, d$line1[i], d$line2[i])
    n <- length(lines)
    lines[n] <- substr_with_tabs(lines[n], 1, d$col2[i])
    lines[1] <- substr_with_tabs(lines[1], d$col1[i], Inf)
    text[i] <- paste(lines, collapse = "\n")
  }
  text
}, function (parseData, id) 
{
  srcfile <- attr(parseData, "srcfile")
  d <- parseData[as.character(id), ]
  text <- d$text
  if (is.null(text)) {
    text <- character(nrow(d))
    blank <- seq_along(text)
  }
  else blank <- which(!nzchar(text) | (d$token == "STR_CONST" & startsWith(text, "[")))
  for (i in blank) {
    lines <- getSrcLines(srcfile, d$line1[i], d$line2[i])
    n <- length(lines)
    lines[n] <- substr_with_tabs(lines[n], 1, d$col2[i])
    lines[1] <- substr_with_tabs(lines[1], d$col1[i], Inf)
    text[i] <- paste(lines, collapse = "\n")
  }
  text
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getS3method
list(`package:utils` = function (f, class, optional = FALSE, envir = parent.frame()) 
{
  stopifnot(is.character(f), length(f) == 1)
  stopifnot(is.character(class), length(class) == 1)
  if (!any(f == getKnownS3generics())) {
    truegf <- findGeneric(f, envir)
    if (nzchar(truegf)) 
      f <- truegf
    else {
      if (optional) 
        return(NULL)
      else stop(gettextf("no function '%s' could be found", f), domain = NA)
    }
  }
  method <- paste(f, class, sep = ".")
  if (!is.null(m <- get0(method, envir = envir, mode = "function"))) 
    return(m)
  defenv <- if (!is.na(w <- .knownS3Generics[f])) 
    asNamespace(w)
  else if (f %in% tools:::.get_internal_S3_generics()) 
    .BaseNamespaceEnv
  else {
    genfun <- get(f, mode = "function", envir = envir)
    if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
      genfun <- methods::selectMethod(genfun, "ANY")
    .defenv_for_S3_registry(genfun)
  }
  S3Table <- get(".__S3MethodsTable__.", envir = defenv)
  if (!is.null(m <- get0(method, envir = S3Table, inherits = FALSE))) 
    m
  else if (optional) 
    NULL
  else stop(gettextf("S3 method '%s' not found", method), domain = NA)
}, function (f, class, optional = FALSE, envir = parent.frame()) 
{
  stopifnot(is.character(f), length(f) == 1)
  stopifnot(is.character(class), length(class) == 1)
  if (!any(f == getKnownS3generics())) {
    truegf <- findGeneric(f, envir)
    if (nzchar(truegf)) 
      f <- truegf
    else {
      if (optional) 
        return(NULL)
      else stop(gettextf("no function '%s' could be found", f), domain = NA)
    }
  }
  method <- paste(f, class, sep = ".")
  if (!is.null(m <- get0(method, envir = envir, mode = "function"))) 
    return(m)
  defenv <- if (!is.na(w <- .knownS3Generics[f])) 
    asNamespace(w)
  else if (f %in% tools:::.get_internal_S3_generics()) 
    .BaseNamespaceEnv
  else {
    genfun <- get(f, mode = "function", envir = envir)
    if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
      genfun <- methods::selectMethod(genfun, "ANY")
    .defenv_for_S3_registry(genfun)
  }
  S3Table <- get(".__S3MethodsTable__.", envir = defenv)
  if (!is.null(m <- get0(method, envir = S3Table, inherits = FALSE))) 
    m
  else if (optional) 
    NULL
  else stop(gettextf("S3 method '%s' not found", method), domain = NA)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getSrcDirectory
list(`package:utils` = function (x, unique = TRUE) 
{
  result <- dirname(getSrcFilename(x, full.names = TRUE, unique = unique))
  if (unique) 
    unique(result)
  else result
}, function (x, unique = TRUE) 
{
  result <- dirname(getSrcFilename(x, full.names = TRUE, unique = unique))
  if (unique) 
    unique(result)
  else result
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getSrcFilename
list(`package:utils` = function (x, full.names = FALSE, unique = TRUE) 
{
  srcref <- getSrcref(x)
  if (is.list(srcref)) 
    result <- sapply(srcref, getSrcFilename, full.names, unique)
  else {
    srcfile <- attr(srcref, "srcfile")
    if (is.null(srcfile)) 
      result <- character()
    else result <- srcfile$filename
  }
  result <- if (full.names) 
    result
  else basename(result)
  if (unique) 
    unique(result)
  else result
}, function (x, full.names = FALSE, unique = TRUE) 
{
  srcref <- getSrcref(x)
  if (is.list(srcref)) 
    result <- sapply(srcref, getSrcFilename, full.names, unique)
  else {
    srcfile <- attr(srcref, "srcfile")
    if (is.null(srcfile)) 
      result <- character()
    else result <- srcfile$filename
  }
  result <- if (full.names) 
    result
  else basename(result)
  if (unique) 
    unique(result)
  else result
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getSrcLocation
list(`package:utils` = function (x, which = c("line", "column", "byte", "parse"), first = TRUE) 
{
  srcref <- getSrcref(x)
  if (is.null(srcref)) 
    return(NULL)
  if (is.list(srcref)) 
    sapply(srcref, getSrcLocation, which, first)
  else {
    if (length(srcref) == 6) 
      srcref <- c(srcref, srcref[c(1, 3)])
    which <- match.arg(which)
    if (first) 
      index <- c(line = 1, column = 5, byte = 2, parse = 7)[which]
    else index <- c(line = 3, column = 6, byte = 4, parse = 8)[which]
    srcref[index]
  }
}, function (x, which = c("line", "column", "byte", "parse"), first = TRUE) 
{
  srcref <- getSrcref(x)
  if (is.null(srcref)) 
    return(NULL)
  if (is.list(srcref)) 
    sapply(srcref, getSrcLocation, which, first)
  else {
    if (length(srcref) == 6) 
      srcref <- c(srcref, srcref[c(1, 3)])
    which <- match.arg(which)
    if (first) 
      index <- c(line = 1, column = 5, byte = 2, parse = 7)[which]
    else index <- c(line = 3, column = 6, byte = 4, parse = 8)[which]
    srcref[index]
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getSrcref
list(`package:utils` = function (x) 
{
  if (inherits(x, "srcref")) 
    x
  else if (!is.null(srcref <- attr(x, "srcref")) || is.function(x) && !is.null(srcref <- getSrcref(body(x)))) 
    srcref
  else if (methods::is(x, "MethodDefinition")) 
    getSrcref(unclass(methods::unRematchDefinition(x)))
}, function (x) 
{
  if (inherits(x, "srcref")) 
    x
  else if (!is.null(srcref <- attr(x, "srcref")) || is.function(x) && !is.null(srcref <- getSrcref(body(x)))) 
    srcref
  else if (methods::is(x, "MethodDefinition")) 
    getSrcref(unclass(methods::unRematchDefinition(x)))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getTxtProgressBar
list(`package:utils` = function (pb) 
{
  if (!inherits(pb, "txtProgressBar")) 
    stop(gettextf("'pb' is not from class %s", dQuote("txtProgressBar")), domain = NA)
  pb$getVal()
}, function (pb) 
{
  if (!inherits(pb, "txtProgressBar")) 
    stop(gettextf("'pb' is not from class %s", dQuote("txtProgressBar")), domain = NA)
  pb$getVal()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getWindowsHandle
list(`package:utils` = function (which = "Console") 
{
  if (is.numeric(which)) {
    which <- as.integer(which)
    if (!exists(".Devices")) 
      .Devices <- list("null device")
    if (which > 0 && which <= length(.Devices) && .Devices[[which]] != "windows") 
      return(NULL)
  }
  .Call(C_getWindowsHandle, which)
}, function (which = "Console") 
{
  if (is.numeric(which)) {
    which <- as.integer(which)
    if (!exists(".Devices")) 
      .Devices <- list("null device")
    if (which > 0 && which <= length(.Devices) && .Devices[[which]] != "windows") 
      return(NULL)
  }
  .Call(C_getWindowsHandle, which)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getWindowsHandles
list(`package:utils` = function (which = "R", pattern = "", minimized = FALSE) 
{
  which <- match.arg(which, c("R", "all"), several.ok = TRUE)
  len <- max(length(which), length(pattern), length(minimized))
  which <- rep_len(which, len)
  pattern <- rep_len(pattern, len)
  minimized <- rep_len(minimized, len)
  result <- list()
  for (i in seq_len(len)) {
    res <- .Call(C_getWindowsHandles, which[i], minimized)
    if (nzchar(pattern[i])) 
      res <- res[grep(pattern[i], names(res))]
    result <- c(result, res)
  }
  dup <- duplicated(lapply(result, deparse))
  result[!dup]
}, function (which = "R", pattern = "", minimized = FALSE) 
{
  which <- match.arg(which, c("R", "all"), several.ok = TRUE)
  len <- max(length(which), length(pattern), length(minimized))
  which <- rep_len(which, len)
  pattern <- rep_len(pattern, len)
  minimized <- rep_len(minimized, len)
  result <- list()
  for (i in seq_len(len)) {
    res <- .Call(C_getWindowsHandles, which[i], minimized)
    if (nzchar(pattern[i])) 
      res <- res[grep(pattern[i], names(res))]
    result <- c(result, res)
  }
  dup <- duplicated(lapply(result, deparse))
  result[!dup]
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getWindowTitle
list(`package:utils` = function () 
  .Call(C_getWindowTitle), function () 
    .Call(C_getWindowTitle))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
getWinProgressBar
list(`package:utils` = function (pb) 
{
  if (!inherits(pb, "winProgressBar")) 
    stop(gettextf("'pb' is not from class %s", dQuote("winProgressBar")), domain = NA)
  .External2(C_setWinProgressBar, pb$pb, NULL, NULL, NULL)
}, function (pb) 
{
  if (!inherits(pb, "winProgressBar")) 
    stop(gettextf("'pb' is not from class %s", dQuote("winProgressBar")), domain = NA)
  .External2(C_setWinProgressBar, pb$pb, NULL, NULL, NULL)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
glob2rx
list(`package:utils` = function (pattern, trim.head = FALSE, trim.tail = TRUE) 
{
  if (!length(pattern)) 
    return(character())
  p <- gsub(".", "\\.", paste0("^", pattern, "$"), fixed = TRUE)
  p <- gsub("?", ".", gsub("*", ".*", p, fixed = TRUE), fixed = TRUE)
  p <- gsub("([^\\])\\(", "\\1\\\\(", p)
  p <- gsub("([^\\])\\[", "\\1\\\\[", p)
  p <- gsub("([^\\])\\{", "\\1\\\\{", p)
  if (trim.tail) 
    p <- sub(".*$", "", p, fixed = TRUE)
  if (trim.head) 
    p <- sub("^.*", "", p, fixed = TRUE)
  p
}, function (pattern, trim.head = FALSE, trim.tail = TRUE) 
{
  if (!length(pattern)) 
    return(character())
  p <- gsub(".", "\\.", paste0("^", pattern, "$"), fixed = TRUE)
  p <- gsub("?", ".", gsub("*", ".*", p, fixed = TRUE), fixed = TRUE)
  p <- gsub("([^\\])\\(", "\\1\\\\(", p)
  p <- gsub("([^\\])\\[", "\\1\\\\[", p)
  p <- gsub("([^\\])\\{", "\\1\\\\{", p)
  if (trim.tail) 
    p <- sub(".*$", "", p, fixed = TRUE)
  if (trim.head) 
    p <- sub("^.*", "", p, fixed = TRUE)
  p
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
globalVariables
list(`package:utils` = function (names, package, add = TRUE) 
  registerNames(names, package, ".__global__", add), function (names, package, add = TRUE) 
    registerNames(names, package, ".__global__", add))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
hashtab
list(`package:utils` = function (type = c("identical", "address"), size) 
{
  K <- if (missing(size)) 
    3
  else ceiling(log2(2 * size))
  type <- match.arg(type)
  .External(C_hashtab_Ext, type, K)
}, function (type = c("identical", "address"), size) 
{
  K <- if (missing(size)) 
    3
  else ceiling(log2(2 * size))
  type <- match.arg(type)
  .External(C_hashtab_Ext, type, K)
}, function (cache, ...) 
  UseMethod("hashtab"))
c("package:utils", "namespace:utils", "namespace:bit64")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
hasName
list(`package:utils` = function (x, name) 
  match(name, names(x), nomatch = 0) > 0, function (x, name) 
    match(name, names(x), nomatch = 0) > 0, function (x, name) 
    {
      match(name, names(x), nomatch = 0) > 0
    })
c("package:utils", "namespace:utils", "namespace:backports")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
head
list(`package:utils` = function (x, ...) 
  UseMethod("head"), function (x, ...) 
    UseMethod("head"), new("standardGeneric", .Data = function (x, ...) 
      standardGeneric("head"), generic = "head", package = "utils", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("head"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "head"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
          UseMethod("head"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "head"))(x, ...)))
c("package:utils", "namespace:utils", "namespace:Matrix")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
head.matrix
list(`package:utils` = function (x, n = 6, ...) 
{
  checkHT(n, d <- dim(x))
  args <- rep(alist(x, , drop = FALSE), c(1, length(d), 1))
  ii <- which(!is.na(n[seq_along(d)]))
  args[1 + ii] <- lapply(ii, function(i) seq_len(if ((ni <- n[i]) < 0) max(d[i] + ni, 0) else min(ni, d[i])))
  do.call(`[`, args)
}, function (x, n = 6, ...) 
{
  checkHT(n, d <- dim(x))
  args <- rep(alist(x, , drop = FALSE), c(1, length(d), 1))
  ii <- which(!is.na(n[seq_along(d)]))
  args[1 + ii] <- lapply(ii, function(i) seq_len(if ((ni <- n[i]) < 0) max(d[i] + ni, 0) else min(ni, d[i])))
  do.call(`[`, args)
}, function (x, n = 6, ...) 
{
  checkHT(n, d <- dim(x))
  args <- rep(alist(x, , drop = FALSE), c(1, length(d), 1))
  ii <- which(!is.na(n[seq_along(d)]))
  args[1 + ii] <- lapply(ii, function(i) seq_len(if ((ni <- n[i]) < 0) max(d[i] + ni, 0) else min(ni, d[i])))
  do.call(`[`, args)
})
c("package:utils", "registered S3 method for head from namespace utils", "namespace:utils")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
help
list(`package:utils` = function (topic, package = NULL, lib.loc = NULL, verbose = getOption("verbose"), try.all.packages = getOption("help.try.all.packages"), help_type = getOption("help_type")) 
{
  types <- c("text", "html", "pdf")
  help_type <- if (!length(help_type)) 
    "text"
  else match.arg(tolower(help_type), types)
  if (!missing(package)) 
    if (is.name(y <- substitute(package))) 
      package <- as.character(y)
  if (missing(topic)) {
    if (!is.null(package)) {
      if (interactive() && help_type == "html") {
        port <- tools::startDynamicHelp(NA)
        if (port <= 0) 
          return(library(help = package, lib.loc = lib.loc, character.only = TRUE))
        browser <- if (.Platform$GUI == "AQUA") {
          get("aqua.browser", envir = as.environment("tools:RGUI"))
        }
        else getOption("browser")
        browseURL(paste0("http://127.0.0.1:", port, "/library/", package, "/html/00Index.html"), browser)
        return(invisible())
      }
      else return(library(help = package, lib.loc = lib.loc, character.only = TRUE))
    }
    if (!is.null(lib.loc)) 
      return(library(lib.loc = lib.loc))
    topic <- "help"
    package <- "utils"
    lib.loc <- .Library
  }
  ischar <- tryCatch(is.character(topic) && length(topic) == 1, error = function(e) FALSE)
  if (!ischar) {
    reserved <- c("TRUE", "FALSE", "NULL", "Inf", "NaN", "NA", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_")
    stopic <- deparse1(substitute(topic))
    if (!is.name(substitute(topic)) && !stopic %in% reserved) 
      stop("'topic' should be a name, length-one character vector or reserved word")
    topic <- stopic
  }
  paths <- index.search(topic, find.package(if (is.null(package)) 
    loadedNamespaces()
    else package, lib.loc, verbose = verbose))
  try.all.packages <- !length(paths) && is.logical(try.all.packages) && !is.na(try.all.packages) && try.all.packages && is.null(package) && is.null(lib.loc)
  if (try.all.packages) {
    for (lib in .libPaths()) {
      packages <- .packages(TRUE, lib)
      packages <- packages[is.na(match(packages, .packages()))]
      paths <- c(paths, index.search(topic, file.path(lib, packages)))
    }
    paths <- paths[nzchar(paths)]
  }
  structure(unique(paths), call = match.call(), topic = topic, tried_all_packages = try.all.packages, type = help_type, class = "help_files_with_topic")
}, function (topic, package = NULL, lib.loc = NULL, verbose = getOption("verbose"), try.all.packages = getOption("help.try.all.packages"), help_type = getOption("help_type")) 
{
  types <- c("text", "html", "pdf")
  help_type <- if (!length(help_type)) 
    "text"
  else match.arg(tolower(help_type), types)
  if (!missing(package)) 
    if (is.name(y <- substitute(package))) 
      package <- as.character(y)
  if (missing(topic)) {
    if (!is.null(package)) {
      if (interactive() && help_type == "html") {
        port <- tools::startDynamicHelp(NA)
        if (port <= 0) 
          return(library(help = package, lib.loc = lib.loc, character.only = TRUE))
        browser <- if (.Platform$GUI == "AQUA") {
          get("aqua.browser", envir = as.environment("tools:RGUI"))
        }
        else getOption("browser")
        browseURL(paste0("http://127.0.0.1:", port, "/library/", package, "/html/00Index.html"), browser)
        return(invisible())
      }
      else return(library(help = package, lib.loc = lib.loc, character.only = TRUE))
    }
    if (!is.null(lib.loc)) 
      return(library(lib.loc = lib.loc))
    topic <- "help"
    package <- "utils"
    lib.loc <- .Library
  }
  ischar <- tryCatch(is.character(topic) && length(topic) == 1, error = function(e) FALSE)
  if (!ischar) {
    reserved <- c("TRUE", "FALSE", "NULL", "Inf", "NaN", "NA", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_")
    stopic <- deparse1(substitute(topic))
    if (!is.name(substitute(topic)) && !stopic %in% reserved) 
      stop("'topic' should be a name, length-one character vector or reserved word")
    topic <- stopic
  }
  paths <- index.search(topic, find.package(if (is.null(package)) 
    loadedNamespaces()
    else package, lib.loc, verbose = verbose))
  try.all.packages <- !length(paths) && is.logical(try.all.packages) && !is.na(try.all.packages) && try.all.packages && is.null(package) && is.null(lib.loc)
  if (try.all.packages) {
    for (lib in .libPaths()) {
      packages <- .packages(TRUE, lib)
      packages <- packages[is.na(match(packages, .packages()))]
      paths <- c(paths, index.search(topic, file.path(lib, packages)))
    }
    paths <- paths[nzchar(paths)]
  }
  structure(unique(paths), call = match.call(), topic = topic, tried_all_packages = try.all.packages, type = help_type, class = "help_files_with_topic")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
help.request
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (subject = "", address = "r-help@R-project.org", file = "R.help.request", ...) 
  {
    webpage <- "corresponding web page"
    catPlease <- function() cat("Please do this first - the", webpage, "has been loaded in your web browser\n")
    go <- function(url) {
      catPlease()
      browseURL(url)
    }
    MyWrap <- function(...) paste(paste(strwrap(paste(...)), collapse = "\n"))
    checkPkgs <- function(pkgDescs, pkgtxt = paste("packages", paste(names(pkgDescs), collapse = ", "))) {
      cat("Checking if", pkgtxt, "are up-to-date; may take some time...\n")
      stopifnot(sapply(pkgDescs, inherits, what = "packageDescription"))
      fields <- .instPkgFields(NULL)
      n <- length(pkgDescs)
      iPkgs <- matrix(NA, n, 2 + length(fields), dimnames = list(NULL, c("Package", "LibPath", fields)))
      for (i in seq_len(n)) {
        desc <- c(unlist(pkgDescs[[i]]), LibPath = dirname(dirname(dirname(attr(pkgDescs[[i]], "file")))))
        nms <- intersect(names(desc), colnames(iPkgs))
        iPkgs[i, nms] <- desc[nms]
      }
      old <- old.packages(instPkgs = iPkgs)
      if (!is.null(old)) {
        update <- askYesNo(MyWrap("The following installed packages are out-of-date:\n", paste(strwrap(rownames(old), width = 0.7 * getOption("width"), indent = 0.15 * getOption("width")), collapse = "\n"), "would you like to update now?"))
        if (is.na(update)) 
          stop("Cancelled by user")
        if (isTRUE(update)) 
          update.packages(oldPkgs = old, ask = FALSE)
      }
    }
    cat("Checklist:\n")
    post <- askYesNo("Have you read the posting guide?")
    if (!isTRUE(post)) 
      return(go("https://www.r-project.org/posting-guide.html"))
    FAQ <- askYesNo("Have you checked the FAQ?")
    if (!isTRUE(FAQ)) 
      return(go("https://cran.r-project.org/faqs.html"))
    intro <- askYesNo("Have you checked An Introduction to R?")
    if (!isTRUE(intro)) 
      return(go("https://cran.r-project.org/manuals.html"))
    NEWS <- askYesNo(MyWrap("Have you checked the NEWS of the latest development release?"))
    if (!isTRUE(NEWS)) 
      return(go("https://cran.r-project.org/doc/manuals/r-devel/NEWS.html"))
    rsitesearch <- askYesNo("Have you looked on RSiteSearch?")
    if (!isTRUE(rsitesearch)) {
      catPlease()
      return(RSiteSearch(subject))
    }
    inf <- sessionInfo()
    if ("otherPkgs" %in% names(inf)) {
      oPkgs <- names(inf$otherPkgs)
      other <- askYesNo(MyWrap("You have packages", paste0("(", paste(sQuote(oPkgs), collapse = ", "), ")"), "other than the base packages loaded. ", "If your query relates to one of these, have you ", "checked any corresponding books/manuals and", "considered contacting the package maintainer?"))
      if (!isTRUE(other)) 
        return("Please do this first.")
    }
    page <- url("https://cran.r-project.org/bin/windows/base")
    title <- try(grep("<title>", readLines(page, 10), fixed = TRUE, value = TRUE), silent = TRUE)
    if (!inherits(title, "try-error")) {
      ver <- sub("^.*R-([^ ]*) for Windows.*$", "\\1", title)
      if (getRversion() < numeric_version(ver)) {
        update <- askYesNo(MyWrap("Your R version is out-of-date,", "would you like to update now?"))
        if (is.na(update)) 
          stop("Cancelled by user")
        if (isTRUE(update)) 
          return(go(getOption("repos")))
      }
    }
    else warning("Unable to connect to CRAN to check R version.")
    if ("otherPkgs" %in% names(inf)) {
      checkPkgs(inf$otherPkgs)
    }
    code <- askYesNo(paste0("Have you written example code that is\n", " - minimal\n - reproducible\n - self-contained\n - commented", "\nusing data that is either\n", " - constructed by the code\n - loaded by data()\n", " - reproduced using dump(\"mydata\", file = \"\")\n", MyWrap("and have you checked this code in a fresh R session", "(invoking R with the --vanilla option if possible)", "and is this code copied to the clipboard?")))
    if (!isTRUE(code)) 
      return(cat("\nIf your query is not directly related to code", "(e.g. a general query \nabout R's capabilities),", "email R-help@r-project.org directly. ", "\nOtherwise prepare some example code first.\n"))
    change <- askYesNo(MyWrap("Would you like to change your subject line: ", dQuote(subject), " to something more meaningful?"))
    if (is.na(change)) 
      stop("Cancelled by user")
    if (isTRUE(change)) 
      subject <- readline("Enter subject: \n")
    create.post(instructions = paste("\\n<<SEND AS PLAIN TEXT!>>\\n\\n", "\\n<<Write your query here, using your example code to illustrate>>", "\\n<<End with your name and affiliation>>\\n\\n\\n\\n"), description = "help request", subject = subject, address = address, filename = file, info = bug.report.info(), ...)
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
help.search
list(`package:utils` = function (pattern, fields = c("alias", "concept", "title"), apropos, keyword, whatis, ignore.case = TRUE, package = NULL, lib.loc = NULL, help.db = getOption("help.db"), verbose = getOption("verbose"), rebuild = FALSE, agrep = NULL, use_UTF8 = FALSE, types = getOption("help.search.types")) 
{
  .wrong_args <- function(args) gettextf("argument %s must be a single character string", sQuote(args))
  if (is.logical(verbose)) 
    verbose <- 2 * as.integer(verbose)
  fuzzy <- agrep
  if (!missing(pattern)) {
    if (!is.character(pattern) || (length(pattern) > 1)) 
      stop(.wrong_args("pattern"), domain = NA)
    i <- pmatch(fields, hsearch_db_fields)
    if (anyNA(i)) 
      stop("incorrect field specification")
    else fields <- hsearch_db_fields[i]
  }
  else if (!missing(apropos)) {
    if (!is.character(apropos) || (length(apropos) > 1)) 
      stop(.wrong_args("apropos"), domain = NA)
    else {
      pattern <- apropos
      fields <- c("alias", "title")
    }
  }
  else if (!missing(keyword)) {
    if (!is.character(keyword) || (length(keyword) > 1)) 
      stop(.wrong_args("keyword"), domain = NA)
    else {
      pattern <- keyword
      fields <- "keyword"
      if (is.null(fuzzy)) 
        fuzzy <- FALSE
    }
  }
  else if (!missing(whatis)) {
    if (!is.character(whatis) || (length(whatis) > 1)) 
      stop(.wrong_args("whatis"), domain = NA)
    else {
      pattern <- whatis
      fields <- "alias"
    }
  }
  else {
    stop("do not know what to search")
  }
  if (!missing(help.db)) 
    warning("argument 'help.db' is deprecated")
  i <- pmatch(types, hsearch_db_types)
  if (anyNA(i)) 
    stop("incorrect type specification")
  else types <- hsearch_db_types[i]
  db <- hsearch_db(package, lib.loc, types, verbose, rebuild, use_UTF8)
  lib.loc <- attr(db, "LibPaths")
  if (!identical(sort(types), sort(attr(db, "Types")))) {
    db$Base <- db$Base[!is.na(match(db$Base$Type, types)), ]
    db[-1] <- lapply(db[-1], function(e) {
      e[!is.na(match(e$ID, db$Base$ID)), ]
    })
  }
  if (!is.null(package)) {
    pos_in_hsearch_db <- match(package, unique(db$Base[, "Package"]), nomatch = 0)
    if (any(pos_in_hsearch_db) == 0) 
      stop(gettextf("no information in the database for package %s: need 'rebuild = TRUE'?", sQuote(package[pos_in_hsearch_db == 0][1])), domain = NA)
    db[] <- lapply(db, function(e) {
      e[!is.na(match(e$Package, package)), ]
    })
  }
  if (verbose >= 2) {
    message("Database of ", NROW(db$Base), " help objects (", NROW(db$Aliases), " aliases, ", NROW(db$Concepts), " concepts, ", NROW(db$Keywords), " keywords)", domain = NA)
    flush.console()
  }
  if (!length(db$Base)) 
    return(invisible())
  if (is.null(fuzzy) || is.na(fuzzy)) 
    fuzzy <- (grepl("^([[:alnum:]]|[[:space:]]|-)+$", pattern) && (nchar(pattern, type = "c") > 4))
  if (is.logical(fuzzy)) {
    if (fuzzy) 
      max.distance <- 0.1
  }
  else if (is.numeric(fuzzy) || is.list(fuzzy)) {
    max.distance <- fuzzy
    fuzzy <- TRUE
  }
  else stop("incorrect 'agrep' specification")
  dbBase <- db$Base
  search_fun <- if (fuzzy) {
    function(x) {
      agrep(pattern, x, ignore.case = ignore.case, max.distance = max.distance)
    }
  }
  else {
    function(x) {
      grep(pattern, x, ignore.case = ignore.case, perl = use_UTF8)
    }
  }
  search_db_results <- function(p, f, e) list2DF(list(Position = p, Field = f, Entry = e))
  search_db_field <- function(field) {
    switch(field, alias = {
      aliases <- db$Aliases$Alias
      matched <- search_fun(aliases)
      search_db_results(match(db$Aliases$ID[matched], dbBase$ID), rep.int(field, length(matched)), aliases[matched])
    }, concept = {
      concepts <- db$Concepts$Concept
      matched <- search_fun(concepts)
      search_db_results(match(db$Concepts$ID[matched], dbBase$ID), rep.int(field, length(matched)), concepts[matched])
    }, keyword = {
      keywords <- db$Keywords$Keyword
      matched <- search_fun(keywords)
      search_db_results(match(db$Keywords$ID[matched], dbBase$ID), rep.int(field, length(matched)), keywords[matched])
    }, name = {
      matched <- search_fun(dbBase$Name)
      search_db_results(matched, rep.int("Name", length(matched)), dbBase$Name[matched])
    }, title = {
      matched <- search_fun(dbBase$Title)
      search_db_results(matched, rep.int("Title", length(matched)), dbBase$Title[matched])
    })
  }
  matches <- NULL
  for (f in fields) matches <- rbind(matches, search_db_field(f))
  matches <- matches[order(matches$Position), ]
  db <- cbind(dbBase[matches$Position, c("Topic", "Title", "Name", "ID", "Package", "LibPath", "Type"), drop = FALSE], matches[c("Field", "Entry")])
  rownames(db) <- NULL
  if (verbose >= 2) {
    n_of_objects_matched <- length(unique(db[, "ID"]))
    message(sprintf(ngettext(n_of_objects_matched, "matched %d object.", "matched %d objects."), n_of_objects_matched), domain = NA)
    flush.console()
  }
  y <- list(pattern = pattern, fields = fields, type = if (fuzzy) "fuzzy" else "regexp", agrep = agrep, ignore.case = ignore.case, types = types, package = package, lib.loc = lib.loc, matches = db)
  class(y) <- "hsearch"
  y
}, function (pattern, fields = c("alias", "concept", "title"), apropos, keyword, whatis, ignore.case = TRUE, package = NULL, lib.loc = NULL, help.db = getOption("help.db"), verbose = getOption("verbose"), rebuild = FALSE, agrep = NULL, use_UTF8 = FALSE, types = getOption("help.search.types")) 
{
  .wrong_args <- function(args) gettextf("argument %s must be a single character string", sQuote(args))
  if (is.logical(verbose)) 
    verbose <- 2 * as.integer(verbose)
  fuzzy <- agrep
  if (!missing(pattern)) {
    if (!is.character(pattern) || (length(pattern) > 1)) 
      stop(.wrong_args("pattern"), domain = NA)
    i <- pmatch(fields, hsearch_db_fields)
    if (anyNA(i)) 
      stop("incorrect field specification")
    else fields <- hsearch_db_fields[i]
  }
  else if (!missing(apropos)) {
    if (!is.character(apropos) || (length(apropos) > 1)) 
      stop(.wrong_args("apropos"), domain = NA)
    else {
      pattern <- apropos
      fields <- c("alias", "title")
    }
  }
  else if (!missing(keyword)) {
    if (!is.character(keyword) || (length(keyword) > 1)) 
      stop(.wrong_args("keyword"), domain = NA)
    else {
      pattern <- keyword
      fields <- "keyword"
      if (is.null(fuzzy)) 
        fuzzy <- FALSE
    }
  }
  else if (!missing(whatis)) {
    if (!is.character(whatis) || (length(whatis) > 1)) 
      stop(.wrong_args("whatis"), domain = NA)
    else {
      pattern <- whatis
      fields <- "alias"
    }
  }
  else {
    stop("do not know what to search")
  }
  if (!missing(help.db)) 
    warning("argument 'help.db' is deprecated")
  i <- pmatch(types, hsearch_db_types)
  if (anyNA(i)) 
    stop("incorrect type specification")
  else types <- hsearch_db_types[i]
  db <- hsearch_db(package, lib.loc, types, verbose, rebuild, use_UTF8)
  lib.loc <- attr(db, "LibPaths")
  if (!identical(sort(types), sort(attr(db, "Types")))) {
    db$Base <- db$Base[!is.na(match(db$Base$Type, types)), ]
    db[-1] <- lapply(db[-1], function(e) {
      e[!is.na(match(e$ID, db$Base$ID)), ]
    })
  }
  if (!is.null(package)) {
    pos_in_hsearch_db <- match(package, unique(db$Base[, "Package"]), nomatch = 0)
    if (any(pos_in_hsearch_db) == 0) 
      stop(gettextf("no information in the database for package %s: need 'rebuild = TRUE'?", sQuote(package[pos_in_hsearch_db == 0][1])), domain = NA)
    db[] <- lapply(db, function(e) {
      e[!is.na(match(e$Package, package)), ]
    })
  }
  if (verbose >= 2) {
    message("Database of ", NROW(db$Base), " help objects (", NROW(db$Aliases), " aliases, ", NROW(db$Concepts), " concepts, ", NROW(db$Keywords), " keywords)", domain = NA)
    flush.console()
  }
  if (!length(db$Base)) 
    return(invisible())
  if (is.null(fuzzy) || is.na(fuzzy)) 
    fuzzy <- (grepl("^([[:alnum:]]|[[:space:]]|-)+$", pattern) && (nchar(pattern, type = "c") > 4))
  if (is.logical(fuzzy)) {
    if (fuzzy) 
      max.distance <- 0.1
  }
  else if (is.numeric(fuzzy) || is.list(fuzzy)) {
    max.distance <- fuzzy
    fuzzy <- TRUE
  }
  else stop("incorrect 'agrep' specification")
  dbBase <- db$Base
  search_fun <- if (fuzzy) {
    function(x) {
      agrep(pattern, x, ignore.case = ignore.case, max.distance = max.distance)
    }
  }
  else {
    function(x) {
      grep(pattern, x, ignore.case = ignore.case, perl = use_UTF8)
    }
  }
  search_db_results <- function(p, f, e) list2DF(list(Position = p, Field = f, Entry = e))
  search_db_field <- function(field) {
    switch(field, alias = {
      aliases <- db$Aliases$Alias
      matched <- search_fun(aliases)
      search_db_results(match(db$Aliases$ID[matched], dbBase$ID), rep.int(field, length(matched)), aliases[matched])
    }, concept = {
      concepts <- db$Concepts$Concept
      matched <- search_fun(concepts)
      search_db_results(match(db$Concepts$ID[matched], dbBase$ID), rep.int(field, length(matched)), concepts[matched])
    }, keyword = {
      keywords <- db$Keywords$Keyword
      matched <- search_fun(keywords)
      search_db_results(match(db$Keywords$ID[matched], dbBase$ID), rep.int(field, length(matched)), keywords[matched])
    }, name = {
      matched <- search_fun(dbBase$Name)
      search_db_results(matched, rep.int("Name", length(matched)), dbBase$Name[matched])
    }, title = {
      matched <- search_fun(dbBase$Title)
      search_db_results(matched, rep.int("Title", length(matched)), dbBase$Title[matched])
    })
  }
  matches <- NULL
  for (f in fields) matches <- rbind(matches, search_db_field(f))
  matches <- matches[order(matches$Position), ]
  db <- cbind(dbBase[matches$Position, c("Topic", "Title", "Name", "ID", "Package", "LibPath", "Type"), drop = FALSE], matches[c("Field", "Entry")])
  rownames(db) <- NULL
  if (verbose >= 2) {
    n_of_objects_matched <- length(unique(db[, "ID"]))
    message(sprintf(ngettext(n_of_objects_matched, "matched %d object.", "matched %d objects."), n_of_objects_matched), domain = NA)
    flush.console()
  }
  y <- list(pattern = pattern, fields = fields, type = if (fuzzy) "fuzzy" else "regexp", agrep = agrep, ignore.case = ignore.case, types = types, package = package, lib.loc = lib.loc, matches = db)
  class(y) <- "hsearch"
  y
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
help.start
list(`package:utils` = function (update = FALSE, gui = "irrelevant", browser = getOption("browser"), remote = NULL) 
{
  WINDOWS <- .Platform$OS.type == "windows"
  if (!WINDOWS) {
    if (!is.function(browser) && (length(browser) != 1 || !is.character(browser) || !nzchar(browser))) 
      stop("invalid browser name, check options(\"browser\").")
  }
  home <- if (is.null(remote)) {
    port <- tools::startDynamicHelp(NA)
    if (port > 0) {
      if (update) 
        make.packages.html(temp = TRUE)
      paste0("http://127.0.0.1:", port)
    }
    else stop("help.start() requires the HTTP server to be running", call. = FALSE)
  }
  else remote
  url <- paste0(home, "/doc/html/index.html")
  if (WINDOWS) {
    cat(gettextf("If nothing happens, you should open\n%s yourself\n", sQuote(url)))
  }
  else if (is.character(browser)) {
    writeLines(strwrap(gettextf("If the browser launched by '%s' is already running, it is *not* restarted, and you must switch to its window.", browser), exdent = 4))
    writeLines(gettext("Otherwise, be patient ..."))
  }
  browseURL(url, browser = browser)
  invisible()
}, function (update = FALSE, gui = "irrelevant", browser = getOption("browser"), remote = NULL) 
{
  WINDOWS <- .Platform$OS.type == "windows"
  if (!WINDOWS) {
    if (!is.function(browser) && (length(browser) != 1 || !is.character(browser) || !nzchar(browser))) 
      stop("invalid browser name, check options(\"browser\").")
  }
  home <- if (is.null(remote)) {
    port <- tools::startDynamicHelp(NA)
    if (port > 0) {
      if (update) 
        make.packages.html(temp = TRUE)
      paste0("http://127.0.0.1:", port)
    }
    else stop("help.start() requires the HTTP server to be running", call. = FALSE)
  }
  else remote
  url <- paste0(home, "/doc/html/index.html")
  if (WINDOWS) {
    cat(gettextf("If nothing happens, you should open\n%s yourself\n", sQuote(url)))
  }
  else if (is.character(browser)) {
    writeLines(strwrap(gettextf("If the browser launched by '%s' is already running, it is *not* restarted, and you must switch to its window.", browser), exdent = 4))
    writeLines(gettext("Otherwise, be patient ..."))
  }
  browseURL(url, browser = browser)
  invisible()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
history
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (max.show = 25, reverse = FALSE, pattern, ...) 
  {
    file1 <- tempfile("Rrawhist")
    savehistory(file1)
    rawhist <- readLines(file1)
    unlink(file1)
    if (!missing(pattern)) 
      rawhist <- unique(grep(pattern, rawhist, value = TRUE, ...))
    nlines <- length(rawhist)
    if (nlines) {
      inds <- max(1, nlines - max.show):nlines
      if (reverse) 
        inds <- rev(inds)
    }
    else inds <- integer()
    file2 <- tempfile("hist")
    writeLines(rawhist[inds], file2)
    file.show(file2, title = "R History", delete.file = TRUE)
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
hsearch_db
list(`package:utils` = function (package = NULL, lib.loc = NULL, types = getOption("help.search.types"), verbose = getOption("verbose"), rebuild = FALSE, use_UTF8 = FALSE) 
{
  WINDOWS <- .Platform$OS.type == "windows"
  if (is.logical(verbose)) 
    verbose <- 2 * as.integer(verbose)
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  i <- pmatch(types, hsearch_db_types)
  if (anyNA(i)) 
    stop("incorrect type specification")
  else types <- hsearch_db_types[i]
  db <- eval(.hsearch_db())
  if (is.null(db)) 
    rebuild <- TRUE
  else if (!rebuild) {
    if (!identical(lib.loc, attr(db, "LibPaths")) || anyNA(match(types, attr(db, "Types"))) || any(attr(db, "mtime") < file.mtime(lib.loc[file.exists(lib.loc)])) || !identical(attr(db, "ctype"), Sys.getlocale("LC_CTYPE"))) 
      rebuild <- TRUE
    if (!is.null(package) && any(is.na(match(package, db$Base[, "Package"])))) 
      rebuild <- TRUE
  }
  if (rebuild) {
    if (verbose > 0) {
      message("Rebuilding the help.search() database", " ", "...", if (verbose > 1) 
        "...", domain = NA)
      flush.console()
    }
    want_type_help <- any(types == "help")
    want_type_demo <- any(types == "demo")
    want_type_vignette <- any(types == "vignette")
    if (!is.null(package)) {
      packages_in_hsearch_db <- package
      package_paths <- NULL
    }
    else {
      ans <- character(0)
      paths <- character(0)
      lib.loc <- lib.loc[file.exists(lib.loc)]
      valid_package_version_regexp <- .standard_regexps()$valid_package_version
      for (lib in lib.loc) {
        a <- list.files(lib, all.files = FALSE, full.names = FALSE)
        for (nam in a) {
          pfile <- file.path(lib, nam, "Meta", "package.rds")
          if (file.exists(pfile)) 
            info <- readRDS(pfile)$DESCRIPTION[c("Package", "Version")]
          else next
          if ((length(info) != 2) || anyNA(info)) 
            next
          if (!grepl(valid_package_version_regexp, info["Version"])) 
            next
          ans <- c(ans, nam)
          paths <- c(paths, file.path(lib, nam))
        }
      }
      un <- !duplicated(ans)
      packages_in_hsearch_db <- ans[un]
      package_paths <- paths[un]
      names(package_paths) <- ans[un]
    }
    np <- 0
    if (verbose >= 2) {
      message("Packages {readRDS() sequentially}:", domain = NA)
      flush.console()
    }
    tot <- length(package_paths)
    incr <- 0
    if (verbose && WINDOWS) {
      pb <- winProgressBar("R: creating the help.search() DB", max = tot)
      on.exit(close(pb))
    }
    else if (verbose == 1) 
      incr <- ifelse(tot > 500, 100, 10)
    dbMat <- vector("list", length(packages_in_hsearch_db) * 4)
    dim(dbMat) <- c(length(packages_in_hsearch_db), 4)
    hDB0 <- tools:::.build_hsearch_index(NULL)
    for (p in packages_in_hsearch_db) {
      if (incr && np%%incr == 0) {
        message(".", appendLF = FALSE, domain = NA)
        flush.console()
      }
      np <- np + 1
      if (verbose && WINDOWS) 
        setWinProgressBar(pb, np)
      if (verbose >= 2) {
        message(" ", p, appendLF = ((np%%5) == 0), domain = NA)
        flush.console()
      }
      path <- if (!is.null(package_paths)) 
        package_paths[p]
      else find.package(p, lib.loc, quiet = TRUE)
      if (length(path) == 0) {
        if (is.null(package)) 
          next
        else stop(packageNotFoundError(p, lib.loc, sys.call()))
      }
      hDB <- NULL
      if (want_type_help) {
        if (file.exists(hs_file <- file.path(path, "Meta", "hsearch.rds"))) {
          hDB <- readRDS(hs_file)
          if (!is.null(hDB)) {
            if (is.na(match("Encoding", colnames(hDB[[1]])))) 
              hDB[[1]] <- cbind(hDB[[1]], Encoding = "")
            for (i in seq_along(hDB)) {
              colnames(hDB[[i]]) <- tools:::hsearch_index_colnames[[i]]
            }
          }
          else if (verbose >= 2) {
            message(gettextf("package %s has empty hsearch data - strangely", sQuote(p)), domain = NA)
            flush.console()
          }
        }
        else if (!is.null(package)) 
          warning("no hsearch.rds meta data for package ", p, domain = NA)
      }
      if (is.null(hDB)) 
        hDB <- hDB0
      nh <- NROW(hDB[[1]])
      hDB[[1]] <- cbind(hDB[[1]], Type = rep.int("help", nh))
      if (nh) 
        hDB[[1]][, "LibPath"] <- path
      if (want_type_vignette) 
        hDB <- merge_vignette_index(hDB, path, p)
      if (want_type_demo) 
        hDB <- merge_demo_index(hDB, path, p)
      dbMat[np, seq_along(hDB)] <- hDB
    }
    if (verbose >= 2) {
      message(ifelse(np%%5 == 0, "\n", "\n\n"), sprintf("Built dbMat[%d,%d]", nrow(dbMat), ncol(dbMat)), domain = NA)
      flush.console()
    }
    db <- list(Base = do.call(rbind, dbMat[, 1]), Aliases = do.call(rbind, dbMat[, 2]), Keywords = do.call(rbind, dbMat[, 3]), Concepts = do.call(rbind, dbMat[, 4]))
    rownames(db$Base) <- NULL
    if (is.null(db$Concepts)) {
      db$Concepts <- matrix(character(), ncol = 3, dimnames = list(NULL, tools:::hsearch_index_colnames$Concepts))
    }
    for (i in which(vapply(db, NROW, 0) > 0)) {
      db[[i]][, "ID"] <- paste(rep.int(seq_along(packages_in_hsearch_db), vapply(dbMat[, i], NROW, 0)), db[[i]][, "ID"], sep = "/")
    }
    if (!identical(Sys.getlocale("LC_CTYPE"), "C")) {
      if (verbose >= 2) {
        message("reencoding ...", appendLF = FALSE, domain = NA)
        flush.console()
      }
      encoding <- db$Base[, "Encoding"]
      target <- ifelse(use_UTF8 && !l10n_info()$`UTF-8`, "UTF-8", "")
      for (enc in unique(encoding)) {
        if (enc != target) 
          next
        IDs <- db$Base[encoding == enc, "ID"]
        for (i in seq_along(db)) {
          ind <- db[[i]][, "ID"] %in% IDs
          db[[i]][ind, ] <- iconv(db[[i]][ind, ], enc, "")
        }
      }
      if (verbose >= 2) {
        message(" ", "done", domain = NA)
        flush.console()
      }
    }
    bad_IDs <- unlist(lapply(db, function(u) u[rowSums(is.na(nchar(u, "chars", allowNA = TRUE, keepNA = FALSE))) > 0, "ID"]))
    if (length(bad_IDs)) {
      for (i in seq_along(db)) {
        ind <- db[[i]][, "ID"] %in% bad_IDs
        db[[i]][ind, ] <- iconv(db[[i]][ind, ], "latin1", "")
      }
      bad_IDs <- unlist(lapply(db, function(u) u[rowSums(is.na(nchar(u, "chars", allowNA = TRUE, keepNA = FALSE))) > 0, "ID"]))
    }
    if (length(bad_IDs)) {
      warning("removing all entries with invalid multi-byte character data")
      for (i in seq_along(db)) {
        ind <- db[[i]][, "ID"] %in% bad_IDs
        db[[i]] <- db[[i]][!ind, , drop = FALSE]
      }
    }
    bad_IDs <- db$Base[is.na(db$Base[, "Topic"]), "ID"]
    if (length(bad_IDs)) {
      for (i in seq_along(db)) {
        ind <- db[[i]][, "ID"] %in% bad_IDs
        db[[i]] <- db[[i]][!ind, , drop = FALSE]
      }
    }
    ind <- nzchar(db$Keywords[, "Keyword"])
    db$Keywords <- db$Keywords[ind, , drop = FALSE]
    ind <- nzchar(db$Concepts[, "Concept"])
    db$Concepts <- db$Concepts[ind, , drop = FALSE]
    standard <- .get_standard_Rd_keywords_with_descriptions()
    keywords <- standard$Keywords
    concepts <- standard$Descriptions
    pos <- match(db$Keywords[, "Keyword"], keywords)
    ind <- !is.na(pos) & (keywords[pos] != "internal")
    db$Concepts <- rbind(db$Concepts, db$Keywords[is.na(pos), , drop = FALSE], cbind(concepts[pos[ind]], db$Keywords[ind, -1, drop = FALSE]))
    db$Keywords <- db$Keywords[!is.na(pos), , drop = FALSE]
    db <- lapply(db, as.data.frame, stringsAsFactors = FALSE, row.names = NULL)
    if (verbose >= 2) {
      message("saving the database ...", appendLF = FALSE, domain = NA)
      flush.console()
    }
    attr(db, "LibPaths") <- lib.loc
    attr(db, "mtime") <- Sys.time()
    attr(db, "ctype") <- Sys.getlocale("LC_CTYPE")
    attr(db, "Types") <- unique(c("help", types))
    class(db) <- "hsearch_db"
    .hsearch_db(db)
    if (verbose >= 2) {
      message(" ", "done", domain = NA)
      flush.console()
    }
    if (verbose > 0) {
      message("... database rebuilt", domain = NA)
      if (WINDOWS) {
        close(pb)
        on.exit()
      }
      flush.console()
    }
  }
  db
}, function (package = NULL, lib.loc = NULL, types = getOption("help.search.types"), verbose = getOption("verbose"), rebuild = FALSE, use_UTF8 = FALSE) 
{
  WINDOWS <- .Platform$OS.type == "windows"
  if (is.logical(verbose)) 
    verbose <- 2 * as.integer(verbose)
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  i <- pmatch(types, hsearch_db_types)
  if (anyNA(i)) 
    stop("incorrect type specification")
  else types <- hsearch_db_types[i]
  db <- eval(.hsearch_db())
  if (is.null(db)) 
    rebuild <- TRUE
  else if (!rebuild) {
    if (!identical(lib.loc, attr(db, "LibPaths")) || anyNA(match(types, attr(db, "Types"))) || any(attr(db, "mtime") < file.mtime(lib.loc[file.exists(lib.loc)])) || !identical(attr(db, "ctype"), Sys.getlocale("LC_CTYPE"))) 
      rebuild <- TRUE
    if (!is.null(package) && any(is.na(match(package, db$Base[, "Package"])))) 
      rebuild <- TRUE
  }
  if (rebuild) {
    if (verbose > 0) {
      message("Rebuilding the help.search() database", " ", "...", if (verbose > 1) 
        "...", domain = NA)
      flush.console()
    }
    want_type_help <- any(types == "help")
    want_type_demo <- any(types == "demo")
    want_type_vignette <- any(types == "vignette")
    if (!is.null(package)) {
      packages_in_hsearch_db <- package
      package_paths <- NULL
    }
    else {
      ans <- character(0)
      paths <- character(0)
      lib.loc <- lib.loc[file.exists(lib.loc)]
      valid_package_version_regexp <- .standard_regexps()$valid_package_version
      for (lib in lib.loc) {
        a <- list.files(lib, all.files = FALSE, full.names = FALSE)
        for (nam in a) {
          pfile <- file.path(lib, nam, "Meta", "package.rds")
          if (file.exists(pfile)) 
            info <- readRDS(pfile)$DESCRIPTION[c("Package", "Version")]
          else next
          if ((length(info) != 2) || anyNA(info)) 
            next
          if (!grepl(valid_package_version_regexp, info["Version"])) 
            next
          ans <- c(ans, nam)
          paths <- c(paths, file.path(lib, nam))
        }
      }
      un <- !duplicated(ans)
      packages_in_hsearch_db <- ans[un]
      package_paths <- paths[un]
      names(package_paths) <- ans[un]
    }
    np <- 0
    if (verbose >= 2) {
      message("Packages {readRDS() sequentially}:", domain = NA)
      flush.console()
    }
    tot <- length(package_paths)
    incr <- 0
    if (verbose && WINDOWS) {
      pb <- winProgressBar("R: creating the help.search() DB", max = tot)
      on.exit(close(pb))
    }
    else if (verbose == 1) 
      incr <- ifelse(tot > 500, 100, 10)
    dbMat <- vector("list", length(packages_in_hsearch_db) * 4)
    dim(dbMat) <- c(length(packages_in_hsearch_db), 4)
    hDB0 <- tools:::.build_hsearch_index(NULL)
    for (p in packages_in_hsearch_db) {
      if (incr && np%%incr == 0) {
        message(".", appendLF = FALSE, domain = NA)
        flush.console()
      }
      np <- np + 1
      if (verbose && WINDOWS) 
        setWinProgressBar(pb, np)
      if (verbose >= 2) {
        message(" ", p, appendLF = ((np%%5) == 0), domain = NA)
        flush.console()
      }
      path <- if (!is.null(package_paths)) 
        package_paths[p]
      else find.package(p, lib.loc, quiet = TRUE)
      if (length(path) == 0) {
        if (is.null(package)) 
          next
        else stop(packageNotFoundError(p, lib.loc, sys.call()))
      }
      hDB <- NULL
      if (want_type_help) {
        if (file.exists(hs_file <- file.path(path, "Meta", "hsearch.rds"))) {
          hDB <- readRDS(hs_file)
          if (!is.null(hDB)) {
            if (is.na(match("Encoding", colnames(hDB[[1]])))) 
              hDB[[1]] <- cbind(hDB[[1]], Encoding = "")
            for (i in seq_along(hDB)) {
              colnames(hDB[[i]]) <- tools:::hsearch_index_colnames[[i]]
            }
          }
          else if (verbose >= 2) {
            message(gettextf("package %s has empty hsearch data - strangely", sQuote(p)), domain = NA)
            flush.console()
          }
        }
        else if (!is.null(package)) 
          warning("no hsearch.rds meta data for package ", p, domain = NA)
      }
      if (is.null(hDB)) 
        hDB <- hDB0
      nh <- NROW(hDB[[1]])
      hDB[[1]] <- cbind(hDB[[1]], Type = rep.int("help", nh))
      if (nh) 
        hDB[[1]][, "LibPath"] <- path
      if (want_type_vignette) 
        hDB <- merge_vignette_index(hDB, path, p)
      if (want_type_demo) 
        hDB <- merge_demo_index(hDB, path, p)
      dbMat[np, seq_along(hDB)] <- hDB
    }
    if (verbose >= 2) {
      message(ifelse(np%%5 == 0, "\n", "\n\n"), sprintf("Built dbMat[%d,%d]", nrow(dbMat), ncol(dbMat)), domain = NA)
      flush.console()
    }
    db <- list(Base = do.call(rbind, dbMat[, 1]), Aliases = do.call(rbind, dbMat[, 2]), Keywords = do.call(rbind, dbMat[, 3]), Concepts = do.call(rbind, dbMat[, 4]))
    rownames(db$Base) <- NULL
    if (is.null(db$Concepts)) {
      db$Concepts <- matrix(character(), ncol = 3, dimnames = list(NULL, tools:::hsearch_index_colnames$Concepts))
    }
    for (i in which(vapply(db, NROW, 0) > 0)) {
      db[[i]][, "ID"] <- paste(rep.int(seq_along(packages_in_hsearch_db), vapply(dbMat[, i], NROW, 0)), db[[i]][, "ID"], sep = "/")
    }
    if (!identical(Sys.getlocale("LC_CTYPE"), "C")) {
      if (verbose >= 2) {
        message("reencoding ...", appendLF = FALSE, domain = NA)
        flush.console()
      }
      encoding <- db$Base[, "Encoding"]
      target <- ifelse(use_UTF8 && !l10n_info()$`UTF-8`, "UTF-8", "")
      for (enc in unique(encoding)) {
        if (enc != target) 
          next
        IDs <- db$Base[encoding == enc, "ID"]
        for (i in seq_along(db)) {
          ind <- db[[i]][, "ID"] %in% IDs
          db[[i]][ind, ] <- iconv(db[[i]][ind, ], enc, "")
        }
      }
      if (verbose >= 2) {
        message(" ", "done", domain = NA)
        flush.console()
      }
    }
    bad_IDs <- unlist(lapply(db, function(u) u[rowSums(is.na(nchar(u, "chars", allowNA = TRUE, keepNA = FALSE))) > 0, "ID"]))
    if (length(bad_IDs)) {
      for (i in seq_along(db)) {
        ind <- db[[i]][, "ID"] %in% bad_IDs
        db[[i]][ind, ] <- iconv(db[[i]][ind, ], "latin1", "")
      }
      bad_IDs <- unlist(lapply(db, function(u) u[rowSums(is.na(nchar(u, "chars", allowNA = TRUE, keepNA = FALSE))) > 0, "ID"]))
    }
    if (length(bad_IDs)) {
      warning("removing all entries with invalid multi-byte character data")
      for (i in seq_along(db)) {
        ind <- db[[i]][, "ID"] %in% bad_IDs
        db[[i]] <- db[[i]][!ind, , drop = FALSE]
      }
    }
    bad_IDs <- db$Base[is.na(db$Base[, "Topic"]), "ID"]
    if (length(bad_IDs)) {
      for (i in seq_along(db)) {
        ind <- db[[i]][, "ID"] %in% bad_IDs
        db[[i]] <- db[[i]][!ind, , drop = FALSE]
      }
    }
    ind <- nzchar(db$Keywords[, "Keyword"])
    db$Keywords <- db$Keywords[ind, , drop = FALSE]
    ind <- nzchar(db$Concepts[, "Concept"])
    db$Concepts <- db$Concepts[ind, , drop = FALSE]
    standard <- .get_standard_Rd_keywords_with_descriptions()
    keywords <- standard$Keywords
    concepts <- standard$Descriptions
    pos <- match(db$Keywords[, "Keyword"], keywords)
    ind <- !is.na(pos) & (keywords[pos] != "internal")
    db$Concepts <- rbind(db$Concepts, db$Keywords[is.na(pos), , drop = FALSE], cbind(concepts[pos[ind]], db$Keywords[ind, -1, drop = FALSE]))
    db$Keywords <- db$Keywords[!is.na(pos), , drop = FALSE]
    db <- lapply(db, as.data.frame, stringsAsFactors = FALSE, row.names = NULL)
    if (verbose >= 2) {
      message("saving the database ...", appendLF = FALSE, domain = NA)
      flush.console()
    }
    attr(db, "LibPaths") <- lib.loc
    attr(db, "mtime") <- Sys.time()
    attr(db, "ctype") <- Sys.getlocale("LC_CTYPE")
    attr(db, "Types") <- unique(c("help", types))
    class(db) <- "hsearch_db"
    .hsearch_db(db)
    if (verbose >= 2) {
      message(" ", "done", domain = NA)
      flush.console()
    }
    if (verbose > 0) {
      message("... database rebuilt", domain = NA)
      if (WINDOWS) {
        close(pb)
        on.exit()
      }
      flush.console()
    }
  }
  db
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
hsearch_db_concepts
list(`package:utils` = function (db = hsearch_db()) 
{
  pos <- match(db$Concepts[, "ID"], db$Base[, "ID"])
  entries <- split(as.data.frame(db$Base[pos, ], stringsAsFactors = FALSE), db$Concepts[, "Concept"])
  enums <- vapply(entries, NROW, 0)
  pnums <- vapply(entries, function(e) length(unique(e$Package)), 0)
  pos <- order(enums, pnums, decreasing = TRUE)
  list2DF(list(Concept = names(entries)[pos], Frequency = enums[pos], Packages = pnums[pos]))
}, function (db = hsearch_db()) 
{
  pos <- match(db$Concepts[, "ID"], db$Base[, "ID"])
  entries <- split(as.data.frame(db$Base[pos, ], stringsAsFactors = FALSE), db$Concepts[, "Concept"])
  enums <- vapply(entries, NROW, 0)
  pnums <- vapply(entries, function(e) length(unique(e$Package)), 0)
  pos <- order(enums, pnums, decreasing = TRUE)
  list2DF(list(Concept = names(entries)[pos], Frequency = enums[pos], Packages = pnums[pos]))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
hsearch_db_keywords
list(`package:utils` = function (db = hsearch_db()) 
{
  pos <- match(db$Keywords[, "ID"], db$Base[, "ID"])
  entries <- split(as.data.frame(db$Base[pos, ], stringsAsFactors = FALSE), db$Keywords[, "Keyword"])
  enums <- vapply(entries, NROW, 0)
  pnums <- vapply(entries, function(e) length(unique(e$Package)), 0)
  standard <- .get_standard_Rd_keywords_with_descriptions()
  concepts <- standard$Descriptions[match(names(entries), standard$Keywords)]
  pos <- order(enums, pnums, decreasing = TRUE)
  list2DF(list(Keyword = names(entries)[pos], Concept = concepts[pos], Frequency = enums[pos], Packages = pnums[pos]))
}, function (db = hsearch_db()) 
{
  pos <- match(db$Keywords[, "ID"], db$Base[, "ID"])
  entries <- split(as.data.frame(db$Base[pos, ], stringsAsFactors = FALSE), db$Keywords[, "Keyword"])
  enums <- vapply(entries, NROW, 0)
  pnums <- vapply(entries, function(e) length(unique(e$Package)), 0)
  standard <- .get_standard_Rd_keywords_with_descriptions()
  concepts <- standard$Descriptions[match(names(entries), standard$Keywords)]
  pos <- order(enums, pnums, decreasing = TRUE)
  list2DF(list(Keyword = names(entries)[pos], Concept = concepts[pos], Frequency = enums[pos], Packages = pnums[pos]))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
install.packages
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (pkgs, lib, repos = getOption("repos"), contriburl = contrib.url(repos, type), method, available = NULL, destdir = NULL, dependencies = NA, type = getOption("pkgType"), configure.args = getOption("configure.args"), configure.vars = getOption("configure.vars"), clean = FALSE, Ncpus = getOption("Ncpus", 1), verbose = getOption("verbose"), libs_only = FALSE, INSTALL_opts, quiet = FALSE, keep_outputs = FALSE, ...) 
  {
    if (!is.character(type)) 
      stop("invalid 'type'; must be a character string")
    type2 <- .Platform$pkgType
    if (type == "binary") {
      if (type2 == "source") 
        stop("type 'binary' is not supported on this platform")
      else type <- type2
      if (type == "both" && (!missing(contriburl) || !is.null(available))) 
        stop("specifying 'contriburl' or 'available' requires a single type, not type = \"both\"")
    }
    if (is.logical(clean) && clean) 
      clean <- "--clean"
    if (is.logical(dependencies) && is.na(dependencies)) 
      dependencies <- if (!missing(lib) && length(lib) > 1) 
        FALSE
    else c("Depends", "Imports", "LinkingTo")
    get_package_name <- function(pkg) {
      gsub("_[.](zip|tar[.]gz|tar[.]bzip2|tar[.]xz)", "", gsub(.standard_regexps()$valid_package_version, "", basename(pkg)))
    }
    getConfigureArgs <- function(pkg) {
      if (.Platform$OS.type == "windows") 
        return(character())
      if (length(pkgs) == 1 && length(configure.args) && length(names(configure.args)) == 0) 
        return(paste0("--configure-args=", shQuote(paste(configure.args, collapse = " "))))
      pkg <- get_package_name(pkg)
      if (length(configure.args) && length(names(configure.args)) && pkg %in% names(configure.args)) 
        config <- paste0("--configure-args=", shQuote(paste(configure.args[[pkg]], collapse = " ")))
      else config <- character()
      config
    }
    getConfigureVars <- function(pkg) {
      if (.Platform$OS.type == "windows") 
        return(character())
      if (length(pkgs) == 1 && length(configure.vars) && length(names(configure.vars)) == 0) 
        return(paste0("--configure-vars=", shQuote(paste(configure.vars, collapse = " "))))
      pkg <- get_package_name(pkg)
      if (length(configure.vars) && length(names(configure.vars)) && pkg %in% names(configure.vars)) 
        config <- paste0("--configure-vars=", shQuote(paste(configure.vars[[pkg]], collapse = " ")))
      else config <- character()
      config
    }
    get_install_opts <- function(pkg) {
      if (!length(INSTALL_opts)) 
        character()
      else paste(INSTALL_opts[[get_package_name(pkg)]], collapse = " ")
    }
    if (missing(pkgs)) {
      if (!interactive()) 
        stop("no packages were specified")
      if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA" || (capabilities("tcltk") && capabilities("X11") && suppressWarnings(tcltk::.TkUp))) {
      }
      else stop("no packages were specified")
      if (is.null(available)) {
        av <- available.packages(contriburl = contriburl, method = method, ...)
        if (missing(repos)) 
          repos <- getOption("repos")
        if (type != "both") 
          available <- av
      }
      else av <- available
      if (NROW(av)) {
        pkgs <- select.list(sort(unique(rownames(av))), multiple = TRUE, title = "Packages", graphics = TRUE)
      }
    }
    if (.Platform$OS.type == "windows" && length(pkgs)) {
      pkgnames <- get_package_name(pkgs)
      inuse <- search()
      inuse <- sub("^package:", "", inuse[grep("^package:", inuse)])
      inuse <- pkgnames %in% inuse
      if (any(inuse)) {
        warning(sprintf(ngettext(sum(inuse), "package %s is in use and will not be installed", "packages %s are in use and will not be installed"), paste(sQuote(pkgnames[inuse]), collapse = ", ")), call. = FALSE, domain = NA, immediate. = TRUE)
        pkgs <- pkgs[!inuse]
      }
    }
    if (!length(pkgs)) 
      return(invisible())
    if (missing(lib) || is.null(lib)) {
      lib <- .libPaths()[1]
      if (!quiet && length(.libPaths()) > 1) 
        message(sprintf(ngettext(length(pkgs), "Installing package into %s\n(as %s is unspecified)", "Installing packages into %s\n(as %s is unspecified)"), sQuote(lib), sQuote("lib")), domain = NA)
    }
    ok <- dir.exists(lib) & (file.access(lib, 2) == 0)
    if (length(lib) > 1 && any(!ok)) 
      stop(sprintf(ngettext(sum(!ok), "'lib' element %s is not a writable directory", "'lib' elements %s are not writable directories"), paste(sQuote(lib[!ok]), collapse = ", ")), domain = NA)
    if (length(lib) == 1 && .Platform$OS.type == "windows") {
      ok <- dir.exists(lib)
      if (ok) {
        fn <- file.path(lib, paste0("_test_dir_", Sys.getpid()))
        unlink(fn, recursive = TRUE)
        res <- try(dir.create(fn, showWarnings = FALSE))
        if (inherits(res, "try-error") || !res) 
          ok <- FALSE
        else unlink(fn, recursive = TRUE)
      }
    }
    if (length(lib) == 1 && !ok) {
      warning(gettextf("'lib = \"%s\"' is not writable", lib), domain = NA, immediate. = TRUE)
      userdir <- unlist(strsplit(Sys.getenv("R_LIBS_USER"), .Platform$path.sep))[1]
      if (interactive()) {
        ans <- askYesNo(gettext("Would you like to use a personal library instead?"), default = FALSE)
        if (!isTRUE(ans)) 
          stop("unable to install packages")
        lib <- userdir
        if (!file.exists(userdir)) {
          ans <- askYesNo(gettextf("Would you like to create a personal library\n%s\nto install packages into?", sQuote(userdir)), default = FALSE)
          if (!isTRUE(ans)) 
            stop("unable to install packages")
          if (!dir.create(userdir, recursive = TRUE)) 
            stop(gettextf("unable to create %s", sQuote(userdir)), domain = NA)
          .libPaths(c(userdir, .libPaths()))
        }
      }
      else stop("unable to install packages")
    }
    lib <- normalizePath(lib)
    if (length(pkgs) == 1 && missing(repos) && missing(contriburl)) {
      if ((type == "source" && any(grepl("[.]tar[.](gz|bz2|xz)$", pkgs))) || (type %in% "win.binary" && endsWith(pkgs, ".zip")) || (startsWith(type, "mac.binary") && endsWith(pkgs, ".tgz"))) {
        repos <- NULL
        message("inferring 'repos = NULL' from 'pkgs'")
      }
      if (type == "both") {
        if (type2 %in% "win.binary" && endsWith(pkgs, ".zip")) {
          repos <- NULL
          type <- type2
          message("inferring 'repos = NULL' from 'pkgs'")
        }
        else if (startsWith(type2, "mac.binary") && endsWith(pkgs, ".tgz")) {
          repos <- NULL
          type <- type2
          message("inferring 'repos = NULL' from 'pkgs'")
        }
        else if (grepl("[.]tar[.](gz|bz2|xz)$", pkgs)) {
          repos <- NULL
          type <- "source"
          message("inferring 'repos = NULL' from 'pkgs'")
        }
      }
    }
    if (length(pkgs) == 1 && is.null(repos) && type == "both") {
      if ((type2 %in% "win.binary" && endsWith(pkgs, ".zip")) || (startsWith(type2, "mac.binary") && endsWith(pkgs, ".tgz"))) {
        type <- type2
      }
      else if (grepl("[.]tar[.](gz|bz2|xz)$", pkgs)) {
        type <- "source"
      }
    }
    if (is.null(repos) && missing(contriburl)) {
      tmpd <- destdir
      nonlocalrepos <- any(web <- grepl("^(http|https|ftp)://", pkgs))
      if (is.null(destdir) && nonlocalrepos) {
        tmpd <- file.path(tempdir(), "downloaded_packages")
        if (!file.exists(tmpd) && !dir.create(tmpd)) 
          stop(gettextf("unable to create temporary directory %s", sQuote(tmpd)), domain = NA)
      }
      if (nonlocalrepos) {
        df <- function(p, destfile, method, ...) download.file(p, destfile, method, mode = "wb", ...)
        urls <- pkgs[web]
        for (p in unique(urls)) {
          this <- pkgs == p
          destfile <- file.path(tmpd, basename(p))
          res <- try(df(p, destfile, method, ...))
          if (!inherits(res, "try-error") && res == 0) 
            pkgs[this] <- destfile
          else {
            pkgs[this] <- NA
          }
        }
      }
    }
    if (type == "both") {
      if (type2 == "source") 
        stop("type == \"both\" can only be used on Windows or a CRAN build for macOS")
      if (!missing(contriburl) || !is.null(available)) 
        type <- type2
    }
    getDeps <- TRUE
    if (type == "both") {
      if (is.null(repos)) 
        stop("type == \"both\" cannot be used with 'repos = NULL'")
      type <- "source"
      contriburl <- contrib.url(repos, "source")
      if (missing(repos)) 
        repos <- getOption("repos")
      available <- available.packages(contriburl = contriburl, method = method, fields = "NeedsCompilation", ...)
      pkgs <- getDependencies(pkgs, dependencies, available, lib, ...)
      getDeps <- FALSE
      av2 <- available.packages(contriburl = contrib.url(repos, type2), method = method, ...)
      bins <- row.names(av2)
      bins <- pkgs[pkgs %in% bins]
      srcOnly <- pkgs[!pkgs %in% bins]
      binvers <- av2[bins, "Version"]
      hasArchs <- !is.na(av2[bins, "Archs"])
      needsCmp <- !(available[bins, "NeedsCompilation"] %in% "no")
      hasSrc <- hasArchs | needsCmp
      srcvers <- available[bins, "Version"]
      later <- as.numeric_version(binvers) < srcvers
      action <- getOption("install.packages.compile.from.source", "interactive")
      if (!nzchar(Sys.which(Sys.getenv("MAKE", "make")))) 
        action <- "never"
      if (any(later)) {
        msg <- ngettext(sum(later), "There is a binary version available but the source version is later", "There are binary versions available but the source versions are later")
        cat("\n", paste(strwrap(msg, indent = 2, exdent = 2), collapse = "\n"), ":\n", sep = "")
        out <- data.frame(binary = binvers, source = srcvers, needs_compilation = hasSrc, row.names = bins, check.names = FALSE)[later, ]
        print(out)
        cat("\n")
        if (any(later & hasSrc)) {
          if (action == "interactive" && interactive()) {
            msg <- ngettext(sum(later & hasSrc), "Do you want to install from sources the package which needs compilation?", "Do you want to install from sources the packages which need compilation?")
            res <- askYesNo(msg)
            if (is.na(res)) 
              stop("Cancelled by user")
            if (!isTRUE(res)) 
              later <- later & !hasSrc
          }
          else if (action == "never") {
            cat("  Binaries will be installed\n")
            later <- later & !hasSrc
          }
        }
      }
      bins <- bins[!later]
      if (length(srcOnly)) {
        s2 <- srcOnly[!(available[srcOnly, "NeedsCompilation"] %in% "no")]
        if (length(s2)) {
          msg <- ngettext(length(s2), "Package which is only available in source form, and may need compilation of C/C++/Fortran", "Packages which are only available in source form, and may need compilation of C/C++/Fortran")
          msg <- c(paste0(msg, ": "), sQuote(s2))
          msg <- strwrap(paste(msg, collapse = " "), exdent = 2)
          message(paste(msg, collapse = "\n"), domain = NA)
          if (action == "interactive" && interactive()) {
            res <- askYesNo("Do you want to attempt to install these from sources?")
            if (is.na(res)) 
              stop("Cancelled by user")
            if (!isTRUE(res)) 
              pkgs <- setdiff(pkgs, s2)
          }
          else if (action == "never") {
            cat("  These will not be installed\n")
            pkgs <- setdiff(pkgs, s2)
          }
        }
      }
      if (length(bins)) {
        if (type2 == "win.binary") 
          .install.winbinary(pkgs = bins, lib = lib, contriburl = contrib.url(repos, type2), method = method, available = av2, destdir = destdir, dependencies = NULL, libs_only = libs_only, quiet = quiet, ...)
        else .install.macbinary(pkgs = bins, lib = lib, contriburl = contrib.url(repos, type2), method = method, available = av2, destdir = destdir, dependencies = NULL, quiet = quiet, ...)
      }
      pkgs <- setdiff(pkgs, bins)
      if (!length(pkgs)) 
        return(invisible())
      message(sprintf(ngettext(length(pkgs), "installing the source package %s", "installing the source packages %s"), paste(sQuote(pkgs), collapse = ", ")), "\n", domain = NA)
      flush.console()
    }
    else if (getOption("install.packages.check.source", "yes") %in% "yes" && (type %in% "win.binary" || startsWith(type, "mac.binary"))) {
      if (missing(contriburl) && is.null(available) && !is.null(repos)) {
        contriburl2 <- contrib.url(repos, "source")
        if (missing(repos)) 
          repos <- getOption("repos")
        av1 <- tryCatch(suppressWarnings(available.packages(contriburl = contriburl2, method = method, ...)), error = function(e) e)
        if (inherits(av1, "error")) {
          message("source repository is unavailable to check versions")
          available <- available.packages(contriburl = contrib.url(repos, type), method = method, ...)
        }
        else {
          srcpkgs <- pkgs[pkgs %in% row.names(av1)]
          available <- available.packages(contriburl = contrib.url(repos, type), method = method, ...)
          bins <- pkgs[pkgs %in% row.names(available)]
          na <- srcpkgs[!srcpkgs %in% bins]
          if (length(na)) {
            msg <- sprintf(ngettext(length(na), "package %s is available as a source package but not as a binary", "packages %s are available as source packages but not as binaries"), paste(sQuote(na), collapse = ", "))
            cat("\n   ", msg, "\n\n", sep = "")
          }
          binvers <- available[bins, "Version"]
          srcvers <- binvers
          OK <- bins %in% srcpkgs
          srcvers[OK] <- av1[bins[OK], "Version"]
          later <- as.numeric_version(binvers) < srcvers
          if (any(later)) {
            msg <- ngettext(sum(later), "There is a binary version available (and will be installed) but the source version is later", "There are binary versions available (and will be installed) but the source versions are later")
            cat("\n", paste(strwrap(msg, indent = 2, exdent = 2), collapse = "\n"), ":\n", sep = "")
            print(data.frame(binary = binvers, source = srcvers, row.names = bins, check.names = FALSE)[later, ])
            cat("\n")
          }
        }
      }
    }
    if (.Platform$OS.type == "windows") {
      if (startsWith(type, "mac.binary")) 
        stop("cannot install macOS binary packages on Windows")
      if (type %in% "win.binary") {
        .install.winbinary(pkgs = pkgs, lib = lib, contriburl = contriburl, method = method, available = available, destdir = destdir, dependencies = dependencies, libs_only = libs_only, quiet = quiet, ...)
        return(invisible())
      }
      have_spaces <- grep(" ", pkgs)
      if (length(have_spaces)) {
        p <- pkgs[have_spaces]
        dirs <- shortPathName(dirname(p))
        pkgs[have_spaces] <- file.path(dirs, basename(p))
      }
      pkgs <- gsub("\\", "/", pkgs, fixed = TRUE)
    }
    else {
      if (startsWith(type, "mac.binary")) {
        if (!grepl("darwin", R.version$platform)) 
          stop("cannot install macOS binary packages on this platform")
        .install.macbinary(pkgs = pkgs, lib = lib, contriburl = contriburl, method = method, available = available, destdir = destdir, dependencies = dependencies, quiet = quiet, ...)
        return(invisible())
      }
      if (type %in% "win.binary") 
        stop("cannot install Windows binary packages on this platform")
      if (!file.exists(file.path(R.home("bin"), "INSTALL"))) 
        stop("This version of R is not set up to install source packages\nIf it was installed from an RPM, you may need the R-devel RPM")
    }
    cmd0 <- file.path(R.home("bin"), "R")
    args0 <- c("CMD", "INSTALL")
    output <- if (quiet) 
      FALSE
    else ""
    env <- character()
    tlim <- Sys.getenv("_R_INSTALL_PACKAGES_ELAPSED_TIMEOUT_")
    tlim <- if (is.na(tlim)) 
      0
    else tools:::get_timeout(tlim)
    outdir <- getwd()
    if (is.logical(keep_outputs)) {
      if (is.na(keep_outputs)) 
        keep_outputs <- FALSE
    }
    else if (is.character(keep_outputs) && (length(keep_outputs) == 1)) {
      if (!dir.exists(keep_outputs) && !dir.create(keep_outputs, recursive = TRUE)) 
        stop(gettextf("unable to create %s", sQuote(keep_outputs)), domain = NA)
      outdir <- normalizePath(keep_outputs)
      keep_outputs <- TRUE
    }
    else stop(gettextf("invalid %s argument", sQuote("keep_outputs")), domain = NA)
    if (length(libpath <- .R_LIBS())) {
      if (.Platform$OS.type == "windows") {
        oldrlibs <- Sys.getenv("R_LIBS")
        Sys.setenv(R_LIBS = libpath)
        on.exit(Sys.setenv(R_LIBS = oldrlibs))
      }
      else env <- paste0("R_LIBS=", shQuote(libpath))
    }
    if (is.character(clean)) 
      args0 <- c(args0, clean)
    if (libs_only) 
      args0 <- c(args0, "--libs-only")
    if (!missing(INSTALL_opts)) {
      if (!is.list(INSTALL_opts)) {
        args0 <- c(args0, paste(INSTALL_opts, collapse = " "))
        INSTALL_opts <- list()
      }
    }
    else {
      INSTALL_opts <- list()
    }
    if (verbose) 
      message(gettextf("system (cmd0): %s", paste(c(cmd0, args0), collapse = " ")), domain = NA)
    if (is.null(repos) && missing(contriburl)) {
      update <- cbind(path.expand(pkgs), lib)
      for (i in seq_len(nrow(update))) {
        if (is.na(update[i, 1])) 
          next
        args <- c(args0, get_install_opts(update[i, 1]), "-l", shQuote(update[i, 2]), getConfigureArgs(update[i, 1]), getConfigureVars(update[i, 1]), shQuote(update[i, 1]))
        status <- system2(cmd0, args, env = env, stdout = output, stderr = output, timeout = tlim)
        if (status > 0) 
          warning(gettextf("installation of package %s had non-zero exit status", sQuote(update[i, 1])), domain = NA)
        else if (verbose) {
          cmd <- paste(c(cmd0, args), collapse = " ")
          message(sprintf("%d): succeeded '%s'", i, cmd), domain = NA)
        }
      }
      return(invisible())
    }
    tmpd <- destdir
    nonlocalrepos <- !all(startsWith(contriburl, "file:"))
    if (is.null(destdir) && nonlocalrepos) {
      tmpd <- file.path(tempdir(), "downloaded_packages")
      if (!file.exists(tmpd) && !dir.create(tmpd)) 
        stop(gettextf("unable to create temporary directory %s", sQuote(tmpd)), domain = NA)
    }
    av2 <- NULL
    if (is.null(available)) {
      filters <- getOption("available_packages_filters")
      if (!is.null(filters)) {
        available <- available.packages(contriburl = contriburl, method = method, ...)
      }
      else {
        f <- setdiff(available_packages_filters_default, c("R_version", "duplicates"))
        av2 <- available.packages(contriburl = contriburl, filters = f, method = method, ...)
        f <- available_packages_filters_db[["R_version"]]
        f2 <- available_packages_filters_db[["duplicates"]]
        available <- f2(f(av2))
      }
    }
    if (getDeps) 
      pkgs <- getDependencies(pkgs, dependencies, available, lib, ..., av2 = av2)
    foundpkgs <- download.packages(pkgs, destdir = tmpd, available = available, contriburl = contriburl, method = method, type = "source", quiet = quiet, ...)
    if (length(foundpkgs)) {
      if (verbose) 
        message(gettextf("foundpkgs: %s", paste(foundpkgs, collapse = ", ")), domain = NA)
      update <- unique(cbind(pkgs, lib))
      colnames(update) <- c("Package", "LibPath")
      found <- pkgs %in% foundpkgs[, 1]
      files <- foundpkgs[match(pkgs[found], foundpkgs[, 1]), 2]
      if (verbose) 
        message(gettextf("files: %s", paste(files, collapse = ", \n\t")), domain = NA)
      update <- cbind(update[found, , drop = FALSE], file = files)
      if (nrow(update) > 1) {
        upkgs <- unique(pkgs <- update[, 1])
        DL <- .make_dependency_list(upkgs, available)
        p0 <- .find_install_order(upkgs, DL)
        update <- update[sort.list(match(pkgs, p0)), ]
      }
      if (Ncpus > 1 && nrow(update) > 1) {
        tlim_cmd <- character()
        if (tlim > 0) {
          if (nzchar(timeout <- Sys.which("timeout"))) {
            tlim_cmd <- c(shQuote(timeout), "-s INT", tlim)
          }
          else warning("timeouts for parallel installs require the 'timeout' command")
        }
        args0 <- c(args0, "--pkglock")
        tmpd2 <- file.path(tempdir(), "make_packages")
        if (!file.exists(tmpd2) && !dir.create(tmpd2)) 
          stop(gettextf("unable to create temporary directory %s", sQuote(tmpd2)), domain = NA)
        mfile <- file.path(tmpd2, "Makefile")
        conn <- file(mfile, "wt")
        deps <- paste(paste0(update[, 1], ".ts"), collapse = " ")
        deps <- strwrap(deps, width = 75, exdent = 2)
        deps <- paste(deps, collapse = " \\\n")
        cat("all: ", deps, "\n", sep = "", file = conn)
        aDL <- .make_dependency_list(upkgs, available, recursive = TRUE)
        for (i in seq_len(nrow(update))) {
          pkg <- update[i, 1]
          fil <- update[i, 3]
          args <- c(args0, get_install_opts(fil), "-l", shQuote(update[i, 2]), getConfigureArgs(fil), getConfigureVars(fil), shQuote(fil), ">", paste0(pkg, ".out"), "2>&1")
          cmd <- paste(c("MAKEFLAGS=", tlim_cmd, shQuote(cmd0), args), collapse = " ")
          deps <- aDL[[pkg]]
          deps <- deps[deps %in% upkgs]
          deps <- if (length(deps)) 
            paste(paste0(deps, ".ts"), collapse = " ")
          else ""
          cat(paste0(pkg, ".ts: ", deps), paste("\t@echo begin installing package", sQuote(pkg)), paste0("\t@", cmd, " && touch ", pkg, ".ts"), paste0("\t@cat ", pkg, ".out"), "", sep = "\n", file = conn)
        }
        close(conn)
        cwd <- setwd(tmpd2)
        on.exit(setwd(cwd))
        status <- system2(Sys.getenv("MAKE", "make"), c("-k -j", Ncpus), stdout = output, stderr = output, env = env)
        if (status > 0) {
          pkgs <- update[, 1]
          tss <- sub("[.]ts$", "", dir(".", pattern = "[.]ts$"))
          failed <- pkgs[!pkgs %in% tss]
          for (pkg in failed) system(paste0("cat ", pkg, ".out"))
          warning(gettextf("installation of one or more packages failed,\n  probably %s", paste(sQuote(failed), collapse = ", ")), domain = NA)
        }
        if (keep_outputs) 
          file.copy(paste0(update[, 1], ".out"), outdir)
        file.copy(Sys.glob(paste0(update[, 1], "*.zip")), cwd)
        file.copy(Sys.glob(paste0(update[, 1], "*.tgz")), cwd)
        file.copy(Sys.glob(paste0(update[, 1], "*.tar.gz")), cwd)
        setwd(cwd)
        on.exit()
        unlink(tmpd2, recursive = TRUE)
      }
      else {
        tmpd2 <- tempfile()
        if (!dir.create(tmpd2)) 
          stop(gettextf("unable to create temporary directory %s", sQuote(tmpd2)), domain = NA)
        outfiles <- file.path(tmpd2, paste0(update[, 1], ".out"))
        for (i in seq_len(nrow(update))) {
          outfile <- if (keep_outputs) 
            outfiles[i]
          else output
          fil <- update[i, 3]
          args <- c(args0, get_install_opts(fil), "-l", shQuote(update[i, 2]), getConfigureArgs(fil), getConfigureVars(fil), shQuote(fil))
          status <- system2(cmd0, args, env = env, stdout = outfile, stderr = outfile, timeout = tlim)
          if (!quiet && keep_outputs) 
            writeLines(readLines(outfile))
          if (status > 0) 
            warning(gettextf("installation of package %s had non-zero exit status", sQuote(update[i, 1])), domain = NA)
          else if (verbose) {
            cmd <- paste(c(cmd0, args), collapse = " ")
            message(sprintf("%d): succeeded '%s'", i, cmd), domain = NA)
          }
        }
        if (keep_outputs) 
          file.copy(outfiles, outdir)
        unlink(tmpd2, recursive = TRUE)
      }
      if (!quiet && nonlocalrepos && !is.null(tmpd) && is.null(destdir)) 
        cat("\n", gettextf("The downloaded source packages are in\n\t%s", sQuote(normalizePath(tmpd, mustWork = FALSE))), "\n", sep = "", file = stderr())
      libs_used <- unique(update[, 2])
      if (.Platform$OS.type == "unix" && .Library %in% libs_used) {
        message("Updating HTML index of packages in '.Library'")
        make.packages.html(.Library)
      }
    }
    else if (!is.null(tmpd) && is.null(destdir)) 
      unlink(tmpd, TRUE)
    invisible()
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
installed.packages
list(`package:utils` = function (lib.loc = NULL, priority = NULL, noCache = FALSE, fields = NULL, subarch = .Platform$r_arch, ...) 
{
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (!is.null(priority)) {
    if (!is.character(priority)) 
      stop("'priority' must be character or NULL")
    if (any(b <- priority %in% "high")) 
      priority <- c(priority[!b], "recommended", "base")
  }
  fields <- .instPkgFields(fields)
  retval <- matrix(character(), 0, 2 + length(fields))
  for (lib in lib.loc) {
    if (noCache) {
      ret0 <- .readPkgDesc(lib, fields)
      if (length(ret0)) 
        retval <- rbind(retval, ret0, deparse.level = 0)
    }
    else {
      base <- paste(c(lib, fields), collapse = ",")
      enc <- sprintf("%d_%s", nchar(base), .Call(C_crc64, base))
      dest <- file.path(tempdir(), paste0("libloc_", enc, ".rds"))
      test <- file.exists(dest) && file.mtime(dest) > file.mtime(lib) && (val <- readRDS(dest))$base == base
      if (isTRUE(as.vector(test))) 
        retval <- rbind(retval, val$value)
      else {
        ret0 <- .readPkgDesc(lib, fields)
        if (length(ret0)) {
          retval <- rbind(retval, ret0, deparse.level = 0)
          saveRDS(list(base = base, value = ret0), dest)
        }
        else unlink(dest)
      }
    }
  }
  .fixupPkgMat(retval, fields, priority, subarch)
}, function (lib.loc = NULL, priority = NULL, noCache = FALSE, fields = NULL, subarch = .Platform$r_arch, ...) 
{
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (!is.null(priority)) {
    if (!is.character(priority)) 
      stop("'priority' must be character or NULL")
    if (any(b <- priority %in% "high")) 
      priority <- c(priority[!b], "recommended", "base")
  }
  fields <- .instPkgFields(fields)
  retval <- matrix(character(), 0, 2 + length(fields))
  for (lib in lib.loc) {
    if (noCache) {
      ret0 <- .readPkgDesc(lib, fields)
      if (length(ret0)) 
        retval <- rbind(retval, ret0, deparse.level = 0)
    }
    else {
      base <- paste(c(lib, fields), collapse = ",")
      enc <- sprintf("%d_%s", nchar(base), .Call(C_crc64, base))
      dest <- file.path(tempdir(), paste0("libloc_", enc, ".rds"))
      test <- file.exists(dest) && file.mtime(dest) > file.mtime(lib) && (val <- readRDS(dest))$base == base
      if (isTRUE(as.vector(test))) 
        retval <- rbind(retval, val$value)
      else {
        ret0 <- .readPkgDesc(lib, fields)
        if (length(ret0)) {
          retval <- rbind(retval, ret0, deparse.level = 0)
          saveRDS(list(base = base, value = ret0), dest)
        }
        else unlink(dest)
      }
    }
  }
  .fixupPkgMat(retval, fields, priority, subarch)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.hashtab
list(`package:utils` = function (x) 
  .External(C_ishashtab_Ext, x), function (x) 
    .External(C_ishashtab_Ext, x))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
is.relistable
list(`package:utils` = function (x) 
  inherits(x, "relistable"), function (x) 
    inherits(x, "relistable"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
isS3method
list(`package:utils` = function (method, f, class, envir = parent.frame()) 
{
  if (missing(method)) {
    method <- paste(f, class, sep = ".")
  }
  else {
    f.c <- strsplit(method, ".", fixed = TRUE)[[1]]
    nfc <- length(f.c)
    if (nfc < 2 || !is.character(f.c)) 
      return(FALSE)
    if (nfc == 2) {
      f <- f.c[[1]]
      class <- f.c[[2]]
    }
    else {
      for (j in 2:nfc) if (isS3method(f = paste(f.c[1:(j - 1)], collapse = "."), class = paste(f.c[j:nfc], collapse = "."), envir = envir)) 
        return(TRUE)
      return(FALSE)
    }
  }
  if (!any(f == getKnownS3generics())) {
    if (!nzchar(f <- findGeneric(f, envir))) 
      return(FALSE)
  }
  if (!is.null(m <- get0(method, envir = envir, mode = "function"))) {
    pkg <- if (isNamespace(em <- environment(m))) 
      environmentName(em)
    else if (is.primitive(m)) 
      "base"
    return(is.na(match(method, tools::nonS3methods(pkg))))
  }
  defenv <- if (!is.na(w <- .knownS3Generics[f])) 
    asNamespace(w)
  else if (f %in% tools:::.get_internal_S3_generics()) 
    .BaseNamespaceEnv
  else {
    genfun <- get(f, mode = "function", envir = envir)
    if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
      genfun <- methods::selectMethod(genfun, "ANY")
    .defenv_for_S3_registry(genfun)
  }
  S3Table <- get(".__S3MethodsTable__.", envir = defenv)
  exists(method, envir = S3Table, inherits = FALSE)
}, function (method, f, class, envir = parent.frame()) 
{
  if (missing(method)) {
    method <- paste(f, class, sep = ".")
  }
  else {
    f.c <- strsplit(method, ".", fixed = TRUE)[[1]]
    nfc <- length(f.c)
    if (nfc < 2 || !is.character(f.c)) 
      return(FALSE)
    if (nfc == 2) {
      f <- f.c[[1]]
      class <- f.c[[2]]
    }
    else {
      for (j in 2:nfc) if (isS3method(f = paste(f.c[1:(j - 1)], collapse = "."), class = paste(f.c[j:nfc], collapse = "."), envir = envir)) 
        return(TRUE)
      return(FALSE)
    }
  }
  if (!any(f == getKnownS3generics())) {
    if (!nzchar(f <- findGeneric(f, envir))) 
      return(FALSE)
  }
  if (!is.null(m <- get0(method, envir = envir, mode = "function"))) {
    pkg <- if (isNamespace(em <- environment(m))) 
      environmentName(em)
    else if (is.primitive(m)) 
      "base"
    return(is.na(match(method, tools::nonS3methods(pkg))))
  }
  defenv <- if (!is.na(w <- .knownS3Generics[f])) 
    asNamespace(w)
  else if (f %in% tools:::.get_internal_S3_generics()) 
    .BaseNamespaceEnv
  else {
    genfun <- get(f, mode = "function", envir = envir)
    if (.isMethodsDispatchOn() && methods::is(genfun, "genericFunction")) 
      genfun <- methods::selectMethod(genfun, "ANY")
    .defenv_for_S3_registry(genfun)
  }
  S3Table <- get(".__S3MethodsTable__.", envir = defenv)
  exists(method, envir = S3Table, inherits = FALSE)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
isS3stdGeneric
list(`package:utils` = function (f) 
{
  bdexpr <- body(if (methods::is(f, "traceable")) 
    f@original
    else f)
  while (is.call(bdexpr) && bdexpr[[1]] == "{") bdexpr <- bdexpr[[2]]
  ret <- is.call(bdexpr) && bdexpr[[1]] == "UseMethod"
  if (ret) 
    names(ret) <- bdexpr[[2]]
  ret
}, function (f) 
{
  bdexpr <- body(if (methods::is(f, "traceable")) 
    f@original
    else f)
  while (is.call(bdexpr) && bdexpr[[1]] == "{") bdexpr <- bdexpr[[2]]
  ret <- is.call(bdexpr) && bdexpr[[1]] == "UseMethod"
  if (ret) 
    names(ret) <- bdexpr[[2]]
  ret
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
limitedLabels
list(`package:utils` = function (value, maxwidth = getOption("width") - 5) 
{
  srcrefs <- sapply(value, function(v) if (!is.null(srcref <- attr(v, "srcref"))) {
    srcfile <- attr(srcref, "srcfile")
    paste0(basename(srcfile$filename), "#", srcref[1], ": ")
  }
  else "")
  value <- paste0(srcrefs, as.character(value))
  if (is.null(maxwidth) || maxwidth < 40) 
    maxwidth <- 40
  maxwidth <- min(maxwidth, 1000)
  strtrim(value, maxwidth)
}, function (value, maxwidth = getOption("width") - 5) 
{
  srcrefs <- sapply(value, function(v) if (!is.null(srcref <- attr(v, "srcref"))) {
    srcfile <- attr(srcref, "srcfile")
    paste0(basename(srcfile$filename), "#", srcref[1], ": ")
  }
  else "")
  value <- paste0(srcrefs, as.character(value))
  if (is.null(maxwidth) || maxwidth < 40) 
    maxwidth <- 40
  maxwidth <- min(maxwidth, 1000)
  strtrim(value, maxwidth)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
loadhistory
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (file = ".Rhistory") 
    invisible(.External2(C_loadhistory, file)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
loadRconsole
list(`package:utils` = function (file = choose.files(file.path(Sys.getenv("R_USER"), "Rconsole"))) 
  invisible(.Call(C_loadRconsole, file)), function (file = choose.files(file.path(Sys.getenv("R_USER"), "Rconsole"))) 
    invisible(.Call(C_loadRconsole, file)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
localeToCharset
list(`package:utils` = function (locale = Sys.getlocale("LC_CTYPE")) 
{
  guess <- function(en) {
    if (en %in% c("aa", "af", "an", "br", "ca", "da", "de", "en", "es", "et", "eu", "fi", "fo", "fr", "ga", "gl", "gv", "id", "is", "it", "kl", "kw", "ml", "ms", "nb", "nn", "no", "oc", "om", "pt", "so", "sq", "st", "sv", "tl", "uz", "wa", "xh", "zu")) 
      return("ISO8859-1")
    if (en %in% c("bs", "cs", "hr", "hu", "pl", "ro", "sk", "sl")) 
      return("ISO8859-2")
    if (en %in% "mt") 
      return("ISO8859-3")
    if (en %in% c("mk", "ru")) 
      return("ISO8859-5")
    if (en %in% "ar") 
      return("ISO8859-6")
    if (en %in% "el") 
      return("ISO8859-7")
    if (en %in% c("he", "iw", "yi")) 
      return("ISO8859-8")
    if (en %in% "tr") 
      return("ISO8859-9")
    if (en %in% "lg") 
      return("ISO8859-10")
    if (en %in% c("lt", "lv", "mi")) 
      return("ISO8859-13")
    if (en %in% "cy") 
      return("ISO8859-14")
    if (en %in% "uk") 
      return("KOI8-U")
    if (en %in% "ja") 
      return("EUC-JP")
    if (en %in% "ko") 
      return("EUC-KR")
    if (en %in% "th") 
      return("TIS-620")
    if (en %in% "tg") 
      return("KOI8-T")
    if (en %in% "ka") 
      return("GEORGIAN-PS")
    if (en %in% "kk") 
      return("PT154")
    return(NA)
  }
  if (locale %in% c("C", "POSIX")) 
    return("ASCII")
  if (.Platform$OS.type == "windows") {
    x <- strsplit(locale, ".", fixed = TRUE)[[1]]
    if (length(x) != 2) 
      return(NA)
    if (x[2] %in% c("UTF8", "UTF-8", "utf8", "utf-8", "Utf-8")) 
      return("UTF-8")
    switch(x[2], `1252` = return("ISO8859-1"), `1257` = return("ISO8859-13"))
    return(paste0("CP", x[2]))
  }
  else {
    x <- strsplit(locale, ".", fixed = TRUE)[[1]]
    enc <- if (length(x) == 2) 
      gsub("@.*$o", "", x[2])
    else ""
    if (toupper(enc) == "UTF-8") 
      enc <- "utf8"
    if (nzchar(enc) && enc != "utf8") {
      enc <- tolower(enc)
      known <- c("ISO8859-1", "ISO8859-2", "ISO8859-3", "ISO8859-6", "ISO8859-7", "ISO8859-8", "ISO8859-9", "ISO8859-10", "ISO8859-13", "ISO8859-14", "ISO8859-15", "CP1251", "CP1255", "EUC-JP", "EUC-KR", "EUC-TW", "GEORGIAN-PS", "KOI8-R", "KOI8-U", "TCVN", "BIG5", "GB2312", "GB18030", "GBK", "TIS-620", "SHIFT_JIS", "GB2312", "BIG5-HKSCS")
      names(known) <- c("iso88591", "iso88592", "iso88593", "iso88596", "iso88597", "iso88598", "iso88599", "iso885910", "iso885913", "iso885914", "iso885915", "cp1251", "cp1255", "eucjp", "euckr", "euctw", "georgianps", "koi8r", "koi8u", "tcvn", "big5", "gb2312", "gb18030", "gbk", "tis-620", "sjis", "eucn", "big5-hkscs")
      if (grepl("darwin", R.version$os)) {
        k <- c(known, "ISO8859-1", "ISO8859-2", "ISO8859-4", "ISO8859-7", "ISO8859-9", "ISO8859-13", "ISO8859-15", "KOI8-U", "KOI8-R", "PT154", "ASCII", "ARMSCII-8", "ISCII-DEV", "BIG5-HKCSC")
        names(k) <- c(names(known), "iso8859-1", "iso8859-2", "iso8859-4", "iso8859-7", "iso8859-9", "iso8859-13", "iso8859-15", "koi8-u", "koi8-r", "pt154", "us-ascii", "armscii-8", "iscii-dev", "big5hkscs")
        known <- k
      }
      if (enc %in% names(known)) 
        return(unname(known[enc]))
      if (length(grep("^cp-", enc))) 
        return(sub("cp-([0-9]+)", "CP\\1", enc))
      if (enc == "EUC") {
        if (length(grep("^[[:alpha:]]{2}_", x[1], perl = TRUE))) {
          ll <- substr(x[1], 1, 2)
          return(switch(ll, jp = "EUC-JP", kr = "EUC-KR", zh = "GB2312"))
        }
      }
    }
    if (grepl("darwin", R.version$os)) 
      return("UTF-8")
    if (length(grep("^[[:alpha:]]{2}_", x[1], perl = TRUE))) {
      ll <- substr(x[1], 1, 2)
      if (enc == "utf8") 
        return(c("UTF-8", guess(ll)))
      else return(guess(ll))
    }
    if (enc == "utf8") 
      return("UTF-8")
    return(NA)
  }
}, function (locale = Sys.getlocale("LC_CTYPE")) 
{
  guess <- function(en) {
    if (en %in% c("aa", "af", "an", "br", "ca", "da", "de", "en", "es", "et", "eu", "fi", "fo", "fr", "ga", "gl", "gv", "id", "is", "it", "kl", "kw", "ml", "ms", "nb", "nn", "no", "oc", "om", "pt", "so", "sq", "st", "sv", "tl", "uz", "wa", "xh", "zu")) 
      return("ISO8859-1")
    if (en %in% c("bs", "cs", "hr", "hu", "pl", "ro", "sk", "sl")) 
      return("ISO8859-2")
    if (en %in% "mt") 
      return("ISO8859-3")
    if (en %in% c("mk", "ru")) 
      return("ISO8859-5")
    if (en %in% "ar") 
      return("ISO8859-6")
    if (en %in% "el") 
      return("ISO8859-7")
    if (en %in% c("he", "iw", "yi")) 
      return("ISO8859-8")
    if (en %in% "tr") 
      return("ISO8859-9")
    if (en %in% "lg") 
      return("ISO8859-10")
    if (en %in% c("lt", "lv", "mi")) 
      return("ISO8859-13")
    if (en %in% "cy") 
      return("ISO8859-14")
    if (en %in% "uk") 
      return("KOI8-U")
    if (en %in% "ja") 
      return("EUC-JP")
    if (en %in% "ko") 
      return("EUC-KR")
    if (en %in% "th") 
      return("TIS-620")
    if (en %in% "tg") 
      return("KOI8-T")
    if (en %in% "ka") 
      return("GEORGIAN-PS")
    if (en %in% "kk") 
      return("PT154")
    return(NA)
  }
  if (locale %in% c("C", "POSIX")) 
    return("ASCII")
  if (.Platform$OS.type == "windows") {
    x <- strsplit(locale, ".", fixed = TRUE)[[1]]
    if (length(x) != 2) 
      return(NA)
    if (x[2] %in% c("UTF8", "UTF-8", "utf8", "utf-8", "Utf-8")) 
      return("UTF-8")
    switch(x[2], `1252` = return("ISO8859-1"), `1257` = return("ISO8859-13"))
    return(paste0("CP", x[2]))
  }
  else {
    x <- strsplit(locale, ".", fixed = TRUE)[[1]]
    enc <- if (length(x) == 2) 
      gsub("@.*$o", "", x[2])
    else ""
    if (toupper(enc) == "UTF-8") 
      enc <- "utf8"
    if (nzchar(enc) && enc != "utf8") {
      enc <- tolower(enc)
      known <- c("ISO8859-1", "ISO8859-2", "ISO8859-3", "ISO8859-6", "ISO8859-7", "ISO8859-8", "ISO8859-9", "ISO8859-10", "ISO8859-13", "ISO8859-14", "ISO8859-15", "CP1251", "CP1255", "EUC-JP", "EUC-KR", "EUC-TW", "GEORGIAN-PS", "KOI8-R", "KOI8-U", "TCVN", "BIG5", "GB2312", "GB18030", "GBK", "TIS-620", "SHIFT_JIS", "GB2312", "BIG5-HKSCS")
      names(known) <- c("iso88591", "iso88592", "iso88593", "iso88596", "iso88597", "iso88598", "iso88599", "iso885910", "iso885913", "iso885914", "iso885915", "cp1251", "cp1255", "eucjp", "euckr", "euctw", "georgianps", "koi8r", "koi8u", "tcvn", "big5", "gb2312", "gb18030", "gbk", "tis-620", "sjis", "eucn", "big5-hkscs")
      if (grepl("darwin", R.version$os)) {
        k <- c(known, "ISO8859-1", "ISO8859-2", "ISO8859-4", "ISO8859-7", "ISO8859-9", "ISO8859-13", "ISO8859-15", "KOI8-U", "KOI8-R", "PT154", "ASCII", "ARMSCII-8", "ISCII-DEV", "BIG5-HKCSC")
        names(k) <- c(names(known), "iso8859-1", "iso8859-2", "iso8859-4", "iso8859-7", "iso8859-9", "iso8859-13", "iso8859-15", "koi8-u", "koi8-r", "pt154", "us-ascii", "armscii-8", "iscii-dev", "big5hkscs")
        known <- k
      }
      if (enc %in% names(known)) 
        return(unname(known[enc]))
      if (length(grep("^cp-", enc))) 
        return(sub("cp-([0-9]+)", "CP\\1", enc))
      if (enc == "EUC") {
        if (length(grep("^[[:alpha:]]{2}_", x[1], perl = TRUE))) {
          ll <- substr(x[1], 1, 2)
          return(switch(ll, jp = "EUC-JP", kr = "EUC-KR", zh = "GB2312"))
        }
      }
    }
    if (grepl("darwin", R.version$os)) 
      return("UTF-8")
    if (length(grep("^[[:alpha:]]{2}_", x[1], perl = TRUE))) {
      ll <- substr(x[1], 1, 2)
      if (enc == "utf8") 
        return(c("UTF-8", guess(ll)))
      else return(guess(ll))
    }
    if (enc == "utf8") 
      return("UTF-8")
    return(NA)
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
ls.str
list(`package:utils` = function (pos = -1, name, envir, all.names = FALSE, pattern, mode = "any") 
{
  if (missing(envir)) 
    envir <- as.environment(pos)
  nms <- ls(name, envir = envir, all.names = all.names, pattern = pattern)
  r <- vapply(nms, exists, NA, envir = envir, mode = mode, inherits = FALSE)
  structure(nms[r], envir = envir, mode = mode, class = "ls_str")
}, function (pos = -1, name, envir, all.names = FALSE, pattern, mode = "any") 
{
  if (missing(envir)) 
    envir <- as.environment(pos)
  nms <- ls(name, envir = envir, all.names = all.names, pattern = pattern)
  r <- vapply(nms, exists, NA, envir = envir, mode = mode, inherits = FALSE)
  structure(nms[r], envir = envir, mode = mode, class = "ls_str")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
lsf.str
list(`package:utils` = function (pos = -1, envir, ...) 
{
  if (missing(envir)) 
    envir <- as.environment(pos)
  ls.str(pos = pos, envir = envir, mode = "function", ...)
}, function (pos = -1, envir, ...) 
{
  if (missing(envir)) 
    envir <- as.environment(pos)
  ls.str(pos = pos, envir = envir, mode = "function", ...)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
maintainer
list(`package:utils` = function (pkg) 
{
  force(pkg)
  desc <- packageDescription(pkg)
  if (is.list(desc)) 
    gsub("\n", " ", desc$Maintainer, fixed = TRUE)
  else NA
}, function (pkg) 
{
  force(pkg)
  desc <- packageDescription(pkg)
  if (is.list(desc)) 
    gsub("\n", " ", desc$Maintainer, fixed = TRUE)
  else NA
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
make.packages.html
list(`package:utils` = function (lib.loc = .libPaths(), temp = FALSE, verbose = TRUE, docdir = R.home("doc")) 
{
  add_lib_index <- function(libs) {
    cat("<div style=\"text-align: left;\">\n<ul>\n", file = out)
    for (i in seq_along(libs)) {
      nm <- libs[i]
      if (nm == .Library) {
        cat("<li>Contents of the <a href=\"#lib-", i, "\">", "standard</a> library</li>\n", sep = "", file = out)
      }
      else {
        cat("<li>Contents of <a href=\"#lib-", i, "\">", nm, "</a></li>\n", sep = "", file = out)
      }
    }
    cat("</ul>\n</div>\n", file = out)
  }
  WINDOWS <- .Platform$OS.type == "windows"
  f.tg <- if (temp) {
    dir.create(file.path(tempdir(), ".R/doc/html"), recursive = TRUE, showWarnings = FALSE)
    file.path(tempdir(), ".R/doc/html/packages.html")
  }
  else file.path(docdir, "html", "packages.html")
  op <- file.path(tempdir(), ".R/doc/html/libPaths.rds")
  if (temp && file.exists(f.tg) && file.exists(op)) {
    if (identical(lib.loc, readRDS(op))) {
      dates <- file.mtime(c(f.tg, lib.loc))
      if (which.max(dates) == 1) 
        return(TRUE)
    }
  }
  if (!file.create(f.tg)) {
    warning("cannot update HTML package index")
    return(FALSE)
  }
  if (verbose) {
    message("Making 'packages.html' ...", appendLF = FALSE, domain = NA)
    flush.console()
  }
  file.append(f.tg, file.path(R.home("doc"), "html", "packages-head-utf8.html"))
  out <- file(f.tg, open = "a", encoding = "UTF-8")
  on.exit(close(out))
  if (WINDOWS) {
    rh <- chartr("\\", "/", R.home())
    drive <- substr(rh, 1, 2)
  }
  pkgs <- vector("list", length(lib.loc))
  names(pkgs) <- lib.loc
  for (lib in lib.loc) {
    pg <- .packages(all.available = TRUE, lib.loc = lib)
    pkgs[[lib]] <- pg[order(toupper(pg), pg)]
  }
  if (WINDOWS) {
    tot <- sum(lengths(pkgs))
    if (verbose) {
      pb <- winProgressBar("R: creating packages.html", max = tot)
      on.exit(close(pb), add = TRUE)
    }
    npkgs <- 0
  }
  if (length(lib.loc) > 1) 
    add_lib_index(lib.loc)
  for (ii in seq_along(lib.loc)) {
    lib <- lib.loc[ii]
    libname <- if (identical(lib, .Library)) 
      "the standard library"
    else if (WINDOWS) 
      chartr("/", "\\", lib)
    else lib
    cat("<h3 id=\"lib-", ii, "\">Packages in ", libname, "</h3>\n", sep = "", file = out)
    lib0 <- "../../library"
    if (!temp) {
      if (WINDOWS) {
        if (is.na(pmatch(rh, lib))) {
          lib0 <- if (substr(lib, 2, 2) != ":") 
            paste0(drive, lib)
          else lib
          lib0 <- paste0("file:///", URLencode(lib0))
        }
      }
      else {
        if (lib != .Library) 
          lib0 <- paste0("file:///", URLencode(lib))
      }
    }
    pg <- pkgs[[lib]]
    use_alpha <- (length(pg) > 100)
    first <- toupper(substr(pg, 1, 1))
    nm <- sort(names(table(first)))
    if (use_alpha) {
      writeLines("<p style=\"text-align: center;\">", out)
      writeLines(paste0("<a href=\"#pkgs-", nm, "\">", nm, "</a>"), out)
      writeLines("</p>\n", out)
    }
    cat("<table style=\"width: 100%;\">\n", file = out)
    for (a in nm) {
      if (use_alpha) 
        cat("<tr id=\"pkgs-", a, "\"> <td></td>\n", sep = "", file = out)
      for (i in pg[first == a]) {
        title <- packageDescription(i, lib.loc = lib, fields = "Title", encoding = "UTF-8")
        if (is.na(title)) 
          title <- "-- Title is missing --"
        cat("<tr style=\"text-align: left; vertical-align: top;\" id=\"lib-", i, "\">\n", "<td style=\"width: 25%;\"><a href=\"", lib0, "/", i, "/html/00Index.html\">", i, "</a></td><td>", gsub("&", "&amp;", title), "</td></tr>\n", file = out, sep = "")
        if (WINDOWS) {
          npkgs <- npkgs + 1
          if (verbose) 
            setWinProgressBar(pb, npkgs)
        }
      }
    }
    cat("</table>\n\n", file = out)
  }
  if (length(lib.loc) > 1) 
    add_lib_index(lib.loc)
  cat("</div></body>\n</html>\n", file = out)
  if (verbose) {
    message(" ", "done")
    flush.console()
  }
  if (temp) 
    saveRDS(lib.loc, op)
  invisible(TRUE)
}, function (lib.loc = .libPaths(), temp = FALSE, verbose = TRUE, docdir = R.home("doc")) 
{
  add_lib_index <- function(libs) {
    cat("<div style=\"text-align: left;\">\n<ul>\n", file = out)
    for (i in seq_along(libs)) {
      nm <- libs[i]
      if (nm == .Library) {
        cat("<li>Contents of the <a href=\"#lib-", i, "\">", "standard</a> library</li>\n", sep = "", file = out)
      }
      else {
        cat("<li>Contents of <a href=\"#lib-", i, "\">", nm, "</a></li>\n", sep = "", file = out)
      }
    }
    cat("</ul>\n</div>\n", file = out)
  }
  WINDOWS <- .Platform$OS.type == "windows"
  f.tg <- if (temp) {
    dir.create(file.path(tempdir(), ".R/doc/html"), recursive = TRUE, showWarnings = FALSE)
    file.path(tempdir(), ".R/doc/html/packages.html")
  }
  else file.path(docdir, "html", "packages.html")
  op <- file.path(tempdir(), ".R/doc/html/libPaths.rds")
  if (temp && file.exists(f.tg) && file.exists(op)) {
    if (identical(lib.loc, readRDS(op))) {
      dates <- file.mtime(c(f.tg, lib.loc))
      if (which.max(dates) == 1) 
        return(TRUE)
    }
  }
  if (!file.create(f.tg)) {
    warning("cannot update HTML package index")
    return(FALSE)
  }
  if (verbose) {
    message("Making 'packages.html' ...", appendLF = FALSE, domain = NA)
    flush.console()
  }
  file.append(f.tg, file.path(R.home("doc"), "html", "packages-head-utf8.html"))
  out <- file(f.tg, open = "a", encoding = "UTF-8")
  on.exit(close(out))
  if (WINDOWS) {
    rh <- chartr("\\", "/", R.home())
    drive <- substr(rh, 1, 2)
  }
  pkgs <- vector("list", length(lib.loc))
  names(pkgs) <- lib.loc
  for (lib in lib.loc) {
    pg <- .packages(all.available = TRUE, lib.loc = lib)
    pkgs[[lib]] <- pg[order(toupper(pg), pg)]
  }
  if (WINDOWS) {
    tot <- sum(lengths(pkgs))
    if (verbose) {
      pb <- winProgressBar("R: creating packages.html", max = tot)
      on.exit(close(pb), add = TRUE)
    }
    npkgs <- 0
  }
  if (length(lib.loc) > 1) 
    add_lib_index(lib.loc)
  for (ii in seq_along(lib.loc)) {
    lib <- lib.loc[ii]
    libname <- if (identical(lib, .Library)) 
      "the standard library"
    else if (WINDOWS) 
      chartr("/", "\\", lib)
    else lib
    cat("<h3 id=\"lib-", ii, "\">Packages in ", libname, "</h3>\n", sep = "", file = out)
    lib0 <- "../../library"
    if (!temp) {
      if (WINDOWS) {
        if (is.na(pmatch(rh, lib))) {
          lib0 <- if (substr(lib, 2, 2) != ":") 
            paste0(drive, lib)
          else lib
          lib0 <- paste0("file:///", URLencode(lib0))
        }
      }
      else {
        if (lib != .Library) 
          lib0 <- paste0("file:///", URLencode(lib))
      }
    }
    pg <- pkgs[[lib]]
    use_alpha <- (length(pg) > 100)
    first <- toupper(substr(pg, 1, 1))
    nm <- sort(names(table(first)))
    if (use_alpha) {
      writeLines("<p style=\"text-align: center;\">", out)
      writeLines(paste0("<a href=\"#pkgs-", nm, "\">", nm, "</a>"), out)
      writeLines("</p>\n", out)
    }
    cat("<table style=\"width: 100%;\">\n", file = out)
    for (a in nm) {
      if (use_alpha) 
        cat("<tr id=\"pkgs-", a, "\"> <td></td>\n", sep = "", file = out)
      for (i in pg[first == a]) {
        title <- packageDescription(i, lib.loc = lib, fields = "Title", encoding = "UTF-8")
        if (is.na(title)) 
          title <- "-- Title is missing --"
        cat("<tr style=\"text-align: left; vertical-align: top;\" id=\"lib-", i, "\">\n", "<td style=\"width: 25%;\"><a href=\"", lib0, "/", i, "/html/00Index.html\">", i, "</a></td><td>", gsub("&", "&amp;", title), "</td></tr>\n", file = out, sep = "")
        if (WINDOWS) {
          npkgs <- npkgs + 1
          if (verbose) 
            setWinProgressBar(pb, npkgs)
        }
      }
    }
    cat("</table>\n\n", file = out)
  }
  if (length(lib.loc) > 1) 
    add_lib_index(lib.loc)
  cat("</div></body>\n</html>\n", file = out)
  if (verbose) {
    message(" ", "done")
    flush.console()
  }
  if (temp) 
    saveRDS(lib.loc, op)
  invisible(TRUE)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
make.socket
list(`package:utils` = function (host = "localhost", port, fail = TRUE, server = FALSE) 
{
  if (length(port <- as.integer(port)) != 1) 
    stop("'port' must be integer of length 1")
  if (length(host <- as.character(host)) != 1) 
    stop("'host' must be character of length 1")
  if (!server) {
    socket <- .Call(C_sockconnect, port, host)
  }
  else {
    if (host != "localhost") 
      stop("can only receive calls on local machine")
    tmp <- .Call(C_sockopen, port)
    socket <- .Call(C_socklisten, tmp)
    host <- attr(socket, "host")
    .Call(C_sockclose, tmp)
  }
  if (socket <= 0) {
    if (fail) 
      stop("socket not established")
    else warning("socket not established")
  }
  rval <- list(socket = socket, host, port = port)
  class(rval) <- "socket"
  rval
}, function (host = "localhost", port, fail = TRUE, server = FALSE) 
{
  if (length(port <- as.integer(port)) != 1) 
    stop("'port' must be integer of length 1")
  if (length(host <- as.character(host)) != 1) 
    stop("'host' must be character of length 1")
  if (!server) {
    socket <- .Call(C_sockconnect, port, host)
  }
  else {
    if (host != "localhost") 
      stop("can only receive calls on local machine")
    tmp <- .Call(C_sockopen, port)
    socket <- .Call(C_socklisten, tmp)
    host <- attr(socket, "host")
    .Call(C_sockclose, tmp)
  }
  if (socket <= 0) {
    if (fail) 
      stop("socket not established")
    else warning("socket not established")
  }
  rval <- list(socket = socket, host, port = port)
  class(rval) <- "socket"
  rval
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
makeRweaveLatexCodeRunner
list(`package:utils` = function (evalFunc = RweaveEvalWithOpt) 
{
  function(object, chunk, options) {
    pdf.Swd <- function(name, width, height, ...) grDevices::pdf(file = paste0(chunkprefix, ".pdf"), width = width, height = height, version = options$pdf.version, encoding = options$pdf.encoding, compress = options$pdf.compress)
    eps.Swd <- function(name, width, height, ...) grDevices::postscript(file = paste0(name, ".eps"), width = width, height = height, paper = "special", horizontal = FALSE)
    png.Swd <- function(name, width, height, options, ...) grDevices::png(filename = paste0(chunkprefix, ".png"), width = width, height = height, res = options$resolution, units = "in")
    jpeg.Swd <- function(name, width, height, options, ...) grDevices::jpeg(filename = paste0(chunkprefix, ".jpeg"), width = width, height = height, res = options$resolution, units = "in")
    if (!(options$engine %in% c("R", "S"))) 
      return(object)
    devs <- devoffs <- list()
    if (options$fig && options$eval) {
      if (options$pdf) {
        devs <- c(devs, list(pdf.Swd))
        devoffs <- c(devoffs, list(grDevices::dev.off))
      }
      if (options$eps) {
        devs <- c(devs, list(eps.Swd))
        devoffs <- c(devoffs, list(grDevices::dev.off))
      }
      if (options$png) {
        devs <- c(devs, list(png.Swd))
        devoffs <- c(devoffs, list(grDevices::dev.off))
      }
      if (options$jpeg) {
        devs <- c(devs, list(jpeg.Swd))
        devoffs <- c(devoffs, list(grDevices::dev.off))
      }
      if (nzchar(grd <- options$grdevice)) {
        grdo <- paste0(grd, ".off")
        if (grepl("::", grd, fixed = TRUE)) {
          devs <- c(devs, eval(str2expression(grd)))
          devoffs <- c(devoffs, if (!inherits(grdo <- tryCatch(eval(str2expression(grdo)), error = identity), "error")) list(grdo) else list(grDevices::dev.off))
        }
        else {
          devs <- c(devs, list(get(grd, envir = .GlobalEnv)))
          devoffs <- c(devoffs, if (exists(grdo, envir = .GlobalEnv)) list(get(grdo, envir = .GlobalEnv)) else list(grDevices::dev.off))
        }
      }
    }
    if (!object$quiet) {
      cat(formatC(options$chunknr, width = 2), ":")
      if (options$echo) 
        cat(" echo")
      if (options$keep.source) 
        cat(" keep.source")
      if (options$eval) {
        if (options$print) 
          cat(" print")
        if (options$term) 
          cat(" term")
        cat("", options$results)
        if (options$fig) {
          if (options$eps) 
            cat(" eps")
          if (options$pdf) 
            cat(" pdf")
          if (options$png) 
            cat(" png")
          if (options$jpeg) 
            cat(" jpeg")
          if (!is.null(options$grdevice)) 
            cat("", options$grdevice)
        }
      }
      cat(" (")
      if (!is.null(options$label)) 
        cat("label = ", options$label, ", ", sep = "")
      filenum <- attr(chunk, "srcFilenum")[1]
      filename <- attr(chunk, "srcFilenames")[filenum]
      cat(basename(filename), ":", attr(chunk, "srclines")[1], ")", sep = "")
      cat("\n")
    }
    chunkprefix <- RweaveChunkPrefix(options)
    if (options$split) {
      chunkout <- object$chunkout[chunkprefix][[1]]
      if (is.null(chunkout)) {
        chunkout <- file(paste0(chunkprefix, ".tex"), "w")
        if (!is.null(options$label)) 
          object$chunkout[[chunkprefix]] <- chunkout
        if (!grepl(.SweaveValidFilenameRegexp, chunkout)) 
          warning("file stem ", sQuote(chunkout), " is not portable", call. = FALSE, domain = NA)
      }
    }
    else chunkout <- object$output
    srcfile <- srcfilecopy(object$filename, chunk, isFile = TRUE)
    chunkexps <- try(parse(text = chunk, srcfile = srcfile), silent = TRUE)
    if (inherits(chunkexps, "try-error")) 
      chunkexps[1] <- sub(" parse(text = chunk, srcfile = srcfile) : \n ", "", chunkexps[1], fixed = TRUE)
    RweaveTryStop(chunkexps, options)
    putSinput <- function(dce, leading) {
      if (!openSinput) {
        if (!openSchunk) {
          cat("\\begin{Schunk}\n", file = chunkout)
          linesout[thisline + 1] <<- srcline
          filenumout[thisline + 1] <<- srcfilenum
          thisline <<- thisline + 1
          openSchunk <<- TRUE
        }
        cat("\\begin{Sinput}", file = chunkout)
        openSinput <<- TRUE
      }
      leading <- max(leading, 1)
      cat("\n", paste0(getOption("prompt"), dce[seq_len(leading)], collapse = "\n"), file = chunkout, sep = "")
      if (length(dce) > leading) 
        cat("\n", paste0(getOption("continue"), dce[-seq_len(leading)], collapse = "\n"), file = chunkout, sep = "")
      linesout[thisline + seq_along(dce)] <<- srcline
      filenumout[thisline + seq_along(dce)] <<- srcfilenum
      thisline <<- thisline + length(dce)
    }
    trySrcLines <- function(srcfile, showfrom, showto, ce) {
      tryCatch(suppressWarnings(getSrcLines(srcfile, showfrom, showto)), error = function(e) {
        if (is.null(ce)) 
          character()
        else deparse(ce, width.cutoff = 0.75 * getOption("width"))
      })
    }
    echoComments <- function(showto) {
      if (options$echo && !is.na(lastshown) && lastshown < showto) {
        dce <- trySrcLines(srcfile, lastshown + 1, showto, NULL)
        linedirs <- startsWith(dce, "#line ")
        dce <- dce[!linedirs]
        if (length(dce)) 
          putSinput(dce, length(dce))
        lastshown <<- showto
      }
    }
    openSinput <- FALSE
    openSchunk <- FALSE
    srclines <- attr(chunk, "srclines")
    srcfilenums <- attr(chunk, "srcFilenum")
    linesout <- integer()
    filenumout <- integer()
    srcline <- srclines[1]
    srcfilenum <- srcfilenums[1]
    thisline <- 0
    lastshown <- 0
    leading <- 1
    srcrefs <- attr(chunkexps, "srcref")
    if (length(devs)) {
      if (!grepl(.SweaveValidFilenameRegexp, chunkprefix)) 
        warning("file stem ", sQuote(chunkprefix), " is not portable", call. = FALSE, domain = NA)
      if (options$figs.only) 
        devs[[1]](name = chunkprefix, width = options$width, height = options$height, options)
    }
    SweaveHooks(options, run = TRUE)
    for (nce in seq_along(chunkexps)) {
      ce <- chunkexps[[nce]]
      if (options$keep.source && nce <= length(srcrefs) && !is.null(srcref <- srcrefs[[nce]])) {
        showfrom <- srcref[7]
        showto <- srcref[8]
        dce <- trySrcLines(srcfile, lastshown + 1, showto, ce)
        leading <- showfrom - lastshown
        lastshown <- showto
        srcline <- srcref[3]
        linedirs <- startsWith(dce, "#line ")
        dce <- dce[!linedirs]
        leading <- leading - sum(linedirs[seq_len(leading)])
        while (length(dce) && length(grep("^[[:blank:]]*$", dce[1]))) {
          dce <- dce[-1]
          leading <- leading - 1
        }
      }
      else {
        dce <- deparse(ce, width.cutoff = 0.75 * getOption("width"))
        leading <- 1
      }
      if (object$debug) 
        cat("\nRnw> ", paste(dce, collapse = "\n+  "), "\n")
      if (options$echo && length(dce)) 
        putSinput(dce, leading)
      if (options$eval) {
        tmpcon <- file()
        sink(file = tmpcon)
        err <- tryCatch(evalFunc(ce, options), finally = {
          cat("\n")
          sink()
        })
        output <- readLines(tmpcon)
        close(tmpcon)
        if (length(output) == 1 && !nzchar(output[1])) 
          output <- NULL
        RweaveTryStop(err, options)
      }
      else output <- NULL
      if (length(output) && object$debug) 
        cat(paste(output, collapse = "\n"))
      if (length(output) && (options$results != "hide")) {
        if (openSinput) {
          cat("\n\\end{Sinput}\n", file = chunkout)
          linesout[thisline + 1:2] <- srcline
          filenumout[thisline + 1:2] <- srcfilenum
          thisline <- thisline + 2
          openSinput <- FALSE
        }
        if (options$results == "verbatim") {
          if (!openSchunk) {
            cat("\\begin{Schunk}\n", file = chunkout)
            linesout[thisline + 1] <- srcline
            filenumout[thisline + 1] <- srcfilenum
            thisline <- thisline + 1
            openSchunk <- TRUE
          }
          cat("\\begin{Soutput}\n", file = chunkout)
          linesout[thisline + 1] <- srcline
          filenumout[thisline + 1] <- srcfilenum
          thisline <- thisline + 1
        }
        output <- paste(output, collapse = "\n")
        if (options$strip.white %in% c("all", "true")) {
          output <- sub("^[[:space:]]*\n", "", output)
          output <- sub("\n[[:space:]]*$", "", output)
          if (options$strip.white == "all") 
            output <- sub("\n[[:space:]]*\n", "\n", output)
        }
        cat(output, file = chunkout)
        count <- sum(strsplit(output, NULL)[[1]] == "\n")
        if (count > 0) {
          linesout[thisline + 1:count] <- srcline
          filenumout[thisline + 1:count] <- srcfilenum
          thisline <- thisline + count
        }
        remove(output)
        if (options$results == "verbatim") {
          cat("\n\\end{Soutput}\n", file = chunkout)
          linesout[thisline + 1:2] <- srcline
          filenumout[thisline + 1:2] <- srcfilenum
          thisline <- thisline + 2
        }
      }
    }
    if (options$keep.source) 
      echoComments(length(srcfile$lines))
    if (openSinput) {
      cat("\n\\end{Sinput}\n", file = chunkout)
      linesout[thisline + 1:2] <- srcline
      filenumout[thisline + 1:2] <- srcfilenum
      thisline <- thisline + 2
    }
    if (openSchunk) {
      cat("\\end{Schunk}\n", file = chunkout)
      linesout[thisline + 1] <- srcline
      filenumout[thisline + 1] <- srcfilenum
      thisline <- thisline + 1
    }
    if (is.null(options$label) && options$split) 
      close(chunkout)
    if (options$split && options$include) {
      cat("\\input{", chunkprefix, "}\n", sep = "", file = object$output)
      linesout[thisline + 1] <- srcline
      filenumout[thisline + 1] <- srcfilenum
      thisline <- thisline + 1
    }
    if (length(devs)) {
      if (options$figs.only) 
        devoffs[[1]]()
      for (i in seq_along(devs)) {
        if (options$figs.only && i == 1) 
          next
        devs[[i]](name = chunkprefix, width = options$width, height = options$height, options)
        err <- tryCatch({
          SweaveHooks(options, run = TRUE)
          eval(chunkexps, envir = .GlobalEnv)
        }, error = function(e) {
          devoffs[[i]]()
          stop(conditionMessage(e), call. = FALSE, domain = NA)
        })
        devoffs[[i]]()
      }
      if (options$include) {
        cat("\\includegraphics{", chunkprefix, "}\n", sep = "", file = object$output)
        linesout[thisline + 1] <- srcline
        filenumout[thisline + 1] <- srcfilenum
        thisline <- thisline + 1
      }
    }
    object$linesout <- c(object$linesout, linesout)
    object$filenumout <- c(object$filenumout, filenumout)
    object
  }
}, function (evalFunc = RweaveEvalWithOpt) 
{
  function(object, chunk, options) {
    pdf.Swd <- function(name, width, height, ...) grDevices::pdf(file = paste0(chunkprefix, ".pdf"), width = width, height = height, version = options$pdf.version, encoding = options$pdf.encoding, compress = options$pdf.compress)
    eps.Swd <- function(name, width, height, ...) grDevices::postscript(file = paste0(name, ".eps"), width = width, height = height, paper = "special", horizontal = FALSE)
    png.Swd <- function(name, width, height, options, ...) grDevices::png(filename = paste0(chunkprefix, ".png"), width = width, height = height, res = options$resolution, units = "in")
    jpeg.Swd <- function(name, width, height, options, ...) grDevices::jpeg(filename = paste0(chunkprefix, ".jpeg"), width = width, height = height, res = options$resolution, units = "in")
    if (!(options$engine %in% c("R", "S"))) 
      return(object)
    devs <- devoffs <- list()
    if (options$fig && options$eval) {
      if (options$pdf) {
        devs <- c(devs, list(pdf.Swd))
        devoffs <- c(devoffs, list(grDevices::dev.off))
      }
      if (options$eps) {
        devs <- c(devs, list(eps.Swd))
        devoffs <- c(devoffs, list(grDevices::dev.off))
      }
      if (options$png) {
        devs <- c(devs, list(png.Swd))
        devoffs <- c(devoffs, list(grDevices::dev.off))
      }
      if (options$jpeg) {
        devs <- c(devs, list(jpeg.Swd))
        devoffs <- c(devoffs, list(grDevices::dev.off))
      }
      if (nzchar(grd <- options$grdevice)) {
        grdo <- paste0(grd, ".off")
        if (grepl("::", grd, fixed = TRUE)) {
          devs <- c(devs, eval(str2expression(grd)))
          devoffs <- c(devoffs, if (!inherits(grdo <- tryCatch(eval(str2expression(grdo)), error = identity), "error")) list(grdo) else list(grDevices::dev.off))
        }
        else {
          devs <- c(devs, list(get(grd, envir = .GlobalEnv)))
          devoffs <- c(devoffs, if (exists(grdo, envir = .GlobalEnv)) list(get(grdo, envir = .GlobalEnv)) else list(grDevices::dev.off))
        }
      }
    }
    if (!object$quiet) {
      cat(formatC(options$chunknr, width = 2), ":")
      if (options$echo) 
        cat(" echo")
      if (options$keep.source) 
        cat(" keep.source")
      if (options$eval) {
        if (options$print) 
          cat(" print")
        if (options$term) 
          cat(" term")
        cat("", options$results)
        if (options$fig) {
          if (options$eps) 
            cat(" eps")
          if (options$pdf) 
            cat(" pdf")
          if (options$png) 
            cat(" png")
          if (options$jpeg) 
            cat(" jpeg")
          if (!is.null(options$grdevice)) 
            cat("", options$grdevice)
        }
      }
      cat(" (")
      if (!is.null(options$label)) 
        cat("label = ", options$label, ", ", sep = "")
      filenum <- attr(chunk, "srcFilenum")[1]
      filename <- attr(chunk, "srcFilenames")[filenum]
      cat(basename(filename), ":", attr(chunk, "srclines")[1], ")", sep = "")
      cat("\n")
    }
    chunkprefix <- RweaveChunkPrefix(options)
    if (options$split) {
      chunkout <- object$chunkout[chunkprefix][[1]]
      if (is.null(chunkout)) {
        chunkout <- file(paste0(chunkprefix, ".tex"), "w")
        if (!is.null(options$label)) 
          object$chunkout[[chunkprefix]] <- chunkout
        if (!grepl(.SweaveValidFilenameRegexp, chunkout)) 
          warning("file stem ", sQuote(chunkout), " is not portable", call. = FALSE, domain = NA)
      }
    }
    else chunkout <- object$output
    srcfile <- srcfilecopy(object$filename, chunk, isFile = TRUE)
    chunkexps <- try(parse(text = chunk, srcfile = srcfile), silent = TRUE)
    if (inherits(chunkexps, "try-error")) 
      chunkexps[1] <- sub(" parse(text = chunk, srcfile = srcfile) : \n ", "", chunkexps[1], fixed = TRUE)
    RweaveTryStop(chunkexps, options)
    putSinput <- function(dce, leading) {
      if (!openSinput) {
        if (!openSchunk) {
          cat("\\begin{Schunk}\n", file = chunkout)
          linesout[thisline + 1] <<- srcline
          filenumout[thisline + 1] <<- srcfilenum
          thisline <<- thisline + 1
          openSchunk <<- TRUE
        }
        cat("\\begin{Sinput}", file = chunkout)
        openSinput <<- TRUE
      }
      leading <- max(leading, 1)
      cat("\n", paste0(getOption("prompt"), dce[seq_len(leading)], collapse = "\n"), file = chunkout, sep = "")
      if (length(dce) > leading) 
        cat("\n", paste0(getOption("continue"), dce[-seq_len(leading)], collapse = "\n"), file = chunkout, sep = "")
      linesout[thisline + seq_along(dce)] <<- srcline
      filenumout[thisline + seq_along(dce)] <<- srcfilenum
      thisline <<- thisline + length(dce)
    }
    trySrcLines <- function(srcfile, showfrom, showto, ce) {
      tryCatch(suppressWarnings(getSrcLines(srcfile, showfrom, showto)), error = function(e) {
        if (is.null(ce)) 
          character()
        else deparse(ce, width.cutoff = 0.75 * getOption("width"))
      })
    }
    echoComments <- function(showto) {
      if (options$echo && !is.na(lastshown) && lastshown < showto) {
        dce <- trySrcLines(srcfile, lastshown + 1, showto, NULL)
        linedirs <- startsWith(dce, "#line ")
        dce <- dce[!linedirs]
        if (length(dce)) 
          putSinput(dce, length(dce))
        lastshown <<- showto
      }
    }
    openSinput <- FALSE
    openSchunk <- FALSE
    srclines <- attr(chunk, "srclines")
    srcfilenums <- attr(chunk, "srcFilenum")
    linesout <- integer()
    filenumout <- integer()
    srcline <- srclines[1]
    srcfilenum <- srcfilenums[1]
    thisline <- 0
    lastshown <- 0
    leading <- 1
    srcrefs <- attr(chunkexps, "srcref")
    if (length(devs)) {
      if (!grepl(.SweaveValidFilenameRegexp, chunkprefix)) 
        warning("file stem ", sQuote(chunkprefix), " is not portable", call. = FALSE, domain = NA)
      if (options$figs.only) 
        devs[[1]](name = chunkprefix, width = options$width, height = options$height, options)
    }
    SweaveHooks(options, run = TRUE)
    for (nce in seq_along(chunkexps)) {
      ce <- chunkexps[[nce]]
      if (options$keep.source && nce <= length(srcrefs) && !is.null(srcref <- srcrefs[[nce]])) {
        showfrom <- srcref[7]
        showto <- srcref[8]
        dce <- trySrcLines(srcfile, lastshown + 1, showto, ce)
        leading <- showfrom - lastshown
        lastshown <- showto
        srcline <- srcref[3]
        linedirs <- startsWith(dce, "#line ")
        dce <- dce[!linedirs]
        leading <- leading - sum(linedirs[seq_len(leading)])
        while (length(dce) && length(grep("^[[:blank:]]*$", dce[1]))) {
          dce <- dce[-1]
          leading <- leading - 1
        }
      }
      else {
        dce <- deparse(ce, width.cutoff = 0.75 * getOption("width"))
        leading <- 1
      }
      if (object$debug) 
        cat("\nRnw> ", paste(dce, collapse = "\n+  "), "\n")
      if (options$echo && length(dce)) 
        putSinput(dce, leading)
      if (options$eval) {
        tmpcon <- file()
        sink(file = tmpcon)
        err <- tryCatch(evalFunc(ce, options), finally = {
          cat("\n")
          sink()
        })
        output <- readLines(tmpcon)
        close(tmpcon)
        if (length(output) == 1 && !nzchar(output[1])) 
          output <- NULL
        RweaveTryStop(err, options)
      }
      else output <- NULL
      if (length(output) && object$debug) 
        cat(paste(output, collapse = "\n"))
      if (length(output) && (options$results != "hide")) {
        if (openSinput) {
          cat("\n\\end{Sinput}\n", file = chunkout)
          linesout[thisline + 1:2] <- srcline
          filenumout[thisline + 1:2] <- srcfilenum
          thisline <- thisline + 2
          openSinput <- FALSE
        }
        if (options$results == "verbatim") {
          if (!openSchunk) {
            cat("\\begin{Schunk}\n", file = chunkout)
            linesout[thisline + 1] <- srcline
            filenumout[thisline + 1] <- srcfilenum
            thisline <- thisline + 1
            openSchunk <- TRUE
          }
          cat("\\begin{Soutput}\n", file = chunkout)
          linesout[thisline + 1] <- srcline
          filenumout[thisline + 1] <- srcfilenum
          thisline <- thisline + 1
        }
        output <- paste(output, collapse = "\n")
        if (options$strip.white %in% c("all", "true")) {
          output <- sub("^[[:space:]]*\n", "", output)
          output <- sub("\n[[:space:]]*$", "", output)
          if (options$strip.white == "all") 
            output <- sub("\n[[:space:]]*\n", "\n", output)
        }
        cat(output, file = chunkout)
        count <- sum(strsplit(output, NULL)[[1]] == "\n")
        if (count > 0) {
          linesout[thisline + 1:count] <- srcline
          filenumout[thisline + 1:count] <- srcfilenum
          thisline <- thisline + count
        }
        remove(output)
        if (options$results == "verbatim") {
          cat("\n\\end{Soutput}\n", file = chunkout)
          linesout[thisline + 1:2] <- srcline
          filenumout[thisline + 1:2] <- srcfilenum
          thisline <- thisline + 2
        }
      }
    }
    if (options$keep.source) 
      echoComments(length(srcfile$lines))
    if (openSinput) {
      cat("\n\\end{Sinput}\n", file = chunkout)
      linesout[thisline + 1:2] <- srcline
      filenumout[thisline + 1:2] <- srcfilenum
      thisline <- thisline + 2
    }
    if (openSchunk) {
      cat("\\end{Schunk}\n", file = chunkout)
      linesout[thisline + 1] <- srcline
      filenumout[thisline + 1] <- srcfilenum
      thisline <- thisline + 1
    }
    if (is.null(options$label) && options$split) 
      close(chunkout)
    if (options$split && options$include) {
      cat("\\input{", chunkprefix, "}\n", sep = "", file = object$output)
      linesout[thisline + 1] <- srcline
      filenumout[thisline + 1] <- srcfilenum
      thisline <- thisline + 1
    }
    if (length(devs)) {
      if (options$figs.only) 
        devoffs[[1]]()
      for (i in seq_along(devs)) {
        if (options$figs.only && i == 1) 
          next
        devs[[i]](name = chunkprefix, width = options$width, height = options$height, options)
        err <- tryCatch({
          SweaveHooks(options, run = TRUE)
          eval(chunkexps, envir = .GlobalEnv)
        }, error = function(e) {
          devoffs[[i]]()
          stop(conditionMessage(e), call. = FALSE, domain = NA)
        })
        devoffs[[i]]()
      }
      if (options$include) {
        cat("\\includegraphics{", chunkprefix, "}\n", sep = "", file = object$output)
        linesout[thisline + 1] <- srcline
        filenumout[thisline + 1] <- srcfilenum
        thisline <- thisline + 1
      }
    }
    object$linesout <- c(object$linesout, linesout)
    object$filenumout <- c(object$filenumout, filenumout)
    object
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
maphash
list(`package:utils` = function (h, FUN) 
  invisible(.External(C_maphash_Ext, h, FUN)), function (h, FUN) 
    invisible(.External(C_maphash_Ext, h, FUN)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
memory.limit
list(`package:utils` = function (size = NA) 
{
  warning("'memory.limit()' is no longer supported", call. = FALSE)
  Inf
}, function (size = NA) 
{
  warning("'memory.limit()' is no longer supported", call. = FALSE)
  Inf
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
memory.size
list(`package:utils` = function (max = FALSE) 
{
  warning("'memory.size()' is no longer supported", call. = FALSE)
  Inf
}, function (max = FALSE) 
{
  warning("'memory.size()' is no longer supported", call. = FALSE)
  Inf
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
menu
list(`package:utils` = function (choices, graphics = FALSE, title = NULL) 
{
  if (!interactive()) 
    stop("menu() cannot be used non-interactively")
  if (isTRUE(graphics)) {
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA" || (capabilities("tcltk") && capabilities("X11") && suppressWarnings(tcltk::.TkUp))) {
      res <- select.list(choices, multiple = FALSE, title = title, graphics = TRUE)
      return(match(res, choices, nomatch = 0))
    }
  }
  nc <- length(choices)
  if (length(title) && nzchar(title[1])) 
    cat(title[1], "\n")
  op <- paste0(format(seq_len(nc)), ": ", choices)
  if (nc > 10) {
    fop <- format(op)
    nw <- nchar(fop[1], "w") + 2
    ncol <- getOption("width")%/%nw
    if (ncol > 1) 
      op <- paste0(fop, c(rep.int("  ", min(nc, ncol) - 1), "\n"), collapse = "")
  }
  cat("", op, "", sep = "\n")
  repeat {
    ind <- .Call(C_menu, as.character(choices))
    if (ind <= nc) 
      return(ind)
    cat(gettext("Enter an item from the menu, or 0 to exit\n"))
  }
}, function (choices, graphics = FALSE, title = NULL) 
{
  if (!interactive()) 
    stop("menu() cannot be used non-interactively")
  if (isTRUE(graphics)) {
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA" || (capabilities("tcltk") && capabilities("X11") && suppressWarnings(tcltk::.TkUp))) {
      res <- select.list(choices, multiple = FALSE, title = title, graphics = TRUE)
      return(match(res, choices, nomatch = 0))
    }
  }
  nc <- length(choices)
  if (length(title) && nzchar(title[1])) 
    cat(title[1], "\n")
  op <- paste0(format(seq_len(nc)), ": ", choices)
  if (nc > 10) {
    fop <- format(op)
    nw <- nchar(fop[1], "w") + 2
    ncol <- getOption("width")%/%nw
    if (ncol > 1) 
      op <- paste0(fop, c(rep.int("  ", min(nc, ncol) - 1), "\n"), collapse = "")
  }
  cat("", op, "", sep = "\n")
  repeat {
    ind <- .Call(C_menu, as.character(choices))
    if (ind <= nc) 
      return(ind)
    cat(gettext("Enter an item from the menu, or 0 to exit\n"))
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
methods
list(`package:utils` = function (generic.function, class) 
{
  envir <- parent.frame()
  if (!missing(generic.function) && !is.character(generic.function)) {
    what <- substitute(generic.function)
    generic.function <- if (is.function(generic.function) && is.call(what) && (deparse(what[[1]], nlines = 1) %in% c("::", ":::"))) {
      what <- as.character(what[2:3])
      envir <- asNamespace(what[[1]])
      what[[2]]
    }
    else deparse(what)
  }
  if (!missing(class) && !is.character(class)) 
    class <- deparse1(substitute(class))
  s3 <- .S3methods(generic.function, class, envir)
  s4 <- if (.isMethodsDispatchOn()) 
    methods::.S4methods(generic.function, class)
  .MethodsFunction(s3, s4, missing(generic.function))
}, function (generic.function, class) 
{
  envir <- parent.frame()
  if (!missing(generic.function) && !is.character(generic.function)) {
    what <- substitute(generic.function)
    generic.function <- if (is.function(generic.function) && is.call(what) && (deparse(what[[1]], nlines = 1) %in% c("::", ":::"))) {
      what <- as.character(what[2:3])
      envir <- asNamespace(what[[1]])
      what[[2]]
    }
    else deparse(what)
  }
  if (!missing(class) && !is.character(class)) 
    class <- deparse1(substitute(class))
  s3 <- .S3methods(generic.function, class, envir)
  s4 <- if (.isMethodsDispatchOn()) 
    methods::.S4methods(generic.function, class)
  .MethodsFunction(s3, s4, missing(generic.function))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
mirror2html
list(`package:utils` = function (mirrors = NULL, file = "mirrors.html", head = "mirrors-head.html", foot = "mirrors-foot.html") 
{
  if (is.null(mirrors)) {
    mirrors <- getCRANmirrors(all = FALSE, local.only = TRUE)
  }
  mirrors$Host <- gsub("&", "&amp;", mirrors$Host, fixed = TRUE)
  z <- NULL
  if (file.exists(head)) 
    z <- readLines(head)
  z <- c(z, "<dl>")
  for (country in unique(mirrors$Country)) {
    m <- mirrors[mirrors$Country == country, ]
    z <- c(z, paste0("<dt>", country, "</dt>"), "<dd>", "<table border=0 style=\"width: 90%;\">")
    for (k in seq_len(nrow(m))) {
      z <- c(z, "<tr>", "<td style=\"width: 45%;\">", sprintf("<a href=\"%s\" target=\"_top\">%s</a>", m$URL[k], m$URL[k]), "</td>\n", "<td>", m$Host[k], "</td>", "</tr>")
    }
    z <- c(z, "</table>", "</dd>")
  }
  z <- c(z, "</dl>")
  if (file.exists(foot)) 
    z <- c(z, readLines(foot))
  if (file != "") 
    writeLines(z, file)
  invisible(z)
}, function (mirrors = NULL, file = "mirrors.html", head = "mirrors-head.html", foot = "mirrors-foot.html") 
{
  if (is.null(mirrors)) {
    mirrors <- getCRANmirrors(all = FALSE, local.only = TRUE)
  }
  mirrors$Host <- gsub("&", "&amp;", mirrors$Host, fixed = TRUE)
  z <- NULL
  if (file.exists(head)) 
    z <- readLines(head)
  z <- c(z, "<dl>")
  for (country in unique(mirrors$Country)) {
    m <- mirrors[mirrors$Country == country, ]
    z <- c(z, paste0("<dt>", country, "</dt>"), "<dd>", "<table border=0 style=\"width: 90%;\">")
    for (k in seq_len(nrow(m))) {
      z <- c(z, "<tr>", "<td style=\"width: 45%;\">", sprintf("<a href=\"%s\" target=\"_top\">%s</a>", m$URL[k], m$URL[k]), "</td>\n", "<td>", m$Host[k], "</td>", "</tr>")
    }
    z <- c(z, "</table>", "</dd>")
  }
  z <- c(z, "</dl>")
  if (file.exists(foot)) 
    z <- c(z, readLines(foot))
  if (file != "") 
    writeLines(z, file)
  invisible(z)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
modifyList
list(`package:utils` = function (x, val, keep.null = FALSE) 
{
  stopifnot(is.list(x), is.list(val))
  xnames <- names(x)
  vnames <- names(val)
  vnames <- vnames[nzchar(vnames)]
  if (keep.null) {
    for (v in vnames) {
      x[v] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]])) 
        list(modifyList(x[[v]], val[[v]], keep.null = keep.null))
      else val[v]
    }
  }
  else {
    for (v in vnames) {
      x[[v]] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]])) 
        modifyList(x[[v]], val[[v]], keep.null = keep.null)
      else val[[v]]
    }
  }
  x
}, function (x, val, keep.null = FALSE) 
{
  stopifnot(is.list(x), is.list(val))
  xnames <- names(x)
  vnames <- names(val)
  vnames <- vnames[nzchar(vnames)]
  if (keep.null) {
    for (v in vnames) {
      x[v] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]])) 
        list(modifyList(x[[v]], val[[v]], keep.null = keep.null))
      else val[v]
    }
  }
  else {
    for (v in vnames) {
      x[[v]] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]])) 
        modifyList(x[[v]], val[[v]], keep.null = keep.null)
      else val[[v]]
    }
  }
  x
}, function (...) 
{
  abort(glue("\n    Please use `modify_list()` instead of `modifyList()` for better performance.\n    See the vignette 'ggplot2 internal programming guidelines' for details.\n  "))
})
c("package:utils", "namespace:utils", "namespace:ggplot2")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
new.packages
list(`package:utils` = function (lib.loc = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), instPkgs = installed.packages(lib.loc = lib.loc, ...), method, available = NULL, ask = FALSE, ..., type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  ask
  if (type == "both" && (!missing(contriburl) || !is.null(available))) {
    stop("specifying 'contriburl' or 'available' requires a single type, not type = \"both\"")
  }
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (!is.matrix(instPkgs)) 
    stop(gettextf("no installed packages for (invalid?) 'lib.loc=%s'", lib.loc), domain = NA)
  if (is.null(available)) 
    available <- available.packages(contriburl = contriburl, method = method, ...)
  installed <- unique(instPkgs[, "Package"])
  poss <- sort(unique(available[, "Package"]))
  res <- setdiff(poss, installed)
  update <- character()
  graphics <- FALSE
  if (is.character(ask) && ask == "graphics") {
    ask <- TRUE
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA" || (capabilities("tcltk") && capabilities("X11"))) 
      graphics <- TRUE
  }
  if (isTRUE(ask)) {
    if (length(res)) 
      update <- res[match(select.list(res, multiple = TRUE, title = "New packages to be installed", graphics = graphics), res)]
    else message("no new packages are available")
  }
  if (length(update)) {
    if (type == "both") 
      install.packages(update, lib = lib.loc[1], method = method, type = type, ...)
    else install.packages(update, lib = lib.loc[1], contriburl = contriburl, method = method, available = available, type = type, ...)
    dirs <- list.files(lib.loc[1])
    updated <- update[update %in% dirs]
    res <- res[!res %in% updated]
  }
  res
}, function (lib.loc = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), instPkgs = installed.packages(lib.loc = lib.loc, ...), method, available = NULL, ask = FALSE, ..., type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  ask
  if (type == "both" && (!missing(contriburl) || !is.null(available))) {
    stop("specifying 'contriburl' or 'available' requires a single type, not type = \"both\"")
  }
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (!is.matrix(instPkgs)) 
    stop(gettextf("no installed packages for (invalid?) 'lib.loc=%s'", lib.loc), domain = NA)
  if (is.null(available)) 
    available <- available.packages(contriburl = contriburl, method = method, ...)
  installed <- unique(instPkgs[, "Package"])
  poss <- sort(unique(available[, "Package"]))
  res <- setdiff(poss, installed)
  update <- character()
  graphics <- FALSE
  if (is.character(ask) && ask == "graphics") {
    ask <- TRUE
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA" || (capabilities("tcltk") && capabilities("X11"))) 
      graphics <- TRUE
  }
  if (isTRUE(ask)) {
    if (length(res)) 
      update <- res[match(select.list(res, multiple = TRUE, title = "New packages to be installed", graphics = graphics), res)]
    else message("no new packages are available")
  }
  if (length(update)) {
    if (type == "both") 
      install.packages(update, lib = lib.loc[1], method = method, type = type, ...)
    else install.packages(update, lib = lib.loc[1], contriburl = contriburl, method = method, available = available, type = type, ...)
    dirs <- list.files(lib.loc[1])
    updated <- update[update %in% dirs]
    res <- res[!res %in% updated]
  }
  res
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
news
list(`package:utils` = function (query, package = "R", lib.loc = NULL, format = NULL, reader = NULL, db = NULL) 
{
  if (new.db <- is.null(db)) {
    db <- if (package == "R") 
      tools:::.build_news_db_from_R_NEWS_Rd()
    else if (package == "R-3") 
      tools:::.build_news_db_from_R_NEWS_Rd(Rfile = "NEWS.3.rds")
    else if (package == "R-2") 
      tools:::.build_news_db_from_R_NEWS_Rd(Rfile = "NEWS.2.rds")
    else tools:::.build_news_db(package, lib.loc, format, reader)
  }
  if (is.null(db)) 
    return(NULL)
  if (new.db) 
    attr(db, "package") <- package
  if (missing(query)) 
    return(db)
  db1 <- db
  version <- db$Version
  pos <- regexpr(sprintf("^%s", .standard_regexps()$valid_numeric_version), version)
  if (any(ind <- (pos > -1))) 
    version[ind] <- substring(version[ind], 1, attr(pos, "match.length")[ind])
  db1$Version <- numeric_version(version, strict = FALSE)
  db1$Date <- as.Date(db$Date)
  r <- eval(substitute(query), db1, parent.frame())
  if (!is.null(r)) {
    if (!is.logical(r) || length(r) != length(version)) 
      stop("invalid query")
    r <- r & !is.na(r)
    db <- db[r, ]
    if (!all(r)) 
      attr(db, "subset") <- r
  }
  db
}, function (query, package = "R", lib.loc = NULL, format = NULL, reader = NULL, db = NULL) 
{
  if (new.db <- is.null(db)) {
    db <- if (package == "R") 
      tools:::.build_news_db_from_R_NEWS_Rd()
    else if (package == "R-3") 
      tools:::.build_news_db_from_R_NEWS_Rd(Rfile = "NEWS.3.rds")
    else if (package == "R-2") 
      tools:::.build_news_db_from_R_NEWS_Rd(Rfile = "NEWS.2.rds")
    else tools:::.build_news_db(package, lib.loc, format, reader)
  }
  if (is.null(db)) 
    return(NULL)
  if (new.db) 
    attr(db, "package") <- package
  if (missing(query)) 
    return(db)
  db1 <- db
  version <- db$Version
  pos <- regexpr(sprintf("^%s", .standard_regexps()$valid_numeric_version), version)
  if (any(ind <- (pos > -1))) 
    version[ind] <- substring(version[ind], 1, attr(pos, "match.length")[ind])
  db1$Version <- numeric_version(version, strict = FALSE)
  db1$Date <- as.Date(db$Date)
  r <- eval(substitute(query), db1, parent.frame())
  if (!is.null(r)) {
    if (!is.logical(r) || length(r) != length(version)) 
      stop("invalid query")
    r <- r & !is.na(r)
    db <- db[r, ]
    if (!all(r)) 
      attr(db, "subset") <- r
  }
  db
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
numhash
list(`package:utils` = function (h) 
  .External(C_numhash_Ext, h), function (h) 
    .External(C_numhash_Ext, h))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
object.size
list(`package:utils` = function (x) 
  structure(.Call(C_objectSize, x), class = "object_size"), function (x) 
    structure(.Call(C_objectSize, x), class = "object_size"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
old.packages
list(`package:utils` = function (lib.loc = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), instPkgs = installed.packages(lib.loc = lib.loc, ...), method, available = NULL, checkBuilt = FALSE, ..., type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (!missing(instPkgs)) {
    if (!is.matrix(instPkgs) || !is.character(instPkgs[, "Package"])) 
      stop("ill-formed 'instPkgs' matrix")
  }
  if (NROW(instPkgs) == 0) 
    return(NULL)
  available <- if (is.null(available)) 
    available.packages(contriburl = contriburl, method = method, ...)
  else tools:::.remove_stale_dups(available)
  update <- NULL
  currentR <- minorR <- getRversion()
  minorR[[c(1, 3)]] <- 0
  for (k in 1:nrow(instPkgs)) {
    if (instPkgs[k, "Priority"] %in% "base") 
      next
    z <- match(instPkgs[k, "Package"], available[, "Package"])
    if (is.na(z)) 
      next
    onRepos <- available[z, ]
    if ((!checkBuilt || package_version(instPkgs[k, "Built"]) >= minorR) && package_version(onRepos["Version"]) <= package_version(instPkgs[k, "Version"])) 
      next
    deps <- onRepos["Depends"]
    if (!is.na(deps)) {
      Rdeps <- tools:::.split_dependencies(deps)[["R", exact = TRUE]]
      if (length(Rdeps) > 1 && !do.call(Rdeps$op, list(currentR, Rdeps$version))) 
        next
    }
    update <- rbind(update, c(instPkgs[k, c("Package", "LibPath", "Version", "Built")], onRepos["Version"], onRepos["Repository"]))
  }
  if (!is.null(update)) 
    colnames(update) <- c("Package", "LibPath", "Installed", "Built", "ReposVer", "Repository")
  rownames(update) <- update[, "Package"]
  update[!duplicated(update), , drop = FALSE]
}, function (lib.loc = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), instPkgs = installed.packages(lib.loc = lib.loc, ...), method, available = NULL, checkBuilt = FALSE, ..., type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (!missing(instPkgs)) {
    if (!is.matrix(instPkgs) || !is.character(instPkgs[, "Package"])) 
      stop("ill-formed 'instPkgs' matrix")
  }
  if (NROW(instPkgs) == 0) 
    return(NULL)
  available <- if (is.null(available)) 
    available.packages(contriburl = contriburl, method = method, ...)
  else tools:::.remove_stale_dups(available)
  update <- NULL
  currentR <- minorR <- getRversion()
  minorR[[c(1, 3)]] <- 0
  for (k in 1:nrow(instPkgs)) {
    if (instPkgs[k, "Priority"] %in% "base") 
      next
    z <- match(instPkgs[k, "Package"], available[, "Package"])
    if (is.na(z)) 
      next
    onRepos <- available[z, ]
    if ((!checkBuilt || package_version(instPkgs[k, "Built"]) >= minorR) && package_version(onRepos["Version"]) <= package_version(instPkgs[k, "Version"])) 
      next
    deps <- onRepos["Depends"]
    if (!is.na(deps)) {
      Rdeps <- tools:::.split_dependencies(deps)[["R", exact = TRUE]]
      if (length(Rdeps) > 1 && !do.call(Rdeps$op, list(currentR, Rdeps$version))) 
        next
    }
    update <- rbind(update, c(instPkgs[k, c("Package", "LibPath", "Version", "Built")], onRepos["Version"], onRepos["Repository"]))
  }
  if (!is.null(update)) 
    colnames(update) <- c("Package", "LibPath", "Installed", "Built", "ReposVer", "Repository")
  rownames(update) <- update[, "Package"]
  update[!duplicated(update), , drop = FALSE]
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
osVersion
list(`package:utils` = "Windows 10 x64 (build 19044)", "Windows 10 x64 (build 19044)")
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
package.skeleton
list(`package:utils` = function (name = "anRpackage", list = character(), environment = .GlobalEnv, path = ".", force = FALSE, code_files = character(), encoding = "unknown") 
{
  if (!grepl(sprintf("^%s$", .standard_regexps()$valid_package_name), name)) 
    stop("Malformed package name.")
  safe.dir.create <- function(path) {
    if (!dir.exists(path) && !dir.create(path)) 
      stop(gettextf("cannot create directory '%s'", path), domain = NA)
  }
  if (!is.character(code_files)) 
    stop("'code_files' must be a character vector")
  use_code_files <- length(code_files) > 0
  envIsMissing <- missing(environment)
  if (missing(list)) {
    if (use_code_files) {
      environment <- new.env(hash = TRUE, parent = globalenv())
      methods::setPackageName(name, environment)
      for (cf in code_files) sys.source(cf, envir = environment)
    }
    list <- ls(environment, all.names = TRUE)
    if (identical(environment, .GlobalEnv)) 
      list <- list[list != ".Random.seed"]
  }
  if (!is.character(list)) 
    stop("'list' must be a character vector naming R objects")
  if (use_code_files || !envIsMissing) {
    classesList <- methods::getClasses(environment)
    classes0 <- .fixPackageFileNames(classesList)
    names(classes0) <- classesList
    methodsList <- methods::getGenerics(environment)
    methods0 <- .fixPackageFileNames(methodsList)
    names(methods0) <- methodsList
  }
  else {
    classesList <- methodsList <- character()
  }
  usingS4 <- length(classesList) > 0 || length(methodsList) > 0
  have <- vapply(list, exists, NA, envir = environment)
  if (any(!have)) 
    warning(sprintf(ngettext(sum(!have), "object '%s' not found", "objects '%s' not found"), paste(sQuote(list[!have]), collapse = ", ")), domain = NA)
  list <- list[have]
  if (!length(list)) 
    stop("no R objects specified or available")
  message("Creating directories ...", domain = NA)
  dir <- file.path(path, name)
  if (file.exists(dir) && !force) 
    stop(gettextf("directory '%s' already exists", dir), domain = NA)
  safe.dir.create(dir)
  safe.dir.create(code_dir <- file.path(dir, "R"))
  safe.dir.create(docs_dir <- file.path(dir, "man"))
  safe.dir.create(data_dir <- file.path(dir, "data"))
  message("Creating DESCRIPTION ...", domain = NA)
  description <- file(file.path(dir, "DESCRIPTION"), "wt")
  cat("Package: ", name, "\n", "Type: Package\n", "Title: What the package does (short line)\n", "Version: 1.0\n", "Date: ", format(Sys.time(), format = "%Y-%m-%d"), "\n", "Author: Who wrote it\n", "Maintainer: Who to complain to <yourfault@somewhere.net>\n", "Description: More about what it does (maybe more than one line)\n", "License: What license is it under?\n", if (usingS4) 
    "Imports: methods\n", if (nzchar(encoding) && encoding != "unknown") 
      paste0("Encoding: ", encoding, "\n"), file = description, sep = "")
  close(description)
  message("Creating NAMESPACE ...", domain = NA)
  out <- file(file.path(dir, "NAMESPACE"), "wt")
  list0 <- list[grepl("^[[:alpha:]]", list)]
  if (length(list0)) 
    writeLines(strwrap(sprintf("export(%s)", paste0("\"", list0, "\"", collapse = ", ")), exdent = 7), out)
  if (length(methodsList)) {
    cat("exportMethods(\n    ", file = out)
    cat(paste0("\"", methodsList, "\"", collapse = ",\n    "), "\n)\n", file = out)
  }
  if (length(classesList)) {
    cat("exportClasses(\n    ", file = out)
    cat(paste0("\"", classesList, "\"", collapse = ",\n     "), "\n)\n", file = out)
  }
  close(out)
  message("Creating Read-and-delete-me ...", domain = NA)
  out <- file(file.path(dir, "Read-and-delete-me"), "wt")
  msg <- c("* Edit the help file skeletons in 'man', possibly combining help files for multiple functions.", "* Edit the exports in 'NAMESPACE', and add necessary imports.", "* Put any C/C++/Fortran code in 'src'.", "* If you have compiled code, add a useDynLib() directive to 'NAMESPACE'.", "* Run R CMD build to build the package tarball.", "* Run R CMD check to check the package tarball.", "", "Read \"Writing R Extensions\" for more information.")
  writeLines(strwrap(msg, exdent = 2), out)
  close(out)
  internalObjInds <- grep("^\\.", list)
  internalObjs <- list[internalObjInds]
  if (length(internalObjInds)) 
    list <- list[-internalObjInds]
  list0 <- .fixPackageFileNames(list)
  names(list0) <- list
  if (!use_code_files) {
    message("Saving functions and data ...", domain = NA)
    if (length(internalObjInds)) 
      dump(internalObjs, file = file.path(code_dir, sprintf("%s-internal.R", name)), envir = environment)
    for (item in list) {
      objItem <- get(item, envir = environment)
      if (is.function(objItem)) {
        if (isS4(objItem)) 
          stop(gettextf("generic functions and other S4 objects (e.g., '%s') cannot be dumped; use the 'code_files' argument", item), domain = NA)
        dump(item, file = file.path(code_dir, sprintf("%s.R", list0[item])), envir = environment)
      }
      else try(save(list = item, envir = environment, file = file.path(data_dir, sprintf("%s.rda", item))))
    }
  }
  else {
    message("Copying code files ...", domain = NA)
    file.copy(code_files, code_dir)
    R_files <- tools::list_files_with_type(code_dir, "code", full.names = FALSE, OS_subdirs = "")
    code_files <- basename(code_files)
    wrong <- code_files[is.na(match(code_files, R_files))]
    if (length(wrong)) {
      warning("Invalid file name(s) for R code in ", code_dir, ":\n", strwrap(paste(sQuote(wrong), collapse = ", "), indent = 2), "\n are now renamed to 'z<name>.R'", domain = NA)
      file.rename(from = file.path(code_dir, wrong), to = file.path(code_dir, paste0("z", sub("(\\.[^.]*)?$", ".R", wrong))))
    }
  }
  message("Making help files ...", domain = NA)
  yy <- try(suppressMessages({
    promptPackage(name, filename = file.path(docs_dir, sprintf("%s-package.Rd", name)), lib.loc = path)
    sapply(list, function(item) {
      prompt(get(item, envir = environment), name = item, filename = file.path(docs_dir, sprintf("%s.Rd", list0[item])))
    })
    sapply(classesList, function(item) {
      methods::promptClass(item, filename = file.path(docs_dir, sprintf("%s-class.Rd", classes0[item])), where = environment)
    })
    sapply(methodsList, function(item) {
      methods::promptMethods(item, filename = file.path(docs_dir, sprintf("%s-methods.Rd", methods0[item])), methods::findMethods(item, where = environment))
    })
  }))
  for (item in methodsList) {
    if (exists(item, envir = environment, inherits = FALSE)) {
      ff <- get(item, envir = environment)
      if (methods::is(ff, "genericFunction") && !identical(ff@package, name)) 
        file.remove(file.path(docs_dir, sprintf("%s.Rd", list0[item])))
    }
  }
  if (inherits(yy, "try-error")) 
    stop(yy)
  if (length(list.files(code_dir)) == 0) 
    unlink(code_dir, recursive = TRUE)
  if (length(list.files(data_dir)) == 0) 
    unlink(data_dir, recursive = TRUE)
  message("Done.", domain = NA)
  message(sprintf("Further steps are described in '%s'.", file.path(dir, "Read-and-delete-me")), domain = NA)
}, function (name = "anRpackage", list = character(), environment = .GlobalEnv, path = ".", force = FALSE, code_files = character(), encoding = "unknown") 
{
  if (!grepl(sprintf("^%s$", .standard_regexps()$valid_package_name), name)) 
    stop("Malformed package name.")
  safe.dir.create <- function(path) {
    if (!dir.exists(path) && !dir.create(path)) 
      stop(gettextf("cannot create directory '%s'", path), domain = NA)
  }
  if (!is.character(code_files)) 
    stop("'code_files' must be a character vector")
  use_code_files <- length(code_files) > 0
  envIsMissing <- missing(environment)
  if (missing(list)) {
    if (use_code_files) {
      environment <- new.env(hash = TRUE, parent = globalenv())
      methods::setPackageName(name, environment)
      for (cf in code_files) sys.source(cf, envir = environment)
    }
    list <- ls(environment, all.names = TRUE)
    if (identical(environment, .GlobalEnv)) 
      list <- list[list != ".Random.seed"]
  }
  if (!is.character(list)) 
    stop("'list' must be a character vector naming R objects")
  if (use_code_files || !envIsMissing) {
    classesList <- methods::getClasses(environment)
    classes0 <- .fixPackageFileNames(classesList)
    names(classes0) <- classesList
    methodsList <- methods::getGenerics(environment)
    methods0 <- .fixPackageFileNames(methodsList)
    names(methods0) <- methodsList
  }
  else {
    classesList <- methodsList <- character()
  }
  usingS4 <- length(classesList) > 0 || length(methodsList) > 0
  have <- vapply(list, exists, NA, envir = environment)
  if (any(!have)) 
    warning(sprintf(ngettext(sum(!have), "object '%s' not found", "objects '%s' not found"), paste(sQuote(list[!have]), collapse = ", ")), domain = NA)
  list <- list[have]
  if (!length(list)) 
    stop("no R objects specified or available")
  message("Creating directories ...", domain = NA)
  dir <- file.path(path, name)
  if (file.exists(dir) && !force) 
    stop(gettextf("directory '%s' already exists", dir), domain = NA)
  safe.dir.create(dir)
  safe.dir.create(code_dir <- file.path(dir, "R"))
  safe.dir.create(docs_dir <- file.path(dir, "man"))
  safe.dir.create(data_dir <- file.path(dir, "data"))
  message("Creating DESCRIPTION ...", domain = NA)
  description <- file(file.path(dir, "DESCRIPTION"), "wt")
  cat("Package: ", name, "\n", "Type: Package\n", "Title: What the package does (short line)\n", "Version: 1.0\n", "Date: ", format(Sys.time(), format = "%Y-%m-%d"), "\n", "Author: Who wrote it\n", "Maintainer: Who to complain to <yourfault@somewhere.net>\n", "Description: More about what it does (maybe more than one line)\n", "License: What license is it under?\n", if (usingS4) 
    "Imports: methods\n", if (nzchar(encoding) && encoding != "unknown") 
      paste0("Encoding: ", encoding, "\n"), file = description, sep = "")
  close(description)
  message("Creating NAMESPACE ...", domain = NA)
  out <- file(file.path(dir, "NAMESPACE"), "wt")
  list0 <- list[grepl("^[[:alpha:]]", list)]
  if (length(list0)) 
    writeLines(strwrap(sprintf("export(%s)", paste0("\"", list0, "\"", collapse = ", ")), exdent = 7), out)
  if (length(methodsList)) {
    cat("exportMethods(\n    ", file = out)
    cat(paste0("\"", methodsList, "\"", collapse = ",\n    "), "\n)\n", file = out)
  }
  if (length(classesList)) {
    cat("exportClasses(\n    ", file = out)
    cat(paste0("\"", classesList, "\"", collapse = ",\n     "), "\n)\n", file = out)
  }
  close(out)
  message("Creating Read-and-delete-me ...", domain = NA)
  out <- file(file.path(dir, "Read-and-delete-me"), "wt")
  msg <- c("* Edit the help file skeletons in 'man', possibly combining help files for multiple functions.", "* Edit the exports in 'NAMESPACE', and add necessary imports.", "* Put any C/C++/Fortran code in 'src'.", "* If you have compiled code, add a useDynLib() directive to 'NAMESPACE'.", "* Run R CMD build to build the package tarball.", "* Run R CMD check to check the package tarball.", "", "Read \"Writing R Extensions\" for more information.")
  writeLines(strwrap(msg, exdent = 2), out)
  close(out)
  internalObjInds <- grep("^\\.", list)
  internalObjs <- list[internalObjInds]
  if (length(internalObjInds)) 
    list <- list[-internalObjInds]
  list0 <- .fixPackageFileNames(list)
  names(list0) <- list
  if (!use_code_files) {
    message("Saving functions and data ...", domain = NA)
    if (length(internalObjInds)) 
      dump(internalObjs, file = file.path(code_dir, sprintf("%s-internal.R", name)), envir = environment)
    for (item in list) {
      objItem <- get(item, envir = environment)
      if (is.function(objItem)) {
        if (isS4(objItem)) 
          stop(gettextf("generic functions and other S4 objects (e.g., '%s') cannot be dumped; use the 'code_files' argument", item), domain = NA)
        dump(item, file = file.path(code_dir, sprintf("%s.R", list0[item])), envir = environment)
      }
      else try(save(list = item, envir = environment, file = file.path(data_dir, sprintf("%s.rda", item))))
    }
  }
  else {
    message("Copying code files ...", domain = NA)
    file.copy(code_files, code_dir)
    R_files <- tools::list_files_with_type(code_dir, "code", full.names = FALSE, OS_subdirs = "")
    code_files <- basename(code_files)
    wrong <- code_files[is.na(match(code_files, R_files))]
    if (length(wrong)) {
      warning("Invalid file name(s) for R code in ", code_dir, ":\n", strwrap(paste(sQuote(wrong), collapse = ", "), indent = 2), "\n are now renamed to 'z<name>.R'", domain = NA)
      file.rename(from = file.path(code_dir, wrong), to = file.path(code_dir, paste0("z", sub("(\\.[^.]*)?$", ".R", wrong))))
    }
  }
  message("Making help files ...", domain = NA)
  yy <- try(suppressMessages({
    promptPackage(name, filename = file.path(docs_dir, sprintf("%s-package.Rd", name)), lib.loc = path)
    sapply(list, function(item) {
      prompt(get(item, envir = environment), name = item, filename = file.path(docs_dir, sprintf("%s.Rd", list0[item])))
    })
    sapply(classesList, function(item) {
      methods::promptClass(item, filename = file.path(docs_dir, sprintf("%s-class.Rd", classes0[item])), where = environment)
    })
    sapply(methodsList, function(item) {
      methods::promptMethods(item, filename = file.path(docs_dir, sprintf("%s-methods.Rd", methods0[item])), methods::findMethods(item, where = environment))
    })
  }))
  for (item in methodsList) {
    if (exists(item, envir = environment, inherits = FALSE)) {
      ff <- get(item, envir = environment)
      if (methods::is(ff, "genericFunction") && !identical(ff@package, name)) 
        file.remove(file.path(docs_dir, sprintf("%s.Rd", list0[item])))
    }
  }
  if (inherits(yy, "try-error")) 
    stop(yy)
  if (length(list.files(code_dir)) == 0) 
    unlink(code_dir, recursive = TRUE)
  if (length(list.files(data_dir)) == 0) 
    unlink(data_dir, recursive = TRUE)
  message("Done.", domain = NA)
  message(sprintf("Further steps are described in '%s'.", file.path(dir, "Read-and-delete-me")), domain = NA)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageDate
list(`package:utils` = function (pkg, lib.loc = NULL, date.fields = c("Date", "Packaged", "Date/Publication", "Built"), tryFormats = c("%Y-%m-%d", "%Y/%m/%d", "%D", "%m/%d/%y"), desc = packageDescription(pkg, lib.loc = lib.loc, fields = date.fields)) 
{
  useDesc <- is.list(desc) && length(names(desc)) >= 1
  for (fld in date.fields) {
    res <- if (useDesc) {
      r <- desc[[fld]]
      if (is.null(r)) 
        NA
      else r
    }
    else packageDescription(pkg, lib.loc = lib.loc, fields = fld)
    res <- if (fld == "Built" && !is.na(res)) 
      tryCatch(asDateBuilt(res), error = function(e) {
        warning("Invalid \"Built\": ", conditionMessage(e))
        NA
      })
    else as.Date(res, tryFormats = tryFormats, optional = TRUE)
    if (!is.na(res)) 
      break
  }
  if (is.na(res)) 
    res
  else structure(res, field = fld)
}, function (pkg, lib.loc = NULL, date.fields = c("Date", "Packaged", "Date/Publication", "Built"), tryFormats = c("%Y-%m-%d", "%Y/%m/%d", "%D", "%m/%d/%y"), desc = packageDescription(pkg, lib.loc = lib.loc, fields = date.fields)) 
{
  useDesc <- is.list(desc) && length(names(desc)) >= 1
  for (fld in date.fields) {
    res <- if (useDesc) {
      r <- desc[[fld]]
      if (is.null(r)) 
        NA
      else r
    }
    else packageDescription(pkg, lib.loc = lib.loc, fields = fld)
    res <- if (fld == "Built" && !is.na(res)) 
      tryCatch(asDateBuilt(res), error = function(e) {
        warning("Invalid \"Built\": ", conditionMessage(e))
        NA
      })
    else as.Date(res, tryFormats = tryFormats, optional = TRUE)
    if (!is.na(res)) 
      break
  }
  if (is.na(res)) 
    res
  else structure(res, field = fld)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageDescription
list(`package:utils` = function (pkg, lib.loc = NULL, fields = NULL, drop = TRUE, encoding = "") 
{
  retval <- list()
  if (!is.null(fields)) {
    fields <- as.character(fields)
    retval[fields] <- NA
  }
  pkgpath <- if (is.null(lib.loc)) {
    if (pkg == "base") 
      file.path(.Library, "base")
    else if (isNamespaceLoaded(pkg)) 
      getNamespaceInfo(pkg, "path")
    else if ((envname <- paste0("package:", pkg)) %in% search()) {
      attr(as.environment(envname), "path")
    }
  }
  if (is.null(pkgpath)) 
    pkgpath <- ""
  if (pkgpath == "") {
    libs <- if (is.null(lib.loc)) 
      .libPaths()
    else lib.loc
    for (lib in libs) if (file.access(file.path(lib, pkg), 5) == 0) {
      pkgpath <- file.path(lib, pkg)
      break
    }
  }
  if (pkgpath == "") {
    warning(gettextf("no package '%s' was found", pkg), domain = NA)
    return(NA)
  }
  if (file.exists(file <- file.path(pkgpath, "Meta", "package.rds"))) {
    desc <- readRDS(file)$DESCRIPTION
    if (length(desc) < 1) 
      stop(gettextf("metadata of package '%s' is corrupt", pkg), domain = NA)
    desc <- as.list(desc)
  }
  else if (file.exists(file <- file.path(pkgpath, "DESCRIPTION"))) {
    dcf <- read.dcf(file = file)
    if (NROW(dcf) < 1) 
      stop(gettextf("DESCRIPTION file of package '%s' is corrupt", pkg), domain = NA)
    desc <- as.list(dcf[1, ])
  }
  else file <- ""
  if (nzchar(file)) {
    enc <- desc[["Encoding"]]
    if (!is.null(enc) && !is.na(encoding)) {
      if (missing(encoding) && Sys.getlocale("LC_CTYPE") == "C") 
        encoding <- "ASCII//TRANSLIT"
      if (encoding != enc) {
        newdesc <- try(lapply(desc, iconv, from = enc, to = encoding))
        dOk <- function(nd) !inherits(nd, "error") && !anyNA(nd)
        ok <- dOk(newdesc)
        if (!ok) 
          ok <- dOk(newdesc <- try(lapply(desc, iconv, from = enc, to = paste0(encoding, "//TRANSLIT"))))
        if (!ok) 
          ok <- dOk(newdesc <- try(lapply(desc, iconv, from = enc, to = "ASCII//TRANSLIT", sub = "?")))
        if (ok) 
          desc <- newdesc
        else warning("'DESCRIPTION' file has an 'Encoding' field and re-encoding is not possible", call. = FALSE)
      }
    }
    if (!is.null(fields)) {
      ok <- names(desc) %in% fields
      retval[names(desc)[ok]] <- desc[ok]
    }
    else retval[names(desc)] <- desc
  }
  if ((file == "") || (length(retval) == 0)) {
    warning(gettextf("DESCRIPTION file of package '%s' is missing or broken", pkg), domain = NA)
    return(NA)
  }
  if (drop && length(fields) == 1) 
    return(retval[[1]])
  class(retval) <- "packageDescription"
  if (!is.null(fields)) 
    attr(retval, "fields") <- fields
  attr(retval, "file") <- file
  retval
}, function (pkg, lib.loc = NULL, fields = NULL, drop = TRUE, encoding = "") 
{
  retval <- list()
  if (!is.null(fields)) {
    fields <- as.character(fields)
    retval[fields] <- NA
  }
  pkgpath <- if (is.null(lib.loc)) {
    if (pkg == "base") 
      file.path(.Library, "base")
    else if (isNamespaceLoaded(pkg)) 
      getNamespaceInfo(pkg, "path")
    else if ((envname <- paste0("package:", pkg)) %in% search()) {
      attr(as.environment(envname), "path")
    }
  }
  if (is.null(pkgpath)) 
    pkgpath <- ""
  if (pkgpath == "") {
    libs <- if (is.null(lib.loc)) 
      .libPaths()
    else lib.loc
    for (lib in libs) if (file.access(file.path(lib, pkg), 5) == 0) {
      pkgpath <- file.path(lib, pkg)
      break
    }
  }
  if (pkgpath == "") {
    warning(gettextf("no package '%s' was found", pkg), domain = NA)
    return(NA)
  }
  if (file.exists(file <- file.path(pkgpath, "Meta", "package.rds"))) {
    desc <- readRDS(file)$DESCRIPTION
    if (length(desc) < 1) 
      stop(gettextf("metadata of package '%s' is corrupt", pkg), domain = NA)
    desc <- as.list(desc)
  }
  else if (file.exists(file <- file.path(pkgpath, "DESCRIPTION"))) {
    dcf <- read.dcf(file = file)
    if (NROW(dcf) < 1) 
      stop(gettextf("DESCRIPTION file of package '%s' is corrupt", pkg), domain = NA)
    desc <- as.list(dcf[1, ])
  }
  else file <- ""
  if (nzchar(file)) {
    enc <- desc[["Encoding"]]
    if (!is.null(enc) && !is.na(encoding)) {
      if (missing(encoding) && Sys.getlocale("LC_CTYPE") == "C") 
        encoding <- "ASCII//TRANSLIT"
      if (encoding != enc) {
        newdesc <- try(lapply(desc, iconv, from = enc, to = encoding))
        dOk <- function(nd) !inherits(nd, "error") && !anyNA(nd)
        ok <- dOk(newdesc)
        if (!ok) 
          ok <- dOk(newdesc <- try(lapply(desc, iconv, from = enc, to = paste0(encoding, "//TRANSLIT"))))
        if (!ok) 
          ok <- dOk(newdesc <- try(lapply(desc, iconv, from = enc, to = "ASCII//TRANSLIT", sub = "?")))
        if (ok) 
          desc <- newdesc
        else warning("'DESCRIPTION' file has an 'Encoding' field and re-encoding is not possible", call. = FALSE)
      }
    }
    if (!is.null(fields)) {
      ok <- names(desc) %in% fields
      retval[names(desc)[ok]] <- desc[ok]
    }
    else retval[names(desc)] <- desc
  }
  if ((file == "") || (length(retval) == 0)) {
    warning(gettextf("DESCRIPTION file of package '%s' is missing or broken", pkg), domain = NA)
    return(NA)
  }
  if (drop && length(fields) == 1) 
    return(retval[[1]])
  class(retval) <- "packageDescription"
  if (!is.null(fields)) 
    attr(retval, "fields") <- fields
  attr(retval, "file") <- file
  retval
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageName
list(`package:utils` = function (env = parent.frame()) 
{
  if (!is.environment(env)) 
    stop("'env' must be an environment")
  env <- topenv(env)
  if (!is.null(pn <- get0(".packageName", envir = env, inherits = FALSE))) 
    pn
  else if (identical(env, .BaseNamespaceEnv)) 
    "base"
}, function (env = parent.frame()) 
{
  if (!is.environment(env)) 
    stop("'env' must be an environment")
  env <- topenv(env)
  if (!is.null(pn <- get0(".packageName", envir = env, inherits = FALSE))) 
    pn
  else if (identical(env, .BaseNamespaceEnv)) 
    "base"
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageStatus
list(`package:utils` = function (lib.loc = NULL, repositories = NULL, method, type = getOption("pkgType"), ...) 
{
  newestVersion <- function(x) {
    vers <- package_version(x)
    max <- vers[1]
    for (i in seq_along(vers)) if (max < vers[i]) 
      max <- vers[i]
    which.max(vers == max)
  }
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (is.null(repositories)) 
    repositories <- contrib.url(getOption("repos"), type = type)
  char2df <- function(x) {
    y <- list()
    for (k in 1:ncol(x)) y[[k]] <- x[, k]
    attr(y, "names") <- colnames(x)
    attr(y, "row.names") <- make.unique(y[[1]])
    class(y) <- "data.frame"
    y
  }
  y <- char2df(installed.packages(lib.loc = lib.loc, ...))
  y[, "Status"] <- rep("ok", nrow(y))
  z <- available.packages(repositories, method, ...)
  ztab <- table(z[, "Package"])
  for (pkg in names(ztab)[ztab > 1]) {
    zrow <- which(z[, "Package"] == pkg)
    znewest <- newestVersion(z[zrow, "Version"])
    z <- z[-zrow[-znewest], ]
  }
  z <- cbind(z, Status = "not installed")
  z[z[, "Package"] %in% y$Package, "Status"] <- "installed"
  z <- char2df(z)
  attr(z, "row.names") <- z$Package
  for (k in seq_len(nrow(y))) {
    pkg <- y[k, "Package"]
    if (pkg %in% z$Package) {
      if (package_version(y[k, "Version"]) < package_version(z[pkg, "Version"])) {
        y[k, "Status"] <- "upgrade"
      }
    }
    else {
      if (!(y[k, "Priority"] %in% "base")) 
        y[k, "Status"] <- "unavailable"
    }
  }
  y$LibPath <- factor(y$LibPath, levels = lib.loc)
  y$Status <- factor(y$Status, levels = c("ok", "upgrade", "unavailable"))
  z$Repository <- factor(z$Repository, levels = repositories)
  z$Status <- factor(z$Status, levels = c("installed", "not installed"))
  retval <- list(inst = y, avail = z)
  class(retval) <- "packageStatus"
  retval
}, function (lib.loc = NULL, repositories = NULL, method, type = getOption("pkgType"), ...) 
{
  newestVersion <- function(x) {
    vers <- package_version(x)
    max <- vers[1]
    for (i in seq_along(vers)) if (max < vers[i]) 
      max <- vers[i]
    which.max(vers == max)
  }
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (is.null(repositories)) 
    repositories <- contrib.url(getOption("repos"), type = type)
  char2df <- function(x) {
    y <- list()
    for (k in 1:ncol(x)) y[[k]] <- x[, k]
    attr(y, "names") <- colnames(x)
    attr(y, "row.names") <- make.unique(y[[1]])
    class(y) <- "data.frame"
    y
  }
  y <- char2df(installed.packages(lib.loc = lib.loc, ...))
  y[, "Status"] <- rep("ok", nrow(y))
  z <- available.packages(repositories, method, ...)
  ztab <- table(z[, "Package"])
  for (pkg in names(ztab)[ztab > 1]) {
    zrow <- which(z[, "Package"] == pkg)
    znewest <- newestVersion(z[zrow, "Version"])
    z <- z[-zrow[-znewest], ]
  }
  z <- cbind(z, Status = "not installed")
  z[z[, "Package"] %in% y$Package, "Status"] <- "installed"
  z <- char2df(z)
  attr(z, "row.names") <- z$Package
  for (k in seq_len(nrow(y))) {
    pkg <- y[k, "Package"]
    if (pkg %in% z$Package) {
      if (package_version(y[k, "Version"]) < package_version(z[pkg, "Version"])) {
        y[k, "Status"] <- "upgrade"
      }
    }
    else {
      if (!(y[k, "Priority"] %in% "base")) 
        y[k, "Status"] <- "unavailable"
    }
  }
  y$LibPath <- factor(y$LibPath, levels = lib.loc)
  y$Status <- factor(y$Status, levels = c("ok", "upgrade", "unavailable"))
  z$Repository <- factor(z$Repository, levels = repositories)
  z$Status <- factor(z$Status, levels = c("installed", "not installed"))
  retval <- list(inst = y, avail = z)
  class(retval) <- "packageStatus"
  retval
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
packageVersion
list(`package:utils` = function (pkg, lib.loc = NULL) 
{
  res <- suppressWarnings(packageDescription(pkg, lib.loc = lib.loc, fields = "Version"))
  if (!is.na(res)) 
    package_version(res)
  else stop(packageNotFoundError(pkg, lib.loc, sys.call()))
}, function (pkg, lib.loc = NULL) 
{
  res <- suppressWarnings(packageDescription(pkg, lib.loc = lib.loc, fields = "Version"))
  if (!is.na(res)) 
    package_version(res)
  else stop(packageNotFoundError(pkg, lib.loc, sys.call()))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
page
list(`package:utils` = function (x, method = c("dput", "print"), ...) 
{
  local.file.show <- function(file, title = subx, delete.file = TRUE, pager = getOption("pager"), ...) file.show(file, title = title, delete.file = delete.file, pager = pager)
  local.dput <- function(x, file, title, delete.file, pager, ...) dput(x, file, ...)
  local.print <- function(x, title, delete.file, pager, ...) print(x, ...)
  if (is.character(x) && length(x) == 1) {
    subx <- x
    parent <- parent.frame()
    if (exists(subx, envir = parent)) 
      x <- get(subx, envir = parent)
    else stop(gettextf("no object named '%s' to show", x), domain = NA)
  }
  else {
    subx <- deparse1(substitute(x))
  }
  file <- tempfile("Rpage.")
  if (match.arg(method) == "dput") 
    local.dput(x, file, ...)
  else {
    sink(file)
    local.print(x, ...)
    sink()
  }
  local.file.show(file, ...)
}, function (x, method = c("dput", "print"), ...) 
{
  local.file.show <- function(file, title = subx, delete.file = TRUE, pager = getOption("pager"), ...) file.show(file, title = title, delete.file = delete.file, pager = pager)
  local.dput <- function(x, file, title, delete.file, pager, ...) dput(x, file, ...)
  local.print <- function(x, title, delete.file, pager, ...) print(x, ...)
  if (is.character(x) && length(x) == 1) {
    subx <- x
    parent <- parent.frame()
    if (exists(subx, envir = parent)) 
      x <- get(subx, envir = parent)
    else stop(gettextf("no object named '%s' to show", x), domain = NA)
  }
  else {
    subx <- deparse1(substitute(x))
  }
  file <- tempfile("Rpage.")
  if (match.arg(method) == "dput") 
    local.dput(x, file, ...)
  else {
    sink(file)
    local.print(x, ...)
    sink()
  }
  local.file.show(file, ...)
}, function (..., title = NULL, theme = bs_theme(), lang = NULL) 
{
  as_page(shiny::bootstrapPage(..., title = title, theme = theme, lang = lang))
})
c("package:utils", "namespace:utils", "namespace:bslib")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
person
list(`package:utils` = function (given = NULL, family = NULL, middle = NULL, email = NULL, role = NULL, comment = NULL, first = NULL, last = NULL) 
{
  args <- list(given = given, family = family, middle = middle, email = email, role = role, comment = comment, first = first, last = last)
  if (all(vapply(args, is.null, NA))) 
    return(.person())
  args <- lapply(args, .listify)
  args_length <- lengths(args)
  if (!all(args_length_ok <- args_length %in% c(1, max(args_length)))) 
    warning(gettextf("Not all arguments are of the same length, the following need to be recycled: %s", paste(names(args)[!args_length_ok], collapse = ", ")), domain = NA)
  args <- lapply(args, function(x) rep_len(x, max(args_length)))
  person1 <- function(given = NULL, family = NULL, middle = NULL, email = NULL, role = NULL, comment = NULL, first = NULL, last = NULL) {
    if (!.is_not_nonempty_text(first)) {
      if (!.is_not_nonempty_text(given)) 
        stop(gettextf("Use either %s or %s/%s but not both.", sQuote("given"), sQuote("first"), sQuote("middle")), domain = NA)
      warning(gettextf("It is recommended to use %s instead of %s.", sQuote("given"), sQuote("first")), domain = NA)
      given <- first
    }
    if (!.is_not_nonempty_text(middle)) {
      warning(gettextf("It is recommended to use %s instead of %s.", sQuote("given"), sQuote("middle")), domain = NA)
      given <- c(given, unlist(strsplit(middle, "[[:space:]]+")))
    }
    if (!.is_not_nonempty_text(last)) {
      if (!.is_not_nonempty_text(family)) 
        stop(gettextf("Use either %s or %s but not both.", sQuote("family"), sQuote("last")), domain = NA)
      warning(gettextf("It is recommended to use %s instead of %s.", sQuote("family"), sQuote("last")), domain = NA)
      family <- last
    }
    if (.is_not_nonempty_text(given)) 
      given <- NULL
    if (.is_not_nonempty_text(family)) 
      family <- NULL
    if (.is_not_nonempty_text(email)) 
      email <- NULL
    if (.is_not_nonempty_text(role)) {
      if (!is.null(role)) 
        warning(sprintf(ngettext(length(role), "Invalid role specification: %s.", "Invalid role specifications: %s."), paste(sQuote(role), collapse = ", ")), domain = NA)
      role <- NULL
    }
    if (.is_not_nonempty_text(comment)) 
      comment <- NULL
    if (length(role)) 
      role <- .canonicalize_person_role(role)
    if (length(comment)) {
      ind <- grepl(sprintf("^https?://orcid.org/%s$", tools:::.ORCID_iD_regexp), comment)
      if (any(ind)) {
        if (is.null(names(comment))) 
          names(comment) <- ifelse(ind, "ORCID", "")
        else names(comment)[ind] <- "ORCID"
      }
    }
    rval <- list(given = given, family = family, role = role, email = email, comment = comment)
    if (any(ind <- (lengths(rval) == 0))) 
      rval[ind] <- vector("list", length = sum(ind))
    if (all(vapply(rval, is.null, NA))) 
      NULL
    else rval
  }
  force(person1)
  rval <- lapply(seq_along(args$given), function(i) with(args, person1(given = given[[i]], family = family[[i]], middle = middle[[i]], email = email[[i]], role = role[[i]], comment = comment[[i]], first = first[[i]], last = last[[i]])))
  .person(rval[!vapply(rval, is.null, NA)])
}, function (given = NULL, family = NULL, middle = NULL, email = NULL, role = NULL, comment = NULL, first = NULL, last = NULL) 
{
  args <- list(given = given, family = family, middle = middle, email = email, role = role, comment = comment, first = first, last = last)
  if (all(vapply(args, is.null, NA))) 
    return(.person())
  args <- lapply(args, .listify)
  args_length <- lengths(args)
  if (!all(args_length_ok <- args_length %in% c(1, max(args_length)))) 
    warning(gettextf("Not all arguments are of the same length, the following need to be recycled: %s", paste(names(args)[!args_length_ok], collapse = ", ")), domain = NA)
  args <- lapply(args, function(x) rep_len(x, max(args_length)))
  person1 <- function(given = NULL, family = NULL, middle = NULL, email = NULL, role = NULL, comment = NULL, first = NULL, last = NULL) {
    if (!.is_not_nonempty_text(first)) {
      if (!.is_not_nonempty_text(given)) 
        stop(gettextf("Use either %s or %s/%s but not both.", sQuote("given"), sQuote("first"), sQuote("middle")), domain = NA)
      warning(gettextf("It is recommended to use %s instead of %s.", sQuote("given"), sQuote("first")), domain = NA)
      given <- first
    }
    if (!.is_not_nonempty_text(middle)) {
      warning(gettextf("It is recommended to use %s instead of %s.", sQuote("given"), sQuote("middle")), domain = NA)
      given <- c(given, unlist(strsplit(middle, "[[:space:]]+")))
    }
    if (!.is_not_nonempty_text(last)) {
      if (!.is_not_nonempty_text(family)) 
        stop(gettextf("Use either %s or %s but not both.", sQuote("family"), sQuote("last")), domain = NA)
      warning(gettextf("It is recommended to use %s instead of %s.", sQuote("family"), sQuote("last")), domain = NA)
      family <- last
    }
    if (.is_not_nonempty_text(given)) 
      given <- NULL
    if (.is_not_nonempty_text(family)) 
      family <- NULL
    if (.is_not_nonempty_text(email)) 
      email <- NULL
    if (.is_not_nonempty_text(role)) {
      if (!is.null(role)) 
        warning(sprintf(ngettext(length(role), "Invalid role specification: %s.", "Invalid role specifications: %s."), paste(sQuote(role), collapse = ", ")), domain = NA)
      role <- NULL
    }
    if (.is_not_nonempty_text(comment)) 
      comment <- NULL
    if (length(role)) 
      role <- .canonicalize_person_role(role)
    if (length(comment)) {
      ind <- grepl(sprintf("^https?://orcid.org/%s$", tools:::.ORCID_iD_regexp), comment)
      if (any(ind)) {
        if (is.null(names(comment))) 
          names(comment) <- ifelse(ind, "ORCID", "")
        else names(comment)[ind] <- "ORCID"
      }
    }
    rval <- list(given = given, family = family, role = role, email = email, comment = comment)
    if (any(ind <- (lengths(rval) == 0))) 
      rval[ind] <- vector("list", length = sum(ind))
    if (all(vapply(rval, is.null, NA))) 
      NULL
    else rval
  }
  force(person1)
  rval <- lapply(seq_along(args$given), function(i) with(args, person1(given = given[[i]], family = family[[i]], middle = middle[[i]], email = email[[i]], role = role[[i]], comment = comment[[i]], first = first[[i]], last = last[[i]])))
  .person(rval[!vapply(rval, is.null, NA)])
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
personList
list(`package:utils` = function (...) 
{
  z <- list(...)
  if (!all(vapply(z, inherits, NA, "person"))) 
    stop(gettextf("all arguments must be of class %s", dQuote("person")), domain = NA)
  do.call(c, z)
}, function (...) 
{
  z <- list(...)
  if (!all(vapply(z, inherits, NA, "person"))) 
    stop(gettextf("all arguments must be of class %s", dQuote("person")), domain = NA)
  do.call(c, z)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
pico
list(`package:utils` = function (name = NULL, file = "") 
  edit.default(name, file, editor = "pico"), function (name = NULL, file = "") 
    edit.default(name, file, editor = "pico"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
process.events
list(`package:utils` = function () 
  invisible(.Call(C_processevents)), function () 
    invisible(.Call(C_processevents)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
prompt
list(`package:utils` = function (object, filename = NULL, name = NULL, ...) 
  UseMethod("prompt"), function (object, filename = NULL, name = NULL, ...) 
    UseMethod("prompt"), new("standardGeneric", .Data = function (object, filename = NULL, name = NULL, ...) 
      standardGeneric("prompt"), generic = "prompt", package = "utils", group = list(), valueClass = character(0), signature = c("object", "filename", "name"), default = new("derivedDefaultMethod", .Data = function (object, filename = NULL, name = NULL, ...) 
        UseMethod("prompt"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "prompt"), skeleton = (new("derivedDefaultMethod", .Data = function (object, filename = NULL, name = NULL, ...) 
          UseMethod("prompt"), target = new("signature", .Data = "ANY", names = "object", package = "methods"), defined = new("signature", .Data = "ANY", names = "object", package = "methods"), generic = "prompt"))(object, filename, name, ...)))
c("package:utils", "namespace:utils", "namespace:Rcpp")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
promptData
list(`package:utils` = function (object, filename = NULL, name = NULL) 
{
  if (missing(name)) 
    name <- if (is.character(object)) 
      object
  else {
    name <- substitute(object)
    if (is.name(name)) 
      as.character(name)
    else stop("cannot determine a usable name")
  }
  if (is.null(filename)) 
    filename <- paste0(name, ".Rd")
  x <- if (!missing(object)) 
    object
  else {
    x <- get(name, envir = parent.frame())
  }
  if (is.data.frame(x)) {
    make_item_tag <- function(s) {
      if (grepl("^([[:alpha:]]|[.][[:alpha:]._])[[:alnum:]._]*$", s)) {
        paste0("\\code{", s, "}")
      }
      else {
        paste0("\\samp{", gsub("([%{}])", "\\\\\\1", s), "}")
      }
    }
    fmt <- c("\\format{", paste("  A data frame with", nrow(x), "observations on the following", ifelse(ncol(x) == 1, "variable.", paste(ncol(x), "variables."))), "  \\describe{")
    for (i in names(x)) {
      xi <- x[[i]]
      fmt <- c(fmt, paste0("    \\item{", make_item_tag(i), "}{", if (inherits(xi, "ordered")) {
        paste("an", data.class(xi), "factor with levels", paste0("\\code{", levels(xi), "}", collapse = " < "), collapse = " ")
      } else if (inherits(xi, "factor")) {
        paste("a factor with levels", paste0("\\code{", levels(xi), "}", collapse = " "), collapse = " ")
      } else if (is.vector(xi)) {
        paste("a", data.class(xi), "vector")
      } else if (is.matrix(xi)) {
        paste("a matrix with", ncol(xi), "columns")
      } else {
        paste("a", data.class(xi))
      }, "}"))
    }
    fmt <- c(fmt, "  }", "}")
  }
  else {
    tf <- tempfile()
    on.exit(unlink(tf))
    sink(tf)
    str(object)
    sink()
    fmt <- c("\\format{", "  The format is:", scan(tf, "", quiet = !getOption("verbose"), sep = "\n"), "}")
  }
  Rdtxt <- list(name = paste0("\\name{", name, "}"), aliases = paste0("\\alias{", name, "}"), docType = "\\docType{data}", title = "\\title{\n%%   ~~ data name/kind ... ~~\n}", description = c("\\description{", "%%  ~~ A concise (1-5 lines) description of the dataset. ~~", "}"), usage = paste0("\\usage{data(\"", name, "\")}"), format = fmt, details = c("\\details{", paste("%%  ~~ If necessary, more details than the", "__description__ above ~~"), "}"), source = c("\\source{", paste("%%  ~~ reference to a publication or URL", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "from which the data were obtained ~~"), "}"), references = c("\\references{", "%%  ~~ possibly secondary sources and usages ~~", "}"), examples = c("\\examples{", paste0("data(", name, ")"), paste0("## maybe str(", name, ") ; plot(", name, ") ..."), "}"), keywords = "\\keyword{datasets}")
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  message(gettextf("Created file named %s.", sQuote(filename)), "\n", gettext("Edit the file and move it to the appropriate directory."), domain = NA)
  invisible(filename)
}, function (object, filename = NULL, name = NULL) 
{
  if (missing(name)) 
    name <- if (is.character(object)) 
      object
  else {
    name <- substitute(object)
    if (is.name(name)) 
      as.character(name)
    else stop("cannot determine a usable name")
  }
  if (is.null(filename)) 
    filename <- paste0(name, ".Rd")
  x <- if (!missing(object)) 
    object
  else {
    x <- get(name, envir = parent.frame())
  }
  if (is.data.frame(x)) {
    make_item_tag <- function(s) {
      if (grepl("^([[:alpha:]]|[.][[:alpha:]._])[[:alnum:]._]*$", s)) {
        paste0("\\code{", s, "}")
      }
      else {
        paste0("\\samp{", gsub("([%{}])", "\\\\\\1", s), "}")
      }
    }
    fmt <- c("\\format{", paste("  A data frame with", nrow(x), "observations on the following", ifelse(ncol(x) == 1, "variable.", paste(ncol(x), "variables."))), "  \\describe{")
    for (i in names(x)) {
      xi <- x[[i]]
      fmt <- c(fmt, paste0("    \\item{", make_item_tag(i), "}{", if (inherits(xi, "ordered")) {
        paste("an", data.class(xi), "factor with levels", paste0("\\code{", levels(xi), "}", collapse = " < "), collapse = " ")
      } else if (inherits(xi, "factor")) {
        paste("a factor with levels", paste0("\\code{", levels(xi), "}", collapse = " "), collapse = " ")
      } else if (is.vector(xi)) {
        paste("a", data.class(xi), "vector")
      } else if (is.matrix(xi)) {
        paste("a matrix with", ncol(xi), "columns")
      } else {
        paste("a", data.class(xi))
      }, "}"))
    }
    fmt <- c(fmt, "  }", "}")
  }
  else {
    tf <- tempfile()
    on.exit(unlink(tf))
    sink(tf)
    str(object)
    sink()
    fmt <- c("\\format{", "  The format is:", scan(tf, "", quiet = !getOption("verbose"), sep = "\n"), "}")
  }
  Rdtxt <- list(name = paste0("\\name{", name, "}"), aliases = paste0("\\alias{", name, "}"), docType = "\\docType{data}", title = "\\title{\n%%   ~~ data name/kind ... ~~\n}", description = c("\\description{", "%%  ~~ A concise (1-5 lines) description of the dataset. ~~", "}"), usage = paste0("\\usage{data(\"", name, "\")}"), format = fmt, details = c("\\details{", paste("%%  ~~ If necessary, more details than the", "__description__ above ~~"), "}"), source = c("\\source{", paste("%%  ~~ reference to a publication or URL", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "from which the data were obtained ~~"), "}"), references = c("\\references{", "%%  ~~ possibly secondary sources and usages ~~", "}"), examples = c("\\examples{", paste0("data(", name, ")"), paste0("## maybe str(", name, ") ; plot(", name, ") ..."), "}"), keywords = "\\keyword{datasets}")
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  message(gettextf("Created file named %s.", sQuote(filename)), "\n", gettext("Edit the file and move it to the appropriate directory."), domain = NA)
  invisible(filename)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
promptImport
list(`package:utils` = function (object, filename = NULL, name = NULL, importedFrom = NULL, importPage = name, ...) 
{
  if (missing(name)) 
    name <- if (is.character(object)) 
      object
  else {
    name <- substitute(object)
    if (is.name(name)) 
      as.character(name)
    else if (is.language(name) && length(name) == 3 && identical(name[[1]], as.name("::"))) 
      as.character(name[[3]])
    else stop("cannot determine a usable name")
  }
  if (is.null(filename)) 
    filename <- paste0(name, ".Rd")
  x <- if (!missing(object)) 
    object
  else {
    x <- get(name, envir = parent.frame())
  }
  if (is.null(importedFrom)) {
    if (is.function(x)) 
      importedFrom <- getNamespaceName(environment(x))
    else stop("cannot determine import name")
  }
  Rdtxt <- list(name = paste0("\\name{", name, "}"), aliases = paste0("\\alias{", name, "}"), docType = "\\docType{import}", title = paste0("\\title{Import from package \\pkg{", importedFrom, "}}"), description = c("\\description{", paste0("The \\code{", name, "} object is imported from package \\pkg{", importedFrom, "}."), paste0("Help is available here:  \\code{\\link[", importedFrom, ":", importPage, "]{", importedFrom, "::", importPage, "}}."), "}"))
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  message(gettextf("Created file named %s.", sQuote(filename)), "\n", gettext("Edit the file and move it to the appropriate directory."), domain = NA)
}, function (object, filename = NULL, name = NULL, importedFrom = NULL, importPage = name, ...) 
{
  if (missing(name)) 
    name <- if (is.character(object)) 
      object
  else {
    name <- substitute(object)
    if (is.name(name)) 
      as.character(name)
    else if (is.language(name) && length(name) == 3 && identical(name[[1]], as.name("::"))) 
      as.character(name[[3]])
    else stop("cannot determine a usable name")
  }
  if (is.null(filename)) 
    filename <- paste0(name, ".Rd")
  x <- if (!missing(object)) 
    object
  else {
    x <- get(name, envir = parent.frame())
  }
  if (is.null(importedFrom)) {
    if (is.function(x)) 
      importedFrom <- getNamespaceName(environment(x))
    else stop("cannot determine import name")
  }
  Rdtxt <- list(name = paste0("\\name{", name, "}"), aliases = paste0("\\alias{", name, "}"), docType = "\\docType{import}", title = paste0("\\title{Import from package \\pkg{", importedFrom, "}}"), description = c("\\description{", paste0("The \\code{", name, "} object is imported from package \\pkg{", importedFrom, "}."), paste0("Help is available here:  \\code{\\link[", importedFrom, ":", importPage, "]{", importedFrom, "::", importPage, "}}."), "}"))
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  message(gettextf("Created file named %s.", sQuote(filename)), "\n", gettext("Edit the file and move it to the appropriate directory."), domain = NA)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
promptPackage
list(`package:utils` = function (package, lib.loc = NULL, filename = NULL, name = NULL, final = FALSE) 
{
  insert1 <- function(field, new) {
    prev <- Rdtxt[[field]]
    Rdtxt[[field]] <<- c(prev[-length(prev)], new, prev[length(prev)])
  }
  insert2 <- function(field, new) insert1(field, paste("~~", new, "~~"))
  if (missing(name)) 
    name <- paste0(package, "-package")
  if (is.null(filename)) 
    filename <- paste0(name, ".Rd")
  Rdtxt <- list(name = paste0("\\name{", name, "}"), aliases = c(paste0("\\alias{", name, "}"), c(paste0("\\alias{", package, "}"))), docType = "\\docType{package}", title = c("\\title{", "}"), description = c("\\description{", "}"), details = c("\\details{", "}"), author = c("\\author{", "}"), references = character(0), keywords = c("\\keyword{ package }"))
  insert1("title", paste0("\\packageTitle{", package, "}"))
  insert1("description", paste0("\\packageDescription{", package, "}"))
  insert1("author", c(paste0("\\packageAuthor{", package, "}"), "", paste("Maintainer:", paste0("\\packageMaintainer{", package, "}"))))
  insert1("details", c("", "The DESCRIPTION file:"))
  insert1("details", paste0("\\packageDESCRIPTION{", package, "}"))
  insert1("details", paste0("\\packageIndices{", package, "}"))
  if (!final) {
    insert2("details", strwrap("An overview of how to use the package, including the most important functions"))
    Rdtxt$references <- c("\\references{", paste("~~", "Literature or other references for background information", "~~"), "}")
    Rdtxt$seealso <- c("\\seealso{", "}")
    insert2("seealso", c("Optional links to other man pages, e.g.", "\\code{\\link[<pkg>:<pkg>-package]{<pkg>}}"))
    Rdtxt$examples <- c("\\examples{", "}")
    insert2("examples", "simple examples of the most important functions")
    insert2("keywords", strwrap("Optionally other standard keywords, one per line, from file KEYWORDS in the R documentation directory"))
  }
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  message(gettextf("Created file named %s.", sQuote(filename)), "\n", gettext("Edit the file and move it to the appropriate directory."), domain = NA)
  invisible(filename)
}, function (package, lib.loc = NULL, filename = NULL, name = NULL, final = FALSE) 
{
  insert1 <- function(field, new) {
    prev <- Rdtxt[[field]]
    Rdtxt[[field]] <<- c(prev[-length(prev)], new, prev[length(prev)])
  }
  insert2 <- function(field, new) insert1(field, paste("~~", new, "~~"))
  if (missing(name)) 
    name <- paste0(package, "-package")
  if (is.null(filename)) 
    filename <- paste0(name, ".Rd")
  Rdtxt <- list(name = paste0("\\name{", name, "}"), aliases = c(paste0("\\alias{", name, "}"), c(paste0("\\alias{", package, "}"))), docType = "\\docType{package}", title = c("\\title{", "}"), description = c("\\description{", "}"), details = c("\\details{", "}"), author = c("\\author{", "}"), references = character(0), keywords = c("\\keyword{ package }"))
  insert1("title", paste0("\\packageTitle{", package, "}"))
  insert1("description", paste0("\\packageDescription{", package, "}"))
  insert1("author", c(paste0("\\packageAuthor{", package, "}"), "", paste("Maintainer:", paste0("\\packageMaintainer{", package, "}"))))
  insert1("details", c("", "The DESCRIPTION file:"))
  insert1("details", paste0("\\packageDESCRIPTION{", package, "}"))
  insert1("details", paste0("\\packageIndices{", package, "}"))
  if (!final) {
    insert2("details", strwrap("An overview of how to use the package, including the most important functions"))
    Rdtxt$references <- c("\\references{", paste("~~", "Literature or other references for background information", "~~"), "}")
    Rdtxt$seealso <- c("\\seealso{", "}")
    insert2("seealso", c("Optional links to other man pages, e.g.", "\\code{\\link[<pkg>:<pkg>-package]{<pkg>}}"))
    Rdtxt$examples <- c("\\examples{", "}")
    insert2("examples", "simple examples of the most important functions")
    insert2("keywords", strwrap("Optionally other standard keywords, one per line, from file KEYWORDS in the R documentation directory"))
  }
  if (is.na(filename)) 
    return(Rdtxt)
  cat(unlist(Rdtxt), file = filename, sep = "\n")
  message(gettextf("Created file named %s.", sQuote(filename)), "\n", gettext("Edit the file and move it to the appropriate directory."), domain = NA)
  invisible(filename)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
rc.getOption
list(`package:utils` = function (name) 
{
  get("options", envir = .CompletionEnv)[[name]]
}, function (name) 
{
  get("options", envir = .CompletionEnv)[[name]]
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
rc.options
list(`package:utils` = function (...) 
{
  new <- list(...)
  if (is.null(names(new)) && length(new) == 1 && is.list(new[[1]])) 
    new <- new[[1]]
  old <- .CompletionEnv$options
  if (length(new) == 0) 
    return(old)
  nm <- names(new)
  if (is.null(nm)) 
    return(old[unlist(new)])
  isNamed <- nzchar(nm)
  if (any(!isNamed)) 
    nm[!isNamed] <- unlist(new[!isNamed])
  retVal <- old[nm]
  names(retVal) <- nm
  nm <- nm[isNamed]
  .CompletionEnv$options <- modifyList(old, new[nm])
  invisible(retVal)
}, function (...) 
{
  new <- list(...)
  if (is.null(names(new)) && length(new) == 1 && is.list(new[[1]])) 
    new <- new[[1]]
  old <- .CompletionEnv$options
  if (length(new) == 0) 
    return(old)
  nm <- names(new)
  if (is.null(nm)) 
    return(old[unlist(new)])
  isNamed <- nzchar(nm)
  if (any(!isNamed)) 
    nm[!isNamed] <- unlist(new[!isNamed])
  retVal <- old[nm]
  names(retVal) <- nm
  nm <- nm[isNamed]
  .CompletionEnv$options <- modifyList(old, new[nm])
  invisible(retVal)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
rc.settings
list(`package:utils` = function (ops, ns, args, dots, func, ipck, S3, data, help, argdb, fuzzy, quotes, files) 
{
  if (length(match.call()) == 1) 
    return(unlist(.CompletionEnv[["settings"]]))
  checkAndChange <- function(what, value) {
    if ((length(value) == 1) && is.logical(value) && !is.na(value)) 
      .CompletionEnv$settings[[what]] <- value
  }
  if (!missing(ops)) 
    checkAndChange("ops", ops)
  if (!missing(ns)) 
    checkAndChange("ns", ns)
  if (!missing(args)) 
    checkAndChange("args", args)
  if (!missing(dots)) 
    checkAndChange("dots", dots)
  if (!missing(func)) 
    checkAndChange("func", func)
  if (!missing(ipck)) 
    checkAndChange("ipck", ipck)
  if (!missing(S3)) 
    checkAndChange("S3", S3)
  if (!missing(data)) 
    checkAndChange("data", data)
  if (!missing(help)) 
    checkAndChange("help", help)
  if (!missing(argdb)) 
    checkAndChange("argdb", argdb)
  if (!missing(files)) 
    checkAndChange("files", files)
  if (!missing(quotes)) 
    checkAndChange("quotes", quotes)
  if (!missing(fuzzy)) 
    checkAndChange("fuzzy", fuzzy)
  invisible()
}, function (ops, ns, args, dots, func, ipck, S3, data, help, argdb, fuzzy, quotes, files) 
{
  if (length(match.call()) == 1) 
    return(unlist(.CompletionEnv[["settings"]]))
  checkAndChange <- function(what, value) {
    if ((length(value) == 1) && is.logical(value) && !is.na(value)) 
      .CompletionEnv$settings[[what]] <- value
  }
  if (!missing(ops)) 
    checkAndChange("ops", ops)
  if (!missing(ns)) 
    checkAndChange("ns", ns)
  if (!missing(args)) 
    checkAndChange("args", args)
  if (!missing(dots)) 
    checkAndChange("dots", dots)
  if (!missing(func)) 
    checkAndChange("func", func)
  if (!missing(ipck)) 
    checkAndChange("ipck", ipck)
  if (!missing(S3)) 
    checkAndChange("S3", S3)
  if (!missing(data)) 
    checkAndChange("data", data)
  if (!missing(help)) 
    checkAndChange("help", help)
  if (!missing(argdb)) 
    checkAndChange("argdb", argdb)
  if (!missing(files)) 
    checkAndChange("files", files)
  if (!missing(quotes)) 
    checkAndChange("quotes", quotes)
  if (!missing(fuzzy)) 
    checkAndChange("fuzzy", fuzzy)
  invisible()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
rc.status
list(`package:utils` = function () 
{
  as.list(.CompletionEnv)
}, function () 
{
  as.list(.CompletionEnv)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.csv
list(`package:utils` = function (file, header = TRUE, sep = ",", quote = "\"", dec = ".", fill = TRUE, comment.char = "", ...) 
  read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...), function (file, header = TRUE, sep = ",", quote = "\"", dec = ".", fill = TRUE, comment.char = "", ...) 
    read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.csv2
list(`package:utils` = function (file, header = TRUE, sep = ";", quote = "\"", dec = ",", fill = TRUE, comment.char = "", ...) 
  read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...), function (file, header = TRUE, sep = ";", quote = "\"", dec = ",", fill = TRUE, comment.char = "", ...) 
    read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.delim
list(`package:utils` = function (file, header = TRUE, sep = "\t", quote = "\"", dec = ".", fill = TRUE, comment.char = "", ...) 
  read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...), function (file, header = TRUE, sep = "\t", quote = "\"", dec = ".", fill = TRUE, comment.char = "", ...) 
    read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.delim2
list(`package:utils` = function (file, header = TRUE, sep = "\t", quote = "\"", dec = ",", fill = TRUE, comment.char = "", ...) 
  read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...), function (file, header = TRUE, sep = "\t", quote = "\"", dec = ",", fill = TRUE, comment.char = "", ...) 
    read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comment.char = comment.char, ...))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.DIF
list(`package:utils` = function (file, header = FALSE, dec = ".", numerals = c("allow.loss", "warn.loss", "no.loss"), row.names, col.names, as.is = !stringsAsFactors, na.strings = "NA", colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, blank.lines.skip = TRUE, stringsAsFactors = FALSE, transpose = FALSE, fileEncoding = "") 
{
  if (.Platform$OS.type == "windows" && identical(file, "clipboard")) {
    if (!(5 %in% getClipboardFormats(numeric = TRUE))) 
      stop("No DIF data on clipboard")
    lines <- readClipboard(5)
  }
  else if (nzchar(fileEncoding)) {
    con <- file(file, "rt", encoding = fileEncoding)
    lines <- readLines(con)
    close(con)
  }
  else {
    lines <- readLines(file)
  }
  if (length(lines) < 1) 
    stop("file had no lines")
  topic <- ""
  nrow <- NA
  ncol <- NA
  i <- 1
  while (topic != "DATA") {
    topic <- lines[i]
    vnum <- lines[i + 1]
    num <- as.numeric(sub("^.*,", "", vnum))
    i <- i + 3
    if (topic == "VECTORS") 
      if (transpose) 
        nrow <- num
    else ncol <- num
    else if (topic == "TUPLES") 
      if (transpose) 
        ncol <- num
    else nrow <- num
  }
  if (is.na(nrow) || is.na(ncol)) 
    stop("row and column counts not found")
  data <- matrix("", nrow, ncol)
  types <- matrix(NA, nrow, ncol)
  row <- 0
  while (i < length(lines)) {
    typenum <- lines[i]
    type <- as.numeric(sub(",.*$", "", typenum))
    num <- as.numeric(sub("^.*,", "", typenum))
    stringval <- lines[i + 1]
    i <- i + 2
    if (type == -1) {
      if (stringval == "BOT") {
        row <- row + 1
        if (row > nrow) 
          stop("More rows than specified in header; maybe use 'transpose=TRUE'")
        col <- 0
      }
      else if (stringval == "EOD") 
        break
      else stop("Unrecognized special data value")
    }
    else {
      col <- col + 1
      if (col > ncol) 
        stop("More columns than specified in header; maybe use 'transpose=TRUE'")
      if (type == 0) {
        types[row, col] <- "numeric"
        if (stringval == "V") 
          data[row, col] <- num
        else if (stringval == "NA") 
          data[row, col] <- NA
        else if (stringval == "ERROR") 
          data[row, col] <- NA
        else if (stringval == "TRUE") {
          data[row, col] <- "TRUE"
          types[row, col] <- "logical"
        }
        else if (stringval == "FALSE") {
          data[row, col] <- "FALSE"
          types[row, col] <- "logical"
        }
        else stop("Unrecognized value indicator")
      }
      else if (type == 1) {
        types[row, col] <- "character"
        stringval <- sub("^\"", "", stringval)
        stringval <- sub("\"$", "", stringval)
        data[row, col] <- stringval
      }
    }
  }
  if (skip > 0) 
    data <- data[-(1:skip), , drop = FALSE]
  nlines <- nrow(data)
  if (!nlines) {
    if (missing(col.names)) 
      stop("no lines available in input")
    else {
      tmp <- vector("list", length(col.names))
      names(tmp) <- col.names
      class(tmp) <- "data.frame"
      return(tmp)
    }
  }
  first <- data[1, ]
  if (first[1] == "") 
    first <- first[-1]
  cols <- ncol
  rlabp <- all(types[1, ][-1] == "character") && data[1, 1] == ""
  if (rlabp && missing(header)) 
    header <- TRUE
  if (!header) 
    rlabp <- FALSE
  if (header) {
    data <- data[-1, , drop = FALSE]
    types <- types[-1, , drop = FALSE]
    if (missing(col.names)) 
      col.names <- first
    else if (length(first) != length(col.names)) 
      warning("header and 'col.names' are of different lengths")
  }
  else if (missing(col.names)) 
    col.names <- paste0("V", 1:cols)
  if (length(col.names) + rlabp < cols) 
    stop("more columns than column names")
  if (cols > 0 && length(col.names) > cols) 
    stop("more column names than columns")
  if (cols == 0) 
    stop("rows are empty: giving up")
  if (check.names) 
    col.names <- make.names(col.names, unique = TRUE)
  if (rlabp) 
    col.names <- c("row.names", col.names)
  nmColClasses <- names(colClasses)
  if (length(colClasses) < cols) 
    if (is.null(nmColClasses)) {
      colClasses <- rep_len(colClasses, cols)
    }
  else {
    tmp <- rep_len(NA, cols)
    names(tmp) <- col.names
    i <- match(nmColClasses, col.names, 0)
    if (any(i <= 0)) 
      warning("not all columns named in 'colClasses' exist")
    tmp[i[i > 0]] <- colClasses
    colClasses <- tmp
  }
  colClasses[colClasses %in% c("real", "double")] <- "numeric"
  known <- colClasses %in% c("logical", "integer", "numeric", "complex", "character")
  keep <- !(colClasses %in% "NULL")
  if (blank.lines.skip) 
    data <- data[apply(data, 1, function(x) !all(x == "")), , drop = FALSE]
  if (nrows > -1 && nrows < nrow(data)) 
    data <- data[seq_len(nrows), , drop = FALSE]
  nlines <- nrow(data)
  data[data %in% na.strings] <- NA
  data <- as.data.frame(data, stringsAsFactors = FALSE)
  names(data) <- col.names
  if (cols != length(data)) {
    warning("cols = ", cols, " != length(data) = ", length(data), domain = NA)
    cols <- length(data)
  }
  if (is.logical(as.is)) {
    as.is <- rep_len(as.is, cols)
  }
  else if (is.numeric(as.is)) {
    if (any(as.is < 1 | as.is > cols)) 
      stop("invalid numeric 'as.is' expression")
    i <- rep.int(FALSE, cols)
    i[as.is] <- TRUE
    as.is <- i
  }
  else if (is.character(as.is)) {
    i <- match(as.is, col.names, 0)
    if (any(i <= 0)) 
      warning("not all columns named in 'as.is' exist")
    i <- i[i > 0]
    as.is <- rep.int(FALSE, cols)
    as.is[i] <- TRUE
  }
  else if (length(as.is) != cols) 
    stop(gettextf("'as.is' has the wrong length %d  != cols = %d", length(as.is), cols), domain = NA)
  do <- keep & !known
  if (rlabp) 
    do[1] <- FALSE
  for (i in (1:cols)[do]) {
    data[[i]] <- if (is.na(colClasses[i])) {
      if (any(types[, i] == "character")) {
        if (stringsAsFactors && !as.is[i]) 
          as.factor(data[[i]])
        else data[[i]]
      }
      else type.convert(data[[i]], as.is = as.is[i], dec = dec, na.strings = character(0), numerals = numerals)
    }
    else if (colClasses[i] == "factor") 
      as.factor(data[[i]])
    else if (colClasses[i] == "Date") 
      as.Date(data[[i]])
    else if (colClasses[i] == "POSIXct") 
      as.POSIXct(data[[i]])
    else methods::as(data[[i]], colClasses[i])
  }
  compactRN <- TRUE
  if (missing(row.names)) {
    if (rlabp) {
      row.names <- data[[1]]
      data <- data[-1]
      keep <- keep[-1]
      compactRN <- FALSE
    }
    else row.names <- .set_row_names(as.integer(nlines))
  }
  else if (is.null(row.names)) {
    row.names <- .set_row_names(as.integer(nlines))
  }
  else if (is.character(row.names)) {
    compactRN <- FALSE
    if (length(row.names) == 1) {
      rowvar <- (1:cols)[match(col.names, row.names, 0) == 1]
      row.names <- data[[rowvar]]
      data <- data[-rowvar]
      keep <- keep[-rowvar]
    }
  }
  else if (is.numeric(row.names) && length(row.names) == 1) {
    compactRN <- FALSE
    rlabp <- row.names
    row.names <- data[[rlabp]]
    data <- data[-rlabp]
    keep <- keep[-rlabp]
  }
  else stop("invalid 'row.names' specification")
  data <- data[keep]
  if (is.object(row.names) || !(is.integer(row.names))) 
    row.names <- as.character(row.names)
  if (!compactRN) {
    if (length(row.names) != nlines) 
      stop("invalid 'row.names' length")
    if (anyDuplicated(row.names)) 
      stop("duplicate 'row.names' are not allowed")
    if (anyNA(row.names)) 
      stop("missing values in 'row.names' are not allowed")
  }
  attr(data, "row.names") <- row.names
  data
}, function (file, header = FALSE, dec = ".", numerals = c("allow.loss", "warn.loss", "no.loss"), row.names, col.names, as.is = !stringsAsFactors, na.strings = "NA", colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, blank.lines.skip = TRUE, stringsAsFactors = FALSE, transpose = FALSE, fileEncoding = "") 
{
  if (.Platform$OS.type == "windows" && identical(file, "clipboard")) {
    if (!(5 %in% getClipboardFormats(numeric = TRUE))) 
      stop("No DIF data on clipboard")
    lines <- readClipboard(5)
  }
  else if (nzchar(fileEncoding)) {
    con <- file(file, "rt", encoding = fileEncoding)
    lines <- readLines(con)
    close(con)
  }
  else {
    lines <- readLines(file)
  }
  if (length(lines) < 1) 
    stop("file had no lines")
  topic <- ""
  nrow <- NA
  ncol <- NA
  i <- 1
  while (topic != "DATA") {
    topic <- lines[i]
    vnum <- lines[i + 1]
    num <- as.numeric(sub("^.*,", "", vnum))
    i <- i + 3
    if (topic == "VECTORS") 
      if (transpose) 
        nrow <- num
    else ncol <- num
    else if (topic == "TUPLES") 
      if (transpose) 
        ncol <- num
    else nrow <- num
  }
  if (is.na(nrow) || is.na(ncol)) 
    stop("row and column counts not found")
  data <- matrix("", nrow, ncol)
  types <- matrix(NA, nrow, ncol)
  row <- 0
  while (i < length(lines)) {
    typenum <- lines[i]
    type <- as.numeric(sub(",.*$", "", typenum))
    num <- as.numeric(sub("^.*,", "", typenum))
    stringval <- lines[i + 1]
    i <- i + 2
    if (type == -1) {
      if (stringval == "BOT") {
        row <- row + 1
        if (row > nrow) 
          stop("More rows than specified in header; maybe use 'transpose=TRUE'")
        col <- 0
      }
      else if (stringval == "EOD") 
        break
      else stop("Unrecognized special data value")
    }
    else {
      col <- col + 1
      if (col > ncol) 
        stop("More columns than specified in header; maybe use 'transpose=TRUE'")
      if (type == 0) {
        types[row, col] <- "numeric"
        if (stringval == "V") 
          data[row, col] <- num
        else if (stringval == "NA") 
          data[row, col] <- NA
        else if (stringval == "ERROR") 
          data[row, col] <- NA
        else if (stringval == "TRUE") {
          data[row, col] <- "TRUE"
          types[row, col] <- "logical"
        }
        else if (stringval == "FALSE") {
          data[row, col] <- "FALSE"
          types[row, col] <- "logical"
        }
        else stop("Unrecognized value indicator")
      }
      else if (type == 1) {
        types[row, col] <- "character"
        stringval <- sub("^\"", "", stringval)
        stringval <- sub("\"$", "", stringval)
        data[row, col] <- stringval
      }
    }
  }
  if (skip > 0) 
    data <- data[-(1:skip), , drop = FALSE]
  nlines <- nrow(data)
  if (!nlines) {
    if (missing(col.names)) 
      stop("no lines available in input")
    else {
      tmp <- vector("list", length(col.names))
      names(tmp) <- col.names
      class(tmp) <- "data.frame"
      return(tmp)
    }
  }
  first <- data[1, ]
  if (first[1] == "") 
    first <- first[-1]
  cols <- ncol
  rlabp <- all(types[1, ][-1] == "character") && data[1, 1] == ""
  if (rlabp && missing(header)) 
    header <- TRUE
  if (!header) 
    rlabp <- FALSE
  if (header) {
    data <- data[-1, , drop = FALSE]
    types <- types[-1, , drop = FALSE]
    if (missing(col.names)) 
      col.names <- first
    else if (length(first) != length(col.names)) 
      warning("header and 'col.names' are of different lengths")
  }
  else if (missing(col.names)) 
    col.names <- paste0("V", 1:cols)
  if (length(col.names) + rlabp < cols) 
    stop("more columns than column names")
  if (cols > 0 && length(col.names) > cols) 
    stop("more column names than columns")
  if (cols == 0) 
    stop("rows are empty: giving up")
  if (check.names) 
    col.names <- make.names(col.names, unique = TRUE)
  if (rlabp) 
    col.names <- c("row.names", col.names)
  nmColClasses <- names(colClasses)
  if (length(colClasses) < cols) 
    if (is.null(nmColClasses)) {
      colClasses <- rep_len(colClasses, cols)
    }
  else {
    tmp <- rep_len(NA, cols)
    names(tmp) <- col.names
    i <- match(nmColClasses, col.names, 0)
    if (any(i <= 0)) 
      warning("not all columns named in 'colClasses' exist")
    tmp[i[i > 0]] <- colClasses
    colClasses <- tmp
  }
  colClasses[colClasses %in% c("real", "double")] <- "numeric"
  known <- colClasses %in% c("logical", "integer", "numeric", "complex", "character")
  keep <- !(colClasses %in% "NULL")
  if (blank.lines.skip) 
    data <- data[apply(data, 1, function(x) !all(x == "")), , drop = FALSE]
  if (nrows > -1 && nrows < nrow(data)) 
    data <- data[seq_len(nrows), , drop = FALSE]
  nlines <- nrow(data)
  data[data %in% na.strings] <- NA
  data <- as.data.frame(data, stringsAsFactors = FALSE)
  names(data) <- col.names
  if (cols != length(data)) {
    warning("cols = ", cols, " != length(data) = ", length(data), domain = NA)
    cols <- length(data)
  }
  if (is.logical(as.is)) {
    as.is <- rep_len(as.is, cols)
  }
  else if (is.numeric(as.is)) {
    if (any(as.is < 1 | as.is > cols)) 
      stop("invalid numeric 'as.is' expression")
    i <- rep.int(FALSE, cols)
    i[as.is] <- TRUE
    as.is <- i
  }
  else if (is.character(as.is)) {
    i <- match(as.is, col.names, 0)
    if (any(i <= 0)) 
      warning("not all columns named in 'as.is' exist")
    i <- i[i > 0]
    as.is <- rep.int(FALSE, cols)
    as.is[i] <- TRUE
  }
  else if (length(as.is) != cols) 
    stop(gettextf("'as.is' has the wrong length %d  != cols = %d", length(as.is), cols), domain = NA)
  do <- keep & !known
  if (rlabp) 
    do[1] <- FALSE
  for (i in (1:cols)[do]) {
    data[[i]] <- if (is.na(colClasses[i])) {
      if (any(types[, i] == "character")) {
        if (stringsAsFactors && !as.is[i]) 
          as.factor(data[[i]])
        else data[[i]]
      }
      else type.convert(data[[i]], as.is = as.is[i], dec = dec, na.strings = character(0), numerals = numerals)
    }
    else if (colClasses[i] == "factor") 
      as.factor(data[[i]])
    else if (colClasses[i] == "Date") 
      as.Date(data[[i]])
    else if (colClasses[i] == "POSIXct") 
      as.POSIXct(data[[i]])
    else methods::as(data[[i]], colClasses[i])
  }
  compactRN <- TRUE
  if (missing(row.names)) {
    if (rlabp) {
      row.names <- data[[1]]
      data <- data[-1]
      keep <- keep[-1]
      compactRN <- FALSE
    }
    else row.names <- .set_row_names(as.integer(nlines))
  }
  else if (is.null(row.names)) {
    row.names <- .set_row_names(as.integer(nlines))
  }
  else if (is.character(row.names)) {
    compactRN <- FALSE
    if (length(row.names) == 1) {
      rowvar <- (1:cols)[match(col.names, row.names, 0) == 1]
      row.names <- data[[rowvar]]
      data <- data[-rowvar]
      keep <- keep[-rowvar]
    }
  }
  else if (is.numeric(row.names) && length(row.names) == 1) {
    compactRN <- FALSE
    rlabp <- row.names
    row.names <- data[[rlabp]]
    data <- data[-rlabp]
    keep <- keep[-rlabp]
  }
  else stop("invalid 'row.names' specification")
  data <- data[keep]
  if (is.object(row.names) || !(is.integer(row.names))) 
    row.names <- as.character(row.names)
  if (!compactRN) {
    if (length(row.names) != nlines) 
      stop("invalid 'row.names' length")
    if (anyDuplicated(row.names)) 
      stop("duplicate 'row.names' are not allowed")
    if (anyNA(row.names)) 
      stop("missing values in 'row.names' are not allowed")
  }
  attr(data, "row.names") <- row.names
  data
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.fortran
list(`package:utils` = function (file, format, ..., as.is = TRUE, colClasses = NA) 
{
  processFormat <- function(format) {
    format <- toupper(format)
    template <- "^([0-9]*)([FXAI])([0-9]*)\\.?([0-9]*)"
    reps <- as.numeric(sub(template, "\\1", format))
    types <- sub(template, "\\2", format)
    lengths <- as.numeric(sub(template, "\\3", format))
    decimals <- as.numeric(sub(template, "\\4", format))
    reps[is.na(reps)] <- 1
    lengths[is.na(lengths) & types == "X"] <- 1
    charskip <- types == "X"
    lengths[charskip] <- reps[charskip] * lengths[charskip]
    reps[charskip] <- 1
    if (anyNA(lengths)) 
      stop("missing lengths for some fields")
    lengths <- rep.int(lengths, reps)
    types <- rep.int(types, reps)
    decimals <- rep.int(decimals, reps)
    types <- match(types, c("F", "D", "X", "A", "I"))
    if (any(!is.na(decimals) & types > 2)) 
      stop("invalid format")
    colClasses <- c("numeric", "numeric", NA, if (as.is) "character" else NA, "integer")[types]
    colClasses <- colClasses[!(types == 3)]
    decimals <- decimals[!(types == 3)]
    lengths[types == 3] <- -lengths[types == 3]
    list(lengths, colClasses, decimals)
  }
  if (is.list(format)) {
    ff <- lapply(format, processFormat)
    widths <- lapply(ff, `[[`, 1)
    if (is.na(colClasses)) 
      colClasses <- do.call(c, lapply(ff, `[[`, 2))
    decimals <- do.call(c, lapply(ff, `[[`, 3))
  }
  else {
    ff <- processFormat(format)
    widths <- ff[[1]]
    if (is.na(colClasses)) 
      colClasses <- ff[[2]]
    decimals <- ff[[3]]
  }
  rval <- read.fwf(file, widths = widths, ..., colClasses = colClasses)
  for (i in which(!is.na(decimals))) rval[, i] <- rval[, i] * (10^-decimals[i])
  rval
}, function (file, format, ..., as.is = TRUE, colClasses = NA) 
{
  processFormat <- function(format) {
    format <- toupper(format)
    template <- "^([0-9]*)([FXAI])([0-9]*)\\.?([0-9]*)"
    reps <- as.numeric(sub(template, "\\1", format))
    types <- sub(template, "\\2", format)
    lengths <- as.numeric(sub(template, "\\3", format))
    decimals <- as.numeric(sub(template, "\\4", format))
    reps[is.na(reps)] <- 1
    lengths[is.na(lengths) & types == "X"] <- 1
    charskip <- types == "X"
    lengths[charskip] <- reps[charskip] * lengths[charskip]
    reps[charskip] <- 1
    if (anyNA(lengths)) 
      stop("missing lengths for some fields")
    lengths <- rep.int(lengths, reps)
    types <- rep.int(types, reps)
    decimals <- rep.int(decimals, reps)
    types <- match(types, c("F", "D", "X", "A", "I"))
    if (any(!is.na(decimals) & types > 2)) 
      stop("invalid format")
    colClasses <- c("numeric", "numeric", NA, if (as.is) "character" else NA, "integer")[types]
    colClasses <- colClasses[!(types == 3)]
    decimals <- decimals[!(types == 3)]
    lengths[types == 3] <- -lengths[types == 3]
    list(lengths, colClasses, decimals)
  }
  if (is.list(format)) {
    ff <- lapply(format, processFormat)
    widths <- lapply(ff, `[[`, 1)
    if (is.na(colClasses)) 
      colClasses <- do.call(c, lapply(ff, `[[`, 2))
    decimals <- do.call(c, lapply(ff, `[[`, 3))
  }
  else {
    ff <- processFormat(format)
    widths <- ff[[1]]
    if (is.na(colClasses)) 
      colClasses <- ff[[2]]
    decimals <- ff[[3]]
  }
  rval <- read.fwf(file, widths = widths, ..., colClasses = colClasses)
  for (i in which(!is.na(decimals))) rval[, i] <- rval[, i] * (10^-decimals[i])
  rval
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.fwf
list(`package:utils` = function (file, widths, header = FALSE, sep = "\t", skip = 0, row.names, col.names, n = -1, buffersize = 2000, fileEncoding = "", ...) 
{
  doone <- function(x) {
    x <- substring(x, first, last)
    x[!nzchar(x)] <- NA
    x
  }
  if (is.list(widths)) {
    recordlength <- length(widths)
    widths <- do.call(c, widths)
  }
  else recordlength <- 1
  drop <- (widths < 0)
  cwidths <- cumsum(abs(widths))
  st <- c(1, 1 + cwidths)
  first <- st[-length(st)][!drop]
  last <- cwidths[!drop]
  outsep <- c(rep_len(sep, length(first) - 1), "\n")
  buffersize <- (buffersize%/%recordlength) * recordlength
  FILENAME <- tempfile("Rfwf.")
  on.exit(unlink(FILENAME))
  FILE <- file(FILENAME, "a")
  on.exit(close(FILE), add = TRUE)
  if (is.character(file)) {
    file <- if (nzchar(fileEncoding)) 
      file(file, "rt", encoding = fileEncoding)
    else file(file, "rt")
    on.exit(close(file), add = TRUE)
  }
  else if (!isOpen(file)) {
    open(file, "rt")
    on.exit(close(file), add = TRUE)
  }
  if (skip) 
    readLines(file, n = skip)
  if (header) {
    headerline <- readLines(file, n = 1)
    cat(file = FILE, headerline, "\n")
  }
  repeat ({
    if (n == 0) 
      break
    thisblock <- if (n == -1) 
      buffersize
    else min(buffersize, n * recordlength)
    raw <- readLines(file, n = thisblock)
    nread <- length(raw)
    if (recordlength > 1 && nread%%recordlength) {
      raw <- raw[1:(nread - nread%%recordlength)]
      warning(sprintf(ngettext(nread%%recordlength, "last record incomplete, %d line discarded", "last record incomplete, %d lines discarded"), nread%%recordlength), domain = NA)
    }
    if (recordlength > 1) {
      raw <- matrix(raw, nrow = recordlength)
      raw <- apply(raw, 2, paste, collapse = "")
    }
    cat(file = FILE, sapply(raw, doone, USE.NAMES = FALSE), sep = outsep)
    if (nread < thisblock) 
      break
    if (n > 0) 
      n <- n - length(raw)
  })
  close(FILE)
  FILE <- file(FILENAME, "r")
  read.table(file = FILE, header = header, sep = sep, row.names = row.names, col.names = col.names, quote = "", ...)
}, function (file, widths, header = FALSE, sep = "\t", skip = 0, row.names, col.names, n = -1, buffersize = 2000, fileEncoding = "", ...) 
{
  doone <- function(x) {
    x <- substring(x, first, last)
    x[!nzchar(x)] <- NA
    x
  }
  if (is.list(widths)) {
    recordlength <- length(widths)
    widths <- do.call(c, widths)
  }
  else recordlength <- 1
  drop <- (widths < 0)
  cwidths <- cumsum(abs(widths))
  st <- c(1, 1 + cwidths)
  first <- st[-length(st)][!drop]
  last <- cwidths[!drop]
  outsep <- c(rep_len(sep, length(first) - 1), "\n")
  buffersize <- (buffersize%/%recordlength) * recordlength
  FILENAME <- tempfile("Rfwf.")
  on.exit(unlink(FILENAME))
  FILE <- file(FILENAME, "a")
  on.exit(close(FILE), add = TRUE)
  if (is.character(file)) {
    file <- if (nzchar(fileEncoding)) 
      file(file, "rt", encoding = fileEncoding)
    else file(file, "rt")
    on.exit(close(file), add = TRUE)
  }
  else if (!isOpen(file)) {
    open(file, "rt")
    on.exit(close(file), add = TRUE)
  }
  if (skip) 
    readLines(file, n = skip)
  if (header) {
    headerline <- readLines(file, n = 1)
    cat(file = FILE, headerline, "\n")
  }
  repeat ({
    if (n == 0) 
      break
    thisblock <- if (n == -1) 
      buffersize
    else min(buffersize, n * recordlength)
    raw <- readLines(file, n = thisblock)
    nread <- length(raw)
    if (recordlength > 1 && nread%%recordlength) {
      raw <- raw[1:(nread - nread%%recordlength)]
      warning(sprintf(ngettext(nread%%recordlength, "last record incomplete, %d line discarded", "last record incomplete, %d lines discarded"), nread%%recordlength), domain = NA)
    }
    if (recordlength > 1) {
      raw <- matrix(raw, nrow = recordlength)
      raw <- apply(raw, 2, paste, collapse = "")
    }
    cat(file = FILE, sapply(raw, doone, USE.NAMES = FALSE), sep = outsep)
    if (nread < thisblock) 
      break
    if (n > 0) 
      n <- n - length(raw)
  })
  close(FILE)
  FILE <- file(FILENAME, "r")
  read.table(file = FILE, header = header, sep = sep, row.names = row.names, col.names = col.names, quote = "", ...)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.socket
list(`package:utils` = function (socket, maxlen = 256, loop = FALSE) 
{
  repeat {
    rval <- .Call(C_sockread, socket$socket, maxlen)
    if (nzchar(rval) || !loop) 
      break
  }
  rval
}, function (socket, maxlen = 256, loop = FALSE) 
{
  repeat {
    rval <- .Call(C_sockread, socket$socket, maxlen)
    if (nzchar(rval) || !loop) 
      break
  }
  rval
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
read.table
list(`package:utils` = function (file, header = FALSE, sep = "", quote = "\"'", dec = ".", numerals = c("allow.loss", "warn.loss", "no.loss"), row.names, col.names, as.is = !stringsAsFactors, na.strings = "NA", colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = "#", allowEscapes = FALSE, flush = FALSE, stringsAsFactors = FALSE, fileEncoding = "", encoding = "unknown", text, skipNul = FALSE) 
{
  if (missing(file) && !missing(text)) {
    file <- textConnection(text, encoding = "UTF-8")
    encoding <- "UTF-8"
    on.exit(close(file))
  }
  if (is.character(file)) {
    file <- if (nzchar(fileEncoding)) 
      file(file, "rt", encoding = fileEncoding)
    else file(file, "rt")
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  if (!isOpen(file, "rt")) {
    open(file, "rt")
    on.exit(close(file))
  }
  pbEncoding <- if (encoding %in% c("", "bytes", "UTF-8")) 
    encoding
  else "bytes"
  numerals <- match.arg(numerals)
  if (skip > 0) 
    readLines(file, skip)
  nlines <- n0lines <- if (nrows < 0) 
    5
  else min(5, (header + nrows))
  lines <- .External(C_readtablehead, file, nlines, comment.char, blank.lines.skip, quote, sep, skipNul)
  if (encoding %in% c("UTF-8", "latin1")) 
    Encoding(lines) <- encoding
  nlines <- length(lines)
  if (!nlines) {
    if (missing(col.names)) 
      stop("no lines available in input")
    rlabp <- FALSE
    cols <- length(col.names)
  }
  else {
    if (all(!nzchar(lines))) 
      stop("empty beginning of file")
    if (nlines < n0lines && file == 0) {
      pushBack(c(lines, lines, ""), file, encoding = pbEncoding)
      on.exit((clearPushBack(stdin())))
    }
    else pushBack(c(lines, lines), file, encoding = pbEncoding)
    first <- scan(file, what = "", sep = sep, quote = quote, nlines = 1, quiet = TRUE, skip = 0, strip.white = TRUE, blank.lines.skip = blank.lines.skip, na.strings = character(0), comment.char = comment.char, allowEscapes = allowEscapes, encoding = encoding, skipNul = skipNul)
    col1 <- if (missing(col.names)) 
      length(first)
    else length(col.names)
    col <- numeric(nlines - 1)
    if (nlines > 1) 
      for (i in seq_along(col)) col[i] <- length(scan(file, what = "", sep = sep, quote = quote, nlines = 1, quiet = TRUE, skip = 0, strip.white = strip.white, blank.lines.skip = blank.lines.skip, comment.char = comment.char, allowEscapes = allowEscapes, encoding = encoding, skipNul = skipNul))
    cols <- max(col1, col)
    rlabp <- (cols - col1) == 1
    if (rlabp && missing(header)) 
      header <- TRUE
    if (!header) 
      rlabp <- FALSE
    if (header) {
      .External(C_readtablehead, file, 1, comment.char, blank.lines.skip, quote, sep, skipNul)
      if (missing(col.names)) 
        col.names <- first
      else if (length(first) != length(col.names)) 
        warning("header and 'col.names' are of different lengths")
    }
    else if (missing(col.names)) 
      col.names <- paste0("V", 1:cols)
    if (length(col.names) + rlabp < cols) 
      stop("more columns than column names")
    if (fill && length(col.names) > cols) 
      cols <- length(col.names)
    if (!fill && cols > 0 && length(col.names) > cols) 
      stop("more column names than columns")
    if (cols == 0) 
      stop("first five rows are empty: giving up")
  }
  if (check.names) 
    col.names <- make.names(col.names, unique = TRUE)
  if (rlabp) 
    col.names <- c("row.names", col.names)
  nmColClasses <- names(colClasses)
  if (is.null(nmColClasses)) {
    if (length(colClasses) < cols) 
      colClasses <- rep_len(colClasses, cols)
  }
  else {
    tmp <- rep_len(NA, cols)
    names(tmp) <- col.names
    i <- match(nmColClasses, col.names, 0)
    if (any(i <= 0)) 
      warning("not all columns named in 'colClasses' exist")
    tmp[i[i > 0]] <- colClasses[i > 0]
    colClasses <- tmp
  }
  what <- rep.int(list(""), cols)
  names(what) <- col.names
  colClasses[colClasses %in% c("real", "double")] <- "numeric"
  known <- colClasses %in% c("logical", "integer", "numeric", "complex", "character", "raw")
  what[known] <- lapply(colClasses[known], do.call, list(0))
  what[colClasses %in% "NULL"] <- list(NULL)
  keep <- !sapply(what, is.null)
  data <- scan(file = file, what = what, sep = sep, quote = quote, dec = dec, nmax = nrows, skip = 0, na.strings = na.strings, quiet = TRUE, fill = fill, strip.white = strip.white, blank.lines.skip = blank.lines.skip, multi.line = FALSE, comment.char = comment.char, allowEscapes = allowEscapes, flush = flush, encoding = encoding, skipNul = skipNul)
  nlines <- length(data[[which.max(keep)]])
  if (cols != length(data)) {
    warning("cols = ", cols, " != length(data) = ", length(data), domain = NA)
    cols <- length(data)
  }
  if (is.logical(as.is)) {
    as.is <- rep_len(as.is, cols)
  }
  else if (is.numeric(as.is)) {
    if (any(as.is < 1 | as.is > cols)) 
      stop("invalid numeric 'as.is' expression")
    i <- rep.int(FALSE, cols)
    i[as.is] <- TRUE
    as.is <- i
  }
  else if (is.character(as.is)) {
    i <- match(as.is, col.names, 0)
    if (any(i <= 0)) 
      warning("not all columns named in 'as.is' exist")
    i <- i[i > 0]
    as.is <- rep.int(FALSE, cols)
    as.is[i] <- TRUE
  }
  else if (length(as.is) != cols) 
    stop(gettextf("'as.is' has the wrong length %d  != cols = %d", length(as.is), cols), domain = NA)
  do <- keep & !known
  if (rlabp) 
    do[1] <- FALSE
  for (i in (1:cols)[do]) {
    data[[i]] <- if (is.na(colClasses[i])) 
      type.convert(data[[i]], as.is = as.is[i], dec = dec, numerals = numerals, na.strings = character(0))
    else if (colClasses[i] == "factor") 
      as.factor(data[[i]])
    else if (colClasses[i] == "Date") 
      as.Date(data[[i]])
    else if (colClasses[i] == "POSIXct") 
      as.POSIXct(data[[i]])
    else methods::as(data[[i]], colClasses[i])
  }
  compactRN <- TRUE
  if (missing(row.names)) {
    if (rlabp) {
      row.names <- data[[1]]
      data <- data[-1]
      keep <- keep[-1]
      compactRN <- FALSE
    }
    else row.names <- .set_row_names(as.integer(nlines))
  }
  else if (is.null(row.names)) {
    row.names <- .set_row_names(as.integer(nlines))
  }
  else if (is.character(row.names)) {
    compactRN <- FALSE
    if (length(row.names) == 1) {
      rowvar <- (1:cols)[match(col.names, row.names, 0) == 1]
      row.names <- data[[rowvar]]
      data <- data[-rowvar]
      keep <- keep[-rowvar]
    }
  }
  else if (is.numeric(row.names) && length(row.names) == 1) {
    compactRN <- FALSE
    rlabp <- row.names
    row.names <- data[[rlabp]]
    data <- data[-rlabp]
    keep <- keep[-rlabp]
  }
  else stop("invalid 'row.names' specification")
  data <- data[keep]
  if (is.object(row.names) || !(is.integer(row.names))) 
    row.names <- as.character(row.names)
  if (!compactRN) {
    if (length(row.names) != nlines) 
      stop("invalid 'row.names' length")
    if (anyDuplicated(row.names)) 
      stop("duplicate 'row.names' are not allowed")
    if (anyNA(row.names)) 
      stop("missing values in 'row.names' are not allowed")
  }
  class(data) <- "data.frame"
  attr(data, "row.names") <- row.names
  data
}, function (file, header = FALSE, sep = "", quote = "\"'", dec = ".", numerals = c("allow.loss", "warn.loss", "no.loss"), row.names, col.names, as.is = !stringsAsFactors, na.strings = "NA", colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = "#", allowEscapes = FALSE, flush = FALSE, stringsAsFactors = FALSE, fileEncoding = "", encoding = "unknown", text, skipNul = FALSE) 
{
  if (missing(file) && !missing(text)) {
    file <- textConnection(text, encoding = "UTF-8")
    encoding <- "UTF-8"
    on.exit(close(file))
  }
  if (is.character(file)) {
    file <- if (nzchar(fileEncoding)) 
      file(file, "rt", encoding = fileEncoding)
    else file(file, "rt")
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  if (!isOpen(file, "rt")) {
    open(file, "rt")
    on.exit(close(file))
  }
  pbEncoding <- if (encoding %in% c("", "bytes", "UTF-8")) 
    encoding
  else "bytes"
  numerals <- match.arg(numerals)
  if (skip > 0) 
    readLines(file, skip)
  nlines <- n0lines <- if (nrows < 0) 
    5
  else min(5, (header + nrows))
  lines <- .External(C_readtablehead, file, nlines, comment.char, blank.lines.skip, quote, sep, skipNul)
  if (encoding %in% c("UTF-8", "latin1")) 
    Encoding(lines) <- encoding
  nlines <- length(lines)
  if (!nlines) {
    if (missing(col.names)) 
      stop("no lines available in input")
    rlabp <- FALSE
    cols <- length(col.names)
  }
  else {
    if (all(!nzchar(lines))) 
      stop("empty beginning of file")
    if (nlines < n0lines && file == 0) {
      pushBack(c(lines, lines, ""), file, encoding = pbEncoding)
      on.exit((clearPushBack(stdin())))
    }
    else pushBack(c(lines, lines), file, encoding = pbEncoding)
    first <- scan(file, what = "", sep = sep, quote = quote, nlines = 1, quiet = TRUE, skip = 0, strip.white = TRUE, blank.lines.skip = blank.lines.skip, na.strings = character(0), comment.char = comment.char, allowEscapes = allowEscapes, encoding = encoding, skipNul = skipNul)
    col1 <- if (missing(col.names)) 
      length(first)
    else length(col.names)
    col <- numeric(nlines - 1)
    if (nlines > 1) 
      for (i in seq_along(col)) col[i] <- length(scan(file, what = "", sep = sep, quote = quote, nlines = 1, quiet = TRUE, skip = 0, strip.white = strip.white, blank.lines.skip = blank.lines.skip, comment.char = comment.char, allowEscapes = allowEscapes, encoding = encoding, skipNul = skipNul))
    cols <- max(col1, col)
    rlabp <- (cols - col1) == 1
    if (rlabp && missing(header)) 
      header <- TRUE
    if (!header) 
      rlabp <- FALSE
    if (header) {
      .External(C_readtablehead, file, 1, comment.char, blank.lines.skip, quote, sep, skipNul)
      if (missing(col.names)) 
        col.names <- first
      else if (length(first) != length(col.names)) 
        warning("header and 'col.names' are of different lengths")
    }
    else if (missing(col.names)) 
      col.names <- paste0("V", 1:cols)
    if (length(col.names) + rlabp < cols) 
      stop("more columns than column names")
    if (fill && length(col.names) > cols) 
      cols <- length(col.names)
    if (!fill && cols > 0 && length(col.names) > cols) 
      stop("more column names than columns")
    if (cols == 0) 
      stop("first five rows are empty: giving up")
  }
  if (check.names) 
    col.names <- make.names(col.names, unique = TRUE)
  if (rlabp) 
    col.names <- c("row.names", col.names)
  nmColClasses <- names(colClasses)
  if (is.null(nmColClasses)) {
    if (length(colClasses) < cols) 
      colClasses <- rep_len(colClasses, cols)
  }
  else {
    tmp <- rep_len(NA, cols)
    names(tmp) <- col.names
    i <- match(nmColClasses, col.names, 0)
    if (any(i <= 0)) 
      warning("not all columns named in 'colClasses' exist")
    tmp[i[i > 0]] <- colClasses[i > 0]
    colClasses <- tmp
  }
  what <- rep.int(list(""), cols)
  names(what) <- col.names
  colClasses[colClasses %in% c("real", "double")] <- "numeric"
  known <- colClasses %in% c("logical", "integer", "numeric", "complex", "character", "raw")
  what[known] <- lapply(colClasses[known], do.call, list(0))
  what[colClasses %in% "NULL"] <- list(NULL)
  keep <- !sapply(what, is.null)
  data <- scan(file = file, what = what, sep = sep, quote = quote, dec = dec, nmax = nrows, skip = 0, na.strings = na.strings, quiet = TRUE, fill = fill, strip.white = strip.white, blank.lines.skip = blank.lines.skip, multi.line = FALSE, comment.char = comment.char, allowEscapes = allowEscapes, flush = flush, encoding = encoding, skipNul = skipNul)
  nlines <- length(data[[which.max(keep)]])
  if (cols != length(data)) {
    warning("cols = ", cols, " != length(data) = ", length(data), domain = NA)
    cols <- length(data)
  }
  if (is.logical(as.is)) {
    as.is <- rep_len(as.is, cols)
  }
  else if (is.numeric(as.is)) {
    if (any(as.is < 1 | as.is > cols)) 
      stop("invalid numeric 'as.is' expression")
    i <- rep.int(FALSE, cols)
    i[as.is] <- TRUE
    as.is <- i
  }
  else if (is.character(as.is)) {
    i <- match(as.is, col.names, 0)
    if (any(i <= 0)) 
      warning("not all columns named in 'as.is' exist")
    i <- i[i > 0]
    as.is <- rep.int(FALSE, cols)
    as.is[i] <- TRUE
  }
  else if (length(as.is) != cols) 
    stop(gettextf("'as.is' has the wrong length %d  != cols = %d", length(as.is), cols), domain = NA)
  do <- keep & !known
  if (rlabp) 
    do[1] <- FALSE
  for (i in (1:cols)[do]) {
    data[[i]] <- if (is.na(colClasses[i])) 
      type.convert(data[[i]], as.is = as.is[i], dec = dec, numerals = numerals, na.strings = character(0))
    else if (colClasses[i] == "factor") 
      as.factor(data[[i]])
    else if (colClasses[i] == "Date") 
      as.Date(data[[i]])
    else if (colClasses[i] == "POSIXct") 
      as.POSIXct(data[[i]])
    else methods::as(data[[i]], colClasses[i])
  }
  compactRN <- TRUE
  if (missing(row.names)) {
    if (rlabp) {
      row.names <- data[[1]]
      data <- data[-1]
      keep <- keep[-1]
      compactRN <- FALSE
    }
    else row.names <- .set_row_names(as.integer(nlines))
  }
  else if (is.null(row.names)) {
    row.names <- .set_row_names(as.integer(nlines))
  }
  else if (is.character(row.names)) {
    compactRN <- FALSE
    if (length(row.names) == 1) {
      rowvar <- (1:cols)[match(col.names, row.names, 0) == 1]
      row.names <- data[[rowvar]]
      data <- data[-rowvar]
      keep <- keep[-rowvar]
    }
  }
  else if (is.numeric(row.names) && length(row.names) == 1) {
    compactRN <- FALSE
    rlabp <- row.names
    row.names <- data[[rlabp]]
    data <- data[-rlabp]
    keep <- keep[-rlabp]
  }
  else stop("invalid 'row.names' specification")
  data <- data[keep]
  if (is.object(row.names) || !(is.integer(row.names))) 
    row.names <- as.character(row.names)
  if (!compactRN) {
    if (length(row.names) != nlines) 
      stop("invalid 'row.names' length")
    if (anyDuplicated(row.names)) 
      stop("duplicate 'row.names' are not allowed")
    if (anyNA(row.names)) 
      stop("missing values in 'row.names' are not allowed")
  }
  class(data) <- "data.frame"
  attr(data, "row.names") <- row.names
  data
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
readCitationFile
list(`package:utils` = function (file, meta = NULL) 
{
  meta <- as.list(meta)
  exprs <- tools:::.parse_CITATION_file(file, meta$Encoding)
  rval <- list()
  mheader <- NULL
  mfooter <- NULL
  envir <- new.env(hash = TRUE)
  assign("meta", meta, envir = envir)
  for (expr in exprs) {
    x <- eval(expr, envir = envir)
    if (inherits(x, "bibentry")) 
      rval <- c(rval, list(x))
    else if (identical(class(x), "citationHeader")) 
      mheader <- c(mheader, x)
    else if (identical(class(x), "citationFooter")) 
      mfooter <- c(mfooter, x)
  }
  rlen <- length(rval)
  if (rlen == 1) 
    rval <- rval[[1]]
  else if (rlen > 1) 
    rval <- do.call(c, rval)
  if (!.is_not_nonempty_text(mheader)) 
    attr(rval, "mheader") <- paste(mheader, collapse = "\n")
  if (!.is_not_nonempty_text(mfooter)) 
    attr(rval, "mfooter") <- paste(mfooter, collapse = "\n")
  .citation(rval, meta$Package)
}, function (file, meta = NULL) 
{
  meta <- as.list(meta)
  exprs <- tools:::.parse_CITATION_file(file, meta$Encoding)
  rval <- list()
  mheader <- NULL
  mfooter <- NULL
  envir <- new.env(hash = TRUE)
  assign("meta", meta, envir = envir)
  for (expr in exprs) {
    x <- eval(expr, envir = envir)
    if (inherits(x, "bibentry")) 
      rval <- c(rval, list(x))
    else if (identical(class(x), "citationHeader")) 
      mheader <- c(mheader, x)
    else if (identical(class(x), "citationFooter")) 
      mfooter <- c(mfooter, x)
  }
  rlen <- length(rval)
  if (rlen == 1) 
    rval <- rval[[1]]
  else if (rlen > 1) 
    rval <- do.call(c, rval)
  if (!.is_not_nonempty_text(mheader)) 
    attr(rval, "mheader") <- paste(mheader, collapse = "\n")
  if (!.is_not_nonempty_text(mfooter)) 
    attr(rval, "mfooter") <- paste(mfooter, collapse = "\n")
  .citation(rval, meta$Package)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
readClipboard
list(`package:utils` = function (format = 1, raw = FALSE) 
  .Call(C_readClipboard, format, raw), function (format = 1, raw = FALSE) 
    .Call(C_readClipboard, format, raw))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
readRegistry
list(`package:utils` = function (key, hive = c("HLM", "HCR", "HCU", "HU", "HCC", "HPD"), maxdepth = 1, view = c("default", "32-bit", "64-bit")) 
{
  view <- match(match.arg(view), c("default", "32-bit", "64-bit"))
  .External2(C_readRegistry, key, match.arg(hive), maxdepth, view)
}, function (key, hive = c("HLM", "HCR", "HCU", "HU", "HCC", "HPD"), maxdepth = 1, view = c("default", "32-bit", "64-bit")) 
{
  view <- match(match.arg(view), c("default", "32-bit", "64-bit"))
  .External2(C_readRegistry, key, match.arg(hive), maxdepth, view)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
recover
list(`package:utils` = function () 
{
  if (.isMethodsDispatchOn()) {
    tState <- tracingState(FALSE)
    on.exit(tracingState(tState))
  }
  calls <- sys.calls()
  from <- 0
  n <- length(calls)
  if (identical(sys.function(n), recover)) 
    n <- n - 1
  for (i in rev(seq_len(n))) {
    calli <- calls[[i]]
    fname <- calli[[1]]
    if (!is.na(match(deparse(fname)[1], c("methods::.doTrace", ".doTrace")))) {
      from <- i - 1
      break
    }
  }
  if (from == 0) 
    for (i in rev(seq_len(n))) {
      calli <- calls[[i]]
      fname <- calli[[1]]
      if (!is.name(fname) || is.na(match(as.character(fname), c("recover", "stop", "Stop")))) {
        from <- i
        break
      }
    }
  if (from > 0) {
    if (!interactive()) {
      try(dump.frames())
      cat(gettext("recover called non-interactively; frames dumped, use debugger() to view\n"))
      return(NULL)
    }
    calls <- limitedLabels(calls[1:from])
    repeat {
      which <- menu(calls, title = "\nEnter a frame number, or 0 to exit  ")
      if (which) 
        eval(substitute(browser(skipCalls = skip), list(skip = 7 - which)), envir = sys.frame(which))
      else break
    }
  }
  else cat(gettext("No suitable frames for recover()\n"))
}, function () 
{
  if (.isMethodsDispatchOn()) {
    tState <- tracingState(FALSE)
    on.exit(tracingState(tState))
  }
  calls <- sys.calls()
  from <- 0
  n <- length(calls)
  if (identical(sys.function(n), recover)) 
    n <- n - 1
  for (i in rev(seq_len(n))) {
    calli <- calls[[i]]
    fname <- calli[[1]]
    if (!is.na(match(deparse(fname)[1], c("methods::.doTrace", ".doTrace")))) {
      from <- i - 1
      break
    }
  }
  if (from == 0) 
    for (i in rev(seq_len(n))) {
      calli <- calls[[i]]
      fname <- calli[[1]]
      if (!is.name(fname) || is.na(match(as.character(fname), c("recover", "stop", "Stop")))) {
        from <- i
        break
      }
    }
  if (from > 0) {
    if (!interactive()) {
      try(dump.frames())
      cat(gettext("recover called non-interactively; frames dumped, use debugger() to view\n"))
      return(NULL)
    }
    calls <- limitedLabels(calls[1:from])
    repeat {
      which <- menu(calls, title = "\nEnter a frame number, or 0 to exit  ")
      if (which) 
        eval(substitute(browser(skipCalls = skip), list(skip = 7 - which)), envir = sys.frame(which))
      else break
    }
  }
  else cat(gettext("No suitable frames for recover()\n"))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
relist
list(`package:utils` = function (flesh, skeleton = attr(flesh, "skeleton")) 
{
  if (is.null(skeleton)) {
    stop("The 'flesh' argument does not contain a skeleton attribute.\n", "Either ensure you unlist a relistable object, or specify the skeleton separately.")
  }
  UseMethod("relist", skeleton)
}, function (flesh, skeleton = attr(flesh, "skeleton")) 
{
  if (is.null(skeleton)) {
    stop("The 'flesh' argument does not contain a skeleton attribute.\n", "Either ensure you unlist a relistable object, or specify the skeleton separately.")
  }
  UseMethod("relist", skeleton)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
remhash
list(`package:utils` = function (h, key) 
  invisible(.External(C_remhash_Ext, h, key)), function (h, key) 
    invisible(.External(C_remhash_Ext, h, key)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
remove.packages
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (pkgs, lib) 
  {
    if (!length(pkgs)) 
      return(invisible())
    base <- vapply(pkgs, isBasePkg, FALSE)
    if (any(base)) {
      (if (all(base)) 
        stop
       else warning)(sprintf(ngettext(sum(base), "package %s is a base package, and cannot be removed", "packages %s are base packages, and cannot be removed"), paste(sQuote(pkgs[base]), collapse = ", ")), domain = NA)
      pkgs <- pkgs[!base]
    }
    updateIndices <- function(lib) {
      if (lib == .Library && .Platform$OS.type == "unix") {
        message("Updating HTML index of packages in '.Library'")
        make.packages.html(.Library)
      }
      Rcss <- file.path(lib, "R.css")
      if (file.exists(Rcss)) {
        pkgs <- Sys.glob(file.path(lib, "*", "Meta", "package.rds"))
        if (!length(pkgs)) 
          unlink(Rcss)
      }
    }
    if (missing(lib) || is.null(lib)) {
      lib <- .libPaths()[1]
      message(sprintf(ngettext(length(pkgs), "Removing package from %s\n(as %s is unspecified)", "Removing packages from %s\n(as %s is unspecified)"), sQuote(lib), sQuote("lib")), domain = NA)
    }
    paths <- find.package(pkgs, lib)
    if (length(paths)) {
      unlink(paths, TRUE)
      for (lib in unique(dirname(paths))) updateIndices(lib)
    }
    invisible()
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
removeSource
list(`package:utils` = function (fn) 
{
  recurse <- function(part) {
    if (is.name(part)) 
      return(part)
    attr(part, "srcref") <- NULL
    attr(part, "wholeSrcref") <- NULL
    attr(part, "srcfile") <- NULL
    if (is.language(part) && is.recursive(part)) {
      for (i in seq_along(part)) part[i] <- list(recurse(part[[i]]))
    }
    part
  }
  if (is.function(fn)) {
    if (!is.primitive(fn)) {
      attr(fn, "srcref") <- NULL
      at <- attributes(fn)
      attr(body(fn), "wholeSrcref") <- NULL
      attr(body(fn), "srcfile") <- NULL
      body(fn) <- recurse(body(fn))
      if (!is.null(at)) 
        attributes(fn) <- at
    }
    fn
  }
  else if (is.language(fn)) {
    recurse(fn)
  }
  else stop("argument is not a function or language object:", typeof(fn))
}, function (fn) 
{
  recurse <- function(part) {
    if (is.name(part)) 
      return(part)
    attr(part, "srcref") <- NULL
    attr(part, "wholeSrcref") <- NULL
    attr(part, "srcfile") <- NULL
    if (is.language(part) && is.recursive(part)) {
      for (i in seq_along(part)) part[i] <- list(recurse(part[[i]]))
    }
    part
  }
  if (is.function(fn)) {
    if (!is.primitive(fn)) {
      attr(fn, "srcref") <- NULL
      at <- attributes(fn)
      attr(body(fn), "wholeSrcref") <- NULL
      attr(body(fn), "srcfile") <- NULL
      body(fn) <- recurse(body(fn))
      if (!is.null(at)) 
        attributes(fn) <- at
    }
    fn
  }
  else if (is.language(fn)) {
    recurse(fn)
  }
  else stop("argument is not a function or language object:", typeof(fn))
}, function (fn) 
{
  recurse <- function(part) {
    if (is.name(part)) 
      return(part)
    attr(part, "srcref") <- NULL
    attr(part, "wholeSrcref") <- NULL
    attr(part, "srcfile") <- NULL
    if (is.language(part) && is.recursive(part)) {
      for (i in seq_along(part)) part[i] <- list(recurse(part[[i]]))
    }
    part
  }
  if (is.function(fn)) {
    if (!is.primitive(fn)) {
      attr(fn, "srcref") <- NULL
      attr(body(fn), "wholeSrcref") <- NULL
      attr(body(fn), "srcfile") <- NULL
      body(fn) <- recurse(body(fn))
    }
    fn
  }
  else if (is.language(fn)) {
    recurse(fn)
  }
  else {
    stop("argument is not a function or language object:", typeof(fn))
  }
})
c("package:utils", "namespace:utils", "namespace:backports")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
Rprof
list(`package:utils` = function (...) 
{
  on.exit(hook(...))
  .rs.callAs(name, original, ...)
}, function (...) 
{
  on.exit(hook(...))
  .rs.callAs(name, original, ...)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
Rprofmem
list(`package:utils` = function (filename = "Rprofmem.out", append = FALSE, threshold = 0) 
{
  if (is.null(filename)) 
    filename <- ""
  invisible(.External(C_Rprofmem, filename, append, as.double(threshold)))
}, function (filename = "Rprofmem.out", append = FALSE, threshold = 0) 
{
  if (is.null(filename)) 
    filename <- ""
  invisible(.External(C_Rprofmem, filename, append, as.double(threshold)))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RShowDoc
list(`package:utils` = function (what, type = c("pdf", "html", "txt"), package) 
{
  paste. <- function(x, ext) paste(x, ext, sep = ".")
  pdf_viewer <- function(path) {
    pdfviewer <- getOption("pdfviewer")
    if (identical(pdfviewer, "false")) {
    }
    else if (.Platform$OS.type == "windows" && identical(pdfviewer, file.path(R.home("bin"), "open.exe"))) 
      shell.exec(path)
    else system2(pdfviewer, shQuote(path), wait = FALSE)
  }
  html_viewer <- function(path) {
    browser <- getOption("browser")
    if (is.null(browser) && .Platform$OS.type == "windows") 
      shell.exec(chartr("/", "\\", path))
    else browseURL(paste0("file://", URLencode(path)))
  }
  type <- match.arg(type)
  if (missing(what) || length(what) != 1 || !is.character(what)) {
    message("   RShowDoc() should be used with a character string argument specifying\n   a documentation file")
    return(invisible())
  }
  if (!missing(package)) {
    pkgpath <- find.package(package)
    if (type == "pdf") {
      path <- file.path(pkgpath, "doc", paste.(what, "pdf"))
      if (file.exists(path)) {
        pdf_viewer(path)
        return(invisible(path))
      }
      path <- file.path(pkgpath, paste.(what, "pdf"))
      if (file.exists(path)) {
        pdf_viewer(path)
        return(invisible(path))
      }
      type <- "html"
    }
    if (type == "html") {
      path <- file.path(pkgpath, "doc", paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
      path <- file.path(pkgpath, paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
    }
    path <- file.path(pkgpath, "doc", what)
    if (file.exists(path)) {
      file.show(path)
      return(invisible(path))
    }
    path <- file.path(pkgpath, what)
    if (file.exists(path)) {
      file.show(path)
      return(invisible(path))
    }
    stop(gettextf("no documentation for %s found in package %s", sQuote(what), sQuote(package)), domain = NA)
  }
  if (what == "FAQ") 
    what <- "R-FAQ"
  if (what == "NEWS") {
    if (type == "pdf") {
      path <- file.path(R.home("doc"), paste.(what, "pdf"))
      if (file.exists(path)) {
        pdf_viewer(path)
        return(invisible(path))
      }
      type <- "html"
    }
    if (type == "html") {
      path <- file.path(R.home("doc"), "html", paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
    }
    path <- file.path(R.home("doc"), what)
    tf <- tempfile()
    tmp <- readLines(path)
    tmp[1] <- ""
    writeLines(tmp, tf)
    file.show(tf, delete.file = TRUE, encoding = "UTF-8")
    return(invisible(path))
  }
  else if (what == "COPYING") {
    path <- file.path(R.home("doc"), what)
    file.show(path)
    return(invisible(path))
  }
  else if (what %in% dir(file.path(R.home("share"), "licenses"))) {
    path <- file.path(R.home("share"), "licenses", what)
    file.show(path)
    return(invisible(path))
  }
  else if (what %in% c("R-admin", "R-data", "R-exts", "R-FAQ", "R-intro", "R-ints", "R-lang")) {
    if (type == "pdf") {
      path <- file.path(R.home("doc"), "manual", paste.(what, "pdf"))
      if (file.exists(path)) {
        pdf_viewer(path)
        return(invisible(path))
      }
      type <- "html"
    }
    if (type == "html") {
      path <- file.path(R.home("doc"), "manual", paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
    }
    if (what == "R-FAQ" && file.exists(path <- file.path(R.home("doc"), "FAQ"))) {
      file.show(path)
      return(invisible(path))
    }
  }
  else if (.Platform$OS.type == "windows" && what %in% "rw-FAQ") {
    if (type == "pdf") 
      type <- "html"
    if (type == "html") {
      path <- file.path(R.home("doc"), "html", paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
    }
    path <- file.path(R.home("doc"), what)
    if (file.exists(path)) {
      file.show(path)
      return(invisible(path))
    }
    path <- file.path(R.home(), "src", "gnuwin32", what)
    if (file.exists(path)) {
      file.show(path)
      return(invisible(path))
    }
  }
  else {
    rdocdir <- R.home("doc")
    docs <- dir(rdocdir, full.names = TRUE)
    docs <- docs[vapply(docs, function(x) file_test("-f", x), NA)]
    m <- match(what, basename(docs), 0)
    if (m > 0) {
      file.show(docs[m])
      return(invisible(docs[m]))
    }
  }
  stop("document not found")
}, function (what, type = c("pdf", "html", "txt"), package) 
{
  paste. <- function(x, ext) paste(x, ext, sep = ".")
  pdf_viewer <- function(path) {
    pdfviewer <- getOption("pdfviewer")
    if (identical(pdfviewer, "false")) {
    }
    else if (.Platform$OS.type == "windows" && identical(pdfviewer, file.path(R.home("bin"), "open.exe"))) 
      shell.exec(path)
    else system2(pdfviewer, shQuote(path), wait = FALSE)
  }
  html_viewer <- function(path) {
    browser <- getOption("browser")
    if (is.null(browser) && .Platform$OS.type == "windows") 
      shell.exec(chartr("/", "\\", path))
    else browseURL(paste0("file://", URLencode(path)))
  }
  type <- match.arg(type)
  if (missing(what) || length(what) != 1 || !is.character(what)) {
    message("   RShowDoc() should be used with a character string argument specifying\n   a documentation file")
    return(invisible())
  }
  if (!missing(package)) {
    pkgpath <- find.package(package)
    if (type == "pdf") {
      path <- file.path(pkgpath, "doc", paste.(what, "pdf"))
      if (file.exists(path)) {
        pdf_viewer(path)
        return(invisible(path))
      }
      path <- file.path(pkgpath, paste.(what, "pdf"))
      if (file.exists(path)) {
        pdf_viewer(path)
        return(invisible(path))
      }
      type <- "html"
    }
    if (type == "html") {
      path <- file.path(pkgpath, "doc", paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
      path <- file.path(pkgpath, paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
    }
    path <- file.path(pkgpath, "doc", what)
    if (file.exists(path)) {
      file.show(path)
      return(invisible(path))
    }
    path <- file.path(pkgpath, what)
    if (file.exists(path)) {
      file.show(path)
      return(invisible(path))
    }
    stop(gettextf("no documentation for %s found in package %s", sQuote(what), sQuote(package)), domain = NA)
  }
  if (what == "FAQ") 
    what <- "R-FAQ"
  if (what == "NEWS") {
    if (type == "pdf") {
      path <- file.path(R.home("doc"), paste.(what, "pdf"))
      if (file.exists(path)) {
        pdf_viewer(path)
        return(invisible(path))
      }
      type <- "html"
    }
    if (type == "html") {
      path <- file.path(R.home("doc"), "html", paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
    }
    path <- file.path(R.home("doc"), what)
    tf <- tempfile()
    tmp <- readLines(path)
    tmp[1] <- ""
    writeLines(tmp, tf)
    file.show(tf, delete.file = TRUE, encoding = "UTF-8")
    return(invisible(path))
  }
  else if (what == "COPYING") {
    path <- file.path(R.home("doc"), what)
    file.show(path)
    return(invisible(path))
  }
  else if (what %in% dir(file.path(R.home("share"), "licenses"))) {
    path <- file.path(R.home("share"), "licenses", what)
    file.show(path)
    return(invisible(path))
  }
  else if (what %in% c("R-admin", "R-data", "R-exts", "R-FAQ", "R-intro", "R-ints", "R-lang")) {
    if (type == "pdf") {
      path <- file.path(R.home("doc"), "manual", paste.(what, "pdf"))
      if (file.exists(path)) {
        pdf_viewer(path)
        return(invisible(path))
      }
      type <- "html"
    }
    if (type == "html") {
      path <- file.path(R.home("doc"), "manual", paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
    }
    if (what == "R-FAQ" && file.exists(path <- file.path(R.home("doc"), "FAQ"))) {
      file.show(path)
      return(invisible(path))
    }
  }
  else if (.Platform$OS.type == "windows" && what %in% "rw-FAQ") {
    if (type == "pdf") 
      type <- "html"
    if (type == "html") {
      path <- file.path(R.home("doc"), "html", paste.(what, "html"))
      if (file.exists(path)) {
        html_viewer(path)
        return(invisible(path))
      }
    }
    path <- file.path(R.home("doc"), what)
    if (file.exists(path)) {
      file.show(path)
      return(invisible(path))
    }
    path <- file.path(R.home(), "src", "gnuwin32", what)
    if (file.exists(path)) {
      file.show(path)
      return(invisible(path))
    }
  }
  else {
    rdocdir <- R.home("doc")
    docs <- dir(rdocdir, full.names = TRUE)
    docs <- docs[vapply(docs, function(x) file_test("-f", x), NA)]
    m <- match(what, basename(docs), 0)
    if (m > 0) {
      file.show(docs[m])
      return(invisible(docs[m]))
    }
  }
  stop("document not found")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RSiteSearch
list(`package:utils` = function (string, restrict = c("functions", "descriptions", "news", "Rfunctions", "Rmanuals", "READMEs", "views", "vignettes"), format, sortby = c("score", "date:late", "date:early", "subject", "subject:descending", "size", "size:descending"), matchesPerPage = 20, words = c("all", "any")) 
{
  matchingDB = list(functions = "cran-help", descriptions = "cran-info", news = "cran-news", Rfunctions = "r-help", Rmanuals = "r-manuals", READMEs = "cran-readme", views = "cran-views", vignettes = "cran-vignettes")
  string <- paste0("https://search.r-project.org/?FMT=query&P=", gsub("%22", "\"", gsub("%20", "+", URLencode(gsub("[\\{\\}]", "\"", trimws(string)), reserved = TRUE), fixed = TRUE), fixed = TRUE))
  mpp <- paste0("HITSPERPAGE=", matchesPerPage)
  restr <- match.arg(restrict, several.ok = TRUE)
  if (length(restr) != length(restrict)) 
    warning("some options in argument 'restrict' were not recognized and hence ignored")
  restr <- paste(paste0("DB=", matchingDB[restr]), collapse = "&")
  sortby <- match.arg(sortby)
  sortby <- paste0("SORT=", switch(sortby, score = "", `date:late` = "-0", `date:early` = "%2B0", subject = "%2B3", `subject:descending` = "-3", size = "%2B2", `size:descending` = "-2"))
  words <- match.arg(words)
  words <- paste0("DEFAULTOP=", switch(words, all = "and", any = "or"))
  qstring <- paste(string, mpp, sortby, restr, words, sep = "&")
  browseURL(qstring)
  if (!missing("format")) 
    warning("argument 'format' is deprecated and has no affect on search results")
  cat(gettextf("A search query has been submitted to %s", "https://search.r-project.org"), "\n", sep = "")
  cat(gettext("The results page should open in your browser shortly\n"))
  invisible(qstring)
}, function (string, restrict = c("functions", "descriptions", "news", "Rfunctions", "Rmanuals", "READMEs", "views", "vignettes"), format, sortby = c("score", "date:late", "date:early", "subject", "subject:descending", "size", "size:descending"), matchesPerPage = 20, words = c("all", "any")) 
{
  matchingDB = list(functions = "cran-help", descriptions = "cran-info", news = "cran-news", Rfunctions = "r-help", Rmanuals = "r-manuals", READMEs = "cran-readme", views = "cran-views", vignettes = "cran-vignettes")
  string <- paste0("https://search.r-project.org/?FMT=query&P=", gsub("%22", "\"", gsub("%20", "+", URLencode(gsub("[\\{\\}]", "\"", trimws(string)), reserved = TRUE), fixed = TRUE), fixed = TRUE))
  mpp <- paste0("HITSPERPAGE=", matchesPerPage)
  restr <- match.arg(restrict, several.ok = TRUE)
  if (length(restr) != length(restrict)) 
    warning("some options in argument 'restrict' were not recognized and hence ignored")
  restr <- paste(paste0("DB=", matchingDB[restr]), collapse = "&")
  sortby <- match.arg(sortby)
  sortby <- paste0("SORT=", switch(sortby, score = "", `date:late` = "-0", `date:early` = "%2B0", subject = "%2B3", `subject:descending` = "-3", size = "%2B2", `size:descending` = "-2"))
  words <- match.arg(words)
  words <- paste0("DEFAULTOP=", switch(words, all = "and", any = "or"))
  qstring <- paste(string, mpp, sortby, restr, words, sep = "&")
  browseURL(qstring)
  if (!missing("format")) 
    warning("argument 'format' is deprecated and has no affect on search results")
  cat(gettextf("A search query has been submitted to %s", "https://search.r-project.org"), "\n", sep = "")
  cat(gettext("The results page should open in your browser shortly\n"))
  invisible(qstring)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
rtags
list(`package:utils` = function (path = ".", pattern = "\\.[RrSs]$", recursive = FALSE, src = list.files(path = path, pattern = pattern, full.names = TRUE, recursive = recursive), keep.re = NULL, ofile = "", append = FALSE, verbose = getOption("verbose"), type = c("etags", "ctags")) 
{
  type <- match.arg(type)
  if (nzchar(ofile) && !append) {
    if (!file.create(ofile, showWarnings = FALSE)) 
      stop(gettextf("Could not create file %s, aborting", ofile), domain = NA)
  }
  write.fun <- if (type == "ctags") 
    write.ctags
  else write.etags
  if (!missing(keep.re)) 
    src <- grep(keep.re, src, value = TRUE)
  for (s in src) {
    if (verbose) 
      message(gettextf("Processing file %s", s), domain = NA)
    tryCatch(rtags.file(s, ofile = ofile, append = TRUE, write.fun = write.fun), error = function(e) NULL)
  }
  if (type == "ctags" && nzchar(ofile)) {
    tagLines <- readLines(ofile)
    writeLines(sort(tagLines), con = ofile)
  }
  invisible()
}, function (path = ".", pattern = "\\.[RrSs]$", recursive = FALSE, src = list.files(path = path, pattern = pattern, full.names = TRUE, recursive = recursive), keep.re = NULL, ofile = "", append = FALSE, verbose = getOption("verbose"), type = c("etags", "ctags")) 
{
  type <- match.arg(type)
  if (nzchar(ofile) && !append) {
    if (!file.create(ofile, showWarnings = FALSE)) 
      stop(gettextf("Could not create file %s, aborting", ofile), domain = NA)
  }
  write.fun <- if (type == "ctags") 
    write.ctags
  else write.etags
  if (!missing(keep.re)) 
    src <- grep(keep.re, src, value = TRUE)
  for (s in src) {
    if (verbose) 
      message(gettextf("Processing file %s", s), domain = NA)
    tryCatch(rtags.file(s, ofile = ofile, append = TRUE, write.fun = write.fun), error = function(e) NULL)
  }
  if (type == "ctags" && nzchar(ofile)) {
    tagLines <- readLines(ofile)
    writeLines(sort(tagLines), con = ofile)
  }
  invisible()
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
Rtangle
list(`package:utils` = function () 
{
  list(setup = RtangleSetup, runcode = RtangleRuncode, writedoc = RtangleWritedoc, finish = RtangleFinish, checkopts = RweaveLatexOptions)
}, function () 
{
  list(setup = RtangleSetup, runcode = RtangleRuncode, writedoc = RtangleWritedoc, finish = RtangleFinish, checkopts = RweaveLatexOptions)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RtangleFinish
list(`package:utils` = function (object, error = FALSE) 
{
  if (!is.null(object$output) && object$output >= 3) 
    close(object$output)
  if (length(object$chunkout)) 
    for (con in object$chunkout) close(con)
}, function (object, error = FALSE) 
{
  if (!is.null(object$output) && object$output >= 3) 
    close(object$output)
  if (length(object$chunkout)) 
    for (con in object$chunkout) close(con)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RtangleRuncode
list(`package:utils` = function (object, chunk, options) 
{
  if (!(options$engine %in% c("R", "S"))) 
    return(object)
  chunkprefix <- RweaveChunkPrefix(options)
  if (options$split) {
    if (!grepl(.SweaveValidFilenameRegexp, chunkprefix)) 
      warning("file stem ", sQuote(chunkprefix), " is not portable", call. = FALSE, domain = NA)
    outfile <- paste(chunkprefix, options$engine, sep = ".")
    if (!object$quiet) 
      cat(options$chunknr, ":", outfile, "\n")
    chunkout <- object$chunkout[chunkprefix][[1]]
    if (is.null(chunkout)) {
      chunkout <- file(outfile, "w")
      if (!is.null(options$label)) 
        object$chunkout[[chunkprefix]] <- chunkout
    }
  }
  else chunkout <- object$output
  showOut <- options$eval || !object$drop.evalFALSE
  if (showOut) {
    annotate <- object$annotate
    if (is.logical(annotate) && annotate) {
      cat("###################################################\n", "### code chunk number ", options$chunknr, ": ", if (!is.null(ol <- options$label)) 
        ol
        else .RtangleCodeLabel(chunk), if (!options$eval) 
          " (eval = FALSE)", "\n", "###################################################\n", file = chunkout, sep = "")
    }
    else if (is.function(annotate)) 
      annotate(options, chunk = chunk, output = chunkout)
  }
  hooks <- SweaveHooks(options, run = FALSE)
  for (k in hooks) cat("getOption(\"SweaveHooks\")[[\"", k, "\"]]()\n", file = chunkout, sep = "")
  if (showOut) {
    if (!options$show.line.nos) 
      chunk <- grep("^#line ", chunk, value = TRUE, invert = TRUE)
    if (!options$eval) 
      chunk <- paste("##", chunk)
    cat(chunk, "\n", file = chunkout, sep = "\n")
  }
  if (is.null(options$label) && options$split) 
    close(chunkout)
  object
}, function (object, chunk, options) 
{
  if (!(options$engine %in% c("R", "S"))) 
    return(object)
  chunkprefix <- RweaveChunkPrefix(options)
  if (options$split) {
    if (!grepl(.SweaveValidFilenameRegexp, chunkprefix)) 
      warning("file stem ", sQuote(chunkprefix), " is not portable", call. = FALSE, domain = NA)
    outfile <- paste(chunkprefix, options$engine, sep = ".")
    if (!object$quiet) 
      cat(options$chunknr, ":", outfile, "\n")
    chunkout <- object$chunkout[chunkprefix][[1]]
    if (is.null(chunkout)) {
      chunkout <- file(outfile, "w")
      if (!is.null(options$label)) 
        object$chunkout[[chunkprefix]] <- chunkout
    }
  }
  else chunkout <- object$output
  showOut <- options$eval || !object$drop.evalFALSE
  if (showOut) {
    annotate <- object$annotate
    if (is.logical(annotate) && annotate) {
      cat("###################################################\n", "### code chunk number ", options$chunknr, ": ", if (!is.null(ol <- options$label)) 
        ol
        else .RtangleCodeLabel(chunk), if (!options$eval) 
          " (eval = FALSE)", "\n", "###################################################\n", file = chunkout, sep = "")
    }
    else if (is.function(annotate)) 
      annotate(options, chunk = chunk, output = chunkout)
  }
  hooks <- SweaveHooks(options, run = FALSE)
  for (k in hooks) cat("getOption(\"SweaveHooks\")[[\"", k, "\"]]()\n", file = chunkout, sep = "")
  if (showOut) {
    if (!options$show.line.nos) 
      chunk <- grep("^#line ", chunk, value = TRUE, invert = TRUE)
    if (!options$eval) 
      chunk <- paste("##", chunk)
    cat(chunk, "\n", file = chunkout, sep = "\n")
  }
  if (is.null(options$label) && options$split) 
    close(chunkout)
  object
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RtangleSetup
list(`package:utils` = function (file, syntax, output = NULL, annotate = TRUE, split = FALSE, quiet = FALSE, drop.evalFALSE = FALSE, ...) 
{
  dots <- list(...)
  if (is.null(output)) {
    prefix.string <- basename(sub(syntax$extension, "", file))
    output <- paste0(prefix.string, ".R")
  }
  else prefix.string <- basename(sub("\\.[rsRS]$", "", output))
  if (!split) {
    if (identical(output, "stdout")) 
      output <- stdout()
    else if (identical(output, "stderr")) 
      output <- stderr()
    else {
      if (!quiet) 
        cat("Writing to file", output, "\n")
      encoding <- attr(file, "encoding")
      if (encoding %in% c("ASCII", "bytes")) 
        encoding <- ""
      output <- file(output, open = "w", encoding = encoding)
    }
    lines <- c(paste("###", sprintf("R code from vignette source '%s'", file)), "")
    writeLines(lines, output)
  }
  else {
    if (!quiet) 
      cat("Writing chunks to files ...\n")
    output <- NULL
  }
  options <- list(split = split, prefix = TRUE, prefix.string = prefix.string, engine = "R", eval = TRUE, show.line.nos = FALSE)
  options$.defaults <- options
  options[names(dots)] <- dots
  options <- RweaveLatexOptions(options)
  list(output = output, annotate = annotate, options = options, chunkout = list(), quiet = quiet, syntax = syntax, drop.evalFALSE = drop.evalFALSE)
}, function (file, syntax, output = NULL, annotate = TRUE, split = FALSE, quiet = FALSE, drop.evalFALSE = FALSE, ...) 
{
  dots <- list(...)
  if (is.null(output)) {
    prefix.string <- basename(sub(syntax$extension, "", file))
    output <- paste0(prefix.string, ".R")
  }
  else prefix.string <- basename(sub("\\.[rsRS]$", "", output))
  if (!split) {
    if (identical(output, "stdout")) 
      output <- stdout()
    else if (identical(output, "stderr")) 
      output <- stderr()
    else {
      if (!quiet) 
        cat("Writing to file", output, "\n")
      encoding <- attr(file, "encoding")
      if (encoding %in% c("ASCII", "bytes")) 
        encoding <- ""
      output <- file(output, open = "w", encoding = encoding)
    }
    lines <- c(paste("###", sprintf("R code from vignette source '%s'", file)), "")
    writeLines(lines, output)
  }
  else {
    if (!quiet) 
      cat("Writing chunks to files ...\n")
    output <- NULL
  }
  options <- list(split = split, prefix = TRUE, prefix.string = prefix.string, engine = "R", eval = TRUE, show.line.nos = FALSE)
  options$.defaults <- options
  options[names(dots)] <- dots
  options <- RweaveLatexOptions(options)
  list(output = output, annotate = annotate, options = options, chunkout = list(), quiet = quiet, syntax = syntax, drop.evalFALSE = drop.evalFALSE)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RtangleWritedoc
list(`package:utils` = function (object, chunk) 
{
  while (length(pos <- grep(object$syntax$docopt, chunk))) {
    opts <- sub(paste0(".*", object$syntax$docopt, ".*"), "\\1", chunk[pos[1]])
    object$options <- SweaveParseOptions(opts, object$options, RweaveLatexOptions)
    chunk[pos[1]] <- sub(object$syntax$docopt, "", chunk[pos[1]])
  }
  object
}, function (object, chunk) 
{
  while (length(pos <- grep(object$syntax$docopt, chunk))) {
    opts <- sub(paste0(".*", object$syntax$docopt, ".*"), "\\1", chunk[pos[1]])
    object$options <- SweaveParseOptions(opts, object$options, RweaveLatexOptions)
    chunk[pos[1]] <- sub(object$syntax$docopt, "", chunk[pos[1]])
  }
  object
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RweaveChunkPrefix
list(`package:utils` = function (options) 
{
  if (!is.null(options$label)) {
    if (options$prefix) 
      paste0(options$prefix.string, "-", options$label)
    else options$label
  }
  else paste0(options$prefix.string, "-", formatC(options$chunknr, flag = "0", width = 3))
}, function (options) 
{
  if (!is.null(options$label)) {
    if (options$prefix) 
      paste0(options$prefix.string, "-", options$label)
    else options$label
  }
  else paste0(options$prefix.string, "-", formatC(options$chunknr, flag = "0", width = 3))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RweaveEvalWithOpt
list(`package:utils` = function (expr, options) 
{
  if (options$eval) {
    res <- try(withVisible(eval(expr, .GlobalEnv)), silent = TRUE)
    if (inherits(res, "try-error")) 
      return(res)
    if (options$print || (options$term && res$visible)) {
      if (.isMethodsDispatchOn() && isS4(res$value)) 
        methods::show(res$value)
      else print(res$value)
    }
  }
  res
}, function (expr, options) 
{
  if (options$eval) {
    res <- try(withVisible(eval(expr, .GlobalEnv)), silent = TRUE)
    if (inherits(res, "try-error")) 
      return(res)
    if (options$print || (options$term && res$visible)) {
      if (.isMethodsDispatchOn() && isS4(res$value)) 
        methods::show(res$value)
      else print(res$value)
    }
  }
  res
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RweaveLatex
list(`package:utils` = function () 
{
  list(setup = RweaveLatexSetup, runcode = RweaveLatexRuncode, writedoc = RweaveLatexWritedoc, finish = RweaveLatexFinish, checkopts = RweaveLatexOptions)
}, function () 
{
  list(setup = RweaveLatexSetup, runcode = RweaveLatexRuncode, writedoc = RweaveLatexWritedoc, finish = RweaveLatexFinish, checkopts = RweaveLatexOptions)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RweaveLatexFinish
list(`package:utils` = function (object, error = FALSE) 
{
  outputname <- summary(object$output)$description
  if (!object$quiet && !error) {
    if (!file.exists(outputname)) 
      stop(gettextf("the output file '%s' has disappeared", outputname))
    cat("\n", sprintf("You can now run (pdf)latex on %s", sQuote(outputname)), "\n", sep = "")
  }
  close(object$output)
  if (length(object$chunkout)) 
    for (con in object$chunkout) close(con)
  if (object$haveconcordance) {
    linesout <- object$linesout
    filenumout <- object$filenumout
    filenames <- object$srcFilenames[filenumout]
    if (!is.null(filenames)) {
      filegps <- rle(filenames)
      offset <- 0
      for (i in seq_along(filegps$lengths)) {
        len <- filegps$lengths[i]
        inputname <- filegps$values[i]
        vals <- rle(diff(linesout[offset + seq_len(len)]))
        vals <- c(linesout[offset + 1], as.numeric(rbind(vals$lengths, vals$values)))
        concordance <- paste(strwrap(paste(vals, collapse = " ")), collapse = " %\n")
        special <- paste0("\\Sconcordance{concordance:", outputname, ":", inputname, ":", if (offset) 
          paste0("ofs ", offset, ":")
          else "", "%\n", concordance, "}\n")
        cat(special, file = object$concordfile, append = offset > 0)
        offset <- offset + len
      }
    }
  }
  invisible(outputname)
}, function (object, error = FALSE) 
{
  outputname <- summary(object$output)$description
  if (!object$quiet && !error) {
    if (!file.exists(outputname)) 
      stop(gettextf("the output file '%s' has disappeared", outputname))
    cat("\n", sprintf("You can now run (pdf)latex on %s", sQuote(outputname)), "\n", sep = "")
  }
  close(object$output)
  if (length(object$chunkout)) 
    for (con in object$chunkout) close(con)
  if (object$haveconcordance) {
    linesout <- object$linesout
    filenumout <- object$filenumout
    filenames <- object$srcFilenames[filenumout]
    if (!is.null(filenames)) {
      filegps <- rle(filenames)
      offset <- 0
      for (i in seq_along(filegps$lengths)) {
        len <- filegps$lengths[i]
        inputname <- filegps$values[i]
        vals <- rle(diff(linesout[offset + seq_len(len)]))
        vals <- c(linesout[offset + 1], as.numeric(rbind(vals$lengths, vals$values)))
        concordance <- paste(strwrap(paste(vals, collapse = " ")), collapse = " %\n")
        special <- paste0("\\Sconcordance{concordance:", outputname, ":", inputname, ":", if (offset) 
          paste0("ofs ", offset, ":")
          else "", "%\n", concordance, "}\n")
        cat(special, file = object$concordfile, append = offset > 0)
        offset <- offset + len
      }
    }
  }
  invisible(outputname)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RweaveLatexOptions
list(`package:utils` = function (options) 
{
  defaults <- options[[".defaults"]]
  c2l <- function(x) if (is.null(x)) 
    FALSE
  else suppressWarnings(as.logical(x))
  NUMOPTS <- c("width", "height", "resolution")
  CHAROPTS <- c("results", "prefix.string", "engine", "label", "strip.white", "pdf.version", "pdf.encoding", "grdevice")
  for (opt in names(options)) {
    if (opt == ".defaults") 
      next
    oldval <- options[[opt]]
    defval <- defaults[[opt]]
    if (opt %in% CHAROPTS || is.character(defval)) {
    }
    else if (is.logical(defval)) 
      options[[opt]] <- c2l(oldval)
    else if (opt %in% NUMOPTS || is.numeric(defval)) 
      options[[opt]] <- as.numeric(oldval)
    else if (!is.na(newval <- c2l(oldval))) 
      options[[opt]] <- newval
    else if (!is.na(newval <- suppressWarnings(as.numeric(oldval)))) 
      options[[opt]] <- newval
    if (is.na(options[[opt]])) 
      stop(gettextf("invalid value for %s : %s", sQuote(opt), oldval), domain = NA)
  }
  if (!is.null(options$results)) {
    res <- as.character(options$results)
    if (tolower(res) != res) 
      warning("value of 'results' option should be lowercase", call. = FALSE)
    options$results <- tolower(res)
  }
  options$results <- match.arg(options$results, c("verbatim", "tex", "hide"))
  if (!is.null(options$strip.white)) {
    res <- as.character(options$strip.white)
    if (tolower(res) != res) 
      warning("value of 'strip.white' option should be lowercase", call. = FALSE)
    options$strip.white <- tolower(res)
  }
  options$strip.white <- match.arg(options$strip.white, c("true", "false", "all"))
  options
}, function (options) 
{
  defaults <- options[[".defaults"]]
  c2l <- function(x) if (is.null(x)) 
    FALSE
  else suppressWarnings(as.logical(x))
  NUMOPTS <- c("width", "height", "resolution")
  CHAROPTS <- c("results", "prefix.string", "engine", "label", "strip.white", "pdf.version", "pdf.encoding", "grdevice")
  for (opt in names(options)) {
    if (opt == ".defaults") 
      next
    oldval <- options[[opt]]
    defval <- defaults[[opt]]
    if (opt %in% CHAROPTS || is.character(defval)) {
    }
    else if (is.logical(defval)) 
      options[[opt]] <- c2l(oldval)
    else if (opt %in% NUMOPTS || is.numeric(defval)) 
      options[[opt]] <- as.numeric(oldval)
    else if (!is.na(newval <- c2l(oldval))) 
      options[[opt]] <- newval
    else if (!is.na(newval <- suppressWarnings(as.numeric(oldval)))) 
      options[[opt]] <- newval
    if (is.na(options[[opt]])) 
      stop(gettextf("invalid value for %s : %s", sQuote(opt), oldval), domain = NA)
  }
  if (!is.null(options$results)) {
    res <- as.character(options$results)
    if (tolower(res) != res) 
      warning("value of 'results' option should be lowercase", call. = FALSE)
    options$results <- tolower(res)
  }
  options$results <- match.arg(options$results, c("verbatim", "tex", "hide"))
  if (!is.null(options$strip.white)) {
    res <- as.character(options$strip.white)
    if (tolower(res) != res) 
      warning("value of 'strip.white' option should be lowercase", call. = FALSE)
    options$strip.white <- tolower(res)
  }
  options$strip.white <- match.arg(options$strip.white, c("true", "false", "all"))
  options
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RweaveLatexSetup
list(`package:utils` = function (file, syntax, output = NULL, quiet = FALSE, debug = FALSE, stylepath, ...) 
{
  dots <- list(...)
  if (is.null(output)) {
    prefix.string <- basename(sub(syntax$extension, "", file))
    output <- paste0(prefix.string, ".tex")
  }
  else prefix.string <- basename(sub("\\.tex$", "", output))
  if (!quiet) 
    cat("Writing to file ", output, "\n", "Processing code chunks with options ...\n", sep = "")
  encoding <- attr(file, "encoding")
  if (encoding %in% c("ASCII", "bytes")) 
    encoding <- ""
  output <- file(output, open = "w", encoding = encoding)
  if (missing(stylepath)) {
    p <- Sys.getenv("SWEAVE_STYLEPATH_DEFAULT")
    stylepath <- if (length(p) >= 1 && nzchar(p[1])) 
      identical(p, "TRUE")
    else FALSE
  }
  if (stylepath) {
    styfile <- file.path(R.home("share"), "texmf", "tex", "latex", "Sweave")
    if (.Platform$OS.type == "windows") 
      styfile <- chartr("\\", "/", styfile)
    if (length(grep(" ", styfile))) 
      warning(gettextf("path to %s contains spaces,\n", sQuote(styfile)), gettext("this may cause problems when running LaTeX"), domain = NA)
  }
  else styfile <- "Sweave"
  options <- list(prefix = TRUE, prefix.string = prefix.string, engine = "R", print = FALSE, eval = TRUE, fig = FALSE, pdf = TRUE, eps = FALSE, png = FALSE, jpeg = FALSE, grdevice = "", width = 6, height = 6, resolution = 300, term = TRUE, echo = TRUE, keep.source = TRUE, results = "verbatim", split = FALSE, strip.white = "true", include = TRUE, pdf.version = grDevices::pdf.options()$version, pdf.encoding = grDevices::pdf.options()$encoding, pdf.compress = grDevices::pdf.options()$compress, expand = TRUE, 
                  concordance = FALSE, figs.only = TRUE)
  options$.defaults <- options
  options[names(dots)] <- dots
  options <- RweaveLatexOptions(options)
  list(output = output, styfile = styfile, havesty = FALSE, haveconcordance = FALSE, debug = debug, quiet = quiet, syntax = syntax, options = options, chunkout = list(), srclines = integer())
}, function (file, syntax, output = NULL, quiet = FALSE, debug = FALSE, stylepath, ...) 
{
  dots <- list(...)
  if (is.null(output)) {
    prefix.string <- basename(sub(syntax$extension, "", file))
    output <- paste0(prefix.string, ".tex")
  }
  else prefix.string <- basename(sub("\\.tex$", "", output))
  if (!quiet) 
    cat("Writing to file ", output, "\n", "Processing code chunks with options ...\n", sep = "")
  encoding <- attr(file, "encoding")
  if (encoding %in% c("ASCII", "bytes")) 
    encoding <- ""
  output <- file(output, open = "w", encoding = encoding)
  if (missing(stylepath)) {
    p <- Sys.getenv("SWEAVE_STYLEPATH_DEFAULT")
    stylepath <- if (length(p) >= 1 && nzchar(p[1])) 
      identical(p, "TRUE")
    else FALSE
  }
  if (stylepath) {
    styfile <- file.path(R.home("share"), "texmf", "tex", "latex", "Sweave")
    if (.Platform$OS.type == "windows") 
      styfile <- chartr("\\", "/", styfile)
    if (length(grep(" ", styfile))) 
      warning(gettextf("path to %s contains spaces,\n", sQuote(styfile)), gettext("this may cause problems when running LaTeX"), domain = NA)
  }
  else styfile <- "Sweave"
  options <- list(prefix = TRUE, prefix.string = prefix.string, engine = "R", print = FALSE, eval = TRUE, fig = FALSE, pdf = TRUE, eps = FALSE, png = FALSE, jpeg = FALSE, grdevice = "", width = 6, height = 6, resolution = 300, term = TRUE, echo = TRUE, keep.source = TRUE, results = "verbatim", split = FALSE, strip.white = "true", include = TRUE, pdf.version = grDevices::pdf.options()$version, pdf.encoding = grDevices::pdf.options()$encoding, pdf.compress = grDevices::pdf.options()$compress, expand = TRUE, 
                  concordance = FALSE, figs.only = TRUE)
  options$.defaults <- options
  options[names(dots)] <- dots
  options <- RweaveLatexOptions(options)
  list(output = output, styfile = styfile, havesty = FALSE, haveconcordance = FALSE, debug = debug, quiet = quiet, syntax = syntax, options = options, chunkout = list(), srclines = integer())
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RweaveLatexWritedoc
list(`package:utils` = function (object, chunk) 
{
  linesout <- attr(chunk, "srclines")
  filenumout <- attr(chunk, "srcFilenum")
  if (length(grep("\\usepackage[^\\}]*Sweave.*\\}", chunk))) 
    object$havesty <- TRUE
  if (!object$havesty) {
    begindoc <- "^[[:space:]]*\\\\begin\\{document\\}"
    which <- grep(begindoc, chunk)
    if (length(which)) {
      chunk[which] <- sub(begindoc, paste0("\\\\usepackage{", object$styfile, "}\n\\\\begin{document}"), chunk[which])
      idx <- c(1:which, which, seq.int(from = which + 1, length.out = length(linesout) - which))
      linesout <- linesout[idx]
      filenumout <- filenumout[idx]
      object$havesty <- TRUE
    }
  }
  while (length(pos <- grep(object$syntax$docexpr, chunk))) {
    cmdloc <- regexpr(object$syntax$docexpr, chunk[pos[1]])
    cmd <- substr(chunk[pos[1]], cmdloc, cmdloc + attr(cmdloc, "match.length") - 1)
    cmd <- sub(object$syntax$docexpr, "\\1", cmd)
    if (object$options$eval) {
      val <- tryCatch(as.character(eval(str2expression(cmd), envir = .GlobalEnv)), error = function(e) {
        filenum <- attr(chunk, "srcFilenum")[pos[1]]
        filename <- attr(chunk, "srcFilenames")[filenum]
        location <- paste0(basename(filename), ":", attr(chunk, "srclines")[pos[1]])
        stop("at ", location, ", ", conditionMessage(e), domain = NA, call. = FALSE)
      })
      if (length(val) == 0) 
        val <- ""
    }
    else val <- paste0("\\\\verb#<<", cmd, ">>#")
    chunk[pos[1]] <- sub(object$syntax$docexpr, val, chunk[pos[1]])
  }
  while (length(pos <- grep(object$syntax$docopt, chunk))) {
    opts <- sub(paste0(".*", object$syntax$docopt, ".*"), "\\1", chunk[pos[1]])
    object$options <- SweaveParseOptions(opts, object$options, RweaveLatexOptions)
    if (isTRUE(object$options$concordance) && !object$haveconcordance) {
      savelabel <- object$options$label
      object$options$label <- "concordance"
      prefix <- RweaveChunkPrefix(object$options)
      object$options$label <- savelabel
      object$concordfile <- paste0(prefix, ".tex")
      chunk[pos[1]] <- sub(object$syntax$docopt, paste0("\\\\input{", prefix, "}"), chunk[pos[1]])
      object$haveconcordance <- TRUE
    }
    else chunk[pos[1]] <- sub(object$syntax$docopt, "", chunk[pos[1]])
  }
  cat(chunk, sep = "\n", file = object$output)
  object$linesout <- c(object$linesout, linesout)
  object$filenumout <- c(object$filenumout, filenumout)
  object
}, function (object, chunk) 
{
  linesout <- attr(chunk, "srclines")
  filenumout <- attr(chunk, "srcFilenum")
  if (length(grep("\\usepackage[^\\}]*Sweave.*\\}", chunk))) 
    object$havesty <- TRUE
  if (!object$havesty) {
    begindoc <- "^[[:space:]]*\\\\begin\\{document\\}"
    which <- grep(begindoc, chunk)
    if (length(which)) {
      chunk[which] <- sub(begindoc, paste0("\\\\usepackage{", object$styfile, "}\n\\\\begin{document}"), chunk[which])
      idx <- c(1:which, which, seq.int(from = which + 1, length.out = length(linesout) - which))
      linesout <- linesout[idx]
      filenumout <- filenumout[idx]
      object$havesty <- TRUE
    }
  }
  while (length(pos <- grep(object$syntax$docexpr, chunk))) {
    cmdloc <- regexpr(object$syntax$docexpr, chunk[pos[1]])
    cmd <- substr(chunk[pos[1]], cmdloc, cmdloc + attr(cmdloc, "match.length") - 1)
    cmd <- sub(object$syntax$docexpr, "\\1", cmd)
    if (object$options$eval) {
      val <- tryCatch(as.character(eval(str2expression(cmd), envir = .GlobalEnv)), error = function(e) {
        filenum <- attr(chunk, "srcFilenum")[pos[1]]
        filename <- attr(chunk, "srcFilenames")[filenum]
        location <- paste0(basename(filename), ":", attr(chunk, "srclines")[pos[1]])
        stop("at ", location, ", ", conditionMessage(e), domain = NA, call. = FALSE)
      })
      if (length(val) == 0) 
        val <- ""
    }
    else val <- paste0("\\\\verb#<<", cmd, ">>#")
    chunk[pos[1]] <- sub(object$syntax$docexpr, val, chunk[pos[1]])
  }
  while (length(pos <- grep(object$syntax$docopt, chunk))) {
    opts <- sub(paste0(".*", object$syntax$docopt, ".*"), "\\1", chunk[pos[1]])
    object$options <- SweaveParseOptions(opts, object$options, RweaveLatexOptions)
    if (isTRUE(object$options$concordance) && !object$haveconcordance) {
      savelabel <- object$options$label
      object$options$label <- "concordance"
      prefix <- RweaveChunkPrefix(object$options)
      object$options$label <- savelabel
      object$concordfile <- paste0(prefix, ".tex")
      chunk[pos[1]] <- sub(object$syntax$docopt, paste0("\\\\input{", prefix, "}"), chunk[pos[1]])
      object$haveconcordance <- TRUE
    }
    else chunk[pos[1]] <- sub(object$syntax$docopt, "", chunk[pos[1]])
  }
  cat(chunk, sep = "\n", file = object$output)
  object$linesout <- c(object$linesout, linesout)
  object$filenumout <- c(object$filenumout, filenumout)
  object
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
RweaveTryStop
list(`package:utils` = function (err, options) 
{
  if (inherits(err, "try-error")) {
    cat("\n")
    msg <- paste(" chunk", options$chunknr)
    if (!is.null(options$label)) 
      msg <- paste0(msg, " (label = ", options$label, ")")
    msg <- paste(msg, "\n")
    stop(msg, err, call. = FALSE)
  }
}, function (err, options) 
{
  if (inherits(err, "try-error")) {
    cat("\n")
    msg <- paste(" chunk", options$chunknr)
    if (!is.null(options$label)) 
      msg <- paste0(msg, " (label = ", options$label, ")")
    msg <- paste(msg, "\n")
    stop(msg, err, call. = FALSE)
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
savehistory
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (file = ".Rhistory") 
    invisible(.External2(C_savehistory, file)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
select.list
list(`package:utils` = function (choices, preselect = NULL, multiple = FALSE, title = NULL, graphics = getOption("menu.graphics")) 
{
  if (!interactive()) 
    stop("select.list() cannot be used non-interactively")
  if (!is.null(title) && (!is.character(title) || length(title) != 1)) 
    stop("'title' must be NULL or a length-1 character vector")
  if (isTRUE(graphics)) {
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA") 
      return(.External2(C_selectlist, choices, preselect, multiple, title))
    else if (graphics && capabilities("tcltk") && capabilities("X11") && suppressWarnings(tcltk::.TkUp)) 
      return(tcltk::tk_select.list(choices, preselect, multiple, title))
  }
  if (!multiple) {
    res <- menu(choices, FALSE, title)
    if (res < 1 || res > length(choices)) 
      return("")
    else return(choices[res])
  }
  else {
    nc <- length(choices)
    if (length(title) && nzchar(title[1])) 
      cat(title, "\n", sep = "")
    def <- if (is.null(preselect)) 
      rep.int(FALSE, nc)
    else choices %in% preselect
    op <- paste0(format(seq_len(nc)), ": ", ifelse(def, "+", " "), " ", choices)
    if (nc > 10) {
      fop <- format(op)
      nw <- nchar(fop[1], "w") + 2
      ncol <- getOption("width")%/%nw
      if (ncol > 1) 
        op <- paste0(fop, c(rep.int("  ", ncol - 1), "\n"), collapse = "")
      cat("", op, sep = "\n")
    }
    else cat("", op, "", sep = "\n")
    cat(gettext("Enter one or more numbers separated by spaces and then ENTER, or 0 to cancel\n"))
    repeat {
      res <- tryCatch(scan("", what = 0, quiet = TRUE, nlines = 1), error = identity)
      if (!inherits(res, "error")) 
        break
      cat(gettext("Invalid input, please try again\n"))
    }
    if (any(res == 0)) 
      return(character())
    if (!is.null(preselect)) 
      res <- c(which(def), res)
    res <- unique(res)
    res <- sort(res[1 <= res & res <= nc])
    return(choices[res])
  }
}, function (choices, preselect = NULL, multiple = FALSE, title = NULL, graphics = getOption("menu.graphics")) 
{
  if (!interactive()) 
    stop("select.list() cannot be used non-interactively")
  if (!is.null(title) && (!is.character(title) || length(title) != 1)) 
    stop("'title' must be NULL or a length-1 character vector")
  if (isTRUE(graphics)) {
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA") 
      return(.External2(C_selectlist, choices, preselect, multiple, title))
    else if (graphics && capabilities("tcltk") && capabilities("X11") && suppressWarnings(tcltk::.TkUp)) 
      return(tcltk::tk_select.list(choices, preselect, multiple, title))
  }
  if (!multiple) {
    res <- menu(choices, FALSE, title)
    if (res < 1 || res > length(choices)) 
      return("")
    else return(choices[res])
  }
  else {
    nc <- length(choices)
    if (length(title) && nzchar(title[1])) 
      cat(title, "\n", sep = "")
    def <- if (is.null(preselect)) 
      rep.int(FALSE, nc)
    else choices %in% preselect
    op <- paste0(format(seq_len(nc)), ": ", ifelse(def, "+", " "), " ", choices)
    if (nc > 10) {
      fop <- format(op)
      nw <- nchar(fop[1], "w") + 2
      ncol <- getOption("width")%/%nw
      if (ncol > 1) 
        op <- paste0(fop, c(rep.int("  ", ncol - 1), "\n"), collapse = "")
      cat("", op, sep = "\n")
    }
    else cat("", op, "", sep = "\n")
    cat(gettext("Enter one or more numbers separated by spaces and then ENTER, or 0 to cancel\n"))
    repeat {
      res <- tryCatch(scan("", what = 0, quiet = TRUE, nlines = 1), error = identity)
      if (!inherits(res, "error")) 
        break
      cat(gettext("Invalid input, please try again\n"))
    }
    if (any(res == 0)) 
      return(character())
    if (!is.null(preselect)) 
      res <- c(which(def), res)
    res <- unique(res)
    res <- sort(res[1 <= res & res <= nc])
    return(choices[res])
  }
}, function (.data, ...) 
{
  abort("`select()` doesn't handle lists.")
})
c("package:utils", "namespace:utils", "namespace:dplyr")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
sessionInfo
list(`package:utils` = function (package = NULL) 
{
  z <- list()
  z$R.version <- R.Version()
  z$platform <- z$R.version$platform
  if (nzchar(.Platform$r_arch)) 
    z$platform <- paste(z$platform, .Platform$r_arch, sep = "/")
  z$platform <- paste0(z$platform, " (", 8 * .Machine$sizeof.pointer, "-bit)")
  z$locale <- Sys.getlocale()
  z$running <- osVersion
  z$RNGkind <- RNGkind()
  if (is.null(package)) {
    package <- grep("^package:", search(), value = TRUE)
    keep <- vapply(package, function(x) x == "package:base" || !is.null(attr(as.environment(x), "path")), NA)
    package <- .rmpkg(package[keep])
  }
  pkgDesc <- lapply(package, packageDescription, encoding = NA)
  if (length(package) == 0) 
    stop("no valid packages were specified")
  basePkgs <- sapply(pkgDesc, function(x) !is.null(x$Priority) && x$Priority == "base")
  z$basePkgs <- package[basePkgs]
  if (any(!basePkgs)) {
    z$otherPkgs <- pkgDesc[!basePkgs]
    names(z$otherPkgs) <- package[!basePkgs]
  }
  loadedOnly <- loadedNamespaces()
  loadedOnly <- loadedOnly[!(loadedOnly %in% package)]
  if (length(loadedOnly)) {
    names(loadedOnly) <- loadedOnly
    pkgDesc <- c(pkgDesc, lapply(loadedOnly, packageDescription))
    z$loadedOnly <- pkgDesc[loadedOnly]
  }
  z$matprod <- as.character(options("matprod"))
  es <- extSoftVersion()
  z$BLAS <- as.character(es["BLAS"])
  z$LAPACK <- La_library()
  l10n <- l10n_info()
  if (!is.null(l10n["system.codepage"])) 
    z$system.codepage <- as.character(l10n["system.codepage"])
  if (!is.null(l10n["codepage"])) 
    z$codepage <- as.character(l10n["codepage"])
  class(z) <- "sessionInfo"
  z
}, function (package = NULL) 
{
  z <- list()
  z$R.version <- R.Version()
  z$platform <- z$R.version$platform
  if (nzchar(.Platform$r_arch)) 
    z$platform <- paste(z$platform, .Platform$r_arch, sep = "/")
  z$platform <- paste0(z$platform, " (", 8 * .Machine$sizeof.pointer, "-bit)")
  z$locale <- Sys.getlocale()
  z$running <- osVersion
  z$RNGkind <- RNGkind()
  if (is.null(package)) {
    package <- grep("^package:", search(), value = TRUE)
    keep <- vapply(package, function(x) x == "package:base" || !is.null(attr(as.environment(x), "path")), NA)
    package <- .rmpkg(package[keep])
  }
  pkgDesc <- lapply(package, packageDescription, encoding = NA)
  if (length(package) == 0) 
    stop("no valid packages were specified")
  basePkgs <- sapply(pkgDesc, function(x) !is.null(x$Priority) && x$Priority == "base")
  z$basePkgs <- package[basePkgs]
  if (any(!basePkgs)) {
    z$otherPkgs <- pkgDesc[!basePkgs]
    names(z$otherPkgs) <- package[!basePkgs]
  }
  loadedOnly <- loadedNamespaces()
  loadedOnly <- loadedOnly[!(loadedOnly %in% package)]
  if (length(loadedOnly)) {
    names(loadedOnly) <- loadedOnly
    pkgDesc <- c(pkgDesc, lapply(loadedOnly, packageDescription))
    z$loadedOnly <- pkgDesc[loadedOnly]
  }
  z$matprod <- as.character(options("matprod"))
  es <- extSoftVersion()
  z$BLAS <- as.character(es["BLAS"])
  z$LAPACK <- La_library()
  l10n <- l10n_info()
  if (!is.null(l10n["system.codepage"])) 
    z$system.codepage <- as.character(l10n["system.codepage"])
  if (!is.null(l10n["codepage"])) 
    z$codepage <- as.character(l10n["codepage"])
  class(z) <- "sessionInfo"
  z
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
setBreakpoint
list(`package:utils` = function (srcfile, line, nameonly = TRUE, envir = parent.frame(), lastenv, verbose = TRUE, tracer, print = FALSE, clear = FALSE, ...) 
{
  if (missing(lastenv)) {
    if (missing(envir)) 
      lastenv <- globalenv()
    else lastenv <- emptyenv()
  }
  locations <- findLineNum(srcfile, line, nameonly, envir, lastenv)
  if (verbose) 
    print(locations, steps = !clear)
  breakpoint <- missing(tracer)
  while (length(locations)) {
    what <- locations[[1]]$name
    where <- locations[[1]]$env
    at <- list(locations[[1]]$at)
    signature <- locations[[1]]$signature
    if (breakpoint) {
      filename <- basename(locations[[1]]$filename)
      linenum <- locations[[1]]$line
      tracer <- bquote({
        cat(paste0(.(filename), "#", .(linenum), "\n"))
        browser(skipCalls = 4)
      })
    }
    locations[[1]] <- NULL
    i <- 1
    while (i <= length(locations)) {
      if (what == locations[[i]]$name && identical(where, locations[[i]]$env) && identical(signature, locations[[i]]$signature)) {
        at <- c(at, list(locations[[i]]))
        locations[[i]] <- NULL
      }
      else i <- i + 1
    }
    if (clear) {
      if (is.null(signature)) 
        untrace(what, where = where)
      else untrace(what, signature = signature, where = where)
    }
    else if (is.null(signature)) 
      trace(what, tracer, at = at, where = where, print = print, ...)
    else trace(what, signature = signature, tracer, at = at, where = where, ...)
  }
}, function (srcfile, line, nameonly = TRUE, envir = parent.frame(), lastenv, verbose = TRUE, tracer, print = FALSE, clear = FALSE, ...) 
{
  if (missing(lastenv)) {
    if (missing(envir)) 
      lastenv <- globalenv()
    else lastenv <- emptyenv()
  }
  locations <- findLineNum(srcfile, line, nameonly, envir, lastenv)
  if (verbose) 
    print(locations, steps = !clear)
  breakpoint <- missing(tracer)
  while (length(locations)) {
    what <- locations[[1]]$name
    where <- locations[[1]]$env
    at <- list(locations[[1]]$at)
    signature <- locations[[1]]$signature
    if (breakpoint) {
      filename <- basename(locations[[1]]$filename)
      linenum <- locations[[1]]$line
      tracer <- bquote({
        cat(paste0(.(filename), "#", .(linenum), "\n"))
        browser(skipCalls = 4)
      })
    }
    locations[[1]] <- NULL
    i <- 1
    while (i <= length(locations)) {
      if (what == locations[[i]]$name && identical(where, locations[[i]]$env) && identical(signature, locations[[i]]$signature)) {
        at <- c(at, list(locations[[i]]))
        locations[[i]] <- NULL
      }
      else i <- i + 1
    }
    if (clear) {
      if (is.null(signature)) 
        untrace(what, where = where)
      else untrace(what, signature = signature, where = where)
    }
    else if (is.null(signature)) 
      trace(what, tracer, at = at, where = where, print = print, ...)
    else trace(what, signature = signature, tracer, at = at, where = where, ...)
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
sethash
list(`package:utils` = function (h, key, value) 
  invisible(.External(C_sethash_Ext, h, key, value)), function (h, key, value) 
    invisible(.External(C_sethash_Ext, h, key, value)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
setInternet2
list(`package:utils` = function (use = TRUE) 
  .Defunct(), function (use = TRUE) 
    .Defunct())
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
setRepositories
list(`package:utils` = function (graphics = getOption("menu.graphics"), ind = NULL, addURLs = character()) 
{
  if (is.null(ind) && !interactive()) 
    stop("cannot set repositories non-interactively")
  a <- tools:::.get_repositories()
  pkgType <- getOption("pkgType")
  if (!is.character(pkgType)) 
    stop("invalid options(\"pkgType\"); must be a character string")
  if (pkgType == "both") 
    pkgType <- "source"
  if (pkgType == "binary") 
    pkgType <- .Platform$pkgType
  if (startsWith(pkgType, "mac.binary")) 
    pkgType <- "mac.binary"
  thisType <- a[[pkgType]]
  a <- a[thisType, 1:3]
  repos <- getOption("repos")
  if ("CRAN" %in% row.names(a) && !is.na(CRAN <- repos["CRAN"])) 
    a["CRAN", "URL"] <- CRAN
  a[(a[["URL"]] %in% repos), "default"] <- TRUE
  new <- !(repos %in% a[["URL"]])
  if (any(new)) {
    aa <- names(repos[new])
    if (is.null(aa)) 
      aa <- rep.int("", length(repos[new]))
    aa[aa == ""] <- repos[new][aa == ""]
    newa <- data.frame(menu_name = aa, URL = repos[new], default = TRUE)
    row.names(newa) <- aa
    a <- rbind(a, newa, deparse.level = 0)
  }
  default <- a[["default"]]
  res <- if (length(ind)) 
    as.integer(ind)
  else {
    title <- if (graphics) 
      "Repositories"
    else gettext("--- Please select repositories for use in this session ---\n")
    match(select.list(a[, 1], a[default, 1], multiple = TRUE, title, graphics = graphics), a[, 1])
  }
  if (length(res) || length(addURLs)) {
    repos <- a[["URL"]]
    names(repos) <- row.names(a)
    repos <- c(repos[res], addURLs)
    options(repos = repos)
  }
}, function (graphics = getOption("menu.graphics"), ind = NULL, addURLs = character()) 
{
  if (is.null(ind) && !interactive()) 
    stop("cannot set repositories non-interactively")
  a <- tools:::.get_repositories()
  pkgType <- getOption("pkgType")
  if (!is.character(pkgType)) 
    stop("invalid options(\"pkgType\"); must be a character string")
  if (pkgType == "both") 
    pkgType <- "source"
  if (pkgType == "binary") 
    pkgType <- .Platform$pkgType
  if (startsWith(pkgType, "mac.binary")) 
    pkgType <- "mac.binary"
  thisType <- a[[pkgType]]
  a <- a[thisType, 1:3]
  repos <- getOption("repos")
  if ("CRAN" %in% row.names(a) && !is.na(CRAN <- repos["CRAN"])) 
    a["CRAN", "URL"] <- CRAN
  a[(a[["URL"]] %in% repos), "default"] <- TRUE
  new <- !(repos %in% a[["URL"]])
  if (any(new)) {
    aa <- names(repos[new])
    if (is.null(aa)) 
      aa <- rep.int("", length(repos[new]))
    aa[aa == ""] <- repos[new][aa == ""]
    newa <- data.frame(menu_name = aa, URL = repos[new], default = TRUE)
    row.names(newa) <- aa
    a <- rbind(a, newa, deparse.level = 0)
  }
  default <- a[["default"]]
  res <- if (length(ind)) 
    as.integer(ind)
  else {
    title <- if (graphics) 
      "Repositories"
    else gettext("--- Please select repositories for use in this session ---\n")
    match(select.list(a[, 1], a[default, 1], multiple = TRUE, title, graphics = graphics), a[, 1])
  }
  if (length(res) || length(addURLs)) {
    repos <- a[["URL"]]
    names(repos) <- row.names(a)
    repos <- c(repos[res], addURLs)
    options(repos = repos)
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
setStatusBar
list(`package:utils` = function (text) 
  .Call(C_setStatusBar, text), function (text) 
    .Call(C_setStatusBar, text))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
setTxtProgressBar
list(`package:utils` = function (pb, value, title = NULL, label = NULL) 
{
  if (!inherits(pb, "txtProgressBar")) 
    stop(gettextf("'pb' is not from class %s", dQuote("txtProgressBar")), domain = NA)
  oldval <- pb$getVal()
  pb$up(value)
  invisible(oldval)
}, function (pb, value, title = NULL, label = NULL) 
{
  if (!inherits(pb, "txtProgressBar")) 
    stop(gettextf("'pb' is not from class %s", dQuote("txtProgressBar")), domain = NA)
  oldval <- pb$getVal()
  pb$up(value)
  invisible(oldval)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
setWindowTitle
list(`package:utils` = function (suffix, title = paste(getIdentification(), suffix)) 
  invisible(.Call(C_setWindowTitle, title)), function (suffix, title = paste(getIdentification(), suffix)) 
    invisible(.Call(C_setWindowTitle, title)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
setWinProgressBar
list(`package:utils` = function (pb, value, title = NULL, label = NULL) 
{
  if (!inherits(pb, "winProgressBar")) 
    stop(gettextf("'pb' is not from class %s", dQuote("winProgressBar")), domain = NA)
  if (!is.null(title)) 
    title <- as.character(title)
  if (!is.null(label)) 
    label <- as.character(label)
  invisible(.External2(C_setWinProgressBar, pb$pb, as.double(value), title, label))
}, function (pb, value, title = NULL, label = NULL) 
{
  if (!inherits(pb, "winProgressBar")) 
    stop(gettextf("'pb' is not from class %s", dQuote("winProgressBar")), domain = NA)
  if (!is.null(title)) 
    title <- as.character(title)
  if (!is.null(label)) 
    label <- as.character(label)
  invisible(.External2(C_setWinProgressBar, pb$pb, as.double(value), title, label))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
shortPathName
list(`package:utils` = function (path) 
  .Call(C_shortpath, path), function (path) 
    .Call(C_shortpath, path))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
stack
list(`package:utils` = function (x, ...) 
  UseMethod("stack"), function (x, ...) 
    UseMethod("stack"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
Stangle
list(`package:utils` = function (file, driver = Rtangle(), syntax = getOption("SweaveSyntax"), encoding = "", ...) 
  Sweave(file = file, driver = driver, encoding = encoding, ...), function (file, driver = Rtangle(), syntax = getOption("SweaveSyntax"), encoding = "", ...) 
    Sweave(file = file, driver = driver, encoding = encoding, ...))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
str
list(`package:utils` = function (object, ...) 
  UseMethod("str"), function (object, ...) 
    UseMethod("str"), function (x) 
    {
      as.character(x)
    })
c("package:utils", "namespace:utils", "namespace:webdriver")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
strcapture
list(`package:utils` = function (pattern, x, proto, perl = FALSE, useBytes = FALSE) 
{
  m <- regexec(pattern, x, perl = perl, useBytes = useBytes)
  str <- regmatches(x, m)
  ntokens <- length(proto) + 1
  nomatch <- lengths(str) == 0
  str[nomatch] <- list(rep.int(NA, ntokens))
  if (length(str) > 0 && length(str[[1]]) != ntokens) {
    stop("The number of captures in 'pattern' != 'length(proto)'")
  }
  mat <- matrix(as.character(unlist(str)), ncol = ntokens, byrow = TRUE)[, -1, drop = FALSE]
  conformToProto(mat, proto)
}, function (pattern, x, proto, perl = FALSE, useBytes = FALSE) 
{
  m <- regexec(pattern, x, perl = perl, useBytes = useBytes)
  str <- regmatches(x, m)
  ntokens <- length(proto) + 1
  nomatch <- lengths(str) == 0
  str[nomatch] <- list(rep.int(NA, ntokens))
  if (length(str) > 0 && length(str[[1]]) != ntokens) {
    stop("The number of captures in 'pattern' != 'length(proto)'")
  }
  mat <- matrix(as.character(unlist(str)), ncol = ntokens, byrow = TRUE)[, -1, drop = FALSE]
  conformToProto(mat, proto)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
strOptions
list(`package:utils` = function (strict.width = "no", digits.d = 3, vec.len = 4, list.len = 99, deparse.lines = NULL, drop.deparse.attr = TRUE, formatNum = function(x, ...) format(x, trim = TRUE, drop0trailing = TRUE, ...)) 
  list(strict.width = strict.width, digits.d = digits.d, vec.len = vec.len, list.len = list.len, deparse.lines = deparse.lines, drop.deparse.attr = drop.deparse.attr, formatNum = match.fun(formatNum)), function (strict.width = "no", digits.d = 3, vec.len = 4, list.len = 99, deparse.lines = NULL, drop.deparse.attr = TRUE, formatNum = function(x, ...) format(x, trim = TRUE, drop0trailing = TRUE, ...)) 
    list(strict.width = strict.width, digits.d = digits.d, vec.len = vec.len, list.len = list.len, deparse.lines = deparse.lines, drop.deparse.attr = drop.deparse.attr, formatNum = match.fun(formatNum)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
summaryRprof
list(`package:utils` = function (filename = "Rprof.out", chunksize = 5000, memory = c("none", "both", "tseries", "stats"), lines = c("hide", "show", "both"), index = 2, diff = TRUE, exclude = NULL, basenames = 1) 
{
  con <- file(filename, "rt")
  on.exit(close(con))
  firstline <- readLines(con, n = 1)
  if (!length(firstline)) 
    stop(gettextf("no lines found in %s", sQuote(filename)), domain = NA)
  sample.interval <- as.numeric(strsplit(firstline, "=")[[1]][2])/1e+06
  memory.profiling <- startsWith(firstline, "memory")
  line.profiling <- grepl("line profiling", firstline)
  if (line.profiling) 
    filenames <- character(0)
  memory <- match.arg(memory)
  if (memory != "none" && !memory.profiling) 
    stop("profile does not contain memory information")
  if (memory == "tseries") 
    return(Rprof_memory_summary(con, chunksize = chunksize, label = index, diff = diff, exclude = exclude, sample.interval = sample.interval))
  else if (memory == "stats") 
    return(Rprof_memory_summary(con, chunksize = chunksize, aggregate = index, diff = diff, exclude = exclude, sample.interval = sample.interval))
  lines <- match.arg(lines)
  if (lines != "hide" && !line.profiling) 
    stop("profile does not contain line information")
  fnames <- NULL
  ucounts <- NULL
  fcounts <- NULL
  memcounts <- NULL
  umem <- NULL
  repeat {
    chunk <- readLines(con, n = chunksize)
    if (line.profiling) {
      filenamelines <- grep("^#File [0-9]+: ", chunk)
      if (length(filenamelines)) {
        fnum <- as.integer(sub("^#File ([0-9]+): .*", "\\1", chunk[filenamelines]))
        filenames[fnum] <- sub("^#File [0-9]+: ", "", chunk[filenamelines])
        if (basenames) {
          dirnames <- dirname(filenames[fnum])
          filenames[fnum] <- basename(filenames[fnum])
          for (i in seq_len(basenames - 1)) {
            tail <- basename(dirnames)
            filenames[fnum] <- ifelse(tail == ".", filenames[fnum], paste0(tail, "/", filenames[fnum]))
            parent <- dirname(dirnames)
            dirnames <- ifelse(dirnames == parent, ".", parent)
          }
        }
        chunk <- chunk[-filenamelines]
      }
    }
    if (length(chunk) == 0) 
      break
    if (memory.profiling) {
      memprefix <- attr(regexpr(":[0-9]+:[0-9]+:[0-9]+:[0-9]+:", chunk), "match.length")
      if (memory == "both") {
        memstuff <- substr(chunk, 2, memprefix - 1)
        memcounts <- pmax(apply(vapply(strsplit(memstuff, ":"), as.numeric, numeric(4)), 1, diff), 0)
        if (!is.matrix(memcounts)) 
          memcounts <- matrix(memcounts, nrow = 1)
        memcounts <- c(0, rowSums(cbind(memcounts[, 1:2, drop = FALSE] * 8, memcounts[, 3, drop = FALSE])))
      }
      chunk <- substr(chunk, memprefix + 1, nchar(chunk, "c"))
      if (any((nc <- nchar(chunk, "c")) == 0)) {
        chunk <- chunk[nc > 0]
        memcounts <- memcounts[nc > 0]
      }
      if (!length(chunk)) 
        next
    }
    chunk <- strsplit(chunk, " ")
    if (line.profiling) 
      chunk <- lapply(chunk, function(x) {
        locations <- !startsWith(x, "\"")
        if (lines != "hide") {
          fnum <- sub("#.*", "", x[locations])
          lnum <- sub(".*#", "", x[locations])
          x[locations] <- paste0(filenames[as.integer(fnum)], "#", lnum)
        }
        if (lines != "both") 
          x <- x[switch(lines, hide = !locations, show = locations)]
        if (length(x)) 
          x
        else "<no location>"
      })
    newfirsts <- vapply(chunk, `[[`, "char", 1)
    newuniques <- lapply(chunk, unique)
    ulen <- lengths(newuniques)
    newuniques <- unlist(newuniques)
    new.utable <- table(newuniques)
    new.ftable <- table(factor(newfirsts, levels = names(new.utable)))
    if (memory == "both") 
      new.umem <- rowsum(memcounts[rep.int(seq_along(memcounts), ulen)], newuniques)
    fcounts <- rowsum(c(as.vector(new.ftable), fcounts), c(names(new.ftable), fnames))
    ucounts <- rowsum(c(as.vector(new.utable), ucounts), c(names(new.utable), fnames))
    if (memory == "both") 
      umem <- rowsum(c(new.umem, umem), c(names(new.utable), fnames))
    fnames <- sort(unique(c(fnames, names(new.utable))))
  }
  firstnum <- fcounts * sample.interval
  uniquenum <- ucounts * sample.interval
  index1 <- order(-firstnum, -uniquenum)
  index2 <- order(-uniquenum, -firstnum)
  if (lines == "show") {
    filename <- sub("#.*$", "", fnames)
    linenum <- rep.int(0, length(filename))
    hasline <- filename != fnames
    linenum[hasline] <- as.numeric(sub("^.*#", "", fnames[hasline]))
    index3 <- order(filename, linenum)
  }
  firstpct <- round(100 * firstnum/sum(firstnum), 2)
  uniquepct <- round(100 * uniquenum/sum(firstnum), 2)
  digits <- ifelse(sample.interval < 0.01, 3, 2)
  firstnum <- round(firstnum, digits)
  uniquenum <- round(uniquenum, digits)
  if (memory == "both") 
    memtotal <- round(umem/1048576, 1)
  rval <- data.frame(firstnum, firstpct, uniquenum, uniquepct)
  names(rval) <- c("self.time", "self.pct", "total.time", "total.pct")
  rownames(rval) <- fnames
  if (memory == "both") 
    rval$mem.total <- memtotal
  by.self <- rval[index1, ]
  by.self <- by.self[by.self[, 1] > 0, ]
  by.total <- rval[index2, c(3, 4, if (memory == "both") 5, 1, 2)]
  result <- list(by.self = by.self, by.total = by.total)
  if (lines == "show") 
    result <- c(result, list(by.line = rval[index3, ]))
  c(result, sample.interval = sample.interval, sampling.time = sum(fcounts) * sample.interval)
}, function (filename = "Rprof.out", chunksize = 5000, memory = c("none", "both", "tseries", "stats"), lines = c("hide", "show", "both"), index = 2, diff = TRUE, exclude = NULL, basenames = 1) 
{
  con <- file(filename, "rt")
  on.exit(close(con))
  firstline <- readLines(con, n = 1)
  if (!length(firstline)) 
    stop(gettextf("no lines found in %s", sQuote(filename)), domain = NA)
  sample.interval <- as.numeric(strsplit(firstline, "=")[[1]][2])/1e+06
  memory.profiling <- startsWith(firstline, "memory")
  line.profiling <- grepl("line profiling", firstline)
  if (line.profiling) 
    filenames <- character(0)
  memory <- match.arg(memory)
  if (memory != "none" && !memory.profiling) 
    stop("profile does not contain memory information")
  if (memory == "tseries") 
    return(Rprof_memory_summary(con, chunksize = chunksize, label = index, diff = diff, exclude = exclude, sample.interval = sample.interval))
  else if (memory == "stats") 
    return(Rprof_memory_summary(con, chunksize = chunksize, aggregate = index, diff = diff, exclude = exclude, sample.interval = sample.interval))
  lines <- match.arg(lines)
  if (lines != "hide" && !line.profiling) 
    stop("profile does not contain line information")
  fnames <- NULL
  ucounts <- NULL
  fcounts <- NULL
  memcounts <- NULL
  umem <- NULL
  repeat {
    chunk <- readLines(con, n = chunksize)
    if (line.profiling) {
      filenamelines <- grep("^#File [0-9]+: ", chunk)
      if (length(filenamelines)) {
        fnum <- as.integer(sub("^#File ([0-9]+): .*", "\\1", chunk[filenamelines]))
        filenames[fnum] <- sub("^#File [0-9]+: ", "", chunk[filenamelines])
        if (basenames) {
          dirnames <- dirname(filenames[fnum])
          filenames[fnum] <- basename(filenames[fnum])
          for (i in seq_len(basenames - 1)) {
            tail <- basename(dirnames)
            filenames[fnum] <- ifelse(tail == ".", filenames[fnum], paste0(tail, "/", filenames[fnum]))
            parent <- dirname(dirnames)
            dirnames <- ifelse(dirnames == parent, ".", parent)
          }
        }
        chunk <- chunk[-filenamelines]
      }
    }
    if (length(chunk) == 0) 
      break
    if (memory.profiling) {
      memprefix <- attr(regexpr(":[0-9]+:[0-9]+:[0-9]+:[0-9]+:", chunk), "match.length")
      if (memory == "both") {
        memstuff <- substr(chunk, 2, memprefix - 1)
        memcounts <- pmax(apply(vapply(strsplit(memstuff, ":"), as.numeric, numeric(4)), 1, diff), 0)
        if (!is.matrix(memcounts)) 
          memcounts <- matrix(memcounts, nrow = 1)
        memcounts <- c(0, rowSums(cbind(memcounts[, 1:2, drop = FALSE] * 8, memcounts[, 3, drop = FALSE])))
      }
      chunk <- substr(chunk, memprefix + 1, nchar(chunk, "c"))
      if (any((nc <- nchar(chunk, "c")) == 0)) {
        chunk <- chunk[nc > 0]
        memcounts <- memcounts[nc > 0]
      }
      if (!length(chunk)) 
        next
    }
    chunk <- strsplit(chunk, " ")
    if (line.profiling) 
      chunk <- lapply(chunk, function(x) {
        locations <- !startsWith(x, "\"")
        if (lines != "hide") {
          fnum <- sub("#.*", "", x[locations])
          lnum <- sub(".*#", "", x[locations])
          x[locations] <- paste0(filenames[as.integer(fnum)], "#", lnum)
        }
        if (lines != "both") 
          x <- x[switch(lines, hide = !locations, show = locations)]
        if (length(x)) 
          x
        else "<no location>"
      })
    newfirsts <- vapply(chunk, `[[`, "char", 1)
    newuniques <- lapply(chunk, unique)
    ulen <- lengths(newuniques)
    newuniques <- unlist(newuniques)
    new.utable <- table(newuniques)
    new.ftable <- table(factor(newfirsts, levels = names(new.utable)))
    if (memory == "both") 
      new.umem <- rowsum(memcounts[rep.int(seq_along(memcounts), ulen)], newuniques)
    fcounts <- rowsum(c(as.vector(new.ftable), fcounts), c(names(new.ftable), fnames))
    ucounts <- rowsum(c(as.vector(new.utable), ucounts), c(names(new.utable), fnames))
    if (memory == "both") 
      umem <- rowsum(c(new.umem, umem), c(names(new.utable), fnames))
    fnames <- sort(unique(c(fnames, names(new.utable))))
  }
  firstnum <- fcounts * sample.interval
  uniquenum <- ucounts * sample.interval
  index1 <- order(-firstnum, -uniquenum)
  index2 <- order(-uniquenum, -firstnum)
  if (lines == "show") {
    filename <- sub("#.*$", "", fnames)
    linenum <- rep.int(0, length(filename))
    hasline <- filename != fnames
    linenum[hasline] <- as.numeric(sub("^.*#", "", fnames[hasline]))
    index3 <- order(filename, linenum)
  }
  firstpct <- round(100 * firstnum/sum(firstnum), 2)
  uniquepct <- round(100 * uniquenum/sum(firstnum), 2)
  digits <- ifelse(sample.interval < 0.01, 3, 2)
  firstnum <- round(firstnum, digits)
  uniquenum <- round(uniquenum, digits)
  if (memory == "both") 
    memtotal <- round(umem/1048576, 1)
  rval <- data.frame(firstnum, firstpct, uniquenum, uniquepct)
  names(rval) <- c("self.time", "self.pct", "total.time", "total.pct")
  rownames(rval) <- fnames
  if (memory == "both") 
    rval$mem.total <- memtotal
  by.self <- rval[index1, ]
  by.self <- by.self[by.self[, 1] > 0, ]
  by.total <- rval[index2, c(3, 4, if (memory == "both") 5, 1, 2)]
  result <- list(by.self = by.self, by.total = by.total)
  if (lines == "show") 
    result <- c(result, list(by.line = rval[index3, ]))
  c(result, sample.interval = sample.interval, sampling.time = sum(fcounts) * sample.interval)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
suppressForeignCheck
list(`package:utils` = function (names, package, add = TRUE) 
  registerNames(names, package, ".__suppressForeign__", add), function (names, package, add = TRUE) 
    registerNames(names, package, ".__suppressForeign__", add))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
Sweave
list(`package:utils` = function (file, driver = RweaveLatex(), syntax = getOption("SweaveSyntax"), encoding = "", ...) 
{
  if (is.character(driver)) 
    driver <- get(driver, mode = "function")()
  else if (is.function(driver)) 
    driver <- driver()
  if (is.null(syntax)) 
    syntax <- SweaveGetSyntax(file)
  if (is.character(syntax)) 
    syntax <- get(syntax, mode = "list")
  if (.Platform$OS.type == "windows") 
    file <- chartr("\\", "/", file)
  text <- SweaveReadFile(file, syntax, encoding = encoding)
  attr(file, "encoding") <- encoding <- attr(text, "encoding")
  srcFilenames <- attr(text, "files")
  srcFilenum <- attr(text, "srcFilenum")
  srcLinenum <- attr(text, "srcLinenum")
  drobj <- driver$setup(file = file, syntax = syntax, ...)
  on.exit(driver$finish(drobj, error = TRUE))
  syntax <- attr(text, "syntax")
  if (!is.na(envopts <- Sys.getenv("SWEAVE_OPTIONS", NA))) 
    drobj$options <- SweaveParseOptions(envopts, drobj$options, driver$checkopts)
  drobj$filename <- file
  mode <- "doc"
  chunknr <- 0
  chunk <- NULL
  chunkopts <- NULL
  namedchunks <- list()
  prevfilenum <- 0
  prevlinediff <- 0
  for (linenum in seq_along(text)) {
    line <- text[linenum]
    filenum <- srcFilenum[linenum]
    linediff <- srcLinenum[linenum] - linenum
    if (nzchar(Sys.getenv("R_DEBUG_Sweave"))) {
      cat(sprintf("l.%3d: %30s -'%4s'- ", linenum, substr(line, 1, 30), mode))
      cat(sprintf("%16s\n", system(paste("ls -s", summary(drobj$output)$description), intern = TRUE)))
    }
    if (length(grep(syntax$doc, line))) {
      if (mode == "doc") {
        if (!is.null(chunk)) 
          drobj <- driver$writedoc(drobj, chunk)
      }
      else {
        if (!is.null(chunkopts$label)) 
          namedchunks[[chunkopts$label]] <- chunk
        if (!is.null(chunk)) 
          drobj <- driver$runcode(drobj, chunk, chunkopts)
        mode <- "doc"
      }
      chunk <- NULL
    }
    else if (length(grep(syntax$code, line))) {
      if (mode == "doc") {
        if (!is.null(chunk)) 
          drobj <- driver$writedoc(drobj, chunk)
      }
      else {
        if (!is.null(chunkopts$label)) 
          namedchunks[[chunkopts$label]] <- chunk
        if (!is.null(chunk)) 
          drobj <- driver$runcode(drobj, chunk, chunkopts)
      }
      mode <- "code"
      chunkopts <- sub(syntax$code, "\\1", line)
      chunkopts <- SweaveParseOptions(chunkopts, drobj$options, driver$checkopts)
      file <- srcFilenames[filenum]
      chunk <- paste0("#line ", linenum + linediff + 1, " \"", basename(file), "\"")
      attr(chunk, "srclines") <- linenum + linediff
      attr(chunk, "srcFilenum") <- filenum
      attr(chunk, "srcFilenames") <- srcFilenames
      chunknr <- chunknr + 1
      chunkopts$chunknr <- chunknr
    }
    else {
      if (mode == "code" && length(grep(syntax$coderef, line))) {
        chunkref <- sub(syntax$coderef, "\\1", line)
        if (!(chunkref %in% names(namedchunks))) {
          warning(gettextf("reference to unknown chunk %s", sQuote(chunkref)), call. = TRUE, domain = NA)
          next
        }
        else {
          file <- srcFilenames[filenum]
          line <- c(namedchunks[[chunkref]], paste0("#line ", linenum + linediff + 1, " \"", basename(file), "\""))
        }
      }
      if (mode == "code" && (prevfilenum != filenum || prevlinediff != linediff)) {
        file <- srcFilenames[filenum]
        line <- c(paste0("#line ", linenum + linediff, " \"", basename(file), "\""), line)
      }
      srclines <- c(attr(chunk, "srclines"), rep.int(linenum + linediff, length(line)))
      srcfilenum <- c(attr(chunk, "srcFilenum"), rep.int(filenum, length(line)))
      chunk <- c(chunk, line)
      attr(chunk, "srclines") <- srclines
      attr(chunk, "srcFilenum") <- srcfilenum
      attr(chunk, "srcFilenames") <- srcFilenames
    }
    prevfilenum <- filenum
    prevlinediff <- linediff
  }
  if (!is.null(chunk)) {
    drobj <- if (mode == "doc") 
      driver$writedoc(drobj, chunk)
    else driver$runcode(drobj, chunk, chunkopts)
  }
  on.exit()
  drobj$srcFilenames <- srcFilenames
  driver$finish(drobj)
}, function (file, driver = RweaveLatex(), syntax = getOption("SweaveSyntax"), encoding = "", ...) 
{
  if (is.character(driver)) 
    driver <- get(driver, mode = "function")()
  else if (is.function(driver)) 
    driver <- driver()
  if (is.null(syntax)) 
    syntax <- SweaveGetSyntax(file)
  if (is.character(syntax)) 
    syntax <- get(syntax, mode = "list")
  if (.Platform$OS.type == "windows") 
    file <- chartr("\\", "/", file)
  text <- SweaveReadFile(file, syntax, encoding = encoding)
  attr(file, "encoding") <- encoding <- attr(text, "encoding")
  srcFilenames <- attr(text, "files")
  srcFilenum <- attr(text, "srcFilenum")
  srcLinenum <- attr(text, "srcLinenum")
  drobj <- driver$setup(file = file, syntax = syntax, ...)
  on.exit(driver$finish(drobj, error = TRUE))
  syntax <- attr(text, "syntax")
  if (!is.na(envopts <- Sys.getenv("SWEAVE_OPTIONS", NA))) 
    drobj$options <- SweaveParseOptions(envopts, drobj$options, driver$checkopts)
  drobj$filename <- file
  mode <- "doc"
  chunknr <- 0
  chunk <- NULL
  chunkopts <- NULL
  namedchunks <- list()
  prevfilenum <- 0
  prevlinediff <- 0
  for (linenum in seq_along(text)) {
    line <- text[linenum]
    filenum <- srcFilenum[linenum]
    linediff <- srcLinenum[linenum] - linenum
    if (nzchar(Sys.getenv("R_DEBUG_Sweave"))) {
      cat(sprintf("l.%3d: %30s -'%4s'- ", linenum, substr(line, 1, 30), mode))
      cat(sprintf("%16s\n", system(paste("ls -s", summary(drobj$output)$description), intern = TRUE)))
    }
    if (length(grep(syntax$doc, line))) {
      if (mode == "doc") {
        if (!is.null(chunk)) 
          drobj <- driver$writedoc(drobj, chunk)
      }
      else {
        if (!is.null(chunkopts$label)) 
          namedchunks[[chunkopts$label]] <- chunk
        if (!is.null(chunk)) 
          drobj <- driver$runcode(drobj, chunk, chunkopts)
        mode <- "doc"
      }
      chunk <- NULL
    }
    else if (length(grep(syntax$code, line))) {
      if (mode == "doc") {
        if (!is.null(chunk)) 
          drobj <- driver$writedoc(drobj, chunk)
      }
      else {
        if (!is.null(chunkopts$label)) 
          namedchunks[[chunkopts$label]] <- chunk
        if (!is.null(chunk)) 
          drobj <- driver$runcode(drobj, chunk, chunkopts)
      }
      mode <- "code"
      chunkopts <- sub(syntax$code, "\\1", line)
      chunkopts <- SweaveParseOptions(chunkopts, drobj$options, driver$checkopts)
      file <- srcFilenames[filenum]
      chunk <- paste0("#line ", linenum + linediff + 1, " \"", basename(file), "\"")
      attr(chunk, "srclines") <- linenum + linediff
      attr(chunk, "srcFilenum") <- filenum
      attr(chunk, "srcFilenames") <- srcFilenames
      chunknr <- chunknr + 1
      chunkopts$chunknr <- chunknr
    }
    else {
      if (mode == "code" && length(grep(syntax$coderef, line))) {
        chunkref <- sub(syntax$coderef, "\\1", line)
        if (!(chunkref %in% names(namedchunks))) {
          warning(gettextf("reference to unknown chunk %s", sQuote(chunkref)), call. = TRUE, domain = NA)
          next
        }
        else {
          file <- srcFilenames[filenum]
          line <- c(namedchunks[[chunkref]], paste0("#line ", linenum + linediff + 1, " \"", basename(file), "\""))
        }
      }
      if (mode == "code" && (prevfilenum != filenum || prevlinediff != linediff)) {
        file <- srcFilenames[filenum]
        line <- c(paste0("#line ", linenum + linediff, " \"", basename(file), "\""), line)
      }
      srclines <- c(attr(chunk, "srclines"), rep.int(linenum + linediff, length(line)))
      srcfilenum <- c(attr(chunk, "srcFilenum"), rep.int(filenum, length(line)))
      chunk <- c(chunk, line)
      attr(chunk, "srclines") <- srclines
      attr(chunk, "srcFilenum") <- srcfilenum
      attr(chunk, "srcFilenames") <- srcFilenames
    }
    prevfilenum <- filenum
    prevlinediff <- linediff
  }
  if (!is.null(chunk)) {
    drobj <- if (mode == "doc") 
      driver$writedoc(drobj, chunk)
    else driver$runcode(drobj, chunk, chunkopts)
  }
  on.exit()
  drobj$srcFilenames <- srcFilenames
  driver$finish(drobj)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
SweaveHooks
list(`package:utils` = function (options, run = FALSE, envir = .GlobalEnv) 
{
  if (is.null(SweaveHooks <- getOption("SweaveHooks"))) 
    return(NULL)
  z <- character()
  for (k in names(SweaveHooks)) if (nzchar(k) && is.logical(options[[k]]) && options[[k]]) 
    if (is.function(SweaveHooks[[k]])) {
      z <- c(z, k)
      if (run) 
        eval(SweaveHooks[[k]](), envir = envir)
    }
  z
}, function (options, run = FALSE, envir = .GlobalEnv) 
{
  if (is.null(SweaveHooks <- getOption("SweaveHooks"))) 
    return(NULL)
  z <- character()
  for (k in names(SweaveHooks)) if (nzchar(k) && is.logical(options[[k]]) && options[[k]]) 
    if (is.function(SweaveHooks[[k]])) {
      z <- c(z, k)
      if (run) 
        eval(SweaveHooks[[k]](), envir = envir)
    }
  z
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
SweaveSyntaxLatex
list(`package:utils` = list(doc = "^[[:space:]]*\\\\end\\{Scode\\}", code = "^[[:space:]]*\\\\begin\\{Scode\\}\\{?([^}]*)\\}?.*", coderef = "^[[:space:]]*\\\\Scoderef\\{([^}]*)\\}.*", docopt = "^[[:space:]]*\\\\SweaveOpts\\{([^}]*)\\}", docexpr = "\\\\Sexpr\\{([^}]*)\\}", extension = "\\.[rsRS]tex$", syntaxname = "^[[:space:]]*\\\\SweaveSyntax\\{([^}]*)\\}", input = "^[[:space:]]*\\\\SweaveInput\\{([^}]*)\\}", trans = list(doc = "\\\\end{Scode}", code = "\\\\begin{Scode}{\\1}", coderef = "\\\\Scoderef{\\1}", 
                                                                                                                                                                                                                                                                                                                                                                                                                                           docopt = "\\\\SweaveOpts{\\1}", docexpr = "\\\\Sexpr{\\1}", extension = ".Stex", syntaxname = "\\\\SweaveSyntax{SweaveSyntaxLatex}", input = "\\\\SweaveInput{\\1}")), list(doc = "^[[:space:]]*\\\\end\\{Scode\\}", code = "^[[:space:]]*\\\\begin\\{Scode\\}\\{?([^}]*)\\}?.*", coderef = "^[[:space:]]*\\\\Scoderef\\{([^}]*)\\}.*", docopt = "^[[:space:]]*\\\\SweaveOpts\\{([^}]*)\\}", docexpr = "\\\\Sexpr\\{([^}]*)\\}", extension = "\\.[rsRS]tex$", syntaxname = "^[[:space:]]*\\\\SweaveSyntax\\{([^}]*)\\}", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       input = "^[[:space:]]*\\\\SweaveInput\\{([^}]*)\\}", trans = list(doc = "\\\\end{Scode}", code = "\\\\begin{Scode}{\\1}", coderef = "\\\\Scoderef{\\1}", docopt = "\\\\SweaveOpts{\\1}", docexpr = "\\\\Sexpr{\\1}", extension = ".Stex", syntaxname = "\\\\SweaveSyntax{SweaveSyntaxLatex}", input = "\\\\SweaveInput{\\1}")))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
SweaveSyntaxNoweb
list(`package:utils` = list(doc = "^@", code = "^<<(.*)>>=.*", coderef = "^<<(.*)>>.*", docopt = "^[[:space:]]*\\\\SweaveOpts\\{([^}]*)\\}", docexpr = "\\\\Sexpr\\{([^}]*)\\}", extension = "\\.[rsRS]?nw$", syntaxname = "^[[:space:]]*\\\\SweaveSyntax\\{([^}]*)\\}", input = "^[[:space:]]*\\\\SweaveInput\\{([^}]*)\\}", trans = list(doc = "@", code = "<<\\1>>=", coderef = "<<\\1>>", docopt = "\\\\SweaveOpts{\\1}", docexpr = "\\\\Sexpr{\\1}", extension = ".Snw", syntaxname = "\\\\SweaveSyntax{SweaveSyntaxNoweb}", 
                                                                                                                                                                                                                                                                                                                                           input = "\\\\SweaveInput{\\1}")), list(doc = "^@", code = "^<<(.*)>>=.*", coderef = "^<<(.*)>>.*", docopt = "^[[:space:]]*\\\\SweaveOpts\\{([^}]*)\\}", docexpr = "\\\\Sexpr\\{([^}]*)\\}", extension = "\\.[rsRS]?nw$", syntaxname = "^[[:space:]]*\\\\SweaveSyntax\\{([^}]*)\\}", input = "^[[:space:]]*\\\\SweaveInput\\{([^}]*)\\}", trans = list(doc = "@", code = "<<\\1>>=", coderef = "<<\\1>>", docopt = "\\\\SweaveOpts{\\1}", docexpr = "\\\\Sexpr{\\1}", extension = ".Snw", syntaxname = "\\\\SweaveSyntax{SweaveSyntaxNoweb}", 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 input = "\\\\SweaveInput{\\1}")))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
SweaveSyntConv
list(`package:utils` = function (file, syntax, output = NULL) 
{
  if (is.character(syntax)) 
    syntax <- get(syntax)
  if (!identical(class(syntax), "SweaveSyntax")) 
    stop(gettextf("target syntax not of class %s", dQuote("SweaveSyntax")), domain = NA)
  if (is.null(syntax$trans)) 
    stop("target syntax contains no translation table")
  insynt <- SweaveGetSyntax(file)
  text <- readLines(file)
  if (is.null(output)) 
    output <- sub(insynt$extension, syntax$trans$extension, basename(file))
  TN <- names(syntax$trans)
  for (n in TN) if (n != "extension") 
    text <- gsub(insynt[[n]], syntax$trans[[n]], text)
  cat(text, file = output, sep = "\n")
  cat("Wrote file", output, "\n")
}, function (file, syntax, output = NULL) 
{
  if (is.character(syntax)) 
    syntax <- get(syntax)
  if (!identical(class(syntax), "SweaveSyntax")) 
    stop(gettextf("target syntax not of class %s", dQuote("SweaveSyntax")), domain = NA)
  if (is.null(syntax$trans)) 
    stop("target syntax contains no translation table")
  insynt <- SweaveGetSyntax(file)
  text <- readLines(file)
  if (is.null(output)) 
    output <- sub(insynt$extension, syntax$trans$extension, basename(file))
  TN <- names(syntax$trans)
  for (n in TN) if (n != "extension") 
    text <- gsub(insynt[[n]], syntax$trans[[n]], text)
  cat(text, file = output, sep = "\n")
  cat("Wrote file", output, "\n")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
tail
list(`package:utils` = function (x, ...) 
  UseMethod("tail"), function (x, ...) 
    UseMethod("tail"), new("standardGeneric", .Data = function (x, ...) 
      standardGeneric("tail"), generic = "tail", package = "utils", group = list(), valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", .Data = function (x, ...) 
        UseMethod("tail"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "tail"), skeleton = (new("derivedDefaultMethod", .Data = function (x, ...) 
          UseMethod("tail"), target = new("signature", .Data = "ANY", names = "x", package = "methods"), defined = new("signature", .Data = "ANY", names = "x", package = "methods"), generic = "tail"))(x, ...)))
c("package:utils", "namespace:utils", "namespace:Matrix")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
tail.matrix
list(`package:utils` = function (x, n = 6, keepnums = TRUE, addrownums, ...) 
{
  if (!missing(addrownums)) {
    .Deprecated(msg = gettext("tail(., addrownums = V) is deprecated.\nUse ", "tail(., keepnums = V) instead.\n"))
    if (missing(keepnums)) 
      keepnums <- addrownums
  }
  checkHT(n, d <- dim(x))
  ii <- which(!is.na(n[seq_along(d)]))
  sel <- lapply(ii, function(i) {
    di <- d[i]
    ni <- n[i]
    seq.int(to = di, length.out = if (ni < 0) max(di + ni, 0) else min(ni, di))
  })
  args <- rep(alist(x, , drop = FALSE), c(1, length(d), 1))
  args[1 + ii] <- sel
  ans <- do.call(`[`, args)
  if (keepnums && length(d) > 1) {
    jj <- if (!is.null(adnms <- dimnames(ans)[ii])) 
      which(vapply(adnms, is.null, NA))
    else seq_along(ii)
    if (length(jj) > 0) {
      dimnames(ans)[ii[jj]] <- lapply(jj, function(k) {
        if ((dnum <- ii[k]) == 1) 
          format(sprintf("[%d,]", sel[[k]]), justify = "right")
        else if (dnum == 2) 
          sprintf("[,%d]", sel[[k]])
        else sel[[k]]
      })
    }
  }
  ans
}, function (x, n = 6, keepnums = TRUE, addrownums, ...) 
{
  if (!missing(addrownums)) {
    .Deprecated(msg = gettext("tail(., addrownums = V) is deprecated.\nUse ", "tail(., keepnums = V) instead.\n"))
    if (missing(keepnums)) 
      keepnums <- addrownums
  }
  checkHT(n, d <- dim(x))
  ii <- which(!is.na(n[seq_along(d)]))
  sel <- lapply(ii, function(i) {
    di <- d[i]
    ni <- n[i]
    seq.int(to = di, length.out = if (ni < 0) max(di + ni, 0) else min(ni, di))
  })
  args <- rep(alist(x, , drop = FALSE), c(1, length(d), 1))
  args[1 + ii] <- sel
  ans <- do.call(`[`, args)
  if (keepnums && length(d) > 1) {
    jj <- if (!is.null(adnms <- dimnames(ans)[ii])) 
      which(vapply(adnms, is.null, NA))
    else seq_along(ii)
    if (length(jj) > 0) {
      dimnames(ans)[ii[jj]] <- lapply(jj, function(k) {
        if ((dnum <- ii[k]) == 1) 
          format(sprintf("[%d,]", sel[[k]]), justify = "right")
        else if (dnum == 2) 
          sprintf("[,%d]", sel[[k]])
        else sel[[k]]
      })
    }
  }
  ans
}, function (x, n = 6, keepnums = TRUE, addrownums, ...) 
{
  if (!missing(addrownums)) {
    .Deprecated(msg = gettext("tail(., addrownums = V) is deprecated.\nUse ", "tail(., keepnums = V) instead.\n"))
    if (missing(keepnums)) 
      keepnums <- addrownums
  }
  checkHT(n, d <- dim(x))
  ii <- which(!is.na(n[seq_along(d)]))
  sel <- lapply(ii, function(i) {
    di <- d[i]
    ni <- n[i]
    seq.int(to = di, length.out = if (ni < 0) max(di + ni, 0) else min(ni, di))
  })
  args <- rep(alist(x, , drop = FALSE), c(1, length(d), 1))
  args[1 + ii] <- sel
  ans <- do.call(`[`, args)
  if (keepnums && length(d) > 1) {
    jj <- if (!is.null(adnms <- dimnames(ans)[ii])) 
      which(vapply(adnms, is.null, NA))
    else seq_along(ii)
    if (length(jj) > 0) {
      dimnames(ans)[ii[jj]] <- lapply(jj, function(k) {
        if ((dnum <- ii[k]) == 1) 
          format(sprintf("[%d,]", sel[[k]]), justify = "right")
        else if (dnum == 2) 
          sprintf("[,%d]", sel[[k]])
        else sel[[k]]
      })
    }
  }
  ans
})
c("package:utils", "registered S3 method for tail from namespace utils", "namespace:utils")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
tar
list(`package:utils` = function (tarfile, files = NULL, compression = c("none", "gzip", "bzip2", "xz"), compression_level = 6, tar = Sys.getenv("tar"), extra_flags = "") 
{
  if (is.character(tarfile)) {
    if (nzchar(tar) && tar != "internal") {
      if (is.null(files)) {
        files <- list.files(all.files = TRUE, full.names = TRUE, include.dirs = TRUE)
        files <- setdiff(files, c("./.", "./.."))
      }
      flags <- switch(match.arg(compression), none = "-cf", gzip = "-zcf", bzip2 = "-jcf", xz = "-Jcf")
      if (grepl("darwin", R.version$os)) {
        tar <- paste("COPYFILE_DISABLE=1", tar)
      }
      if (is.null(extra_flags)) 
        extra_flags <- ""
      nc <- nchar(ff <- paste(shQuote(files), collapse = " "))
      if (nc > 1000 && any(grepl("(GNU tar|libarchive)", tryCatch(system(paste(tar, "--version"), intern = TRUE), error = function(e) "")))) {
        tf <- tempfile("Rtar")
        on.exit(unlink(tf))
        writeLines(files, tf)
        cmd <- paste(tar, extra_flags, flags, shQuote(tarfile), "-T", shQuote(tf))
      }
      else {
        cmd <- paste(tar, extra_flags, flags, shQuote(tarfile), ff)
      }
      return(invisible(system(cmd)))
    }
    if (is.null(files)) 
      files <- "."
    isd <- dir.exists(files)
    files <- c(list.files(files[isd], recursive = TRUE, all.files = TRUE, full.names = TRUE, include.dirs = TRUE), files[!isd])
    con <- switch(match.arg(compression), none = file(tarfile, "wb"), gzip = gzfile(tarfile, "wb", compression = compression_level), bzip2 = bzfile(tarfile, "wb", compression = compression_level), xz = xzfile(tarfile, "wb", compression = compression_level))
    on.exit(close(con))
  }
  else if (inherits(tarfile, "connection")) 
    con <- tarfile
  else stop("'tarfile' must be a character string or a connection")
  GNUname <- function(name, link = FALSE) {
    header <- raw(512)
    n1 <- charToRaw("ExtendedName")
    header[seq_along(n1)] <- n1
    header[157] <- charToRaw(ifelse(link, "K", "L"))
    size <- length(name)
    header[125:135] <- charToRaw(sprintf("%011o", as.integer(size)))
    header[149:156] <- charToRaw(" ")
    checksum <- sum(as.integer(header))%%2^24
    header[149:154] <- charToRaw(sprintf("%06o", as.integer(checksum)))
    header[155] <- as.raw(0)
    writeBin(header, con)
    writeBin(name, con)
    ssize <- 512 * ceiling(size/512)
    if (ssize > size) 
      writeBin(raw(ssize - size), con)
  }
  warn1 <- character()
  invalid_uid <- invalid_gid <- FALSE
  for (f in unique(files)) {
    info <- file.info(f)
    if (is.na(info$size)) {
      warning(gettextf("file '%s' not found", f), domain = NA)
      next
    }
    header <- raw(512)
    if (info$isdir && !endsWith(f, "/")) 
      f <- paste0(f, "/")
    name <- charToRaw(f)
    if (length(name) > 100) {
      OK <- TRUE
      if (length(name) > 256) 
        OK <- FALSE
      else {
        m <- length(name)
        s <- max(which(name[1:min(156, m - 1)] == charToRaw("/")))
        if (is.infinite(s) || s + 100 < length(name)) 
          OK <- FALSE
      }
      warning("storing paths of more than 100 bytes is not portable:\n  ", sQuote(f), domain = NA)
      if (OK) {
        prefix <- name[1:(s - 1)]
        name <- name[-(1:s)]
        header[345 + seq_along(prefix)] <- prefix
      }
      else {
        GNUname(name)
        name <- charToRaw("dummy")
        warn1 <- c(warn1, "using GNU extension for long pathname")
      }
    }
    header[seq_along(name)] <- name
    mode <- info$mode
    if (is.null(extra_flags) && grepl("/(configure|cleanup)$", f) && (mode & "111") != as.octmode("111")) {
      warning(gettextf("file '%s' did not have execute permissions: corrected", f), domain = NA, call. = FALSE)
      mode <- mode | "111"
    }
    header[101:107] <- charToRaw(sprintf("%07o", mode))
    uid <- info$uid
    if (!is.null(uid) && !is.na(uid)) {
      if (uid < 0 || uid > 32767) {
        invalid_uid <- TRUE
        uid <- 32767
      }
      header[109:115] <- charToRaw(sprintf("%07o", uid))
    }
    gid <- info$gid
    if (!is.null(gid) && !is.na(gid)) {
      if (gid < 0 || gid > 32767) {
        invalid_gid <- TRUE
        gid <- 32767
      }
      header[117:123] <- charToRaw(sprintf("%07o", gid))
    }
    header[137:147] <- charToRaw(sprintf("%011o", as.integer(info$mtime)))
    if (info$isdir) 
      header[157] <- charToRaw("5")
    else {
      lnk <- Sys.readlink(f)
      if (is.na(lnk)) 
        lnk <- ""
      header[157] <- charToRaw(ifelse(nzchar(lnk), "2", "0"))
      if (nzchar(lnk)) {
        if (nchar(lnk, "b") > 100) {
          GNUname(charToRaw(lnk), TRUE)
          warn1 <- c(warn1, "using GNU extension for long linkname")
          lnk <- "dummy"
        }
        header[157 + seq_len(nchar(lnk))] <- charToRaw(lnk)
        size <- 0
      }
    }
    size <- ifelse(info$isdir, 0, info$size)
    if (size >= 8^11) 
      stop("file size is limited to 8GB")
    header[125:135] <- .Call(C_octsize, size)
    header[258:262] <- charToRaw("ustar")
    header[264:265] <- charToRaw("0")
    s <- info$uname
    if (!is.null(s) && !is.na(s)) {
      ns <- nchar(s, "b")
      header[265 + (1:ns)] <- charToRaw(s)
    }
    s <- info$grname
    if (!is.null(s) && !is.na(s)) {
      ns <- nchar(s, "b")
      header[297 + (1:ns)] <- charToRaw(s)
    }
    header[149:156] <- charToRaw(" ")
    checksum <- sum(as.integer(header))%%2^24
    header[149:154] <- charToRaw(sprintf("%06o", as.integer(checksum)))
    header[155] <- as.raw(0)
    writeBin(header, con)
    if (info$isdir || nzchar(lnk)) 
      next
    inf <- file(f, "rb")
    for (i in seq_len(ceiling(info$size/512))) {
      block <- readBin(inf, "raw", 512)
      writeBin(block, con)
      if ((n <- length(block)) < 512) 
        writeBin(raw(512 - n), con)
    }
    close(inf)
  }
  if (invalid_uid) 
    warning("invalid uid value replaced by that for user 'nobody'", call. = FALSE)
  if (invalid_gid) 
    warning("invalid gid value replaced by that for user 'nobody'", call. = FALSE)
  block <- raw(512)
  writeBin(block, con)
  writeBin(block, con)
  if (length(warn1)) {
    warn1 <- unique(warn1)
    for (w in warn1) warning(w, domain = NA)
  }
  invisible(0)
}, function (tarfile, files = NULL, compression = c("none", "gzip", "bzip2", "xz"), compression_level = 6, tar = Sys.getenv("tar"), extra_flags = "") 
{
  if (is.character(tarfile)) {
    if (nzchar(tar) && tar != "internal") {
      if (is.null(files)) {
        files <- list.files(all.files = TRUE, full.names = TRUE, include.dirs = TRUE)
        files <- setdiff(files, c("./.", "./.."))
      }
      flags <- switch(match.arg(compression), none = "-cf", gzip = "-zcf", bzip2 = "-jcf", xz = "-Jcf")
      if (grepl("darwin", R.version$os)) {
        tar <- paste("COPYFILE_DISABLE=1", tar)
      }
      if (is.null(extra_flags)) 
        extra_flags <- ""
      nc <- nchar(ff <- paste(shQuote(files), collapse = " "))
      if (nc > 1000 && any(grepl("(GNU tar|libarchive)", tryCatch(system(paste(tar, "--version"), intern = TRUE), error = function(e) "")))) {
        tf <- tempfile("Rtar")
        on.exit(unlink(tf))
        writeLines(files, tf)
        cmd <- paste(tar, extra_flags, flags, shQuote(tarfile), "-T", shQuote(tf))
      }
      else {
        cmd <- paste(tar, extra_flags, flags, shQuote(tarfile), ff)
      }
      return(invisible(system(cmd)))
    }
    if (is.null(files)) 
      files <- "."
    isd <- dir.exists(files)
    files <- c(list.files(files[isd], recursive = TRUE, all.files = TRUE, full.names = TRUE, include.dirs = TRUE), files[!isd])
    con <- switch(match.arg(compression), none = file(tarfile, "wb"), gzip = gzfile(tarfile, "wb", compression = compression_level), bzip2 = bzfile(tarfile, "wb", compression = compression_level), xz = xzfile(tarfile, "wb", compression = compression_level))
    on.exit(close(con))
  }
  else if (inherits(tarfile, "connection")) 
    con <- tarfile
  else stop("'tarfile' must be a character string or a connection")
  GNUname <- function(name, link = FALSE) {
    header <- raw(512)
    n1 <- charToRaw("ExtendedName")
    header[seq_along(n1)] <- n1
    header[157] <- charToRaw(ifelse(link, "K", "L"))
    size <- length(name)
    header[125:135] <- charToRaw(sprintf("%011o", as.integer(size)))
    header[149:156] <- charToRaw(" ")
    checksum <- sum(as.integer(header))%%2^24
    header[149:154] <- charToRaw(sprintf("%06o", as.integer(checksum)))
    header[155] <- as.raw(0)
    writeBin(header, con)
    writeBin(name, con)
    ssize <- 512 * ceiling(size/512)
    if (ssize > size) 
      writeBin(raw(ssize - size), con)
  }
  warn1 <- character()
  invalid_uid <- invalid_gid <- FALSE
  for (f in unique(files)) {
    info <- file.info(f)
    if (is.na(info$size)) {
      warning(gettextf("file '%s' not found", f), domain = NA)
      next
    }
    header <- raw(512)
    if (info$isdir && !endsWith(f, "/")) 
      f <- paste0(f, "/")
    name <- charToRaw(f)
    if (length(name) > 100) {
      OK <- TRUE
      if (length(name) > 256) 
        OK <- FALSE
      else {
        m <- length(name)
        s <- max(which(name[1:min(156, m - 1)] == charToRaw("/")))
        if (is.infinite(s) || s + 100 < length(name)) 
          OK <- FALSE
      }
      warning("storing paths of more than 100 bytes is not portable:\n  ", sQuote(f), domain = NA)
      if (OK) {
        prefix <- name[1:(s - 1)]
        name <- name[-(1:s)]
        header[345 + seq_along(prefix)] <- prefix
      }
      else {
        GNUname(name)
        name <- charToRaw("dummy")
        warn1 <- c(warn1, "using GNU extension for long pathname")
      }
    }
    header[seq_along(name)] <- name
    mode <- info$mode
    if (is.null(extra_flags) && grepl("/(configure|cleanup)$", f) && (mode & "111") != as.octmode("111")) {
      warning(gettextf("file '%s' did not have execute permissions: corrected", f), domain = NA, call. = FALSE)
      mode <- mode | "111"
    }
    header[101:107] <- charToRaw(sprintf("%07o", mode))
    uid <- info$uid
    if (!is.null(uid) && !is.na(uid)) {
      if (uid < 0 || uid > 32767) {
        invalid_uid <- TRUE
        uid <- 32767
      }
      header[109:115] <- charToRaw(sprintf("%07o", uid))
    }
    gid <- info$gid
    if (!is.null(gid) && !is.na(gid)) {
      if (gid < 0 || gid > 32767) {
        invalid_gid <- TRUE
        gid <- 32767
      }
      header[117:123] <- charToRaw(sprintf("%07o", gid))
    }
    header[137:147] <- charToRaw(sprintf("%011o", as.integer(info$mtime)))
    if (info$isdir) 
      header[157] <- charToRaw("5")
    else {
      lnk <- Sys.readlink(f)
      if (is.na(lnk)) 
        lnk <- ""
      header[157] <- charToRaw(ifelse(nzchar(lnk), "2", "0"))
      if (nzchar(lnk)) {
        if (nchar(lnk, "b") > 100) {
          GNUname(charToRaw(lnk), TRUE)
          warn1 <- c(warn1, "using GNU extension for long linkname")
          lnk <- "dummy"
        }
        header[157 + seq_len(nchar(lnk))] <- charToRaw(lnk)
        size <- 0
      }
    }
    size <- ifelse(info$isdir, 0, info$size)
    if (size >= 8^11) 
      stop("file size is limited to 8GB")
    header[125:135] <- .Call(C_octsize, size)
    header[258:262] <- charToRaw("ustar")
    header[264:265] <- charToRaw("0")
    s <- info$uname
    if (!is.null(s) && !is.na(s)) {
      ns <- nchar(s, "b")
      header[265 + (1:ns)] <- charToRaw(s)
    }
    s <- info$grname
    if (!is.null(s) && !is.na(s)) {
      ns <- nchar(s, "b")
      header[297 + (1:ns)] <- charToRaw(s)
    }
    header[149:156] <- charToRaw(" ")
    checksum <- sum(as.integer(header))%%2^24
    header[149:154] <- charToRaw(sprintf("%06o", as.integer(checksum)))
    header[155] <- as.raw(0)
    writeBin(header, con)
    if (info$isdir || nzchar(lnk)) 
      next
    inf <- file(f, "rb")
    for (i in seq_len(ceiling(info$size/512))) {
      block <- readBin(inf, "raw", 512)
      writeBin(block, con)
      if ((n <- length(block)) < 512) 
        writeBin(raw(512 - n), con)
    }
    close(inf)
  }
  if (invalid_uid) 
    warning("invalid uid value replaced by that for user 'nobody'", call. = FALSE)
  if (invalid_gid) 
    warning("invalid gid value replaced by that for user 'nobody'", call. = FALSE)
  block <- raw(512)
  writeBin(block, con)
  writeBin(block, con)
  if (length(warn1)) {
    warn1 <- unique(warn1)
    for (w in warn1) warning(w, domain = NA)
  }
  invisible(0)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
timestamp
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (...) 
    .rs.callAs(name, hook, original, ...), function (x = Sys.time()) 
    {
      format(x, "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
    })
c("package:utils", "namespace:utils", "namespace:httr")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
toBibtex
list(`package:utils` = function (object, ...) 
  UseMethod("toBibtex"), function (object, ...) 
    UseMethod("toBibtex"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
toLatex
list(`package:utils` = function (object, ...) 
  UseMethod("toLatex"), function (object, ...) 
    UseMethod("toLatex"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
txtProgressBar
list(`package:utils` = function (min = 0, max = 1, initial = 0, char = "=", width = NA, title, label, style = 1, file = "") 
{
  if (!identical(file, "") && !(inherits(file, "connection") && isOpen(file))) 
    stop("'file' must be \"\" or an open connection object")
  if (!style %in% 1:3) 
    style <- 1
  .val <- initial
  .killed <- FALSE
  .nb <- 0
  .pc <- -1
  nw <- nchar(char, "w")
  if (nw == 0) 
    stop("'char' must have a non-zero width")
  if (is.na(width)) {
    width <- getOption("width")
    if (style == 3) 
      width <- width - 10
    if (nw > 1) 
      width <- trunc(width/nw)
  }
  if (max <= min) 
    stop("must have 'max' > 'min'")
  up1 <- function(value) {
    if (!is.finite(value) || value < min || value > max) 
      return()
    .val <<- value
    nb <- round(width * (value - min)/(max - min))
    if (.nb < nb) {
      cat(strrep(char, nb - .nb), file = file)
      flush.console()
    }
    else if (.nb > nb) {
      cat("\r", strrep(" ", .nb * nw), "\r", strrep(char, nb), sep = "", file = file)
      flush.console()
    }
    .nb <<- nb
  }
  up2 <- function(value) {
    if (!is.finite(value) || value < min || value > max) 
      return()
    .val <<- value
    nb <- round(width * (value - min)/(max - min))
    if (.nb <= nb) {
      cat("\r", strrep(char, nb), sep = "", file = file)
      flush.console()
    }
    else {
      cat("\r", strrep(" ", .nb * nw), "\r", strrep(char, nb), sep = "", file = file)
      flush.console()
    }
    .nb <<- nb
  }
  up3 <- function(value) {
    if (!is.finite(value) || value < min || value > max) 
      return()
    .val <<- value
    nb <- round(width * (value - min)/(max - min))
    pc <- round(100 * (value - min)/(max - min))
    if (nb == .nb && pc == .pc) 
      return()
    cat(paste0("\r  |", strrep(" ", nw * width + 6)), file = file)
    cat(paste(c("\r  |", rep.int(char, nb), rep.int(" ", nw * (width - nb)), sprintf("| %3d%%", pc)), collapse = ""), file = file)
    flush.console()
    .nb <<- nb
    .pc <<- pc
  }
  getVal <- function() .val
  kill <- function() if (!.killed) {
    cat("\n", file = file)
    flush.console()
    .killed <<- TRUE
  }
  up <- switch(style, up1, up2, up3)
  up(initial)
  structure(list(getVal = getVal, up = up, kill = kill), class = "txtProgressBar")
}, function (min = 0, max = 1, initial = 0, char = "=", width = NA, title, label, style = 1, file = "") 
{
  if (!identical(file, "") && !(inherits(file, "connection") && isOpen(file))) 
    stop("'file' must be \"\" or an open connection object")
  if (!style %in% 1:3) 
    style <- 1
  .val <- initial
  .killed <- FALSE
  .nb <- 0
  .pc <- -1
  nw <- nchar(char, "w")
  if (nw == 0) 
    stop("'char' must have a non-zero width")
  if (is.na(width)) {
    width <- getOption("width")
    if (style == 3) 
      width <- width - 10
    if (nw > 1) 
      width <- trunc(width/nw)
  }
  if (max <= min) 
    stop("must have 'max' > 'min'")
  up1 <- function(value) {
    if (!is.finite(value) || value < min || value > max) 
      return()
    .val <<- value
    nb <- round(width * (value - min)/(max - min))
    if (.nb < nb) {
      cat(strrep(char, nb - .nb), file = file)
      flush.console()
    }
    else if (.nb > nb) {
      cat("\r", strrep(" ", .nb * nw), "\r", strrep(char, nb), sep = "", file = file)
      flush.console()
    }
    .nb <<- nb
  }
  up2 <- function(value) {
    if (!is.finite(value) || value < min || value > max) 
      return()
    .val <<- value
    nb <- round(width * (value - min)/(max - min))
    if (.nb <= nb) {
      cat("\r", strrep(char, nb), sep = "", file = file)
      flush.console()
    }
    else {
      cat("\r", strrep(" ", .nb * nw), "\r", strrep(char, nb), sep = "", file = file)
      flush.console()
    }
    .nb <<- nb
  }
  up3 <- function(value) {
    if (!is.finite(value) || value < min || value > max) 
      return()
    .val <<- value
    nb <- round(width * (value - min)/(max - min))
    pc <- round(100 * (value - min)/(max - min))
    if (nb == .nb && pc == .pc) 
      return()
    cat(paste0("\r  |", strrep(" ", nw * width + 6)), file = file)
    cat(paste(c("\r  |", rep.int(char, nb), rep.int(" ", nw * (width - nb)), sprintf("| %3d%%", pc)), collapse = ""), file = file)
    flush.console()
    .nb <<- nb
    .pc <<- pc
  }
  getVal <- function() .val
  kill <- function() if (!.killed) {
    cat("\n", file = file)
    flush.console()
    .killed <<- TRUE
  }
  up <- switch(style, up1, up2, up3)
  up(initial)
  structure(list(getVal = getVal, up = up, kill = kill), class = "txtProgressBar")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
type.convert
list(`package:utils` = function (x, ...) 
  UseMethod("type.convert"), function (x, ...) 
    UseMethod("type.convert"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
typhash
list(`package:utils` = function (h) 
  .External(C_typhash_Ext, h), function (h) 
    .External(C_typhash_Ext, h))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
undebugcall
list(`package:utils` = function (call) 
{
  call <- substitute(call)
  .debugcall(call, undebug)
  invisible(NULL)
}, function (call) 
{
  call <- substitute(call)
  .debugcall(call, undebug)
  invisible(NULL)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
unstack
list(`package:utils` = function (x, ...) 
  UseMethod("unstack"), function (x, ...) 
    UseMethod("unstack"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
untar
list(`package:utils` = function (tarfile, files = NULL, list = FALSE, exdir = ".", compressed = NA, extras = NULL, verbose = FALSE, restore_times = TRUE, support_old_tars = Sys.getenv("R_SUPPORT_OLD_TARS", FALSE), tar = Sys.getenv("TAR")) 
{
  if (inherits(tarfile, "connection") || identical(tar, "internal")) {
    if (!missing(compressed)) 
      warning("argument 'compressed' is ignored for the internal method")
    return(untar2(tarfile, files, list, exdir, restore_times))
  }
  if (!(is.character(tarfile) && length(tarfile) == 1)) 
    stop("invalid 'tarfile' argument")
  tarfile <- path.expand(tarfile)
  support_old_tars <- isTRUE(as.logical(support_old_tars))
  TAR <- tar
  if (!nzchar(TAR) && .Platform$OS.type == "windows" && nzchar(Sys.which("tar.exe"))) 
    TAR <- "tar.exe"
  if (!nzchar(TAR) || TAR == "internal") 
    return(untar2(tarfile, files, list, exdir))
  cflag <- ""
  if (!missing(compressed)) 
    warning("untar(compressed=) is deprecated", call. = FALSE, domain = NA)
  if (is.character(compressed)) {
    cflag <- switch(match.arg(compressed, c("gzip", "bzip2", "xz")), gzip = "z", bzip2 = "j", xz = "J")
  }
  else if (is.logical(compressed)) {
    if (is.na(compressed) && support_old_tars) {
      magic <- readBin(tarfile, "raw", n = 6)
      if (all(magic[1:2] == c(31, 139))) 
        cflag <- "z"
      else if (all(magic[1:2] == c(31, 157))) 
        cflag <- "z"
      else if (rawToChar(magic[1:3]) == "BZh") 
        cflag <- "j"
      else if (all(magic[1:6] == c(253, 55, 122, 88, 90, 0))) 
        cflag <- "J"
    }
    else if (isTRUE(compressed)) 
      cflag <- "z"
  }
  else stop("'compressed' must be logical or character")
  if (support_old_tars) {
    if (cflag == "z") 
      if (nzchar(ZIP <- Sys.getenv("R_GZIPCMD"))) {
        TAR <- paste(ZIP, "-dc", shQuote(tarfile), "|", TAR)
        tarfile <- "-"
        cflag <- ""
      }
    else stop(sprintf("No %s command found", sQuote("gzip")))
    if (cflag == "j") 
      if (nzchar(ZIP <- Sys.getenv("R_BZIPCMD"))) {
        TAR <- paste(ZIP, "-dc", shQuote(tarfile), "|", TAR)
        tarfile <- "-"
        cflag <- ""
      }
    else stop(sprintf("No %s command found", sQuote("bzip2")))
    if (cflag == "J") 
      if (nzchar(Sys.which("xz"))) {
        TAR <- paste("xz -dc", shQuote(tarfile), "|", TAR)
        tarfile <- "-"
        cflag <- ""
      }
    else stop(sprintf("No %s command found", sQuote("xz")))
  }
  if (list) {
    cmd <- paste0(TAR, " -", cflag, "tf ", shQuote(tarfile))
    if (length(extras)) 
      cmd <- paste(cmd, extras, collapse = " ")
    if (verbose) 
      message("untar: using cmd = ", sQuote(cmd), domain = NA)
    system(cmd, intern = TRUE)
  }
  else {
    if (!restore_times) 
      cflag <- paste0(cflag, "m")
    cmd <- paste0(TAR, " -", cflag, "xf ", shQuote(tarfile))
    if (!missing(exdir)) {
      if (!dir.exists(exdir)) {
        if (!dir.create(exdir, showWarnings = TRUE, recursive = TRUE)) 
          stop(gettextf("failed to create directory %s", sQuote(exdir)), domain = NA)
      }
      cmd <- if (.Platform$OS.type == "windows") 
        paste(cmd, "-C", shQuote(gsub("\\", "/", exdir, fixed = TRUE)))
      else paste(cmd, "-C", shQuote(exdir))
    }
    if (length(extras)) 
      cmd <- paste(cmd, extras, collapse = " ")
    if (length(files)) 
      cmd <- paste(cmd, paste(shQuote(files), collapse = " "))
    if (verbose) 
      message("untar: using cmd = ", sQuote(cmd), domain = NA)
    res <- system(cmd)
    if (res) 
      warning(sQuote(cmd), " returned error code ", res, domain = NA)
    invisible(res)
  }
}, function (tarfile, files = NULL, list = FALSE, exdir = ".", compressed = NA, extras = NULL, verbose = FALSE, restore_times = TRUE, support_old_tars = Sys.getenv("R_SUPPORT_OLD_TARS", FALSE), tar = Sys.getenv("TAR")) 
{
  if (inherits(tarfile, "connection") || identical(tar, "internal")) {
    if (!missing(compressed)) 
      warning("argument 'compressed' is ignored for the internal method")
    return(untar2(tarfile, files, list, exdir, restore_times))
  }
  if (!(is.character(tarfile) && length(tarfile) == 1)) 
    stop("invalid 'tarfile' argument")
  tarfile <- path.expand(tarfile)
  support_old_tars <- isTRUE(as.logical(support_old_tars))
  TAR <- tar
  if (!nzchar(TAR) && .Platform$OS.type == "windows" && nzchar(Sys.which("tar.exe"))) 
    TAR <- "tar.exe"
  if (!nzchar(TAR) || TAR == "internal") 
    return(untar2(tarfile, files, list, exdir))
  cflag <- ""
  if (!missing(compressed)) 
    warning("untar(compressed=) is deprecated", call. = FALSE, domain = NA)
  if (is.character(compressed)) {
    cflag <- switch(match.arg(compressed, c("gzip", "bzip2", "xz")), gzip = "z", bzip2 = "j", xz = "J")
  }
  else if (is.logical(compressed)) {
    if (is.na(compressed) && support_old_tars) {
      magic <- readBin(tarfile, "raw", n = 6)
      if (all(magic[1:2] == c(31, 139))) 
        cflag <- "z"
      else if (all(magic[1:2] == c(31, 157))) 
        cflag <- "z"
      else if (rawToChar(magic[1:3]) == "BZh") 
        cflag <- "j"
      else if (all(magic[1:6] == c(253, 55, 122, 88, 90, 0))) 
        cflag <- "J"
    }
    else if (isTRUE(compressed)) 
      cflag <- "z"
  }
  else stop("'compressed' must be logical or character")
  if (support_old_tars) {
    if (cflag == "z") 
      if (nzchar(ZIP <- Sys.getenv("R_GZIPCMD"))) {
        TAR <- paste(ZIP, "-dc", shQuote(tarfile), "|", TAR)
        tarfile <- "-"
        cflag <- ""
      }
    else stop(sprintf("No %s command found", sQuote("gzip")))
    if (cflag == "j") 
      if (nzchar(ZIP <- Sys.getenv("R_BZIPCMD"))) {
        TAR <- paste(ZIP, "-dc", shQuote(tarfile), "|", TAR)
        tarfile <- "-"
        cflag <- ""
      }
    else stop(sprintf("No %s command found", sQuote("bzip2")))
    if (cflag == "J") 
      if (nzchar(Sys.which("xz"))) {
        TAR <- paste("xz -dc", shQuote(tarfile), "|", TAR)
        tarfile <- "-"
        cflag <- ""
      }
    else stop(sprintf("No %s command found", sQuote("xz")))
  }
  if (list) {
    cmd <- paste0(TAR, " -", cflag, "tf ", shQuote(tarfile))
    if (length(extras)) 
      cmd <- paste(cmd, extras, collapse = " ")
    if (verbose) 
      message("untar: using cmd = ", sQuote(cmd), domain = NA)
    system(cmd, intern = TRUE)
  }
  else {
    if (!restore_times) 
      cflag <- paste0(cflag, "m")
    cmd <- paste0(TAR, " -", cflag, "xf ", shQuote(tarfile))
    if (!missing(exdir)) {
      if (!dir.exists(exdir)) {
        if (!dir.create(exdir, showWarnings = TRUE, recursive = TRUE)) 
          stop(gettextf("failed to create directory %s", sQuote(exdir)), domain = NA)
      }
      cmd <- if (.Platform$OS.type == "windows") 
        paste(cmd, "-C", shQuote(gsub("\\", "/", exdir, fixed = TRUE)))
      else paste(cmd, "-C", shQuote(exdir))
    }
    if (length(extras)) 
      cmd <- paste(cmd, extras, collapse = " ")
    if (length(files)) 
      cmd <- paste(cmd, paste(shQuote(files), collapse = " "))
    if (verbose) 
      message("untar: using cmd = ", sQuote(cmd), domain = NA)
    res <- system(cmd)
    if (res) 
      warning(sQuote(cmd), " returned error code ", res, domain = NA)
    invisible(res)
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
unzip
list(`package:utils` = function (zipfile, files = NULL, list = FALSE, overwrite = TRUE, junkpaths = FALSE, exdir = ".", unzip = "internal", setTimes = FALSE) 
{
  if (identical(unzip, "internal")) {
    if (!list && !missing(exdir)) 
      dir.create(exdir, showWarnings = FALSE, recursive = TRUE)
    res <- .External(C_unzip, zipfile, files, exdir, list, overwrite, junkpaths, setTimes)
    if (list) {
      dates <- as.POSIXct(res[[3]], "%Y-%m-%d %H:%M", tz = "UTC")
      data.frame(Name = res[[1]], Length = res[[2]], Date = dates, stringsAsFactors = FALSE)
    }
    else invisible(attr(res, "extracted"))
  }
  else {
    WINDOWS <- .Platform$OS.type == "windows"
    if (!is.character(unzip) || length(unzip) != 1 || !nzchar(unzip)) 
      stop("'unzip' must be a single character string")
    zipfile <- path.expand(zipfile)
    if (list) {
      res <- if (WINDOWS) 
        system2(unzip, c("-ql", shQuote(zipfile)), stdout = TRUE)
      else system2(unzip, c("-ql", shQuote(zipfile)), stdout = TRUE, env = c("TZ=UTC"))
      l <- length(res)
      res2 <- res[-c(2, l - 1, l)]
      res3 <- gsub(" *([^ ]+) +([^ ]+) +([^ ]+) +(.*)", "\\1 \\2 \\3 \"\\4\"", res2)
      con <- textConnection(res3)
      on.exit(close(con))
      z <- read.table(con, header = TRUE, as.is = TRUE)
      dt <- paste(z$Date, z$Time)
      formats <- if (max(nchar(z$Date) > 8)) 
        c("%Y-%m-%d", "%d-%m-%Y", "%m-%d-%Y")
      else c("%m-%d-%y", "%d-%m-%y", "%y-%m-%d")
      slash <- any(grepl("/", z$Date))
      if (slash) 
        formats <- gsub("-", "/", formats, fixed = TRUE)
      formats <- paste(formats, "%H:%M")
      for (f in formats) {
        zz <- as.POSIXct(dt, tz = "UTC", format = f)
        if (all(!is.na(zz))) 
          break
      }
      z[, "Date"] <- zz
      z[c("Name", "Length", "Date")]
    }
    else {
      args <- character()
      if (junkpaths) 
        args <- c(args, "-j")
      if (overwrite) 
        args <- c(args, "-oq", shQuote(zipfile))
      else args <- c(args, "-nq", shQuote(zipfile))
      if (length(files)) 
        args <- c(args, shQuote(files))
      if (exdir != ".") 
        args <- c(args, "-d", shQuote(exdir))
      if (WINDOWS) 
        system2(unzip, args, stdout = NULL, stderr = NULL, invisible = TRUE)
      else system2(unzip, args, stdout = NULL, stderr = NULL)
      invisible(NULL)
    }
  }
}, function (zipfile, files = NULL, list = FALSE, overwrite = TRUE, junkpaths = FALSE, exdir = ".", unzip = "internal", setTimes = FALSE) 
{
  if (identical(unzip, "internal")) {
    if (!list && !missing(exdir)) 
      dir.create(exdir, showWarnings = FALSE, recursive = TRUE)
    res <- .External(C_unzip, zipfile, files, exdir, list, overwrite, junkpaths, setTimes)
    if (list) {
      dates <- as.POSIXct(res[[3]], "%Y-%m-%d %H:%M", tz = "UTC")
      data.frame(Name = res[[1]], Length = res[[2]], Date = dates, stringsAsFactors = FALSE)
    }
    else invisible(attr(res, "extracted"))
  }
  else {
    WINDOWS <- .Platform$OS.type == "windows"
    if (!is.character(unzip) || length(unzip) != 1 || !nzchar(unzip)) 
      stop("'unzip' must be a single character string")
    zipfile <- path.expand(zipfile)
    if (list) {
      res <- if (WINDOWS) 
        system2(unzip, c("-ql", shQuote(zipfile)), stdout = TRUE)
      else system2(unzip, c("-ql", shQuote(zipfile)), stdout = TRUE, env = c("TZ=UTC"))
      l <- length(res)
      res2 <- res[-c(2, l - 1, l)]
      res3 <- gsub(" *([^ ]+) +([^ ]+) +([^ ]+) +(.*)", "\\1 \\2 \\3 \"\\4\"", res2)
      con <- textConnection(res3)
      on.exit(close(con))
      z <- read.table(con, header = TRUE, as.is = TRUE)
      dt <- paste(z$Date, z$Time)
      formats <- if (max(nchar(z$Date) > 8)) 
        c("%Y-%m-%d", "%d-%m-%Y", "%m-%d-%Y")
      else c("%m-%d-%y", "%d-%m-%y", "%y-%m-%d")
      slash <- any(grepl("/", z$Date))
      if (slash) 
        formats <- gsub("-", "/", formats, fixed = TRUE)
      formats <- paste(formats, "%H:%M")
      for (f in formats) {
        zz <- as.POSIXct(dt, tz = "UTC", format = f)
        if (all(!is.na(zz))) 
          break
      }
      z[, "Date"] <- zz
      z[c("Name", "Length", "Date")]
    }
    else {
      args <- character()
      if (junkpaths) 
        args <- c(args, "-j")
      if (overwrite) 
        args <- c(args, "-oq", shQuote(zipfile))
      else args <- c(args, "-nq", shQuote(zipfile))
      if (length(files)) 
        args <- c(args, shQuote(files))
      if (exdir != ".") 
        args <- c(args, "-d", shQuote(exdir))
      if (WINDOWS) 
        system2(unzip, args, stdout = NULL, stderr = NULL, invisible = TRUE)
      else system2(unzip, args, stdout = NULL, stderr = NULL)
      invisible(NULL)
    }
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
update.packages
list(`package:utils` = function (lib.loc = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), method, instlib = NULL, ask = TRUE, available = NULL, oldPkgs = NULL, ..., checkBuilt = FALSE, type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  force(ask)
  text.select <- function(old) {
    update <- NULL
    for (k in seq_len(nrow(old))) {
      cat(old[k, "Package"], ":\n", "Version", old[k, "Installed"], "installed in", old[k, "LibPath"], if (checkBuilt) 
        paste("built under R", old[k, "Built"]), "\n", "Version", old[k, "ReposVer"], "available at", simplifyRepos(old[k, "Repository"], type))
      cat("\n")
      answer <- askYesNo("Update?")
      if (is.na(answer)) {
        cat("cancelled by user\n")
        return(invisible())
      }
      if (isTRUE(answer)) 
        update <- rbind(update, old[k, ])
    }
    update
  }
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (type == "both" && (!missing(contriburl) || !is.null(available))) {
    stop("specifying 'contriburl' or 'available' requires a single type, not type = \"both\"")
  }
  if (is.null(available)) {
    available <- available.packages(contriburl = contriburl, method = method, ...)
    if (missing(repos)) 
      repos <- getOption("repos")
  }
  if (!is.matrix(oldPkgs) && is.character(oldPkgs)) {
    subset <- oldPkgs
    oldPkgs <- NULL
  }
  else subset <- NULL
  if (is.null(oldPkgs)) {
    oldPkgs <- old.packages(lib.loc = lib.loc, contriburl = contriburl, method = method, available = available, checkBuilt = checkBuilt)
    if (missing(repos)) 
      repos <- getOption("repos")
    if (!is.null(oldPkgs)) {
      pkg <- 0
      while (pkg < nrow(oldPkgs)) {
        pkg <- pkg + 1
        if (find.package(oldPkgs[pkg], lib.loc = lib.loc) != find.package(oldPkgs[pkg], lib.loc = oldPkgs[pkg, 2])) {
          warning(sprintf("package '%s' in library '%s' will not be updated", oldPkgs[pkg], oldPkgs[pkg, 2]), call. = FALSE, immediate. = TRUE)
          oldPkgs <- oldPkgs[-pkg, , drop = FALSE]
          pkg <- pkg - 1
        }
      }
    }
    if (is.null(oldPkgs)) 
      return(invisible())
  }
  else if (!(is.matrix(oldPkgs) && is.character(oldPkgs))) 
    stop("invalid 'oldPkgs'; must be a character vector or a result from old.packages()")
  if (!is.null(subset)) {
    oldPkgs <- oldPkgs[rownames(oldPkgs) %in% subset, , drop = FALSE]
    if (nrow(oldPkgs) == 0) 
      return(invisible())
  }
  update <- if (is.character(ask) && ask == "graphics") {
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA" || (capabilities("tcltk") && capabilities("X11"))) {
      k <- select.list(oldPkgs[, 1], oldPkgs[, 1], multiple = TRUE, title = "Packages to be updated", graphics = TRUE)
      oldPkgs[match(k, oldPkgs[, 1]), , drop = FALSE]
    }
    else text.select(oldPkgs)
  }
  else if (isTRUE(ask)) 
    text.select(oldPkgs)
  else oldPkgs
  if (length(update)) {
    if (is.null(instlib)) 
      instlib <- update[, "LibPath"]
    libs <- unique(instlib)
    for (l in libs) if (type == "both") 
      install.packages(update[instlib == l, "Package"], l, repos = repos, method = method, ..., type = type)
    else install.packages(update[instlib == l, "Package"], l, contriburl = contriburl, method = method, available = available, ..., type = type)
  }
}, function (lib.loc = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), method, instlib = NULL, ask = TRUE, available = NULL, oldPkgs = NULL, ..., checkBuilt = FALSE, type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  force(ask)
  text.select <- function(old) {
    update <- NULL
    for (k in seq_len(nrow(old))) {
      cat(old[k, "Package"], ":\n", "Version", old[k, "Installed"], "installed in", old[k, "LibPath"], if (checkBuilt) 
        paste("built under R", old[k, "Built"]), "\n", "Version", old[k, "ReposVer"], "available at", simplifyRepos(old[k, "Repository"], type))
      cat("\n")
      answer <- askYesNo("Update?")
      if (is.na(answer)) {
        cat("cancelled by user\n")
        return(invisible())
      }
      if (isTRUE(answer)) 
        update <- rbind(update, old[k, ])
    }
    update
  }
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (type == "both" && (!missing(contriburl) || !is.null(available))) {
    stop("specifying 'contriburl' or 'available' requires a single type, not type = \"both\"")
  }
  if (is.null(available)) {
    available <- available.packages(contriburl = contriburl, method = method, ...)
    if (missing(repos)) 
      repos <- getOption("repos")
  }
  if (!is.matrix(oldPkgs) && is.character(oldPkgs)) {
    subset <- oldPkgs
    oldPkgs <- NULL
  }
  else subset <- NULL
  if (is.null(oldPkgs)) {
    oldPkgs <- old.packages(lib.loc = lib.loc, contriburl = contriburl, method = method, available = available, checkBuilt = checkBuilt)
    if (missing(repos)) 
      repos <- getOption("repos")
    if (!is.null(oldPkgs)) {
      pkg <- 0
      while (pkg < nrow(oldPkgs)) {
        pkg <- pkg + 1
        if (find.package(oldPkgs[pkg], lib.loc = lib.loc) != find.package(oldPkgs[pkg], lib.loc = oldPkgs[pkg, 2])) {
          warning(sprintf("package '%s' in library '%s' will not be updated", oldPkgs[pkg], oldPkgs[pkg, 2]), call. = FALSE, immediate. = TRUE)
          oldPkgs <- oldPkgs[-pkg, , drop = FALSE]
          pkg <- pkg - 1
        }
      }
    }
    if (is.null(oldPkgs)) 
      return(invisible())
  }
  else if (!(is.matrix(oldPkgs) && is.character(oldPkgs))) 
    stop("invalid 'oldPkgs'; must be a character vector or a result from old.packages()")
  if (!is.null(subset)) {
    oldPkgs <- oldPkgs[rownames(oldPkgs) %in% subset, , drop = FALSE]
    if (nrow(oldPkgs) == 0) 
      return(invisible())
  }
  update <- if (is.character(ask) && ask == "graphics") {
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA" || (capabilities("tcltk") && capabilities("X11"))) {
      k <- select.list(oldPkgs[, 1], oldPkgs[, 1], multiple = TRUE, title = "Packages to be updated", graphics = TRUE)
      oldPkgs[match(k, oldPkgs[, 1]), , drop = FALSE]
    }
    else text.select(oldPkgs)
  }
  else if (isTRUE(ask)) 
    text.select(oldPkgs)
  else oldPkgs
  if (length(update)) {
    if (is.null(instlib)) 
      instlib <- update[, "LibPath"]
    libs <- unique(instlib)
    for (l in libs) if (type == "both") 
      install.packages(update[instlib == l, "Package"], l, repos = repos, method = method, ..., type = type)
    else install.packages(update[instlib == l, "Package"], l, contriburl = contriburl, method = method, available = available, ..., type = type)
  }
}, function (lib.loc = NULL, repos = getOption("repos"), contriburl = contrib.url(repos, type), method, instlib = NULL, ask = TRUE, available = NULL, oldPkgs = NULL, ..., checkBuilt = FALSE, type = getOption("pkgType")) 
{
  if (!is.character(type)) 
    stop("invalid 'type'; must be a character string")
  force(ask)
  text.select <- function(old) {
    update <- NULL
    for (k in seq_len(nrow(old))) {
      cat(old[k, "Package"], ":\n", "Version", old[k, "Installed"], "installed in", old[k, "LibPath"], if (checkBuilt) 
        paste("built under R", old[k, "Built"]), "\n", "Version", old[k, "ReposVer"], "available at", simplifyRepos(old[k, "Repository"], type))
      cat("\n")
      answer <- askYesNo("Update?")
      if (is.na(answer)) {
        cat("cancelled by user\n")
        return(invisible())
      }
      if (isTRUE(answer)) 
        update <- rbind(update, old[k, ])
    }
    update
  }
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  if (type == "both" && (!missing(contriburl) || !is.null(available))) {
    stop("specifying 'contriburl' or 'available' requires a single type, not type = \"both\"")
  }
  if (is.null(available)) {
    available <- available.packages(contriburl = contriburl, method = method, ...)
    if (missing(repos)) 
      repos <- getOption("repos")
  }
  if (!is.matrix(oldPkgs) && is.character(oldPkgs)) {
    subset <- oldPkgs
    oldPkgs <- NULL
  }
  else subset <- NULL
  if (is.null(oldPkgs)) {
    oldPkgs <- old.packages(lib.loc = lib.loc, contriburl = contriburl, method = method, available = available, checkBuilt = checkBuilt)
    if (missing(repos)) 
      repos <- getOption("repos")
    if (!is.null(oldPkgs)) {
      pkg <- 0
      while (pkg < nrow(oldPkgs)) {
        pkg <- pkg + 1
        if (find.package(oldPkgs[pkg], lib.loc = lib.loc) != find.package(oldPkgs[pkg], lib.loc = oldPkgs[pkg, 2])) {
          warning(sprintf("package '%s' in library '%s' will not be updated", oldPkgs[pkg], oldPkgs[pkg, 2]), call. = FALSE, immediate. = TRUE)
          oldPkgs <- oldPkgs[-pkg, , drop = FALSE]
          pkg <- pkg - 1
        }
      }
    }
    if (is.null(oldPkgs)) 
      return(invisible())
  }
  else if (!(is.matrix(oldPkgs) && is.character(oldPkgs))) 
    stop("invalid 'oldPkgs'; must be a character vector or a result from old.packages()")
  if (!is.null(subset)) {
    oldPkgs <- oldPkgs[rownames(oldPkgs) %in% subset, , drop = FALSE]
    if (nrow(oldPkgs) == 0) 
      return(invisible())
  }
  update <- if (is.character(ask) && ask == "graphics") {
    if (.Platform$OS.type == "windows" || .Platform$GUI == "AQUA" || (capabilities("tcltk") && capabilities("X11"))) {
      k <- select.list(oldPkgs[, 1], oldPkgs[, 1], multiple = TRUE, title = "Packages to be updated", graphics = TRUE)
      oldPkgs[match(k, oldPkgs[, 1]), , drop = FALSE]
    }
    else text.select(oldPkgs)
  }
  else if (isTRUE(ask)) 
    text.select(oldPkgs)
  else oldPkgs
  if (length(update)) {
    if (is.null(instlib)) 
      instlib <- update[, "LibPath"]
    libs <- unique(instlib)
    for (l in libs) if (type == "both") 
      install.packages(update[instlib == l, "Package"], l, repos = repos, method = method, ..., type = type)
    else install.packages(update[instlib == l, "Package"], l, contriburl = contriburl, method = method, available = available, ..., type = type)
  }
})
c("package:utils", "registered S3 method for update from namespace utils", "namespace:utils")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, TRUE)
upgrade
list(`package:utils` = function (object, ...) 
  UseMethod("upgrade"), function (object, ...) 
    UseMethod("upgrade"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
url.show
list(`package:utils` = function (url, title = url, file = tempfile(), delete.file = TRUE, method, ...) 
{
  if (download.file(url, destfile = file, method = method, mode = "w")) 
    stop("transfer failure")
  file.show(file, delete.file = delete.file, title = title, ...)
}, function (url, title = url, file = tempfile(), delete.file = TRUE, method, ...) 
{
  if (download.file(url, destfile = file, method = method, mode = "w")) 
    stop("transfer failure")
  file.show(file, delete.file = delete.file, title = title, ...)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
URLdecode
list(`package:utils` = function (URL) 
{
  vapply(URL, function(URL) {
    x <- charToRaw(URL)
    pc <- charToRaw("%")
    out <- raw(0)
    i <- 1
    while (i <= length(x)) {
      if (x[i] != pc) {
        out <- c(out, x[i])
        i <- i + 1
      }
      else {
        y <- as.integer(x[i + 1:2])
        y[y > 96] <- y[y > 96] - 32
        y[y > 57] <- y[y > 57] - 7
        y <- sum((y - 48) * c(16, 1))
        out <- c(out, as.raw(as.character(y)))
        i <- i + 3
      }
    }
    rawToChar(out)
  }, character(1), USE.NAMES = FALSE)
}, function (URL) 
{
  vapply(URL, function(URL) {
    x <- charToRaw(URL)
    pc <- charToRaw("%")
    out <- raw(0)
    i <- 1
    while (i <= length(x)) {
      if (x[i] != pc) {
        out <- c(out, x[i])
        i <- i + 1
      }
      else {
        y <- as.integer(x[i + 1:2])
        y[y > 96] <- y[y > 96] - 32
        y[y > 57] <- y[y > 57] - 7
        y <- sum((y - 48) * c(16, 1))
        out <- c(out, as.raw(as.character(y)))
        i <- i + 3
      }
    }
    rawToChar(out)
  }, character(1), USE.NAMES = FALSE)
}, function (value) 
{
  decodeURIComponent(value)
})
c("package:utils", "namespace:utils", "namespace:shiny")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
URLencode
list(`package:utils` = function (URL, reserved = FALSE, repeated = FALSE) 
{
  vapply(URL, function(URL) {
    if (!repeated && grepl("%[[:xdigit:]]{2}", URL, useBytes = TRUE)) 
      return(URL)
    OK <- paste0("[^", if (!reserved) 
      "][!$&'()*+,;=:/?@#", "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz0123456789._~-", "]")
    x <- strsplit(URL, "")[[1]]
    z <- grep(OK, x)
    if (length(z)) {
      y <- vapply(x[z], function(x) paste0("%", toupper(as.character(charToRaw(x))), collapse = ""), "")
      x[z] <- y
    }
    paste(x, collapse = "")
  }, character(1), USE.NAMES = FALSE)
}, function (URL, reserved = FALSE, repeated = FALSE) 
{
  vapply(URL, function(URL) {
    if (!repeated && grepl("%[[:xdigit:]]{2}", URL, useBytes = TRUE)) 
      return(URL)
    OK <- paste0("[^", if (!reserved) 
      "][!$&'()*+,;=:/?@#", "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz0123456789._~-", "]")
    x <- strsplit(URL, "")[[1]]
    z <- grep(OK, x)
    if (length(z)) {
      y <- vapply(x[z], function(x) paste0("%", toupper(as.character(charToRaw(x))), collapse = ""), "")
      x[z] <- y
    }
    paste(x, collapse = "")
  }, character(1), USE.NAMES = FALSE)
}, function (URL, reserved = FALSE, repeated = FALSE) 
{
  if (!repeated && grepl("%[[:xdigit:]]{2}", URL, useBytes = TRUE)) 
    return(URL)
  OK <- paste0("[^", if (!reserved) 
    "][!$&'()*+,;=:/?@#", "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz0123456789._~-", "]")
  x <- strsplit(URL, "")[[1]]
  z <- grep(OK, x)
  if (length(z)) {
    y <- sapply(x[z], function(x) paste0("%", toupper(as.character(charToRaw(x))), collapse = ""))
    x[z] <- y
  }
  paste(x, collapse = "")
}, function (value, reserved = FALSE) 
{
  value <- enc2utf8(value)
  if (reserved) 
    encodeURIComponent(value)
  else encodeURI(value)
})
c("package:utils", "namespace:utils", "namespace:backports", "namespace:shiny")
c(TRUE, FALSE, FALSE, FALSE)
c(FALSE, TRUE, FALSE, FALSE)
vi
list(`package:utils` = function (name = NULL, file = "") 
  edit.default(name, file, editor = "vi"), function (name = NULL, file = "") 
    edit.default(name, file, editor = "vi"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
View
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (x, title) 
  {
    check <- Sys.getenv("_R_CHECK_SCREEN_DEVICE_", "")
    msg <- "View() should not be used in examples etc"
    if (identical(check, "stop")) 
      stop(msg, domain = NA)
    else if (identical(check, "warn")) 
      warning(msg, immediate. = TRUE, noBreaks. = TRUE, domain = NA)
    if (missing(title)) 
      title <- paste("Data:", deparse(substitute(x))[1])
    x0 <- as.data.frame(x)
    x <- as.list(format.data.frame(x0))
    rn <- row.names(x0)
    if (any(rn != seq_along(rn))) 
      x <- c(list(row.names = rn), x)
    if (!is.list(x) || !length(x) || !all(sapply(x, is.atomic)) || !max(lengths(x))) 
      stop("invalid 'x' argument")
    if (grepl("darwin", R.version$os)) 
      check_for_XQuartz()
    invisible(.External2(C_dataviewer, x, title))
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
vignette
list(`package:utils` = function (topic, package = NULL, lib.loc = NULL, all = TRUE) 
{
  vinfo <- tools::getVignetteInfo(package, lib.loc, all)
  if (!missing(topic)) {
    topic <- topic[1]
    vinfo <- vinfo[vinfo[, "Topic"] == topic, , drop = FALSE]
    if (length(vinfo)) {
      pos <- which(file_test("-f", file.path(vinfo[, "Dir"], "doc", vinfo[, "PDF"])))
      if (!length(pos)) {
        z <- as.list(vinfo[1, ])
        z$PDF <- ""
      }
      else {
        if (length(pos) > 1) {
          pos <- pos[1]
          warning(gettextf("vignette %s found more than once,\nusing the one found in %s", sQuote(topic), sQuote(file.path(vinfo[pos, "Dir"], "doc"))), call. = FALSE, domain = NA)
        }
        z <- as.list(vinfo[pos, ])
      }
      if (!file_test("-f", file.path(z$Dir, "doc", z$R))) 
        z$R <- ""
      class(z) <- "vignette"
      return(z)
    }
    else warning(gettextf("vignette %s not found", sQuote(topic)), call. = FALSE, domain = NA)
  }
  else {
    title <- if (nrow(vinfo)) {
      paste(vinfo[, "Title"], paste0(rep.int("(source", nrow(vinfo)), ifelse(nzchar(vinfo[, "PDF"]), paste0(", ", tools::file_ext(vinfo[, "PDF"])), ""), ")"))
    }
    else character()
    db <- cbind(Package = basename(vinfo[, "Dir"]), LibPath = dirname(vinfo[, "Dir"]), Item = vinfo[, "Topic"], Title = title)
    footer <- if (all) 
      NULL
    else paste0("Use ", sQuote("vignette(all = TRUE)"), "\n", "to list the vignettes in all *available* packages.")
    structure(class = "packageIQR", list(type = "vignette", title = "Vignettes", header = NULL, results = db, footer = footer))
  }
}, function (topic, package = NULL, lib.loc = NULL, all = TRUE) 
{
  vinfo <- tools::getVignetteInfo(package, lib.loc, all)
  if (!missing(topic)) {
    topic <- topic[1]
    vinfo <- vinfo[vinfo[, "Topic"] == topic, , drop = FALSE]
    if (length(vinfo)) {
      pos <- which(file_test("-f", file.path(vinfo[, "Dir"], "doc", vinfo[, "PDF"])))
      if (!length(pos)) {
        z <- as.list(vinfo[1, ])
        z$PDF <- ""
      }
      else {
        if (length(pos) > 1) {
          pos <- pos[1]
          warning(gettextf("vignette %s found more than once,\nusing the one found in %s", sQuote(topic), sQuote(file.path(vinfo[pos, "Dir"], "doc"))), call. = FALSE, domain = NA)
        }
        z <- as.list(vinfo[pos, ])
      }
      if (!file_test("-f", file.path(z$Dir, "doc", z$R))) 
        z$R <- ""
      class(z) <- "vignette"
      return(z)
    }
    else warning(gettextf("vignette %s not found", sQuote(topic)), call. = FALSE, domain = NA)
  }
  else {
    title <- if (nrow(vinfo)) {
      paste(vinfo[, "Title"], paste0(rep.int("(source", nrow(vinfo)), ifelse(nzchar(vinfo[, "PDF"]), paste0(", ", tools::file_ext(vinfo[, "PDF"])), ""), ")"))
    }
    else character()
    db <- cbind(Package = basename(vinfo[, "Dir"]), LibPath = dirname(vinfo[, "Dir"]), Item = vinfo[, "Topic"], Title = title)
    footer <- if (all) 
      NULL
    else paste0("Use ", sQuote("vignette(all = TRUE)"), "\n", "to list the vignettes in all *available* packages.")
    structure(class = "packageIQR", list(type = "vignette", title = "Vignettes", header = NULL, results = db, footer = footer))
  }
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
warnErrList
list(`package:utils` = function (x, warn = TRUE, errValue = NULL) 
{
  errs <- vapply(x, inherits, NA, what = "error")
  if (any(errs)) {
    v.err <- x[errs]
    e.call <- deparse1(conditionCall(v.err[[1]]), collapse = "\n")
    tt <- table(vapply(v.err, conditionMessage, ""))
    msg <- if (length(tt) == 1) 
      sprintf(ngettext(tt[[1]], "%d error caught in %s: %s", "%d times caught the same error in %s: %s"), tt[[1]], e.call, names(tt)[[1]])
    else paste(gettextf("%d errors caught in %s.  The error messages and their frequencies are", sum(tt), e.call), paste(capture.output(sort(tt)), collapse = "\n"), sep = "\n")
    if (warn) 
      warning(msg, call. = FALSE, domain = NA)
    x[errs] <- list(errValue)
    attr(x, "warningMsg") <- msg
  }
  x
}, function (x, warn = TRUE, errValue = NULL) 
{
  errs <- vapply(x, inherits, NA, what = "error")
  if (any(errs)) {
    v.err <- x[errs]
    e.call <- deparse1(conditionCall(v.err[[1]]), collapse = "\n")
    tt <- table(vapply(v.err, conditionMessage, ""))
    msg <- if (length(tt) == 1) 
      sprintf(ngettext(tt[[1]], "%d error caught in %s: %s", "%d times caught the same error in %s: %s"), tt[[1]], e.call, names(tt)[[1]])
    else paste(gettextf("%d errors caught in %s.  The error messages and their frequencies are", sum(tt), e.call), paste(capture.output(sort(tt)), collapse = "\n"), sep = "\n")
    if (warn) 
      warning(msg, call. = FALSE, domain = NA)
    x[errs] <- list(errValue)
    attr(x, "warningMsg") <- msg
  }
  x
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
win.version
list(`package:utils` = function () 
  .Call(C_winver), function () 
    .Call(C_winver))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
winDialog
list(`package:utils` = function (type = c("ok", "okcancel", "yesno", "yesnocancel"), message) 
{
  if (!interactive()) 
    stop("winDialog() cannot be used non-interactively")
  type <- match.arg(type)
  res <- .External2(C_winDialog, type, message)
  if (res == 10) 
    return(invisible(NULL))
  c("NO", "CANCEL", "YES", "OK")[res + 2]
}, function (type = c("ok", "okcancel", "yesno", "yesnocancel"), message) 
{
  if (!interactive()) 
    stop("winDialog() cannot be used non-interactively")
  type <- match.arg(type)
  res <- .External2(C_winDialog, type, message)
  if (res == 10) 
    return(invisible(NULL))
  c("NO", "CANCEL", "YES", "OK")[res + 2]
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
winDialogString
list(`package:utils` = function (message, default) 
{
  if (!interactive()) 
    stop("winDialogString() cannot be used non-interactively")
  .External2(C_winDialogString, message, default)
}, function (message, default) 
{
  if (!interactive()) 
    stop("winDialogString() cannot be used non-interactively")
  .External2(C_winDialogString, message, default)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
winMenuAdd
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (menuname) 
    invisible(.External2(C_winMenuAdd, menuname, NULL, NULL)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
winMenuAddItem
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (menuname, itemname, action) 
  {
    if (!menuname %in% winMenuNames()) 
      winMenuAdd(menuname)
    invisible(.External2(C_winMenuAdd, menuname, itemname, action))
  })
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
winMenuDel
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (menuname) 
    invisible(.External2(C_winMenuDel, menuname, NULL)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
winMenuDelItem
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (menuname, itemname) 
    invisible(.External2(C_winMenuDel, menuname, itemname)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
winMenuItems
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function (menuname) 
    .External2(C_winMenuItems, menuname))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
winMenuNames
list(`package:utils` = function (...) 
  .rs.callAs(name, hook, original, ...), function () 
    .External2(C_winMenuNames))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, FALSE)
winProgressBar
list(`package:utils` = function (title = "R progress bar", label = "", min = 0, max = 1, initial = 0, width = 300) 
{
  res <- .External2(C_winProgressBar, as.integer(width), as.character(title), as.character(label), as.double(min), as.double(max), as.double(initial))
  structure(list(pb = res), class = "winProgressBar")
}, function (title = "R progress bar", label = "", min = 0, max = 1, initial = 0, width = 300) 
{
  res <- .External2(C_winProgressBar, as.integer(width), as.character(title), as.character(label), as.double(min), as.double(max), as.double(initial))
  structure(list(pb = res), class = "winProgressBar")
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
write.csv
list(`package:utils` = function (...) 
{
  Call <- match.call(expand.dots = TRUE)
  for (argname in c("append", "col.names", "sep", "dec", "qmethod")) if (!is.null(Call[[argname]])) 
    warning(gettextf("attempt to set '%s' ignored", argname), domain = NA)
  rn <- eval.parent(Call$row.names)
  Call$append <- NULL
  Call$col.names <- if (is.logical(rn) && !rn) 
    TRUE
  else NA
  Call$sep <- ","
  Call$dec <- "."
  Call$qmethod <- "double"
  Call[[1]] <- quote(utils::write.table)
  eval.parent(Call)
}, function (...) 
{
  Call <- match.call(expand.dots = TRUE)
  for (argname in c("append", "col.names", "sep", "dec", "qmethod")) if (!is.null(Call[[argname]])) 
    warning(gettextf("attempt to set '%s' ignored", argname), domain = NA)
  rn <- eval.parent(Call$row.names)
  Call$append <- NULL
  Call$col.names <- if (is.logical(rn) && !rn) 
    TRUE
  else NA
  Call$sep <- ","
  Call$dec <- "."
  Call$qmethod <- "double"
  Call[[1]] <- quote(utils::write.table)
  eval.parent(Call)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
write.csv2
list(`package:utils` = function (...) 
{
  Call <- match.call(expand.dots = TRUE)
  for (argname in c("append", "col.names", "sep", "dec", "qmethod")) if (!is.null(Call[[argname]])) 
    warning(gettextf("attempt to set '%s' ignored", argname), domain = NA)
  rn <- eval.parent(Call$row.names)
  Call$append <- NULL
  Call$col.names <- if (is.logical(rn) && !rn) 
    TRUE
  else NA
  Call$sep <- ";"
  Call$dec <- ","
  Call$qmethod <- "double"
  Call[[1]] <- quote(utils::write.table)
  eval.parent(Call)
}, function (...) 
{
  Call <- match.call(expand.dots = TRUE)
  for (argname in c("append", "col.names", "sep", "dec", "qmethod")) if (!is.null(Call[[argname]])) 
    warning(gettextf("attempt to set '%s' ignored", argname), domain = NA)
  rn <- eval.parent(Call$row.names)
  Call$append <- NULL
  Call$col.names <- if (is.logical(rn) && !rn) 
    TRUE
  else NA
  Call$sep <- ";"
  Call$dec <- ","
  Call$qmethod <- "double"
  Call[[1]] <- quote(utils::write.table)
  eval.parent(Call)
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
write.socket
list(`package:utils` = function (socket, string) 
  invisible(.Call(C_sockwrite, socket$socket, string)), function (socket, string) 
    invisible(.Call(C_sockwrite, socket$socket, string)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
write.table
list(`package:utils` = function (x, file = "", append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA", dec = ".", row.names = TRUE, col.names = TRUE, qmethod = c("escape", "double"), fileEncoding = "") 
{
  qmethod <- match.arg(qmethod)
  if (is.logical(quote) && (length(quote) != 1 || is.na(quote))) 
    stop("'quote' must be 'TRUE', 'FALSE' or numeric")
  quoteC <- if (is.logical(quote)) 
    quote
  else TRUE
  qset <- is.logical(quote) && quote
  if (!is.data.frame(x) && !is.matrix(x)) 
    x <- data.frame(x)
  makeRownames <- isTRUE(row.names)
  makeColnames <- is.logical(col.names) && !identical(FALSE, col.names)
  if (is.matrix(x)) {
    p <- ncol(x)
    d <- dimnames(x)
    if (is.null(d)) 
      d <- list(NULL, NULL)
    if (is.null(d[[1]]) && makeRownames) 
      d[[1]] <- seq_len(nrow(x))
    if (is.null(d[[2]]) && makeColnames && p > 0) 
      d[[2]] <- paste0("V", 1:p)
    if (qset) 
      quote <- if (is.character(x)) 
        seq_len(p)
    else numeric()
  }
  else {
    if (qset) 
      quote <- if (length(x)) 
        which(unlist(lapply(x, function(x) is.character(x) || is.factor(x))))
    else numeric()
    if (any(vapply(x, function(z) length(dim(z)) == 2 && dim(z)[2] > 1, NA))) {
      c1 <- names(x)
      x <- as.matrix(x, rownames.force = makeRownames)
      d <- dimnames(x)
      if (qset) {
        ord <- match(c1, d[[2]], 0)
        quote <- ord[quote]
        quote <- quote[quote > 0]
      }
    }
    else d <- list(if (makeRownames) row.names(x), if (makeColnames) names(x))
    p <- ncol(x)
  }
  nocols <- p == 0
  if (is.logical(quote)) 
    quote <- NULL
  else if (is.numeric(quote)) {
    if (any(quote < 1 | quote > p)) 
      stop("invalid numbers in 'quote'")
  }
  else stop("invalid 'quote' specification")
  rn <- FALSE
  rnames <- NULL
  if (is.logical(row.names)) {
    if (row.names) {
      rnames <- as.character(d[[1]])
      rn <- TRUE
    }
  }
  else {
    rnames <- as.character(row.names)
    rn <- TRUE
    if (length(rnames) != nrow(x)) 
      stop("invalid 'row.names' specification")
  }
  if (!is.null(quote) && rn) 
    quote <- c(0, quote)
  if (is.logical(col.names)) {
    if (!rn && is.na(col.names)) 
      stop("'col.names = NA' makes no sense when 'row.names = FALSE'")
    col.names <- if (is.na(col.names) && rn) 
      c("", d[[2]])
    else if (col.names) 
      d[[2]]
    else NULL
  }
  else {
    col.names <- as.character(col.names)
    if (length(col.names) != p) 
      stop("invalid 'col.names' specification")
  }
  if (file == "") 
    file <- stdout()
  else if (is.character(file)) {
    file <- if (nzchar(fileEncoding)) 
      file(file, ifelse(append, "a", "w"), encoding = fileEncoding)
    else file(file, ifelse(append, "a", "w"))
    on.exit(close(file))
  }
  else if (!isOpen(file, "w")) {
    open(file, "w")
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  qstring <- switch(qmethod, escape = "\\\"", double = "\"\"")
  if (!is.null(col.names)) {
    if (append) 
      warning("appending column names to file")
    if (quoteC) 
      col.names <- paste0("\"", gsub("\"", qstring, col.names, fixed = TRUE), "\"")
    writeLines(paste(col.names, collapse = sep), file, sep = eol)
  }
  if (nrow(x) == 0) 
    return(invisible())
  if (nocols && !rn) 
    return(cat(rep.int(eol, NROW(x)), file = file, sep = ""))
  if (is.matrix(x) && !is.atomic(x)) 
    mode(x) <- "character"
  if (is.data.frame(x)) {
    x[] <- lapply(x, function(z) {
      if (is.object(z) && !is.factor(z)) 
        as.character(z)
      else z
    })
  }
  invisible(.External2(C_writetable, x, file, nrow(x), p, rnames, sep, eol, na, dec, as.integer(quote), qmethod != "double"))
}, function (x, file = "", append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA", dec = ".", row.names = TRUE, col.names = TRUE, qmethod = c("escape", "double"), fileEncoding = "") 
{
  qmethod <- match.arg(qmethod)
  if (is.logical(quote) && (length(quote) != 1 || is.na(quote))) 
    stop("'quote' must be 'TRUE', 'FALSE' or numeric")
  quoteC <- if (is.logical(quote)) 
    quote
  else TRUE
  qset <- is.logical(quote) && quote
  if (!is.data.frame(x) && !is.matrix(x)) 
    x <- data.frame(x)
  makeRownames <- isTRUE(row.names)
  makeColnames <- is.logical(col.names) && !identical(FALSE, col.names)
  if (is.matrix(x)) {
    p <- ncol(x)
    d <- dimnames(x)
    if (is.null(d)) 
      d <- list(NULL, NULL)
    if (is.null(d[[1]]) && makeRownames) 
      d[[1]] <- seq_len(nrow(x))
    if (is.null(d[[2]]) && makeColnames && p > 0) 
      d[[2]] <- paste0("V", 1:p)
    if (qset) 
      quote <- if (is.character(x)) 
        seq_len(p)
    else numeric()
  }
  else {
    if (qset) 
      quote <- if (length(x)) 
        which(unlist(lapply(x, function(x) is.character(x) || is.factor(x))))
    else numeric()
    if (any(vapply(x, function(z) length(dim(z)) == 2 && dim(z)[2] > 1, NA))) {
      c1 <- names(x)
      x <- as.matrix(x, rownames.force = makeRownames)
      d <- dimnames(x)
      if (qset) {
        ord <- match(c1, d[[2]], 0)
        quote <- ord[quote]
        quote <- quote[quote > 0]
      }
    }
    else d <- list(if (makeRownames) row.names(x), if (makeColnames) names(x))
    p <- ncol(x)
  }
  nocols <- p == 0
  if (is.logical(quote)) 
    quote <- NULL
  else if (is.numeric(quote)) {
    if (any(quote < 1 | quote > p)) 
      stop("invalid numbers in 'quote'")
  }
  else stop("invalid 'quote' specification")
  rn <- FALSE
  rnames <- NULL
  if (is.logical(row.names)) {
    if (row.names) {
      rnames <- as.character(d[[1]])
      rn <- TRUE
    }
  }
  else {
    rnames <- as.character(row.names)
    rn <- TRUE
    if (length(rnames) != nrow(x)) 
      stop("invalid 'row.names' specification")
  }
  if (!is.null(quote) && rn) 
    quote <- c(0, quote)
  if (is.logical(col.names)) {
    if (!rn && is.na(col.names)) 
      stop("'col.names = NA' makes no sense when 'row.names = FALSE'")
    col.names <- if (is.na(col.names) && rn) 
      c("", d[[2]])
    else if (col.names) 
      d[[2]]
    else NULL
  }
  else {
    col.names <- as.character(col.names)
    if (length(col.names) != p) 
      stop("invalid 'col.names' specification")
  }
  if (file == "") 
    file <- stdout()
  else if (is.character(file)) {
    file <- if (nzchar(fileEncoding)) 
      file(file, ifelse(append, "a", "w"), encoding = fileEncoding)
    else file(file, ifelse(append, "a", "w"))
    on.exit(close(file))
  }
  else if (!isOpen(file, "w")) {
    open(file, "w")
    on.exit(close(file))
  }
  if (!inherits(file, "connection")) 
    stop("'file' must be a character string or connection")
  qstring <- switch(qmethod, escape = "\\\"", double = "\"\"")
  if (!is.null(col.names)) {
    if (append) 
      warning("appending column names to file")
    if (quoteC) 
      col.names <- paste0("\"", gsub("\"", qstring, col.names, fixed = TRUE), "\"")
    writeLines(paste(col.names, collapse = sep), file, sep = eol)
  }
  if (nrow(x) == 0) 
    return(invisible())
  if (nocols && !rn) 
    return(cat(rep.int(eol, NROW(x)), file = file, sep = ""))
  if (is.matrix(x) && !is.atomic(x)) 
    mode(x) <- "character"
  if (is.data.frame(x)) {
    x[] <- lapply(x, function(z) {
      if (is.object(z) && !is.factor(z)) 
        as.character(z)
      else z
    })
  }
  invisible(.External2(C_writetable, x, file, nrow(x), p, rnames, sep, eol, na, dec, as.integer(quote), qmethod != "double"))
})
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
writeClipboard
list(`package:utils` = function (str, format = 1) 
  invisible(.Call(C_writeClipboard, str, format)), function (str, format = 1) 
    invisible(.Call(C_writeClipboard, str, format)))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
xedit
list(`package:utils` = function (name = NULL, file = "") 
  edit.default(name, file, editor = "xedit"), function (name = NULL, file = "") 
    edit.default(name, file, editor = "xedit"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
xemacs
list(`package:utils` = function (name = NULL, file = "") 
  edit.default(name, file, editor = "xemacs"), function (name = NULL, file = "") 
    edit.default(name, file, editor = "xemacs"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)
zip
list(`package:utils` = function (zipfile, files, flags = "-r9X", extras = "", zip = Sys.getenv("R_ZIPCMD", "zip")) 
{
  if (missing(flags) && (!is.character(files) || !length(files))) 
    stop("'files' must be a character vector specifying one or more filepaths")
  if (!is.character(zip) || length(zip) != 1 || !nzchar(zip)) 
    stop("argument 'zip' must be a non-empty character string")
  args <- c(flags, shQuote(path.expand(zipfile)), shQuote(files), extras)
  if (sum(nchar(c(args, Sys.getenv()))) + length(args) > 8000) {
    args <- c(flags, "-@", shQuote(path.expand(zipfile)), extras)
    input <- files
  }
  else input <- NULL
  if (.Platform$OS.type == "windows") 
    invisible(system2(zip, args, input = input, invisible = TRUE))
  else invisible(system2(zip, args, input = input))
}, function (zipfile, files, flags = "-r9X", extras = "", zip = Sys.getenv("R_ZIPCMD", "zip")) 
{
  if (missing(flags) && (!is.character(files) || !length(files))) 
    stop("'files' must be a character vector specifying one or more filepaths")
  if (!is.character(zip) || length(zip) != 1 || !nzchar(zip)) 
    stop("argument 'zip' must be a non-empty character string")
  args <- c(flags, shQuote(path.expand(zipfile)), shQuote(files), extras)
  if (sum(nchar(c(args, Sys.getenv()))) + length(args) > 8000) {
    args <- c(flags, "-@", shQuote(path.expand(zipfile)), extras)
    input <- files
  }
  else input <- NULL
  if (.Platform$OS.type == "windows") 
    invisible(system2(zip, args, input = input, invisible = TRUE))
  else invisible(system2(zip, args, input = input))
}, function (name, ...) 
{
  if (utils::zip(name, ...) != 0) 
    stop("Failed to create the zip archive ", name)
  invisible(0)
})
c("package:utils", "namespace:utils", "namespace:xfun")
c(TRUE, FALSE, FALSE)
c(FALSE, TRUE, FALSE)
zip.unpack
list(`package:utils` = function (zipname, dest) 
  .Defunct("unzip"), function (zipname, dest) 
    .Defunct("unzip"))
c("package:utils", "namespace:utils")
c(TRUE, FALSE)
c(FALSE, TRUE)





#####################################################################################################
library(wikifacts)
wiki_define
function (term = NULL, sentences = 5L) 
{
  if (!is.numeric(sentences)) {
    sentences <- 10L
    warning("'sentences' at wiki_define() should be an integer falling back to 10L")
  }
  sentences <- trunc(sentences)
  tryCatch({
    sapply(term, function(x) {
      response <- xml2::read_xml(paste0("https://en.wikipedia.org/w/api.php?action=query&prop=extracts&exsentences=", 
                                        sentences, "&exlimit=1&titles=", utils::URLencode(x), 
                                        "&explaintext=1&format=xml"))
      xml2::xml_text(xml2::xml_find_first(response, "query/pages/page/extract"))
    })
  }, error = function(e) {
    "I got nothin'"
  }, warning = function(w) {
    "I got nothin'"
  })
}
wiki_didyouknow
function (n_facts = 1L, date = sample(seq(as.Date("2015-01-01"), 
                                          Sys.Date() - 1, by = "day"), 1), bare_fact = FALSE) 
{
  locale <- Sys.getlocale("LC_TIME")
  if (.Platform$OS.type == "windows") {
    invisible(Sys.setlocale("LC_TIME", "English"))
  }
  else {
    invisible(Sys.setlocale("LC_TIME", "en_US.UTF-8"))
  }
  date <- as.Date(date)
  date1 <- format(date, "%Y_%B_")
  date2 <- gsub("^0+", "", format(date, "%d"))
  date_str <- paste0(date1, date2)
  invisible(Sys.setlocale("LC_TIME", locale))
  input <- paste0("https://en.wikipedia.org/wiki/Wikipedia:Main_Page_history/", 
                  date_str)
  tryCatch({
    input <- url(input, "rb")
    wiki_page <- xml2::read_html(input, fill = TRUE)
    close(input)
    dyk <- wiki_page %>% rvest::html_nodes(xpath = "//*[@id=\"mp-dyk\"]") %>% 
      rvest::html_nodes("li") %>% rvest::html_text() %>% 
      subset(grepl("... that", .))
    n <- min(n_facts, length(dyk))
    dyk <- dyk[grepl("... that", dyk)] %>% sample(n)
    if (bare_fact == TRUE) {
      dyk
    }
    else {
      paste0("Did you know ", gsub("\\.\\.\\. ", "", dyk), 
             " (Courtesy of Wikipedia)")
    }
  }, error = function(e) {
    "I got nothin'"
  }, warning = function(w) {
    "I got nothin'"
  })
}
wiki_inthenews
function (n_facts = 1L, date = sample(seq(as.Date("2015-01-01"), 
                                          Sys.Date() - 1, by = "day"), 1), bare_fact = FALSE) 
{
  locale <- Sys.getlocale("LC_TIME")
  if (.Platform$OS.type == "windows") {
    invisible(Sys.setlocale("LC_TIME", "English"))
  }
  else {
    invisible(Sys.setlocale("LC_TIME", "en_US.UTF-8"))
  }
  date <- as.Date(date)
  date1 <- format(date, "%Y_%B_")
  date2 <- gsub("^0+", "", format(date, "%d"))
  date_str <- paste0(date1, date2)
  invisible(Sys.setlocale("LC_TIME", locale))
  input <- paste0("https://en.wikipedia.org/wiki/Wikipedia:Main_Page_history/", 
                  date_str)
  tryCatch({
    input <- url(input, "rb")
    wiki_page <- xml2::read_html(input, fill = TRUE)
    close(input)
    itn <- wiki_page %>% rvest::html_nodes(xpath = "//*[@id=\"mp-itn\"]") %>% 
      rvest::html_nodes("li") %>% rvest::html_text() %>% 
      subset(nchar(.) > 40)
    n <- min(n_facts, length(itn))
    itn <- itn %>% sample(n)
    if (bare_fact == TRUE) {
      itn
    }
    else {
      paste0("Here's some news from ", format(date, "%d %B %Y"), 
             ". ", itn, " (Courtesy of Wikipedia)")
    }
  }, error = function(e) {
    "I got nothin'"
  }, warning = function(w) {
    "I got nothin'"
  })
}
wiki_onthisday
function (n_facts = 1L, date = sample(seq(as.Date("2015-01-01"), 
                                          Sys.Date() - 1, by = "day"), 1), bare_fact = FALSE) 
{
  locale <- Sys.getlocale("LC_TIME")
  if (.Platform$OS.type == "windows") {
    invisible(Sys.setlocale("LC_TIME", "English"))
  }
  else {
    invisible(Sys.setlocale("LC_TIME", "en_US.UTF-8"))
  }
  date <- as.Date(date)
  date1 <- format(date, "%Y_%B_")
  date2 <- gsub("^0+", "", format(date, "%d"))
  date_str <- paste0(date1, date2)
  invisible(Sys.setlocale("LC_TIME", locale))
  input <- paste0("https://en.wikipedia.org/wiki/Wikipedia:Main_Page_history/", 
                  date_str)
  tryCatch({
    input <- url(input, "rb")
    wiki_page <- xml2::read_html(input, fill = TRUE)
    close(input)
    otd <- wiki_page %>% rvest::html_nodes(xpath = "//*[@id=\"mp-otd\"]") %>% 
      rvest::html_nodes("li") %>% rvest::html_text() %>% 
      subset(grepl("^\\d{3}", .))
    n <- min(n_facts, length(otd))
    otd <- otd %>% sample(n)
    if (bare_fact == TRUE) {
      otd
    }
    else {
      paste0("Did you know that on ", format(date, "%B"), 
             " ", date2, " in ", otd, " (Courtesy of Wikipedia)")
    }
  }, error = function(e) {
    "I got nothin'"
  }, warning = function(w) {
    "I got nothin'"
  })
}
wiki_query
function (qry) 
{
  if (missing(qry)) {
    stop("No SPARQL query provided.")
  }
  LIMIT <- 2048
  WIKIDATA <- "https://query.wikidata.org/sparql"
  qry <- gsub("[[:blank:]]+", " ", qry)
  qry <- utils::URLencode(qry)
  qry <- gsub("#", "%23", qry)
  if (length(qry) > LIMIT) {
    stop(paste("Too long SPARQL query: maximum is", LIMIT, 
               "characters"))
  }
  spr <- url(description = paste0(WIKIDATA, "?query=", qry), 
             headers = c(Accept = "text/csv; charset=utf-8"))
  response <- tryCatch(utils::read.csv(spr, na.strings = "", 
                                       encoding = "UTF-8"), error = function(e) {
                                         message(paste(e))
                                         close(spr)
                                         return(data.frame())
                                       })
  if (nrow(response) == 0) {
    return(data.frame())
  }
  return(response)
}
wiki_randomfact
function (n_facts = 1L, fact = c("any", "didyouknow", "onthisday", 
                                 "inthenews"), bare_fact = FALSE, repeats = TRUE) 
{
  fact <- match.arg(fact)
  fun1 <- function() {
    wiki_didyouknow(date = sample(seq(as.Date("2015-01-01"), 
                                      Sys.Date() - 1, by = "day"), 1), bare_fact = bare_fact)
  }
  fun2 <- function() {
    wiki_onthisday(date = sample(seq(as.Date("2015-01-01"), 
                                     Sys.Date() - 1, by = "day"), 1), bare_fact = bare_fact)
  }
  fun3 <- function() {
    wiki_inthenews(date = sample(seq(as.Date("2015-01-01"), 
                                     Sys.Date() - 1, by = "day"), 1), bare_fact = bare_fact)
  }
  out <- c()
  for (i in 1:n_facts) {
    s <- switch(fact, any = sample(1:3, 1), didyouknow = 1, 
                onthisday = 2, inthenews = 3)
    out[i] <- eval(parse(text = paste0("fun", s, "()")))
  }
  if (repeats == FALSE) {
    unique(out)
  }
  else {
    out
  }
}
wiki_search
function (term = NULL, browser = getOption("browser")) 
{
  url <- paste0("https://en.wikipedia.org/w/index.php?search=", 
                utils::URLencode(term))
  browseURL(url, browser = browser)
}